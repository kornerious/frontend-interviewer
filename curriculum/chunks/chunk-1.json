[
  {
    "id": "94af5f9b-4c14-49e5-b46c-3298aed31646",
    "startLine": 3400,
    "endLine": 3499,
    "processedDate": "2025-06-17T08:43:59.991Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_class_component_state_basics",
          "title": "React State Management: Class Components Basics and Asynchronous Updates",
          "content": "In React class components, `state` is a plain JavaScript object that holds data influencing the component's rendering. To modify the state, you must use the `this.setState()` method. Direct modification of `this.state` (e.g., `this.state.count = 5;`) will not trigger a re-render and is considered a bad practice, leading to unpredictable behavior.\n\n## Key Concepts\n- **`this.state`**: An object holding the current state of the component.\n- **`this.setState(updater, [callback])`**: The primary method to update component state. It queues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state.\n- **Asynchronous Nature**: `this.setState` calls are often asynchronous and batched for performance reasons. This means you might not see the updated state immediately after calling `setState`.\n- **Batching**: React may batch multiple `setState` calls into a single update for efficiency. This is why if you call `setState` multiple times in the same synchronous event handler, React will only perform one re-render, applying all the changes at once.\n- **Immutability**: When updating state, especially nested objects or arrays, it's crucial to treat `this.state` as immutable. Always create new objects/arrays instead of modifying existing ones directly. This helps prevent side effects and ensures React can correctly detect changes and optimize re-renders.\n\n## Practical Considerations\n- **Accessing Latest State**: Because `setState` is asynchronous, relying on `this.state` immediately after `setState` can lead to errors. For updates that depend on the previous state, use the functional form of `setState` (covered in the next section).\n- **Callback Function**: `this.setState` can optionally take a callback function as its second argument. This callback is executed after the state update has been applied and the component has re-rendered. This is useful for performing side effects that depend on the new state.",
          "examples": [
            {
              "id": "example_class_component_state_basics_1",
              "title": "Basic State Initialization and Update",
              "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  state = {\n    count: 0\n  };\n\n  increment = () => {\n    // Basic update: new state does not depend on old state, or simple increment\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}",
              "explanation": "This example shows the initialization of `count` in `state` and a basic `increment` method. The `this.setState({ count: this.state.count + 1 });` line updates the `count` property. When `increment` is called multiple times in quick succession within the same event loop (e.g., due to React's batching), `this.state.count` might not reflect the very latest value from a preceding `setState` call.",
              "language": "typescript"
            },
            {
              "id": "example_class_component_state_basics_2",
              "title": "Using setState Callback",
              "code": "import React from 'react';\n\nclass DataFetcher extends React.Component {\n  state = {\n    data: null,\n    loading: false\n  };\n\n  fetchData = () => {\n    this.setState({ loading: true }, () => {\n      // This callback runs AFTER loading state is updated and component potentially re-rendered\n      console.log('Loading state updated to true. Now fetching data...');\n      // Simulate API call\n      setTimeout(() => {\n        this.setState({ data: 'Fetched Data!', loading: false });\n      }, 1000);\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.fetchData} disabled={this.state.loading}>\n          {this.state.loading ? 'Loading...' : 'Fetch Data'}\n        </button>\n        {this.state.data && <p>{this.state.data}</p>}\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates using the optional callback function of `setState`. The `console.log` statement inside the callback will execute only after `this.setState({ loading: true })` has completed and the component has potentially re-rendered. This is crucial for operations that depend on the state being fully updated.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_class_component_state_basics_1",
            "question_class_component_state_basics_2",
            "question_class_component_state_basics_3",
            "question_class_component_state_basics_4"
          ],
          "relatedTasks": [
            "task_class_component_counter",
            "task_class_component_form"
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "setState",
            "Asynchronous",
            "Batching"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_basics",
            "react_components_intro"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_lifecycle_methods",
            "react_performance_optimization"
          ]
        },
        {
          "id": "theory_class_component_functional_and_complex_updates",
          "title": "React State Management: Class Components - Functional Updates & Complex State",
          "content": "When the new state depends on the previous state, or when performing multiple state updates in quick succession, using the functional form of `this.setState` is critical. This form takes a function as its first argument, which receives the `prevState` and `props` as arguments, ensuring you are working with the most up-to-date state.\n\n## Functional Updates\n- **`this.setState(updaterFunction, [callback])`**: The `updaterFunction` signature is `(prevState, props) => newState`. React guarantees that `prevState` reflects the state at the time the update is applied, avoiding issues with asynchronous updates and batching.\n- **Guaranteed Consistency**: This form is essential for reliable increments/decrements or toggles where multiple updates might queue up.\n\n## Complex State Updates (Immutability)\nWhen dealing with nested state objects or arrays, directly modifying them will not trigger a re-render, as React performs a shallow comparison of state changes. To correctly update nested state, you must create new objects/arrays at each level where a change occurs, using techniques like the spread operator (`...`). This ensures immutability and proper change detection.\n\n## Key Principles for Complex State Updates:\n1.  **Shallow Copy for Top-Level**: Use the spread operator (`...`) to create a shallow copy of the object containing the nested state you want to update.\n2.  **Deep Copy for Nested Changes**: For each nested level that changes, also create a new object/array, copying over unchanged properties and updating the specific ones.\n3.  **No Direct Mutation**: Never mutate `this.state` directly, nor its nested objects or arrays. Always return a new object from your `setState` updater function.",
          "examples": [
            {
              "id": "example_class_component_functional_update_1",
              "title": "Functional Update for Safe Increment",
              "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  incrementSafely = () => {\n    // Functional update: prevState ensures we always use the latest count value\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  // Batch multiple state updates\n  resetAndIncrement = () => {\n    // Even though both are setState, React might batch them. Using functional update\n    // for the second call ensures it operates on the state after the first update.\n    this.setState({ count: 0 }); // This might be batched with the next update\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.incrementSafely}>Increment Safely</button>\n        <button onClick={this.resetAndIncrement}>Reset and Increment</button>\n      </div>\n    );\n  }\n}",
              "explanation": "The `incrementSafely` method uses the functional form of `setState`. This is crucial when multiple `setState` calls might occur in quick succession (e.g., inside a loop or batched by React), ensuring each update operates on the most current state. The `resetAndIncrement` example shows how multiple `setState` calls are batched, and the functional update ensures the second `setState` operates on the value after the first one has been processed, even if batched.",
              "language": "typescript"
            },
            {
              "id": "example_class_component_complex_update_1",
              "title": "Updating Nested State in Class Components",
              "code": "import React from 'react';\n\nclass UserForm extends React.Component {\n  state = {\n    user: {\n      name: '',\n      email: '',\n      preferences: {\n        newsletter: false,\n        notifications: true\n      }\n    }\n  };\n\n  handleNameChange = (event) => {\n    // Correctly updating a top-level nested property (name)\n    this.setState({\n      user: {\n        ...this.state.user, // Copy existing user properties\n        name: event.target.value // Update 'name'\n      }\n    });\n  };\n\n  toggleNewsletter = () => {\n    // Correctly updating a deeply nested property (newsletter) using functional update\n    this.setState(prevState => ({\n      user: {\n        ...prevState.user, // Copy existing user properties\n        preferences: {\n          ...prevState.user.preferences, // Copy existing preferences properties\n          newsletter: !prevState.user.preferences.newsletter // Toggle 'newsletter'\n        }\n      }\n    }));\n  };\n\n  render() {\n    const { user } = this.state;\n    return (\n      <div>\n        <label>Name:</label>\n        <input type=\"text\" value={user.name} onChange={this.handleNameChange} />\n        <p>Newsletter: {user.preferences.newsletter ? 'Yes' : 'No'}</p>\n        <button onClick={this.toggleNewsletter}>Toggle Newsletter</button>\n      </div>\n    );\n  }\n}",
              "explanation": "The `handleNameChange` method demonstrates updating a property within a nested object (`user.name`). It uses the spread operator (`...this.state.user`) to create a new `user` object, ensuring immutability. The `toggleNewsletter` method shows an even deeper nested update (`user.preferences.newsletter`). It uses the functional `setState` form to access `prevState`, and then applies spreading at each level (`...prevState.user` and `...prevState.user.preferences`) to immutably update the specific nested property.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_class_component_functional_and_complex_updates_1",
            "question_class_component_functional_and_complex_updates_2",
            "question_class_component_functional_and_complex_updates_3",
            "question_class_component_functional_and_complex_updates_4"
          ],
          "relatedTasks": [
            "task_class_component_form",
            "task_class_component_nested_list"
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "Functional setState",
            "Immutability",
            "Nested State",
            "Spread Operator"
          ],
          "technology": "React",
          "prerequisites": [
            "theory_class_component_state_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_context_api",
            "react_redux_integration"
          ]
        },
        {
          "id": "theory_functional_component_state_useState",
          "title": "React State Management: Functional Components with useState Hook",
          "content": "In functional components, React Hooks provide a way to add state and other React features without writing a class. The `useState` hook is the fundamental hook for managing state.\n\n## Key Concepts\n- **`useState(initialState)`**: This hook declares a state variable. It returns an array with two elements: the current state value and a function that lets you update it.\n  - `initialState`: The value the state should have on the first render. It can be a primitive value (number, string, boolean) or an object/array. If `initialState` is a function, `useState` will execute it once during the initial render to get the initial state value. This is useful for expensive initializations.\n- **`[stateVariable, setStateFunction]`**: The common pattern is to use array destructuring to name the state variable and its updater function (e.g., `const [count, setCount] = useState(0);`).\n- **Updater Function (`setStateFunction`)**: This function is similar to `this.setState` in class components but specifically for the state variable it's paired with. It queues a re-render with the new state.\n  - **Direct Update**: `setCount(newValue)`: Directly sets the state to `newValue`. Similar to the object form of `setState` in classes, this update is batched.\n  - **Functional Update**: `setCount(prevValue => newValue)`: Takes a function that receives the previous state and returns the new state. This is highly recommended for updates that depend on the previous state to avoid stale closures and ensure reliable updates, especially in scenarios with multiple updates or asynchronous operations.\n- **Immutability with useState**: Just like in class components, `useState` updates trigger a re-render if the new state value is referentially different from the old one. For objects and arrays, you must always provide a new object or array, even if only a nested property has changed. Direct mutation of state objects/arrays will not trigger re-render.",
          "examples": [
            {
              "id": "example_functional_component_state_useState_1",
              "title": "Basic useState for Counter",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  // Declare a state variable 'count' initialized to 0, and its updater 'setCount'\n  const [count, setCount] = useState(0);\n  \n  const increment = () => {\n    // Direct update: new state does not depend on old state, or simple increment\n    setCount(count + 1);\n  };\n  \n  const decrement = () => {\n    // Direct update\n    setCount(count - 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the basic usage of `useState`. `const [count, setCount] = useState(0);` initializes `count` to 0. `setCount(count + 1);` updates the `count` state. Although `count + 1` uses the current `count` value, this approach can lead to issues if `setCount` is called multiple times within a single batch or asynchronous operation, as `count` might be a 'stale' value from a previous render.",
              "language": "typescript"
            },
            {
              "id": "example_functional_component_state_useState_2",
              "title": "Functional Updates with useState",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const incrementSafely = () => {\n    // Functional update: prevCount is guaranteed to be the latest state\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const resetAndIncrement = () => {\n    // Example of batched updates using functional form for reliability\n    setCount(0); // This sets count to 0, but might be batched\n    setCount(prevCount => prevCount + 1); // This ensures increment happens after 0, regardless of batching\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={incrementSafely}>Increment Safely</button>\n      <button onClick={resetAndIncrement}>Reset and Increment</button>\n    </div>\n  );\n}",
              "explanation": "The `incrementSafely` function uses the functional update form `setCount(prevCount => prevCount + 1)`. This is the preferred way to update state when the new state depends on the previous state, as `prevCount` is guaranteed to be the most up-to-date value. The `resetAndIncrement` function illustrates how React batches updates; even if `setCount(0)` and `setCount(prevCount => prevCount + 1)` are called in the same event, the functional update ensures `prevCount` correctly reflects the state *after* the `setCount(0)` update has been processed internally.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_functional_component_state_useState_1",
            "question_functional_component_state_useState_2",
            "question_functional_component_state_useState_3",
            "question_functional_component_state_useState_4"
          ],
          "relatedTasks": [
            "task_functional_counter_app",
            "task_functional_timer_component"
          ],
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState",
            "State Management",
            "Functional Updates"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_es6_features",
            "react_functional_components"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_use_effect",
            "react_custom_hooks",
            "react_context_api"
          ]
        },
        {
          "id": "theory_functional_component_complex_useState",
          "title": "React State Management: Functional Components - Complex State with useState",
          "content": "Managing complex state objects or arrays in functional components with `useState` requires careful attention to immutability, similar to class components. When your state is an object or an array, `useState` does not automatically merge updates like `this.setState` does in class components. Instead, it *replaces* the entire state value with the new value you provide.\n\n## Key Concepts\n- **State Replacement, Not Merging**: Unlike `this.setState` in class components which merges partial state updates, `useState`'s setter function replaces the entire state value. If your state is an object, and you only want to update one property, you must manually merge the old state with the new property using the spread operator (`...`).\n- **Immutability for Nested Objects**: To update a nested property within a state object, you need to create new objects at each level of nesting leading up to the property you're changing. This ensures React detects the change and re-renders.\n- **Spread Operator for Copies**: The spread operator (`...`) is essential for creating shallow copies of objects and arrays, allowing you to update specific properties while retaining others.\n- **Functional Update for Reliability**: For updates that depend on the previous complex state, especially deeply nested ones, always use the functional form of the setter (`setMyObject(prevObject => ({ ...prevObject, updatedProp }))`) to ensure you're working with the most current state snapshot.",
          "examples": [
            {
              "id": "example_functional_component_complex_useState_1",
              "title": "Updating Nested State in Functional Components",
              "code": "import React, { useState } from 'react';\n\nfunction UserForm() {\n  const [user, setUser] = useState({\n    name: '',\n    email: '',\n    preferences: {\n      newsletter: false,\n      notifications: true\n    }\n  });\n\n  const handleNameChange = (event) => {\n    // Correctly updating a top-level nested property (name)\n    setUser(prevUser => ({\n      ...prevUser, // Copy existing user properties\n      name: event.target.value // Update 'name'\n    }));\n  };\n\n  const toggleNewsletter = () => {\n    // Correctly updating a deeply nested property (newsletter) using functional update\n    setUser(prevUser => ({\n      ...prevUser, // Copy existing user properties\n      preferences: {\n        ...prevUser.preferences, // Copy existing preferences properties\n        newsletter: !prevUser.preferences.newsletter // Toggle 'newsletter'\n      }\n    }));\n  };\n\n  const handleEmailChange = (event) => {\n    // Example: Direct update (less safe if batched, but common for independent updates)\n    setUser({\n      ...user, // Needs 'user' from the current render scope, which might be stale\n      email: event.target.value\n    });\n  };\n\n  return (\n    <div>\n      <label>Name:</label>\n      <input type=\"text\" value={user.name} onChange={handleNameChange} />\n      <label>Email:</label>\n      <input type=\"email\" value={user.email} onChange={handleEmailChange} />\n      <p>Newsletter: {user.preferences.newsletter ? 'Yes' : 'No'}</p>\n      <button onClick={toggleNewsletter}>Toggle Newsletter</button>\n    </div>\n  );\n}",
              "explanation": "This example shows how to manage complex state objects using `useState` in functional components. Notice that to update just the `name`, we must spread the `prevUser` object to retain its `email` and `preferences`. Similarly, for deeply nested updates like `newsletter`, we spread both the `user` object and the `preferences` object to ensure only the `newsletter` property is toggled while others remain unchanged. Using the functional update form (`prevUser => (...)`) is generally safer for complex state as it guarantees access to the latest state.",
              "language": "typescript"
            },
            {
              "id": "example_functional_component_complex_useState_2",
              "title": "Updating Array State with useState",
              "code": "import React, { useState } from 'react';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'Learn React', completed: false },\n    { id: 2, text: 'Build a project', completed: true }\n  ]);\n\n  const addTodo = (text) => {\n    const newTodo = { id: Date.now(), text, completed: false };\n    setTodos(prevTodos => [...prevTodos, newTodo]); // Add new item\n  };\n\n  const toggleTodo = (id) => {\n    setTodos(prevTodos =>\n      prevTodos.map(todo =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      )\n    );\n  };\n\n  return (\n    <div>\n      <input type=\"text\" onKeyPress={(e) => { if (e.key === 'Enter') { addTodo(e.target.value); e.target.value = ''; } }} placeholder=\"Add new todo\" />\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            <span onClick={() => toggleTodo(todo.id)}>{todo.text}</span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates how to manage an array of objects in state. To add a new todo, `setTodos` is called with a new array created by spreading `prevTodos` and appending the `newTodo`. To toggle a todo's completion status, `map` is used to iterate over the `prevTodos` array. For the matching todo, a *new* todo object is created with the `completed` status toggled, ensuring immutability of the todo object itself. This results in a new array, triggering a re-render.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_functional_component_complex_useState_1",
            "question_functional_component_complex_useState_2",
            "question_functional_component_complex_useState_3",
            "question_functional_component_complex_useState_4"
          ],
          "relatedTasks": [
            "task_functional_form_validation",
            "task_functional_shopping_cart"
          ],
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState",
            "Complex State",
            "Immutability",
            "Spread Operator",
            "Array Updates",
            "Object Updates"
          ],
          "technology": "React",
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "react_performance_optimization",
            "react_context_api_patterns",
            "react_reducer_hook"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_class_component_state_basics_1",
          "topic": "Class Component State & setState",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct way to update state in a React class component?",
          "answer": "Using this.setState()",
          "options": [
            "Directly modifying this.state (e.g., this.state.count = 5;)",
            "Using this.setState()",
            "Calling forceUpdate()",
            "Modifying props directly"
          ],
          "analysisPoints": [
            "Understanding that `this.state` should be treated as immutable.",
            "Recognizing `this.setState()` as the prescribed method for state updates.",
            "Distinguishing between state updates and prop modifications."
          ],
          "keyConcepts": [
            "Class Components",
            "State Management",
            "setState"
          ],
          "evaluationCriteria": [
            "Basic knowledge of React state update mechanisms."
          ],
          "example": "```typescript\nclass MyComponent extends React.Component {\n  state = { count: 0 };\n  handleClick = () => {\n    this.setState({ count: this.state.count + 1 }); // Correct way\n    // this.state.count = 5; // Incorrect, will not trigger re-render\n  };\n  render() {\n    return <button onClick={this.handleClick}>Count: {this.state.count}</button>;\n  }\n}\n```\nExplanation: Directly modifying `this.state` does not notify React of a state change, thus not triggering a re-render. `this.setState()` is the designated method to inform React about state changes and queue a re-render.",
          "tags": [
            "React",
            "Class Components",
            "State",
            "setState"
          ],
          "prerequisites": [
            "javascript_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_component_state_basics_2",
          "topic": "setState Asynchronous Nature and Batching",
          "level": "medium",
          "type": "open",
          "question": "Explain why `this.setState` calls are considered asynchronous and how React handles multiple `setState` calls made within the same event loop. Provide a scenario where understanding this behavior is crucial.",
          "answer": "N/A",
          "analysisPoints": [
            "Ability to articulate the asynchronous nature of `setState` (React batches updates for performance).",
            "Understanding that React batches multiple `setState` calls made synchronously within the same event handler/loop to avoid unnecessary re-renders.",
            "Identifying that the functional form of `setState` (`prevState => newState`) is necessary for updates dependent on previous state due to this asynchronous nature.",
            "Providing a concrete scenario (e.g., multiple increments/toggles) where direct state access after `setState` would lead to incorrect results."
          ],
          "keyConcepts": [
            "setState",
            "Asynchronous",
            "Batching",
            "Performance Optimization",
            "Functional setState"
          ],
          "evaluationCriteria": [
            "Depth of understanding of React's internal state update mechanisms.",
            "Ability to explain practical implications."
          ],
          "example": "When `this.setState` is called, React doesn't immediately update the state and re-render the component. Instead, it queues the update. React batches multiple `setState` calls made within the same synchronous event handler (e.g., a button click) into a single re-render cycle. This is done for performance optimization, preventing multiple expensive re-renders for trivial changes. Consequently, if you try to read `this.state` immediately after calling `this.setState`, you might not get the updated value.\n\nScenario: Consider a counter component where you want to increment the count by 3 when a button is clicked, by calling `this.setState({ count: this.state.count + 1 });` three times consecutively.\n\n```typescript\nclass Counter extends React.Component {\n  state = { count: 0 };\n  incrementByThreeIncorrect() {\n    this.setState({ count: this.state.count + 1 }); // count = 0 + 1 = 1\n    this.setState({ count: this.state.count + 1 }); // count is still 0 here, so 0 + 1 = 1\n    this.setState({ count: this.state.count + 1 }); // count is still 0 here, so 0 + 1 = 1\n  }\n  // After batching, the state will be { count: 1 }, not 3.\n\n  incrementByThreeCorrect() {\n    this.setState(prevState => ({ count: prevState.count + 1 })); // prev: 0 -> next: 1\n    this.setState(prevState => ({ count: prevState.count + 1 })); // prev: 1 -> next: 2\n    this.setState(prevState => ({ count: prevState.count + 1 })); // prev: 2 -> next: 3\n  }\n  // After batching, the state will be { count: 3 }.\n}\n```\nIn `incrementByThreeIncorrect`, because `this.state.count` doesn't update immediately, all three `setState` calls read the initial `count` value (0), leading to an incorrect final count of 1. The `incrementByThreeCorrect` method uses the functional update form, ensuring each `setState` call receives the *latest* state from the previous update in the batch, thus correctly incrementing the count to 3.",
          "tags": [
            "React",
            "State Management",
            "setState",
            "Asynchronous",
            "Batching",
            "Performance"
          ],
          "prerequisites": [
            "theory_class_component_state_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_component_state_basics_3",
          "topic": "setState Callback",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React class component, what will be logged to the console by `console.log(this.state.message);` after the button is clicked, and when will the callback `console.log('State updated and re-rendered');` execute?",
          "answer": "logs 'Initial Message' first, then 'State updated and re-rendered' after the component re-renders.",
          "options": [
            "logs 'New Message' first, then 'State updated and re-rendered' immediately after.",
            "logs 'Initial Message' first, then 'State updated and re-rendered' after the component re-renders.",
            "logs 'Initial Message' first, then 'New Message' immediately after.",
            "logs 'New Message' first, then 'Initial Message' after the component re-renders."
          ],
          "analysisPoints": [
            "Understanding `setState` is asynchronous and its updates are batched.",
            "Knowing that `this.state` might not reflect the updated value immediately after `setState`.",
            "Recognizing that the `setState` callback executes *after* the state has been updated and the component has potentially re-rendered."
          ],
          "keyConcepts": [
            "setState",
            "Asynchronous",
            "Callback Function",
            "Re-render"
          ],
          "evaluationCriteria": [
            "Ability to predict `setState` behavior.",
            "Understanding of `setState` callback execution timing."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  state = { message: 'Initial Message' };\n\n  handleClick = () => {\n    this.setState({ message: 'New Message' }, () => {\n      console.log('State updated and re-rendered');\n    });\n    console.log(this.state.message); // This logs the 'Initial Message'\n  };\n\n  render() {\n    return (\n      <div>\n        <p>{this.state.message}</p>\n        <button onClick={this.handleClick}>Change Message</button>\n      </div>\n    );\n  }\n}\n```\nExplanation: When `handleClick` is called, `this.setState` queues the update. The `console.log(this.state.message);` immediately after `setState` will log the *current* state value ('Initial Message') because `setState` is asynchronous and the state hasn't been updated yet in that synchronous execution flow. The callback function `() => { console.log('State updated and re-rendered'); }` will execute *after* the state update has been processed by React and the component has potentially re-rendered with the new state ('New Message').",
          "tags": [
            "React",
            "Class Components",
            "setState",
            "Asynchronous",
            "Callback"
          ],
          "prerequisites": [
            "theory_class_component_state_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_component_state_basics_4",
          "topic": "State vs. Props",
          "level": "flashcard",
          "question": "What is the primary difference between `state` and `props` in React class components?",
          "answer": "`State` is data managed by the component itself and can change over time. `Props` are data passed from a parent component to a child component and are immutable (read-only) within the child component.",
          "analysisPoints": [
            "Distinguishing mutability/immutability.",
            "Identifying source of data (internal vs. external)."
          ],
          "keyConcepts": [
            "State",
            "Props",
            "Class Components",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Quick recall of fundamental React concepts."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "State",
            "Props",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_components_intro"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_component_functional_and_complex_updates_1",
          "topic": "Class Component Functional setState",
          "level": "medium",
          "type": "mcq",
          "question": "You have a React class component with a state `counter: 0`. You want to increment `counter` twice when a single button is clicked. Which method ensures the `counter` is correctly incremented by 2, assuming React's batching behavior?",
          "answer": "```javascript\nthis.setState(prevState => ({ counter: prevState.counter + 1 }));\nthis.setState(prevState => ({ counter: prevState.counter + 1 }));\n```",
          "options": [
            "```javascript\nthis.setState({ counter: this.state.counter + 1 });\nthis.setState({ counter: this.state.counter + 1 });\n```",
            "```javascript\nthis.setState(prevState => ({ counter: prevState.counter + 1 }));\nthis.setState(prevState => ({ counter: prevState.counter + 1 }));\n```",
            "```javascript\nthis.setState({ counter: this.state.counter + 2 });\n```",
            "```javascript\nthis.state.counter += 2;\nthis.forceUpdate();\n```"
          ],
          "analysisPoints": [
            "Understanding the importance of functional `setState` for updates depending on previous state.",
            "Knowing that direct `this.state` access inside multiple `setState` calls within a batched update can lead to stale state.",
            "Recognizing that `this.setState({ counter: this.state.counter + 2 });` would also work but does not directly test the understanding of multiple batched updates using functional forms.",
            "Identifying direct mutation + `forceUpdate` as an anti-pattern."
          ],
          "keyConcepts": [
            "Class Components",
            "setState",
            "Functional Update",
            "Batching",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Ability to apply `setState` best practices for sequential updates.",
            "Understanding of asynchronous nature and batching."
          ],
          "example": "```typescript\nclass MyComponent extends React.Component {\n  state = { counter: 0 };\n\n  incrementTwiceSafe = () => {\n    this.setState(prevState => ({ counter: prevState.counter + 1 }));\n    this.setState(prevState => ({ counter: prevState.counter + 1 }));\n    // When batched, the second call's prevState will correctly reflect the first update.\n  };\n\n  incrementTwiceUnsafe = () => {\n    this.setState({ counter: this.state.counter + 1 });\n    this.setState({ counter: this.state.counter + 1 });\n    // Both calls read the original this.state.counter value before any update is processed,\n    // leading to a final counter of 1 if initial was 0.\n  };\n}\n```\nExplanation: The first option using `this.setState({ counter: this.state.counter + 1 });` twice will likely result in `counter` only increasing by 1 (if it started at 0) due to React's batching and the asynchronous nature of `setState`. Both calls will read the same `this.state.counter` value before the update is applied. The second option uses the functional form (`prevState => ...`), which guarantees that each update receives the most recent state value, leading to a correct increment by 2.",
          "tags": [
            "React",
            "Class Components",
            "setState",
            "Functional Update",
            "Batching"
          ],
          "prerequisites": [
            "theory_class_component_state_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_component_functional_and_complex_updates_2",
          "topic": "Class Component Complex State Immutability",
          "level": "hard",
          "type": "code",
          "question": "Implement a `UserProfileEditor` class component. The component should manage a `user` state object with nested properties: `name` (string), `contact` (object with `email` and `phone` strings), and `settings` (object with `receiveEmails` boolean and `theme` string). Provide methods to:\n1. Update the user's `name`.\n2. Update the user's `email` (nested property).\n3. Toggle `receiveEmails` (deeply nested property).\n\nEnsure all updates are immutable and trigger proper re-renders.",
          "answer": "N/A",
          "analysisPoints": [
            "Correctly initializing nested state.",
            "Using spread syntax (`...`) at each level of nested object to ensure immutability.",
            "Applying functional `setState` for updates that depend on previous state (especially toggles/complex paths).",
            "Triggering re-renders without direct mutation."
          ],
          "keyConcepts": [
            "Class Components",
            "Complex State",
            "Immutability",
            "setState",
            "Nested Objects",
            "Spread Operator"
          ],
          "evaluationCriteria": [
            "Ability to handle complex state structures.",
            "Correct application of immutability principles.",
            "Proper use of `setState`."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass UserProfileEditor extends React.Component {\n  state = {\n    user: {\n      name: 'John Doe',\n      contact: {\n        email: 'john.doe@example.com',\n        phone: '123-456-7890'\n      },\n      settings: {\n        receiveEmails: true,\n        theme: 'light'\n      }\n    }\n  };\n\n  handleNameChange = (event) => {\n    this.setState(prevState => ({\n      user: {\n        ...prevState.user,\n        name: event.target.value\n      }\n    }));\n  };\n\n  handleEmailChange = (event) => {\n    this.setState(prevState => ({\n      user: {\n        ...prevState.user,\n        contact: {\n          ...prevState.user.contact,\n          email: event.target.value\n        }\n      }\n    }));\n  };\n\n  toggleReceiveEmails = () => {\n    this.setState(prevState => ({\n      user: {\n        ...prevState.user,\n        settings: {\n          ...prevState.user.settings,\n          receiveEmails: !prevState.user.settings.receiveEmails\n        }\n      }\n    }));\n  };\n\n  render() {\n    const { user } = this.state;\n    return (\n      <div>\n        <h3>User Profile</h3>\n        <div>\n          <label>Name:</label>\n          <input type=\"text\" value={user.name} onChange={this.handleNameChange} />\n        </div>\n        <div>\n          <label>Email:</label>\n          <input type=\"email\" value={user.contact.email} onChange={this.handleEmailChange} />\n        </div>\n        <div>\n          <label>Receive Emails:</label>\n          <input type=\"checkbox\" checked={user.settings.receiveEmails} onChange={this.toggleReceiveEmails} />\n        </div>\n        <p>Theme: {user.settings.theme}</p>\n        <pre>{JSON.stringify(user, null, 2)}</pre>\n      </div>\n    );\n  }\n}\n```",
          "tags": [
            "React",
            "Class Components",
            "State",
            "Complex State",
            "Immutability",
            "setState"
          ],
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_class_component_functional_and_complex_updates"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_class_component_functional_and_complex_updates_3",
          "topic": "Immutability Principle",
          "level": "open",
          "question": "Why is it important to update state immutably in React, especially when dealing with objects and arrays? What issues can arise from direct state mutation?",
          "answer": "N/A",
          "analysisPoints": [
            "Explaining how React's shallow comparison (`shouldComponentUpdate`, `PureComponent`) relies on reference equality.",
            "Stating that direct mutation bypasses React's change detection mechanism.",
            "Listing issues: components not re-rendering, unpredictable behavior, difficulty in debugging, breaking optimization techniques, issues with features like Context API, Redux, or DevTools time-travel debugging."
          ],
          "keyConcepts": [
            "Immutability",
            "State Management",
            "Performance",
            "Shallow Comparison",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of immutability's role in React.",
            "Ability to identify potential pitfalls."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Immutability",
            "State",
            "Best Practices",
            "Performance"
          ],
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_class_component_functional_and_complex_updates"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_component_functional_and_complex_updates_4",
          "topic": "Class Component vs. Functional Component State",
          "level": "flashcard",
          "question": "How does `this.setState`'s merging behavior differ from `useState`'s setter behavior when updating an object?",
          "answer": "`this.setState` in class components automatically merges the object you pass with the current state. `useState`'s setter function, however, *replaces* the entire state value; for objects, you must manually merge by spreading the previous state.",
          "analysisPoints": [
            "Distinguishing `setState` (merge) vs. `useState` setter (replace).",
            "Understanding implications for object updates."
          ],
          "keyConcepts": [
            "setState",
            "useState",
            "Merging",
            "Replacing",
            "State Differences"
          ],
          "evaluationCriteria": [
            "Quick recall of key differences between class and functional state management."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Class Components",
            "Functional Components",
            "State",
            "setState",
            "useState"
          ],
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_functional_component_state_useState"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_state_useState_1",
          "topic": "Functional Component State - useState Hook",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following correctly initializes a state variable `username` with an empty string in a functional component using `useState`?",
          "answer": "```javascript\nconst [username, setUsername] = useState('');\n```",
          "options": [
            "```javascript\nconst username = useState('');\n```",
            "```javascript\nconst [username] = useState('');\n```",
            "```javascript\nconst [username, setUsername] = useState('');\n```",
            "```javascript\nlet username = '';\n```"
          ],
          "analysisPoints": [
            "Understanding `useState` returns an array.",
            "Correctly applying array destructuring `[state, setState]`.",
            "Identifying the correct `useState` syntax."
          ],
          "keyConcepts": [
            "useState",
            "Functional Components",
            "Hooks",
            "State Initialization"
          ],
          "evaluationCriteria": [
            "Basic syntax knowledge of `useState`."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction LoginForm() {\n  const [username, setUsername] = useState(''); // Correct initialization\n  // ... rest of component\n}\n```\nExplanation: `useState` returns a pair: the current state value and a function to update it. Array destructuring `[username, setUsername]` is the standard way to capture these values. Simply assigning `useState('')` to `username` would result in `username` being the entire array `['', Function]`, which is not what's intended for the state value itself.",
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState"
          ],
          "prerequisites": [
            "javascript_es6_features"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_component_state_useState_2",
          "topic": "Functional Component State - Functional Updates",
          "level": "medium",
          "type": "open",
          "question": "Consider a functional component with state `count` initialized to 0. You have a button that, when clicked, calls `setCount(count + 1);` twice. What will be the final `count` value if the initial `count` is 0, and why? How would you modify the code to ensure it increments by 2 correctly?",
          "answer": "N/A",
          "analysisPoints": [
            "Explaining the concept of 'stale closures' or 'stale state' when `setCount(count + 1)` is called multiple times.",
            "Understanding that `count` in `setCount(count + 1)` refers to the value from the render when the function was created.",
            "Identifying that React batches `useState` updates similarly to `setState`.",
            "Providing the correct solution using the functional update form `setCount(prevCount => prevCount + 1)`."
          ],
          "keyConcepts": [
            "useState",
            "Functional Updates",
            "Stale Closures",
            "Batching",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to explain functional update necessity.",
            "Understanding of React's update lifecycle in hooks."
          ],
          "example": "If `count` is initially 0, and `setCount(count + 1)` is called twice:  \n```typescript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const incrementTwice = () => {\n    setCount(count + 1); // count is 0, so setCount(1)\n    setCount(count + 1); // count is still 0 in this render's closure, so setCount(1) again\n  };\n\n  return <button onClick={incrementTwice}>Increment Twice</button>;\n}\n```\nThe final `count` will be 1, not 2. This is because both `setCount(count + 1)` calls in `incrementTwice` closure refer to the `count` value from the *initial render* when `incrementTwice` was defined, which was 0. Even though React batches these updates, both updates try to set the count to 1 based on that initial 0.\n\nTo correct this, use the functional update form:\n```typescript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const incrementTwiceCorrect = () => {\n    setCount(prevCount => prevCount + 1); // prevCount is 0 -> 1\n    setCount(prevCount => prevCount + 1); // prevCount is 1 -> 2\n  };\n\n  return <button onClick={incrementTwiceCorrect}>Increment Twice Correctly</button>;\n}\n```\nWith the functional update, `prevCount` in each `setCount` call is guaranteed to be the most recent state value, ensuring correct sequential updates.",
          "tags": [
            "React",
            "Functional Components",
            "useState",
            "Functional Updates",
            "Stale Closures",
            "Batching"
          ],
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_state_useState_3",
          "topic": "useState Initial State Performance",
          "level": "medium",
          "type": "mcq",
          "question": "Which `useState` initialization method is more performant if `calculateInitialValue` is a computationally expensive function?",
          "answer": "```javascript\nconst [value, setValue] = useState(() => calculateInitialValue());\n```",
          "options": [
            "```javascript\nconst [value, setValue] = useState(calculateInitialValue());\n```",
            "```javascript\nconst [value, setValue] = useState(() => calculateInitialValue());\n```",
            "Both are equally performant.",
            "It depends on the React version."
          ],
          "analysisPoints": [
            "Understanding that `useState` accepts a function for lazy initialization.",
            "Recognizing that `useState(expensiveFn())` executes the function on every render.",
            "Identifying that `useState(() => expensiveFn())` executes the function only once on the initial render."
          ],
          "keyConcepts": [
            "useState",
            "Performance",
            "Lazy Initialization",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Knowledge of `useState` initialization nuances for performance."
          ],
          "example": "```typescript\nfunction calculateExpensiveValue() {\n  console.log('Calculating initial value...'); // This will be logged on every render if not lazy initialized\n  // Imagine complex computations here\n  return 100;\n}\n\nfunction MyComponent() {\n  // Option 1: calculateExpensiveValue() runs on every render\n  // const [value1, setValue1] = useState(calculateExpensiveValue());\n\n  // Option 2: calculateExpensiveValue() runs ONLY on initial render\n  const [value2, setValue2] = useState(() => calculateExpensiveValue());\n\n  return <p>Value: {value2}</p>;\n}\n```\nExplanation: When `useState(calculateInitialValue())` is used, `calculateInitialValue()` is executed on every render because it's called directly during the render phase. If this function is expensive, it can lead to performance issues. However, when `useState(() => calculateInitialValue())` is used, the function `calculateInitialValue` is passed as a *lazy initializer*. React will only execute this function once, during the initial render, to determine the initial state. Subsequent re-renders will reuse the previously stored state value without re-executing the initializer function, making it more performant for expensive initializations.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_state_useState_4",
          "topic": "useState Immutability",
          "level": "flashcard",
          "question": "What is the key difference in how `useState`'s setter handles object updates compared to `this.setState` in class components?",
          "answer": "`useState`'s setter *replaces* the entire object, requiring manual merging with the spread operator. `this.setState` *merges* the new object into the existing state automatically.",
          "analysisPoints": [
            "Understanding the 'replace' behavior of `useState`'s setter for objects.",
            "Understanding the 'merge' behavior of `this.setState` for objects."
          ],
          "keyConcepts": [
            "useState",
            "setState",
            "Object Updates",
            "Merge vs Replace",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Quick recall of critical behavioral differences."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "setState",
            "Immutability"
          ],
          "prerequisites": [
            "theory_class_component_functional_and_complex_updates",
            "theory_functional_component_state_useState"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_complex_useState_1",
          "topic": "Functional Component Complex State Update",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following functional component state:\n```javascript\nconst [form, setForm] = useState({\n  personal: { firstName: '', lastName: '' },\n  address: { street: '', city: '' }\n});\n```\nWhich code snippet correctly updates only the `firstName` to 'Jane'?",
          "answer": "```javascript\nsetForm(prevForm => ({\n  ...prevForm,\n  personal: { ...prevForm.personal, firstName: 'Jane' }\n}));\n```",
          "options": [
            "```javascript\nsetForm({ firstName: 'Jane' });\n```",
            ""
          ],
          "analysisPoints": [
            "Understanding that `useState` setter replaces the entire state object, not merges.",
            "Applying immutability by spreading at each level of the nested object.",
            "Avoiding direct mutation of the state object.",
            "Using the functional updater form for reliability."
          ],
          "keyConcepts": [
            "useState",
            "Complex State",
            "Immutability",
            "Functional Update",
            "Spread Operator"
          ],
          "evaluationCriteria": [
            "Ability to correctly update deeply nested state in functional components.",
            "Strong grasp of immutability."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction MyForm() {\n  const [form, setForm] = useState({\n    personal: { firstName: 'John', lastName: 'Doe' },\n    address: { street: '123 Main St', city: 'Anytown' }\n  });\n\n  const updateFirstName = () => {\n    // Incorrect: Replaces the whole form object\n    // setForm({ firstName: 'Jane' });\n\n    // Incorrect: Mutates state directly, might not re-render\n    // setForm(prevForm => {\n    //   prevForm.personal.firstName = 'Jane';\n    //   return prevForm;\n    // });\n\n    // Correct way:\n    setForm(prevForm => ({\n      ...prevForm,\n      personal: { ...prevForm.personal, firstName: 'Jane' }\n    }));\n  };\n\n  return (\n    <div>\n      <p>First Name: {form.personal.firstName}</p>\n      <button onClick={updateFirstName}>Update First Name</button>\n    </div>\n  );\n}\n```\nExplanation: Option 1 (`setForm({ firstName: 'Jane' });`) is incorrect because `useState` replaces the entire state object; it would remove `personal.lastName`, `address`, etc. Option 2 and 4 directly mutate the `prevForm` or `form` object, which is an anti-pattern and might not trigger a re-render because the reference to the object itself doesn't change. Option 3 is correct. It uses the functional update form and the spread operator at each level (`...prevForm` and `...prevForm.personal`) to create new objects, preserving other properties while immutably updating `firstName`. This ensures React detects the change and re-renders correctly.",
          "tags": [
            "React",
            "Functional Components",
            "useState",
            "Complex State",
            "Immutability",
            "Spread Operator"
          ],
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_complex_useState_2",
          "topic": "Functional Component State - Array Updates",
          "level": "hard",
          "type": "code",
          "question": "You are building a `TaskList` functional component. The component's state `tasks` is an array of objects, where each object has `id` (number), `text` (string), and `completed` (boolean). Implement the `toggleTaskCompletion` function which takes a `taskId` and toggles the `completed` status of the matching task. Ensure the update is immutable.",
          "answer": "N/A",
          "analysisPoints": [
            "Correctly identifying that array methods like `map` are suitable for immutable updates.",
            "Creating a new array and new task objects for updated elements.",
            "Avoiding direct mutation of the array or its elements.",
            "Using functional `setTasks` for reliable updates."
          ],
          "keyConcepts": [
            "useState",
            "Array State",
            "Immutability",
            "Functional Update",
            "map",
            "Spread Operator"
          ],
          "evaluationCriteria": [
            "Ability to perform immutable updates on array state.",
            "Understanding of array manipulation methods for immutability."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction TaskList() {\n  const [tasks, setTasks] = useState([\n    { id: 1, text: 'Buy groceries', completed: false },\n    { id: 2, text: 'Do laundry', completed: true },\n    { id: 3, text: 'Call mom', completed: false }\n  ]);\n\n  const toggleTaskCompletion = (taskId) => {\n    setTasks(prevTasks =>\n      prevTasks.map(task =>\n        task.id === taskId ? { ...task, completed: !task.completed } : task\n      )\n    );\n  };\n\n  return (\n    <div>\n      <h3>My Tasks</h3>\n      <ul>\n        {tasks.map(task => (\n          <li key={task.id} onClick={() => toggleTaskCompletion(task.id)} style={{ textDecoration: task.completed ? 'line-through' : 'none', cursor: 'pointer' }}>\n            {task.text}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Functional Components",
            "useState",
            "Array State",
            "Immutability",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_functional_component_state_useState",
            "theory_functional_component_complex_useState"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_functional_component_complex_useState_3",
          "topic": "useState vs. useReducer",
          "level": "open",
          "question": "For what kind of state management scenarios might `useReducer` be preferred over `useState` in functional components?",
          "answer": "N/A",
          "analysisPoints": [
            "Identifying complex state logic (multiple interrelated state transitions).",
            "Situations where the next state depends on the previous one in a complex way.",
            "Managing multiple pieces of state that often change together.",
            "When passing state update logic down to child components without prop drilling (dispatch function is stable).",
            "Replacing redux-like patterns for local component state."
          ],
          "keyConcepts": [
            "useState",
            "useReducer",
            "Complex State",
            "State Logic",
            "Prop Drilling",
            "Hooks"
          ],
          "evaluationCriteria": [
            "Understanding the strengths and weaknesses of different React hooks for state management.",
            "Ability to identify appropriate tools for specific problems."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useReducer",
            "State Management",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_functional_component_complex_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_functional_component_complex_useState_4",
          "topic": "State Immutability Recap",
          "level": "flashcard",
          "question": "What is the primary reason for using the spread operator (`...`) when updating objects or arrays in React state?",
          "answer": "To create a shallow copy of the existing object or array, ensuring immutability. This allows you to update specific properties while keeping others, and more importantly, ensures React detects the change and triggers a re-render.",
          "analysisPoints": [
            "Connecting spread operator to immutability.",
            "Linking immutability to React's rendering mechanism."
          ],
          "keyConcepts": [
            "Immutability",
            "Spread Operator",
            "State Updates",
            "Re-render"
          ],
          "evaluationCriteria": [
            "Quick recall of a fundamental React best practice."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Immutability",
            "Spread Operator",
            "Best Practices"
          ],
          "prerequisites": [
            "theory_class_component_functional_and_complex_updates",
            "theory_functional_component_complex_useState"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_class_component_counter",
          "title": "Build a Simple Class Component Counter",
          "description": "\nCreate a React class component named `SimpleCounter` that manages a single piece of state: `count` (initialized to 0).\n\nRequirements:\n1. Display the current `count` value.\n2. Include two buttons: 'Increment' and 'Decrement'.\n3. The 'Increment' button should increase the `count` by 1. Use the functional form of `setState` for this update to ensure reliability against batching.\n4. The 'Decrement' button should decrease the `count` by 1. Use the direct object form of `setState` for this update.\n5. Add a third button 'Reset' that sets the count back to 0.\n\nYour solution should demonstrate basic state management in a class component, including both direct and functional `setState` approaches.",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\nclass SimpleCounter extends React.Component {\n  // TODO: Initialize state\n  \n  // TODO: Implement increment method (functional setState)\n  \n  // TODO: Implement decrement method (direct setState)\n\n  // TODO: Implement reset method\n\n  render() {\n    return (\n      <div>\n        <h2>Simple Counter</h2>\n        {/* TODO: Display count */}\n        {/* TODO: Add Increment, Decrement, Reset buttons */}\n      </div>\n    );\n  }\n}\n\nexport default SimpleCounter;\n",
          "solutionCode": "import React from 'react';\n\nclass SimpleCounter extends React.Component {\n  state = {\n    count: 0\n  };\n\n  increment = () => {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  decrement = () => {\n    this.setState({ count: this.state.count - 1 });\n  };\n\n  reset = () => {\n    this.setState({ count: 0 });\n  };\n\n  render() {\n    return (\n      <div>\n        <h2>Simple Counter</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n        <button onClick={this.decrement}>Decrement</button>\n        <button onClick={this.reset}>Reset</button>\n      </div>\n    );\n  }\n}\n\nexport default SimpleCounter;\n",
          "testCases": [
            "Initial render: Count should be 0.",
            "Clicking 'Increment': Count should increase by 1.",
            "Clicking 'Decrement': Count should decrease by 1.",
            "Clicking 'Increment' multiple times rapidly: Count should increase correctly due to functional update.",
            "Clicking 'Reset': Count should return to 0.",
            "Interacting with all buttons: State should update predictably."
          ],
          "hints": [
            "Remember to use `this.state` for reading state and `this.setState()` for updating it.",
            "For functional updates, the callback function receives `prevState` as its argument.",
            "Make sure to bind `this` to your event handlers if not using arrow functions for class methods (though arrow functions are preferred for brevity here)."
          ],
          "tags": [
            "React",
            "Class Components",
            "State",
            "setState",
            "Functional setState",
            "Basic"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_class_component_functional_and_complex_updates"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "react_event_handling"
          ]
        },
        {
          "id": "task_class_component_form",
          "title": "Build a Class Component User Profile Form",
          "description": "\nCreate a React class component named `UserProfileForm` that manages a complex state object representing a user's profile.\n\nRequirements:\n1.  The component's state should include a `user` object with the following structure:\n    ```javascript\n    user: {\n      firstName: string,\n      lastName: string,\n      contact: {\n        email: string,\n        phone: string\n      },\n      preferences: {\n        newsletter: boolean,\n        smsNotifications: boolean\n      }\n    }\n    ```\n    Initialize all string fields to empty strings and boolean fields to `false`.\n2.  Render input fields for `firstName`, `lastName`, `email`, and `phone`.\n3.  Render checkboxes for `newsletter` and `smsNotifications`.\n4.  Implement change handlers for all input types (`onChange` for text inputs, `onChange` for checkboxes) that correctly update the corresponding state properties.\n5.  **Crucially**: All state updates must be immutable. Use the spread operator (`...`) to copy existing state properties at each level of nesting. Use the functional form of `setState` where necessary (e.g., for toggling booleans or when an update depends on previous nested state).\n6.  Display the current state (e.g., using `JSON.stringify`) to visually verify updates.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass UserProfileForm extends React.Component {\n  state = {\n    // TODO: Initialize complex user state\n  };\n\n  // TODO: Implement handleChange for text inputs (firstName, lastName, email, phone)\n  // Remember to handle nested properties immutably.\n\n  // TODO: Implement handleToggle for checkboxes (newsletter, smsNotifications)\n  // Remember to handle deeply nested properties immutably with functional setState.\n\n  render() {\n    const { user } = this.state;\n    return (\n      <div>\n        <h2>User Profile Editor (Class Component)</h2>\n        {/* TODO: Render input fields and checkboxes */}\n        {/* TODO: Display current state */}\n      </div>\n    );\n  }\n}\n\nexport default UserProfileForm;\n",
          "solutionCode": "import React from 'react';\n\nclass UserProfileForm extends React.Component {\n  state = {\n    user: {\n      firstName: '',\n      lastName: '',\n      contact: {\n        email: '',\n        phone: ''\n      },\n      preferences: {\n        newsletter: false,\n        smsNotifications: false\n      }\n    }\n  };\n\n  handleTextChange = (event) => {\n    const { name, value } = event.target;\n    this.setState(prevState => {\n      // Split name by dot for nested properties, e.g., 'contact.email'\n      const nameParts = name.split('.');\n      if (nameParts.length === 1) {\n        // Top-level property of user\n        return {\n          user: {\n            ...prevState.user,\n            [name]: value\n          }\n        };\n      } else if (nameParts.length === 2) {\n        // Nested property, e.g., contact.email or preferences.newsletter\n        const [parent, child] = nameParts;\n        return {\n          user: {\n            ...prevState.user,\n            [parent]: {\n              ...prevState.user[parent],\n              [child]: value\n            }\n          }\n        };\n      }\n      return prevState; // Should not reach here\n    });\n  };\n\n  handleToggleChange = (event) => {\n    const { name, checked } = event.target;\n    this.setState(prevState => {\n      const nameParts = name.split('.');\n      if (nameParts.length === 2) {\n        const [parent, child] = nameParts;\n        return {\n          user: {\n            ...prevState.user,\n            [parent]: {\n              ...prevState.user[parent],\n              [child]: checked\n            }\n          }\n        };\n      }\n      return prevState; // Should not reach here\n    });\n  };\n\n  render() {\n    const { user } = this.state;\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n        <h2>User Profile Editor (Class Component)</h2>\n        <div>\n          <label>First Name:</label>\n          <input type=\"text\" name=\"firstName\" value={user.firstName} onChange={this.handleTextChange} />\n        </div>\n        <div>\n          <label>Last Name:</label>\n          <input type=\"text\" name=\"lastName\" value={user.lastName} onChange={this.handleTextChange} />\n        </div>\n        <h3>Contact Info</h3>\n        <div>\n          <label>Email:</label>\n          <input type=\"email\" name=\"contact.email\" value={user.contact.email} onChange={this.handleTextChange} />\n        </div>\n        <div>\n          <label>Phone:</label>\n          <input type=\"text\" name=\"contact.phone\" value={user.contact.phone} onChange={this.handleTextChange} />\n        </div>\n        <h3>Preferences</h3>\n        <div>\n          <label>\n            <input type=\"checkbox\" name=\"preferences.newsletter\" checked={user.preferences.newsletter} onChange={this.handleToggleChange} />\n            Receive Newsletter\n          </label>\n        </div>\n        <div>\n          <label>\n            <input type=\"checkbox\" name=\"preferences.smsNotifications\" checked={user.preferences.smsNotifications} onChange={this.handleToggleChange} />\n            SMS Notifications\n          </label>\n        </div>\n        <hr/>\n        <h4>Current State:</h4>\n        <pre>{JSON.stringify(user, null, 2)}</pre>\n      </div>\n    );\n  }\n}\n\nexport default UserProfileForm;\n",
          "testCases": [
            "Initial render: All fields should match initial state (empty strings, false booleans).",
            "Typing in 'First Name' field: Only `user.firstName` should update.",
            "Typing in 'Email' field: Only `user.contact.email` should update, `firstName`, `lastName`, etc., should remain unchanged.",
            "Toggling 'Receive Newsletter': Only `user.preferences.newsletter` should toggle, other state values unaffected.",
            "Rapid typing in multiple fields: All updates should be applied correctly due to immutable updates and functional setState.",
            "Verify JSON.stringify output matches expected state after various interactions."
          ],
          "hints": [
            "For handling generic `onChange` for different input types, consider using the `name` attribute of the input elements and `event.target.name` to identify which property to update.",
            "When updating nested objects, remember to spread (`...`) all sibling properties to avoid losing them.",
            "The functional form of `setState` (`prevState => newState`) is highly recommended for complex updates to ensure you're always operating on the most up-to-date state."
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "Form Handling",
            "Immutability",
            "Complex State",
            "setState"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_class_component_functional_and_complex_updates"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_forms",
            "javascript_spread_operator"
          ]
        },
        {
          "id": "task_functional_counter_app",
          "title": "Build a Feature-Rich Functional Counter with useState",
          "description": "\nCreate a React functional component named `FeatureCounter` that demonstrates advanced `useState` usage.\n\nRequirements:\n1.  Initialize the `count` state with a default value of 0.\n2.  Display the current `count`.\n3.  Implement an 'Increment' button that increases the count by 1. Use the functional update form (`prevCount => prevCount + 1`).\n4.  Implement a 'Decrement' button that decreases the count by 1, ensuring the count never goes below 0.\n5.  Implement a 'Reset' button that sets the count back to 0.\n6.  Add an input field and a 'Set Count' button. When the button is clicked, it should set the count to the value entered in the input field. Validate that the input is a valid number before updating the state; if not, show an error message and do not update count.\n7.  Implement a 'Fast Increment' button that increments the count by 5 in a single click. Demonstrate that using the functional update form sequentially results in the correct total increment (e.g., `setCount(prev => prev + 1)` called 5 times).",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction FeatureCounter() {\n  // TODO: Initialize count state\n  // TODO: Initialize error state for input validation\n\n  // TODO: Implement increment, decrement, reset functions\n\n  // TODO: Implement handleSetCount function with validation\n\n  // TODO: Implement fastIncrement function\n\n  return (\n    <div>\n      <h2>Feature-Rich Counter (Functional Component)</h2>\n      {/* TODO: Display count, buttons, input field, and error message */}\n    </div>\n  );\n}\n\nexport default FeatureCounter;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction FeatureCounter() {\n  const [count, setCount] = useState(0);\n  const [inputValue, setInputValue] = useState('');\n  const [error, setError] = useState('');\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const decrement = () => {\n    setCount(prevCount => Math.max(0, prevCount - 1));\n  };\n\n  const reset = () => {\n    setCount(0);\n    setError(''); // Clear error on reset\n    setInputValue('');\n  };\n\n  const handleInputChange = (event) => {\n    setInputValue(event.target.value);\n    setError(''); // Clear error as user types\n  };\n\n  const handleSetCount = () => {\n    const num = parseInt(inputValue, 10);\n    if (isNaN(num)) {\n      setError('Please enter a valid number.');\n    } else {\n      setCount(num);\n      setError('');\n    }\n  };\n\n  const fastIncrement = () => {\n    // Calling functional update multiple times in a batch ensures correct increment\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Feature-Rich Counter (Functional Component)</h2>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n      <button onClick={reset}>Reset</button>\n      <hr />\n      <div>\n        <input\n          type=\"text\"\n          value={inputValue}\n          onChange={handleInputChange}\n          placeholder=\"Enter number\"\n        />\n        <button onClick={handleSetCount}>Set Count</button>\n        {error && <p style={{ color: 'red' }}>{error}</p>}\n      </div>\n      <hr />\n      <button onClick={fastIncrement}>Fast Increment (+5)</button>\n    </div>\n  );\n};\n\nexport default FeatureCounter;\n",
          "testCases": [
            "Initial render: Count should be 0, input empty, no error.",
            "Increment button: Count should increase by 1.",
            "Decrement button: Count should decrease by 1, but not below 0.",
            "Reset button: Count should return to 0.",
            "Set Count: Enter '10', click Set Count -> Count becomes 10.",
            "Set Count: Enter 'abc', click Set Count -> Error message appears, Count remains unchanged.",
            "Fast Increment: Click button -> Count increases by exactly 5, demonstrating functional updates handling batching."
          ],
          "hints": [
            "Remember to use `Math.max()` to prevent the count from going below zero.",
            "For the 'Set Count' feature, use `parseInt()` to convert the input string to a number and `isNaN()` to check for valid numbers.",
            "The `setCount` function from `useState` can also accept a function as an argument, which is crucial for the 'Fast Increment' feature to work reliably when multiple updates are batched."
          ],
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState",
            "State Management",
            "Input Validation",
            "Batching"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_forms",
            "javascript_type_conversion"
          ]
        },
        {
          "id": "task_functional_shopping_cart",
          "title": "Implement a Functional Shopping Cart with Nested State",
          "description": "\nCreate a React functional component `ShoppingCart` that manages a list of items in a shopping cart. The state should be an array of objects, where each object represents a cart item.\n\nRequirements:\n1.  **State Structure**: The `cartItems` state should be an array of objects, e.g.:\n    ```javascript\n    [\n      { id: 1, name: 'Laptop', price: 1200, quantity: 1 },\n      { id: 2, name: 'Mouse', price: 25, quantity: 2 }\n    ]\n    ```\n    Initialize with at least two sample items.\n2.  **Display Cart**: Render the current items in the cart, showing name, price, quantity, and a subtotal for each item (`price * quantity`). Display the overall total price of all items in the cart.\n3.  **Add Item**: Implement a function `addItem(newItem)` that adds a new item to the cart. If the item (by `id`) already exists, increment its quantity; otherwise, add it as a new item. Ensure this is an immutable update.\n4.  **Remove Item**: Implement a function `removeItem(itemId)` that removes an item from the cart by its `id`. This should also be immutable.\n5.  **Update Quantity**: Implement a function `updateQuantity(itemId, newQuantity)` that changes an item's quantity. Ensure quantity cannot go below 1. This must be an immutable update.\n6.  **All state updates must be immutable**. Use the `useState` functional updater form (`prevItems => ...`) for all modifications to guarantee consistency.\n7.  Add buttons or input fields to trigger these actions for demonstration.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\nfunction ShoppingCart() {\n  // TODO: Initialize cartItems state with sample data\n\n  // TODO: Implement addItem function\n\n  // TODO: Implement removeItem function\n\n  // TODO: Implement updateQuantity function\n\n  // TODO: Calculate total price\n\n  return (\n    <div>\n      <h2>My Shopping Cart (Functional Component)</h2>\n      {/* TODO: Render cart items and total */}\n      {/* TODO: Add controls for addItem, removeItem, updateQuantity */}\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "solutionCode": "import React, { useState, useMemo } from 'react';\n\nfunction ShoppingCart() {\n  const [cartItems, setCartItems] = useState([\n    { id: 1, name: 'Laptop', price: 1200, quantity: 1 },\n    { id: 2, name: 'Mouse', price: 25, quantity: 2 },\n    { id: 3, name: 'Keyboard', price: 75, quantity: 1 }\n  ]);\n\n  const addItem = (itemToAdd) => {\n    setCartItems(prevItems => {\n      const existingItem = prevItems.find(item => item.id === itemToAdd.id);\n      if (existingItem) {\n        // If item exists, update its quantity\n        return prevItems.map(item =>\n          item.id === itemToAdd.id ? { ...item, quantity: item.quantity + 1 } : item\n        );\n      } else {\n        // If item is new, add it to the cart\n        return [...prevItems, { ...itemToAdd, quantity: 1 }];\n      }\n    });\n  };\n\n  const removeItem = (itemId) => {\n    setCartItems(prevItems => prevItems.filter(item => item.id !== itemId));\n  };\n\n  const updateQuantity = (itemId, newQuantity) => {\n    setCartItems(prevItems =>\n      prevItems.map(item =>\n        item.id === itemId ? { ...item, quantity: Math.max(1, newQuantity) } : item\n      )\n    );\n  };\n\n  // Calculate total price using useMemo for performance\n  const total = useMemo(() => {\n    return cartItems.reduce((sum, item) => sum + item.price * item.quantity, 0);\n  }, [cartItems]);\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>My Shopping Cart (Functional Component)</h2>\n      <div>\n        <h3>Items:</h3>\n        {cartItems.length === 0 ? (\n          <p>Your cart is empty.</p>\n        ) : (\n          <ul>\n            {cartItems.map(item => (\n              <li key={item.id} style={{ marginBottom: '10px' }}>\n                {item.name} - ${item.price} x \n                <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>-</button>\n                {item.quantity}\n                <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>+</button>\n                (Subtotal: ${(item.price * item.quantity).toFixed(2)})\n                <button onClick={() => removeItem(item.id)} style={{ marginLeft: '10px', color: 'red' }}>Remove</button>\n              </li>\n            ))}\n          </ul>\n        )}\n        <h3>Total: ${total.toFixed(2)}</h3>\n      </div>\n      <hr />\n      <div>\n        <h4>Add new items:</h4>\n        <button onClick={() => addItem({ id: 4, name: 'Monitor', price: 300 })}>Add Monitor</button>\n        <button onClick={() => addItem({ id: 1, name: 'Laptop', price: 1200 })} style={{ marginLeft: '10px' }}>Add Laptop (existing)</button>\n      </div>\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "testCases": [
            "Initial render: Cart displays sample items and correct total.",
            "Click 'Add Monitor': Monitor should appear with quantity 1, total updates.",
            "Click 'Add Laptop' (existing): Laptop quantity should increment, total updates.",
            "Click '-' button on an item: Quantity decreases, but not below 1. Total updates.",
            "Click '+' button on an item: Quantity increases, total updates.",
            "Click 'Remove' button: Item disappears, total updates.",
            "Remove all items: Cart shows 'empty' message, total is 0.",
            "Verify immutability: Ensure no direct modification of `cartItems` array or item objects."
          ],
          "hints": [
            "When adding or removing items from an array, think about `filter` and spreading the array (`[...array, newItem]`).",
            "When updating an item's property within an array, `map` is your friend. Remember to create a new object for the modified item as well (`{ ...item, key: newValue }`).",
            "Always use the functional form of `setCartItems` to ensure you're working with the latest `prevItems`."
          ],
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState",
            "Complex State",
            "Array State",
            "Immutability",
            "Shopping Cart",
            "Coding Challenge"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_functional_component_state_useState",
            "theory_functional_component_complex_useState"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "javascript_array_methods",
            "react_use_memo"
          ]
        }
      ]
    }
  },
  {
    "id": "95c3d04e-9528-42b0-bc0d-990dd359c4ab",
    "startLine": 3500,
    "endLine": 3599,
    "processedDate": "2025-06-17T08:46:57.355Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_immutable_state_updates",
          "title": "Immutable State Updates for Objects and Nested Objects in React",
          "content": "In React, direct modification of state can lead to unexpected behavior and make debugging difficult. React relies on state immutability to optimize re-renders and ensure predictable data flow. When updating state that contains objects or arrays, you should always create a *new* object or array rather than mutating the existing one. The spread syntax (`...`) is a powerful tool for achieving this.\n\n## Updating Top-Level Object Properties\nWhen a state variable is an object, and you need to update one of its properties, you should spread the existing state object into a new object, and then override the specific property you want to change. This creates a new object with the desired update, preserving the other properties.\n\n## Updating Nested Object Properties\nFor nested objects, the principle remains the same: immutability at every level. You need to create a new object for each level of nesting that you are modifying. This often involves multiple spread operations, working from the outermost object inwards to the property being updated.",
          "examples": [
            {
              "id": "example_immutable_state_1",
              "title": "Updating a Top-Level Object Property",
              "code": "import React, { useState } from 'react';\n\nfunction UserProfileEditor() {\n  const [user, setUser] = useState({\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com'\n  });\n\n  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    // Create a new user object, spreading the old properties\n    // and overriding 'name'\n    setUser({\n      ...user,\n      name: event.target.value\n    });\n  };\n\n  return (\n    <div>\n      <label>Name:</label>\n      <input type=\"text\" value={user.name} onChange={handleNameChange} />\n      <p>Current Name: {user.name}</p>\n      <p>Age: {user.age}</p>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates how to immutably update the `name` property of the `user` state object. `...user` copies all existing properties, and `name: event.target.value` then overwrites the `name` property in the new object. This ensures other properties like `age` and `email` remain unchanged without direct mutation.",
              "language": "typescript"
            },
            {
              "id": "example_immutable_state_2",
              "title": "Updating a Nested Object Property",
              "code": "import React, { useState } from 'react';\n\nfunction UserPreferencesEditor() {\n  const [user, setUser] = useState({\n    name: 'Bob',\n    preferences: {\n      newsletter: false,\n      notifications: true\n    }\n  });\n\n  const toggleNewsletter = () => {\n    // To update 'newsletter', we need to create new objects for:\n    // 1. the 'preferences' object\n    // 2. the top-level 'user' object\n    setUser({\n      ...user, // Copy existing user properties\n      preferences: {\n        ...user.preferences, // Copy existing preferences properties\n        newsletter: !user.preferences.newsletter // Override newsletter\n      }\n    });\n  };\n\n  return (\n    <div>\n      <p>Newsletter Subscription: {user.preferences.newsletter ? 'Subscribed' : 'Not Subscribed'}</p>\n      <button onClick={toggleNewsletter}>Toggle Newsletter</button>\n    </div>\n  );\n}",
              "explanation": "This example shows how to update a nested property (`newsletter`) within the `preferences` object. Notice the nested spread operations: `...user.preferences` creates a new `preferences` object, and then `...user` creates a new `user` object containing the newly created `preferences` object. This ensures immutability at all levels.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_state_1",
            "question_immutable_state_2",
            "question_immutable_state_3",
            "question_immutable_state_4",
            "question_immutable_state_5"
          ],
          "relatedTasks": [
            "task_user_profile_form"
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "JavaScript",
            "ES6"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_Objects",
            "JavaScript_Spread_Syntax",
            "React_useState"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Redux",
            "Context_API",
            "Performance_Optimization"
          ]
        },
        {
          "id": "theory_multiple_state_variables",
          "title": "Managing Multiple State Variables with `useState` Hook",
          "content": "When managing component state in React functional components, developers often face a choice: use a single `useState` call with an object to hold all related state, or use multiple `useState` calls for individual state variables. Both approaches have their merits and can be appropriate depending on the specific use case.\n\n## Single State Object with `useState`\nThis approach involves declaring a single state variable that holds an object. All related pieces of state are properties within this object. When updating any part of this object, you must use the immutable update pattern (spreading the old object and then overwriting the specific property). This can lead to more complex update logic for nested properties but keeps all related state grouped together.\n\n## Multiple `useState` Calls\nThis approach involves declaring a separate `useState` call for each distinct piece of state. For example, `[name, setName]` for a user's name and `[email, setEmail]` for their email. This simplifies individual updates as you just call the corresponding setter function. However, it can lead to many `useState` calls if a component has a large number of independent state variables.\n\n## When to choose which approach?\n*   **Single State Object:** Prefer this when state variables are highly related, frequently updated together, or form a complex, hierarchical data structure. It can make the state more cohesive.\n*   **Multiple `useState` Calls:** Prefer this when state variables are mostly independent, updated separately, and are of simple types (strings, numbers, booleans). It often leads to cleaner update logic for individual pieces of state and can prevent unnecessary re-renders if the `set` function is called with the exact same value.",
          "examples": [
            {
              "id": "example_multiple_state_1",
              "title": "Single State Object Approach",
              "code": "import React, { useState } from 'react';\n\nfunction UserFormSingleState() {\n  const [user, setUser] = useState({\n    name: '',\n    email: '',\n    preferences: {\n      newsletter: false,\n      notifications: true\n    }\n  });\n\n  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUser({ ...user, name: event.target.value });\n  };\n\n  const handleEmailChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUser({ ...user, email: event.target.value });\n  };\n\n  const toggleNewsletter = () => {\n    setUser({\n      ...user,\n      preferences: {\n        ...user.preferences,\n        newsletter: !user.preferences.newsletter\n      }\n    });\n  };\n\n  return (\n    <form>\n      <input type=\"text\" value={user.name} onChange={handleNameChange} placeholder=\"Name\" />\n      <input type=\"email\" value={user.email} onChange={handleEmailChange} placeholder=\"Email\" />\n      <label>\n        <input type=\"checkbox\" checked={user.preferences.newsletter} onChange={toggleNewsletter} />\n        Subscribe to Newsletter\n      </label>\n      <p>Name: {user.name}, Email: {user.email}, Newsletter: {user.preferences.newsletter.toString()}</p>\n    </form>\n  );\n}",
              "explanation": "This example uses a single `user` object to hold all form data. Updates for `name` and `email` are simple, but `newsletter` requires nested spread syntax as seen in the previous theory block. This approach groups related data.",
              "language": "typescript"
            },
            {
              "id": "example_multiple_state_2",
              "title": "Multiple `useState` Calls Approach",
              "code": "import React, { useState } from 'react';\n\nfunction UserFormMultipleState() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [preferences, setPreferences] = useState({\n    newsletter: false,\n    notifications: true\n  });\n\n  const toggleNewsletter = () => {\n    setPreferences({ ...preferences, newsletter: !preferences.newsletter });\n  };\n\n  return (\n    <form>\n      <input type=\"text\" value={name} onChange={(e) => setName(e.target.value)} placeholder=\"Name\" />\n      <input type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} placeholder=\"Email\" />\n      <label>\n        <input type=\"checkbox\" checked={preferences.newsletter} onChange={toggleNewsletter} />\n        Subscribe to Newsletter\n      </label>\n      <p>Name: {name}, Email: {email}, Newsletter: {preferences.newsletter.toString()}</p>\n    </form>\n  );\n}",
              "explanation": "Here, `name`, `email`, and `preferences` are separate state variables. Each has its own setter, making individual updates straightforward (`setName`, `setEmail`). The `preferences` object still requires immutable updates, but it's isolated to that specific state variable.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_multiple_state_1",
            "question_multiple_state_2",
            "question_multiple_state_3",
            "question_multiple_state_4"
          ],
          "relatedTasks": [
            "task_user_profile_form"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State Management",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Functional_Components",
            "React_useState"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "React_Forms",
            "Complex_UIs"
          ]
        },
        {
          "id": "theory_immutable_array_manipulation",
          "title": "Immutable Array Manipulation in React State",
          "content": "Just like objects, arrays in React state should be treated immutably. Modifying an array directly (e.g., using `push`, `pop`, `splice`) will not trigger a re-render and can lead to bugs because React's shallow comparison might not detect the change. Instead, you should always return a *new* array with the desired modifications.\n\n## Common Immutable Array Operations\n*   **Adding Elements:** Use the spread syntax (`...`) to create a new array with existing elements and the new element(s). Example: `[...oldArray, newElement]` or `[newElement, ...oldArray]`.\n*   **Removing Elements:** Use the `filter()` method, which always returns a new array containing only the elements that pass a provided test. This is ideal for removing items by index or by a specific property (like an ID).\n*   **Updating Elements:** Use `map()` to iterate over the array and return a new array with the updated element(s). Example: `oldArray.map(item => item.id === idToUpdate ? { ...item, updatedProp: newValue } : item)`.\n*   **Concatenating Arrays:** Use `concat()` or spread syntax. Example: `array1.concat(array2)` or `[...array1, ...array2]`.\n*   **Sorting Arrays:** Create a shallow copy first using `slice()` or spread syntax before calling `sort()`. Example: `[...oldArray].sort((a,b) => a.value - b.value)`.",
          "examples": [
            {
              "id": "example_immutable_array_1",
              "title": "Removing an Array Element by Index (Filter)",
              "code": "import React, { useState } from 'react';\n\nfunction ItemListByIndex() {\n  const [data, setData] = useState(['Apple', 'Banana', 'Cherry', 'Date']);\n\n  const removeItemByIndex = (indexToRemove: number) => {\n    setData(\n      data.filter((_, i) => i !== indexToRemove) // Filter out the item at the specified index\n    );\n  };\n\n  return (\n    <div>\n      <h3>Items:</h3>\n      <ul>\n        {data.map((item, index) => (\n          <li key={index}>\n            {item}\n            <button onClick={() => removeItemByIndex(index)}>Remove</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates removing an element by its index using `filter`. The `filter` method iterates over the array and creates a new array containing all elements except the one at `indexToRemove`. This is an immutable operation.",
              "language": "typescript"
            },
            {
              "id": "example_immutable_array_2",
              "title": "Removing an Array Element by ID (Filter)",
              "code": "import React, { useState } from 'react';\n\ninterface Item { id: number; name: string; }\n\nfunction ItemListById() {\n  const [data, setData] = useState<Item[]>([\n    { id: 1, name: 'Laptop' },\n    { id: 2, name: 'Keyboard' },\n    { id: 3, name: 'Mouse' }\n  ]);\n\n  const removeItemById = (idToRemove: number) => {\n    setData(\n      data.filter(item => item.id !== idToRemove) // Filter out the item with the specified ID\n    );\n  };\n\n  return (\n    <div>\n      <h3>Products:</h3>\n      <ul>\n        {data.map(item => (\n          <li key={item.id}>\n            {item.name}\n            <button onClick={() => removeItemById(item.id)}>Remove</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "Similar to removing by index, `filter` is used here to remove an item based on a unique `id` property. This is a common and robust way to remove items from an array in a React application, ensuring state immutability.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_array_1",
            "question_immutable_array_2",
            "question_immutable_array_3",
            "question_immutable_array_4"
          ],
          "relatedTasks": [
            "task_todo_list_manager"
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Array Methods",
            "JavaScript"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_Arrays",
            "JavaScript_Array_Methods",
            "React_useState"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex_Lists",
            "Data_Manipulation"
          ]
        },
        {
          "id": "theory_refs_dom_manipulation",
          "title": "Direct DOM Manipulation with Refs in React",
          "content": "While React encourages a declarative approach to UI development, there are scenarios where direct interaction with the DOM element is necessary. These include managing focus, text selection, media playback, triggering imperative animations, or integrating with third-party DOM libraries. React provides `refs` (short for 'references') for this purpose.\n\n## Refs in Class Components\nIn class components, refs are typically created using `React.createRef()` in the constructor or a callback ref. The ref is then attached to an element's `ref` attribute in the `render` method. The current DOM node can be accessed via `this.refName.current` after the component has mounted (e.g., in `componentDidMount`). Callback refs give more fine-grained control, allowing a function to be executed directly with the DOM node as an argument.\n\n## Refs in Functional Components (with `useRef`)\nIn functional components, the `useRef` hook provides a way to create a mutable `ref` object. This object will persist for the full lifetime of the component. The `ref` object has a `current` property that initially holds `null` and will point to the DOM element once it's rendered. To trigger actions after the component mounts or updates, `useEffect` is typically used in conjunction with `useRef`.\n\n## When to Use Refs?\n*   Managing focus, text selection, or media playback.\n*   Triggering imperative animations.\n*   Integrating with third-party DOM libraries.\n*   Measuring the size or position of a DOM element.\n\n**Avoid using refs for anything that can be done declaratively.** For example, don't use refs to change styling or content if state and props can achieve the same result.",
          "examples": [
            {
              "id": "example_refs_class_component",
              "title": "Focusing Input using Class Component Ref",
              "code": "import React from 'react';\n\nclass AutoFocusFormClass extends React.Component {\n  private nameInput: HTMLInputElement | null = null; // Declare type for better safety\n\n  componentDidMount() {\n    // Focus the input element when component mounts\n    if (this.nameInput) {\n      this.nameInput.focus();\n    }\n  }\n\n  render() {\n    return (\n      <form>\n        <p>Class Component Example:</p>\n        <input \n          ref={(input) => { this.nameInput = input; }} // Callback Ref\n          defaultValue=\"Will be focused on load (Class)\"\n        />\n      </form>\n    );\n  }\n}",
              "explanation": "This example uses a callback ref in a class component. The `ref` attribute is assigned a function that receives the DOM element (`input`) as an argument. This element is then stored in `this.nameInput`. In `componentDidMount`, after the component is rendered and the DOM element is available, `focus()` is called on it.",
              "language": "typescript"
            },
            {
              "id": "example_refs_functional_component",
              "title": "Focusing Input using Functional Component Ref with `useRef`",
              "code": "import React, { useRef, useEffect } from 'react';\n\nfunction AutoFocusFormHooks() {\n  const inputRef = useRef<HTMLInputElement>(null); // Initialize with null, specify type\n  \n  useEffect(() => {\n    // Focus the input element when component mounts\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array means this runs once on mount\n  \n  return (\n    <form>\n      <p>Functional Component Example:</p>\n      <input \n        ref={inputRef} // Assign the ref object to the element\n        defaultValue=\"Will be focused on load (Hooks)\"\n      />\n    </form>\n  );\n}",
              "explanation": "This example uses the `useRef` hook in a functional component. `inputRef` is a mutable object whose `current` property will hold the DOM node. `useEffect` with an empty dependency array ensures the `focus()` call happens only once after the initial render, when `inputRef.current` has been assigned the actual DOM input element.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_refs_1",
            "question_refs_2",
            "question_refs_3",
            "question_refs_4"
          ],
          "relatedTasks": [
            "task_autofocus_input",
            "task_media_player_control"
          ],
          "tags": [
            "React",
            "Refs",
            "DOM Manipulation",
            "Hooks",
            "useEffect",
            "useRef"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components_Lifecycle",
            "React_Hooks_Fundamentals"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Accessibility",
            "Integration_with_Legacy_Code"
          ]
        },
        {
          "id": "theory_https_development",
          "title": "Using HTTPS in Development",
          "content": "While often overlooked during local development, using HTTPS (Hypertext Transfer Protocol Secure) is crucial for a complete and secure development experience, especially when dealing with APIs, authentication, or features that require a secure context (like Geolocation, Service Workers, WebAuthn, or certain browser APIs).\n\n## Why Use HTTPS in Development?\n1.  **Security Consistency:** Mirrors production environment more closely, preventing issues that might arise only when switching from HTTP to HTTPS (e.g., mixed content warnings, API endpoint discrepancies).\n2.  **API Compatibility:** Many modern APIs (especially payment gateways, authentication providers, or services requiring OAuth) mandate secure contexts and will refuse to work over plain HTTP.\n3.  **Browser Features:** Features like Service Workers (for Progressive Web Apps), Web Push Notifications, Geolocation, or `navigator.clipboard.writeText()` often require a secure context. Using HTTPS locally enables you to test these features fully.\n4.  **Cookie Security:** `Secure` and `SameSite=None` cookies only work over HTTPS. If your application relies on these, developing with HTTP can lead to unexpected behavior.\n5.  **Avoiding Mixed Content:** If your frontend is served over HTTPS in production but fetches resources (images, scripts, API calls) from HTTP endpoints, browsers will block these requests as 'mixed content', leading to broken functionality. Developing with HTTPS helps catch such issues early.\n\n## How to Enable HTTPS for Local Development?\nMost modern frontend development tools and frameworks provide built-in ways to enable HTTPS, often using self-signed certificates. These certificates are generated locally and are trusted by your browser during development (though they'll show a warning initially, which you can usually bypass for local domains).\n\n*   **Create React App (CRA):** Set the `HTTPS` environment variable to `true` when starting the development server. E.g., `HTTPS=true npm start`.\n*   **Next.js:** Next.js doesn't have a built-in `HTTPS` flag for `next dev`. You typically need to use a proxy, a tool like `mkcert`, or a custom server configuration to serve it over HTTPS.\n*   **Vite:** Configure `server.https: true` in your `vite.config.ts`. You might also need to install `@vitejs/plugin-basic-ssl` or use `mkcert`.\n*   **Vue CLI:** Similar to CRA, you can usually pass a `--https` flag or configure `vue.config.js`.\n*   **`mkcert`:** A simple tool to create locally trusted development certificates. You can use it to generate certificates for `localhost` and then configure your development server (e.g., Webpack Dev Server, Express server) to use these certificates.\n\n```bash\n# Example using mkcert\nbrew install mkcert # on macOS, or follow instructions for your OS\nmkcert -install\nmkcert localhost 127.0.0.1 ::1 myapp.local\n# This generates localhost.pem and localhost-key.pem (or similar) in your current directory\n# Then configure your dev server (e.g., in webpack.config.js or express server):\n```\n\n```javascript\n// Example: Using generated certificates with an Express server\nconst express = require('express');\nconst https = require('https');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\nconst port = 3000;\n\n// Point to your generated certificates\nconst options = {\n  key: fs.readFileSync(path.resolve(__dirname, 'localhost-key.pem')),\n  cert: fs.readFileSync(path.resolve(__dirname, 'localhost.pem'))\n};\n\napp.get('/', (req, res) => {\n  res.send('Hello from HTTPS!');\n});\n\nhttps.createServer(options, app).listen(port, () => {\n  console.log(`HTTPS server running on https://localhost:${port}`);\n});\n```",
          "examples": [],
          "relatedQuestions": [
            "question_https_dev_1",
            "question_https_dev_2",
            "question_https_dev_3"
          ],
          "relatedTasks": [
            "task_setup_https_dev"
          ],
          "tags": [
            "HTTPS",
            "Development",
            "Security",
            "Web_Development",
            "Browser_APIs",
            "Tooling"
          ],
          "technology": "Web Development",
          "prerequisites": [
            "Networking_Basics",
            "Web_Servers"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "PWA_Development",
            "Authentication_Systems",
            "API_Integration"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_immutable_state_1",
          "topic": "Immutable State Updates",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is it important to update React state immutably, especially for objects and arrays?",
          "answer": "Updating state immutably ensures that React's shallow comparison (used for performance optimizations like `PureComponent` or `React.memo`) correctly detects changes and triggers re-renders. It also prevents unexpected side effects and makes debugging easier by ensuring a predictable state flow.",
          "analysisPoints": [
            "React's rendering mechanism relies on reference equality.",
            "Prevents side effects and promotes predictable state.",
            "Enables performance optimizations like `PureComponent` and `React.memo`."
          ],
          "keyConcepts": [
            "Immutability",
            "React State",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of React's rendering mechanism",
            "Awareness of side effects"
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "Immutability"
          ],
          "prerequisites": [
            "React_State_Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_state_2",
          "topic": "Immutable State Updates",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React component state, which of the following is the correct way to update only the `city` property within the `address` object without mutating the original state?",
          "answer": "Option A",
          "options": [
            "A. `setUser(prevUser => ({ ...prevUser, address: { ...prevUser.address, city: 'New York' } }));`",
            "B. `user.address.city = 'New York'; setUser(user);`",
            "C. `setUser({ ...user, city: 'New York' });`",
            "D. `setUser(user.address.city = 'New York');`"
          ],
          "analysisPoints": [
            "Correctly identifies the need for nested spread syntax.",
            "Understands that direct mutation (Option B) is incorrect.",
            "Recognizes that `city` is nested, so updating at the top level (Option C) is incorrect.",
            "Option D attempts to assign a value directly to a nested property as the new state, which is syntactically and logically wrong."
          ],
          "keyConcepts": [
            "Immutability",
            "Nested State Updates",
            "Spread Syntax",
            "React State"
          ],
          "evaluationCriteria": [
            "Ability to apply immutable update patterns.",
            "Understanding of object spread syntax.",
            "Distinguishing between mutable and immutable operations."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction UserProfile() {\n  const [user, setUser] = useState({\n    name: 'Jane Doe',\n    address: {\n      street: '123 Main St',\n      city: 'Anytown',\n      zip: '12345'\n    }\n  });\n\n  const updateCity = () => {\n    setUser(prevUser => ({\n      ...prevUser, // Spread the top-level user object\n      address: {\n        ...prevUser.address, // Spread the nested address object\n        city: 'New York' // Override the city property\n      }\n    }));\n  };\n\n  return (\n    <div>\n      <p>Current City: {user.address.city}</p>\n      <button onClick={updateCity}>Move to New York</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "MCQ"
          ],
          "prerequisites": [
            "JavaScript_Objects",
            "React_useState"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_state_3",
          "topic": "Immutable State Updates",
          "level": "hard",
          "type": "code",
          "question": "Implement a `handleFormChange` function for a complex form state. The function should take an `event` object (from an input change) and immutably update the state. The state can have nested objects. Assume input `name` attributes map directly to state paths (e.g., `name=\"user.address.street\"` for `state.user.address.street`). You may need to parse the `name` attribute to correctly update the nested property. If the name is simple (e.g., `name=\"firstName\"`), treat it as a top-level property.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Ability to handle dynamic updates for nested state.",
            "Correct use of recursion or iterative approach for deep updates.",
            "Maintaining immutability at all levels.",
            "Handling edge cases like non-existent paths or top-level properties."
          ],
          "keyConcepts": [
            "Immutability",
            "Dynamic State Updates",
            "Nested Objects",
            "Recursion",
            "Spread Syntax"
          ],
          "evaluationCriteria": [
            "Correctness of the immutable update logic.",
            "Efficiency of path parsing and state update.",
            "Robustness to different `name` attribute formats.",
            "Readability and maintainability of code."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction ComplexForm() {\n  const [formData, setFormData] = useState({\n    personal: {\n      firstName: '',\n      lastName: '',\n      age: 0\n    },\n    contact: {\n      email: '',\n      phone: ''\n    },\n    address: {\n      street: '',\n      city: '',\n      zip: ''\n    }\n  });\n\n  const handleFormChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = event.target;\n\n    setFormData(prevFormData => {\n      const keys = name.split('.');\n      let newFormData = { ...prevFormData };\n      let currentLevel: any = newFormData;\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (i === keys.length - 1) {\n          // Last key, update the value\n          currentLevel[key] = value;\n        } else {\n          // Not the last key, deep copy the nested object\n          currentLevel[key] = { ...currentLevel[key] };\n          currentLevel = currentLevel[key];\n        }\n      }\n      return newFormData;\n    });\n  };\n\n  return (\n    <form>\n      <h3>Personal Info</h3>\n      <input name=\"personal.firstName\" value={formData.personal.firstName} onChange={handleFormChange} placeholder=\"First Name\" />\n      <input name=\"personal.lastName\" value={formData.personal.lastName} onChange={handleFormChange} placeholder=\"Last Name\" />\n      <input name=\"personal.age\" type=\"number\" value={formData.personal.age} onChange={handleFormChange} placeholder=\"Age\" />\n\n      <h3>Contact Info</h3>\n      <input name=\"contact.email\" value={formData.contact.email} onChange={handleFormChange} placeholder=\"Email\" />\n      <input name=\"contact.phone\" value={formData.contact.phone} onChange={handleFormChange} placeholder=\"Phone\" />\n\n      <h3>Address</h3>\n      <input name=\"address.street\" value={formData.address.street} onChange={handleFormChange} placeholder=\"Street\" />\n      <input name=\"address.city\" value={formData.address.city} onChange={handleFormChange} placeholder=\"City\" />\n      <input name=\"address.zip\" value={formData.address.zip} onChange={handleFormChange} placeholder=\"Zip Code\" />\n\n      <pre>{JSON.stringify(formData, null, 2)}</pre>\n    </form>\n  );\n}\n```",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Coding Challenge",
            "Advanced"
          ],
          "prerequisites": [
            "JavaScript_Objects",
            "JavaScript_Array_Methods",
            "React_useState"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_state_4",
          "topic": "Immutable State Updates",
          "level": "medium",
          "type": "open",
          "question": "Discuss the potential performance implications of incorrect state updates (i.e., mutating state directly) versus correct immutable state updates in a large React application. How does React's reconciliation process relate to this?",
          "answer": "Directly mutating state can lead to several performance issues. React's reconciliation algorithm relies on shallow comparisons of state and props to determine if a component needs to re-render. If you mutate an object or array directly, its reference in memory remains the same, even though its contents have changed. React's shallow comparison will then incorrectly assume that the state has not changed, leading to: \n1. **Missed Re-renders:** Components that *should* update based on the mutated data might not, causing UI inconsistencies.\n2. **Unnecessary Re-renders (less common but possible):** If a parent component re-renders for another reason, the child might still re-render even if its props/state *appear* unchanged to React, but the underlying mutated data might cause issues.\n\nImmutable updates, by contrast, always create new references for changed data. This allows React's shallow comparison to accurately detect that the state (or props derived from state) has changed, triggering the necessary re-renders and enabling optimizations like `PureComponent` or `React.memo` (which internally use shallow comparisons) to prevent unnecessary re-renders for components whose props/state truly haven't changed. This predictable behavior is crucial for performance in complex applications.",
          "analysisPoints": [
            "Explain React's shallow comparison.",
            "Describe how direct mutation fools the reconciliation.",
            "Explain how immutable updates provide new references for comparison.",
            "Mention performance benefits (or pitfalls) with `PureComponent`/`React.memo`."
          ],
          "keyConcepts": [
            "React Reconciliation",
            "Shallow Comparison",
            "Immutability",
            "Performance Optimization",
            "PureComponent",
            "React.memo"
          ],
          "evaluationCriteria": [
            "Depth of understanding of React's internal mechanisms.",
            "Ability to link abstract concepts to practical performance implications.",
            "Clarity and completeness of explanation."
          ],
          "example": "",
          "tags": [
            "React",
            "Performance",
            "State Management",
            "Immutability",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_Reconciliation",
            "React_Optimization"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_state_5",
          "topic": "Immutable State Updates",
          "level": "easy",
          "type": "flashcard",
          "question": "What JavaScript syntax is commonly used for immutably updating objects and arrays in React state?",
          "answer": "The spread syntax (`...`) is commonly used for immutably updating objects and arrays.",
          "analysisPoints": [
            "Identifies the primary JavaScript syntax.",
            "Connects syntax to the concept of immutability."
          ],
          "keyConcepts": [
            "Spread Syntax",
            "Immutability",
            "JavaScript"
          ],
          "evaluationCriteria": [
            "Recall of key syntax"
          ],
          "example": "",
          "tags": [
            "React",
            "JavaScript",
            "Flashcard"
          ],
          "prerequisites": [
            "JavaScript_ES6"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_multiple_state_1",
          "topic": "Managing Multiple State Variables",
          "level": "easy",
          "type": "flashcard",
          "question": "What are two common ways to manage multiple related pieces of state in a React functional component using the `useState` hook?",
          "answer": "1. Using a single `useState` call with an object to hold all related state.\n2. Using multiple separate `useState` calls for individual state variables.",
          "analysisPoints": [
            "Identifies both major patterns.",
            "Distinguishes between object-based and individual `useState`."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "React Hooks"
          ],
          "evaluationCriteria": [
            "Recall of common patterns"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Flashcard"
          ],
          "prerequisites": [
            "React_useState"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_multiple_state_2",
          "topic": "Managing Multiple State Variables",
          "level": "medium",
          "type": "mcq",
          "question": "Consider a form with `firstName`, `lastName`, and `email` fields. Which `useState` approach is generally simpler for updating *individual* fields, and why?",
          "answer": "B. Multiple `useState` calls, because each field has its own dedicated setter function, simplifying updates.",
          "options": [
            "A. A single `useState` object, because all related data is grouped.",
            "B. Multiple `useState` calls, because each field has its own dedicated setter function, simplifying updates.",
            "C. A single `useState` object, because it reduces the number of hook calls.",
            "D. Multiple `useState` calls, because it forces immutable updates automatically."
          ],
          "analysisPoints": [
            "Correctly identifies that multiple `useState` calls simplify individual updates.",
            "Understands that while a single object groups data, it complicates individual updates due to spread syntax.",
            "Clarifies that immutability is a developer responsibility, not automatically enforced by the choice of `useState` structure.",
            "Option C is a valid point about reducing hook calls, but B directly answers 'simpler for updating *individual* fields'."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "Form Handling",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Understanding of practical implications of each `useState` pattern.",
            "Ability to weigh pros and cons for specific scenarios."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction SimpleForm() {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n\n  // To update firstName:\n  // setName(e.target.value); // Simple and direct\n\n  // If it was a single object: { name: { first, last } }\n  // setFormData(prev => ({ ...prev, name: { ...prev.name, first: e.target.value } })); // More verbose\n\n  return (\n    <form>\n      <input type=\"text\" value={firstName} onChange={(e) => setFirstName(e.target.value)} placeholder=\"First Name\" />\n      <input type=\"text\" value={lastName} onChange={(e) => setLastName(e.target.value)} placeholder=\"Last Name\" />\n    </form>\n  );\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "State Management",
            "MCQ"
          ],
          "prerequisites": [
            "React_useState"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_multiple_state_3",
          "topic": "Managing Multiple State Variables",
          "level": "medium",
          "type": "open",
          "question": "In what scenarios would using a single state object with `useState` be more advantageous than using multiple individual `useState` calls? Provide an example.",
          "answer": "A single state object with `useState` is more advantageous when:\n\n1.  **Related Data:** The pieces of state are logically grouped and frequently updated together as a cohesive unit. For instance, a user's entire profile information (name, age, address, preferences) often makes sense as one object.\n2.  **Complex or Nested Structures:** When the state has a deep or hierarchical structure (e.g., a form with sections and sub-sections), managing it as one object can sometimes make it easier to reason about the overall data structure, even if individual updates require nested spreads.\n3.  **Reducer Pattern:** If the state updates become complex and involve multiple related changes, converting to `useReducer` later is often smoother when the state is already structured as a single object.\n\n**Example:** Consider a drawing application where the state represents the current drawing canvas, including active tool, brush size, color, and a list of drawn shapes. These are all tightly coupled to the drawing context.\n\n```typescript\nimport React, { useState } from 'react';\n\ninterface DrawingState {\n  activeTool: 'pen' | 'eraser' | 'fill';\n  brushSize: number;\n  color: string;\n  shapes: { id: string; type: string; coordinates: number[]; color: string; }[];\n}\n\nfunction DrawingCanvas() {\n  const [drawingState, setDrawingState] = useState<DrawingState>({\n    activeTool: 'pen',\n    brushSize: 5,\n    color: '#000000',\n    shapes: []\n  });\n\n  const changeTool = (tool: DrawingState['activeTool']) => {\n    setDrawingState(prev => ({ ...prev, activeTool: tool }));\n  };\n\n  const addShape = (newShape: DrawingState['shapes'][0]) => {\n    setDrawingState(prev => ({ ...prev, shapes: [...prev.shapes, newShape] }));\n  };\n\n  return (\n    <div>\n      {/* UI for tools, brush size, color */}\n      <button onClick={() => changeTool('eraser')}>Eraser</button>\n      <button onClick={() => addShape({ id: 's1', type: 'circle', coordinates: [10, 20, 5], color: drawingState.color })}>Add Circle</button>\n      <p>Active Tool: {drawingState.activeTool}</p>\n      <p>Shapes count: {drawingState.shapes.length}</p>\n    </div>\n  );\n}\n```\nIn this example, `activeTool`, `brushSize`, `color`, and `shapes` are all part of the `drawingState` context. While individual updates are possible, keeping them within one object reflects their conceptual relationship to the drawing canvas.",
          "analysisPoints": [
            "Identify scenarios for single object (related data, complex structure).",
            "Provide a clear, relevant example demonstrating the advantage.",
            "Discuss `useReducer` as a natural progression."
          ],
          "keyConcepts": [
            "useState",
            "State Management Patterns",
            "useReducer",
            "Cohesion"
          ],
          "evaluationCriteria": [
            "Ability to identify appropriate use cases.",
            "Demonstration of understanding through examples.",
            "Logical reasoning for architectural choices."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "State Management",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_multiple_state_4",
          "topic": "Managing Multiple State Variables",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a potential downside of using a single state object for many unrelated state variables in a React functional component?",
          "answer": "A potential downside is that updates to any single property within the object require spreading the entire object, which can lead to more verbose update logic, especially for deeply nested properties. It can also potentially cause unnecessary re-renders if not handled carefully, though React's batching helps mitigate this for simple cases.",
          "analysisPoints": [
            "Focus on the verbosity of updates.",
            "Mention potential re-render issues (less critical with modern React, but still a conceptual point)."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "Immutability",
            "Verbosity"
          ],
          "evaluationCriteria": [
            "Recall of disadvantages"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Flashcard"
          ],
          "prerequisites": [
            "React_useState"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_array_1",
          "topic": "Immutable Array Manipulation",
          "level": "easy",
          "type": "flashcard",
          "question": "Which JavaScript array method is commonly used to immutably remove elements from an array?",
          "answer": "The `filter()` method is commonly used to immutably remove elements from an array.",
          "analysisPoints": [
            "Correctly identifies `filter`.",
            "Connects `filter` to immutability."
          ],
          "keyConcepts": [
            "Array Methods",
            "Immutability",
            "filter"
          ],
          "evaluationCriteria": [
            "Recall of key array methods"
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Arrays",
            "Flashcard"
          ],
          "prerequisites": [
            "JavaScript_Arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_array_2",
          "topic": "Immutable Array Manipulation",
          "level": "medium",
          "type": "mcq",
          "question": "You have a list of `todos` as a state variable: `const [todos, setTodos] = useState([{ id: 1, text: 'Learn React' }, { id: 2, text: 'Build Project' }]);`. Which code snippet correctly removes the todo with `id: 1` immutably?",
          "answer": "B. `setTodos(todos.filter(todo => todo.id !== 1));`",
          "options": [
            "A. `todos.splice(0, 1); setTodos(todos);`",
            "B. `setTodos(todos.filter(todo => todo.id !== 1));`",
            "C. `setTodos([...todos.slice(1)]);`",
            "D. `const newTodos = todos; newTodos.pop(); setTodos(newTodos);`"
          ],
          "analysisPoints": [
            "Option A mutates the original array and then sets the same reference, leading to potential issues.",
            "Option B correctly uses `filter` to create a new array without the specified item.",
            "Option C would remove the first element by index, not by ID, and is not a general solution for removing a specific item.",
            "Option D mutates the array via `pop()` and then sets the same reference, which is incorrect for immutability.",
            "Emphasizes the use of `filter` for conditional removal."
          ],
          "keyConcepts": [
            "Immutability",
            "Array Methods",
            "filter",
            "React State"
          ],
          "evaluationCriteria": [
            "Ability to choose the correct immutable array operation.",
            "Understanding of side effects of mutable array methods."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\ninterface Todo { id: number; text: string; completed: boolean; }\n\nfunction TodoList() {\n  const [todos, setTodos] = useState<Todo[]>([\n    { id: 1, text: 'Learn React', completed: false },\n    { id: 2, text: 'Build Project', completed: false },\n    { id: 3, text: 'Deploy App', completed: false }\n  ]);\n\n  const removeTodo = (idToRemove: number) => {\n    setTodos(todos.filter(todo => todo.id !== idToRemove));\n  };\n\n  return (\n    <div>\n      {todos.map(todo => (\n        <div key={todo.id}>\n          {todo.text}\n          <button onClick={() => removeTodo(todo.id)}>X</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "MCQ",
            "Arrays"
          ],
          "prerequisites": [
            "JavaScript_Arrays",
            "React_useState"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_array_3",
          "topic": "Immutable Array Manipulation",
          "level": "hard",
          "type": "code",
          "question": "You have a list of `products` in state, each with an `id`, `name`, and `price`. Implement a function `updateProductPrice(id: number, newPrice: number)` that immutably updates the price of a specific product by its ID. Also, implement `sortProductsByName()` that immutably sorts the products alphabetically by name.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly uses `map()` for updating an item in an array.",
            "Correctly uses spread syntax to update the item object itself within `map()`.",
            "Correctly uses `slice()` or spread `[...]` to create a shallow copy before sorting.",
            "Demonstrates understanding of immutable array operations for both modification and reordering."
          ],
          "keyConcepts": [
            "Immutability",
            "Array Methods",
            "map",
            "sort",
            "React State"
          ],
          "evaluationCriteria": [
            "Correctness and immutability of `updateProductPrice`.",
            "Correctness and immutability of `sortProductsByName`.",
            "Efficiency of the operations.",
            "Readability of the code."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\ninterface Product { id: number; name: string; price: number; }\n\nfunction ProductCatalog() {\n  const [products, setProducts] = useState<Product[]>([\n    { id: 1, name: 'Laptop', price: 1200 },\n    { id: 2, name: 'Mouse', price: 25 },\n    { id: 3, name: 'Keyboard', price: 75 }\n  ]);\n\n  const updateProductPrice = (id: number, newPrice: number) => {\n    setProducts(products.map(product => \n      product.id === id \n        ? { ...product, price: newPrice } // Create new product object with updated price\n        : product // Return original product if not the one to update\n    ));\n  };\n\n  const sortProductsByName = () => {\n    setProducts([...products].sort((a, b) => a.name.localeCompare(b.name))); // Create shallow copy before sorting\n  };\n\n  return (\n    <div>\n      <button onClick={() => updateProductPrice(1, 1250)}>Update Laptop Price</button>\n      <button onClick={sortProductsByName}>Sort by Name</button>\n      <h3>Products:</h3>\n      <ul>\n        {products.map(product => (\n          <li key={product.id}>\n            {product.name} - ${product.price}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Coding Challenge",
            "Arrays"
          ],
          "prerequisites": [
            "JavaScript_Arrays",
            "React_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_array_4",
          "topic": "Immutable Array Manipulation",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between `array.sort()` and `[...array].sort()` in the context of React state updates. Why is the latter generally preferred?",
          "answer": "`array.sort()` is a **mutable** array method. It sorts the array *in place*, meaning it modifies the original array and returns a reference to that same modified array. If you use `array.sort()` directly on a state array in React, you are mutating the state without changing its reference. React's shallow comparison will not detect a change, and therefore, the component might not re-render, leading to an inconsistent UI.\n\n`[...array].sort()` on the other hand, first uses the spread syntax (`...`) to create a **shallow copy** of the original array. Then, the `sort()` method is called on this *new* copy. This means the original array in state remains untouched, and a brand new array (the sorted copy) is returned. When this new array is set as the state, React's shallow comparison detects a change in the array's reference, triggering a re-render and ensuring the UI reflects the sorted data.\n\nThe latter (`[...array].sort()`) is preferred because it adheres to React's principle of immutability, ensuring predictable state updates and proper re-rendering behavior.",
          "analysisPoints": [
            "Clearly differentiate mutable (`array.sort()`) vs. immutable (`[...array].sort()`).",
            "Explain the effect on array reference and React's reconciliation.",
            "Emphasize why immutability is important for `sort`."
          ],
          "keyConcepts": [
            "Immutability",
            "Array Methods",
            "sort",
            "Spread Syntax",
            "React Reconciliation"
          ],
          "evaluationCriteria": [
            "Clear explanation of mutable vs. immutable array operations.",
            "Understanding of how these relate to React's rendering."
          ],
          "example": "",
          "tags": [
            "React",
            "JavaScript",
            "Arrays",
            "Immutability",
            "Open-Ended"
          ],
          "prerequisites": [
            "JavaScript_Arrays",
            "React_State_Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_1",
          "topic": "Direct DOM Manipulation with Refs",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `refs` in React?",
          "answer": "The primary purpose of `refs` in React is to provide a way to access DOM nodes or React elements created in the `render` method imperatively. They are typically used for direct DOM manipulation when declarative approaches are not sufficient.",
          "analysisPoints": [
            "Defines the core function of refs.",
            "Highlights the imperative nature."
          ],
          "keyConcepts": [
            "Refs",
            "DOM Manipulation",
            "Imperative Programming"
          ],
          "evaluationCriteria": [
            "Recall of fundamental concept"
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_refs_2",
          "topic": "Direct DOM Manipulation with Refs",
          "level": "medium",
          "type": "mcq",
          "question": "When should you generally *avoid* using `refs` in React?",
          "answer": "C. To change the appearance or content of a component based on state or props.",
          "options": [
            "A. When you need to manage focus, text selection, or media playback.",
            "B. When integrating with third-party DOM libraries.",
            "C. To change the appearance or content of a component based on state or props.",
            "D. When triggering imperative animations on a DOM element."
          ],
          "analysisPoints": [
            "Options A, B, and D describe valid use cases for refs (imperative scenarios).",
            "Option C describes a declarative task (UI changes based on data) that should be handled with state and props, not direct DOM manipulation via refs.",
            "Reinforces the 'declarative first' principle in React."
          ],
          "keyConcepts": [
            "Refs",
            "Declarative vs Imperative",
            "React Best Practices",
            "State vs. Props"
          ],
          "evaluationCriteria": [
            "Understanding of appropriate and inappropriate ref usage.",
            "Adherence to React's declarative paradigm."
          ],
          "example": "```typescript\n// Avoid using refs for this:\n// function MyComponent() {\n//   const divRef = useRef(null);\n//   useEffect(() => {\n//     if (someCondition) {\n//       divRef.current.style.backgroundColor = 'red'; // Bad practice for simple styling\n//     }\n//   }, [someCondition]);\n//   return <div ref={divRef}>Hello</div>;\n// }\n\n// Do this instead:\nfunction MyComponent({ someCondition }: { someCondition: boolean }) {\n  const backgroundColor = someCondition ? 'red' : 'blue';\n  return <div style={{ backgroundColor }}>Hello</div>;\n}\n```",
          "tags": [
            "React",
            "Refs",
            "Best Practices",
            "MCQ"
          ],
          "prerequisites": [
            "React_State_Props"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_3",
          "topic": "Direct DOM Manipulation with Refs",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast how refs are created and accessed in class components versus functional components. Include a discussion of the lifecycle implications for accessing the DOM node.",
          "answer": "### Class Components\n*   **Creation:** Refs can be created using `React.createRef()` in the constructor and assigned to an instance property (e.g., `this.myRef = React.createRef();`). Alternatively, a 'callback ref' can be used, where the `ref` attribute is set to a function that receives the DOM node (or component instance) directly (e.g., `<input ref={node => this.myInput = node} />`).\n*   **Access:** The DOM node is accessed via `this.myRef.current` for `createRef` or directly via the instance property (e.g., `this.myInput`) for callback refs.\n*   **Lifecycle Implications:** The ref's `current` property is guaranteed to be populated with the DOM node after the component has mounted. Therefore, you should typically access refs in `componentDidMount` for initial interactions, and potentially in `componentDidUpdate` if the ref itself or related props change.\n\n### Functional Components\n*   **Creation:** Refs are created using the `useRef` hook: `const myRef = useRef(null);`. `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`null` in this case). This object persists across re-renders.\n*   **Access:** The DOM node is accessed via `myRef.current`.\n*   **Lifecycle Implications:** `myRef.current` is guaranteed to be assigned the DOM node *after* the component has rendered. Therefore, to perform actions that require the DOM node (like focusing an input), you should wrap the logic in a `useEffect` hook. If the effect needs to run only once on mount, use an empty dependency array (`[]`). If it needs to re-run when specific dependencies change, include them in the dependency array.\n\n**Comparison:**\n*   **Syntax:** Class components use `React.createRef()` or callback functions; functional components use `useRef`.\n*   **Access Pattern:** Both eventually provide a `.current` property that holds the DOM node, but class components can store it directly on `this`, while functional components rely on the `ref` object returned by `useRef`.\n*   **Lifecycle Integration:** Class components use lifecycle methods (`componentDidMount`, `componentDidUpdate`) to interact with refs. Functional components use the `useEffect` hook to achieve similar timing and side-effect management.",
          "analysisPoints": [
            "Detail ref creation methods for both component types.",
            "Explain how to access the ref's current value.",
            "Discuss appropriate lifecycle methods/hooks for ref interaction.",
            "Summarize key differences in a comparative manner."
          ],
          "keyConcepts": [
            "Refs",
            "Class Components",
            "Functional Components",
            "useRef",
            "useEffect",
            "Lifecycle Methods",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison of ref mechanisms.",
            "Accurate explanation of lifecycle integration.",
            "Clarity and structure of the answer."
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "Class Components",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_Components",
            "React_Lifecycle",
            "React_Hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_refs_4",
          "topic": "Direct DOM Manipulation with Refs",
          "level": "hard",
          "type": "code",
          "question": "Implement a custom React hook `usePrevious` that stores the previous value of a prop or state. Then, use this hook and a `useRef` to create a `ScrollableDiv` component that automatically scrolls to the bottom when its content height changes (e.g., when new messages are added to a chat).",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly implements `usePrevious` using `useRef` and `useEffect`.",
            "Correctly uses `useRef` to get a reference to the scrollable div.",
            "Compares current scroll height to previous scroll height to detect content change.",
            "Applies `scrollTop` property correctly for auto-scrolling.",
            "Handles edge cases like initial render or when content is smaller than div."
          ],
          "keyConcepts": [
            "Refs",
            "useRef",
            "useEffect",
            "Custom Hooks",
            "DOM Manipulation",
            "Scroll Management"
          ],
          "evaluationCriteria": [
            "Correct implementation of `usePrevious` hook.",
            "Effective use of `useRef` for DOM element access.",
            "Logical application of `useEffect` for side effects.",
            "Correct implementation of auto-scrolling logic.",
            "Handling of dependencies in `useEffect`."
          ],
          "example": "```typescript\nimport React, { useRef, useEffect, useState } from 'react';\n\n// Custom hook to get the previous value of a state or prop\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\ninterface ScrollableDivProps {\n  children: React.ReactNode;\n}\n\nfunction ScrollableDiv({ children }: ScrollableDivProps) {\n  const scrollRef = useRef<HTMLDivElement>(null);\n  const prevChildren = usePrevious(children);\n\n  useEffect(() => {\n    if (scrollRef.current) {\n      // Only scroll to bottom if content has changed (e.g., new messages)\n      // A more robust check might compare actual message count or scroll height\n      // For simplicity, we check if children ref has changed, meaning content likely did\n      if (prevChildren !== children) {\n         scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n      }\n    }\n  }, [children, prevChildren]); // Re-run when children content changes\n\n  return (\n    <div\n      ref={scrollRef}\n      style={{\n        height: '200px',\n        overflowY: 'auto',\n        border: '1px solid #ccc',\n        padding: '10px',\n        display: 'flex',\n        flexDirection: 'column'\n      }}\n    >\n      {children}\n    </div>\n  );\n}\n\n// Example Usage:\nfunction ChatWindow() {\n  const [messages, setMessages] = useState<string[]>([\n    \"Hello!\",\n    \"Welcome to the chat.\"\n  ]);\n\n  const addMessage = () => {\n    setMessages(prev => [...prev, `New message at ${new Date().toLocaleTimeString()}`]);\n  };\n\n  return (\n    <div>\n      <ScrollableDiv>\n        {messages.map((msg, index) => (\n          <p key={index}>{msg}</p>\n        ))}\n      </ScrollableDiv>\n      <button onClick={addMessage}>Add Message</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "Custom Hooks",
            "DOM Manipulation",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React_Hooks",
            "JavaScript_DOM_Basics"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_https_dev_1",
          "topic": "Using HTTPS in Development",
          "level": "easy",
          "type": "flashcard",
          "question": "Name two reasons why it's beneficial to use HTTPS even in local development.",
          "answer": "1. To mirror the production environment more closely and prevent mixed content issues.\n2. To enable browser features that require a secure context (e.g., Geolocation, Service Workers, WebAuthn).",
          "analysisPoints": [
            "Identifies common reasons for HTTPS in dev.",
            "Highlights consistency and feature access."
          ],
          "keyConcepts": [
            "HTTPS",
            "Development Environment",
            "Security"
          ],
          "evaluationCriteria": [
            "Recall of key benefits"
          ],
          "example": "",
          "tags": [
            "Web_Development",
            "Security",
            "Flashcard"
          ],
          "prerequisites": [
            "Networking_Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_https_dev_2",
          "topic": "Using HTTPS in Development",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following browser features or API requirements *typically* mandate a secure context (HTTPS) to function correctly?",
          "answer": "D. All of the above.",
          "options": [
            "A. Service Workers for Progressive Web Apps (PWAs).",
            "B. Geolocation API (`navigator.geolocation`).",
            "C. Web Push Notifications.",
            "D. All of the above."
          ],
          "analysisPoints": [
            "Identifies that all listed options require HTTPS.",
            "Understands the concept of 'secure context' in modern web development."
          ],
          "keyConcepts": [
            "HTTPS",
            "Secure Context",
            "Browser APIs",
            "PWA"
          ],
          "evaluationCriteria": [
            "Knowledge of secure context requirements for web features."
          ],
          "example": "",
          "tags": [
            "Web_Development",
            "Security",
            "Browser APIs",
            "MCQ"
          ],
          "prerequisites": [
            "Networking_Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_https_dev_3",
          "topic": "Using HTTPS in Development",
          "level": "open",
          "type": "open",
          "question": "Describe the concept of 'mixed content' in web development and explain how using HTTPS in development helps to mitigate issues related to it.",
          "answer": "Mixed content occurs when an initial HTML page is loaded over a secure HTTPS connection, but other resources (like images, videos, stylesheets, scripts, or API calls) on that same page are loaded over an insecure HTTP connection. This poses a security risk because even though the main page is encrypted, the insecure resources can be intercepted, modified, or expose sensitive information.\n\nBrowsers have strict policies against mixed content. They typically:\n*   **Block active mixed content:** Scripts, iframes, stylesheets that are loaded over HTTP on an HTTPS page are usually blocked entirely, leading to broken functionality or UI.\n*   **Warn about passive mixed content:** Images, audio, and video loaded over HTTP might be displayed, but the browser will show a warning in the console or address bar, indicating a potential security vulnerability.\n\nUsing HTTPS in development helps mitigate these issues by:\n1.  **Early Detection:** By developing with HTTPS, your local environment mirrors production. If you accidentally reference an HTTP resource (e.g., an image from an external HTTP server or a local API not served over HTTPS), the browser will immediately flag it as mixed content during development. This allows developers to catch and fix these issues before deployment.\n2.  **Consistent Testing:** It ensures that your application behaves consistently across environments. Features that might work locally over HTTP but fail in production due to mixed content (e.g., fetching data from an external non-HTTPS API) will break during development, prompting necessary adjustments.",
          "analysisPoints": [
            "Define mixed content (secure page, insecure resources).",
            "Explain the security implications (interception, modification).",
            "Describe browser behavior (blocking vs. warning).",
            "Explain how dev HTTPS helps (early detection, consistent testing)."
          ],
          "keyConcepts": [
            "HTTPS",
            "Mixed Content",
            "Security",
            "Browser Security",
            "Development Practices"
          ],
          "evaluationCriteria": [
            "Clear and accurate definition of mixed content.",
            "Thorough explanation of its implications.",
            "Detailed description of how dev HTTPS addresses the problem."
          ],
          "example": "",
          "tags": [
            "Web_Development",
            "Security",
            "Browser",
            "Open-Ended"
          ],
          "prerequisites": [
            "Networking_Basics",
            "HTTP_HTTPS"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_user_profile_form",
          "title": "Build a User Profile Form with Immutable State Management",
          "description": "\nCreate a React functional component `UserProfileForm` that manages a user's profile information. The form should include:\n\n1.  **Basic Fields:** `firstName`, `lastName`, `email`.\n2.  **Nested Preference:** An object `preferences` containing `newsletterSubscription` (boolean) and `smsNotifications` (boolean).\n\n**Requirements:**\n*   Use **a single `useState` object** to manage the entire form's state.\n*   Implement `onChange` handlers for all input fields (text and checkboxes) to update the state **immutably**.\n*   Ensure updates to nested properties (`newsletterSubscription`, `smsNotifications`) are also immutable.\n*   Display the current state below the form in a readable JSON format (`<pre>`).\n*   The form should reflect state changes immediately.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface UserProfile {\n  firstName: string;\n  lastName: string;\n  email: string;\n  preferences: {\n    newsletterSubscription: boolean;\n    smsNotifications: boolean;\n  };\n}\n\nfunction UserProfileForm() {\n  const [user, setUser] = useState<UserProfile>({\n    firstName: '',\n    lastName: '',\n    email: '',\n    preferences: {\n      newsletterSubscription: false,\n      smsNotifications: false,\n    },\n  });\n\n  // TODO: Implement handleInputChange for text fields\n  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    // ... your implementation for text inputs\n  };\n\n  // TODO: Implement handleCheckboxChange for checkboxes\n  const handleCheckboxChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    // ... your implementation for checkboxes, especially nested ones\n  };\n\n  return (\n    <div>\n      <h2>User Profile Editor</h2>\n      <form>\n        <label>\n          First Name:\n          <input\n            type=\"text\"\n            name=\"firstName\"\n            value={user.firstName}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <label>\n          Last Name:\n          <input\n            type=\"text\"\n            name=\"lastName\"\n            value={user.lastName}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <label>\n          Email:\n          <input\n            type=\"email\"\n            name=\"email\"\n            value={user.email}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <h3>Preferences</h3>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"newsletterSubscription\"\n            checked={user.preferences.newsletterSubscription}\n            onChange={handleCheckboxChange}\n          />\n          Newsletter Subscription\n        </label>\n        <br />\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"smsNotifications\"\n            checked={user.preferences.smsNotifications}\n            onChange={handleCheckboxChange}\n          />\n          SMS Notifications\n        </label>\n      </form>\n      <h3>Current State:</h3>\n      <pre>{JSON.stringify(user, null, 2)}</pre>\n    </div>\n  );\n}\n\nexport default UserProfileForm;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface UserProfile {\n  firstName: string;\n  lastName: string;\n  email: string;\n  preferences: {\n    newsletterSubscription: boolean;\n    smsNotifications: boolean;\n  };\n}\n\nfunction UserProfileForm() {\n  const [user, setUser] = useState<UserProfile>({\n    firstName: '',\n    lastName: '',\n    email: '',\n    preferences: {\n      newsletterSubscription: false,\n      smsNotifications: false,\n    },\n  });\n\n  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = event.target;\n    setUser(prevUser => ({\n      ...prevUser,\n      [name]: value, // Update top-level properties dynamically\n    }));\n  };\n\n  const handleCheckboxChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, checked } = event.target;\n    // For nested preferences, we need nested spread\n    setUser(prevUser => ({\n      ...prevUser,\n      preferences: {\n        ...prevUser.preferences,\n        [name]: checked,\n      },\n    }));\n  };\n\n  return (\n    <div>\n      <h2>User Profile Editor</h2>\n      <form>\n        <label>\n          First Name:\n          <input\n            type=\"text\"\n            name=\"firstName\"\n            value={user.firstName}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <label>\n          Last Name:\n          <input\n            type=\"text\"\n            name=\"lastName\"\n            value={user.lastName}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <label>\n          Email:\n          <input\n            type=\"email\"\n            name=\"email\"\n            value={user.email}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <h3>Preferences</h3>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"newsletterSubscription\"\n            checked={user.preferences.newsletterSubscription}\n            onChange={handleCheckboxChange}\n          />\n          Newsletter Subscription\n        </label>\n        <br />\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"smsNotifications\"\n            checked={user.preferences.smsNotifications}\n            onChange={handleCheckboxChange}\n          />\n          SMS Notifications\n        </label>\n      </form>\n      <h3>Current State:</h3>\n      <pre>{JSON.stringify(user, null, 2)}</pre>\n    </div>\n  );\n}\n\nexport default UserProfileForm;\n",
          "testCases": [
            "Entering text in 'First Name' should update `user.firstName`.",
            "Entering text in 'Last Name' should update `user.lastName`.",
            "Entering text in 'Email' should update `user.email`.",
            "Toggling 'Newsletter Subscription' checkbox should immutably update `user.preferences.newsletterSubscription`.",
            "Toggling 'SMS Notifications' checkbox should immutably update `user.preferences.smsNotifications`.",
            "Verify that unrelated properties remain unchanged after an update (e.g., changing first name doesn't affect preferences).",
            "Initial state should match the `useState` initialization."
          ],
          "hints": [
            "For the `handleInputChange` function, you can use computed property names `[name]: value` with the spread operator.",
            "For `handleCheckboxChange`, remember that `event.target.checked` provides the boolean value for checkboxes.",
            "Updating nested objects requires spreading at each level to create new references."
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Forms",
            "Hooks"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_useState",
            "JavaScript_Objects",
            "JavaScript_Spread_Syntax"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_immutable_state_updates",
            "theory_multiple_state_variables"
          ]
        },
        {
          "id": "task_todo_list_manager",
          "title": "Implement an Immutable Todo List Manager",
          "description": "\nCreate a React functional component `TodoListManager` that allows users to add, delete, and toggle the completion status of todo items. All state manipulations must be **immutable**.\n\n**Requirements:**\n1.  **Add Todo:** An input field and a button to add new todo items. Each todo should have a unique `id` (e.g., using `Date.now()`), `text`, and `completed` status (default `false`).\n2.  **Delete Todo:** A button next to each todo item to remove it from the list.\n3.  **Toggle Complete:** A checkbox next to each todo item to toggle its `completed` status.\n4.  **Display:** List all todos, showing their text and completion status. Completed todos can have a strikethrough style.\n\n**Constraints:**\n*   Use `useState` for managing the list of todos.\n*   All array modifications (add, delete, update) must be done immutably.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nfunction TodoListManager() {\n  const [todos, setTodos] = useState<Todo[]>([]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return;\n    // TODO: Add new todo immutably\n    setNewTodoText('');\n  };\n\n  const handleDeleteTodo = (id: number) => {\n    // TODO: Delete todo immutably\n  };\n\n  const handleToggleComplete = (id: number) => {\n    // TODO: Toggle completion status immutably\n  };\n\n  return (\n    <div>\n      <h2>Todo List Manager</h2>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add a new todo\"\n        />\n        <button onClick={handleAddTodo}>Add Todo</button>\n      </div>\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => handleToggleComplete(todo.id)}\n            />\n            {todo.text}\n            <button onClick={() => handleDeleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default TodoListManager;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nfunction TodoListManager() {\n  const [todos, setTodos] = useState<Todo[]>([]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newTodo: Todo = {\n      id: Date.now(), // Simple unique ID\n      text: newTodoText.trim(),\n      completed: false,\n    };\n    setTodos(prevTodos => [...prevTodos, newTodo]); // Add immutably\n    setNewTodoText('');\n  };\n\n  const handleDeleteTodo = (id: number) => {\n    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id)); // Delete immutably using filter\n  };\n\n  const handleToggleComplete = (id: number) => {\n    setTodos(prevTodos =>\n      prevTodos.map(todo =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      ) // Update immutably using map\n    );\n  };\n\n  return (\n    <div>\n      <h2>Todo List Manager</h2>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add a new todo\"\n        />\n        <button onClick={handleAddTodo}>Add Todo</button>\n      </div>\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => handleToggleComplete(todo.id)}\n            />\n            {todo.text}\n            <button onClick={() => handleDeleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default TodoListManager;\n",
          "testCases": [
            "Adding a new todo should append it to the list with `completed: false`.",
            "Adding an empty todo text should do nothing.",
            "Deleting a todo should remove it from the list.",
            "Toggling a todo's checkbox should change its `completed` status and its strikethrough style.",
            "Deleting a non-existent todo should not cause errors and leave the list unchanged.",
            "Adding multiple todos and ensuring they have unique IDs."
          ],
          "hints": [
            "For adding, use the spread syntax `[...]` to create a new array.",
            "For deleting, the `filter()` method is ideal as it returns a new array.",
            "For toggling completion, `map()` allows you to iterate and create a new array, selectively updating only the target item's properties using object spread."
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Arrays",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_useState",
            "JavaScript_Array_Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_immutable_array_manipulation"
          ]
        },
        {
          "id": "task_autofocus_input",
          "title": "Auto-Focus Input on Component Mount using `useRef`",
          "description": "\nCreate a React functional component `AutoFocusInput` that automatically focuses an input field when the component mounts.\n\n**Requirements:**\n*   Use the `useRef` hook to create a ref for the input element.\n*   Use the `useEffect` hook to perform the focus action.\n*   Ensure the `focus()` call happens only once when the component first mounts.\n*   Include a button that conditionally renders `AutoFocusInput` to demonstrate the auto-focus behavior upon mounting.\n",
          "difficulty": "easy",
          "startingCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // TODO: Implement focusing logic here\n  }, []); // Dependency array for 'mount only'\n\n  return (\n    <div>\n      <p>This input should auto-focus on load:</p>\n      <input ref={inputRef} type=\"text\" placeholder=\"Type here...\" />\n    </div>\n  );\n}\n\nfunction App() {\n  const [showInput, setShowInput] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowInput(!showInput)}>\n        {showInput ? 'Hide Input' : 'Show Input'}\n      </button>\n      {showInput && <AutoFocusInput />}\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    // Check if the ref.current is not null before focusing\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array ensures this runs only once on mount\n\n  return (\n    <div>\n      <p>This input should auto-focus on load:</p>\n      <input ref={inputRef} type=\"text\" placeholder=\"Type here...\" />\n    </div>\n  );\n}\n\nfunction App() {\n  const [showInput, setShowInput] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowInput(!showInput)}>\n        {showInput ? 'Hide Input' : 'Show Input'}\n      </button>\n      {showInput && <AutoFocusInput />}\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "When the 'Show Input' button is clicked, the input field inside `AutoFocusInput` should gain focus.",
            "When the 'Hide Input' button is clicked, the `AutoFocusInput` component should unmount.",
            "When 'Show Input' is clicked again, the input should re-focus."
          ],
          "hints": [
            "The `useEffect` hook with an empty dependency array `[]` runs once after the initial render, which is the perfect time to access the DOM node via ref.",
            "Remember to check if `inputRef.current` is not `null` before trying to call `focus()` on it, as the ref might not be attached immediately.",
            "The `inputRef.current` will be the actual DOM element for the `<input>` tag."
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "useRef",
            "useEffect",
            "DOM Manipulation"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React_Hooks_Fundamentals",
            "JavaScript_DOM_Basics"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_refs_dom_manipulation"
          ]
        },
        {
          "id": "task_media_player_control",
          "title": "Implement a Video Player with Play/Pause Control using `useRef`",
          "description": "\nCreate a React functional component `VideoPlayer` that displays a simple video and provides 'Play' and 'Pause' buttons to control it. The video control must be done imperatively using `useRef`.\n\n**Requirements:**\n*   Use a `<video>` HTML element.\n*   Use `useRef` to get a reference to the video DOM element.\n*   Implement `playVideo()` and `pauseVideo()` functions that use the ref to call the `play()` and `pause()` methods directly on the video element.\n*   Provide buttons labeled 'Play' and 'Pause' that trigger these functions.\n*   Choose a small, publicly available video URL for demonstration.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef(null);\n  const videoSrc = \"https://www.w3schools.com/html/mov_bbb.mp4\"; // Example public video URL\n\n  const playVideo = () => {\n    // TODO: Play the video using the ref\n  };\n\n  const pauseVideo = () => {\n    // TODO: Pause the video using the ref\n  };\n\n  return (\n    <div>\n      <h2>Simple Video Player</h2>\n      <video ref={videoRef} width=\"320\" height=\"240\" controls>\n        <source src={videoSrc} type=\"video/mp4\" />\n        Your browser does not support the video tag.\n      </video>\n      <div>\n        <button onClick={playVideo}>Play</button>\n        <button onClick={pauseVideo}>Pause</button>\n      </div>\n    </div>\n  );\n}\n\nexport default VideoPlayer;\n",
          "solutionCode": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const videoSrc = \"https://www.w3schools.com/html/mov_bbb.mp4\"; // Example public video URL\n\n  const playVideo = () => {\n    if (videoRef.current) {\n      videoRef.current.play();\n    }\n  };\n\n  const pauseVideo = () => {\n    if (videoRef.current) {\n      videoRef.current.pause();\n    }\n  };\n\n  return (\n    <div>\n      <h2>Simple Video Player</h2>\n      <video ref={videoRef} width=\"320\" height=\"240\" controls>\n        <source src={videoSrc} type=\"video/mp4\" />\n        Your browser does not support the video tag.\n      </video>\n      <div>\n        <button onClick={playVideo}>Play</button>\n        <button onClick={pauseVideo}>Pause</button>\n      </div>\n    </div>\n  );\n}\n\nexport default VideoPlayer;\n",
          "testCases": [
            "Clicking 'Play' button should start the video.",
            "Clicking 'Pause' button should pause the video.",
            "Video should load correctly from the `videoSrc`.",
            "The component should render without errors."
          ],
          "hints": [
            "The `HTMLVideoElement` has `play()` and `pause()` methods.",
            "Remember to check if `videoRef.current` is not `null` before calling methods on it.",
            "You don't need `useEffect` for these simple imperative calls triggered by user interaction, as `videoRef.current` will be available after the initial render."
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "useRef",
            "DOM Manipulation",
            "Media"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "React_Hooks_Fundamentals",
            "JavaScript_DOM_Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_refs_dom_manipulation"
          ]
        },
        {
          "id": "task_setup_https_dev",
          "title": "Configure a React Dev Server for HTTPS",
          "description": "\nDemonstrate how to configure a typical React development environment (e.g., using Create React App's built-in server or a simple Node.js Express server) to serve content over HTTPS during local development. You don't need to build a complex React app, just show the setup.\n\n**Requirements:**\n*   **Option A (CRA):** Show the command-line approach to start a CRA project with HTTPS.\n*   **Option B (Express):** Set up a minimal Node.js Express server that serves a simple HTML/React build over HTTPS using self-signed certificates (e.g., generated with `mkcert`). Provide instructions for generating the certificates.\n\n**Choose ONE option** to implement and provide the necessary code/commands. Explain why this setup is useful.\n",
          "difficulty": "medium",
          "startingCode": "```bash\n# OPTION A: Create React App (CRA)\n# No starting code, provide the command to run it with HTTPS\n\n# OPTION B: Node.js Express Server\n# Create a directory for your project:\n# mkdir my-https-app\n# cd my-https-app\n# npm init -y\n# npm install express\n# npm install -g mkcert # if you don't have it\n\n# Provide a simple index.html or React build placeholder\n# Then, your server.js setup...\n```\n",
          "solutionCode": "```bash\n# OPTION A: Create React App (CRA)\n# 1. Create a new React App (if you don't have one):\n#    npx create-react-app my-https-cra --template typescript\n#    cd my-https-cra\n\n# 2. To run the Create React App development server with HTTPS, use:\nHTTPS=true npm start\n# Or, for Windows PowerShell:\n# $env:HTTPS=\"true\"; npm start\n\n# Explanation:\n# Create React App provides a convenient environment variable, `HTTPS`, which when set to `true`, instructs the underlying webpack-dev-server to serve the application over HTTPS. It automatically generates and uses a self-signed certificate, which your browser might initially warn you about, but you can proceed past the warning for `localhost`.\n```\n\n```javascript\n// OPTION B: Node.js Express Server with mkcert\n\n// Step 1: Install mkcert (if you haven't already)\n// On macOS (using Homebrew): brew install mkcert\n// On Linux (using Homebrew): brew install mkcert\n// On Windows: choco install mkcert (or follow instructions on mkcert GitHub)\n\n// Step 2: Install mkcert locally (this will add a CA to your system's trust store)\n// mkcert -install\n\n// Step 3: Generate certificates for localhost (run this in your project root)\n// mkcert localhost 127.0.0.1 ::1\n// This will create files like `localhost.pem` and `localhost-key.pem`\n\n// Step 4: Create a server.js file\n// (Make sure you have `npm install express`)\n\n// server.js\nconst express = require('express');\nconst https = require('https');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\nconst PORT = 3000;\n\n// Serve static files (e.g., your React build output in a 'build' folder)\n// If you have a React app, run `npm run build` and then point this to the 'build' folder.\n// For simplicity, let's just serve a simple HTML file.\napp.use(express.static(path.join(__dirname, 'public'))); // Assuming a 'public' directory with index.html\n\n// Certificate files generated by mkcert\nconst options = {\n  key: fs.readFileSync('localhost-key.pem'),\n  cert: fs.readFileSync('localhost.pem')\n};\n\n// Create HTTPS server\nhttps.createServer(options, app).listen(PORT, () => {\n  console.log(`HTTPS server running on https://localhost:${PORT}`);\n  console.log('You might need to accept a security warning in your browser for the self-signed certificate.');\n});\n\n// Example public/index.html:\n// <!DOCTYPE html>\n// <html>\n// <head><title>HTTPS Dev</title></head>\n// <body><h1>Hello from HTTPS Development!</h1></body>\n// </html>\n```\n\n**Explanation:**\nThis setup allows you to simulate a production-like secure environment locally. By running your development server over HTTPS, you can:\n*   **Test browser features** that require a secure context (e.g., service workers, geolocation, WebAuthn).\n*   **Prevent mixed content warnings/errors** that can occur when an HTTPS page tries to load HTTP resources.\n*   **Debug API calls** that might behave differently or be blocked over HTTP (e.g., certain OAuth flows, secure cookie attributes).\nThis helps catch potential production issues early in the development cycle.\n",
          "testCases": [
            "The development server should start successfully.",
            "Navigating to `https://localhost:[PORT]` (e.g., `https://localhost:3000`) in the browser should load the application.",
            "The browser should show a 'secure' connection indicator (possibly after accepting a self-signed certificate warning).",
            "No mixed content warnings should appear if all resources are served from HTTPS."
          ],
          "hints": [
            "For CRA, environment variables are often the easiest way. Check CRA documentation for how to set `HTTPS=true` for your specific shell.",
            "For a custom Node.js server, you'll need the `https` built-in module and `fs` to read the certificate files.",
            "`mkcert` is a very convenient tool for generating locally trusted development certificates. Follow its installation instructions carefully.",
            "Ensure the certificate files (`.pem`, `.key`) are accessible by your Node.js server."
          ],
          "tags": [
            "HTTPS",
            "Development",
            "Security",
            "Node.js",
            "Express",
            "React",
            "Tooling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Node.js_Basics",
            "NPM_Yarn",
            "Basic_Web_Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_https_development"
          ]
        }
      ]
    }
  },
  {
    "id": "681ba99a-be4b-44b6-ac61-e7ee1f8365bb",
    "startLine": 3600,
    "endLine": 3699,
    "processedDate": "2025-06-17T08:48:57.492Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_https_setup",
          "title": "Enabling HTTPS in React Development",
          "content": "Running a React application over HTTPS (Hypertext Transfer Protocol Secure) during development can be crucial for various reasons, including testing certain browser features that require a secure context (e.g., Service Workers, Geolocation API, WebAuthn), ensuring consistent behavior with production environments, or interacting with APIs that only allow requests from secure origins. Create React App (CRA) provides a simple way to enable HTTPS for your development server.\n\n### How to Enable HTTPS\nTo enable HTTPS for your Create React App development server, you can set the `HTTPS` environment variable to `true`. This can be done in two primary ways:\n\n1.  **In `package.json` scripts:** You can modify your `start` script in `package.json` to include the `HTTPS=true` environment variable before `react-scripts start`. This makes HTTPS the default when you run `npm start`.\n2.  **From the command line:** You can directly set the `HTTPS=true` environment variable in your terminal before running the `npm start` command. This is useful for one-off sessions or testing.\n\n**Note on Cross-Platform Compatibility:** The syntax `set HTTPS=true` is specific to Windows command prompt. For macOS/Linux (Bash/Zsh), you would use `HTTPS=true`. For cross-platform scripts, tools like `cross-env` can be used to set environment variables universally.\n\n### Benefits of Development HTTPS\n*   **Security Feature Testing:** Enables testing of features that require a secure context (e.g., Service Workers, Web Push Notifications, Geolocation).\n*   **API Interaction:** Allows local development to interact with APIs that might enforce secure origins.\n*   **Production Parity:** Helps catch potential issues early that might only arise when serving over HTTPS in a production environment.\n*   **Reduced Browser Warnings:** Prevents browsers from flagging `http://localhost` as insecure, which can be distracting during development.\n\nBy default, when `HTTPS=true` is set, `react-scripts` will generate and use a self-signed SSL certificate. Browsers will typically warn you about this certificate being untrusted, but you can usually proceed past the warning.",
          "examples": [
            {
              "id": "example_https_setup_1",
              "title": "Enabling HTTPS via package.json script (Windows)",
              "code": "{\n  \"name\": \"my-react-app\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"set HTTPS=true && react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}",
              "explanation": "This demonstrates how to modify the `start` script in your `package.json` file. When you run `npm start`, the `set HTTPS=true` command will execute first, setting the environment variable for the `react-scripts start` command. This approach is persistent.",
              "language": "json"
            },
            {
              "id": "example_https_setup_2",
              "title": "Enabling HTTPS from Command Line (Cross-Platform)",
              "code": "// For Windows Command Prompt:\nset HTTPS=true && npm start\n\n// For macOS/Linux (Bash/Zsh):\nHTTPS=true npm start",
              "explanation": "These commands show how to enable HTTPS temporarily from the command line. On Windows, `set` is used. On Unix-like systems, `HTTPS=true` directly before the command sets the variable only for that command's process. This is useful for quick tests without modifying `package.json`.",
              "language": "shell"
            }
          ],
          "relatedQuestions": [
            "question_https_setup_1",
            "question_https_setup_2",
            "question_https_setup_3",
            "question_https_setup_4"
          ],
          "relatedTasks": [
            "task_https_setup_1"
          ],
          "tags": [
            "React",
            "Development",
            "HTTPS",
            "Environment Variables",
            "CLI",
            "Web Security"
          ],
          "technology": "React",
          "prerequisites": [
            "Node.js",
            "npm",
            "Create React App"
          ],
          "complexity": 2,
          "interviewRelevance": 4,
          "learningPath": "beginner",
          "requiredFor": [
            "PWA development",
            "Service Workers",
            "Geolocation API testing"
          ]
        },
        {
          "id": "theory_use_reducer",
          "title": "Using useReducer for Complex State Logic in React",
          "content": "The `useReducer` Hook is an alternative to `useState` for managing state in React components, particularly useful for more complex state logic that involves multiple sub-values or when the next state depends on the previous one. It's conceptually similar to Redux, providing a predictable state container pattern within a single component or custom hook.\n\n### Core Concepts\n1.  **`reducer` function:** A pure function that takes the current `state` and an `action` object as arguments, and returns the `new state`. It should be pure, meaning it produces the same output for the same input and has no side effects.\n    *   `reducer(state, action) => newState`\n2.  **`initialState`:** The initial value of the state. This can be a simple value or a complex object.\n3.  **`dispatch` function:** A function returned by `useReducer` that you call to update the state. You pass an `action` object to `dispatch`, which then triggers the `reducer` function.\n    *   `dispatch(action)`\n4.  **`action` object:** A plain JavaScript object that describes 'what happened'. It typically has a `type` property (a string constant) and can have a `payload` property containing any data necessary for the state update.\n\n### `useReducer` Signature\n`const [state, dispatch] = useReducer(reducer, initialState, init?)`\n\n*   `reducer`: Your reducer function.\n*   `initialState`: The state that the reducer will start with.\n*   `init?` (optional): An optional function that can compute the initial state lazily. If provided, `initialState` will be passed to `init`, and `init`'s return value will be the actual initial state.\n\n### When to use `useReducer` over `useState`\n*   **Complex state logic:** When state updates involve multiple related pieces of state that change together, or when the next state depends heavily on the previous state.\n*   **State transitions:** When there are many different ways the state can transition (e.g., `loading`, `success`, `error` for a data fetch).\n*   **Performance optimization:** If state updates are batched by React, `dispatch` calls within event handlers are typically processed efficiently. For highly optimized scenarios, the `dispatch` function identity is stable and doesn't change on re-renders, so child components can be memoized effectively with `React.memo`.\n*   **Centralized state logic:** Keeps all state update logic in one place (the reducer function), making it easier to understand, test, and maintain.\n\n### Immutability in Reducers\nIt is crucial that reducer functions *do not directly mutate* the original `state` object. Instead, they should return a *new state object* with the necessary changes. This is fundamental to React's change detection mechanism and helps prevent unexpected side effects. The spread operator (`...`) is commonly used for creating new copies of state objects or arrays.",
          "examples": [
            {
              "id": "example_use_reducer_1",
              "title": "Counter with Basic useReducer Actions",
              "code": "// Initial state\nconst initialState = { count: 0 };\n\n// Reducer function\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    case 'DECREMENT':\n      return { ...state, count: state.count - 1 };\n    case 'RESET':\n      return { ...state, count: 0 };\n    default:\n      throw new Error(`Unsupported action type: ${action.type}`);\n  }\n}\n\nfunction CounterBasic() {\n  const [state, dispatch] = useReducer(counterReducer, initialState);\n  \n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>\n      <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>\n      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates a basic counter using `useReducer`. The `counterReducer` function handles `INCREMENT`, `DECREMENT`, and `RESET` actions, returning a new state object for each. The component dispatches actions via `dispatch({ type: 'ACTION_TYPE' })` to update the count.",
              "language": "typescript"
            },
            {
              "id": "example_use_reducer_2",
              "title": "Data Fetching with useReducer",
              "code": "// Initial state for data fetching\nconst initialState = {\n  count: 0,\n  loading: false,\n  error: null,\n  data: null\n};\n\n// Reducer function for combined state\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    case 'DECREMENT':\n      return { ...state, count: state.count - 1 };\n    case 'RESET':\n      return { ...state, count: 0 };\n    case 'FETCH_START':\n      return { ...state, loading: true, error: null };\n    case 'FETCH_SUCCESS':\n      return { ...state, loading: false, data: action.payload };\n    case 'FETCH_ERROR':\n      return { ...state, loading: false, error: action.payload };\n    default:\n      throw new Error(`Unsupported action type: ${action.type}`);\n  }\n}\n\nfunction CounterAndDataFetcher() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  const fetchData = async () => {\n    dispatch({ type: 'FETCH_START' });\n    try {\n      // Simulate API call\n      const response = await new Promise(resolve => setTimeout(() => {\n        resolve({ json: () => ({ message: 'Data fetched successfully!', value: Math.random() }) });\n      }, 1000));\n      // const response = await fetch('/api/data'); // Original API call\n      const data = await response.json();\n      dispatch({ type: 'FETCH_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_ERROR', payload: error.message });\n    }\n  };\n  \n  return (\n    <div>\n      <h2>Counter Section</h2>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>\n      <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>\n      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>\n      \n      <h2>Data Fetching Section</h2>\n      <button onClick={fetchData}>Fetch Data</button>\n      {state.loading && <p>Loading...</p>}\n      {state.error && <p style={{ color: 'red' }}>Error: {state.error}</p>}\n      {state.data && (\n        <div>\n          <p>Fetched Data:</p>\n          <pre>{JSON.stringify(state.data, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n}",
              "explanation": "This enhanced example combines the counter logic with asynchronous data fetching. It showcases how `useReducer` can manage multiple related pieces of state (`count`, `loading`, `error`, `data`) effectively. Different actions (`FETCH_START`, `FETCH_SUCCESS`, `FETCH_ERROR`) are dispatched at various stages of the fetch operation to update the UI accordingly. The `payload` property is used to pass fetched data or error messages.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_reducer_1",
            "question_use_reducer_2",
            "question_use_reducer_3",
            "question_use_reducer_4",
            "question_use_reducer_5",
            "question_use_reducer_6",
            "question_use_reducer_7",
            "question_use_reducer_8",
            "question_use_reducer_9"
          ],
          "relatedTasks": [
            "task_use_reducer_1",
            "task_use_reducer_2"
          ],
          "tags": [
            "React Hooks",
            "State Management",
            "useReducer",
            "Reducer Pattern",
            "Immutability",
            "Functional Programming"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "useState Hook",
            "JavaScript ES6+ (Objects, Arrays)"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex forms",
            "Data loading states",
            "Global state management alternatives"
          ]
        },
        {
          "id": "theory_default_props",
          "title": "Default Props in React Components",
          "content": "In React, `defaultProps` provide a way to define default values for the props of a component. These default values are used when a prop is not explicitly passed to the component, or when it's passed as `undefined`. This feature helps make components more robust and predictable by ensuring that certain props always have a value, even if the parent component doesn't supply one.\n\n### How to Define `defaultProps`\n`defaultProps` are defined as a static property on the component class (for class components) or directly on the function component (for functional components). They are typically declared after the component definition.\n\n```jsx\n// Functional Component\nfunction MyComponent(props) {\n  return (\n    <div>\n      <h1>Hello, {props.name}!</h1>\n      <p>You are {props.age} years old.</p>\n    </div>\n  );\n}\n\nMyComponent.defaultProps = {\n  name: 'Stranger',\n  age: 30\n};\n\n// Usage:\n// <MyComponent />                 // name: 'Stranger', age: 30\n// <MyComponent name=\"Alice\" />    // name: 'Alice', age: 30\n// <MyComponent age={25} />      // name: 'Stranger', age: 25\n// <MyComponent name={undefined} /> // name: 'Stranger', age: 30\n```\n\n### Key Considerations\n*   **When `defaultProps` are applied:** They are applied *before* the component's `render` method (for class components) or functional component body executes, ensuring that `this.props` or `props` always contain the default values if not explicitly provided.\n*   **`undefined` vs. `null`:** `defaultProps` apply when a prop is `undefined`, but not when it's explicitly `null`. If you pass `null` for a prop, it will override the default value.\n*   **Type Checking:** Often used in conjunction with `PropTypes` (or TypeScript interfaces) for better validation and clarity of component's expected props.\n*   **Alternatives for Functional Components (ES6 Default Parameters):** For functional components, ES6 default parameters are often a more concise and preferred way to handle default prop values directly within the function signature. This method doesn't require the `MyComponent.defaultProps` static property.\n\n```jsx\n// Using ES6 Default Parameters\nfunction MyComponentWithDefaults({ name = 'Stranger', age = 30 }) {\n  return (\n    <div>\n      <h1>Hello, {name}!</h1>\n      <p>You are {age} years old.</p>\n    </div>\n  );\n}\n\n// Usage is the same as with defaultProps\n// <MyComponentWithDefaults />\n// <MyComponentWithDefaults name=\"Bob\" />\n```\n\nWhile ES6 default parameters are often cleaner for functional components, `defaultProps` are still widely used, especially in existing codebases or when working with class components. It's also useful if you need to access the default values from outside the component definition.",
          "examples": [
            {
              "id": "example_default_props_1",
              "title": "Functional Component with defaultProps",
              "code": "import React from 'react';\n\nfunction GreetingCard({ name, message }) {\n  return (\n    <div style={{ border: '1px solid gray', padding: '10px', margin: '10px' }}>\n      <h2>{message}, {name}!</h2>\n      <p>Hope you have a great day!</p>\n    </div>\n  );\n}\n\nGreetingCard.defaultProps = {\n  name: 'Guest',\n  message: 'Hello'\n};\n\nfunction App() {\n  return (\n    <div>\n      <GreetingCard />\n      <GreetingCard name=\"Alice\" />\n      <GreetingCard message=\"Greetings\" />\n      <GreetingCard name=\"Bob\" message=\"Hi there\" />\n      <GreetingCard name={undefined} /> {/* Uses default name 'Guest' */}\n      <GreetingCard name={null} />      {/* Uses null, not default */}\n    </div>\n  );\n}",
              "explanation": "This example demonstrates how `defaultProps` work with a functional component. When `GreetingCard` is rendered without `name` or `message` props, or with `undefined` for `name`, the default values are applied. However, when `name={null}` is passed, the default is overridden, and `name` inside the component becomes `null`.",
              "language": "typescript"
            },
            {
              "id": "example_default_props_2",
              "title": "Functional Component with ES6 Default Parameters",
              "code": "import React from 'react';\n\nfunction UserProfile({ username = 'Anonymous', theme = 'light' }) {\n  return (\n    <div style={{ backgroundColor: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#333' : '#fff', padding: '15px' }}>\n      <h3>User: {username}</h3>\n      <p>Theme: {theme}</p>\n    </div>\n  );\n}\n\nfunction AppES6Defaults() {\n  return (\n    <div>\n      <UserProfile />\n      <UserProfile username=\"DevMaster\" />\n      <UserProfile theme=\"dark\" />\n      <UserProfile username=\"Admin\" theme=\"dark\" />\n      <UserProfile username={undefined} /> {/* Uses default username 'Anonymous' */}\n      <UserProfile username={null} />      {/* Uses null, not default */}\n    </div>\n  );\n}",
              "explanation": "This example shows the equivalent functionality using ES6 default parameters directly in the function component's destructuring assignment. This is often preferred for its conciseness. Similar to `defaultProps`, `undefined` triggers the default, but `null` overrides it.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_default_props_1",
            "question_default_props_2",
            "question_default_props_3",
            "question_default_props_4",
            "question_default_props_5"
          ],
          "relatedTasks": [
            "task_default_props_1"
          ],
          "tags": [
            "React Components",
            "Props",
            "Default Values",
            "ES6",
            "Functional Components",
            "Class Components"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "Props"
          ],
          "complexity": 3,
          "interviewRelevance": 6,
          "learningPath": "beginner",
          "requiredFor": [
            "Robust component design",
            "Reusable components"
          ]
        },
        {
          "id": "theory_spread_operator",
          "title": "The JavaScript Spread Operator (`...`)",
          "content": "The spread operator (`...`) in JavaScript is a powerful and versatile syntax introduced in ES6 (ECMAScript 2015). It allows an iterable (like an array, string, or map) or an object to be expanded into individual elements or key-value pairs where multiple elements or pairs are expected. Its primary use cases include creating shallow copies of arrays and objects, merging arrays and objects, and passing function arguments.\n\n### Key Use Cases\n\n1.  **Copying Arrays and Objects (Shallow Copy):**\n    The spread operator creates a new array or object containing the elements/properties of the original. This is a *shallow copy*, meaning nested objects or arrays are still referenced by memory, not deeply cloned.\n    ```javascript\n    const originalArray = [1, 2, 3];\n    const copiedArray = [...originalArray]; // [1, 2, 3] - new array\n\n    const originalObject = { a: 1, b: 2 };\n    const copiedObject = { ...originalObject }; // { a: 1, b: 2 } - new object\n    ```\n\n2.  **Concatenating/Merging Arrays:**\n    It's an elegant way to combine multiple arrays or add elements to an existing array without using `concat()`.\n    ```javascript\n    const arr1 = [1, 2];\n    const arr2 = [3, 4];\n    const combinedArray = [...arr1, ...arr2, 5]; // [1, 2, 3, 4, 5]\n    ```\n\n3.  **Merging Objects:**\n    When used with objects, properties from the spread object are copied into the new object. If there are duplicate keys, the last key's value will override previous ones.\n    ```javascript\n    const obj1 = { a: 1, b: 2 };\n    const obj2 = { c: 3, d: 4 };\n    const mergedObject = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }\n\n    const overrides = { a: 10, e: 5 };\n    const updatedObject = { ...obj1, ...overrides }; // { a: 10, b: 2, e: 5 }\n    ```\n\n4.  **Passing Props in React (Common Pattern):**\n    In React, the spread operator is frequently used to pass all properties of an object (typically `this.props`) to a child component.\n    ```jsx\n    // ES5 equivalent:\n    <SomeComponent someData={this.props.someData} dispatch={this.props.dispatch} />\n\n    // ES6 using spread operator:\n    <SomeComponent {...this.props} />\n    ```\n    This effectively unpacks all key-value pairs from `this.props` and sets them as individual props on `SomeComponent`. While convenient, it can sometimes obscure which props a component is actually receiving, so explicit prop passing is often preferred for clarity.\n\n5.  **Function Arguments (Rest Parameters and Spreading):**\n    *   **Spread in Function Call:** Expands an array into separate arguments for a function.\n        ```javascript\n        function sum(a, b, c) { return a + b + c; }\n        const numbers = [1, 2, 3];\n        const result = sum(...numbers); // equivalent to sum(1, 2, 3)\n        ```\n    *   **Rest Parameters in Function Definition:** Collects an indefinite number of arguments into an array. (Note: This is the opposite of spread, but uses the same `...` syntax).\n        ```javascript\n        function logArguments(firstArg, ...remainingArgs) {\n          console.log(firstArg); // 'Hello'\n          console.log(remainingArgs); // ['world', '!']\n        }\n        logArguments('Hello', 'world', '!');\n        ```\n\n### Visual Example\n\n![Spread Operator Example](https://0d70d0e6-ab1f-4e8f-90e5-e65998e87b70--1747720800--d5ef9057.app.yourware.app/WEB%20files/aaaa.png)\n\n### Important Note: Shallow Copy\nAlways remember that the spread operator performs a *shallow copy*. If your object or array contains nested objects or arrays, those nested structures are *still referenced* by the new object/array. Modifying a nested structure in the copied version will also affect the original. For deep copies, you would need to use methods like `JSON.parse(JSON.stringify(obj))` (with caveats for functions, dates, etc.) or a dedicated deep-cloning library.",
          "examples": [
            {
              "id": "example_spread_operator_1",
              "title": "Shallow Copying and Merging",
              "code": "const user = { id: 1, name: 'Alice', settings: { theme: 'dark', notifications: true } };\nconst newSettings = { theme: 'light' };\n\n// Shallow copy of user, updating settings\nconst updatedUser = { ...user, settings: { ...user.settings, ...newSettings } };\n\nconsole.log(user);\n// { id: 1, name: 'Alice', settings: { theme: 'dark', notifications: true } }\n\nconsole.log(updatedUser);\n// { id: 1, name: 'Alice', settings: { theme: 'light', notifications: true } }\n\n// Demonstrate shallow copy issue if not careful with nested objects\nconst userCopy = { ...user };\nuserCopy.settings.theme = 'blue';\n\nconsole.log(user.settings.theme); // Output: 'blue' - original object was mutated because settings object was not deep copied\n\nconst items = ['apple', 'banana'];\nconst moreItems = ['cherry', 'date'];\nconst allItems = [...items, 'grape', ...moreItems];\n\nconsole.log(allItems); // ['apple', 'banana', 'grape', 'cherry', 'date']",
              "explanation": "This example illustrates how to use the spread operator for shallow copying and merging objects and arrays. It also highlights the 'shallow copy' limitation: when a nested object (like `settings`) is not explicitly spread and copied, changes to it in the copied object will reflect in the original object. To correctly update nested properties, the nested object itself must also be spread.",
              "language": "typescript"
            },
            {
              "id": "example_spread_operator_2",
              "title": "Spread Operator in React Props",
              "code": "import React from 'react';\n\nfunction Button({ text, type, onClick, disabled }) {\n  return (\n    <button type={type} onClick={onClick} disabled={disabled}>\n      {text}\n    </button>\n  );\n}\n\nfunction App() {\n  const commonButtonProps = {\n    type: 'submit',\n    onClick: () => alert('Button clicked!'),\n    disabled: false\n  };\n\n  return (\n    <div>\n      {/* Explicitly passing props */}\n      <Button text=\"Submit A\" type=\"button\" onClick={() => console.log('A clicked')} disabled={false} />\n\n      {/* Using spread operator for common props */}\n      <Button text=\"Submit B\" {...commonButtonProps} />\n\n      {/* Overriding a spread prop */}\n      <Button text=\"Disabled Button\" {...commonButtonProps} disabled={true} />\n    </div>\n  );\n}",
              "explanation": "This React example demonstrates the convenience of using the spread operator to pass a collection of props to a child component. `commonButtonProps` defines a set of default or frequently used props. When spread onto the `Button` component, these props are applied. It also shows how individual props can override values provided by the spread operator (e.g., `disabled={true}` overrides `disabled: false` from `commonButtonProps`).",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_spread_operator_1",
            "question_spread_operator_2",
            "question_spread_operator_3",
            "question_spread_operator_4",
            "question_spread_operator_5",
            "question_spread_operator_6",
            "question_spread_operator_7"
          ],
          "relatedTasks": [
            "task_spread_operator_1"
          ],
          "tags": [
            "JavaScript ES6",
            "Spread Syntax",
            "Object Copy",
            "Array Copy",
            "Immutability",
            "React Props",
            "Functional Programming"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript Objects",
            "JavaScript Arrays",
            "React Props (for React context)"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Immutable state updates",
            "Component flexibility",
            "Modern JavaScript development"
          ]
        },
        {
          "id": "theory_react_events",
          "title": "React's SyntheticEvent System",
          "content": "React implements its own event system, known as `SyntheticEvent`, which wraps the browser's native event system. This wrapper provides a consistent, cross-browser compatible interface to events, addressing inconsistencies that exist across different browsers' DOM implementations. When you define an event handler like `onClick` or `onChange` in React, you're interacting with a `SyntheticEvent` object, not the native browser event.\n\n### Key Characteristics and Differences from Native Events\n\n1.  **Cross-Browser Consistency:** `SyntheticEvent` normalizes event properties across different browsers, meaning you don't have to write browser-specific code for common event properties like `event.target`, `event.currentTarget`, `event.preventDefault()`, or `event.stopPropagation()`. This ensures your event handling logic behaves predictably everywhere.\n\n2.  **Event Pooling:** React used to pool `SyntheticEvent` objects for performance reasons. This meant that the event object was reused and its properties were nullified after the event callback was invoked. **As of React 17, event pooling has been removed.** You can now access event properties asynchronously without needing to call `event.persist()`. This simplifies asynchronous event handling.\n\n3.  **Event Delegation:** React automatically delegates events to the document root. When you attach an event handler to a React element, React actually attaches a single event listener to the document. When an event fires, React then dispatches it to the correct component based on the event's target. This improves performance by reducing the number of actual DOM event listeners, especially in large applications with many components.\n\n4.  **Naming Convention:** React event handlers are named using camelCase (e.g., `onClick`, `onChange`), unlike standard HTML attributes which are lowercase (e.g., `onclick`, `onchange`).\n\n5.  **Event Handler Binding (`this` context):** In class components, `this` context for event handlers needs to be explicitly bound, typically in the constructor or using arrow functions, because JavaScript functions lose their `this` context when passed as callbacks. In functional components with Hooks, `this` is not an issue.\n\n    ```jsx\n    // Class Component - Binding 'this'\n    class MyButton extends React.Component {\n      handleClick() { /* ... */ }\n      render() { return <button onClick={this.handleClick.bind(this)}>Click Me</button>; }\n    }\n    // Or using arrow function class property (preferred):\n    class MyButton extends React.Component {\n      handleClick = () => { /* ... */ };\n      render() { return <button onClick={this.handleClick}>Click Me</button>; }\n    }\n    ```\n\n6.  **`preventDefault()` and `stopPropagation()`:** These methods work similarly to their native counterparts on the `SyntheticEvent` object to prevent default browser behavior or stop event propagation through the DOM. It's important to call them on the `SyntheticEvent` object, not directly on the native event if you were to access it.\n\n### Accessing the Native Event\nIf for some rare reason you need to access the underlying native browser event object, you can do so via `event.nativeEvent` property of the `SyntheticEvent` object.\n\n```jsx\nfunction MyComponent() {\n  const handleButtonClick = (event) => {\n    console.log('Synthetic Event:', event);\n    console.log('Native Event:', event.nativeEvent);\n    event.preventDefault(); // Prevents default behavior (e.g., form submission)\n    event.stopPropagation(); // Stops event from bubbling up\n  };\n\n  return <button onClick={handleButtonClick}>Click Me</button>;\n}\n```\n\nUnderstanding `SyntheticEvent` is crucial for effective event handling and debugging in React applications.",
          "examples": [
            {
              "id": "example_react_events_1",
              "title": "Basic Event Handling with SyntheticEvent",
              "code": "import React, { useState } from 'react';\n\nfunction EventDemo() {\n  const [message, setMessage] = useState('');\n\n  const handleChange = (event) => {\n    // event is a SyntheticEvent object\n    setMessage(`Input value: ${event.target.value}`);\n    console.log('SyntheticEvent type:', event.type);\n    console.log('NativeEvent type:', event.nativeEvent.type);\n  };\n\n  const handleSubmit = (event) => {\n    // Prevent default form submission behavior (page reload)\n    event.preventDefault();\n    alert('Form submitted with message: ' + message);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"text\" value={message} onChange={handleChange} placeholder=\"Type something...\" />\n      <button type=\"submit\">Submit</button>\n      <p>{message}</p>\n    </form>\n  );\n}",
              "explanation": "This example demonstrates how React event handlers receive `SyntheticEvent` objects. The `handleChange` function updates state based on `event.target.value`, showing how `SyntheticEvent` provides access to common DOM event properties. The `handleSubmit` function uses `event.preventDefault()` to stop the default form submission behavior, which would typically cause a page reload.",
              "language": "typescript"
            },
            {
              "id": "example_react_events_2",
              "title": "Event Propagation and `stopPropagation`",
              "code": "import React from 'react';\n\nfunction ParentComponent() {\n  const handleParentClick = () => {\n    console.log('Parent div clicked!');\n  };\n\n  const handleChildClick = (event) => {\n    event.stopPropagation(); // Stop the event from bubbling up to the parent div\n    console.log('Child button clicked!');\n  };\n\n  return (\n    <div onClick={handleParentClick} style={{ padding: '20px', border: '1px solid blue' }}>\n      Parent Div\n      <button onClick={handleChildClick} style={{ marginLeft: '10px' }}>\n        Child Button\n      </button>\n    </div>\n  );\n}",
              "explanation": "This example illustrates event propagation in React's SyntheticEvent system and the use of `event.stopPropagation()`. When the 'Child Button' is clicked, `handleChildClick` is invoked. Because `event.stopPropagation()` is called, the click event does not propagate up to the `ParentComponent`'s `div`, preventing `handleParentClick` from being triggered. If `stopPropagation()` were removed, clicking the button would trigger both handlers.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_events_1",
            "question_react_events_2",
            "question_react_events_3",
            "question_react_events_4",
            "question_react_events_5",
            "question_react_events_6"
          ],
          "relatedTasks": [
            "task_react_events_1"
          ],
          "tags": [
            "React Events",
            "SyntheticEvent",
            "DOM Events",
            "Event Delegation",
            "Cross-Browser Compatibility",
            "Performance Optimization"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "JavaScript Events"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Interactive UI development",
            "Form handling",
            "Performance understanding"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_https_setup_1",
          "topic": "Enabling HTTPS in React Development",
          "level": "easy",
          "type": "flashcard",
          "question": "What environment variable needs to be set to enable HTTPS for a Create React App development server?",
          "answer": "HTTPS",
          "analysisPoints": [
            "Recalling the specific environment variable name."
          ],
          "keyConcepts": [
            "HTTPS environment variable",
            "Create React App development"
          ],
          "evaluationCriteria": [
            "Memory recall of configuration settings."
          ],
          "example": null,
          "tags": [
            "React",
            "HTTPS",
            "Environment Variable"
          ],
          "prerequisites": [
            "Create React App"
          ],
          "complexity": 2,
          "interviewFrequency": 3,
          "learningPath": "beginner"
        },
        {
          "id": "question_https_setup_2",
          "topic": "Enabling HTTPS in React Development",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following commands would correctly start a React development server with HTTPS enabled on a Windows system?",
          "answer": "set HTTPS=true && npm start",
          "options": [
            "start HTTPS=true && npm start",
            "HTTPS=true npm start",
            "npm start --https",
            "set HTTPS=true && npm start"
          ],
          "analysisPoints": [
            "Knowledge of Windows command line syntax for setting environment variables.",
            "Understanding of how Create React App utilizes the `HTTPS` variable."
          ],
          "keyConcepts": [
            "HTTPS environment variable",
            "Windows CLI syntax",
            "Create React App scripts"
          ],
          "evaluationCriteria": [
            "Correct application of command-line syntax.",
            "Distinguishing between platform-specific commands."
          ],
          "example": "The `set` command is used on Windows to set environment variables. `&&` chains commands, ensuring `npm start` runs after the variable is set. `HTTPS=true npm start` is for Unix-like systems. `--https` is not the standard way CRA enables HTTPS from the CLI.",
          "tags": [
            "React",
            "HTTPS",
            "CLI",
            "Windows"
          ],
          "prerequisites": [
            "Node.js",
            "npm"
          ],
          "complexity": 4,
          "interviewFrequency": 4,
          "learningPath": "beginner"
        },
        {
          "id": "question_https_setup_3",
          "topic": "Enabling HTTPS in React Development",
          "level": "medium",
          "type": "open",
          "question": "Why might a frontend developer choose to enable HTTPS for their local React development server, even if the production environment uses a CDN or proxy that handles HTTPS?",
          "answer": "A frontend developer might enable HTTPS for their local React development server for several reasons:\n\n1.  **Testing Browser Features:** Many modern web features, such as Service Workers, Web Push Notifications, Geolocation API, WebRTC, and WebAuthn, require a 'secure context' (HTTPS) to function. Developing locally over HTTP would prevent these features from being tested effectively.\n2.  **API Interaction:** If the application interacts with external APIs that strictly enforce HTTPS for all requests, making local HTTP requests to them might result in CORS errors or blocked requests. Running locally over HTTPS avoids these issues.\n3.  **Production Parity:** Ensuring the development environment closely mirrors the production environment can help catch subtle bugs or misbehaviors that might only manifest when served over HTTPS. This includes issues related to mixed content warnings or insecure script loading.\n4.  **Security Best Practices:** Even for local development, adopting secure practices like HTTPS helps reinforce good habits and prepares the developer for security considerations in production.\n5.  **Reduced Browser Warnings:** Browsers increasingly flag HTTP connections as 'Not Secure'. While a minor nuisance in development, enabling HTTPS removes these constant warnings, leading to a cleaner development experience.",
          "analysisPoints": [
            "Understanding of browser security features that require HTTPS.",
            "Awareness of API security policies.",
            "Concept of development environment parity with production.",
            "General web security best practices."
          ],
          "keyConcepts": [
            "Secure Context",
            "Service Workers",
            "CORS",
            "Mixed Content",
            "Development vs. Production environment"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of technical reasons.",
            "Ability to connect different web concepts.",
            "Practical understanding of development workflows."
          ],
          "example": null,
          "tags": [
            "React",
            "HTTPS",
            "Web Security",
            "Development Practices",
            "Service Workers",
            "API"
          ],
          "prerequisites": [
            "Web security basics",
            "CORS",
            "API calls"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_https_setup_4",
          "topic": "Enabling HTTPS in React Development",
          "level": "easy",
          "type": "mcq",
          "question": "When running `npm start` in a Create React App project, where can you modify the script to ensure HTTPS is enabled by default without needing to type extra commands every time?",
          "answer": "In the `scripts` section of `package.json`",
          "options": [
            "In `index.js` or `App.js`",
            "In the `config` folder of your project",
            "In the `scripts` section of `package.json`",
            "By creating a `.env` file with `HTTPS=true`"
          ],
          "analysisPoints": [
            "Knowing the standard configuration files for `npm` scripts.",
            "Understanding how environment variables are typically set for build/start processes."
          ],
          "keyConcepts": [
            "package.json",
            "npm scripts",
            "Environment variables"
          ],
          "evaluationCriteria": [
            "Correct identification of the project configuration file.",
            "Understanding of common React project setup."
          ],
          "example": "The `package.json` file's `scripts` section is where `npm` commands are defined, allowing you to prepend environment variables like `HTTPS=true` directly to the `start` script. While a `.env` file can also be used for environment variables, the direct script modification is explicitly shown and common for this particular setup.",
          "tags": [
            "React",
            "HTTPS",
            "package.json",
            "npm scripts"
          ],
          "prerequisites": [
            "React project structure"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_reducer_1",
          "topic": "useReducer Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two main values returned by the `useReducer` hook?",
          "answer": "The current state and the dispatch function.",
          "analysisPoints": [
            "Recalling the destructuring assignment of `useReducer`."
          ],
          "keyConcepts": [
            "useReducer hook signature",
            "state",
            "dispatch function"
          ],
          "evaluationCriteria": [
            "Memory recall of hook return values."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "useReducer"
          ],
          "prerequisites": [
            "React Hooks basics"
          ],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_2",
          "topic": "useReducer Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `reducer` function and initial state:\n\n```javascript\nconst initialState = { count: 10, isActive: false };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'TOGGLE_ACTIVE':\n      return { ...state, isActive: !state.isActive };\n    case 'ADD':\n      return { ...state, count: state.count + action.payload };\n    case 'RESET':\n      return initialState;\n    default:\n      throw new Error();\n  }\n}\n```\n\nIf the current state is `{ count: 5, isActive: true }` and `dispatch({ type: 'ADD', payload: 3 })` is called, what will be the next state?",
          "answer": "{ count: 8, isActive: true }",
          "options": [
            "{ count: 13, isActive: true }",
            "{ count: 8, isActive: true }",
            "{ count: 5, isActive: true, payload: 3 }",
            "{ count: 8, isActive: false }"
          ],
          "analysisPoints": [
            "Understanding how reducer functions process actions.",
            "Correctly applying the `payload` from the action.",
            "Recognizing that other state properties remain unchanged unless explicitly modified."
          ],
          "keyConcepts": [
            "Reducer function logic",
            "Action payload",
            "Immutability",
            "State updates"
          ],
          "evaluationCriteria": [
            "Ability to trace state changes in a reducer.",
            "Correctly interpret action types and payloads."
          ],
          "example": "The current state is `{ count: 5, isActive: true }`. The `ADD` action type is dispatched with a `payload` of `3`. The reducer creates a new state object, spreading the existing state and updating `count` to `state.count + action.payload`, which is `5 + 3 = 8`. The `isActive` property remains `true` as it's not affected by this action.",
          "tags": [
            "React Hooks",
            "useReducer",
            "State Management"
          ],
          "prerequisites": [
            "JavaScript objects",
            "Reducer pattern"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_3",
          "topic": "useReducer Hook",
          "level": "hard",
          "type": "code",
          "question": "Implement a `TaskReducer` that manages a list of tasks. Each task object should have an `id` (unique number), `text` (string), and `completed` (boolean). The reducer should support the following actions:\n\n*   `ADD_TASK`: Adds a new task. The action payload should be `{ text: string }`. The new task should automatically get a unique `id` and `completed: false`.\n*   `TOGGLE_TASK`: Toggles the `completed` status of a task. The action payload should be `{ id: number }`.\n*   `DELETE_TASK`: Removes a task from the list. The action payload should be `{ id: number }`.\n\nProvide the `initialState` and the `reducer` function.",
          "answer": "```typescript\nconst initialTasksState = [];\n\nfunction taskReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_TASK':\n      return [\n        ...state,\n        {\n          id: Date.now(), // Simple unique ID generation\n          text: action.payload.text,\n          completed: false,\n        },\n      ];\n    case 'TOGGLE_TASK':\n      return state.map((task) =>\n        task.id === action.payload.id\n          ? { ...task, completed: !task.completed }\n          : task\n      );\n    case 'DELETE_TASK':\n      return state.filter((task) => task.id !== action.payload.id);\n    default:\n      throw new Error(`Unsupported action type: ${action.type}`);\n  }\n}\n\n// Example Usage (for testing):\n// const [tasks, dispatch] = useReducer(taskReducer, initialTasksState);\n// dispatch({ type: 'ADD_TASK', payload: { text: 'Learn React' } });\n// dispatch({ type: 'ADD_TASK', payload: { text: 'Build a project' } });\n// dispatch({ type: 'TOGGLE_TASK', payload: { id: tasks[0]?.id } });\n// dispatch({ type: 'DELETE_TASK', payload: { id: tasks[1]?.id } });\n```",
          "analysisPoints": [
            "Ability to define initial state for a list.",
            "Correctly implementing `ADD_TASK` with new object creation and unique ID generation (e.g., `Date.now()`).",
            "Using `map` for `TOGGLE_TASK` to create a new array with updated element, demonstrating immutability.",
            "Using `filter` for `DELETE_TASK` to create a new array without the removed element, demonstrating immutability.",
            "Handling the `default` case for unknown action types."
          ],
          "keyConcepts": [
            "Reducer pattern",
            "Immutability (spread operator, map, filter)",
            "State shape design",
            "Action types and payloads"
          ],
          "evaluationCriteria": [
            "Correctness of reducer logic for all actions.",
            "Adherence to immutability principles.",
            "Effective use of array methods (`map`, `filter`).",
            "Appropriate handling of unique IDs."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "useReducer",
            "State Management",
            "Immutability",
            "Coding Challenge"
          ],
          "prerequisites": [
            "JavaScript array methods",
            "Object destructuring",
            "Reducer pattern"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_reducer_4",
          "topic": "useReducer Hook",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary benefits of using `useReducer` over `useState` for state management in a React functional component. Provide a scenario where `useReducer` would be clearly preferred.",
          "answer": "The primary benefits of `useReducer` over `useState` are:\n\n1.  **Complex State Logic:** `useReducer` shines when state updates involve complex logic, multiple related sub-values, or when the next state depends heavily on the previous state. `useState` can lead to verbose and error-prone code with multiple `setState` calls and `prev => ...` patterns.\n2.  **Predictable State Transitions:** By centralizing state logic within a single `reducer` function, all possible state transitions are defined in one place. This makes the state predictable, easier to understand, test, and debug, similar to the Redux pattern.\n3.  **Separation of Concerns:** The state update logic (the reducer) is separated from the component's rendering logic. This improves readability and maintainability.\n4.  **Performance Optimization (Stable `dispatch`):** The `dispatch` function returned by `useReducer` has a stable identity and won't change on re-renders. This allows child components that receive `dispatch` as a prop to be effectively memoized using `React.memo` without unnecessary re-renders, unlike `setState` from `useState` which can be wrapped in `useCallback` for similar effect but is less straightforward for complex updates.\n5.  **Scalability:** For features with many possible interactions and derived states, `useReducer` scales better than a multitude of `useState` calls.\n\n**Scenario where `useReducer` is clearly preferred:**\nConsider a complex multi-step form with several interdependent fields, validation rules, and different submission states (e.g., `idle`, `submitting`, `success`, `error`). Using `useState` might involve many individual state variables (`formData`, `validationErrors`, `isSubmitting`, `submitStatus`, etc.) and complex conditional logic in the component to update them. With `useReducer`, you could have a single state object like `{ formData: {}, errors: {}, status: 'idle' }` and a `reducer` function that handles actions like `UPDATE_FIELD`, `VALIDATE_FORM`, `SUBMIT_START`, `SUBMIT_SUCCESS`, `SUBMIT_ERROR`. This centralizes all form logic, making it more manageable, testable, and ensuring consistent state transitions.",
          "analysisPoints": [
            "Ability to articulate the specific advantages of `useReducer`.",
            "Comparison of `useReducer` and `useState`.",
            "Providing a concrete and relevant use-case scenario.",
            "Discussing benefits like predictability, testability, and performance."
          ],
          "keyConcepts": [
            "useReducer vs. useState",
            "Complex state logic",
            "Predictable state management",
            "Separation of concerns",
            "Performance optimization (dispatch identity)",
            "State transitions"
          ],
          "evaluationCriteria": [
            "Clarity and depth of explanation.",
            "Relevance and aptness of the provided scenario.",
            "Demonstration of comprehensive understanding of state management in React."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "useReducer",
            "useState",
            "State Management",
            "Design Patterns"
          ],
          "prerequisites": [
            "React Hooks",
            "State management concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_5",
          "topic": "useReducer Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about `useReducer`'s `reducer` function is TRUE?",
          "answer": "It must be a pure function that returns a new state object.",
          "options": [
            "It can perform side effects like fetching data or setting timers.",
            "It directly mutates the `state` object passed to it.",
            "It must be a pure function that returns a new state object.",
            "It automatically batches multiple `dispatch` calls within a single render cycle."
          ],
          "analysisPoints": [
            "Understanding the purity requirement of reducer functions.",
            "Knowledge of immutability in state updates.",
            "Distinguishing reducer responsibilities from component effects."
          ],
          "keyConcepts": [
            "Pure function",
            "Immutability",
            "Side effects",
            "Reducer pattern"
          ],
          "evaluationCriteria": [
            "Correct identification of reducer properties.",
            "Understanding of functional programming principles in React."
          ],
          "example": "Reducers must be pure functions: given the same inputs (state and action), they must always produce the same output (new state) without any side effects (like API calls or DOM manipulation). They must also return a *new* state object, never directly modify the existing one. While React *does* batch updates, this is a property of `dispatch` and React's scheduler, not the `reducer` function itself.",
          "tags": [
            "React Hooks",
            "useReducer",
            "Pure Functions",
            "Immutability"
          ],
          "prerequisites": [
            "Functional programming basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_6",
          "topic": "useReducer Hook",
          "level": "medium",
          "type": "flashcard",
          "question": "In the `useReducer` hook, what is the purpose of the `action.payload` property?",
          "answer": "To carry any additional data needed by the reducer to compute the new state.",
          "analysisPoints": [
            "Understanding the structure and role of action objects.",
            "Distinguishing between action type and data."
          ],
          "keyConcepts": [
            "Action object",
            "Payload",
            "Reducer input"
          ],
          "evaluationCriteria": [
            "Accurate definition of `payload`'s role."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "useReducer",
            "Action Object"
          ],
          "prerequisites": [
            "Reducer pattern basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_7",
          "topic": "useReducer Hook",
          "level": "easy",
          "type": "mcq",
          "question": "Given the following `initialState` and `reducer` from the provided content, what would be the result of calling `dispatch({ type: 'RESET' })` when the current `count` is 5 and `loading` is true?\n\n```javascript\n// Initial state\nconst initialState = {\n  count: 0,\n  loading: false,\n  error: null,\n  data: null\n};\n\n// Reducer function\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    case 'RESET':\n      return { ...state, count: 0 };\n    // ... other cases\n  }\n}\n```",
          "answer": "{ count: 0, loading: true, error: null, data: null }",
          "options": [
            "{ count: 0, loading: false, error: null, data: null }",
            "{ count: 0, loading: true, error: null, data: null }",
            "{ count: 5, loading: true, error: null, data: null }",
            "An error, as `loading` is not handled by `RESET`."
          ],
          "analysisPoints": [
            "Correctly interpreting the `RESET` action logic (`return { ...state, count: 0 }`).",
            "Understanding that `...state` preserves other properties of the current state.",
            "Differentiating between returning `initialState` directly vs. modifying current state."
          ],
          "keyConcepts": [
            "Reducer logic",
            "Spread operator",
            "Immutability",
            "State preservation"
          ],
          "evaluationCriteria": [
            "Accurate trace of state change.",
            "Understanding of how `...state` functions."
          ],
          "example": "The `RESET` action specifically sets `count: 0` while spreading the *current* `state`. This means `loading`, `error`, and `data` retain their values from the state *before* the dispatch. If the reducer had `return initialState;`, then `loading` would revert to `false`.",
          "tags": [
            "React Hooks",
            "useReducer",
            "State Logic"
          ],
          "prerequisites": [
            "JavaScript objects",
            "Spread operator"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_8",
          "topic": "useReducer Hook",
          "level": "medium",
          "type": "open",
          "question": "Can `useReducer` be used for global state management across multiple components without libraries like Redux or React Context? If so, how, and what are the limitations?",
          "answer": "Yes, `useReducer` can be effectively combined with React's `Context API` to manage global state across multiple components. This pattern is often referred to as the 'Context + Reducer' pattern.\n\n**How it works:**\n1.  **Create a Context:** Create a React Context (e.g., `StateContext` and `DispatchContext`).\n2.  **Define Reducer and Initial State:** Define your `reducer` function and `initialState` outside of any component.\n3.  **Provide Context:** In a common ancestor component (e.g., `App.js` or a dedicated `StoreProvider` component), call `useReducer` to get the `state` and `dispatch` function. Then, provide the `state` via `StateContext.Provider` and `dispatch` via `DispatchContext.Provider` to their children.\n4.  **Consume Context:** In any descendant component, use `useContext(StateContext)` to get the global state and `useContext(DispatchContext)` to get the dispatch function, allowing them to read state and dispatch actions.\n\n**Limitations:**\n1.  **Re-renders:** Any component consuming the `StateContext` will re-render whenever *any part* of the state managed by that context changes. This can lead to performance issues if the global state is very large and frequently updated, requiring careful use of memoization (`React.memo`, `useCallback`, `useMemo`).\n2.  **Single Global Store:** It's typically one large global state object. If you need distinct, isolated state domains, you might end up creating multiple contexts, which can add complexity.\n3.  **No Middleware or DevTools out-of-the-box:** Unlike Redux, the Context + Reducer pattern doesn't natively support middleware (for async actions, logging, etc.) or powerful developer tools (like Redux DevTools) without custom implementations.\n4.  **Boilerplate:** While less than full Redux, setting up the provider and consumer pattern can still involve some boilerplate, especially for larger applications with many different state slices.",
          "analysisPoints": [
            "Knowledge of `useReducer` and `Context API` integration.",
            "Ability to describe the implementation pattern.",
            "Identification of key limitations (performance, tooling, scalability for very large apps).",
            "Comparison to dedicated state management libraries."
          ],
          "keyConcepts": [
            "React Context API",
            "Global state management",
            "Context + Reducer pattern",
            "Performance considerations",
            "Middleware",
            "Developer tools"
          ],
          "evaluationCriteria": [
            "Accurate explanation of the pattern.",
            "Thorough discussion of advantages and disadvantages.",
            "Demonstration of practical architectural knowledge."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "useReducer",
            "React Context",
            "Global State",
            "Architecture",
            "Performance"
          ],
          "prerequisites": [
            "React Context API",
            "useReducer Hook"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_reducer_9",
          "topic": "useReducer Hook",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a typical component of an `action` object dispatched to a `useReducer` hook?",
          "answer": "A function to compute the next state directly.",
          "options": [
            "A `type` property (string).",
            "A `payload` property (any data).",
            "A function to compute the next state directly.",
            "An `id` property for targeting specific items (if applicable)."
          ],
          "analysisPoints": [
            "Understanding the standard structure of a Redux-like action object.",
            "Distinguishing between an action (what happened) and a reducer (how to update state)."
          ],
          "keyConcepts": [
            "Action object structure",
            "Action type",
            "Action payload",
            "Reducer function"
          ],
          "evaluationCriteria": [
            "Correct identification of invalid action component.",
            "Clear understanding of action's role."
          ],
          "example": "An action object describes *what* happened, typically with a `type` and relevant `payload` data. The *how* to compute the next state is the responsibility of the `reducer` function, not part of the `action` itself. An `id` property might be part of the `payload` for actions that target specific items (like toggling a task).",
          "tags": [
            "React Hooks",
            "useReducer",
            "Action Object"
          ],
          "prerequisites": [
            "Reducer pattern"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_default_props_1",
          "topic": "Default Props",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `defaultProps` in React components?",
          "answer": "To define default values for component props that are not explicitly provided by the parent or are `undefined`.",
          "analysisPoints": [
            "Understanding the core function of `defaultProps`."
          ],
          "keyConcepts": [
            "defaultProps",
            "Component props",
            "Default values"
          ],
          "evaluationCriteria": [
            "Accurate and concise definition."
          ],
          "example": null,
          "tags": [
            "React",
            "Props",
            "defaultProps"
          ],
          "prerequisites": [
            "React components",
            "Props"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_default_props_2",
          "topic": "Default Props",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React functional component definition:\n\n```jsx\nfunction UserAvatar({ username, size }) {\n  return (\n    <div style={{ width: size, height: size, borderRadius: '50%', backgroundColor: 'lightgray' }}>\n      <span>{username ? username[0].toUpperCase() : '?' }</span>\n    </div>\n  );\n}\n\nUserAvatar.defaultProps = {\n  username: 'Guest User',\n  size: 50\n};\n```\n\nWhat will be the rendered output (specifically the `username` and `size` values) for the following usage:\n`<UserAvatar size={75} username={null} />`",
          "answer": "username: `null`, size: `75`",
          "options": [
            "username: `'Guest User'`, size: `50`",
            "username: `null`, size: `75`",
            "username: `'Guest User'`, size: `75`",
            "username: `null`, size: `50`"
          ],
          "analysisPoints": [
            "Understanding that `defaultProps` apply when a prop is `undefined`, but not `null`.",
            "Correctly identifying that explicitly passed props override defaults."
          ],
          "keyConcepts": [
            "defaultProps application",
            "`undefined` vs. `null`",
            "Prop overriding"
          ],
          "evaluationCriteria": [
            "Accurate application of `defaultProps` rules.",
            "Distinguishing between `null` and `undefined` behavior."
          ],
          "example": "The `size` prop is explicitly passed as `75`, so it overrides the default `50`. The `username` prop is explicitly passed as `null`. `defaultProps` only apply when a prop is `undefined` or not passed at all. Since `null` is a defined value, it overrides the default `'Guest User'`, meaning `username` inside the component will be `null`.",
          "tags": [
            "React",
            "Props",
            "defaultProps",
            "JavaScript"
          ],
          "prerequisites": [
            "React props",
            "JavaScript primitives"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_default_props_3",
          "topic": "Default Props",
          "level": "medium",
          "type": "open",
          "question": "Discuss the two main ways to provide default values for props in a React functional component. What are the advantages and disadvantages of each, and when might you prefer one over the other?",
          "answer": "The two main ways to provide default values for props in a React functional component are:\n\n1.  **Using `Component.defaultProps`:**\n    ```jsx\n    function MyComponent({ text, count }) {\n      return <p>{text}: {count}</p>;\n    }\n    MyComponent.defaultProps = {\n      text: 'Default Text',\n      count: 0\n    };\n    ```\n    *   **Advantages:**\n        *   Explicitly declares defaults outside the function body, which can be useful for tooling or quick reference.\n        *   Works identically for class components, providing consistency across component types in older codebases.\n        *   Defaults are applied even if the prop is passed as `undefined`.\n    *   **Disadvantages:**\n        *   Requires an extra line of code outside the component's main definition.\n        *   Less concise than ES6 default parameters for functional components.\n        *   Can be overlooked if not checked in documentation.\n\n2.  **Using ES6 Default Parameters in function destructuring:**\n    ```jsx\n    function MyComponent({ text = 'Default Text', count = 0 }) {\n      return <p>{text}: {count}</p>;\n    }\n    ```\n    *   **Advantages:**\n        *   More concise and readable, as defaults are defined directly in the function signature.\n        *   Leverages standard JavaScript syntax, making it familiar to developers.\n        *   Integrates naturally with destructuring.\n    *   **Disadvantages:**\n        *   Specific to functional components (not directly applicable to class components).\n        *   Only applies when the prop is `undefined` or not passed; it does **not** apply if the prop is explicitly `null`.\n\n**When to prefer one over the other:**\n*   **Prefer ES6 Default Parameters** for new functional components due to their conciseness and alignment with modern JavaScript best practices, especially when the prop being passed `null` is not a relevant use case for a default value. It's often considered cleaner.\n*   **Consider `Component.defaultProps`** when:\n    *   Working with older codebases that primarily use `defaultProps` or class components.\n    *   You need the default to apply even if the prop is explicitly `null` (though this is a rare use case).\n    *   You want external tools or `PropTypes` to easily inspect the default values (though ES6 defaults are generally well-supported now too).\n\nIn most modern functional React development, ES6 default parameters are the preferred approach for their brevity and clarity.",
          "analysisPoints": [
            "Identification of both methods.",
            "Accurate description of syntax for each.",
            "Balanced discussion of advantages and disadvantages.",
            "Clear guidance on when to choose each method."
          ],
          "keyConcepts": [
            "defaultProps",
            "ES6 Default Parameters",
            "Functional components",
            "Prop definition",
            "`undefined` vs. `null`"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison.",
            "Practical advice on usage.",
            "Understanding of nuances like `null` handling."
          ],
          "example": null,
          "tags": [
            "React",
            "Props",
            "defaultProps",
            "ES6",
            "Functional Components",
            "Best Practices"
          ],
          "prerequisites": [
            "React components",
            "JavaScript ES6"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_default_props_4",
          "topic": "Default Props",
          "level": "easy",
          "type": "mcq",
          "question": "If a component has a `defaultProps` defined for a `theme` prop (`theme: 'light'`), and a parent component passes `theme={null}` to it, what will be the value of `theme` inside the component?",
          "answer": "`null`",
          "options": [
            "`'light'`",
            "`undefined`",
            "`null`",
            "An error will be thrown"
          ],
          "analysisPoints": [
            "Confirming the behavior of `defaultProps` when `null` is explicitly passed."
          ],
          "keyConcepts": [
            "defaultProps behavior",
            "`null` vs `undefined`",
            "Prop precedence"
          ],
          "evaluationCriteria": [
            "Correctly predicting prop resolution.",
            "Demonstrating knowledge of `defaultProps` edge cases."
          ],
          "example": "The `defaultProps` are only used if the prop is `undefined` or not provided. If a prop is explicitly passed as `null`, `null` is considered a valid value, and it will override the default. Therefore, `theme` will be `null`.",
          "tags": [
            "React",
            "Props",
            "defaultProps",
            "Edge Cases"
          ],
          "prerequisites": [
            "React props"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_default_props_5",
          "topic": "Default Props",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following functional component to use ES6 default parameters for `color` and `size`, instead of `defaultProps`. The default `color` should be `'blue'` and default `size` should be `'medium'`.\n\n```jsx\nimport React from 'react';\n\nfunction StyledText({ content, color, size }) {\n  const style = {\n    color: color,\n    fontSize: size === 'small' ? '12px' : size === 'medium' ? '16px' : '20px'\n  };\n  return <p style={style}>{content}</p>;\n}\n\nStyledText.defaultProps = {\n  color: 'red',\n  size: 'large'\n};\n\n// Example usage:\n// <StyledText content=\"Hello\" />\n// <StyledText content=\"World\" color=\"green\" size=\"small\" />\n```",
          "answer": "```jsx\nimport React from 'react';\n\nfunction StyledText({ content, color = 'blue', size = 'medium' }) {\n  const style = {\n    color: color,\n    fontSize: size === 'small' ? '12px' : size === 'medium' ? '16px' : '20px'\n  };\n  return <p style={style}>{content}</p>;\n}\n\n// Example usage (remains the same):\n// <StyledText content=\"Hello\" /> // color: 'blue', size: 'medium'\n// <StyledText content=\"World\" color=\"green\" size=\"small\" />\n```",
          "analysisPoints": [
            "Ability to convert from `defaultProps` to ES6 default parameters.",
            "Correctly applying default values within destructuring.",
            "Maintaining existing component logic and functionality."
          ],
          "keyConcepts": [
            "ES6 Default Parameters",
            "Functional component props",
            "Destructuring assignment"
          ],
          "evaluationCriteria": [
            "Correct use of ES6 default parameters syntax.",
            "Functional equivalence to the original code."
          ],
          "example": null,
          "tags": [
            "React",
            "Props",
            "ES6",
            "Refactoring",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React functional components",
            "ES6 destructuring"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_spread_operator_1",
          "topic": "Spread Operator",
          "level": "easy",
          "type": "flashcard",
          "question": "What symbol is used for the spread operator in JavaScript?",
          "answer": "`...` (three dots)",
          "analysisPoints": [
            "Recalling the syntax of the spread operator."
          ],
          "keyConcepts": [
            "Spread operator syntax"
          ],
          "evaluationCriteria": [
            "Basic syntax recall."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "ES6",
            "Spread Operator"
          ],
          "prerequisites": [
            "Basic JavaScript"
          ],
          "complexity": 1,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_spread_operator_2",
          "topic": "Spread Operator",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following JavaScript code:\n\n```javascript\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\n\nconst mergedObj = { ...obj1, ...obj2 };\n```\n\nWhat will be the value of `mergedObj`?",
          "answer": "`{ a: 1, b: 3, c: 4 }`",
          "options": [
            "`{ a: 1, b: 2, c: 4 }`",
            "`{ a: 1, b: 3, c: 4 }`",
            "`{ a: 1, b: 2, b: 3, c: 4 }`",
            "`{ b: 3, c: 4, a: 1 }`"
          ],
          "analysisPoints": [
            "Understanding how object spread handles duplicate keys (last-in wins).",
            "Correctly merging properties from multiple objects."
          ],
          "keyConcepts": [
            "Object spread",
            "Duplicate keys",
            "Object merging"
          ],
          "evaluationCriteria": [
            "Accurate prediction of object merge result.",
            "Knowledge of spread operator precedence."
          ],
          "example": "When merging objects with the spread operator, if there are duplicate keys (like `b` in this case), the value from the *last* object spread will overwrite previous values. So, `b: 3` from `obj2` overwrites `b: 2` from `obj1`.",
          "tags": [
            "JavaScript",
            "ES6",
            "Spread Operator",
            "Object Manipulation"
          ],
          "prerequisites": [
            "JavaScript objects"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_spread_operator_3",
          "topic": "Spread Operator",
          "level": "medium",
          "type": "open",
          "question": "Explain what a 'shallow copy' means in the context of the spread operator when copying arrays or objects. Provide a short code example to illustrate its implication.",
          "answer": "A 'shallow copy' created by the spread operator means that a new top-level array or object is created, but if the original array/object contains nested objects or arrays, those nested structures are *not* copied. Instead, the new array/object will contain *references* to the same nested objects/arrays as the original. This implies that if you modify a nested object/array in the shallow copy, the original object/array will also be affected because they both point to the same memory location for that nested structure.\n\n**Code Example:**\n\n```javascript\nconst originalUser = {\n  id: 1,\n  name: 'Alice',\n  address: { street: '123 Main St', city: 'Anytown' },\n  hobbies: ['reading', 'hiking']\n};\n\n// Create a shallow copy\nconst shallowCopyUser = { ...originalUser };\n\n// Modify a top-level property - this works as expected\nshallowCopyUser.name = 'Bob';\nconsole.log(originalUser.name); // Output: 'Alice' (original is unchanged)\n\n// Modify a nested object property - this AFFECTS THE ORIGINAL\nshallowCopyUser.address.city = 'Newcity';\nconsole.log(originalUser.address.city); // Output: 'Newcity' (Original also changed!)\n\n// Modify a nested array property - this AFFECTS THE ORIGINAL\nshallowCopyUser.hobbies.push('coding');\nconsole.log(originalUser.hobbies); // Output: ['reading', 'hiking', 'coding'] (Original also changed!)\n\nconsole.log(originalUser === shallowCopyUser); // false (different top-level objects)\nconsole.log(originalUser.address === shallowCopyUser.address); // true (same nested object reference)\n```\n\nThe example shows that while `shallowCopyUser` is a new object at the top level, its `address` and `hobbies` properties still refer to the *exact same objects/arrays* as `originalUser`'s `address` and `hobbies`. Therefore, changes to these nested references in the shallow copy propagate to the original.",
          "analysisPoints": [
            "Clear definition of shallow copy.",
            "Explanation of how nested references behave.",
            "Demonstration with a practical code example.",
            "Ability to differentiate from deep copy implications."
          ],
          "keyConcepts": [
            "Shallow copy",
            "Deep copy",
            "Object references",
            "Immutability",
            "Nested objects/arrays"
          ],
          "evaluationCriteria": [
            "Accurate technical explanation.",
            "Effective and illustrative code example.",
            "Understanding of memory management implications."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "ES6",
            "Spread Operator",
            "Shallow Copy",
            "Immutability",
            "Memory Management"
          ],
          "prerequisites": [
            "JavaScript objects and arrays",
            "References vs. values"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_spread_operator_4",
          "topic": "Spread Operator",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is a common use case for the spread operator (`...`) in React development?",
          "answer": "Passing all properties from `props` object to a child component.",
          "options": [
            "Directly mutating component state objects.",
            "Creating a deep clone of a complex state object.",
            "Performing asynchronous operations within a functional component.",
            "Passing all properties from `props` object to a child component."
          ],
          "analysisPoints": [
            "Identifying correct and incorrect applications of the spread operator in React context.",
            "Understanding immutability principles in React state updates."
          ],
          "keyConcepts": [
            "React props",
            "Object spread",
            "Immutability",
            "Deep vs. shallow copy"
          ],
          "evaluationCriteria": [
            "Correctly identifying a relevant React use case.",
            "Distinguishing valid from invalid uses related to React patterns."
          ],
          "example": "The spread operator is commonly used as `<ChildComponent {...this.props} />` (or `<ChildComponent {...props} />` in functional components) to pass all parent's props to a child. It is used for *immutable* updates, not direct mutation, and it performs a *shallow* copy, not a deep clone.",
          "tags": [
            "React",
            "Spread Operator",
            "Props",
            "Best Practices"
          ],
          "prerequisites": [
            "React props"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_spread_operator_5",
          "topic": "Spread Operator",
          "level": "medium",
          "type": "code",
          "question": "Write a JavaScript function `updateConfig` that takes an existing `config` object and an `updates` object. The function should return a *new* configuration object that is a shallow merge of the `config` and `updates`, with properties in `updates` overriding those in `config`.\n\nExample:\n`updateConfig({ theme: 'dark', font: 'Arial' }, { font: 'Roboto', notifications: true })` should return `{ theme: 'dark', font: 'Roboto', notifications: true }`",
          "answer": "```javascript\nfunction updateConfig(config, updates) {\n  return { ...config, ...updates };\n}\n\n// Test Cases:\nconsole.log(updateConfig({ theme: 'dark', font: 'Arial' }, { font: 'Roboto', notifications: true }));\n// Expected: { theme: 'dark', font: 'Roboto', notifications: true }\n\nconsole.log(updateConfig({ name: 'App', version: '1.0' }, { version: '2.0', author: 'Dev' }));\n// Expected: { name: 'App', version: '2.0', author: 'Dev' }\n\nconsole.log(updateConfig({ data: { a: 1 } }, { data: { b: 2 } }));\n// Expected: { data: { b: 2 } } (demonstrates shallow merge for nested objects)\n\nconsole.log(updateConfig({}, { initial: true }));\n// Expected: { initial: true }\n```",
          "analysisPoints": [
            "Correct application of object spread syntax for merging.",
            "Understanding the order of spread for property overriding.",
            "Returning a new object (immutability)."
          ],
          "keyConcepts": [
            "Object spread",
            "Object merging",
            "Immutability",
            "Function parameters"
          ],
          "evaluationCriteria": [
            "Correctness of the merging logic.",
            "Adherence to immutability.",
            "Conciseness and effectiveness of solution."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "ES6",
            "Spread Operator",
            "Object Manipulation",
            "Coding Challenge"
          ],
          "prerequisites": [
            "JavaScript objects"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_spread_operator_6",
          "topic": "Spread Operator",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary difference between the spread operator (`...`) when used in an array literal (e.g., `[...arr1, ...arr2]`) versus when used in function parameters (e.g., `function foo(...args)`)?",
          "answer": "In array literals, it 'spreads' elements; in function parameters, it 'collects' them (rest parameter).",
          "options": [
            "One creates a deep copy, the other a shallow copy.",
            "One is for arrays, the other is for objects.",
            "In array literals, it 'spreads' elements; in function parameters, it 'collects' them (rest parameter).",
            "There is no difference; they are interchangeable."
          ],
          "analysisPoints": [
            "Distinguishing between 'spread' (unpacking) and 'rest' (collecting) usage of the `...` syntax.",
            "Understanding context-dependent meaning of the same syntax."
          ],
          "keyConcepts": [
            "Spread syntax",
            "Rest parameters",
            "Array literals",
            "Function parameters"
          ],
          "evaluationCriteria": [
            "Accurate differentiation of spread vs. rest.",
            "Understanding of contextual usage."
          ],
          "example": "While both use `...`, their roles are opposite based on context. In `[...arr]`, it spreads `arr`'s elements into the new array. In `function foo(...args)`, it collects all remaining arguments into an array named `args`. This is a common point of confusion due to the identical syntax.",
          "tags": [
            "JavaScript",
            "ES6",
            "Spread Operator",
            "Rest Parameters",
            "Syntax"
          ],
          "prerequisites": [
            "ES6 functions",
            "Arrays"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_spread_operator_7",
          "topic": "Spread Operator",
          "level": "hard",
          "type": "code",
          "question": "Implement a JavaScript function `deepMerge` that performs a deep merge of two objects. Unlike the shallow merge of the spread operator, `deepMerge` should recursively merge nested objects. If a key exists in both objects and its value is an object, that nested object should also be merged. For non-object values, `obj2`'s value should override `obj1`'s.\n\nConsider simple objects without arrays or functions for this task.\n\nExample:\n`deepMerge({ a: 1, b: { c: 2 } }, { b: { d: 3 }, e: 4 })` should return `{ a: 1, b: { c: 2, d: 3 }, e: 4 }`",
          "answer": "```javascript\nfunction deepMerge(obj1, obj2) {\n  const result = { ...obj1 }; // Start with a shallow copy of obj1\n\n  for (const key in obj2) {\n    if (Object.prototype.hasOwnProperty.call(obj2, key)) {\n      if (typeof result[key] === 'object' && result[key] !== null &&\n          typeof obj2[key] === 'object' && obj2[key] !== null &&\n          !Array.isArray(result[key]) && !Array.isArray(obj2[key])) {\n        // If both values are non-null objects and not arrays, deep merge them\n        result[key] = deepMerge(result[key], obj2[key]);\n      } else {\n        // Otherwise, obj2's value overrides obj1's\n        result[key] = obj2[key];\n      }\n    }\n  }\n\n  return result;\n}\n\n// Test Cases:\nconsole.log(deepMerge({ a: 1, b: { c: 2 } }, { b: { d: 3 }, e: 4 }));\n// Expected: { a: 1, b: { c: 2, d: 3 }, e: 4 }\n\nconsole.log(deepMerge({ user: { name: 'Alice', age: 30 } }, { user: { age: 31, city: 'NY' }, status: 'active' }));\n// Expected: { user: { name: 'Alice', age: 31, city: 'NY' }, status: 'active' }\n\nconsole.log(deepMerge({ config: { level: 1 } }, { config: { level: 2, enabled: true }, data: 10 }));\n// Expected: { config: { level: 2, enabled: true }, data: 10 }\n\nconsole.log(deepMerge({ a: { b: { c: 1 } } }, { a: { b: { d: 2 } } }));\n// Expected: { a: { b: { c: 1, d: 2 } } }\n\nconsole.log(deepMerge({ a: 1 }, { a: { b: 2 } }));\n// Expected: { a: { b: 2 } } (obj2's object overrides obj1's primitive)\n\nconsole.log(deepMerge({ a: { b: 2 } }, { a: 1 }));\n// Expected: { a: 1 } (obj2's primitive overrides obj1's object)\n```",
          "analysisPoints": [
            "Ability to implement a recursive function for deep merging.",
            "Correctly handling different data types (objects vs. primitives).",
            "Ensuring immutability at each level of recursion by creating new objects.",
            "Proper use of `typeof` and `hasOwnProperty`.",
            "Edge case handling for `null` and arrays (as per prompt, not strictly required but good to exclude from recursion)."
          ],
          "keyConcepts": [
            "Deep merge",
            "Recursion",
            "Object iteration (`for...in`)",
            "Immutability",
            "Type checking",
            "Object property checking"
          ],
          "evaluationCriteria": [
            "Correct recursive logic.",
            "Adherence to immutability.",
            "Robustness in handling various property types.",
            "Efficiency and clarity of the code."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Object Manipulation",
            "Recursion",
            "Deep Copy",
            "Algorithm",
            "Coding Challenge"
          ],
          "prerequisites": [
            "JavaScript objects",
            "Functions",
            "Recursion basics"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_events_1",
          "topic": "React Events (SyntheticEvent)",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the name of React's wrapper around native browser events?",
          "answer": "`SyntheticEvent`",
          "analysisPoints": [
            "Recalling the specific term for React's event system."
          ],
          "keyConcepts": [
            "SyntheticEvent",
            "React events"
          ],
          "evaluationCriteria": [
            "Memory recall of core React concepts."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "SyntheticEvent"
          ],
          "prerequisites": [
            "React basics"
          ],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_events_2",
          "topic": "React Events (SyntheticEvent)",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is a primary benefit of React's `SyntheticEvent` system?",
          "answer": "It provides cross-browser consistency for event properties and behavior.",
          "options": [
            "It allows direct manipulation of the native DOM event object for better performance.",
            "It automatically prevents all default browser behaviors for every event.",
            "It provides cross-browser consistency for event properties and behavior.",
            "It completely replaces browser event delegation with its own custom system."
          ],
          "analysisPoints": [
            "Understanding the core problem `SyntheticEvent` solves (cross-browser compatibility).",
            "Distinguishing benefits from misconceptions about the system."
          ],
          "keyConcepts": [
            "SyntheticEvent",
            "Cross-browser compatibility",
            "Event normalization",
            "Event delegation"
          ],
          "evaluationCriteria": [
            "Correct identification of `SyntheticEvent`'s purpose.",
            "Ability to differentiate correct from incorrect statements."
          ],
          "example": "The primary benefit of `SyntheticEvent` is to normalize event behavior and properties across different browsers, so developers don't have to worry about browser-specific quirks. It doesn't prevent all default behaviors (you still need `preventDefault()`), and while it *uses* event delegation, it doesn't completely replace the browser's underlying system.",
          "tags": [
            "React",
            "Events",
            "SyntheticEvent",
            "Browser Compatibility"
          ],
          "prerequisites": [
            "DOM Events"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_events_3",
          "topic": "React Events (SyntheticEvent)",
          "level": "medium",
          "type": "open",
          "question": "Describe two key differences between handling events in plain HTML/JavaScript versus React's `SyntheticEvent` system. How do these differences impact a frontend developer's work?",
          "answer": "Here are two key differences between plain HTML/JavaScript event handling and React's `SyntheticEvent` system:\n\n1.  **Cross-Browser Consistency (Normalization):**\n    *   **Plain JS:** Native DOM events can have inconsistencies across different browsers (e.g., `event.keyCode` vs. `event.which`, different ways to access `target` or `srcElement`). Developers often need to write conditional code or use polyfills to ensure cross-browser compatibility.\n    *   **React:** `SyntheticEvent` normalizes event properties and behavior across all supported browsers. The `SyntheticEvent` object provides a consistent API, meaning `event.target`, `event.preventDefault()`, `event.stopPropagation()` behave the same regardless of the underlying browser. This greatly simplifies development and reduces debugging time related to browser quirks.\n    *   **Impact:** Developers can write event handling logic once, confident it will work uniformly. It abstracts away browser-specific event implementation details, allowing focus on application logic.\n\n2.  **Event Delegation and Attachment:**\n    *   **Plain JS:** When you attach an event listener (e.g., `element.addEventListener('click', handler)`), a new listener is typically attached directly to that specific DOM element. For a list of many items, this could mean hundreds or thousands of individual listeners, which can be inefficient.\n    *   **React:** React implements its own event delegation system. Instead of attaching a listener to every single DOM element, React attaches a single event listener to the document root (or the container where your React app is mounted). When an event occurs, it bubbles up to this root listener, and React then dispatches it to the appropriate React component's event handler based on its internal virtual DOM representation.\n    *   **Impact:** This delegation significantly improves performance, especially in applications with many interactive elements, by reducing memory consumption and improving startup time. It also means that event handlers are managed by React's efficient reconciliation process, reducing the need for manual DOM manipulation.",
          "analysisPoints": [
            "Clear articulation of normalization and consistency.",
            "Detailed explanation of event delegation and its performance implications.",
            "Comparison of developer experience with both approaches.",
            "Demonstration of understanding the underlying mechanisms."
          ],
          "keyConcepts": [
            "SyntheticEvent",
            "Cross-browser compatibility",
            "Event normalization",
            "Event delegation",
            "Performance optimization",
            "DOM events"
          ],
          "evaluationCriteria": [
            "Accuracy and depth of technical explanation.",
            "Clarity in contrasting the two approaches.",
            "Ability to explain practical impact on development.",
            "Comprehensive understanding of event systems."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "SyntheticEvent",
            "DOM Events",
            "Performance",
            "Architecture"
          ],
          "prerequisites": [
            "JavaScript events",
            "DOM manipulation"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_events_4",
          "topic": "React Events (SyntheticEvent)",
          "level": "easy",
          "type": "mcq",
          "question": "In React, what happens if you call `event.preventDefault()` on a `SyntheticEvent` object within an event handler?",
          "answer": "It prevents the default browser action associated with the event (e.g., a form submission).",
          "options": [
            "It stops the event from bubbling up the DOM tree.",
            "It prevents the default browser action associated with the event (e.g., a form submission).",
            "It persists the `SyntheticEvent` object so its properties can be accessed asynchronously.",
            "It reloads the page to clear the event state."
          ],
          "analysisPoints": [
            "Understanding the specific functionality of `preventDefault()`.",
            "Distinguishing `preventDefault()` from `stopPropagation()` and `persist()`."
          ],
          "keyConcepts": [
            "SyntheticEvent methods",
            "preventDefault()",
            "Default browser actions"
          ],
          "evaluationCriteria": [
            "Correct identification of method behavior.",
            "Clear understanding of event control."
          ],
          "example": "The `event.preventDefault()` method on a `SyntheticEvent` (just like its native counterpart) prevents the browser's default behavior for that event, such as preventing a form from submitting and reloading the page, or preventing a link from navigating. `stopPropagation()` stops bubbling, and `persist()` (now largely unnecessary in React 17+) was for asynchronous access.",
          "tags": [
            "React",
            "Events",
            "SyntheticEvent",
            "preventDefault"
          ],
          "prerequisites": [
            "DOM Events"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_events_5",
          "topic": "React Events (SyntheticEvent)",
          "level": "medium",
          "type": "code",
          "question": "Implement a React functional component `Tooltip` that shows a tooltip when a `div` element is hovered over and hides it when the mouse leaves. Use `onMouseEnter` and `onMouseLeave` event handlers.\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction Tooltip({ text, children }) {\n  // Implement logic here\n  return (\n    <div /* Add event handlers here */ style={{ position: 'relative', display: 'inline-block' }}>\n      {children}\n      {/* Tooltip content to be rendered conditionally */}\n    </div>\n  );\n}\n\n// Example Usage:\n// <Tooltip text=\"This is a helpful tip!\">\n//   <span>Hover over me</span>\n// </Tooltip>\n```",
          "answer": "```jsx\nimport React, { useState } from 'react';\n\nfunction Tooltip({ text, children }) {\n  const [showTooltip, setShowTooltip] = useState(false);\n\n  const handleMouseEnter = () => {\n    setShowTooltip(true);\n  };\n\n  const handleMouseLeave = () => {\n    setShowTooltip(false);\n  };\n\n  return (\n    <div\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      style={{ position: 'relative', display: 'inline-block', border: '1px solid #ccc', padding: '5px', margin: '10px' }}\n    >\n      {children}\n      {showTooltip && (\n        <div\n          style={{\n            position: 'absolute',\n            top: 'calc(100% + 5px)',\n            left: '50%',\n            transform: 'translateX(-50%)',\n            backgroundColor: '#333',\n            color: 'white',\n            padding: '8px',\n            borderRadius: '4px',\n            whiteSpace: 'nowrap',\n            zIndex: 1000\n          }}\n        >\n          {text}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Example Usage:\nfunction App() {\n  return (\n    <div>\n      <Tooltip text=\"This is a helpful tip!\">\n        <span>Hover over me (simple)</span>\n      </Tooltip>\n      <br />\n      <Tooltip text=\"Another tip for this button.\">\n        <button>Hover Button</button>\n      </Tooltip>\n    </div>\n  );\n}\n```",
          "analysisPoints": [
            "Correct usage of `useState` to manage tooltip visibility.",
            "Implementing `onMouseEnter` and `onMouseLeave` event handlers.",
            "Conditional rendering of the tooltip based on state.",
            "Basic CSS for tooltip positioning and styling."
          ],
          "keyConcepts": [
            "React events",
            "onMouseEnter",
            "onMouseLeave",
            "useState",
            "Conditional rendering",
            "Functional components"
          ],
          "evaluationCriteria": [
            "Correct event handler implementation.",
            "Proper state management for UI visibility.",
            "Functional tooltip display and hide.",
            "Clean and readable code."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "useState",
            "UI Component",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React functional components",
            "useState"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_events_6",
          "topic": "React Events (SyntheticEvent)",
          "level": "hard",
          "type": "open",
          "question": "React 17 removed event pooling for `SyntheticEvent` objects. Explain what event pooling was, why it was used, and why React decided to remove it. What implications does this have for developers when working with `SyntheticEvent` objects asynchronously (e.g., inside `setTimeout` or `async/await`)?",
          "answer": "**What was Event Pooling?**\nBefore React 17, `SyntheticEvent` objects were pooled. This meant that React would reuse event objects for performance. After an event callback was invoked, the properties of the `SyntheticEvent` object were nullified or reset to allow the object to be recycled for the next event. This was an optimization to reduce garbage collection overhead.\n\n**Why was it used?**\nIt was used to improve performance by reducing the number of new `SyntheticEvent` objects created and subsequently garbage collected. By reusing objects, memory allocation and deallocation overhead could be minimized, leading to smoother UI performance, especially in high-frequency event scenarios.\n\n**Why was it removed?**\nReact removed event pooling in React 17 primarily because it caused more confusion and bugs for developers than the performance benefits it provided. Developers often forgot that `SyntheticEvent` properties were nullified after the event handler completed. This meant that if you tried to access `event.target` or `event.currentTarget` asynchronously (e.g., inside a `setTimeout` callback, `async/await` blocks, or after a promise resolved), the properties would be `null`, leading to hard-to-debug errors. The performance gains were also becoming less significant with modern JavaScript engines and garbage collectors.\n\n**Implications for Developers:**\n1.  **No more `event.persist()`:** Developers no longer need to call `event.persist()` when they want to access `SyntheticEvent` properties asynchronously. The `SyntheticEvent` object and its properties will remain valid even after the event handler finishes executing.\n2.  **Simplified Asynchronous Event Handling:** Code involving `setTimeout`, `requestAnimationFrame`, `async/await`, or `Promise.then()` that needs to access event properties is now much simpler and less error-prone. You can just use the `event` object directly.\n    ```javascript\n    // Before React 17 (needed persist() for async access)\n    const handleClickOld = (event) => {\n      // event.persist(); // Necessary!\n      setTimeout(() => {\n        console.log(event.target.value); // Might be null without persist\n      }, 0);\n    };\n\n    // React 17+ (no persist() needed)\n    const handleClickNew = (event) => {\n      setTimeout(() => {\n        console.log(event.target.value); // Works directly\n      }, 0);\n    };\n    ```\n3.  **Slightly Increased Memory Usage (Potentially):** While the primary goal of pooling was performance, modern JavaScript engines are very good at garbage collection. The increased memory overhead from not pooling is generally negligible for most applications and is a worthy trade-off for improved developer experience and reduced bugs.",
          "analysisPoints": [
            "Definition of event pooling.",
            "Explanation of its original purpose (performance).",
            "Detailed reasons for its removal (developer confusion, nullified properties, modern JS engines).",
            "Clear explanation of implications for asynchronous event access.",
            "Demonstration with `event.persist()` context."
          ],
          "keyConcepts": [
            "SyntheticEvent",
            "Event pooling",
            "Performance optimization",
            "Asynchronous JavaScript",
            "event.persist()",
            "React 17 changes"
          ],
          "evaluationCriteria": [
            "Comprehensive and accurate historical context.",
            "Clear explanation of technical rationale.",
            "Precise description of practical implications for coding.",
            "Demonstration of deep understanding of React's event system evolution."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "SyntheticEvent",
            "React 17",
            "Performance",
            "Asynchronous JavaScript"
          ],
          "prerequisites": [
            "React Events",
            "JavaScript asynchronous concepts"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_https_setup_1",
          "title": "Configure React App for HTTPS and Verify",
          "description": "\nYour task is to configure a new or existing Create React App project to run its development server over HTTPS. After configuration, you must verify that the application is indeed serving on `https://localhost:3000` (or your configured port).\n\n**Requirements:**\n1.  Initialize a new Create React App project if you don't have one.\n2.  Modify the `package.json` file to enable HTTPS by default when running `npm start`.\n3.  Start the development server.\n4.  Confirm in your browser that the application is loaded via HTTPS. You might see a privacy warning due to the self-signed certificate; this is expected.\n5.  (Optional but recommended for cross-platform understanding): Demonstrate how to achieve the same result using a command-line argument for both Windows and macOS/Linux.\n",
          "difficulty": "easy",
          "startingCode": "{\n  \"name\": \"my-react-app\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"eslintConfig\": {\n    \"extends\": [\n      \"react-app\",\n      \"react-app/jest\"\n    ]\n  },\n  \"browserslist\": {\n    \"production\": [\n      \">0.2%\",\n      \"not dead\",\n      \"not op_mini all\"\n    ],\n    \"development\": [\n      \"last 1 chrome version\",\n      \"last 1 firefox version\",\n      \"last 1 safari version\"\n    ]\n  }\n}\n",
          "solutionCode": "{\n  \"name\": \"my-react-app\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"set HTTPS=true && react-scripts start\", // For Windows\n    // Or for cross-platform (using cross-env, which needs to be installed: npm install --save-dev cross-env)\n    // \"start\": \"cross-env HTTPS=true react-scripts start\", \n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"eslintConfig\": {\n    \"extends\": [\n      \"react-app\",\n      \"react-app/jest\"\n    ]\n  },\n  \"browserslist\": {\n    \"production\": [\n      \">0.2%\",\n      \"not dead\",\n      \"not op_mini all\"\n    ],\n    \"development\": [\n      \"last 1 chrome version\",\n      \"last 1 firefox version\",\n      \"last 1 safari version\"\n    ]\n  }\n}\n\n// Command Line Verification:\n// For Windows:\n// set HTTPS=true && npm start\n// Expected: Browser opens https://localhost:3000\n\n// For macOS/Linux:\n// HTTPS=true npm start\n// Expected: Browser opens https://localhost:3000\n",
          "testCases": [
            "Open `package.json` and verify `start` script contains `set HTTPS=true &&` or `cross-env HTTPS=true`.",
            "Run `npm start` in the terminal.",
            "Observe the terminal output for messages indicating HTTPS is enabled (e.g., 'Compiled successfully!', 'You can now view ... in the browser. Local: https://localhost:3000').",
            "Open a browser and navigate to `https://localhost:3000` (or the indicated port).",
            "Verify that the URL starts with `https://` and the browser displays a secure connection (even if with a certificate warning).",
            "If `cross-env` is used, verify it works on both Windows and Linux/macOS."
          ],
          "hints": [
            "Remember that `set` is for Windows Command Prompt. For Bash/Zsh (macOS/Linux), you'd use `HTTPS=true` directly before the command.",
            "If you want a truly cross-platform solution directly in `package.json` without conditional scripts, consider installing the `cross-env` package (`npm install --save-dev cross-env`).",
            "After modifying `package.json`, save the file and restart your `npm start` process."
          ],
          "tags": [
            "React",
            "HTTPS",
            "Development Setup",
            "CLI",
            "Environment Variables"
          ],
          "timeEstimate": 20,
          "prerequisites": [
            "Node.js",
            "npm",
            "Create React App"
          ],
          "complexity": 3,
          "interviewRelevance": 5,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_https_setup"
          ]
        },
        {
          "id": "task_use_reducer_1",
          "title": "Build a Simple Shopping Cart with useReducer",
          "description": "\nYour task is to implement a basic shopping cart functionality using the `useReducer` hook in a React functional component. The cart should allow adding items, removing items, and updating item quantities.\n\n**Requirements:**\n1.  Define an `initialState` for the shopping cart. It should contain an array of `items`, where each `item` object has an `id` (unique number), `name` (string), `price` (number), and `quantity` (number).\n2.  Create a `cartReducer` function that handles the following actions:\n    *   `ADD_ITEM`: Payload: `{ id, name, price }`. If the item already exists in the cart, increment its quantity. Otherwise, add the new item with quantity `1`.\n    *   `REMOVE_ITEM`: Payload: `{ id }`. Removes the item completely from the cart.\n    *   `UPDATE_QUANTITY`: Payload: `{ id, quantity }`. Updates the quantity of an existing item. If `quantity` is 0 or less, remove the item.\n    *   `CLEAR_CART`: No payload. Empties the cart.\n3.  Create a React component (`ShoppingCart`) that uses this `cartReducer`.\n4.  Display the items in the cart, including their name, price, quantity, and subtotal per item. Also display the total price of all items in the cart.\n5.  Provide buttons/inputs to trigger `dispatch` calls for adding, removing, and updating quantities of example items, and clearing the cart.\n\nEnsure all state updates in the reducer are immutable.",
          "difficulty": "medium",
          "startingCode": "import React, { useReducer } from 'react';\n\n// 1. Define initialState\nconst initialCartState = {\n  items: [],\n  totalPrice: 0,\n};\n\n// 2. Define cartReducer function\nfunction cartReducer(state, action) {\n  switch (action.type) {\n    // TODO: Implement ADD_ITEM\n    // TODO: Implement REMOVE_ITEM\n    // TODO: Implement UPDATE_QUANTITY\n    // TODO: Implement CLEAR_CART\n    default:\n      throw new Error(`Unsupported action type: ${action.type}`);\n  }\n}\n\nfunction calculateTotalPrice(items) {\n  return items.reduce((acc, item) => acc + (item.price * item.quantity), 0);\n}\n\nfunction ShoppingCart() {\n  const [cartState, dispatch] = useReducer(cartReducer, initialCartState);\n\n  // Example products for adding\n  const products = [\n    { id: 1, name: 'Laptop', price: 1200 },\n    { id: 2, name: 'Mouse', price: 25 },\n    { id: 3, name: 'Keyboard', price: 75 }\n  ];\n\n  return (\n    <div>\n      <h1>Shopping Cart</h1>\n\n      <h2>Products to Add</h2>\n      {products.map(product => (\n        <div key={product.id} style={{ display: 'flex', gap: '10px', marginBottom: '5px' }}>\n          <span>{product.name} - ${product.price}</span>\n          <button onClick={() => dispatch({ type: 'ADD_ITEM', payload: product })}>Add to Cart</button>\n        </div>\n      ))}\n      <hr />\n\n      <h2>Your Cart</h2>\n      {cartState.items.length === 0 ? (\n        <p>Your cart is empty.</p>\n      ) : (\n        <>\n          <ul>\n            {cartState.items.map(item => (\n              <li key={item.id} style={{ marginBottom: '10px' }}>\n                {item.name} (${item.price}) x {item.quantity} = ${(item.price * item.quantity).toFixed(2)}\n                <button onClick={() => dispatch({ type: 'UPDATE_QUANTITY', payload: { id: item.id, quantity: item.quantity + 1 } })}> + </button>\n                <button onClick={() => dispatch({ type: 'UPDATE_QUANTITY', payload: { id: item.id, quantity: item.quantity - 1 } })}> - </button>\n                <button onClick={() => dispatch({ type: 'REMOVE_ITEM', payload: { id: item.id } })}>Remove</button>\n              </li>\n            ))}\n          </ul>\n          <h3>Total: ${cartState.totalPrice.toFixed(2)}</h3>\n          <button onClick={() => dispatch({ type: 'CLEAR_CART' })}>Clear Cart</button>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "solutionCode": "import React, { useReducer } from 'react';\n\nconst initialCartState = {\n  items: [],\n  totalPrice: 0,\n};\n\nfunction calculateTotalPrice(items) {\n  return items.reduce((acc, item) => acc + (item.price * item.quantity), 0);\n}\n\nfunction cartReducer(state, action) {\n  let updatedItems;\n  switch (action.type) {\n    case 'ADD_ITEM':\n      const existingItemIndex = state.items.findIndex(item => item.id === action.payload.id);\n      if (existingItemIndex > -1) {\n        updatedItems = state.items.map((item, index) =>\n          index === existingItemIndex\n            ? { ...item, quantity: item.quantity + 1 }\n            : item\n        );\n      } else {\n        updatedItems = [...state.items, { ...action.payload, quantity: 1 }];\n      }\n      return { ...state, items: updatedItems, totalPrice: calculateTotalPrice(updatedItems) };\n\n    case 'REMOVE_ITEM':\n      updatedItems = state.items.filter(item => item.id !== action.payload.id);\n      return { ...state, items: updatedItems, totalPrice: calculateTotalPrice(updatedItems) };\n\n    case 'UPDATE_QUANTITY':\n      updatedItems = state.items.map(item =>\n        item.id === action.payload.id\n          ? { ...item, quantity: action.payload.quantity }\n          : item\n      ).filter(item => item.quantity > 0); // Remove if quantity becomes 0 or less\n      return { ...state, items: updatedItems, totalPrice: calculateTotalPrice(updatedItems) };\n\n    case 'CLEAR_CART':\n      return { ...initialCartState }; // Reset to initial empty state\n\n    default:\n      throw new Error(`Unsupported action type: ${action.type}`);\n  }\n}\n\nfunction ShoppingCart() {\n  const [cartState, dispatch] = useReducer(cartReducer, initialCartState);\n\n  const products = [\n    { id: 1, name: 'Laptop', price: 1200 },\n    { id: 2, name: 'Mouse', price: 25 },\n    { id: 3, name: 'Keyboard', price: 75 }\n  ];\n\n  return (\n    <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #eee', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\n      <h1 style={{ textAlign: 'center', color: '#333' }}>Shopping Cart</h1>\n\n      <h2 style={{ borderBottom: '1px solid #eee', paddingBottom: '10px', marginBottom: '15px', color: '#555' }}>Products to Add</h2>\n      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '15px', marginBottom: '20px' }}>\n        {products.map(product => (\n          <div key={product.id} style={{ border: '1px solid #ddd', borderRadius: '4px', padding: '10px', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px' }}>\n            <span style={{ fontWeight: 'bold' }}>{product.name}</span>\n            <span>${product.price.toFixed(2)}</span>\n            <button\n              onClick={() => dispatch({ type: 'ADD_ITEM', payload: product })}\n              style={{ padding: '8px 15px', backgroundColor: '#28a745', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}\n            >\n              Add to Cart\n            </button>\n          </div>\n        ))}\n      </div>\n      \n      <h2 style={{ borderBottom: '1px solid #eee', paddingBottom: '10px', marginBottom: '15px', color: '#555' }}>Your Cart ({cartState.items.length} items)</h2>\n      {cartState.items.length === 0 ? (\n        <p style={{ textAlign: 'center', color: '#888' }}>Your cart is empty.</p>\n      ) : (\n        <>\n          <ul style={{ listStyle: 'none', padding: 0 }}>\n            {cartState.items.map(item => (\n              <li key={item.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom: '1px dashed #eee', padding: '10px 0' }}>\n                <span style={{ flex: 2, fontWeight: 'bold' }}>{item.name}</span>\n                <span style={{ flex: 1 }}>${item.price.toFixed(2)}</span>\n                <span style={{ flex: 1, textAlign: 'center' }}>Qty: {item.quantity}</span>\n                <span style={{ flex: 1, textAlign: 'right', fontWeight: 'bold' }}>${(item.price * item.quantity).toFixed(2)}</span>\n                <div style={{ flex: 1, display: 'flex', justifyContent: 'flex-end', gap: '5px' }}>\n                  <button \n                    onClick={() => dispatch({ type: 'UPDATE_QUANTITY', payload: { id: item.id, quantity: item.quantity + 1 } })}\n                    style={{ padding: '5px 10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}\n                  > + </button>\n                  <button \n                    onClick={() => dispatch({ type: 'UPDATE_QUANTITY', payload: { id: item.id, quantity: item.quantity - 1 } })}\n                    style={{ padding: '5px 10px', backgroundColor: '#ffc107', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}\n                  > - </button>\n                  <button \n                    onClick={() => dispatch({ type: 'REMOVE_ITEM', payload: { id: item.id } })}\n                    style={{ padding: '5px 10px', backgroundColor: '#dc3545', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}\n                  >Remove</button>\n                </div>\n              </li>\n            ))}\n          </ul>\n          <h3 style={{ textAlign: 'right', marginTop: '20px', color: '#333' }}>Cart Total: <span style={{ color: '#28a745' }}>${cartState.totalPrice.toFixed(2)}</span></h3>\n          <div style={{ textAlign: 'center', marginTop: '20px' }}>\n            <button \n              onClick={() => dispatch({ type: 'CLEAR_CART' })}\n              style={{ padding: '10px 20px', backgroundColor: '#6c757d', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n            >Clear Cart</button>\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "testCases": [
            "**Add Item:** Add 'Laptop'. Verify cart shows 1 Laptop, total 1200. Add 'Laptop' again. Verify quantity becomes 2, total 2400. Add 'Mouse'. Verify Laptop (2) and Mouse (1) are present, total updated.",
            "**Update Quantity:** Change 'Laptop' quantity from 2 to 1. Verify quantity changes, total updates. Change 'Mouse' quantity to 0. Verify 'Mouse' is removed.",
            "**Remove Item:** Remove 'Laptop'. Verify 'Laptop' is gone, total updated.",
            "**Clear Cart:** Click 'Clear Cart'. Verify cart is empty and total is 0.",
            "**Immutability:** After each action, ensure that the `state.items` array and individual `item` objects (if modified) are new references, not mutations of the previous state.",
            "**Edge Case: Negative Quantity:** Try to update quantity to a negative number. Ensure it gets removed (as per `quantity <= 0` rule)."
          ],
          "hints": [
            "Remember to use `map` for updating items and `filter` for removing items to ensure immutability.",
            "When an item's quantity is updated, if it reaches 0 or less, you should filter it out of the `items` array.",
            "The `calculateTotalPrice` helper function should be called after any item manipulation to keep `totalPrice` updated.",
            "The `ADD_ITEM` logic needs to check if the item already exists in the cart to either increment quantity or add a new item."
          ],
          "tags": [
            "React",
            "useReducer",
            "State Management",
            "Shopping Cart",
            "Immutability",
            "Functional Component",
            "Coding Challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Hooks",
            "JavaScript Array methods (`map`, `filter`, `findIndex`)",
            "Object destructuring"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_use_reducer",
            "theory_spread_operator"
          ]
        },
        {
          "id": "task_use_reducer_2",
          "title": "Build a Stopwatch with useReducer and side effects (useEffect)",
          "description": "\nImplement a stopwatch component using `useReducer` to manage its state and `useEffect` to handle side effects like timers.\n\n**Requirements:**\n1.  Define an `initialState` for the stopwatch, including `isRunning` (boolean), `time` (number, in milliseconds), and `lapTimes` (array of numbers).\n2.  Create a `stopwatchReducer` function that handles the following actions:\n    *   `START`: Sets `isRunning` to `true`.\n    *   `STOP`: Sets `isRunning` to `false`.\n    *   `RESET`: Sets `isRunning` to `false`, `time` to `0`, and `lapTimes` to an empty array.\n    *   `TICK`: Increments `time` by a small interval (e.g., 10ms or 100ms).\n    *   `LAP`: Adds the current `time` to the `lapTimes` array.\n3.  Create a `Stopwatch` React component that uses `stopwatchReducer`.\n4.  Use `useEffect` to manage the timer. When `isRunning` is true, an interval should be set to dispatch `TICK` actions. The interval should be cleared when `isRunning` becomes false or the component unmounts.\n5.  Display the current time, and a list of recorded lap times. Format time nicely (e.g., MM:SS:ms).\n6.  Provide buttons for Start, Stop, Reset, and Lap.\n\nEnsure all state updates in the reducer are immutable.",
          "difficulty": "hard",
          "startingCode": "import React, { useReducer, useEffect, useRef } from 'react';\n\n// 1. Define initialState\nconst initialStopwatchState = {\n  // TODO: Add isRunning, time, lapTimes\n};\n\n// Helper to format time (optional, but good practice)\nfunction formatTime(milliseconds) {\n  const minutes = Math.floor(milliseconds / 60000);\n  const seconds = Math.floor((milliseconds % 60000) / 1000);\n  const ms = Math.floor((milliseconds % 1000) / 10);\n  return `${\n    minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;\n}\n\n// 2. Define stopwatchReducer function\nfunction stopwatchReducer(state, action) {\n  switch (action.type) {\n    // TODO: Implement START, STOP, RESET, TICK, LAP\n    default:\n      throw new Error(`Unsupported action type: ${action.type}`);\n  }\n}\n\nfunction Stopwatch() {\n  const [state, dispatch] = useReducer(stopwatchReducer, initialStopwatchState);\n  const timerIdRef = useRef(null);\n\n  // 4. Use useEffect to manage the timer\n  useEffect(() => {\n    // TODO: Implement timer logic\n    // Clean up function\n    return () => {\n      // TODO: Clear interval\n    };\n  }, [state.isRunning, dispatch]); // Dependencies for useEffect\n\n  return (\n    <div style={{ textAlign: 'center', fontFamily: 'monospace' }}>\n      <h1>Stopwatch</h1>\n      <p style={{ fontSize: '3em', margin: '20px 0' }}>{formatTime(state.time)}</p>\n      <div style={{ marginBottom: '20px' }}>\n        <button onClick={() => dispatch({ type: 'START' })} disabled={state.isRunning}>Start</button>\n        <button onClick={() => dispatch({ type: 'STOP' })} disabled={!state.isRunning}>Stop</button>\n        <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>\n        <button onClick={() => dispatch({ type: 'LAP' })} disabled={!state.isRunning}>Lap</button>\n      </div>\n      <h2>Lap Times</h2>\n      <ul style={{ listStyle: 'none', padding: 0 }}>\n        {state.lapTimes.length === 0 ? (\n          <li>No lap times recorded.</li>\n        ) : (\n          state.lapTimes.map((lap, index) => (\n            <li key={index}>Lap {index + 1}: {formatTime(lap)}</li>\n          ))\n        )}\n      </ul>\n    </div>\n  );\n}\n\nexport default Stopwatch;\n",
          "solutionCode": "import React, { useReducer, useEffect, useRef } from 'react';\n\nconst initialStopwatchState = {\n  isRunning: false,\n  time: 0,\n  lapTimes: [],\n};\n\nfunction formatTime(milliseconds) {\n  const minutes = Math.floor(milliseconds / 60000);\n  const seconds = Math.floor((milliseconds % 60000) / 1000);\n  const ms = Math.floor((milliseconds % 1000) / 10); // Display centiseconds\n  return `${\n    minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;\n}\n\nfunction stopwatchReducer(state, action) {\n  switch (action.type) {\n    case 'START':\n      return { ...state, isRunning: true };\n    case 'STOP':\n      return { ...state, isRunning: false };\n    case 'RESET':\n      return { ...initialStopwatchState }; // Reset to full initial state\n    case 'TICK':\n      return { ...state, time: state.time + action.payload }; // Payload for interval time\n    case 'LAP':\n      return { ...state, lapTimes: [...state.lapTimes, state.time] };\n    default:\n      throw new Error(`Unsupported action type: ${action.type}`);\n  }\n}\n\nconst TICK_INTERVAL = 10; // milliseconds\n\nfunction Stopwatch() {\n  const [state, dispatch] = useReducer(stopwatchReducer, initialStopwatchState);\n  const timerIdRef = useRef(null);\n\n  useEffect(() => {\n    if (state.isRunning) {\n      timerIdRef.current = setInterval(() => {\n        dispatch({ type: 'TICK', payload: TICK_INTERVAL });\n      }, TICK_INTERVAL);\n    } else {\n      clearInterval(timerIdRef.current);\n      timerIdRef.current = null;\n    }\n\n    return () => {\n      clearInterval(timerIdRef.current);\n      timerIdRef.current = null;\n    };\n  }, [state.isRunning, dispatch]); // dispatch is stable, so it won't cause re-runs itself\n\n  return (\n    <div style={{ textAlign: 'center', fontFamily: 'monospace', padding: '20px', background: '#f8f8f8', borderRadius: '10px', boxShadow: '0 4px 8px rgba(0,0,0,0.1)', maxWidth: '400px', margin: '20px auto' }}>\n      <h1 style={{ color: '#333' }}>Stopwatch</h1>\n      <p style={{ fontSize: '3.5em', margin: '25px 0', color: '#007bff' }}>{formatTime(state.time)}</p>\n      <div style={{ marginBottom: '25px', display: 'flex', justifyContent: 'center', gap: '10px' }}>\n        <button \n          onClick={() => dispatch({ type: 'START' })}\n          disabled={state.isRunning}\n          style={{ padding: '10px 20px', fontSize: '1.1em', backgroundColor: '#28a745', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n        >\n          Start\n        </button>\n        <button \n          onClick={() => dispatch({ type: 'STOP' })}\n          disabled={!state.isRunning}\n          style={{ padding: '10px 20px', fontSize: '1.1em', backgroundColor: '#dc3545', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n        >\n          Stop\n        </button>\n        <button \n          onClick={() => dispatch({ type: 'RESET' })}\n          style={{ padding: '10px 20px', fontSize: '1.1em', backgroundColor: '#6c757d', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n        >\n          Reset\n        </button>\n        <button \n          onClick={() => dispatch({ type: 'LAP' })}\n          disabled={!state.isRunning || state.time === 0}\n          style={{ padding: '10px 20px', fontSize: '1.1em', backgroundColor: '#ffc107', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n        >\n          Lap\n        </button>\n      </div>\n      <h2 style={{ color: '#555', borderTop: '1px solid #eee', paddingTop: '20px' }}>Lap Times</h2>\n      <ul style={{ listStyle: 'none', padding: 0, maxHeight: '150px', overflowY: 'auto', border: '1px solid #eee', borderRadius: '5px', background: 'white', paddingRight: '10px' }}>\n        {state.lapTimes.length === 0 ? (\n          <li style={{ padding: '8px 0', color: '#888' }}>No lap times recorded.</li>\n        ) : (\n          state.lapTimes.map((lap, index) => (\n            <li key={index} style={{ padding: '8px 0', borderBottom: index < state.lapTimes.length - 1 ? '1px dashed #eee' : 'none', display: 'flex', justifyContent: 'space-between' }}>\n              <span>Lap {index + 1}:</span>\n              <span style={{ fontWeight: 'bold' }}>{formatTime(lap)}</span>\n            </li>\n          ))\n        )}\n      </ul>\n    </div>\n  );\n}\n\nexport default Stopwatch;\n",
          "testCases": [
            "**Initial State:** Verify `isRunning` is false, `time` is 0, `lapTimes` is empty.",
            "**Start/Stop:** Click Start. Verify time starts incrementing. Click Stop. Verify time pauses. Click Start again. Verify time resumes from where it left off.",
            "**Reset:** Start the timer, let it run, then click Reset. Verify time resets to 0, `isRunning` is false, and `lapTimes` are cleared.",
            "**Lap:** Start the timer. Click Lap multiple times. Verify current time is added to `lapTimes` list each time, and the main timer continues.",
            "**Time Format:** Verify time is displayed correctly in MM:SS.ms format (e.g., 00:05.23 for 5 seconds and 230 milliseconds).",
            "**Immutability:** Confirm that `state.time` and `state.lapTimes` are updated immutably in the reducer.",
            "**Cleanup:** Verify that `clearInterval` is called when `isRunning` becomes false or the component unmounts to prevent memory leaks."
          ],
          "hints": [
            "Use `setInterval` for the ticking mechanism within `useEffect`.",
            "Remember to return a cleanup function from `useEffect` to clear the interval when the component unmounts or `isRunning` changes.",
            "The `TICK` action can take a `payload` for the interval duration, making the reducer more flexible.",
            "Use `useRef` to store the `setInterval` ID so it can be cleared in the cleanup function without being caught in closures."
          ],
          "tags": [
            "React",
            "useReducer",
            "useEffect",
            "Timer",
            "State Management",
            "Side Effects",
            "Coding Challenge"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React Hooks",
            "JavaScript Timers (`setInterval`, `clearInterval`)",
            "Immutability",
            "useRef"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_use_reducer"
          ]
        },
        {
          "id": "task_default_props_1",
          "title": "Refactor User Profile Card with ES6 Default Parameters",
          "description": "\nRefactor the provided React `UserProfileCard` functional component. Currently, it uses `defaultProps` to set default values for `theme` and `isAdmin`. Your task is to update it to use ES6 default parameters directly within the component's function signature.\n\n**Requirements:**\n1.  Remove the `UserProfileCard.defaultProps` static property.\n2.  Implement default values for `theme` (default: `'light'`) and `isAdmin` (default: `false`) using ES6 default parameters in the component's destructuring assignment.\n3.  Ensure the component functions identically with and without the default props being explicitly passed.\n4.  Add a test case where `isAdmin` is explicitly passed as `null` to verify default parameters do *not* apply in that scenario.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nfunction UserProfileCard({ name, email, theme, isAdmin }) {\n  const cardStyle = {\n    backgroundColor: theme === 'dark' ? '#333' : '#f0f0f0',\n    color: theme === 'dark' ? '#f0f0f0' : '#333',\n    padding: '20px',\n    borderRadius: '8px',\n    boxShadow: '0 2px 4px rgba(0,0,0,0.1)',\n    width: '300px',\n    margin: '20px',\n    textAlign: 'left'\n  };\n\n  return (\n    <div style={cardStyle}>\n      <h3>{name}</h3>\n      <p>Email: {email}</p>\n      <p>Theme: {theme}</p>\n      {isAdmin && <p style={{ color: 'gold', fontWeight: 'bold' }}>Admin User</p>}\n    </div>\n  );\n}\n\nUserProfileCard.defaultProps = {\n  theme: 'light',\n  isAdmin: false\n};\n\nfunction App() {\n  return (\n    <div>\n      <h2>User Profile Cards</h2>\n      <UserProfileCard name=\"Alice\" email=\"alice@example.com\" />\n      <UserProfileCard name=\"Bob\" email=\"bob@example.com\" theme=\"dark\" isAdmin={true} />\n      <UserProfileCard name=\"Charlie\" email=\"charlie@example.com\" theme=\"dark\" />\n      <UserProfileCard name=\"David\" email=\"david@example.com\" isAdmin={true} />\n      {/* Add a test case for isAdmin={null} here */}\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\n\nfunction UserProfileCard({ name, email, theme = 'light', isAdmin = false }) {\n  const cardStyle = {\n    backgroundColor: theme === 'dark' ? '#333' : '#f0f0f0',\n    color: theme === 'dark' ? '#f0f0f0' : '#333',\n    padding: '20px',\n    borderRadius: '8px',\n    boxShadow: '0 2px 4px rgba(0,0,0,0.1)',\n    width: '300px',\n    margin: '20px',\n    textAlign: 'left'\n  };\n\n  return (\n    <div style={cardStyle}>\n      <h3>{name}</h3>\n      <p>Email: {email}</p>\n      <p>Theme: {theme}</p>\n      {isAdmin && <p style={{ color: 'gold', fontWeight: 'bold' }}>Admin User</p>}\n      {isAdmin === null && <p style={{ color: 'red' }}>Admin Status: Explicitly Null</p>} {/* Added for test case */}\n    </div>\n  );\n}\n\n// Removed: UserProfileCard.defaultProps = { ... };\n\nfunction App() {\n  return (\n    <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center' }}>\n      <h2>User Profile Cards</h2>\n      <UserProfileCard name=\"Alice\" email=\"alice@example.com\" /> {/* theme: light, isAdmin: false */}\n      <UserProfileCard name=\"Bob\" email=\"bob@example.com\" theme=\"dark\" isAdmin={true} /> {/* theme: dark, isAdmin: true */}\n      <UserProfileCard name=\"Charlie\" email=\"charlie@example.com\" theme=\"dark\" /> {/* theme: dark, isAdmin: false */}\n      <UserProfileCard name=\"David\" email=\"david@example.com\" isAdmin={true} /> {/* theme: light, isAdmin: true */}\n      <UserProfileCard name=\"Eve\" email=\"eve@example.com\" isAdmin={null} /> {/* theme: light, isAdmin: null (default not applied) */}\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Render `<UserProfileCard name=\"Alice\" email=\"alice@example.com\" />`. Verify `theme` is `'light'` and `isAdmin` is `false`.",
            "Render `<UserProfileCard name=\"Bob\" email=\"bob@example.com\" theme=\"dark\" isAdmin={true} />`. Verify `theme` is `'dark'` and `isAdmin` is `true`.",
            "Render `<UserProfileCard name=\"Charlie\" email=\"charlie@example.com\" theme=\"dark\" />`. Verify `theme` is `'dark'` and `isAdmin` is `false`.",
            "Render `<UserProfileCard name=\"David\" email=\"david@example.com\" isAdmin={true} />`. Verify `theme` is `'light'` and `isAdmin` is `true`.",
            "Render `<UserProfileCard name=\"Eve\" email=\"eve@example.com\" isAdmin={null} />`. Verify `theme` is `'light'` and `isAdmin` is `null` (not `false`), and the `Admin User` paragraph is NOT rendered, but the `Explicitly Null` message IS rendered (if added for testing)."
          ],
          "hints": [
            "Focus on the function's parameter list for destructuring and applying default values.",
            "Remember that `defaultProps` is a static property, while ES6 default parameters are part of the function signature.",
            "Test carefully with `undefined`, `null`, and explicitly provided values to confirm correct behavior."
          ],
          "tags": [
            "React",
            "Props",
            "Default Values",
            "ES6",
            "Refactoring",
            "Functional Components"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React functional components",
            "ES6 destructuring"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_default_props"
          ]
        },
        {
          "id": "task_spread_operator_1",
          "title": "Manage User Preferences with Immutable Updates using Spread Operator",
          "description": "\nYour task is to create a React component (`UserPreferences`) that manages a user's settings. The settings object can contain nested properties, and updates must be performed immutably using the spread operator.\n\n**Requirements:**\n1.  Define an initial state for user preferences using `useState`. The state should be an object with nested properties, e.g.:\n    ```javascript\n    {\n      notifications: {\n        email: true,\n        sms: false,\n        push: true\n      },\n      theme: 'dark',\n      privacy: {\n        dataSharing: true,\n        profileVisibility: 'public'\n      }\n    }\n    ```\n2.  Create a functional component `UserPreferences` that displays these preferences.\n3.  Implement functions or event handlers to update specific preferences. Each update should return a *new* state object, ensuring no direct mutations of the original state or nested objects.\n    *   A function to toggle `notifications.sms`.\n    *   A function to change `theme` (e.g., to 'light' or 'dark').\n    *   A function to change `privacy.profileVisibility` (e.g., to 'private').\n4.  Render UI elements (buttons/toggles) to trigger these updates.\n\nDemonstrate a clear understanding of immutable updates for nested objects using the spread operator.",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction UserPreferences() {\n  const [preferences, setPreferences] = useState({\n    notifications: {\n      email: true,\n      sms: false,\n      push: true\n    },\n    theme: 'dark',\n    privacy: {\n      dataSharing: true,\n      profileVisibility: 'public'\n    }\n  });\n\n  // TODO: Implement functions for immutable updates\n\n  const toggleSmsNotifications = () => {\n    // Implement immutable update for preferences.notifications.sms\n  };\n\n  const changeTheme = (newTheme) => () => {\n    // Implement immutable update for preferences.theme\n  };\n\n  const setProfileVisibility = (newVisibility) => () => {\n    // Implement immutable update for preferences.privacy.profileVisibility\n  };\n\n  return (\n    <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '600px', margin: '20px auto', padding: '20px', border: '1px solid #eee', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\n      <h1>User Preferences</h1>\n\n      <h2>Notifications</h2>\n      <p>Email: {preferences.notifications.email ? 'On' : 'Off'}</p>\n      <p>SMS: {preferences.notifications.sms ? 'On' : 'Off'}</p>\n      <p>Push: {preferences.notifications.push ? 'On' : 'Off'}</p>\n      <button onClick={toggleSmsNotifications}>Toggle SMS Notifications</button>\n\n      <h2>Theme</h2>\n      <p>Current Theme: {preferences.theme}</p>\n      <button onClick={changeTheme('light')}>Set Light Theme</button>\n      <button onClick={changeTheme('dark')}>Set Dark Theme</button>\n\n      <h2>Privacy</h2>\n      <p>Data Sharing: {preferences.privacy.dataSharing ? 'Enabled' : 'Disabled'}</p>\n      <p>Profile Visibility: {preferences.privacy.profileVisibility}</p>\n      <button onClick={setProfileVisibility('private')}>Set Profile Private</button>\n      <button onClick={setProfileVisibility('public')}>Set Profile Public</button>\n\n      <hr />\n      <h3>Current State (for debugging)</h3>\n      <pre style={{ backgroundColor: '#f5f5f5', padding: '10px', borderRadius: '4px' }}>\n        {JSON.stringify(preferences, null, 2)}\n      </pre>\n    </div>\n  );\n}\n\nexport default UserPreferences;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction UserPreferences() {\n  const [preferences, setPreferences] = useState({\n    notifications: {\n      email: true,\n      sms: false,\n      push: true\n    },\n    theme: 'dark',\n    privacy: {\n      dataSharing: true,\n      profileVisibility: 'public'\n    }\n  });\n\n  const toggleSmsNotifications = () => {\n    setPreferences(prevPrefs => ({\n      ...prevPrefs, // Shallow copy of top-level preferences object\n      notifications: { // Create new notifications object\n        ...prevPrefs.notifications, // Shallow copy of existing notifications\n        sms: !prevPrefs.notifications.sms // Update the sms property\n      }\n    }));\n  };\n\n  const changeTheme = (newTheme) => () => {\n    setPreferences(prevPrefs => ({\n      ...prevPrefs, // Shallow copy of top-level preferences object\n      theme: newTheme // Update the theme property\n    }));\n  };\n\n  const setProfileVisibility = (newVisibility) => () => {\n    setPreferences(prevPrefs => ({\n      ...prevPrefs, // Shallow copy of top-level preferences object\n      privacy: { // Create new privacy object\n        ...prevPrefs.privacy, // Shallow copy of existing privacy\n        profileVisibility: newVisibility // Update the profileVisibility property\n      }\n    }));\n  };\n\n  return (\n    <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '600px', margin: '20px auto', padding: '20px', border: '1px solid #eee', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\n      <h1 style={{ color: '#333', textAlign: 'center' }}>User Preferences</h1>\n\n      <h2 style={{ borderBottom: '1px solid #eee', paddingBottom: '10px', marginBottom: '15px' }}>Notifications</h2>\n      <p>Email: <span style={{ fontWeight: 'bold', color: preferences.notifications.email ? 'green' : 'red' }}>{preferences.notifications.email ? 'On' : 'Off'}</span></p>\n      <p>SMS: <span style={{ fontWeight: 'bold', color: preferences.notifications.sms ? 'green' : 'red' }}>{preferences.notifications.sms ? 'On' : 'Off'}</span></p>\n      <p>Push: <span style={{ fontWeight: 'bold', color: preferences.notifications.push ? 'green' : 'red' }}>{preferences.notifications.push ? 'On' : 'Off'}</span></p>\n      <button \n        onClick={toggleSmsNotifications}\n        style={{ padding: '8px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', marginRight: '10px' }}\n      >Toggle SMS Notifications</button>\n\n      <h2 style={{ borderBottom: '1px solid #eee', paddingBottom: '10px', marginTop: '20px', marginBottom: '15px' }}>Theme</h2>\n      <p>Current Theme: <span style={{ fontWeight: 'bold', color: '#555' }}>{preferences.theme}</span></p>\n      <button \n        onClick={changeTheme('light')}\n        style={{ padding: '8px 15px', backgroundColor: '#28a745', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', marginRight: '10px' }}\n      >Set Light Theme</button>\n      <button \n        onClick={changeTheme('dark')}\n        style={{ padding: '8px 15px', backgroundColor: '#6c757d', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}\n      >Set Dark Theme</button>\n\n      <h2 style={{ borderBottom: '1px solid #eee', paddingBottom: '10px', marginTop: '20px', marginBottom: '15px' }}>Privacy</h2>\n      <p>Data Sharing: <span style={{ fontWeight: 'bold', color: preferences.privacy.dataSharing ? 'green' : 'red' }}>{preferences.privacy.dataSharing ? 'Enabled' : 'Disabled'}</span></p>\n      <p>Profile Visibility: <span style={{ fontWeight: 'bold', color: '#555' }}>{preferences.privacy.profileVisibility}</span></p>\n      <button \n        onClick={setProfileVisibility('private')}\n        style={{ padding: '8px 15px', backgroundColor: '#ffc107', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', marginRight: '10px' }}\n      >Set Private</button>\n      <button \n        onClick={setProfileVisibility('public')}\n        style={{ padding: '8px 15px', backgroundColor: '#17a2b8', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}\n      >Set Public</button>\n\n      <hr style={{ marginTop: '30px' }}/>\n      <h3>Current State (for debugging)</h3>\n      <pre style={{ backgroundColor: '#f5f5f5', padding: '15px', borderRadius: '4px', overflowX: 'auto' }}>\n        <code>{JSON.stringify(preferences, null, 2)}</code>\n      </pre>\n    </div>\n  );\n}\n\nexport default UserPreferences;\n",
          "testCases": [
            "**Initial State:** Render the component. Verify initial preferences are displayed correctly.",
            "**Toggle SMS Notifications:** Click 'Toggle SMS Notifications'. Verify `preferences.notifications.sms` changes (`false` to `true`, then `true` to `false`). Verify `preferences.notifications` and the overall `preferences` object are new references (not mutated).",
            "**Change Theme:** Click 'Set Light Theme'. Verify `preferences.theme` changes to `'light'`. Click 'Set Dark Theme'. Verify `preferences.theme` changes to `'dark'`. Verify `preferences` object is a new reference.",
            "**Set Profile Visibility:** Click 'Set Profile Private'. Verify `preferences.privacy.profileVisibility` changes to `'private'`. Click 'Set Profile Public'. Verify it changes to `'public'`. Verify `preferences.privacy` and `preferences` objects are new references.",
            "**Combined Changes:** Perform a sequence of changes (e.g., toggle SMS, change theme, set privacy). Verify all changes are reflected correctly and immutably."
          ],
          "hints": [
            "To update a nested property immutably, you need to create new objects at each level of nesting using the spread operator.",
            "For example, to update `obj.nested.prop`: `setObj(prev => ({ ...prev, nested: { ...prev.nested, prop: newValue } }))`.",
            "Use the functional update form of `setPreferences` (`setPreferences(prevState => newState)`) to ensure you're working with the most up-to-date state."
          ],
          "tags": [
            "React",
            "useState",
            "Immutability",
            "Spread Operator",
            "Object Manipulation",
            "Coding Challenge"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Hooks",
            "JavaScript Objects",
            "Spread Operator"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_spread_operator"
          ]
        },
        {
          "id": "task_react_events_1",
          "title": "Implement a Draggable Box Component",
          "description": "\nYour task is to create a simple draggable `div` component in React using `SyntheticEvent` and `useState`.\n\n**Requirements:**\n1.  Create a functional component called `DraggableBox`.\n2.  This component should have its own internal state (`positionX`, `positionY`) to control its `left` and `top` CSS properties.\n3.  Implement `onMouseDown`, `onMouseMove`, and `onMouseUp` event handlers on the `DraggableBox` element to enable dragging.\n    *   `onMouseDown`: When the mouse button is pressed on the box, set a `isDragging` state to `true` and record the initial mouse position and box position to calculate the offset.\n    *   `onMouseMove`: When `isDragging` is `true`, update the `positionX` and `positionY` states based on the mouse movement. These events should ideally be listened for on the `document` to handle cases where the mouse moves off the box while dragging.\n    *   `onMouseUp`: When the mouse button is released, set `isDragging` to `false`.\n4.  Ensure `event.preventDefault()` is used on `onMouseDown` to prevent default browser drag behavior (e.g., image dragging).\n5.  Add cleanup logic in `useEffect` to remove `mousemove` and `mouseup` listeners from `document` when dragging stops or the component unmounts.\n\nYour solution should use React's `SyntheticEvent` system effectively.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect, useRef } from 'react';\n\nfunction DraggableBox() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const offset = useRef({ x: 0, y: 0 }); // To store the initial mouse-to-box offset\n\n  const handleMouseDown = (event) => {\n    // TODO: Implement logic to start dragging\n    // Remember to use event.preventDefault()\n  };\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      if (!isDragging) return;\n      // TODO: Implement logic to update box position based on mouse movement\n    };\n\n    const handleMouseUp = () => {\n      // TODO: Implement logic to stop dragging\n    };\n\n    // TODO: Attach and detach event listeners on document\n\n    return () => {\n      // TODO: Cleanup event listeners\n    };\n  }, [isDragging]); // Dependencies for useEffect\n\n  return (\n    <div\n      onMouseDown={handleMouseDown}\n      style={{\n        position: 'absolute',\n        left: position.x,\n        top: position.y,\n        width: '100px',\n        height: '100px',\n        backgroundColor: 'lightblue',\n        border: '2px solid steelblue',\n        cursor: 'grab',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        userSelect: 'none'\n      }}\n    >\n      Drag Me\n    </div>\n  );\n}\n\nexport default DraggableBox;\n",
          "solutionCode": "import React, { useState, useEffect, useRef } from 'react';\n\nfunction DraggableBox() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const offset = useRef({ x: 0, y: 0 }); // Stores the initial click offset from box's top-left\n\n  const handleMouseDown = (event) => {\n    // Prevent default browser drag behavior (e.g., image drag, text selection)\n    event.preventDefault(); \n    event.stopPropagation(); // Stop bubbling if nested\n\n    setIsDragging(true);\n    // Calculate the offset from the top-left of the box to the mouse click point\n    // event.clientX/Y are relative to the viewport\n    // event.target.getBoundingClientRect() gives box's position relative to viewport\n    const boxRect = event.target.getBoundingClientRect();\n    offset.current = {\n      x: event.clientX - boxRect.left,\n      y: event.clientY - boxRect.top,\n    };\n  };\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      if (!isDragging) return;\n\n      // Calculate new position based on mouse move and initial offset\n      setPosition({\n        x: event.clientX - offset.current.x,\n        y: event.clientY - offset.current.y,\n      });\n    };\n\n    const handleMouseUp = () => {\n      setIsDragging(false);\n    };\n\n    // Attach listeners to the document to ensure dragging works even if mouse leaves the box\n    if (isDragging) {\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    }\n\n    // Cleanup function\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [isDragging]); // Re-run effect when isDragging changes\n\n  return (\n    <div\n      onMouseDown={handleMouseDown}\n      style={{\n        position: 'absolute',\n        left: position.x,\n        top: position.y,\n        width: '120px',\n        height: '120px',\n        backgroundColor: isDragging ? '#ffebcd' : 'lightblue',\n        border: '2px solid steelblue',\n        borderRadius: '8px',\n        cursor: isDragging ? 'grabbing' : 'grab',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        userSelect: 'none',\n        boxShadow: '0 4px 8px rgba(0,0,0,0.2)'\n      }}\n    >\n      Drag Me\n      <br />\n      (x:{position.x}, y:{position.y})\n    </div>\n  );\n}\n\nexport default DraggableBox;\n",
          "testCases": [
            "**Initial Position:** Verify the box starts at `x: 0, y: 0` (top-left of its containing context or viewport).",
            "**Basic Dragging:** Click and drag the box. Verify it moves smoothly with the mouse cursor.",
            "**Off-Box Dragging:** Click on the box, drag the mouse rapidly outside the box's boundaries, then release. Verify the box stops dragging when the mouse is released, even if off the box.",
            "**`preventDefault()`:** Try dragging text or images on the page without the box. Then, click and drag the box itself. Verify that the browser's default drag-and-drop behavior (e.g., ghost image of the box) is prevented when dragging the box.",
            "**State Update:** Observe `position.x` and `position.y` values updating in the `JSON.stringify` or a debugger as you drag.",
            "**Cleanup:** Confirm no memory leaks by checking event listeners if using browser dev tools (advanced). Ensure that `mousemove` and `mouseup` listeners are removed when `isDragging` becomes `false` or the component unmounts."
          ],
          "hints": [
            "Use `event.clientX` and `event.clientY` (viewport coordinates) for mouse position.",
            "To ensure dragging works even if the mouse cursor leaves the box, attach `mousemove` and `mouseup` listeners to the `document` object inside `useEffect`.",
            "Remember to return a cleanup function from `useEffect` to remove the `document` event listeners when the component unmounts or `isDragging` changes back to `false`.",
            "Calculate the `offset` between the mouse pointer and the top-left corner of the box at `onMouseDown` to prevent the box from 'jumping' when clicked.",
            "The `useRef` hook is useful for storing mutable values (like the offset or `setInterval` IDs) that don't trigger re-renders when they change."
          ],
          "tags": [
            "React",
            "Events",
            "SyntheticEvent",
            "useState",
            "useEffect",
            "useRef",
            "DOM Manipulation",
            "UI Component",
            "Coding Challenge"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "React Hooks",
            "JavaScript Events",
            "DOM Events (`mousemove`, `mouseup`)"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_react_events"
          ]
        }
      ]
    }
  },
  {
    "id": "e51c3a6f-4f35-470b-b485-1fd99e46d080",
    "startLine": 3700,
    "endLine": 3799,
    "processedDate": "2025-06-17T08:52:09.094Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_event_handling_basics",
          "title": "React Event Handling Fundamentals",
          "content": "React implements a synthetic event system that wraps browser's native events, providing a consistent cross-browser interface. While similar to traditional HTML DOM event handling, React introduces several key differences:\n\n### 1. Event Naming Convention (camelCase)\nUnlike HTML, where event names are typically lowercase (e.g., `onclick`), React uses camelCase for event names (e.g., `onClick`). This convention applies to all event types.\n\n### 2. Passing Functions as Event Handlers\nIn HTML, event handlers are often defined as strings containing JavaScript code that gets executed. In React, you pass a direct reference to a JavaScript function as the event handler. This allows for cleaner separation of concerns and easier maintenance.\n\n### 3. Explicit `preventDefault()`\nTo prevent the default browser behavior (like form submission or navigating away from a link), you must explicitly call `event.preventDefault()` within your event handler function. In traditional HTML, returning `false` from an event handler could sometimes prevent default behavior, but this is not the case in React's synthetic event system.\n\nReact's synthetic events are pooled. This means the synthetic event object will be reused, and its properties will be nullified after the event callback has been invoked. If you need to access the event object asynchronously, you should call `event.persist()` on the event, or read the properties you need before the event callback returns.",
          "examples": [
            {
              "id": "example_react_event_handling_basics_1",
              "title": "HTML vs. React Event Naming and Handler Passing",
              "code": "```html\n<!-- In HTML -->\n<button onclick=\"activateAccount()\">\n  Activate Account\n</button>\n<a href=\"#\" onclick=\"console.log('Clicked'); return false;\">\n  Click me\n</a>\n```\n\n```jsx\n// In React\nfunction activateAccount() {\n  console.log('Account activated!');\n}\n\nfunction preventNavigation(e) {\n  e.preventDefault(); // Explicitly prevent default\n  console.log('Navigation prevented, but clicked!');\n}\n\nfunction MyComponent() {\n  return (\n    <>\n      <button onClick={activateAccount}>\n        Activate Account\n      </button>\n      <a href=\"#\" onClick={preventNavigation}>\n        Click me (Prevent Default)\n      </a>\n    </>\n  );\n}\n```",
              "explanation": "This example clearly illustrates the differences. In HTML, `onclick` is lowercase and accepts a string. In React, `onClick` is camelCase and accepts a function reference. Additionally, the `preventDefault()` method is explicitly called on the synthetic event object `e` to stop the default browser behavior of navigating to '#'.",
              "language": "jsx"
            },
            {
              "id": "example_react_event_handling_basics_2",
              "title": "Complete Event Handling Example in React",
              "code": "```jsx\nfunction ButtonComponent() {\n  const handleClick = (e) => {\n    // console.log('Event target:', e.target);\n    // console.log('Event type:', e.type);\n    e.preventDefault(); // Prevents default behavior (e.g., form submission if this was a submit button)\n    console.log('Button was clicked and default prevented');\n  };\n\n  return (\n    <button onClick={handleClick}>\n      Click me\n    </button>\n  );\n}\n\n// Usage example:\n// ReactDOM.render(<ButtonComponent />, document.getElementById('root'));\n```",
              "explanation": "This example shows a functional React component demonstrating a basic click handler. The `handleClick` function receives the synthetic event object `e`. Inside this handler, `e.preventDefault()` is called to explicitly prevent any default browser action associated with the button (though for a simple button, it's less critical unless it's a submit button within a form). `console.log` is used to confirm the event has fired.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_react_events_syntax_mcq",
            "question_prevent_default_code",
            "question_html_react_event_diff_flashcard",
            "question_event_pooling_open"
          ],
          "relatedTasks": [
            "task_button_link_events"
          ],
          "tags": [
            "React",
            "Events",
            "Event Handling",
            "Synthetic Events",
            "DOM"
          ],
          "technology": "React",
          "prerequisites": [
            "html_basics",
            "javascript_functions",
            "dom_events"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_forms",
            "react_interactions"
          ]
        },
        {
          "id": "theory_pointer_events",
          "title": "React Pointer Events",
          "content": "React supports Pointer Events, which offer a unified and abstract way to handle various input types, including mouse, touch, and pen interactions, through a single set of event handlers. This API simplifies developing applications that need to support diverse input methods without writing separate logic for each. Pointer Events provide a `pointerId` property to track individual pointers, and properties like `clientX`, `clientY` for coordinates, similar to mouse events.\n\nKey Pointer Event types include:\n- `onPointerDown`: Triggered when a pointer comes into contact with the surface.\n- `onPointerMove`: Triggered when a pointer changes coordinates.\n- `onPointerUp`: Triggered when a pointer is lifted from the surface.\n- `onPointerCancel`: Triggered when a pointer event is canceled by the browser (e.g., due to a browser gesture).\n- `onGotPointerCapture`: Triggered when an element receives pointer capture.\n- `onLostPointerCapture`: Triggered when an element loses pointer capture.\n- `onPointerEnter`: Triggered when a pointer enters an element's hit test boundaries.\n- `onPointerLeave`: Triggered when a pointer leaves an element's hit test boundaries.\n- `onPointerOver`: Triggered when a pointer is moved into the hit test boundaries of an element or one of its descendants.\n- `onPointerOut`: Triggered when a pointer is moved out of the hit test boundaries of an element or one of its descendants.\n\nPointer Events are particularly useful for creating interactive elements like draggable components, drawing applications, or any UI element requiring precise input tracking across different devices.",
          "examples": [
            {
              "id": "example_pointer_events_1",
              "title": "Basic Pointer Event Handlers",
              "code": "```jsx\nfunction PointerEventsDemo() {\n  return (\n    <div\n      style={{\n        width: '300px',\n        height: '200px',\n        border: '2px solid blue',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        cursor: 'pointer'\n      }}\n      onPointerDown={(e) => console.log('Pointer down, ID:', e.pointerId)}\n      onPointerMove={(e) => console.log('Pointer move, X:', e.clientX, 'Y:', e.clientY)}\n      onPointerUp={(e) => console.log('Pointer up')}\n      onPointerCancel={(e) => console.log('Pointer cancel')}\n      onGotPointerCapture={(e) => console.log('Got pointer capture, ID:', e.pointerId)}\n      onLostPointerCapture={(e) => console.log('Lost pointer capture, ID:', e.pointerId)}\n      onPointerEnter={(e) => console.log('Pointer enter')}\n      onPointerLeave={(e) => console.log('Pointer leave')}\n      onPointerOver={(e) => console.log('Pointer over')}\n      onPointerOut={(e) => console.log('Pointer out')}\n    >\n      Pointer Events Demo Area\n    </div>\n  );\n}\n\n// Usage example:\n// ReactDOM.render(<PointerEventsDemo />, document.getElementById('root'));\n```",
              "explanation": "This example demonstrates how to attach various Pointer Event handlers to a `div` element. When interacting with this area using a mouse, touch, or pen, the respective console logs will show the event type and relevant properties like `pointerId` and coordinates (`clientX`, `clientY`). This allows for a unified approach to input handling.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_pointer_events_purpose_mcq",
            "question_pointer_events_use_cases_open",
            "question_pointer_events_types_flashcard",
            "question_mouse_vs_pointer_open"
          ],
          "relatedTasks": [
            "task_draggable_element_pointer_events"
          ],
          "tags": [
            "React",
            "Events",
            "Pointer Events",
            "Input Handling",
            "Cross-Browser"
          ],
          "technology": "React",
          "prerequisites": [
            "react_event_handling_basics",
            "dom_events"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "interactive_uis",
            "touch_interfaces"
          ]
        },
        {
          "id": "theory_react_state_management_class_components",
          "title": "React State Management in Class Components",
          "content": "In React class components, `state` is a plain JavaScript object that holds data relevant to a component that can change over time. When the `state` object changes, the component re-renders. `state` is managed within the component itself and is typically initialized in the constructor or as a class property (using the class fields syntax).\n\n### Initializing State\nState can be initialized as a class property directly, as shown in the example, or within the `constructor` method of the class component:\n\n```jsx\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 }; // Initialize state in constructor\n  }\n  // ...\n}\n// OR using class fields syntax (requires Babel preset-env with class properties):\nclass MyComponent extends React.Component {\n  state = { count: 0 }; // Initialize state as a class property\n  // ...\n}\n```\n\n### Updating State (`this.setState()`)\nTo update the state, you must use the `this.setState()` method. This method merges the new state into the current state and triggers a re-render of the component and its children. `setState` is asynchronous; React may batch multiple `setState` calls for performance. For updates that depend on the previous state, it's recommended to pass a function to `setState` to ensure you're working with the most up-to-date state value.\n\n```jsx\n// Updating state with an object (for independent values)\nthis.setState({ visible: true });\n\n// Updating state with a function (when new state depends on previous state)\nthis.setState((prevState) => ({\n  count: prevState.count + 1\n}));\n```\n\nIt's important to remember that `state` should not be modified directly (e.g., `this.state.visible = true;`). Always use `this.setState()` to ensure React's re-rendering mechanism works correctly.",
          "examples": [
            {
              "id": "example_react_state_class_component_1",
              "title": "Basic State Management in a Class Component",
              "code": "```jsx\nimport React from 'react';\n\nclass Article extends React.Component {\n  // Initialize state using class fields syntax\n  state = {\n    visible: false,\n    readCount: 0\n  };\n\n  // Event handler to update state\n  handleReadMoreClick = (e) => {\n    e.preventDefault(); // Prevent default link behavior\n    // Using setState to merge the new state with the existing state\n    this.setState({\n      visible: true,\n      readCount: this.state.readCount + 1 // Directly using this.state for simple updates\n    });\n    console.log('Article visibility updated to:', true);\n  };\n\n  render() {\n    const { visible, readCount } = this.state;\n    return (\n      <div>\n        <h2>My Awesome Article</h2>\n        <p>This is a short introduction...</p>\n        {!visible && (\n          <a href=\"#\" onClick={this.handleReadMoreClick}>\n            Read More\n          </a>\n        )}\n        {visible && (\n          <p>This is the full article content that becomes visible after clicking 'Read More'.</p>\n        )}\n        <p>Times read: {readCount}</p>\n      </div>\n    );\n  }\n}\n\n// Usage example:\n// ReactDOM.render(<Article />, document.getElementById('root'));\n```",
              "explanation": "This example demonstrates a `Article` class component managing its `visible` and `readCount` state. The `state` is initialized directly as a class property. The `handleReadMoreClick` method updates `visible` to `true` and increments `readCount` using `this.setState()`. When `visible` changes, the component re-renders to show the full article content. The `e.preventDefault()` ensures the link doesn't navigate.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_setstate_purpose_mcq",
            "question_direct_state_mutation_flashcard",
            "question_setstate_async_open",
            "question_class_state_toggle_code"
          ],
          "relatedTasks": [
            "task_toggle_visibility_component"
          ],
          "tags": [
            "React",
            "State",
            "Class Components",
            "setState",
            "Component Lifecycle"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_classes",
            "react_components"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_flow",
            "component_interaction"
          ]
        },
        {
          "id": "theory_lifting_state_up",
          "title": "Lifting State Up",
          "content": "In React, when multiple sibling components need to share or communicate data, or when a child component needs to communicate with a parent's sibling, the recommended approach is to 'lift the state up' to their closest common ancestor. This pattern ensures that the 'single source of truth' for that shared state resides in one place, making data flow predictable and debugging easier.\n\n### How it Works:\n1.  **Identify Shared State:** Determine which piece of state is needed by multiple components.\n2.  **Move State to Common Ancestor:** Move this shared state from a child component to its closest common parent component.\n3.  **Pass Data Down via Props:** The parent component then passes the state down to its children (or grandchildren) as props.\n4.  **Pass Callbacks Down via Props:** If a child needs to update this shared state, the parent passes down a callback function (also via props) that the child can call to request state changes. The parent's state update function then modifies the state, causing a re-render and updated props for all relevant children.\n\nThis pattern aligns with React's philosophy of 'one-way data flow' (or 'unidirectional data flow'), where data moves down the component tree through props. Lifting state up is a fundamental concept for building robust and maintainable React applications with interactive data dependencies.",
          "examples": [
            {
              "id": "example_lifting_state_up_1",
              "title": "Counter Example with Lifting State Up",
              "code": "```jsx\nimport React, { useState } from 'react';\n\n// Child Component 1: Displays the count\nfunction DisplayCount({ count }) {\n  return <h2>Current Count: {count}</h2>;\n}\n\n// Child Component 2: Button to increment the count\nfunction CounterButton({ onIncrement }) {\n  return (\n    <button onClick={onIncrement}>\n      Increment Count\n    </button>\n  );\n}\n\n// Parent Component: Manages the shared count state\nfunction CounterApp() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <h1>Lifting State Up Example</h1>\n      {/* State passed down as prop */}\n      <DisplayCount count={count} />\n      {/* Callback function passed down as prop */}\n      <CounterButton onIncrement={handleIncrement} />\n    </div>\n  );\n}\n\n// Usage example:\n// ReactDOM.render(<CounterApp />, document.getElementById('root'));\n```",
              "explanation": "In this example, `CounterApp` is the common ancestor managing the `count` state. It passes `count` as a prop to `DisplayCount` for display. It also passes `handleIncrement`, a callback function, to `CounterButton`. When `CounterButton` is clicked, it calls `onIncrement`, which in turn executes `handleIncrement` in `CounterApp`, updating the `count` state. This update triggers a re-render, and `DisplayCount` receives the new `count` value, demonstrating the flow of lifted state.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_lifting_state_up_purpose_open",
            "question_lifting_state_up_flow_flashcard",
            "question_lifting_state_up_mcq",
            "question_lifting_state_up_code"
          ],
          "relatedTasks": [
            "task_parent_child_communication_lifting_state"
          ],
          "tags": [
            "React",
            "State Management",
            "Data Flow",
            "Component Communication",
            "Props",
            "Patterns"
          ],
          "technology": "React",
          "prerequisites": [
            "react_state_management_class_components",
            "react_hooks_useState",
            "react_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_applications",
            "state_management_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_events_syntax_mcq",
          "topic": "React Event Handling Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct way to handle a click event on a button in React?",
          "answer": "<button onClick={handleClick}>Click Me</button>",
          "options": [
            "<button onclick=\"handleClick()\">Click Me</button>",
            "<button onClick=\"handleClick\">Click Me</button>",
            "<button onClick={handleClick()}>Click Me</button>",
            "<button onClick={handleClick}>Click Me</button>"
          ],
          "analysisPoints": [
            "React event names are camelCase (e.g., `onClick` instead of `onclick`).",
            "Event handlers in React receive a direct function reference, not a string.",
            "Calling `handleClick()` directly in JSX would execute the function immediately during render, not when the button is clicked. It should be `handleClick`."
          ],
          "keyConcepts": [
            "React event naming conventions",
            "Passing function references as event handlers",
            "Distinction between function call and function reference"
          ],
          "evaluationCriteria": [
            "Understanding of React's JSX event syntax.",
            "Knowledge of camelCase convention for events.",
            "Ability to differentiate between calling a function and passing a reference."
          ],
          "example": "The correct option `<button onClick={handleClick}>Click Me</button>` demonstrates React's camelCase syntax for event names and passing a direct reference to the `handleClick` function, ensuring it's called only when the button is clicked. Other options show common pitfalls like using HTML-like string syntax or immediately invoking the function.",
          "tags": [
            "React",
            "Events",
            "JSX",
            "Syntax"
          ],
          "prerequisites": [
            "react_basics",
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_prevent_default_code",
          "topic": "React Event Handling Fundamentals",
          "level": "medium",
          "type": "code",
          "question": "You have an anchor (`<a>`) tag in React that, when clicked, should log a message to the console but **should not** navigate the page. Complete the `handleLinkClick` function and the JSX for the `<a>` tag to achieve this.",
          "answer": "```jsx\nimport React from 'react';\n\nfunction MyLinkComponent() {\n  const handleLinkClick = (e) => {\n    e.preventDefault(); // Prevents the default navigation behavior\n    console.log('Link was clicked, but navigation prevented.');\n  };\n\n  return (\n    <a href=\"/some-page\" onClick={handleLinkClick}>\n      Click me, but stay here\n    </a>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "The primary method to prevent default browser actions in React synthetic events is `e.preventDefault()`.",
            "Returning `false` from a handler does not prevent default behavior in React.",
            "The `onClick` attribute should receive a function reference."
          ],
          "keyConcepts": [
            "SyntheticEvent object",
            "`preventDefault()` method",
            "React event handling syntax"
          ],
          "evaluationCriteria": [
            "Correct use of `e.preventDefault()`.",
            "Correct React event syntax (`onClick={handler}`).",
            "Understanding of the difference from traditional HTML event handling."
          ],
          "example": "The solution correctly uses `e.preventDefault()` within the `handleLinkClick` function. This is the standard and only reliable way to prevent default browser actions like navigation for an `<a>` tag or form submission for a `<form>` in React's synthetic event system. The `onClick` attribute is correctly assigned the function reference.",
          "tags": [
            "React",
            "Events",
            "preventDefault",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_event_handling_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_html_react_event_diff_flashcard",
          "topic": "React Event Handling Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two main differences between event handling in plain HTML (inline) and React JSX?",
          "answer": "1. **Naming Convention:** HTML uses lowercase (e.g., `onclick`), React uses camelCase (e.g., `onClick`).\n2. **Handler Type:** HTML often uses strings (e.g., `onclick=\"doSomething()\"`), React uses direct function references (e.g., `onClick={doSomething}`).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Events",
            "HTML Events",
            "JSX",
            "CamelCase"
          ],
          "evaluationCriteria": [
            "Recall of fundamental differences."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "Flashcard",
            "Basics"
          ],
          "prerequisites": [
            "react_event_handling_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_pooling_open",
          "topic": "React Event Handling Fundamentals",
          "level": "medium",
          "type": "open",
          "question": "React's synthetic events are 'pooled'. What does this mean, and what is a potential pitfall and its solution when dealing with asynchronous code?",
          "answer": "React's synthetic events are 'pooled' for performance. This means that the synthetic event object is reused and its properties are nullified (set to `null`) shortly after the event handler function has completed. This optimization reduces the garbage collection overhead.\n\n**Potential Pitfall:** If you try to access properties of the `e` (event) object asynchronously (e.g., inside a `setTimeout`, a `Promise.then()` callback, or an `async/await` function after the `await`), the properties will likely be nullified, leading to unexpected behavior or errors.\n\n**Solution:** To safely access event properties asynchronously, you have two main options:\n1.  **Call `e.persist()`:** This method removes the synthetic event from the pool, allowing you to retain references to it and its properties. However, `e.persist()` is deprecated in React 17+ and not needed with modern event handling (e.g., React DOM event handlers no longer use pooling from React 17 onwards, though it's still a good concept to know for interviews).\n2.  **Extract properties:** The more robust and recommended solution is to extract the properties you need from the event object *before* the event handler completes, and then use these extracted values in your asynchronous code.",
          "options": [],
          "analysisPoints": [
            "Definition of event pooling and its purpose (performance).",
            "Identification of the pitfall: accessing nullified properties asynchronously.",
            "Explanation of solutions: `e.persist()` (and its deprecation context) or extracting properties."
          ],
          "keyConcepts": [
            "Synthetic Events",
            "Event Pooling",
            "Asynchronous JavaScript",
            "`e.persist()`"
          ],
          "evaluationCriteria": [
            "Demonstrates understanding of React's internal event optimization.",
            "Identifies and explains common asynchronous pitfalls.",
            "Proposes correct and modern solutions."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "Performance",
            "Asynchronous",
            "Advanced"
          ],
          "prerequisites": [
            "react_event_handling_basics",
            "javascript_async"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_pointer_events_purpose_mcq",
          "topic": "React Pointer Events",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary advantage of using React's Pointer Events over traditional mouse and touch events?",
          "answer": "They provide a unified way to handle various input types (mouse, touch, pen) with a single set of event handlers.",
          "options": [
            "They offer better performance than traditional events.",
            "They are specifically designed for virtual reality applications.",
            "They provide a unified way to handle various input types (mouse, touch, pen) with a single set of event handlers.",
            "They automatically prevent default browser behavior for all interactions."
          ],
          "analysisPoints": [
            "Pointer Events abstract different input types into a single model.",
            "Their main benefit is code simplification for multi-input applications.",
            "They do not automatically prevent default behavior; `preventDefault()` is still required."
          ],
          "keyConcepts": [
            "Pointer Events",
            "Unified Input",
            "Cross-device compatibility"
          ],
          "evaluationCriteria": [
            "Understanding of the core purpose of Pointer Events.",
            "Ability to distinguish its unique selling proposition."
          ],
          "example": "The key benefit of Pointer Events is their ability to unify input handling across different devices (mouse, touch, pen). This simplifies development for applications that need to respond to various forms of user interaction without writing separate code branches for each.",
          "tags": [
            "React",
            "Events",
            "Pointer Events",
            "Input"
          ],
          "prerequisites": [
            "react_event_handling_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pointer_events_use_cases_open",
          "topic": "React Pointer Events",
          "level": "medium",
          "type": "open",
          "question": "Describe two real-world scenarios where using React's Pointer Events would be particularly beneficial. Justify your choices.",
          "answer": "1.  **Draggable/Resizable UI Elements:** When building a UI where elements can be dragged or resized, Pointer Events provide a single API to handle interactions regardless of whether the user is using a mouse, touch, or a pen. For instance, an `onPointerDown` can initiate a drag, `onPointerMove` can update the position, and `onPointerUp` can end the drag. This avoids having to manage separate `onMouseDown`/`onMouseMove`/`onMouseUp` and `onTouchStart`/`onTouchMove`/`onTouchEnd` logic.\n\n2.  **Interactive Canvas/Drawing Applications:** In applications like a whiteboard or a graphic design tool where users draw or manipulate objects, Pointer Events are invaluable. They can distinguish between different pointer types (e.g., finger vs. pen) and provide pressure information (`e.pressure`). This allows for richer interactions, such as varying line thickness based on pen pressure, or differentiating between a 'select' action (mouse click) and a 'draw' action (pen stroke) with a unified event listener.",
          "options": [],
          "analysisPoints": [
            "Identifies scenarios requiring multi-input support.",
            "Explains how Pointer Events simplify development in these scenarios.",
            "Mentions specific Pointer Event properties or capabilities (`pointerId`, `pressure`)."
          ],
          "keyConcepts": [
            "Pointer Events",
            "Cross-device UI",
            "Unified input",
            "User experience"
          ],
          "evaluationCriteria": [
            "Ability to apply theoretical knowledge to practical scenarios.",
            "Justification of choices with technical details.",
            "Demonstrates understanding of the unique value proposition of Pointer Events."
          ],
          "example": null,
          "tags": [
            "React",
            "Pointer Events",
            "Use Cases",
            "Design",
            "Interactive UI"
          ],
          "prerequisites": [
            "react_pointer_events"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_pointer_events_types_flashcard",
          "topic": "React Pointer Events",
          "level": "easy",
          "type": "flashcard",
          "question": "Name three common React Pointer Events and what they generally signify.",
          "answer": "1.  `onPointerDown`: A pointer (mouse, touch, pen) has made contact with the surface.\n2.  `onPointerMove`: A pointer is moving across the surface.\n3.  `onPointerUp`: A pointer has been lifted from the surface.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Pointer Events",
            "Event Types",
            "Input"
          ],
          "evaluationCriteria": [
            "Recall of common Pointer Event types and their meaning."
          ],
          "example": null,
          "tags": [
            "React",
            "Pointer Events",
            "Flashcard"
          ],
          "prerequisites": [
            "react_pointer_events"
          ],
          "complexity": 3,
          "interviewFrequency": 4,
          "learningPath": "intermediate"
        },
        {
          "id": "question_setstate_purpose_mcq",
          "topic": "React State Management in Class Components",
          "level": "easy",
          "type": "mcq",
          "question": "In a React class component, what is the correct method to update the component's `state` and trigger a re-render?",
          "answer": "this.setState()",
          "options": [
            "this.state.propertyName = newValue;",
            "updateState()",
            "this.setState()",
            "this.forceUpdate()"
          ],
          "analysisPoints": [
            "Direct mutation of `this.state` (e.g., `this.state.propertyName = newValue;`) will not trigger a re-render and is a common anti-pattern.",
            "`this.setState()` is the standard asynchronous method for updating state.",
            "`this.forceUpdate()` forces a re-render but should generally be avoided unless absolutely necessary, as it bypasses `shouldComponentUpdate`."
          ],
          "keyConcepts": [
            "React State",
            "`setState` method",
            "Component re-rendering",
            "Immutability of state"
          ],
          "evaluationCriteria": [
            "Correct identification of the state update method.",
            "Understanding of why direct state mutation is wrong.",
            "Familiarity with React component lifecycle and rendering."
          ],
          "example": "The `this.setState()` method is the sole way to update a class component's state and inform React that the component needs to be re-rendered. Directly modifying `this.state.propertyName = newValue;` will change the state object but bypass React's update mechanism, leading to UI that doesn't reflect the data.",
          "tags": [
            "React",
            "State",
            "Class Components",
            "setState"
          ],
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_direct_state_mutation_flashcard",
          "topic": "React State Management in Class Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Why should you never directly modify `this.state` in a React class component (e.g., `this.state.count = 5;`)?",
          "answer": "Directly modifying `this.state` will not trigger a re-render of the component. React's change detection and reconciliation process relies on `this.setState()` to know when state has changed and a re-render is needed. Bypassing `setState()` leads to UI that does not reflect the underlying data.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React State",
            "Immutability",
            "setState",
            "Re-render"
          ],
          "evaluationCriteria": [
            "Understanding of state immutability in React."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Class Components",
            "Flashcard"
          ],
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_setstate_async_open",
          "topic": "React State Management in Class Components",
          "level": "medium",
          "type": "open",
          "question": "Explain why `this.setState()` is asynchronous and what implications this has for state updates that depend on the previous state. Provide an example of how to correctly update state based on previous state.",
          "answer": "`this.setState()` is asynchronous because React may batch multiple `setState()` calls for performance reasons to avoid unnecessary re-renders. When `setState()` is called, React doesn't necessarily update the state immediately; it schedules an update. This means `this.state` might not be the most up-to-date value right after calling `setState()`.\n\n**Implication:** If you try to update state based on the current `this.state` value immediately after calling `setState()`, you might be using a stale value. For example, if you call `this.setState({ count: this.state.count + 1 });` twice in a row within the same event loop tick, the second call might use the `count` value from *before* the first `setState()` call was processed.\n\n**Correct Way (Functional `setState`):** To correctly update state that depends on the previous state, you should pass a function to `this.setState()`. This function receives the `prevState` as its first argument and `props` as its second, guaranteeing you're working with the most current state value.\n\n**Example:**\n```jsx\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  handleIncrement = () => {\n    // Incorrect way if multiple updates are batched or depend on previous state\n    // this.setState({ count: this.state.count + 1 }); \n\n    // Correct way: using a function to ensure latest state is used\n    this.setState((prevState) => ({\n      count: prevState.count + 1\n    }));\n\n    this.setState((prevState) => ({\n      count: prevState.count + 1 // This will correctly increment from the result of the first update\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleIncrement}>Increment</button>\n      </div>\n    );\n  }\n}\n```",
          "options": [],
          "analysisPoints": [
            "Explains the asynchronous nature and its purpose (batching, performance).",
            "Identifies the pitfall of relying on `this.state` immediately after `setState`.",
            "Demonstrates the functional form of `setState` with `prevState` parameter.",
            "Provides a clear code example for correct usage."
          ],
          "keyConcepts": [
            "setState Asynchronous",
            "State Batching",
            "Functional setState",
            "Previous State"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of `setState`'s async behavior.",
            "Correctly identifies and demonstrates the solution for dependent state updates.",
            "Provides a clear and accurate code example."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Class Components",
            "setState",
            "Asynchronous"
          ],
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifting_state_up_purpose_open",
          "topic": "Lifting State Up",
          "level": "medium",
          "type": "open",
          "question": "What is the 'Lifting State Up' pattern in React, and why is it considered a best practice for managing shared state between components?",
          "answer": "The 'Lifting State Up' pattern in React is a strategy where if multiple child components need to share the same state, or if a child component needs to communicate with a sibling component, the state is moved (or 'lifted') from the child component(s) to their closest common ancestor component. This common ancestor then becomes the 'single source of truth' for that particular piece of state.\n\n**Why it's a best practice:**\n1.  **Single Source of Truth:** It ensures that shared data is managed in one place, making it easier to reason about the state and predict how changes will affect the UI.\n2.  **Unidirectional Data Flow:** It adheres to React's principle of one-way data flow. The parent component passes state down to children via props, and children communicate updates back to the parent via callback functions passed down as props.\n3.  **Simpler Debugging:** With state centralized, it's easier to trace data changes and pinpoint bugs related to shared data.\n4.  **Improved Component Reusability:** Child components become 'dumb' or 'presentational' components that simply receive data and callbacks via props, making them more reusable and less coupled to specific state management logic.",
          "options": [],
          "analysisPoints": [
            "Clear definition of 'Lifting State Up'.",
            "Explanation of the 'single source of truth' concept.",
            "Connection to unidirectional data flow.",
            "Benefits like simpler debugging and improved reusability."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Shared State",
            "Common Ancestor",
            "Unidirectional Data Flow",
            "Props",
            "Callbacks"
          ],
          "evaluationCriteria": [
            "Ability to define and explain the pattern.",
            "Understanding of the underlying principles (single source of truth, one-way data flow).",
            "Articulation of benefits and best practices."
          ],
          "example": null,
          "tags": [
            "React",
            "State Management",
            "Patterns",
            "Architecture",
            "Best Practices"
          ],
          "prerequisites": [
            "react_state_management_class_components",
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifting_state_up_flow_flashcard",
          "topic": "Lifting State Up",
          "level": "easy",
          "type": "flashcard",
          "question": "How does data flow when state is 'lifted up' in React (i.e., from parent to child, and child to parent for updates)?",
          "answer": "Data (state) flows down from the common ancestor (parent) to child components via `props`. When a child component needs to update this shared state, it calls a callback function, which was passed down from the parent via `props`. This callback function then updates the state in the parent.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Lifting State Up",
            "Data Flow",
            "Props",
            "Callbacks"
          ],
          "evaluationCriteria": [
            "Recall of data flow in lifted state scenarios."
          ],
          "example": null,
          "tags": [
            "React",
            "State Management",
            "Flashcard",
            "Data Flow"
          ],
          "prerequisites": [
            "react_lifting_state_up"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifting_state_up_mcq",
          "topic": "Lifting State Up",
          "level": "medium",
          "type": "mcq",
          "question": "Consider a `ParentComponent` that renders two sibling components: `InputComponent` and `DisplayComponent`. `InputComponent` has a text input, and `DisplayComponent` should show the current value typed into `InputComponent`. How would you typically implement this using the 'Lifting State Up' pattern?",
          "answer": "The ParentComponent manages the input's value in its state and passes the value to DisplayComponent as a prop, and a callback function to InputComponent to update the value.",
          "options": [
            "InputComponent directly updates DisplayComponent's state using a ref.",
            "Each component maintains its own state, and a global event bus communicates changes.",
            "The ParentComponent manages the input's value in its state and passes the value to DisplayComponent as a prop, and a callback function to InputComponent to update the value.",
            "DisplayComponent fetches the input's value directly from InputComponent's DOM element."
          ],
          "analysisPoints": [
            "Refs are generally not used for state management between components.",
            "Global event buses are an alternative but not the standard 'Lifting State Up' pattern for direct parent-child/sibling communication in React.",
            "Directly accessing another component's DOM is an anti-pattern for data flow.",
            "The correct answer describes the core mechanism of lifting state: state in common ancestor, data down via props, callbacks up via props."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Unidirectional Data Flow",
            "Props",
            "Callbacks",
            "Shared State"
          ],
          "evaluationCriteria": [
            "Understanding of the core mechanism of 'Lifting State Up'.",
            "Ability to identify correct data flow patterns in React.",
            "Recognition of anti-patterns."
          ],
          "example": "This scenario is a classic example for 'Lifting State Up'. The `ParentComponent` would hold the `inputValue` state. It passes `inputValue` as a prop to `DisplayComponent` to render it. It also passes a function, let's say `handleInputChange`, as a prop to `InputComponent`. When the input's value changes, `InputComponent` calls `handleInputChange` with the new value, which then updates the state in `ParentComponent`, triggering re-renders for both children.",
          "tags": [
            "React",
            "State Management",
            "Lifting State Up",
            "Component Communication",
            "Pattern"
          ],
          "prerequisites": [
            "react_lifting_state_up"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_state_toggle_code",
          "topic": "React State Management in Class Components",
          "level": "medium",
          "type": "code",
          "question": "Create a React class component named `ToggleButton` that displays a message. When a button inside the component is clicked, the message should toggle between 'Message Visible!' and 'Message Hidden!'. Initial state should be 'Message Hidden!'.",
          "answer": "```jsx\nimport React from 'react';\n\nclass ToggleButton extends React.Component {\n  state = {\n    isVisible: false\n  };\n\n  handleToggle = () => {\n    this.setState(prevState => ({\n      isVisible: !prevState.isVisible\n    }));\n  };\n\n  render() {\n    const { isVisible } = this.state;\n    return (\n      <div>\n        <p>{isVisible ? 'Message Visible!' : 'Message Hidden!'}</p>\n        <button onClick={this.handleToggle}>\n          Toggle Message\n        </button>\n      </div>\n    );\n  }\n}\n\n// Usage example:\n// ReactDOM.render(<ToggleButton />, document.getElementById('root'));\n```",
          "options": [],
          "analysisPoints": [
            "Correct initialization of state in a class component.",
            "Correct usage of `this.setState()` to update state.",
            "Using the functional form of `setState` (`prevState`) is best practice when the new state depends on the old state.",
            "Conditional rendering based on state.",
            "Binding `this` context to `handleToggle` (implicitly handled by arrow function as class property)."
          ],
          "keyConcepts": [
            "Class Component State",
            "`setState`",
            "Conditional Rendering",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Ability to manage state in class components.",
            "Correct application of `setState` for toggling boolean state.",
            "Proper use of conditional rendering.",
            "Adherence to React coding conventions."
          ],
          "example": "This solution correctly initializes `isVisible` to `false`. The `handleToggle` method uses the functional `setState` to safely toggle the `isVisible` boolean, ensuring accurate state updates even if React batches calls. The `render` method then conditionally displays the message based on `isVisible`.",
          "tags": [
            "React",
            "State",
            "Class Components",
            "Code Challenge",
            "Conditional Rendering"
          ],
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_button_link_events",
          "title": "Implement Interactive Button and Link in React",
          "description": "\nCreate a React functional component named `InteractionDemo` that includes:\n\n1.  A `<button>` element that, when clicked, logs 'Button was clicked!' to the console.\n2.  A `<a>` tag with `href=\"#\"` that, when clicked, logs 'Link clicked, navigation prevented!' to the console, and importantly, **prevents the default browser behavior** (i.e., doesn't navigate or scroll to the top of the page).\n\nEnsure that you adhere to React's event handling conventions (camelCase, passing functions).",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\nfunction InteractionDemo() {\n  // Implement button click handler here\n  const handleButtonClick = () => {\n    // TODO: Log a message\n  };\n\n  // Implement link click handler here\n  const handleLinkClick = (e) => {\n    // TODO: Prevent default behavior and log a message\n  };\n\n  return (\n    <div>\n      {/* TODO: Add a button here */}\n      {/* TODO: Add a link here */}\n    </div>\n  );\n}\n\nexport default InteractionDemo;\n",
          "solutionCode": "import React from 'react';\n\nfunction InteractionDemo() {\n  const handleButtonClick = () => {\n    console.log('Button was clicked!');\n  };\n\n  const handleLinkClick = (e) => {\n    e.preventDefault(); // Critical: prevents default navigation for <a> tags\n    console.log('Link clicked, navigation prevented!');\n  };\n\n  return (\n    <div>\n      <button onClick={handleButtonClick}>\n        Click Me\n      </button>\n      <br /><br />\n      <a href=\"#\" onClick={handleLinkClick}>\n        Click me, but stay here\n      </a>\n    </div>\n  );\n}\n\nexport default InteractionDemo;\n",
          "testCases": [
            "Clicking the button should log 'Button was clicked!' to the console.",
            "Clicking the link should log 'Link clicked, navigation prevented!' to the console.",
            "Clicking the link should NOT cause the page to scroll to the top or change the URL hash.",
            "Ensure event handlers are passed as function references, not strings."
          ],
          "hints": [
            "Remember React's `onClick` syntax (camelCase).",
            "To prevent default actions for the link, you'll need access to the synthetic event object."
          ],
          "tags": [
            "React",
            "Events",
            "Event Handling",
            "preventDefault",
            "Basics"
          ],
          "timeEstimate": 20,
          "prerequisites": [
            "react_basics",
            "react_event_handling_basics"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "synthetic_events",
            "jsx"
          ]
        },
        {
          "id": "task_draggable_element_pointer_events",
          "title": "Create a Draggable Element with React Pointer Events",
          "description": "\nImplement a React functional component named `DraggableBox` that allows a user to drag a `div` element around the screen using mouse, touch, or pen.\n\nRequirements:\n1.  The `div` should have a fixed size (e.g., 100px by 100px) and a distinct background color.\n2.  Use **Pointer Events** (`onPointerDown`, `onPointerMove`, `onPointerUp`) to manage the drag functionality.\n3.  The box's position should update as the pointer moves while it's 'down'.\n4.  The box should stop moving when the pointer is 'up'.\n5.  Consider how to correctly calculate the position relative to the element's initial click point to avoid 'jumping'.\n6.  The element should be absolutely positioned.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useRef } from 'react';\n\nfunction DraggableBox() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const offset = useRef({ x: 0, y: 0 }); // To store the offset from mouse to element top-left\n\n  const handlePointerDown = (e) => {\n    // TODO: Implement logic for when pointer goes down\n    // 1. Set isDragging to true\n    // 2. Calculate the offset from pointer position to element's top-left corner\n    //    e.g., offset.current.x = e.clientX - position.x\n  };\n\n  const handlePointerMove = (e) => {\n    // TODO: Implement logic for when pointer moves\n    // 1. If dragging, update the position based on pointer movement and stored offset\n    //    e.g., setPosition({ x: e.clientX - offset.current.x, y: e.clientY - offset.current.y });\n  };\n\n  const handlePointerUp = () => {\n    // TODO: Implement logic for when pointer goes up\n    // 1. Set isDragging to false\n  };\n\n  return (\n    <div\n      style={{\n        position: 'absolute',\n        width: '100px',\n        height: '100px',\n        backgroundColor: 'rebeccapurple',\n        cursor: 'grab',\n        left: position.x,\n        top: position.y,\n        userSelect: 'none'\n      }}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      Drag Me\n    </div>\n  );\n}\n\nexport default DraggableBox;\n",
          "solutionCode": "import React, { useState, useRef } from 'react';\n\nfunction DraggableBox() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const offset = useRef({ x: 0, y: 0 }); // To store the offset from mouse to element top-left\n  const boxRef = useRef(null);\n\n  const handlePointerDown = (e) => {\n    setIsDragging(true);\n    // Calculate the offset from the pointer's current position to the box's top-left corner\n    // This prevents the box from 'jumping' its top-left to the pointer's position on click.\n    const rect = boxRef.current.getBoundingClientRect();\n    offset.current = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top,\n    };\n    // Important for dragging: capture the pointer to receive events even if pointer leaves the element\n    boxRef.current.setPointerCapture(e.pointerId);\n  };\n\n  const handlePointerMove = (e) => {\n    if (isDragging) {\n      // Update the position based on pointer movement and stored offset\n      setPosition({\n        x: e.clientX - offset.current.x,\n        y: e.clientY - offset.current.y,\n      });\n    }\n  };\n\n  const handlePointerUp = (e) => {\n    setIsDragging(false);\n    // Release pointer capture\n    boxRef.current.releasePointerCapture(e.pointerId);\n  };\n\n  return (\n    <div\n      ref={boxRef}\n      style={{\n        position: 'absolute',\n        width: '100px',\n        height: '100px',\n        backgroundColor: 'rebeccapurple',\n        color: 'white',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        cursor: isDragging ? 'grabbing' : 'grab',\n        left: position.x + 'px',\n        top: position.y + 'px',\n        userSelect: 'none',\n        touchAction: 'none' // Prevents browser default touch actions like scrolling\n      }}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n      // onPointerLeave={isDragging ? handlePointerUp : undefined} // Optional: useful if drag ends by leaving window\n      // onPointerCancel={handlePointerUp} // Also good to handle cancel events\n    >\n      Drag Me\n    </div>\n  );\n}\n\nexport default DraggableBox;\n",
          "testCases": [
            "The box should appear on the screen.",
            "Clicking and dragging the box should move it across the screen.",
            "Releasing the click (mouse up) should stop the box from moving.",
            "The box should not 'jump' when the drag starts.",
            "Dragging outside the box's boundaries while `onPointerDown` is active should still move the box (due to `setPointerCapture`).",
            "On touch devices, the box should be draggable with a finger.",
            "Browser default touch actions (like scrolling) should be prevented on the box itself (using `touchAction: 'none'`)."
          ],
          "hints": [
            "You'll need `useState` for the box's position and drag state.",
            "A `useRef` can be useful to store the offset between the pointer's position and the element's top-left corner at the moment `onPointerDown` fires.",
            "Consider using `element.setPointerCapture()` and `element.releasePointerCapture()` to ensure consistent dragging behavior even if the pointer moves off the element.",
            "Don't forget to add `px` to your `left` and `top` style properties if they are numbers.",
            "For touch devices, consider the `touch-action: none` CSS property to prevent default browser gestures."
          ],
          "tags": [
            "React",
            "Pointer Events",
            "State",
            "Hooks",
            "Interactive UI",
            "Drag and Drop"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_hooks_useState",
            "react_hooks_useRef",
            "react_pointer_events"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "dom_manipulation",
            "event_listeners"
          ]
        },
        {
          "id": "task_toggle_visibility_component",
          "title": "Implement a Message Toggle Component (Class Component)",
          "description": "\nCreate a React **class component** called `MessageToggler` that displays a hidden message that can be toggled visible/hidden by clicking a button.\n\nRequirements:\n1.  The component should manage its visibility state internally using `this.state`.\n2.  Initially, the message should be hidden.\n3.  A button should exist that, when clicked, toggles the visibility of the message.\n4.  The button's text should change based on the message's visibility (e.g., 'Show Message' when hidden, 'Hide Message' when visible).\n5.  The message itself should be a simple paragraph element.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass MessageToggler extends React.Component {\n  // TODO: Initialize state here (e.g., isMessageVisible: false)\n\n  // TODO: Create a method to handle the button click and toggle state\n  handleToggleClick = () => {\n    // Use setState to update visibility\n  };\n\n  render() {\n    // TODO: Destructure state\n    const { /* state variable here */ } = this.state;\n\n    return (\n      <div>\n        {/* TODO: Conditionally render the message */}\n        {/* TODO: Render the button with changing text and onClick handler */}\n      </div>\n    );\n  }\n}\n\nexport default MessageToggler;\n",
          "solutionCode": "import React from 'react';\n\nclass MessageToggler extends React.Component {\n  // Initialize state using class fields syntax\n  state = {\n    isMessageVisible: false\n  };\n\n  // Method to handle the button click and toggle state\n  handleToggleClick = () => {\n    // Use the functional form of setState for toggling boolean values\n    this.setState(prevState => ({\n      isMessageVisible: !prevState.isMessageVisible\n    }));\n  };\n\n  render() {\n    const { isMessageVisible } = this.state;\n\n    return (\n      <div>\n        <button onClick={this.handleToggleClick}>\n          {isMessageVisible ? 'Hide Message' : 'Show Message'}\n        </button>\n        {isMessageVisible && (\n          <p>This is the secret message! You found it!</p>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default MessageToggler;\n",
          "testCases": [
            "Initially, the message paragraph should not be visible.",
            "The button's initial text should be 'Show Message'.",
            "Clicking the button once should make the message visible and change the button text to 'Hide Message'.",
            "Clicking the button a second time should hide the message and change the button text back to 'Show Message'.",
            "Ensure state is managed correctly within the class component using `this.state` and `this.setState()`."
          ],
          "hints": [
            "Remember to use `this.setState()` to update the component's state.",
            "For toggling a boolean state, it's often best practice to use the functional update form of `setState` to ensure you're working with the most recent state value.",
            "Conditional rendering in React can be achieved using logical `&&` or ternary operators (`? :`)."
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "setState",
            "Conditional Rendering"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "component_lifecycle",
            "event_handling"
          ]
        },
        {
          "id": "task_parent_child_communication_lifting_state",
          "title": "Implement Parent-Child Communication via Lifting State Up",
          "description": "\nCreate a React application consisting of three components: `ParentCounter`, `IncrementButton`, and `DisplayValue`. Demonstrate the 'Lifting State Up' pattern.\n\nRequirements:\n1.  `ParentCounter` should be the main component that manages a `count` state (initialized to 0).\n2.  `IncrementButton` should be a child component of `ParentCounter` that, when clicked, requests an increment of the `count`.\n3.  `DisplayValue` should be another child component of `ParentCounter` that simply displays the current `count`.\n4.  `IncrementButton` and `DisplayValue` should be 'dumb' or 'presentational' components; they should not manage their own state. All shared state logic should reside in `ParentCounter`.\n5.  Ensure proper data flow: `ParentCounter` passes `count` to `DisplayValue` and a callback to `IncrementButton`.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Child Component: Displays the count\nfunction DisplayValue({ /* TODO: props for count */ }) {\n  return <h2>Current Value: { /* TODO: display count */ }</h2>;\n}\n\n// Child Component: Button to increment the count\nfunction IncrementButton({ /* TODO: props for callback */ }) {\n  return (\n    <button onClick={ /* TODO: call increment callback */ }>\n      Increment\n    </button>\n  );\n}\n\n// Parent Component: Manages the shared count state\nfunction ParentCounter() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    // TODO: Update count state\n  };\n\n  return (\n    <div>\n      <h1>Lifting State Up Demo</h1>\n      {/* TODO: Pass count to DisplayValue */}\n      {/* TODO: Pass handleIncrement to IncrementButton */}\n    </div>\n  );\n}\n\nexport default ParentCounter;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Child Component: Displays the count\nfunction DisplayValue({ count }) {\n  return <h2>Current Value: {count}</h2>;\n}\n\n// Child Component: Button to increment the count\nfunction IncrementButton({ onIncrement }) {\n  return (\n    <button onClick={onIncrement}>\n      Increment\n    </button>\n  );\n}\n\n// Parent Component: Manages the shared count state\nfunction ParentCounter() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <h1>Lifting State Up Demo</h1>\n      <DisplayValue count={count} />\n      <IncrementButton onIncrement={handleIncrement} />\n    </div>\n  );\n}\n\nexport default ParentCounter;\n",
          "testCases": [
            "Initially, the displayed value should be 0.",
            "Clicking the 'Increment' button should increase the displayed value by 1.",
            "Verify that `DisplayValue` and `IncrementButton` do not contain `useState` or `this.state`.",
            "Ensure `ParentCounter` is the sole source of truth for the `count` state.",
            "Check that data flows down via props and updates flow up via callbacks."
          ],
          "hints": [
            "Use the `useState` hook in the `ParentCounter` for the `count` state.",
            "Pass the `count` state to `DisplayValue` as a prop.",
            "Pass the `handleIncrement` function (defined in `ParentCounter`) to `IncrementButton` as a prop. `IncrementButton` will call this prop when its button is clicked.",
            "Remember to use the functional update form of `setCount` when incrementing (`setCount(prevCount => prevCount + 1)`) to avoid stale closure issues."
          ],
          "tags": [
            "React",
            "State Management",
            "Lifting State Up",
            "Component Communication",
            "Hooks"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_useState",
            "react_props",
            "react_lifting_state_up"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "unidirectional_data_flow",
            "functional_components"
          ]
        }
      ]
    }
  },
  {
    "id": "dac5694d-d623-4dc4-8968-de83d980e021",
    "startLine": 3800,
    "endLine": 3899,
    "processedDate": "2025-06-17T08:57:45.652Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_lifting_state_up",
          "title": "Lifting State Up for Shared Data",
          "content": "When multiple components in a React application need to share and react to the same piece of state, it is a recommended practice to \"lift\" that shared state up to their closest common ancestor component. This pattern is fundamental for maintaining data consistency and simplifying state management in complex component trees.\n\n## Core Concept\n\n**Single Source of Truth:** By lifting state, you establish a single, authoritative source for that data. Instead of each child component managing its own copy of potentially conflicting state, the parent component becomes the owner of the shared state. This ensures that all components that depend on this state are always in sync.\n\n**Data Flow:** The data flows downwards from the parent (owner) component to its children via props. If a child component needs to update this shared state, it doesn't modify the state directly. Instead, the parent passes down a callback function (also via props) that the child can invoke to request a state update. The parent then executes its state update logic, which in turn causes a re-render of itself and its children, passing down the new state.\n\n## Benefits of Lifting State Up\n\n-   **Maintains a single source of truth:** Eliminates duplication and ensures data consistency.\n-   **Easier synchronization:** All related components automatically receive updates from the central state, making it simpler to keep them in sync.\n-   **Reduces bugs:** By centralizing state logic, you minimize the chances of inconsistent data and related bugs.\n-   **Simpler debugging:** State changes are centralized in one component, making it easier to trace data flow and identify the source of issues.\n-   **Improved maintainability:** The explicit data flow (props down, events up) makes the application's behavior more predictable and easier to understand.\n\n## Implementation Steps\n\n1.  **Identify Shared State:** Determine which piece of state is needed by multiple sibling components.\n2.  **Find Common Ancestor:** Locate the closest parent component that renders all components needing access to this state.\n3.  **Move State to Ancestor:** Declare the `useState` hook for the shared state in the common ancestor component.\n4.  **Pass State Down:** Pass the state value from the ancestor to its children as props.\n5.  **Pass Update Callbacks Down:** Pass a function from the ancestor (which updates the shared state) down to children as props. Children will call this function when they need to request a state change.\n6.  **Handle Updates in Parent:** The parent component's update function will receive the new data, update its state, and trigger re-renders.\n\nThis pattern encourages a unidirectional data flow, which is a core principle in React, leading to more predictable and manageable applications.",
          "examples": [
            {
              "id": "example_lifting_state_up_1",
              "title": "Temperature Converter Example",
              "code": "import React, { useState } from 'react';\n\n// Parent component holds the shared state\nfunction TemperatureCalculator() {\n  const [temperature, setTemperature] = useState('');\n  const [scale, setScale] = useState('c');\n  \n  // Conversion functions\n  const toCelsius = (fahrenheit) => {\n    if (isNaN(parseFloat(fahrenheit))) return '';\n    return ((parseFloat(fahrenheit) - 32) * 5 / 9).toFixed(2);\n  };\n  const toFahrenheit = (celsius) => {\n    if (isNaN(parseFloat(celsius))) return '';\n    return ((parseFloat(celsius) * 9 / 5) + 32).toFixed(2);\n  };\n  \n  // Handle temperature change from Celsius input\n  const handleCelsiusChange = (value) => {\n    setTemperature(value);\n    setScale('c');\n  };\n  \n  // Handle temperature change from Fahrenheit input\n  const handleFahrenheitChange = (value) => {\n    setTemperature(value);\n    setScale('f');\n  };\n  \n  // Calculate both temperatures based on current scale\n  const celsius = scale === 'f' ? toCelsius(temperature) : temperature;\n  const fahrenheit = scale === 'c' ? toFahrenheit(temperature) : temperature;\n  \n  return (\n    <div>\n      <h2>Temperature Converter</h2>\n      <TemperatureInput \n        scale=\"c\" \n        temperature={celsius}\n        onTemperatureChange={handleCelsiusChange} \n      />\n      <TemperatureInput \n        scale=\"f\" \n        temperature={fahrenheit}\n        onTemperatureChange={handleFahrenheitChange} \n      />\n      <BoilingVerdict celsius={parseFloat(celsius)} />\n    </div>\n  );\n}\n\n// Child component receives props from parent\nfunction TemperatureInput({ scale, temperature, onTemperatureChange }) {\n  const scaleNames = {\n    c: 'Celsius',\n    f: 'Fahrenheit'\n  };\n  \n  const handleChange = (e) => {\n    onTemperatureChange(e.target.value);\n  };\n  \n  return (\n    <fieldset>\n      <legend>Enter temperature in {scaleNames[scale]}:</legend>\n      <input \n        value={temperature}\n        onChange={handleChange} \n      />\n    </fieldset>\n  );\n}\n\n// Another component that uses the same state\nfunction BoilingVerdict({ celsius }) {\n  if (isNaN(celsius)) {\n    return <p>Enter a number to see boiling verdict.</p>;\n  }\n  return celsius >= 100 ?\n    <p style={{ color: 'green' }}>The water would boil.</p> :\n    <p style={{ color: 'blue' }}>The water would not boil.</p>;\n}\n\n// To render:\n// ReactDOM.render(<TemperatureCalculator />, document.getElementById('root'));",
              "explanation": "This example demonstrates how state (`temperature` and `scale`) is lifted up to the `TemperatureCalculator` component. Both `TemperatureInput` components receive the current `temperature` and `onTemperatureChange` callback from `TemperatureCalculator`. When a user types in either input, the `handleChange` function in `TemperatureInput` calls `onTemperatureChange` (which is `handleCelsiusChange` or `handleFahrenheitChange` from the parent). The parent then updates its state, re-calculates both Celsius and Fahrenheit values, and re-renders, ensuring both inputs and the `BoilingVerdict` component are always synchronized based on the single source of truth in `TemperatureCalculator`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_lifting_state_up_1",
            "question_lifting_state_up_2",
            "question_lifting_state_up_3",
            "question_lifting_state_up_4",
            "question_lifting_state_up_5",
            "question_lifting_state_up_6"
          ],
          "relatedTasks": [
            "task_lifting_state_up_1",
            "task_lifting_state_up_2"
          ],
          "tags": [
            "React",
            "State Management",
            "Component Communication",
            "Unidirectional Data Flow",
            "Best Practices"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_state_hook",
            "react_props"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_forms",
            "data_synchronization",
            "global_state_management_patterns"
          ]
        },
        {
          "id": "theory_refs",
          "title": "Refs in React: Accessing DOM Elements and React Components Imperatively",
          "content": "Refs (short for references) provide a way to access DOM nodes or React components created in the render method. In the typical React data flow, props are the primary way components interact with each other, flowing data from parent to child. However, there are scenarios where you need to imperatively modify a child, which cannot be achieved with props alone. Refs are designed for these cases.\n\n## When to Use Refs\n\nRefs are not intended for general-purpose state management or for making declarative changes to your UI. Instead, they are specifically for imperative interactions. Common use cases include:\n\n1.  **Managing Focus, Text Selection, or Media Playback:** Directly focusing an input field, selecting text, or controlling `play()`/`pause()` on video/audio elements.\n2.  **Triggering Imperative Animations:** Interacting with browser APIs or third-party animation libraries that directly manipulate the DOM.\n3.  **Integrating with Third-Party DOM Libraries:** When you need to integrate React with a non-React library that expects a DOM element to operate on (e.g., a charting library).\n\n## When NOT to Use Refs\n\n-   **Do not overuse refs:** Avoid using refs for anything that can be achieved declaratively through props and state. For example, don't use a ref to show/hide a component; use conditional rendering based on state.\n-   **Refs are not for component communication:** Don't use refs to pass data between components or trigger updates. This should be handled by props and state.\n\n## Creating Refs\n\nReact provides different ways to create and use refs depending on whether you are using class components or functional components.\n\n### In Class Components\n\nRefs are typically created using `React.createRef()` in the constructor and attached to React elements via the `ref` attribute. The ref's `current` property will hold the underlying DOM element or the instance of the React component after it has mounted.\n\n### In Functional Components (with Hooks)\n\nFor functional components, the `useRef` Hook is used. `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. It's similar to `createRef`, but `useRef` is specifically designed for functional components.\n\n### Forwarding Refs\n\nBy default, you cannot attach a `ref` directly to a custom functional component and expect to get a reference to its internal DOM node. This is because functional components are typically stateless and don't expose their internal DOM structure directly. To allow a parent component to get a ref to a DOM node *inside* a child functional component, you use `React.forwardRef`. This Higher-Order Component allows you to pass the `ref` prop down to an underlying DOM element or another component.\n\n",
          "examples": [
            {
              "id": "example_refs_1",
              "title": "Using `createRef` in Class Components",
              "code": "import React from 'react';\n\nclass MyForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.textInput = React.createRef(); // Create a ref\n  }\n\n  focusTextInput = () => {\n    // Use the DOM API to focus the input\n    this.textInput.current.focus();\n  };\n\n  render() {\n    return (\n      <div>\n        <input\n          type=\"text\"\n          ref={this.textInput} // Attach the ref to the input element\n        />\n        <button onClick={this.focusTextInput}>\n          Focus the text input\n        </button>\n      </div>\n    );\n  }\n}\n// To render:\n// ReactDOM.render(<MyForm />, document.getElementById('root'));",
              "explanation": "In this class component, `this.textInput` is created using `React.createRef()` in the constructor. It's then attached to the `<input>` element via the `ref` prop. When the component mounts, `this.textInput.current` will point to the actual DOM input element, allowing us to call DOM methods like `focus()` on it.",
              "language": "typescript"
            },
            {
              "id": "example_refs_2",
              "title": "Using `useRef` in Functional Components",
              "code": "import React, { useRef } from 'react';\n\nfunction MyFunctionalForm() {\n  const textInput = useRef(null); // Create a ref using useRef hook\n\n  const focusTextInput = () => {\n    // Use the DOM API to focus the input\n    textInput.current.focus();\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        ref={textInput} // Attach the ref to the input element\n      />\n      <button onClick={focusTextInput}>\n        Focus the text input\n      </button>\n    </div>\n  );\n}\n// To render:\n// ReactDOM.render(<MyFunctionalForm />, document.getElementById('root'));",
              "explanation": "This example shows the equivalent functionality using a functional component and the `useRef` hook. `useRef(null)` initializes the ref. The `textInput.current` property will hold the DOM input element after rendering. The `focusTextInput` function then accesses `textInput.current` to call the `focus()` method. `useRef` is preferred in functional components.",
              "language": "typescript"
            },
            {
              "id": "example_refs_3",
              "title": "Using `forwardRef` to Pass Refs",
              "code": "import React, { useRef, forwardRef } from 'react';\n\n// Child functional component that forwards the ref to its input\nconst CustomInput = forwardRef((props, ref) => (\n  <div>\n    <label>{props.label}: </label>\n    <input type=\"text\" ref={ref} {...props} />\n  </div>\n));\n\n// Parent component that uses CustomInput and wants to focus its internal input\nfunction ParentComponent() {\n  const inputRef = useRef(null);\n\n  const handleClick = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <div>\n      <CustomInput label=\"Your Name\" ref={inputRef} />\n      <button onClick={handleClick}>Focus Name Input</button>\n    </div>\n  );\n}\n// To render:\n// ReactDOM.render(<ParentComponent />, document.getElementById('root'));",
              "explanation": "Here, `CustomInput` is a functional component wrapped with `forwardRef`. This allows `ParentComponent` to pass `inputRef` directly to `CustomInput`, and `CustomInput` explicitly attaches it to its internal `<input>` element. When the button is clicked, `inputRef.current.focus()` successfully focuses the input inside `CustomInput`, demonstrating how refs can be passed through components.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_refs_1",
            "question_refs_2",
            "question_refs_3",
            "question_refs_4",
            "question_refs_5",
            "question_refs_6"
          ],
          "relatedTasks": [
            "task_refs_1",
            "task_refs_2",
            "task_refs_3"
          ],
          "tags": [
            "React",
            "Refs",
            "DOM Manipulation",
            "Imperative Programming",
            "Hooks",
            "forwardRef",
            "useRef"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_class_components",
            "react_hooks_overview",
            "react_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "integrating_third_party_libs",
            "advanced_dom_manipulation",
            "media_controls"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lifting_state_up_1",
          "topic": "Lifting State Up - Core Concept",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary motivation for 'lifting state up' in React applications?",
          "answer": "To establish a single source of truth for shared data.",
          "options": [
            "To reduce the total amount of state in an application.",
            "To make components completely independent of each other.",
            "To establish a single source of truth for shared data.",
            "To allow child components to directly modify parent state."
          ],
          "analysisPoints": [
            "Lifting state centralizes shared data, making it consistent.",
            "It doesn't necessarily reduce the total state, but rather organizes it.",
            "Components become interdependent through shared state, not independent.",
            "Children do not directly modify parent state; they call callbacks provided by the parent."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Single Source of Truth",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles of state management in React."
          ],
          "example": "The core idea behind lifting state up is to ensure that when multiple components need to react to changes in the same data, there's only one place where that data lives. This prevents inconsistencies and simplifies debugging.",
          "tags": [
            "React State",
            "Component Communication",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_state_hook",
            "react_props"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifting_state_up_2",
          "topic": "Lifting State Up - Implementation",
          "level": "medium",
          "type": "code",
          "question": "Consider a `CounterDisplay` component that simply shows a number and `IncrementButton` that increases a counter. Refactor the following code to lift the `count` state to a common parent component `App`, ensuring both components reflect the same count value.",
          "answer": "```typescript\nimport React, { useState } from 'react';\n\nfunction CounterDisplay({ count }) {\n  return <h2>Current Count: {count}</h2>;\n}\n\nfunction IncrementButton({ onIncrement }) {\n  return (\n    <button onClick={onIncrement}>Increment</button>\n  );\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <h1>Shared Counter</h1>\n      <CounterDisplay count={count} />\n      <IncrementButton onIncrement={handleIncrement} />\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "The `count` state is moved from `CounterDisplay` (or `IncrementButton` if it were there) to `App`.",
            "The `count` value is passed down to `CounterDisplay` as a prop.",
            "A function `handleIncrement` (which updates `count` in `App`) is passed down to `IncrementButton` as a prop (`onIncrement`).",
            "The `IncrementButton` calls the `onIncrement` callback, triggering the state update in `App`."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Props",
            "Callbacks",
            "Unidirectional Data Flow"
          ],
          "evaluationCriteria": [
            "Correctly identifies the common ancestor.",
            "Moves state to the ancestor.",
            "Passes state and update functions as props.",
            "Ensures correct data flow (props down, events up)."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\n// Initial (incorrect) setup:\n// function CounterDisplay() {\n//   const [count, setCount] = useState(0);\n//   return <h2>Current Count: {count}</h2>;\n// }\n// function IncrementButton() {\n//   // How to update count in CounterDisplay from here?\n//   return <button>Increment</button>;\n// }\n// function App() {\n//   return (\n//     <div>\n//       <CounterDisplay />\n//       <IncrementButton />\n//     </div>\n//   );\n// }\n\n// Corrected (lifted state) solution:\nfunction CounterDisplay({ count }) {\n  return <h2>Current Count: {count}</h2>;\n}\n\nfunction IncrementButton({ onIncrement }) {\n  return (\n    <button onClick={onIncrement}>Increment</button>\n  );\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <h1>Shared Counter</h1>\n      <CounterDisplay count={count} />\n      <IncrementButton onIncrement={handleIncrement} />\n    </div>\n  );\n}\n```",
          "tags": [
            "React Code",
            "State Management",
            "Refactoring",
            "Hooks"
          ],
          "prerequisites": [
            "react_state_hook",
            "react_props"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifting_state_up_3",
          "topic": "Lifting State Up - Benefits",
          "level": "medium",
          "type": "open",
          "question": "Besides 'maintaining a single source of truth', describe two other significant benefits of lifting state up in a React application. Provide a brief explanation for each.",
          "answer": "1.  **Easier Synchronization:** When state is lifted, all child components that depend on that state receive updates directly from the parent component. This makes it inherently easier to keep the UI consistent across multiple components, as they are all rendering based on the same, updated data. Without lifted state, each component might manage its own version, leading to potential discrepancies.\n2.  **Reduced Bugs & Simpler Debugging:** By centralizing state management logic in one place (the common ancestor), you minimize the chances of inconsistencies and related bugs. If an issue arises with the shared data, you know exactly where to look – the parent component that owns the state. This makes debugging significantly more straightforward than trying to trace state across multiple, independently managed components.",
          "options": [],
          "analysisPoints": [
            "Ability to articulate benefits beyond the primary one.",
            "Clarity and conciseness of explanations.",
            "Understanding of practical implications (e.g., consistency, debugging)."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Synchronization",
            "Debugging",
            "Bug Reduction"
          ],
          "evaluationCriteria": [
            "Comprehension of the pattern's advantages.",
            "Ability to explain concepts clearly.",
            "Demonstrates practical understanding."
          ],
          "example": "An example demonstrating 'Easier Synchronization' is the temperature calculator: without lifting state, if Celsius input updated its own state and Fahrenheit input updated its own, they would quickly fall out of sync. By lifting the state, typing in one input immediately updates the other, maintaining synchronization. 'Simpler Debugging' is evident because if the temperature calculation or display is wrong, the developer knows to check the `TemperatureCalculator` component where the state and logic reside, rather than searching through multiple independent components.",
          "tags": [
            "React State",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "react_state_management"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifting_state_up_4",
          "topic": "Lifting State Up - Flashcard",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the term for a common pattern where shared state is moved to a common ancestor component in React?",
          "answer": "Lifting State Up",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Lifting State Up"
          ],
          "evaluationCriteria": [
            "Recall of fundamental React terminology."
          ],
          "example": "",
          "tags": [
            "React Terminology",
            "State Management"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifting_state_up_5",
          "topic": "Lifting State Up - Trade-offs",
          "level": "hard",
          "type": "open",
          "question": "While beneficial, lifting state up can sometimes lead to 'prop drilling'. Explain what prop drilling is and suggest one alternative pattern or technology in React that aims to mitigate it.",
          "answer": "**Prop Drilling (or Threading)**: Prop drilling refers to the situation where a piece of data (state) needs to be passed down through several layers of intermediary components that don't actually need the data themselves, just to get it to a deeply nested child component that does. This can make the code harder to read, maintain, and refactor because changes to the data structure or requirements necessitate modifying many intermediary components.\n\n**Alternative Mitigation (Context API):** React's Context API is a common solution to prop drilling. It provides a way to pass data through the component tree without having to pass props down manually at every level. You define a Context Provider higher up in the tree which holds the data, and any component nested deeper in the tree can consume this context using `useContext` (for functional components) or `Context.Consumer` (for class components), without needing props from intermediate components. This is ideal for 'global' data like theme, user authentication, or preferences that many components might need.",
          "options": [],
          "analysisPoints": [
            "Accurate definition of prop drilling.",
            "Identification of a valid alternative (e.g., Context API, Redux, Zustand).",
            "Clear explanation of how the alternative mitigates prop drilling.",
            "Understanding of the trade-offs of lifting state up in large applications."
          ],
          "keyConcepts": [
            "Prop Drilling",
            "React Context API",
            "State Management",
            "Scalability"
          ],
          "evaluationCriteria": [
            "In-depth understanding of React state patterns and their limitations.",
            "Knowledge of advanced React features or common state management libraries.",
            "Ability to analyze and propose solutions for architectural challenges."
          ],
          "example": "Imagine a user's `theme` (dark/light) stored in `App` component. If a component `Button` is nested several layers deep (`App -> Layout -> Header -> Navigation -> Button`), and `Button` needs the theme, `theme` would have to be passed as a prop through `Layout`, `Header`, and `Navigation` (which don't use `theme` themselves). This is prop drilling. Using `Context API`, `App` provides the theme context, and `Button` can directly consume it without `Layout`, `Header`, or `Navigation` needing to know about it.",
          "tags": [
            "React State",
            "Advanced React",
            "Context API",
            "Architecture"
          ],
          "prerequisites": [
            "react_context_api"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifting_state_up_6",
          "topic": "Lifting State Up - Unidirectional Data Flow",
          "level": "medium",
          "type": "mcq",
          "question": "Which principle does 'lifting state up' reinforce in React's data flow?",
          "answer": "Unidirectional data flow",
          "options": [
            "Bidirectional data binding",
            "Component reusability",
            "Unidirectional data flow",
            "Direct DOM manipulation"
          ],
          "analysisPoints": [
            "Lifting state ensures data flows from parent to child (downwards) via props, and updates are requested upwards via callbacks, which is the definition of unidirectional data flow.",
            "React primarily advocates for unidirectional flow, unlike some other frameworks that support bidirectional binding.",
            "While it can enable reusability, it's not the core principle reinforced.",
            "It's about managing state, not directly manipulating the DOM (unless it's an escape hatch like refs)."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Unidirectional Data Flow",
            "React Principles"
          ],
          "evaluationCriteria": [
            "Understanding of core React architectural principles."
          ],
          "example": "In the temperature converter example, the `temperature` flows down from `TemperatureCalculator` to `TemperatureInput` and `BoilingVerdict`. When `TemperatureInput` wants to change the temperature, it doesn't directly modify the state; it calls a function (`onTemperatureChange`) that was passed down from the parent, allowing the parent to control the update. This explicit, one-way flow makes the application more predictable.",
          "tags": [
            "React Architecture",
            "Data Flow",
            "Principles"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_1",
          "topic": "Refs - Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of `Refs` in React?",
          "answer": "To provide a way to access DOM nodes or React components created in the render method.",
          "options": [
            "To manage component state declaratively.",
            "To provide a way to access DOM nodes or React components created in the render method.",
            "To facilitate component-to-component communication for shared data.",
            "To replace the need for props in data passing."
          ],
          "analysisPoints": [
            "Refs are an escape hatch for imperative interactions, not for declarative state.",
            "Refs allow direct access to underlying DOM or component instances.",
            "Component communication is primarily via props and state, not refs.",
            "Refs complement props; they don't replace them."
          ],
          "keyConcepts": [
            "Refs",
            "DOM Access",
            "Imperative Programming"
          ],
          "evaluationCriteria": [
            "Understanding the core function of refs."
          ],
          "example": "```typescript\nimport React, { useRef, useEffect } from 'react';\n\nfunction MyInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // Directly access the DOM node to focus it after mount\n    inputRef.current.focus();\n  }, []);\n\n  return <input type=\"text\" ref={inputRef} />;\n}\n```\nThis example shows `inputRef.current.focus()` directly manipulating the DOM node to set focus, which is a classic use case for refs.",
          "tags": [
            "React Refs",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_refs_2",
          "topic": "Refs - Use Cases",
          "level": "medium",
          "type": "open",
          "question": "List at least three specific use cases where using `Refs` is appropriate in React, as opposed to relying solely on state and props.",
          "answer": "1.  **Managing Focus, Text Selection, or Media Playback:** For example, programmatically setting focus on an input field when a component mounts, selecting all text in a textbox, or controlling a `<video>` or `<audio>` element (play, pause, volume).\n2.  **Triggering Imperative Animations:** When integrating with animation libraries that directly manipulate the DOM (e.g., GreenSock (GSAP)) or performing low-level DOM animations that are not easily managed through React's declarative state.\n3.  **Integrating with Third-Party DOM Libraries:** When you need to interact with external JavaScript libraries (like charting libraries, map libraries, or advanced UI widgets) that expect a direct DOM element reference to initialize or operate upon.",
          "options": [],
          "analysisPoints": [
            "Ability to recall specific, appropriate use cases for refs.",
            "Distinction between imperative ref usage and declarative state/prop management.",
            "Clarity and conciseness of examples."
          ],
          "keyConcepts": [
            "Refs Use Cases",
            "Imperative Programming",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Knowledge of practical scenarios for ref usage.",
            "Understanding of React's architectural philosophy."
          ],
          "example": "",
          "tags": [
            "React Refs",
            "Best Practices",
            "DOM"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_3",
          "topic": "Refs - `useRef` vs `createRef`",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements correctly describes the difference between `React.createRef()` and `useRef()` in React?",
          "answer": "`React.createRef()` is used in class components, while `useRef()` is a Hook used in functional components.",
          "options": [
            "`React.createRef()` is for DOM elements, while `useRef()` is for React components.",
            "`React.createRef()` is used for mutable values, while `useRef()` is for immutable values.",
            "`React.createRef()` causes a re-render when its value changes, while `useRef()` does not.",
            "`React.createRef()` is used in class components, while `useRef()` is a Hook used in functional components."
          ],
          "analysisPoints": [
            "The primary distinction is their usage context: `createRef` for classes, `useRef` for hooks/functional components.",
            "Both can refer to DOM elements or component instances.",
            "Both `current` properties are mutable.",
            "Neither `createRef` nor `useRef` directly cause re-renders when their `current` property changes. Re-renders are triggered by state or prop changes."
          ],
          "keyConcepts": [
            "Refs",
            "Hooks",
            "Class Components",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Understanding of ref creation mechanisms in different component types.",
            "Knowledge of React Hooks principles."
          ],
          "example": "```typescript\n// Class component using createRef\nclass MyClassComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n  render() {\n    return <div ref={this.myRef} />; // this.myRef.current will be the div\n  }\n}\n\n// Functional component using useRef\nfunction MyFunctionalComponent() {\n  const myRef = useRef(null);\n  return <div ref={myRef} />; // myRef.current will be the div\n}\n```",
          "tags": [
            "React Hooks",
            "Class Components",
            "Functional Components",
            "Refs"
          ],
          "prerequisites": [
            "react_class_components",
            "react_functional_components",
            "react_hooks_overview"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_4",
          "topic": "Refs - `forwardRef`",
          "level": "hard",
          "type": "code",
          "question": "You have a `CustomButton` functional component that renders a native `<button>` element. How would you modify `CustomButton` so that a parent component can obtain a ref to the *native button DOM element* inside `CustomButton`?",
          "answer": "```typescript\nimport React, { forwardRef } from 'react';\n\n// CustomButton now accepts a ref prop and forwards it to the native button.\nconst CustomButton = forwardRef(({ children, ...props }, ref) => (\n  <button ref={ref} {...props}>\n    {children}\n  </button>\n));\n\n// Parent component using CustomButton\nfunction ParentComponent() {\n  const buttonRef = React.useRef(null);\n\n  const handleClick = () => {\n    if (buttonRef.current) {\n      buttonRef.current.focus(); // Example: Focusing the button\n      console.log('Button clicked:', buttonRef.current.textContent);\n    }\n  };\n\n  return (\n    <div>\n      <CustomButton ref={buttonRef} onClick={handleClick}>\n        Click Me to Focus\n      </CustomButton>\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "The solution correctly uses `React.forwardRef`.",
            "The `forwardRef` HOC passes `props` and `ref` as arguments to the functional component.",
            "The `ref` argument is then attached to the internal native DOM element (`<button>`).",
            "The parent component correctly uses `useRef` and passes the ref to the `CustomButton`."
          ],
          "keyConcepts": [
            "Refs",
            "forwardRef",
            "Functional Components",
            "DOM Access",
            "Higher-Order Components"
          ],
          "evaluationCriteria": [
            "Correct application of `forwardRef`.",
            "Understanding of ref propagation in functional components.",
            "Ability to solve common ref-related challenges."
          ],
          "example": "```typescript\n// Original CustomButton (does not forward ref)\n// function CustomButton({ children, onClick }) {\n//   return <button onClick={onClick}>{children}</button>;\n// }\n\n// Parent attempting to use ref (would fail):\n// function ParentComponent() {\n//   const btnRef = useRef(null);\n//   useEffect(() => {\n//     console.log(btnRef.current); // This would be null because ref isn't forwarded\n//   }, []);\n//   return <CustomButton ref={btnRef}>Test</CustomButton>;\n// }\n\n// Corrected with forwardRef:\nimport React, { useRef, forwardRef } from 'react';\n\nconst CustomButton = forwardRef(({ children, ...props }, ref) => (\n  <button ref={ref} {...props}>\n    {children}\n  </button>\n));\n\nfunction ParentComponent() {\n  const buttonRef = useRef(null);\n\n  const handleClick = () => {\n    if (buttonRef.current) {\n      buttonRef.current.focus(); // Works now!\n      alert('Button Focused!');\n    }\n  };\n\n  return (\n    <div>\n      <CustomButton ref={buttonRef} onClick={handleClick}>\n        Focus Button\n      </CustomButton>\n    </div>\n  );\n}\n```",
          "tags": [
            "React Code",
            "Refs",
            "forwardRef",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_overview",
            "react_functional_components"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_refs_5",
          "topic": "Refs - When NOT to Use",
          "level": "medium",
          "type": "flashcard",
          "question": "True or False: It is generally a good practice to use refs to manage whether a component is visible or hidden.",
          "answer": "False",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Refs Best Practices",
            "Declarative UI",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of when refs are inappropriate."
          ],
          "example": "Managing visibility should be done using state and conditional rendering (e.g., `isVisible ? <Component /> : null`) or CSS classes based on state, not by directly manipulating DOM visibility via refs.",
          "tags": [
            "React Refs",
            "Best Practices"
          ],
          "prerequisites": [
            "react_conditional_rendering"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_6",
          "topic": "Refs - `current` Property",
          "level": "easy",
          "type": "mcq",
          "question": "After attaching a ref object (`myRef = useRef(null)`) to an element `<input ref={myRef} />`, what does `myRef.current` refer to after the component mounts?",
          "answer": "The actual DOM node of the input element.",
          "options": [
            "The React component instance of the input.",
            "The props object passed to the input.",
            "The actual DOM node of the input element.",
            "The initial value passed to `useRef`."
          ],
          "analysisPoints": [
            "When a ref is attached to a native HTML element (like `input`, `div`, `button`), `myRef.current` will be the corresponding DOM element.",
            "If attached to a class component, `myRef.current` would be the instance of that component.",
            "It never refers to the props or the initial value of `useRef` (though the initial value is what `current` holds *before* being attached)."
          ],
          "keyConcepts": [
            "Refs",
            "useRef",
            "DOM Access",
            "current property"
          ],
          "evaluationCriteria": [
            "Understanding how refs provide access to elements."
          ],
          "example": "```typescript\nimport React, { useRef, useEffect } from 'react';\n\nfunction DOMAccessExample() {\n  const myInputRef = useRef(null);\n\n  useEffect(() => {\n    if (myInputRef.current) {\n      console.log(myInputRef.current); // Logs the <input> DOM element\n      myInputRef.current.value = 'Hello Ref!';\n    }\n  }, []);\n\n  return <input type=\"text\" ref={myInputRef} />;\n}\n```",
          "tags": [
            "React Refs",
            "DOM",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_overview"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_lifting_state_up_1",
          "title": "Build a Color Picker with Shared Display",
          "description": "\nImplement a React application where multiple `ColorInput` components allow users to select a color, and a `ColorDisplay` component shows the currently selected color.\n\n**Requirements:**\n1.  Create a parent component (e.g., `App` or `ColorPickerContainer`) to manage the shared `selectedColor` state.\n2.  Create a `ColorInput` functional component that takes a `colorName` (e.g., 'Red', 'Green', 'Blue') and an `onColorSelect` callback as props. When clicked, it should call `onColorSelect` with its `colorName`.\n3.  Create a `ColorDisplay` functional component that takes `color` as a prop and renders a `div` with its background color set to the `color` prop and displays the color name.\n4.  The `ColorPickerContainer` should render at least three `ColorInput` components (e.g., for Red, Green, Blue) and one `ColorDisplay` component.\n5.  Clicking any `ColorInput` should update the `ColorDisplay` to show the chosen color.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Parent component to manage shared state\nfunction ColorPickerContainer() {\n  // TODO: Implement shared state for selectedColor\n  // TODO: Implement handler to update selectedColor\n\n  return (\n    <div>\n      <h1>Color Picker</h1>\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>\n        {/* TODO: Render ColorInput components */}\n        {/* Example: <ColorInput colorName=\"Red\" onColorSelect={handleColorSelect} /> */}\n      </div>\n      {/* TODO: Render ColorDisplay component */}\n    </div>\n  );\n}\n\n// Child component: ColorInput\nfunction ColorInput({ colorName, onColorSelect }) {\n  return (\n    <button \n      style={{\n        padding: '10px 20px',\n        backgroundColor: colorName,\n        color: 'white',\n        border: 'none',\n        borderRadius: '5px',\n        cursor: 'pointer'\n      }}\n      onClick={() => onColorSelect(colorName)}\n    >\n      {colorName}\n    </button>\n  );\n}\n\n// Child component: ColorDisplay\nfunction ColorDisplay({ color }) {\n  return (\n    <div \n      style={{\n        width: '200px',\n        height: '100px',\n        backgroundColor: color || 'lightgray',\n        border: '1px solid black',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        color: color ? (['red', 'green', 'blue'].includes(color.toLowerCase()) ? 'white' : 'black') : 'black',\n        fontWeight: 'bold'\n      }}\n    >\n      {color ? `Selected: ${color}` : 'No Color Selected'}\n    </div>\n  );\n}\n\n// To render the application:\n// ReactDOM.render(<ColorPickerContainer />, document.getElementById('root'));",
          "solutionCode": "import React, { useState } from 'react';\n\n// Parent component to manage shared state\nfunction ColorPickerContainer() {\n  const [selectedColor, setSelectedColor] = useState('');\n\n  const handleColorSelect = (color) => {\n    setSelectedColor(color);\n  };\n\n  return (\n    <div>\n      <h1>Color Picker</h1>\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>\n        <ColorInput colorName=\"Red\" onColorSelect={handleColorSelect} />\n        <ColorInput colorName=\"Green\" onColorSelect={handleColorSelect} />\n        <ColorInput colorName=\"Blue\" onColorSelect={handleColorSelect} />\n        <ColorInput colorName=\"Yellow\" onColorSelect={handleColorSelect} />\n      </div>\n      <ColorDisplay color={selectedColor} />\n    </div>\n  );\n}\n\n// Child component: ColorInput\nfunction ColorInput({ colorName, onColorSelect }) {\n  return (\n    <button \n      style={{\n        padding: '10px 20px',\n        backgroundColor: colorName,\n        color: colorName.toLowerCase() === 'yellow' ? 'black' : 'white',\n        border: 'none',\n        borderRadius: '5px',\n        cursor: 'pointer'\n      }}\n      onClick={() => onColorSelect(colorName)}\n    >\n      {colorName}\n    </button>\n  );\n}\n\n// Child component: ColorDisplay\nfunction ColorDisplay({ color }) {\n  return (\n    <div \n      style={{\n        width: '200px',\n        height: '100px',\n        backgroundColor: color || 'lightgray',\n        border: '1px solid black',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        color: color ? (['red', 'green', 'blue'].includes(color.toLowerCase()) ? 'white' : 'black') : 'black',\n        fontWeight: 'bold'\n      }}\n    >\n      {color ? `Selected: ${color}` : 'No Color Selected'}\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: ColorDisplay should show 'No Color Selected' and have a lightgray background.",
            "Click 'Red' button: ColorDisplay should show 'Selected: Red' and have a red background.",
            "Click 'Green' button: ColorDisplay should show 'Selected: Green' and have a green background.",
            "Click 'Blue' button: ColorDisplay should show 'Selected: Blue' and have a blue background.",
            "Verify all `ColorInput` components are rendered and interactive."
          ],
          "hints": [
            "Remember to use `useState` in the parent for the `selectedColor`.",
            "The parent will need a function to update `selectedColor` that it passes down to `ColorInput` components.",
            "The `ColorDisplay` component simply receives the `selectedColor` as a prop."
          ],
          "tags": [
            "React",
            "State Management",
            "Lifting State Up",
            "Component Communication",
            "Hooks"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_state_hook",
            "react_props"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "unidirectional_data_flow",
            "single_source_of_truth"
          ]
        },
        {
          "id": "task_lifting_state_up_2",
          "title": "Implement a Shopping Cart Item Quantity Adjuster",
          "description": "\nCreate a simplified shopping cart item quantity adjuster where multiple displays for the same product need to show the same quantity.\n\n**Requirements:**\n1.  Create a `ProductItem` component that represents a single product in the cart. This component should display the product name and its quantity. It should also have 'Add' and 'Remove' buttons.\n2.  The `quantity` state should *not* be held within `ProductItem` directly. Instead, lift it up to a common parent component (e.g., `ShoppingCart`).\n3.  `ShoppingCart` should manage a map/object of product quantities (e.g., `{ 'Product A': 2, 'Product B': 1 }`).\n4.  `ProductItem` will receive `productName`, `quantity`, and `onQuantityChange` callback as props.\n5.  When 'Add' or 'Remove' is clicked in any `ProductItem`, the `ShoppingCart`'s state should be updated, and all relevant `ProductItem` components should reflect the new quantity.\n6.  Ensure the quantity cannot go below 0.\n7.  Add a `TotalItems` component that displays the sum of all quantities of all products.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\n// Parent component: ShoppingCart\nfunction ShoppingCart() {\n  // TODO: Manage product quantities here using useState\n  // Example: { 'Laptop': 1, 'Mouse': 2 }\n\n  const handleQuantityChange = (productName, change) => {\n    // TODO: Update the quantity for the given product\n  };\n\n  // TODO: Calculate total items\n  const totalItems = 0; \n\n  return (\n    <div>\n      <h1>Your Shopping Cart</h1>\n      {/* TODO: Render ProductItem components for different products */}\n      {/* Example: <ProductItem productName=\"Laptop\" quantity={quantities['Laptop']} onQuantityChange={handleQuantityChange} /> */}\n      <TotalItems total={totalItems} />\n    </div>\n  );\n}\n\n// Child component: ProductItem\nfunction ProductItem({ productName, quantity, onQuantityChange }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n      <span>{productName}</span>\n      <div>\n        <button onClick={() => onQuantityChange(productName, -1)} disabled={quantity <= 0}>-</button>\n        <span style={{ margin: '0 10px' }}>{quantity}</span>\n        <button onClick={() => onQuantityChange(productName, 1)}>+</button>\n      </div>\n    </div>\n  );\n}\n\n// Another child component: TotalItems\nfunction TotalItems({ total }) {\n  return (\n    <h3 style={{ marginTop: '20px', borderTop: '1px solid #eee', paddingTop: '10px' }}>Total Items in Cart: {total}</h3>\n  );\n}\n\n// To render:\n// ReactDOM.render(<ShoppingCart />, document.getElementById('root'));",
          "solutionCode": "import React, { useState } from 'react';\n\n// Parent component: ShoppingCart\nfunction ShoppingCart() {\n  const [quantities, setQuantities] = useState({\n    'Laptop': 1,\n    'Mouse': 2,\n    'Keyboard': 0\n  });\n\n  const handleQuantityChange = (productName, change) => {\n    setQuantities(prevQuantities => {\n      const newQuantity = Math.max(0, prevQuantities[productName] + change);\n      return {\n        ...prevQuantities,\n        [productName]: newQuantity\n      };\n    });\n  };\n\n  const totalItems = Object.values(quantities).reduce((sum, qty) => sum + qty, 0);\n\n  return (\n    <div>\n      <h1>Your Shopping Cart</h1>\n      <ProductItem \n        productName=\"Laptop\" \n        quantity={quantities['Laptop']} \n        onQuantityChange={handleQuantityChange} \n      />\n      <ProductItem \n        productName=\"Mouse\" \n        quantity={quantities['Mouse']} \n        onQuantityChange={handleQuantityChange} \n      />\n      <ProductItem \n        productName=\"Keyboard\" \n        quantity={quantities['Keyboard']} \n        onQuantityChange={handleQuantityChange} \n      />\n      <TotalItems total={totalItems} />\n    </div>\n  );\n}\n\n// Child component: ProductItem\nfunction ProductItem({ productName, quantity, onQuantityChange }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n      <span>{productName}</span>\n      <div>\n        <button onClick={() => onQuantityChange(productName, -1)} disabled={quantity <= 0}>-</button>\n        <span style={{ margin: '0 10px' }}>{quantity}</span>\n        <button onClick={() => onQuantityChange(productName, 1)}>+</button>\n      </div>\n    </div>\n  );\n}\n\n// Another child component: TotalItems\nfunction TotalItems({ total }) {\n  return (\n    <h3 style={{ marginTop: '20px', borderTop: '1px solid #eee', paddingTop: '10px' }}>Total Items in Cart: {total}</h3>\n  );\n}\n",
          "testCases": [
            "Initial render: 'Laptop' quantity 1, 'Mouse' quantity 2, 'Keyboard' quantity 0. Total Items: 3.",
            "Click '+' for 'Laptop': 'Laptop' quantity should become 2. Total Items should become 4.",
            "Click '-' for 'Mouse': 'Mouse' quantity should become 1. Total Items should become 3.",
            "Click '-' for 'Keyboard' (initially 0): 'Keyboard' quantity should remain 0, and the '-' button should be disabled.",
            "Repeatedly click '-' for 'Laptop' until quantity is 0: Quantity should not go below 0, and '-' button should disable."
          ],
          "hints": [
            "The `useState` in `ShoppingCart` should hold an object where keys are product names and values are quantities.",
            "When updating the `quantities` state, remember to create a new object using the spread operator (`...prevQuantities`) to ensure immutability.",
            "The `reduce` method is useful for calculating the `totalItems` from the `quantities` object values."
          ],
          "tags": [
            "React",
            "State Management",
            "Lifting State Up",
            "Complex State",
            "Functional Programming"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_state_hook",
            "react_props",
            "javascript_object_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "unidirectional_data_flow",
            "immutable_updates"
          ]
        },
        {
          "id": "task_refs_1",
          "title": "Implement an Auto-Focusing Input Field",
          "description": "\nCreate a React component that renders an input field and automatically focuses on it when the component mounts.\n\n**Requirements:**\n1.  Use a functional component.\n2.  Utilize the `useRef` hook to get a reference to the input DOM element.\n3.  Use the `useEffect` hook to trigger the focus action after the component has rendered for the first time.\n4.  Ensure that the input is truly focused (e.g., you can immediately start typing).\n",
          "difficulty": "easy",
          "startingCode": "import React, { useRef, useEffect } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // TODO: Use inputRef to focus the input element\n  }, []); // Empty dependency array means it runs once after initial render\n\n  return (\n    <div>\n      <label>Your Name:</label>\n      <input type=\"text\" ref={inputRef} />\n    </div>\n  );\n}\n\n// To render:\n// ReactDOM.render(<AutoFocusInput />, document.getElementById('root'));",
          "solutionCode": "import React, { useRef, useEffect } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []);\n\n  return (\n    <div>\n      <h2>Auto-Focus Input</h2>\n      <label>Your Name:</label>\n      <input type=\"text\" ref={inputRef} placeholder=\"Type here...\"/>\n    </div>\n  );\n}\n",
          "testCases": [
            "Component mounts: The input field should immediately gain focus.",
            "Verify you can type into the input without manually clicking on it after the page loads."
          ],
          "hints": [
            "The `useRef` hook returns an object with a `current` property that holds the DOM element.",
            "The `focus()` method is a standard DOM API method available on input elements.",
            "An empty dependency array `[]` in `useEffect` ensures the effect runs only once after the initial render, similar to `componentDidMount`."
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "useEffect",
            "DOM Manipulation"
          ],
          "timeEstimate": 15,
          "prerequisites": [
            "react_hooks_overview",
            "react_functional_components"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "imperative_programming"
          ]
        },
        {
          "id": "task_refs_2",
          "title": "Implement a Basic Video Player Controls",
          "description": "\nCreate a simple video player component with play and pause buttons using React refs to control the `<video>` element.\n\n**Requirements:**\n1.  Create a functional component `VideoPlayer`.\n2.  Inside `VideoPlayer`, render a `<video>` element (you can use a placeholder video URL or a local one). Give it `controls={false}` so you manage playback programmatically.\n3.  Use `useRef` to get a reference to the `<video>` DOM element.\n4.  Implement two buttons: 'Play' and 'Pause'.\n5.  When the 'Play' button is clicked, call the `play()` method on the video element via its ref.\n6.  When the 'Pause' button is clicked, call the `pause()` method on the video element via its ref.\n7.  Add a `src` attribute to the video tag, you can use `http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4` for testing.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef(null);\n\n  const handlePlay = () => {\n    // TODO: Implement play logic using videoRef\n  };\n\n  const handlePause = () => {\n    // TODO: Implement pause logic using videoRef\n  };\n\n  return (\n    <div>\n      <h2>My Custom Video Player</h2>\n      <video \n        ref={videoRef}\n        width=\"640\" \n        height=\"360\" \n        controls={false}\n        src=\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n      >\n        Your browser does not support the video tag.\n      </video>\n      <div style={{ marginTop: '10px' }}>\n        <button onClick={handlePlay} style={{ marginRight: '10px' }}>Play</button>\n        <button onClick={handlePause}>Pause</button>\n      </div>\n    </div>\n  );\n}\n\n// To render:\n// ReactDOM.render(<VideoPlayer />, document.getElementById('root'));",
          "solutionCode": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef(null);\n\n  const handlePlay = () => {\n    if (videoRef.current) {\n      videoRef.current.play();\n    }\n  };\n\n  const handlePause = () => {\n    if (videoRef.current) {\n      videoRef.current.pause();\n    }\n  };\n\n  return (\n    <div>\n      <h2>My Custom Video Player</h2>\n      <video \n        ref={videoRef}\n        width=\"640\" \n        height=\"360\" \n        controls={false}\n        src=\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n      >\n        Your browser does not support the video tag.\n      </video>\n      <div style={{ marginTop: '10px' }}>\n        <button onClick={handlePlay} style={{ marginRight: '10px' }}>Play</button>\n        <button onClick={handlePause}>Pause</button>\n      </div>\n    </div>\n  );\n}\n",
          "testCases": [
            "Component renders: Video should be present but not playing (due to `controls={false}`).",
            "Click 'Play' button: Video should start playing.",
            "Click 'Pause' button while playing: Video should pause.",
            "Click 'Play' button again after pausing: Video should resume playing."
          ],
          "hints": [
            "The `videoRef.current` will be the HTMLVideoElement, which has `play()` and `pause()` methods.",
            "Always check `if (videoRef.current)` before trying to access its methods, as `current` might be null if the element hasn't mounted yet or the ref isn't properly assigned."
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "Media Playback",
            "DOM Manipulation"
          ],
          "timeEstimate": 25,
          "prerequisites": [
            "react_hooks_overview",
            "react_functional_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "imperative_animations",
            "third_party_dom_libraries"
          ]
        },
        {
          "id": "task_refs_3",
          "title": "Create a Scroll-to-Top Button for a Long Content Page",
          "description": "\nImplement a 'Scroll to Top' button that appears when the user scrolls down a long page and, when clicked, smoothly scrolls the page back to the top.\n\n**Requirements:**\n1.  Create a `LongContentPage` component that contains enough content to require scrolling (e.g., several paragraphs or `div`s with `height`).\n2.  Implement a `ScrollToTopButton` component. This component should:\n    a.  Be a functional component.\n    b.  Use `useState` to control its visibility (e.g., `showButton`).\n    c.  Use `useEffect` and `window.addEventListener('scroll', ...)` to update `showButton` based on scroll position (e.g., show if `window.scrollY > 200px`). Remember to clean up the event listener.\n    d.  When clicked, it should smoothly scroll the window to the top using `window.scrollTo()` with `behavior: 'smooth'`.\n3.  Render `ScrollToTopButton` within `LongContentPage`.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Parent component with long content\nfunction LongContentPage() {\n  return (\n    <div style={{ height: '2000px', background: 'linear-gradient(to bottom, #f0f0f0, #ccc)' }}>\n      <h1>Long Page Content</h1>\n      {Array.from({ length: 50 }).map((_, i) => (\n        <p key={i}>This is paragraph {i + 1}. Scroll down to see the button appear!</p>\n      ))}\n      {/* TODO: Render ScrollToTopButton here */}\n    </div>\n  );\n}\n\n// ScrollToTopButton component\nfunction ScrollToTopButton() {\n  const [showButton, setShowButton] = useState(false);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      // TODO: Update showButton based on window.scrollY\n    };\n\n    // TODO: Add scroll event listener\n    // TODO: Return cleanup function for event listener\n  }, []);\n\n  const scrollToTop = () => {\n    // TODO: Implement smooth scroll to top\n  };\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        bottom: '20px',\n        right: '20px',\n        padding: '10px 15px',\n        backgroundColor: '#007bff',\n        color: 'white',\n        borderRadius: '5px',\n        cursor: 'pointer',\n        display: showButton ? 'block' : 'none',\n        zIndex: 1000\n      }}\n      onClick={scrollToTop}\n    >\n      Scroll to Top\n    </div>\n  );\n}\n\n// To render:\n// ReactDOM.render(<LongContentPage />, document.getElementById('root'));",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// Parent component with long content\nfunction LongContentPage() {\n  return (\n    <div style={{ height: '2000px', background: 'linear-gradient(to bottom, #f0f0f0, #ccc)' }}>\n      <h1>Long Page Content</h1>\n      {Array.from({ length: 50 }).map((_, i) => (\n        <p key={i}>This is paragraph {i + 1}. Scroll down to see the button appear!</p>\n      ))}\n      <ScrollToTopButton />\n    </div>\n  );\n}\n\n// ScrollToTopButton component\nfunction ScrollToTopButton() {\n  const [showButton, setShowButton] = useState(false);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      // Show button if scrolled more than 200px\n      if (window.scrollY > 200) {\n        setShowButton(true);\n      } else {\n        setShowButton(false);\n      }\n    };\n\n    window.addEventListener('scroll', handleScroll);\n\n    // Cleanup the event listener when the component unmounts\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []); // Empty dependency array ensures listener is added/removed once\n\n  const scrollToTop = () => {\n    window.scrollTo({\n      top: 0,\n      behavior: 'smooth'\n    });\n  };\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        bottom: '20px',\n        right: '20px',\n        padding: '10px 15px',\n        backgroundColor: '#007bff',\n        color: 'white',\n        borderRadius: '5px',\n        cursor: 'pointer',\n        display: showButton ? 'block' : 'none',\n        zIndex: 1000,\n        boxShadow: '0 2px 5px rgba(0,0,0,0.2)'\n      }}\n      onClick={scrollToTop}\n    >\n      Scroll to Top\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: The 'Scroll to Top' button should NOT be visible.",
            "Scroll down past 200px: The button should become visible.",
            "Scroll back up above 200px: The button should disappear.",
            "Click the visible button: The page should smoothly scroll back to the top.",
            "Verify smooth scrolling functionality."
          ],
          "hints": [
            "You'll need `window.scrollY` to check the current scroll position.",
            "The `useEffect` hook with an empty dependency array `[]` is crucial for setting up and tearing down the `scroll` event listener correctly.",
            "`window.scrollTo({ top: 0, behavior: 'smooth' })` is the modern way to achieve smooth scrolling."
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Event Listeners",
            "DOM Manipulation",
            "Scroll"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_overview",
            "react_functional_components",
            "javascript_dom_events"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "refs_use_cases",
            "side_effects_in_react"
          ]
        }
      ]
    }
  },
  {
    "id": "59fc381d-1589-4a63-8766-4f40e6aba3fa",
    "startLine": 3900,
    "endLine": 3999,
    "processedDate": "2025-06-17T08:59:13.588Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_refs_overview",
          "title": "React Refs: Accessing DOM Nodes and React Elements",
          "content": "Refs provide a way to access DOM nodes or React elements created in the render method. In a typical React data flow, props are the only way parent components interact with their children. However, there are a few cases where you need to imperatively modify a child outside of the typical data flow. Refs are the solution for this.\n\n## When to Use Refs\nRefs are useful in scenarios where direct manipulation or access to a DOM element or component instance is necessary. Common use cases include:\n\n*   Managing focus, text selection, or media playback.\n*   Triggering imperative animations.\n*   Integrating with third-party DOM libraries.\n*   Working with uncontrolled components.\n\n## When NOT to Use Refs\nAvoid using refs for anything that can be done declaratively. For example, rather than using a ref to imperatively change a component's style, you should pass a prop to it. Props are the primary way to pass data down the component tree.",
          "examples": [],
          "relatedQuestions": [
            "question_react_refs_overview_1",
            "question_react_refs_overview_2",
            "question_react_refs_overview_3",
            "question_react_refs_overview_4"
          ],
          "relatedTasks": [],
          "tags": [
            "React",
            "Refs",
            "DOM",
            "Imperative Programming",
            "Component Interaction"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "dom_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "controlled_vs_uncontrolled_components",
            "integrating_third_party_libraries"
          ]
        },
        {
          "id": "theory_refs_class_components",
          "title": "Refs in Class Components: createRef and Callback Refs",
          "content": "In class components, refs can be created using `React.createRef()` or by using a 'callback ref'.\n\n### Using `React.createRef()`\n`React.createRef()` is the modern way to create refs in class components. It returns a ref object, and the ref is assigned to an instance property. This ref object's `.current` property will hold the actual DOM element or React component instance after the component mounts.\n\n**Initialization:**\n`this.myRef = React.createRef()` should be called in the constructor so that the ref is created once when the component instance is created.\n\n**Attaching to an Element:**\nThe ref object is then attached to a React element by passing it as the `ref` prop: `<div ref={this.myRef} />`.\n\n### Using Callback Refs\nCallback refs provide more fine-grained control over when refs are set and unset. Instead of passing a ref object, you pass a function to the `ref` attribute. This function receives the underlying DOM element or class component instance as its argument. React will call the ref callback with the DOM element when the component mounts, and call it with `null` when it unmounts. This ensures you can clean up any resources if necessary.\n\n**Syntax:**\n`<input ref={(element) => { this.textInput = element; }} />`\n\nWhile callback refs offer more control, `createRef()` is often simpler for common use cases.",
          "examples": [
            {
              "id": "example_class_component_createRef",
              "title": "Basic createRef in Class Component",
              "code": "import React from 'react';\n\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myDivRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Accessing the DOM node after mount\n    if (this.myDivRef.current) {\n      console.log('Div element:', this.myDivRef.current);\n      this.myDivRef.current.style.backgroundColor = 'lightblue';\n    }\n  }\n\n  render() {\n    return <div ref={this.myDivRef}>Hello, I'm a div!</div>;\n  }\n}",
              "explanation": "This example demonstrates how to create a ref using `React.createRef()` in a class component's constructor, attach it to a DOM element in the `render` method, and then access the underlying DOM node via `this.myDivRef.current` in `componentDidMount` to modify its style.",
              "language": "javascript"
            },
            {
              "id": "example_class_component_callbackRef",
              "title": "Callback Ref in Class Component",
              "code": "import React from 'react';\n\nclass AutoFocusInputCallbackRef extends React.Component {\n  constructor(props) {\n    super(props);\n    this.nameInput = null; // Initialize the ref holder\n  }\n\n  componentDidMount() {\n    // Focus the input using the callback ref\n    if (this.nameInput) {\n      this.nameInput.focus();\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <input\n          ref={(inputElement) => { this.nameInput = inputElement; }}\n          defaultValue={'Focused with Callback Ref'}\n        />\n      </div>\n    );\n  }\n}",
              "explanation": "This example uses a callback ref. The `ref` prop is a function that receives the DOM `inputElement` when the component mounts, which is then stored in `this.nameInput`. This allows the `componentDidMount` lifecycle method to imperatively call `focus()` on the input.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_class_refs_1",
            "question_class_refs_2",
            "question_class_refs_3",
            "question_class_refs_4",
            "question_class_refs_5"
          ],
          "relatedTasks": [
            "task_class_component_ref_focus"
          ],
          "tags": [
            "React",
            "Refs",
            "Class Components",
            "createRef",
            "Callback Refs",
            "DOM Manipulation"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_lifecycle_methods"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "legacy_react_codebase",
            "uncontrolled_forms"
          ]
        },
        {
          "id": "theory_use_ref_hook",
          "title": "Refs in Functional Components: The `useRef` Hook",
          "content": "For functional components, React provides the `useRef` hook to work with refs. `useRef` is a powerful hook that serves multiple purposes beyond just accessing DOM elements.\n\n### How `useRef` Works\n`useRef` returns a mutable ref object. This object has a `.current` property which is initialized to the argument passed to `useRef` (e.g., `useRef(null)`). The returned ref object will persist for the full lifetime of the component, meaning it won't be re-created on every render.\n\n**Key Characteristics of `useRef`:**\n\n*   **Mutable:** Unlike state, `useRef` allows you to directly mutate its `.current` property. `ref.current = newValue` is a valid operation.\n*   **No Re-renders:** Changing a ref's `.current` property *does not* trigger a re-render of the component. This is a crucial distinction from `useState`.\n*   **Lifetime:** The ref object persists across renders, maintaining its `.current` value.\n*   **Versatility:** While often used for DOM access, `useRef` is perfect for storing any mutable value that doesn't affect the visual output of your component and doesn't need to trigger re-renders. This can include timers (e.g., `setInterval` IDs), mutable objects, or previous values of props/state.",
          "examples": [
            {
              "id": "example_useRef_focus_input",
              "title": "Focusing Input with `useRef` Hook",
              "code": "import React, { useRef } from 'react';\n\nfunction TextInputWithFocusButton() {\n  const inputRef = useRef(null);\n  \n  const focusTextInput = () => {\n    // Explicitly focus the text input using the raw DOM API\n    // Note: we're accessing \"current\" to get the DOM node\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  };\n  \n  return (\n    <>\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={focusTextInput}>Focus the input</button>\n    </>\n  );\n}",
              "explanation": "This example demonstrates the primary use case of `useRef` for DOM manipulation. An `inputRef` is created, attached to the `<input>` element, and then its `.current` property is used within the `focusTextInput` handler to call the native DOM `focus()` method.",
              "language": "javascript"
            },
            {
              "id": "example_useRef_store_value",
              "title": "Storing Mutable Value with `useRef`",
              "code": "import React, { useRef, useState } from 'react';\n\nfunction CounterWithNoRerenderRef() {\n  const counterRef = useRef(0); // Initialize with 0\n  const [renderCount, setRenderCount] = useState(0);\n\n  const incrementRefCounter = () => {\n    counterRef.current++;\n    console.log('Ref Counter:', counterRef.current);\n  };\n\n  return (\n    <div>\n      <p>Ref Counter (does not re-render): {counterRef.current}</p>\n      <button onClick={incrementRefCounter}>Increment Ref Counter</button>\n      <button onClick={() => setRenderCount(prev => prev + 1)}>Force Re-render ({renderCount})</button>\n      <p>Click 'Force Re-render' to see updated Ref Counter display.</p>\n    </div>\n  );\n}",
              "explanation": "This advanced example shows `useRef` used for storing a mutable value (`counterRef.current`) that does not trigger a re-render. The `Ref Counter` displayed on screen only updates when a `useState`-driven re-render is explicitly triggered (e.g., by clicking 'Force Re-render'), highlighting the difference between `useRef` and `useState`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_use_ref_1",
            "question_use_ref_2",
            "question_use_ref_3",
            "question_use_ref_4",
            "question_use_ref_5",
            "question_use_ref_6"
          ],
          "relatedTasks": [
            "task_autofocus_functional_component",
            "task_timer_with_ref"
          ],
          "tags": [
            "React Hooks",
            "useRef",
            "Functional Components",
            "Mutable Values",
            "DOM Manipulation",
            "No Re-render"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_form_management",
            "performance_optimization_in_hooks",
            "integrating_non_react_libraries"
          ]
        },
        {
          "id": "theory_autofocus_with_refs",
          "title": "Focusing an Input Element with Refs (Auto-Focus)",
          "content": "A very common and practical application of refs is to programmatically focus an input element, often when a component mounts or after a certain user action. This is particularly useful for user experience in forms, such as login fields or search bars, where you want to place the cursor immediately for user convenience.\n\n### Class Component Approach\nIn class components, you typically use `componentDidMount` to perform side effects like focusing. After the component has mounted and the ref has been assigned the DOM node, you can call the `focus()` method on it.\n\n### Functional Component Approach with `useRef` and `useEffect`\nIn functional components, the `useEffect` hook is the equivalent of lifecycle methods like `componentDidMount` and `componentDidUpdate`. To focus an input on mount, you'd use `useEffect` with an empty dependency array (`[]`), ensuring the effect runs only once after the initial render. The `useRef` hook creates the ref object, and `useEffect` accesses its `.current` property to call `focus()`.\n\nIt's important to always check if `ref.current` is not `null` before attempting to interact with it, as refs are `null` initially and only populated after the component renders and the DOM node is available.",
          "examples": [
            {
              "id": "example_autofocus_class_component",
              "title": "Auto-Focus in Class Component",
              "code": "import React from 'react';\n\nclass AutoFocusInputClass extends React.Component {\n  componentDidMount() {\n    // Using a callback ref for simplicity here, as seen in original content\n    if (this.nameInput) {\n      this.nameInput.focus();\n    }\n  }\n  \n  render() {\n    return (\n      <div>\n        <input\n          ref={(input) => this.nameInput = input} // Callback ref\n          defaultValue={'Will be focused on mount (Class)'}\n        />\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates auto-focusing an input in a class component using a callback ref. The `componentDidMount` lifecycle method is used to ensure the DOM element is available before attempting to call `focus()`.",
              "language": "javascript"
            },
            {
              "id": "example_autofocus_functional_component",
              "title": "Auto-Focus in Functional Component with `useRef` and `useEffect`",
              "code": "import React, { useRef, useEffect } from 'react';\n\nconst AutoFocusInputFunc = () => {\n  // Create a ref\n  const inputRef = useRef(null);\n  \n  // Focus the input element after component mounts\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array ensures this runs once after mount\n  \n  return (\n    <div>\n      <input\n        ref={inputRef}\n        defaultValue={'Will be focused on mount (Functional)'}\n      />\n    </div>\n  );\n};",
              "explanation": "This example shows how to achieve auto-focus in a functional component. `useRef` creates the mutable ref object, and `useEffect` with an empty dependency array executes the `focus()` call once the component has rendered and the ref's `.current` property has been assigned the DOM `input` element.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_autofocus_1",
            "question_autofocus_2",
            "question_autofocus_3"
          ],
          "relatedTasks": [
            "task_autofocus_functional_component"
          ],
          "tags": [
            "React",
            "Refs",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Focus",
            "User Experience"
          ],
          "technology": "React",
          "prerequisites": [
            "react_hooks_basics",
            "react_lifecycle_methods"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "form_development",
            "accessibility"
          ]
        },
        {
          "id": "theory_uncontrolled_components",
          "title": "Uncontrolled Components with Refs",
          "content": "In React, form components are typically 'controlled components,' meaning their values are handled by React state, and every state update triggers a re-render. While this is the recommended approach for most form inputs, sometimes you might want to integrate with non-React code or if you need to access a form value once, without managing its state throughout its lifecycle. This is where 'uncontrolled components' come in.\n\n### What are Uncontrolled Components?\nUncontrolled components are form components where the form data is handled by the DOM itself, not by React. Instead of writing an event handler for every state update, you use a ref to get the form value directly from the DOM when you need it (e.g., when the form is submitted). This can sometimes make integration with non-React libraries or legacy code easier.\n\n### How Refs are Used\nFor uncontrolled components, you attach a ref to the form input element. When the form is submitted or a specific action occurs, you access `ref.current.value` (for `<input>`, `<textarea>`) or `ref.current.files` (for `<input type='file'>`) to retrieve the current value directly from the DOM element.\n\n**Contrast with Controlled Components:**\n*   **Controlled:** React state is the single source of truth. Updates happen via `onChange` and `setState`. Re-renders occur on every input change.\n*   **Uncontrolled:** DOM is the single source of truth. Values are retrieved via refs when needed. No re-renders on input change, only when values are explicitly accessed.",
          "examples": [
            {
              "id": "example_uncontrolled_form",
              "title": "Basic Uncontrolled Form with Class Component",
              "code": "import React from 'react';\n\nclass UncontrolledForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.nameInput = React.createRef();\n    this.fileInput = React.createRef();\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n    // Access values directly from the DOM using refs\n    const name = this.nameInput.current.value;\n    const file = this.fileInput.current.files[0];\n\n    alert(`Name: ${name}\\nSelected file: ${file ? file.name : 'No file'}`);\n    console.log('Name:', name);\n    console.log('File:', file);\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={this.nameInput} defaultValue=\"John Doe\" />\n        </label>\n        <br />\n        <label>\n          Upload File:\n          <input type=\"file\" ref={this.fileInput} />\n        </label>\n        <br />\n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  }\n}",
              "explanation": "This example demonstrates an uncontrolled form in a class component. `React.createRef()` is used to create refs for an input and a file input. When the form is submitted, the `handleSubmit` method directly accesses the current values from the DOM elements via `this.nameInput.current.value` and `this.fileInput.current.files`, without needing to manage their state in React.",
              "language": "javascript"
            },
            {
              "id": "example_uncontrolled_form_functional",
              "title": "Basic Uncontrolled Form with Functional Component",
              "code": "import React, { useRef } from 'react';\n\nconst UncontrolledFormFunc = () => {\n  const nameInputRef = useRef(null);\n  const fileInputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const name = nameInputRef.current.value;\n    const file = fileInputRef.current.files[0];\n\n    alert(`Name: ${name}\\nSelected file: ${file ? file.name : 'No file'}`);\n    console.log('Name:', name);\n    console.log('File:', file);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input type=\"text\" ref={nameInputRef} defaultValue=\"Jane Doe\" />\n      </label>\n      <br />\n      <label>\n        Upload File:\n        <input type=\"file\" ref={fileInputRef} />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};",
              "explanation": "This functional component example mirrors the uncontrolled form behavior using `useRef`. The refs `nameInputRef` and `fileInputRef` are attached to the respective inputs, and their `.current` property is accessed directly within the `handleSubmit` function to retrieve the form values.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_uncontrolled_1",
            "question_uncontrolled_2",
            "question_uncontrolled_3",
            "question_uncontrolled_4"
          ],
          "relatedTasks": [
            "task_uncontrolled_login_form"
          ],
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Refs",
            "useRef",
            "Controlled vs Uncontrolled"
          ],
          "technology": "React",
          "prerequisites": [
            "react_forms",
            "react_state"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "form_optimization",
            "integration_with_dom_libraries"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_refs_overview_1",
          "topic": "Introduction to React Refs",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of React Refs?",
          "answer": "Refs provide a way to access DOM nodes or React elements created in the render method, allowing imperative modifications outside of the typical React data flow.",
          "options": [],
          "analysisPoints": [
            "Understanding of when direct DOM interaction is needed.",
            "Recognition that refs are an escape hatch from declarative React.",
            "Differentiating between typical data flow (props) and refs."
          ],
          "keyConcepts": [
            "Refs",
            "DOM Access",
            "Imperative Programming",
            "React Data Flow"
          ],
          "evaluationCriteria": [
            "Correctly identifies the core function of refs."
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Basics"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_refs_overview_2",
          "topic": "Use Cases for Refs",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is a valid and common use case for React Refs?\n\nA. Managing the state of a complex form input that updates on every keystroke.\nB. Passing data from a parent component to a child component.\nC. Programmatically focusing an input field when a component mounts.\nD. Styling a component's background color based on a prop.",
          "answer": "C. Programmatically focusing an input field when a component mounts.",
          "options": [
            "A. Managing the state of a complex form input that updates on every keystroke.",
            "B. Passing data from a parent component to a child component.",
            "C. Programmatically focusing an input field when a component mounts.",
            "D. Styling a component's background color based on a prop."
          ],
          "analysisPoints": [
            "Distinguishes between declarative (props, state) and imperative (refs) operations.",
            "Identifies common imperative DOM manipulations appropriate for refs.",
            "Avoids using refs for tasks better handled by state or props."
          ],
          "keyConcepts": [
            "Refs",
            "Controlled Components",
            "Props",
            "DOM Manipulation",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Correctly identifies appropriate use of refs.",
            "Demonstrates understanding of React's declarative nature."
          ],
          "example": "Option A describes a controlled component, best handled by React state. Option B is the primary use case for props. Option D is a declarative styling choice, also handled by props or state. Option C, focusing an input, is a classic imperative DOM operation that refs are designed for.",
          "tags": [
            "React",
            "Refs",
            "Use Cases",
            "Best Practices"
          ],
          "prerequisites": [
            "react_state",
            "react_props"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_refs_overview_3",
          "topic": "Ref vs. State",
          "level": "medium",
          "type": "open",
          "question": "Explain the key differences between `useState` and `useRef` in React functional components, specifically focusing on how they handle value updates and component re-renders.",
          "answer": "While both `useState` and `useRef` can store values, their primary differences lie in mutability and effect on re-renders.\n\n1.  **Re-rendering:**\n    *   `useState`: When the setter function (`setSomething`) is called to update state, it queues a re-render of the component and its children. This is ideal for values that affect the component's visual output.\n    *   `useRef`: Changing the `.current` property of a ref object (`ref.current = newValue`) *does not* trigger a re-render of the component. This makes it suitable for storing values that need to persist across renders but do not directly influence the UI, such as timer IDs, DOM elements, or mutable objects.\n\n2.  **Mutability:**\n    *   `useState`: State values are generally treated as immutable. You update state by replacing the old value with a new one using the setter function. Direct mutation of state (e.g., `state.property = value`) is a common anti-pattern that can lead to bugs.\n    *   `useRef`: The `.current` property of a ref object is mutable. You can directly assign a new value to it (`ref.current = newValue`). The ref object itself (`myRef`) remains the same across renders, but its `current` property can change.\n\n3.  **Persistence:**\n    *   Both persist across renders. State values are managed by React and persist. Ref objects are also guaranteed to persist for the entire lifetime of the component.",
          "options": [],
          "analysisPoints": [
            "Distinguishes between re-render behavior of state and refs.",
            "Explains the mutability characteristics of each.",
            "Provides clear use cases for each based on their behavior."
          ],
          "keyConcepts": [
            "useState",
            "useRef",
            "State Management",
            "Component Lifecycle",
            "Re-renders",
            "Mutability"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of explanation.",
            "Ability to articulate the core behavioral differences.",
            "Demonstrates understanding of React's rendering mechanism."
          ],
          "example": "",
          "tags": [
            "React Hooks",
            "useState",
            "useRef",
            "Comparison",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_state"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_refs_overview_4",
          "topic": "When to avoid Refs",
          "level": "easy",
          "type": "flashcard",
          "question": "When should you generally AVOID using React Refs?",
          "answer": "You should avoid using refs for anything that can be done declaratively with props and state. For example, changing a component's style or content based on dynamic data should be handled by props/state, not refs.",
          "options": [],
          "analysisPoints": [
            "Reinforces understanding of React's declarative paradigm.",
            "Highlights the 'escape hatch' nature of refs.",
            "Encourages best practices in React development."
          ],
          "keyConcepts": [
            "Refs",
            "Declarative Programming",
            "Props",
            "State",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Identifies the core principle of when to avoid refs."
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Best Practices"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_refs_1",
          "topic": "Refs in Class Components: createRef",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you create a ref in a React class component using the modern API?",
          "answer": "You create a ref using `React.createRef()` and assign it to an instance property in the component's constructor, e.g., `this.myRef = React.createRef();`",
          "options": [],
          "analysisPoints": [
            "Recalls the specific method for creating refs in classes.",
            "Identifies the correct place for initialization (constructor)."
          ],
          "keyConcepts": [
            "Refs",
            "Class Components",
            "createRef"
          ],
          "evaluationCriteria": [
            "Correctly names the method and its usage."
          ],
          "example": "",
          "tags": [
            "React",
            "Class Components",
            "Refs"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_refs_2",
          "topic": "Refs in Class Components: Accessing `current`",
          "level": "easy",
          "type": "mcq",
          "question": "Given the following class component snippet, how would you access the underlying DOM `div` element to change its background color after it mounts?\n\n```javascript\nimport React from 'react';\n\nclass MyDivComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.divRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // CODE TO ACCESS DIV ELEMENT HERE\n  }\n\n  render() {\n    return <div ref={this.divRef}>Hello</div>;\n  }\n}\n```\n\nA. `this.divRef.style.backgroundColor = 'blue';`\nB. `this.divRef.domNode.style.backgroundColor = 'blue';`\nC. `this.divRef.current.style.backgroundColor = 'blue';`\nD. `document.getElementById('my-div').style.backgroundColor = 'blue';`",
          "answer": "C. `this.divRef.current.style.backgroundColor = 'blue';`",
          "options": [
            "A. `this.divRef.style.backgroundColor = 'blue';`",
            "B. `this.divRef.domNode.style.backgroundColor = 'blue';`",
            "C. `this.divRef.current.style.backgroundColor = 'blue';`",
            "D. `document.getElementById('my-div').style.backgroundColor = 'blue';`"
          ],
          "analysisPoints": [
            "Understands the `.current` property of a ref object.",
            "Recognizes how to interact with the underlying DOM element.",
            "Distinguishes between direct DOM manipulation and React's ref mechanism."
          ],
          "keyConcepts": [
            "Refs",
            "Class Components",
            "createRef",
            "DOM Access",
            "current property"
          ],
          "evaluationCriteria": [
            "Correctly uses the `.current` property.",
            "Demonstrates knowledge of ref object structure."
          ],
          "example": "The `divRef` object itself is not the DOM node; it's a plain JavaScript object with a `current` property that holds the DOM node after the component mounts. Option D is incorrect because it bypasses React entirely and relies on an ID that isn't present in the JSX.",
          "tags": [
            "React",
            "Class Components",
            "Refs",
            "DOM"
          ],
          "prerequisites": [
            "react_class_components",
            "react_createRef"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_refs_3",
          "topic": "Callback Refs",
          "level": "medium",
          "type": "open",
          "question": "Describe what a 'callback ref' is in React class components and explain a scenario where it might be preferred over `React.createRef()`.",
          "answer": "A callback ref is a function passed as the `ref` prop to a React element. This function receives the underlying DOM element or component instance as its argument. React calls this function with the element when it mounts and with `null` when it unmounts, allowing for setup and cleanup logic.\n\n**Scenario for Preference:**\nCallback refs are often preferred when you need more granular control over when the ref is set and unset, or when you need to integrate with external DOM libraries that require specific initialization/cleanup. For example, if you need to attach or detach event listeners or perform other imperative actions that require cleanup when the component unmounts, the callback ref naturally provides both the mounting (element provided) and unmounting (`null` provided) hooks for this.",
          "options": [],
          "analysisPoints": [
            "Defines callback ref correctly.",
            "Explains its mechanism (receives element, `null` on unmount).",
            "Identifies specific use cases for callback refs that leverage their unique behavior (cleanup, fine-grained control)."
          ],
          "keyConcepts": [
            "Refs",
            "Callback Refs",
            "Class Components",
            "DOM Manipulation",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Accurate definition and functionality explanation.",
            "Provides a relevant and justified use case."
          ],
          "example": "",
          "tags": [
            "React",
            "Class Components",
            "Refs",
            "Callback Refs"
          ],
          "prerequisites": [
            "react_class_components",
            "react_createRef"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_refs_4",
          "topic": "Ref Assignment in Class Components",
          "level": "medium",
          "type": "code",
          "question": "Correct the following class component to properly create and use a ref to access the `input` element and log its value to the console when a button is clicked.\n\n```javascript\nimport React from 'react';\n\nclass MyForm extends React.Component {\n  // Missing constructor and ref creation\n\n  handleClick = () => {\n    // Incorrect ref access\n    console.log(this.myInputRef.value);\n  };\n\n  render() {\n    return (\n      <div>\n        <input type=\"text\" ref=\"myInputRef\" />\n        <button onClick={this.handleClick}>Log Input</button>\n      </div>\n    );\n  }\n}\n```",
          "answer": "```javascript\nimport React from 'react';\n\nclass MyForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myInputRef = React.createRef(); // Correct: Create ref in constructor\n  }\n\n  handleClick = () => {\n    // Correct: Access DOM element via .current property\n    if (this.myInputRef.current) {\n      console.log(this.myInputRef.current.value);\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        {/* Correct: Pass the ref object to the ref prop */}\n        <input type=\"text\" ref={this.myInputRef} />\n        <button onClick={this.handleClick}>Log Input</button>\n      </div>\n    );\n  }\n}\n```",
          "options": [],
          "analysisPoints": [
            "Identifies missing ref creation in the constructor.",
            "Correctly uses `React.createRef()`.",
            "Understands that the `ref` prop expects a ref *object*, not a string.",
            "Accesses the DOM element through the `.current` property of the ref.",
            "Includes a null check for `ref.current` (best practice)."
          ],
          "keyConcepts": [
            "Refs",
            "Class Components",
            "createRef",
            "DOM Access",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Produces runnable, correct code.",
            "Demonstrates understanding of ref lifecycle and access patterns.",
            "Applies best practices (null checks)."
          ],
          "example": "The original code had several issues: `this.myInputRef` was not initialized, passing a string to `ref` is a legacy pattern (string refs) and discouraged, and it attempted to access `value` directly on the ref object instead of its `.current` property.",
          "tags": [
            "React",
            "Class Components",
            "Refs",
            "Coding Challenge",
            "Debugging"
          ],
          "prerequisites": [
            "react_class_components",
            "react_createRef"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_refs_5",
          "topic": "String Refs (Legacy)",
          "level": "hard",
          "type": "mcq",
          "question": "Which of the following is true about string refs (`ref=\"myRefString\"`) in React?\n\nA. They are the recommended way to use refs in modern React applications.\nB. They are automatically cleared to `null` by React after unmounting, similar to callback refs.\nC. They have some caveats, such as not allowing component composition and being generally discouraged in favor of `React.createRef()` or `useRef()`.\nD. They can directly access a component's state and props.",
          "answer": "C. They have some caveats, such as not allowing component composition and being generally discouraged in favor of `React.createRef()` or `useRef()`.",
          "options": [
            "A. They are the recommended way to use refs in modern React applications.",
            "B. They are automatically cleared to `null` by React after unmounting, similar to callback refs.",
            "C. They have some caveats, such as not allowing component composition and being generally discouraged in favor of `React.createRef()` or `useRef()`.",
            "D. They can directly access a component's state and props."
          ],
          "analysisPoints": [
            "Understands the legacy nature of string refs.",
            "Knows why string refs are discouraged (performance, composability issues).",
            "Distinguishes string refs from modern ref APIs.",
            "Correctly identifies that refs access DOM nodes/component instances, not internal state/props directly."
          ],
          "keyConcepts": [
            "Refs",
            "String Refs",
            "Legacy API",
            "Best Practices",
            "createRef",
            "useRef"
          ],
          "evaluationCriteria": [
            "Demonstrates knowledge of historical React ref patterns.",
            "Understands reasons for deprecation.",
            "Avoids common misconceptions about ref capabilities."
          ],
          "example": "String refs are a legacy API in React. They have minor performance implications and are problematic with hot reloading and component composition. React recommends using `React.createRef()` or `useRef()` instead. Refs provide access to the DOM node or component instance, not direct access to its internal state or props, which should be managed through standard React data flow.",
          "tags": [
            "React",
            "Refs",
            "Legacy",
            "Best Practices"
          ],
          "prerequisites": [
            "react_class_components",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_ref_1",
          "topic": "useRef Hook Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What does the `useRef` hook return?",
          "answer": "`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument. This object persists for the full lifetime of the component.",
          "options": [],
          "analysisPoints": [
            "Identifies the return value as a mutable ref object.",
            "Recalls the `.current` property.",
            "Knows about its persistence across renders."
          ],
          "keyConcepts": [
            "useRef",
            "React Hooks",
            "Ref Object",
            "Current Property"
          ],
          "evaluationCriteria": [
            "Correctly identifies the structure and behavior of the returned object."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Basics"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_ref_2",
          "topic": "useRef and Re-renders",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React functional component:\n\n```javascript\nimport React, { useRef, useState } from 'react';\n\nfunction MyComponent() {\n  const countRef = useRef(0);\n  const [renderCounter, setRenderCounter] = useState(0);\n\n  const incrementCount = () => {\n    countRef.current++;\n    console.log('Ref Count:', countRef.current);\n  };\n\n  return (\n    <div>\n      <p>Ref Count: {countRef.current}</p>\n      <button onClick={incrementCount}>Increment Ref Count</button>\n      <button onClick={() => setRenderCounter(prev => prev + 1)}>Force Re-render</button>\n    </div>\n  );\n}\n```\n\nWhat happens to the displayed 'Ref Count' value when the 'Increment Ref Count' button is clicked multiple times *without* clicking 'Force Re-render'?",
          "answer": "B. The `console.log` will show the updated value, but the displayed 'Ref Count' on the screen will not change until 'Force Re-render' is clicked.",
          "options": [
            "A. The displayed 'Ref Count' will immediately update on screen with each click, matching the `console.log` output.",
            "B. The `console.log` will show the updated value, but the displayed 'Ref Count' on the screen will not change until 'Force Re-render' is clicked.",
            "C. The `countRef.current` value will not increment at all because `useRef` cannot store mutable numbers.",
            "D. The component will re-render automatically, but the `countRef.current` value will reset to 0 on each re-render."
          ],
          "analysisPoints": [
            "Understands that changing `useRef().current` does not trigger a re-render.",
            "Differentiates `useRef` behavior from `useState`.",
            "Predicts the visual outcome based on React's rendering mechanism."
          ],
          "keyConcepts": [
            "useRef",
            "Re-renders",
            "useState",
            "Mutable Values",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Correctly identifies the re-render characteristic of `useRef`.",
            "Explains the discrepancy between internal state and displayed UI."
          ],
          "example": "This question directly tests the core characteristic of `useRef`: its `.current` property is mutable, but mutating it does not cause the component to re-render. Therefore, while `countRef.current` updates internally and in the console, the UI only reflects this update when a re-render is triggered by something else, like a `useState` update.",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Re-renders",
            "State Management"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_state"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_ref_3",
          "topic": "useRef Use Cases Beyond DOM",
          "level": "medium",
          "type": "open",
          "question": "Besides accessing DOM elements, what are other common use cases for the `useRef` hook in React functional components? Provide an example for one such use case.",
          "answer": "Beyond DOM element access, `useRef` is commonly used for:\n\n1.  **Storing any mutable value that doesn't trigger a re-render:** This is useful for values that need to persist across renders but aren't part of the component's render output. Examples include timer IDs (from `setInterval` or `setTimeout`), previous values of props/state, or mutable objects that are part of an external library.\n2.  **Referencing a previous value of state or props:** You can store the current value of a prop or state in a ref, and in the next render, compare it to the current prop/state value to understand changes over time.\n\n**Example: Storing a Timer ID**\n```javascript\nimport React, { useRef, useEffect, useState } from 'react';\n\nfunction Timer() {\n  const intervalRef = useRef(null); // Stores the interval ID\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    intervalRef.current = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n\n    return () => {\n      // Cleanup: Clear the interval when component unmounts\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []); // Run only on mount and unmount\n\n  const stopTimer = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null; // Clear the ref\n    }\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={stopTimer}>Stop Timer</button>\n    </div>\n  );\n}\n```\nIn this example, `intervalRef` is used to hold the ID returned by `setInterval`. This ID is mutable and needs to persist across renders (so `useEffect`'s cleanup function can access it), but changing it doesn't need to cause a re-render of the component itself.",
          "options": [],
          "analysisPoints": [
            "Identifies multiple non-DOM use cases.",
            "Provides a clear and correct code example.",
            "Explains *why* `useRef` is suitable for the chosen example (persistence, no re-render)."
          ],
          "keyConcepts": [
            "useRef",
            "React Hooks",
            "Side Effects",
            "Persistence",
            "Timers",
            "useEffect"
          ],
          "evaluationCriteria": [
            "Comprehensive answer covering diverse use cases.",
            "Code example is relevant and functional.",
            "Demonstrates a deep understanding of `useRef`'s capabilities."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Advanced Use Cases",
            "Side Effects"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_useEffect"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_ref_4",
          "topic": "Initializing useRef",
          "level": "easy",
          "type": "flashcard",
          "question": "When `useRef` is called, what value is its `.current` property initialized to?",
          "answer": "The `.current` property of the ref object returned by `useRef` is initialized to the argument passed to `useRef` (e.g., `useRef(null)` initializes `current` to `null`).",
          "options": [],
          "analysisPoints": [
            "Recalls the initialization behavior of `useRef`.",
            "Understands the direct correlation between argument and `.current` value."
          ],
          "keyConcepts": [
            "useRef",
            "Initialization",
            "current property"
          ],
          "evaluationCriteria": [
            "Correctly states the initialization value."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Basics"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_ref_5",
          "topic": "Code Prediction with useRef",
          "level": "medium",
          "type": "code",
          "question": "What will be logged to the console when `ComponentA` is rendered and then its button is clicked? Assume this is the first time the component is mounted.",
          "answer": "```text\nInitial render: 0\nButton click: 1\n```",
          "options": [],
          "analysisPoints": [
            "Understands that `useRef` maintains its value across renders.",
            "Understands that changing `ref.current` does not trigger a re-render, so the `console.log` inside the component body runs only on the initial render, but the value inside the `handleClick` function will always be the latest.",
            "Differentiates between the value *during* render and the value *after* an event handler mutates it."
          ],
          "keyConcepts": [
            "useRef",
            "Re-renders",
            "Functional Components",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Correctly predicts console output.",
            "Demonstrates understanding of `useRef` persistence and re-render behavior."
          ],
          "example": "```javascript\nimport React, { useRef } from 'react';\n\nfunction ComponentA() {\n  const valueRef = useRef(0);\n\n  console.log('Initial render:', valueRef.current);\n\n  const handleClick = () => {\n    valueRef.current++;\n    console.log('Button click:', valueRef.current);\n  };\n\n  return (\n    <button onClick={handleClick}>Click Me</button>\n  );\n}\n\n// When <ComponentA /> is rendered:\n// 1. First render: valueRef.current is 0. 'Initial render: 0' is logged.\n// 2. Button click: valueRef.current becomes 1. 'Button click: 1' is logged. The component does NOT re-render due to ref change.\n// If the button is clicked again: valueRef.current becomes 2. 'Button click: 2' is logged. Still no re-render.\n```",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Code Prediction",
            "Re-renders"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_ref_6",
          "topic": "When to choose useRef",
          "level": "hard",
          "type": "open",
          "question": "You need to implement a feature where a component should keep track of how many times it has rendered, but this count should not trigger any additional re-renders itself. Which React hook would you use and why?",
          "answer": "I would use the `useRef` hook. The `useRef` hook returns a mutable ref object whose `.current` property can be updated without causing a re-render of the component. This is perfect for storing a value like a render count, which needs to persist across renders but should not visually update the component simply by changing its value. If `useState` were used, every time the render count increased, it would trigger a re-render, leading to an infinite loop (as the render count would increment during the re-render process, triggering another re-render, and so on). `useRef` avoids this re-render cycle while still providing persistent storage.",
          "options": [],
          "analysisPoints": [
            "Identifies `useRef` as the correct hook.",
            "Clearly explains *why* `useRef` is suitable (no re-render on mutation).",
            "Contrasts with `useState` and explains the infinite loop issue if `useState` were mistakenly used.",
            "Demonstrates a nuanced understanding of React's rendering lifecycle."
          ],
          "keyConcepts": [
            "useRef",
            "useState",
            "Re-renders",
            "Component Lifecycle",
            "Performance Optimization",
            "Infinite Loops"
          ],
          "evaluationCriteria": [
            "Selects the optimal hook with a robust justification.",
            "Demonstrates understanding of potential pitfalls with `useState` in this scenario.",
            "Articulates the core difference between `useRef` and `useState` effectively."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useState",
            "Architecture",
            "Optimization"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_state",
            "react_rendering_principles"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_autofocus_1",
          "topic": "Auto-Focus Implementation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the correct and idiomatic way to auto-focus an input element in a React functional component when it mounts?\n\nA.\n```javascript\nimport React, { useRef } from 'react';\nfunction MyInput() {\n  const inputRef = useRef();\n  inputRef.current.focus(); // Problematic: Runs on every render, might be null\n  return <input ref={inputRef} />;\n}\n```\n\nB.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }); // Problematic: No dependency array, runs on every render\n  return <input ref={inputRef} />;\n}\n```\n\nC.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Correct: Runs once after mount\n  return <input ref={inputRef} />;\n}\n```\n\nD.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  // No effect hook, relying on direct DOM access after render\n  inputRef.current.focus(); // Still problematic\n  return <input ref={inputRef} />;\n}\n```",
          "answer": "C. \n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Correct: Runs once after mount\n  return <input ref={inputRef} />;\n}\n```",
          "options": [
            "A.\n```javascript\nimport React, { useRef } from 'react';\nfunction MyInput() {\n  const inputRef = useRef();\n  inputRef.current.focus(); // Problematic: Runs on every render, might be null\n  return <input ref={inputRef} />;\n}\n```",
            "B.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }); // Problematic: No dependency array, runs on every render\n  return <input ref={inputRef} />;\n}\n```",
            "C.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Correct: Runs once after mount\n  return <input ref={inputRef} />;\n}\n```",
            "D.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  // No effect hook, relying on direct DOM access after render\n  inputRef.current.focus(); // Still problematic\n  return <input ref={inputRef} />;\n}\n```"
          ],
          "analysisPoints": [
            "Understands the correct use of `useRef` to acquire a DOM reference.",
            "Recognizes the necessity of `useEffect` for side effects like focusing.",
            "Knows that an empty dependency array (`[]`) in `useEffect` ensures the effect runs only once after the initial mount.",
            "Appreciates the importance of checking `ref.current` for nullability."
          ],
          "keyConcepts": [
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Component Lifecycle",
            "Side Effects",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Selects the most robust and idiomatic React solution.",
            "Identifies errors in incorrect implementations (e.g., running `focus` in render, missing dependency array).",
            "Demonstrates knowledge of Hook best practices."
          ],
          "example": "Option A and D attempt to call `focus()` directly during the render phase, which is incorrect and can lead to errors as `inputRef.current` might not yet be populated. Option B uses `useEffect` but lacks a dependency array, meaning it would run on *every* render, which is inefficient and potentially problematic for focusing. Option C correctly uses `useEffect` with an empty dependency array to ensure the focus operation happens once after the component has mounted and the `inputRef.current` value is available, adhering to React's lifecycle principles for side effects.",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Best Practices"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_useEffect"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_autofocus_2",
          "topic": "Class Component Auto-Focus Lifecycle",
          "level": "medium",
          "type": "flashcard",
          "question": "Which lifecycle method in a React class component is typically used to auto-focus an input element with refs, and why?",
          "answer": "The `componentDidMount` lifecycle method is typically used. This is because `componentDidMount` runs only once after the component has been rendered to the DOM, ensuring that the DOM element referenced by the ref (`this.myRef.current`) is available and ready for interaction (like calling `focus()`).",
          "options": [],
          "analysisPoints": [
            "Correctly identifies `componentDidMount`.",
            "Explains the reason based on the component lifecycle (DOM availability).",
            "Connects lifecycle to ref usage."
          ],
          "keyConcepts": [
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "Refs",
            "DOM Interaction"
          ],
          "evaluationCriteria": [
            "Accurately names the lifecycle method and provides a correct rationale."
          ],
          "example": "",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Refs"
          ],
          "prerequisites": [
            "react_class_components",
            "react_lifecycle_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_autofocus_3",
          "topic": "Why `if (inputRef.current)` is important",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is it important to include a check like `if (inputRef.current)` before attempting to call methods on a ref's `current` property (e.g., `inputRef.current.focus()`)?",
          "answer": "It's important because `inputRef.current` will be `null` on the initial render before the DOM element is mounted and assigned to the ref. Attempting to call a method on `null` would result in a runtime error.",
          "options": [],
          "analysisPoints": [
            "Understands the initial state of `ref.current`.",
            "Recognizes the potential for runtime errors if not checked.",
            "Applies defensive programming principles."
          ],
          "keyConcepts": [
            "Refs",
            "Null Checks",
            "Error Handling",
            "DOM Access",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Provides a clear and correct reason for the null check."
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Best Practices",
            "Error Handling"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_uncontrolled_1",
          "topic": "Uncontrolled Components Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is an 'uncontrolled component' in React?",
          "answer": "An uncontrolled component is a form component where the form data is handled by the DOM itself, rather than by React state. Refs are used to get the form value directly from the DOM when needed.",
          "options": [],
          "analysisPoints": [
            "Correctly defines uncontrolled components.",
            "Highlights the role of the DOM as the source of truth.",
            "Mentions refs as the mechanism for access."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Forms",
            "Refs",
            "DOM"
          ],
          "evaluationCriteria": [
            "Provides an accurate and concise definition."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components"
          ],
          "prerequisites": [
            "react_forms"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_2",
          "topic": "Controlled vs Uncontrolled Components",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast 'controlled components' and 'uncontrolled components' in React forms. When would you typically choose one over the other?",
          "answer": "**Controlled Components:**\n*   **Source of Truth:** React state is the single source of truth for form input values.\n*   **Data Flow:** Input values are controlled by React state. Changes are handled via `onChange` event handlers, which update state, causing re-renders.\n*   **Benefits:** Easier to implement validation, conditional input disabling, formatting, and immediate feedback. Predictable data flow.\n*   **When to Use:** Most common and recommended approach for form inputs in React, especially when you need to respond to every keystroke, perform real-time validation, or manipulate the input value.\n\n**Uncontrolled Components:**\n*   **Source of Truth:** The DOM itself is the source of truth for form input values.\n*   **Data Flow:** Input values are retrieved directly from the DOM using refs, typically when a form is submitted or a specific action occurs. React does not actively manage the input's value during typing.\n*   **Benefits:** Can be simpler for very basic forms where you only need the final value, or when integrating with non-React DOM libraries. Potentially fewer re-renders for simple inputs compared to constantly updating state.\n*   **When to Use:** Less common. Suitable for simple forms where you don't need real-time validation or intricate state management. Often used when integrating with third-party DOM libraries or when dealing with file inputs (where file data is naturally handled by the DOM).",
          "options": [],
          "analysisPoints": [
            "Defines both types of components accurately.",
            "Highlights the 'source of truth' difference.",
            "Explains the data flow for each.",
            "Lists clear advantages/disadvantages and appropriate use cases for both.",
            "Demonstrates understanding of form management paradigms in React."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "Forms",
            "React State",
            "Refs",
            "Data Flow",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Comprehensive and accurate comparison.",
            "Provides clear and justified recommendations for usage.",
            "Demonstrates strong knowledge of React form handling."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Uncontrolled Components",
            "Comparison"
          ],
          "prerequisites": [
            "react_forms",
            "react_state",
            "react_refs"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_3",
          "topic": "Accessing Uncontrolled Form Data",
          "level": "medium",
          "type": "mcq",
          "question": "You have an uncontrolled `<input type=\"text\" ref={myInputRef} />` in a functional component. How would you access the current value of this input when a submit button is clicked?",
          "answer": "B. `myInputRef.current.value`",
          "options": [
            "A. `myInputRef.value`",
            "B. `myInputRef.current.value`",
            "C. `myInputRef.current()`",
            "D. `myInputRef.getValue()`"
          ],
          "analysisPoints": [
            "Knows that `useRef` returns an object with a `current` property.",
            "Understands that form input values are accessed via the `value` property on the DOM element.",
            "Differentiates between the ref object and the actual DOM element."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Refs",
            "useRef",
            "DOM Access",
            "Form Inputs"
          ],
          "evaluationCriteria": [
            "Correctly identifies the property used to access the input value.",
            "Demonstrates practical knowledge of `useRef`."
          ],
          "example": "The `myInputRef` is the ref object itself. The actual DOM `<input>` element is assigned to its `.current` property. Once you have the DOM element via `myInputRef.current`, you can access its properties like `value` (for text inputs) or `files` (for file inputs), or call its methods like `focus()`.",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "useRef",
            "DOM"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_forms"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_4",
          "topic": "Uncontrolled File Inputs",
          "level": "medium",
          "type": "flashcard",
          "question": "Why are `<input type=\"file\">` elements commonly handled as uncontrolled components in React?",
          "answer": "File inputs are typically uncontrolled components because their value is read-only for security reasons (you cannot programmatically set the value of a file input). React recommends `defaultValue` for pre-filling but otherwise allows the user to interact directly with it. You retrieve the file data using a ref to `ref.current.files` when the form is submitted, rather than trying to control it with React state.",
          "options": [],
          "analysisPoints": [
            "Identifies the read-only nature of file inputs.",
            "Connects security restrictions to the uncontrolled paradigm.",
            "Explains how file data is accessed via `ref.current.files`."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "File Input",
            "Refs",
            "Security",
            "Forms"
          ],
          "evaluationCriteria": [
            "Provides a clear and accurate explanation for the specific case of file inputs."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "File Input"
          ],
          "prerequisites": [
            "react_forms",
            "react_refs"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_autofocus_functional_component",
          "title": "Implement Auto-Focus on a Search Input",
          "description": "\nCreate a React functional component `SearchBar` that automatically focuses its text input field when the component first mounts. The input should also have a placeholder text 'Search...'.\n\n1.  Use the `useRef` hook to create a ref for the input element.\n2.  Use the `useEffect` hook to apply focus to the input after the component mounts.\n3.  Ensure the focus logic runs only once.\n4.  Add a button that, when clicked, clears the input field and re-focuses it.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef, useEffect } from 'react';\n\nfunction SearchBar() {\n  // TODO: Create ref for the input\n  // TODO: Implement useEffect for auto-focus on mount\n\n  const handleClearAndFocus = () => {\n    // TODO: Clear input value and re-focus\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search...\"\n        // TODO: Attach ref\n      />\n      <button onClick={handleClearAndFocus}>Clear & Focus</button>\n    </div>\n  );\n}\n\nexport default SearchBar;",
          "solutionCode": "import React, { useRef, useEffect } from 'react';\n\nfunction SearchBar() {\n  const inputRef = useRef(null); // Create ref for the input\n\n  useEffect(() => {\n    // Auto-focus on mount\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array ensures this runs once after mount\n\n  const handleClearAndFocus = () => {\n    if (inputRef.current) {\n      inputRef.current.value = ''; // Clear input value\n      inputRef.current.focus();   // Re-focus\n    }\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search...\"\n        ref={inputRef} // Attach ref\n      />\n      <button onClick={handleClearAndFocus}>Clear & Focus</button>\n    </div>\n  );\n}\n\nexport default SearchBar;",
          "testCases": [
            "Component renders and the input field is automatically focused.",
            "Clicking 'Clear & Focus' button clears the input value and re-focuses the input."
          ],
          "hints": [
            "Remember that `useEffect` with an empty dependency array (`[]`) behaves like `componentDidMount`.",
            "To clear an input field imperatively, you can set its `value` property to an empty string.",
            "Always check `ref.current` before trying to use it."
          ],
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Forms",
            "UX"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_hooks_basics",
            "react_functional_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "autofocus_with_refs",
            "theory_use_ref_hook"
          ]
        },
        {
          "id": "task_class_component_ref_focus",
          "title": "Class Component: Dynamic Ref Focus Button",
          "description": "\nCreate a React class component named `TextFocusControl` that renders two input fields: 'First Name' and 'Last Name'.\n\nImplement two buttons:\n1.  'Focus First Name': When clicked, it should focus the 'First Name' input.\n2.  'Focus Last Name': When clicked, it should focus the 'Last Name' input.\n\nUse `React.createRef()` for each input.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass TextFocusControl extends React.Component {\n  constructor(props) {\n    super(props);\n    // TODO: Create refs for first and last name inputs\n  }\n\n  focusFirstName = () => {\n    // TODO: Implement focus logic for first name\n  };\n\n  focusLastName = () => {\n    // TODO: Implement focus logic for last name\n  };\n\n  render() {\n    return (\n      <div>\n        <label>\n          First Name:\n          <input type=\"text\" /> {/* TODO: Attach ref */}\n        </label>\n        <br />\n        <label>\n          Last Name:\n          <input type=\"text\" /> {/* TODO: Attach ref */}\n        </label>\n        <br />\n        <button onClick={this.focusFirstName}>Focus First Name</button>\n        <button onClick={this.focusLastName}>Focus Last Name</button>\n      </div>\n    );\n  }\n}\n\nexport default TextFocusControl;",
          "solutionCode": "import React from 'react';\n\nclass TextFocusControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.firstNameRef = React.createRef();\n    this.lastNameRef = React.createRef();\n  }\n\n  focusFirstName = () => {\n    if (this.firstNameRef.current) {\n      this.firstNameRef.current.focus();\n    }\n  };\n\n  focusLastName = () => {\n    if (this.lastNameRef.current) {\n      this.lastNameRef.current.focus();\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        <label>\n          First Name:\n          <input type=\"text\" ref={this.firstNameRef} />\n        </label>\n        <br />\n        <label>\n          Last Name:\n          <input type=\"text\" ref={this.lastNameRef} />\n        </label>\n        <br />\n        <button onClick={this.focusFirstName}>Focus First Name</button>\n        <button onClick={this.focusLastName}>Focus Last Name</button>\n      </div>\n    );\n  }\n}\n\nexport default TextFocusControl;",
          "testCases": [
            "Component renders with two input fields and two buttons.",
            "Clicking 'Focus First Name' button puts focus on the 'First Name' input.",
            "Clicking 'Focus Last Name' button puts focus on the 'Last Name' input."
          ],
          "hints": [
            "Remember to create a separate `React.createRef()` instance for each element you want to reference.",
            "Refs should be initialized in the constructor for class components.",
            "Always use the `.current` property to access the actual DOM element."
          ],
          "tags": [
            "React",
            "Class Components",
            "Refs",
            "createRef",
            "DOM Manipulation",
            "Forms"
          ],
          "timeEstimate": 35,
          "prerequisites": [
            "react_class_components",
            "react_createRef"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_refs_class_components",
            "autofocus_with_refs"
          ]
        },
        {
          "id": "task_timer_with_ref",
          "title": "Build a Stopwatch with Ref for Interval ID",
          "description": "\nCreate a React functional component `Stopwatch` that displays a continuously incrementing timer.\n\nRequirements:\n1.  The timer should start automatically when the component mounts.\n2.  Use `useRef` to store the `setInterval` ID to enable cleanup.\n3.  Use `useState` to manage and display the elapsed time (in seconds).\n4.  Implement a 'Stop' button that clears the interval and stops the timer.\n5.  Implement a 'Reset' button that stops the timer and resets the count to 0.\n6.  Ensure the timer correctly cleans up when the component unmounts.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction Stopwatch() {\n  const intervalRef = useRef(null); // Used to store interval ID\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    // TODO: Start interval and store its ID in intervalRef.current\n\n    return () => {\n      // TODO: Cleanup interval when component unmounts\n    };\n  }, []); // Empty dependency array for componentDidMount-like behavior\n\n  const stopTimer = () => {\n    // TODO: Clear interval\n  };\n\n  const resetTimer = () => {\n    // TODO: Clear interval and reset seconds to 0\n  };\n\n  return (\n    <div>\n      <h1>Stopwatch: {seconds}s</h1>\n      <button onClick={stopTimer}>Stop</button>\n      <button onClick={resetTimer}>Reset</button>\n    </div>\n  );\n}\n\nexport default Stopwatch;",
          "solutionCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction Stopwatch() {\n  const intervalRef = useRef(null); // Used to store interval ID\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    // Start interval and store its ID in intervalRef.current\n    intervalRef.current = setInterval(() => {\n      setSeconds(prevSeconds => prevSeconds + 1);\n    }, 1000);\n\n    return () => {\n      // Cleanup: Clear interval when component unmounts\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []); // Empty dependency array for componentDidMount-like behavior\n\n  const stopTimer = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null; // Important to nullify after clearing\n    }\n  };\n\n  const resetTimer = () => {\n    stopTimer(); // Reuse stop logic\n    setSeconds(0);\n  };\n\n  return (\n    <div>\n      <h1>Stopwatch: {seconds}s</h1>\n      <button onClick={stopTimer}>Stop</button>\n      <button onClick={resetTimer}>Reset</button>\n    </div>\n  );\n}\n\nexport default Stopwatch;",
          "testCases": [
            "Component mounts and timer starts incrementing every second.",
            "Clicking 'Stop' button pauses the timer at its current value.",
            "Clicking 'Reset' button stops the timer and resets the displayed seconds to 0.",
            "Verify in browser dev tools that the `setInterval` is cleared upon component unmount (e.g., navigating away or conditionally rendering the component)."
          ],
          "hints": [
            "The `setInterval` function returns an ID that you need to pass to `clearInterval`.",
            "`useRef` is perfect for storing the interval ID because it persists across renders and doesn't trigger re-renders when updated.",
            "The `useEffect` cleanup function (`return () => {...}`) is crucial for preventing memory leaks."
          ],
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "useState",
            "Timers",
            "Side Effects",
            "Cleanup"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_basics",
            "javascript_timers"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_use_ref_hook",
            "theory_autofocus_with_refs"
          ]
        },
        {
          "id": "task_uncontrolled_login_form",
          "title": "Implement an Uncontrolled Login Form",
          "description": "\nCreate a React functional component `LoginForm` that uses refs to handle form data for a username and password, without using React state to manage input values.\n\nRequirements:\n1.  Render two input fields: one for 'Username' and one for 'Password'.\n2.  Use `useRef` to create a separate ref for each input.\n3.  Implement a 'Submit' button.\n4.  On form submission, prevent the default browser behavior.\n5.  Access the current values of the username and password inputs directly via their refs.\n6.  Log the username and password to the console when the form is submitted.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef } from 'react';\n\nfunction LoginForm() {\n  // TODO: Create refs for username and password inputs\n\n  const handleSubmit = (event) => {\n    // TODO: Prevent default form submission\n    // TODO: Access input values via refs and log them\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Username:\n        <input type=\"text\" /> {/* TODO: Attach ref */}\n      </label>\n      <br />\n      <label>\n        Password:\n        <input type=\"password\" /> {/* TODO: Attach ref */}\n      </label>\n      <br />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nexport default LoginForm;",
          "solutionCode": "import React, { useRef } from 'react';\n\nfunction LoginForm() {\n  const usernameRef = useRef(null);\n  const passwordRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault(); // Prevent default form submission\n\n    const username = usernameRef.current ? usernameRef.current.value : '';\n    const password = passwordRef.current ? passwordRef.current.value : '';\n\n    console.log('Username:', username);\n    console.log('Password:', password);\n\n    // In a real app, you'd send this to an API or perform authentication\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Username:\n        <input type=\"text\" ref={usernameRef} />\n      </label>\n      <br />\n      <label>\n        Password:\n        <input type=\"password\" ref={passwordRef} />\n      </label>\n      <br />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nexport default LoginForm;",
          "testCases": [
            "Component renders with username and password input fields and a submit button.",
            "Enter values in both fields and click 'Login'. Verify that the console logs the correct username and password.",
            "Test with empty inputs to ensure `value` access doesn't throw errors (e.g., `ref.current` might be null or value is empty string)."
          ],
          "hints": [
            "Remember to call `event.preventDefault()` in the submit handler to stop the browser's default form submission behavior.",
            "Access the input value using the `.current` property of the ref, followed by the `.value` property of the DOM element.",
            "It's good practice to check if `ref.current` exists before trying to access its properties."
          ],
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "useRef",
            "Event Handling",
            "DOM"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "react_forms",
            "react_hooks_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_uncontrolled_components",
            "theory_use_ref_hook"
          ]
        }
      ]
    }
  },
  {
    "id": "e4fbbc01-c6ff-4ee2-ab4e-695915cf88ef",
    "startLine": 4000,
    "endLine": 4099,
    "processedDate": "2025-06-17T09:02:20.772Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_uncontrolled_components",
          "title": "Uncontrolled Components in React",
          "content": "Uncontrolled components are a way to handle form data in React where the form data is handled by the DOM itself, rather than by React state. In this approach, instead of writing an event handler for every state update, you use a ref to get the form values directly from the DOM when the form is submitted. This is similar to how HTML forms work without React.\n\n### Key Concepts\n-   **DOM as Source of Truth:** The input elements maintain their own internal state, and you query the DOM using refs to get their current value.\n-   **`React.createRef()`:** Used to create a ref that can be attached to a DOM element (or a class component instance) in the `render` method.\n-   **`this.refName.current`:** After the component mounts, the `current` property of the ref object will hold a reference to the DOM element (e.g., `<input>`). You can then access its properties like `value` or `files`.\n-   **File Inputs:** File inputs are always uncontrolled because their value can only be set by a user, not programmatically by React.\n-   **`defaultValue` and `defaultChecked`:** For initial values, uncontrolled components use `defaultValue` (for text inputs, select, textarea) or `defaultChecked` (for checkboxes/radio buttons) instead of `value` or `checked` which are used for controlled components.\n\n### Use Cases\nUncontrolled components are useful in specific scenarios:\n-   **Integrating with non-React code:** When you need to interact with DOM elements managed by libraries or code outside of React.\n-   **Simpler code for basic forms:** For forms with very few inputs where direct DOM access might seem simpler than managing multiple state variables.\n-   **Working with file inputs:** File inputs are inherently uncontrolled as their value cannot be set by JavaScript for security reasons.\n\n### Limitations\nFor most form scenarios, controlled components are recommended because they provide more reactive control over form data, easier validation, and immediate feedback. Uncontrolled components can make it harder to implement features like instant input validation, conditionally disabling the submit button, or enforcing input format.\n\n### Example Code Structure\n```typescript\nimport React from 'react';\n\nclass UncontrolledForm extends React.Component {\n  constructor(props) {\n    super(props);\n    // Create refs to access DOM elements directly\n    this.input = React.createRef();\n    this.fileInput = React.createRef();\n  }\n\n  handleSubmit = (event) => {\n    // Prevent default form submission behavior (page reload)\n    event.preventDefault();\n    \n    // Access input values directly from the DOM using refs\n    const inputValue = this.input.current.value;\n    const fileValue = this.fileInput.current.files[0]; // For file input, files[0] gets the first selected file\n    \n    // Process the form data\n    console.log('Input Value:', inputValue);\n    console.log('Selected File:', fileValue);\n    \n    // You can still send the form data to a server or parent component\n    this.props.onSubmit({ inputValue, fileValue });\n  };\n  \n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <div>\n          <label htmlFor=\"name\">Name:</label>\n          <input\n            id=\"name\"\n            className=\"form-input\"\n            defaultValue=\"\" // Use defaultValue for initial value in uncontrolled components\n            placeholder=\"Enter your name\"\n            ref={this.input} // Attach the ref to the input element\n          />\n        </div>\n        \n        <div>\n          <label htmlFor=\"file\">Upload File:</label>\n          <input\n            id=\"file\"\n            type=\"file\"\n            ref={this.fileInput} // Attach ref to file input\n          />\n        </div>\n        \n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  }\n}\n\n// Example Usage (conceptual, not in original content but good for context)\n// <UncontrolledForm onSubmit={(data) => console.log('Form submitted:', data)} />\n```",
          "examples": [
            {
              "id": "example_uncontrolled_1",
              "title": "Basic Uncontrolled Text Input",
              "code": "import React, { useRef } from 'react';\n\nfunction NameForm() {\n  const nameInputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert('A name was submitted: ' + nameInputRef.current.value);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input type=\"text\" ref={nameInputRef} defaultValue=\"Bob\" />\n      </label>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}",
              "explanation": "This example demonstrates a basic uncontrolled text input. The `useRef` hook is used in a functional component to create a ref. The `ref` is then attached to the input element. When the form is submitted, `nameInputRef.current.value` directly accesses the current value from the DOM.",
              "language": "typescript"
            },
            {
              "id": "example_uncontrolled_file_input",
              "title": "Uncontrolled File Input",
              "code": "import React, { useRef } from 'react';\n\nfunction FileUploadForm() {\n  const fileInputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const file = fileInputRef.current.files[0];\n    if (file) {\n      console.log('Selected file:', file.name, file.type, file.size, 'bytes');\n      // In a real application, you would upload this file to a server\n    } else {\n      console.log('No file selected.');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Upload File:\n        <input type=\"file\" ref={fileInputRef} />\n      </label>\n      <button type=\"submit\">Upload</button>\n    </form>\n  );\n}",
              "explanation": "This example shows how to handle a file input, which is always an uncontrolled component. The `useRef` hook provides access to the underlying DOM file input element. Upon submission, `fileInputRef.current.files[0]` retrieves the first selected file, which can then be processed (e.g., uploaded).",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Refs",
            "DOM Interaction"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "react_state",
            "dom_manipulation"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "controlled_components",
            "react_hooks",
            "form_validation"
          ]
        },
        {
          "id": "theory_ref_forwarding",
          "title": "Ref Forwarding in React",
          "content": "Ref forwarding is a technique in React for automatically passing a ref from a parent component through to one of its children's underlying DOM elements or class component instances. This is particularly useful for building reusable component libraries, allowing consumers of a component to get a direct reference to an internal DOM node.\n\n### Why Ref Forwarding?\nBy default, when you attach a ref to a custom component (e.g., `<MyComponent ref={myRef} />`), `myRef` will receive the instance of `MyComponent` itself, not the DOM element rendered *by* `MyComponent`. If `MyComponent` renders an `input` element and you want to directly access that `input`'s DOM node (e.g., to focus it), you need ref forwarding.\n\n### `React.forwardRef()` API\n`React.forwardRef()` is a higher-order component that takes a render function. This function receives `props` as its first argument and `ref` as its second argument. The `ref` argument is the ref that was passed to the `forwardRef` component by its parent. You then attach this `ref` to the desired underlying DOM element or class component instance.\n\n```jsx\nReact.forwardRef((props, ref) => {\n  // Inside this function, `ref` is the ref from the parent\n  return <DOMElement ref={ref} {...props} />;\n});\n```\n\n### Key Principles\n-   `ref` is not a regular prop: React handles `ref` specially, similar to `key`. It's not passed down automatically via the `props` object.\n-   Allows parent to interact with child's DOM: Enables common patterns like imperatively triggering focus, selection, or animations on a child's DOM node.\n-   Enhances reusability: Makes your components more flexible and composable, as their internal DOM elements can be manipulated by their parents when necessary.\n\n### When to use?\n-   **Imperative animations:** Triggering animations on child DOM nodes.\n-   **Managing focus, text selection, or media playback:** For example, focusing an input field after a button click.\n-   **Integrating with third-party DOM libraries:** When you need a direct reference to a DOM element for integration.\n\n```typescript\nimport React from 'react';\n\n// ButtonElement is a functional component that forwards its ref to the native <button> DOM element.\nconst ButtonElement = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"CustomButton\">\n    {props.children}\n  </button>\n));\n\n// Usage example:\nclass ParentComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // Create a ref that will eventually hold the DOM button element\n    this.buttonRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // After the component mounts, buttonRef.current will refer to the <button> DOM node\n    if (this.buttonRef.current) {\n      console.log('Button DOM element:', this.buttonRef.current);\n      this.buttonRef.current.focus(); // Example: focus the button\n    }\n  }\n\n  render() {\n    return (\n      // Pass the ref to ButtonElement, which then forwards it to its internal <button>\n      <ButtonElement ref={this.buttonRef}>{'Forward Ref Example'}</ButtonElement>\n    );\n  }\n}\n\n// You can also use useRef hook in functional components:\n// import React, { useRef, useEffect } from 'react';\n// function FunctionalParent() {\n//   const buttonRef = useRef(null);\n//   useEffect(() => {\n//     if (buttonRef.current) {\n//       console.log('Button DOM element (functional):', buttonRef.current);\n//       buttonRef.current.click(); // Example: programmatically click the button\n//     }\n//   }, []);\n//   return <ButtonElement ref={buttonRef}>{'Click Me'}</ButtonElement>;\n// }\n```",
          "examples": [
            {
              "id": "example_ref_forwarding_input",
              "title": "Ref Forwarding for an Input Component",
              "code": "import React, { useRef, useEffect } from 'react';\n\n// MyInput component forwards the ref to the native <input> element\nconst MyInput = React.forwardRef((props, ref) => (\n  <input type=\"text\" ref={ref} placeholder=\"Type something...\" {...props} />\n));\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // Focus the input when the component mounts\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []);\n\n  const handleClick = () => {\n    if (inputRef.current) {\n      alert('Input value: ' + inputRef.current.value);\n    }\n  };\n\n  return (\n    <div>\n      <MyInput ref={inputRef} />\n      <button onClick={handleClick}>Get Input Value</button>\n    </div>\n  );\n}",
              "explanation": "This example shows how to create a custom `MyInput` component that correctly forwards a ref to its internal HTML `input` element. The parent `App` component can then use `useRef` to get a direct reference to the DOM input and perform imperative actions like `focus()` or access its `value`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding",
            "DOM Interaction",
            "Component Design"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_refs",
            "functional_components",
            "useRef_hook"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "higher_order_components",
            "render_props_pattern",
            "component_libraries"
          ]
        },
        {
          "id": "theory_ref_forwarding_hocs",
          "title": "Ref Forwarding in Higher-Order Components (HOCs)",
          "content": "Higher-Order Components (HOCs) are functions that take a component and return a new component. They are a powerful pattern for reusing component logic. However, a common pitfall arises when using refs with HOCs.\n\n### The Problem with Refs and HOCs\nBy default, if you add a ref to a component wrapped by an HOC (e.g., `<MyHOCWrappedComponent ref={myRef} />`), the `myRef` will not refer to the original `WrappedComponent` instance or its internal DOM node. Instead, it will refer to the instance of the *outermost wrapper component* created by the HOC.\n\nThis happens because `ref` is not a regular prop; React handles it specially. When `MyHOCWrappedComponent` is rendered, React sees the `ref` on the element created by the HOC itself, not the `WrappedComponent` that the HOC is rendering internally. This prevents you from directly accessing the underlying component or its DOM element.\n\n### The Solution: Using `React.forwardRef` within HOCs\nTo correctly forward refs through an HOC, you need to combine `React.forwardRef` with the HOC pattern. The `React.forwardRef` API allows the HOC to receive the ref passed by the parent and explicitly pass it down to the `WrappedComponent`.\n\nHere's how it works:\n1.  **Define the HOC:** The HOC function takes a `Component` as an argument.\n2.  **Create an internal wrapper component:** This component (e.g., `LogProps` in the example) will render the `Component` passed to the HOC.\n3.  **Use `React.forwardRef` for the HOC's return value:** The HOC's return value is now a `React.forwardRef` call. This `forwardRef`'s render function receives the `props` and the `ref` from the parent.\n4.  **Pass the forwarded ref as a prop:** Inside the `forwardRef`'s render function, you extract the `ref` (often renamed to `forwardedRef` to avoid naming conflicts with original props) and pass it as a *regular prop* to the internal wrapper component (e.g., `<LogProps forwardedRef={ref} />`).\n5.  **Attach the prop to the wrapped component:** Inside the internal wrapper component's `render` method, you attach `this.props.forwardedRef` to the actual `WrappedComponent` (`<Component ref={forwardedRef} />`).\n\nThis ensures that the ref from the parent ultimately attaches to the `WrappedComponent`, allowing direct access to its instance or its internal DOM element (if the `WrappedComponent` itself uses `React.forwardRef`).\n\n```typescript\nimport React from 'react';\n\n// A Higher-Order Component that logs props and forwards refs\nfunction logProps(Component) {\n  class LogProps extends React.Component {\n    componentDidUpdate(prevProps) {\n      console.log('old props:', prevProps);\n      console.log('new props:', this.props);\n    }\n    \n    render() {\n      // Extract the forwarded ref from props (it's passed as a regular prop here)\n      const { forwardedRef, ...rest } = this.props;\n      \n      // Pass the ref to the wrapped component using its 'ref' attribute\n      // 'Component' itself must be a functional component wrapped with React.forwardRef\n      // OR a class component.\n      return <Component ref={forwardedRef} {...rest} />;\n    }\n  }\n  \n  // Use React.forwardRef to allow the HOC itself to receive a ref\n  // and pass it down to the LogProps wrapper.\n  return React.forwardRef((props, ref) => {\n    // Here, 'ref' is the ref from the parent that rendered the HOC-wrapped component.\n    // We pass it to LogProps as a regular prop named 'forwardedRef'.\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n// Example usage:\n// First, define a component that can receive a ref (e.g., using forwardRef itself)\nconst MyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} onClick={props.onClick}>\n    {props.children}\n  </button>\n));\n\n// Now, wrap MyButton with the logProps HOC\nconst LoggedButton = logProps(MyButton);\n\n// A parent component that uses the HOC-wrapped component and attaches a ref\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.buttonRef = React.createRef();\n  }\n\n  componentDidMount() {\n    if (this.buttonRef.current) {\n      console.log('Direct DOM access via HOC-forwarded ref:', this.buttonRef.current);\n      this.buttonRef.current.focus(); // We can focus the actual button!\n    }\n  }\n\n  handleClick = () => {\n    alert('Button clicked!');\n  };\n\n  render() {\n    return (\n      <LoggedButton ref={this.buttonRef} onClick={this.handleClick}>\n        Click Me (Logged & Ref-Forwarded)\n      </LoggedButton>\n    );\n  }\n}\n\n// To use this, render <App />\n```",
          "examples": [
            {
              "id": "example_hoc_ref_forwarding_basic",
              "title": "HOC for Input with Ref Forwarding",
              "code": "import React, { useRef, useEffect } from 'react';\n\n// HOC: withLogging that logs renders and forwards refs\nfunction withLogging(WrappedComponent) {\n  class WithLogging extends React.Component {\n    componentDidMount() {\n      console.log(`${WrappedComponent.name || 'Component'} mounted.`);\n    }\n\n    render() {\n      const { forwardedRef, ...restProps } = this.props;\n      return <WrappedComponent ref={forwardedRef} {...restProps} />;\n    }\n  }\n\n  return React.forwardRef((props, ref) => {\n    return <WithLogging {...props} forwardedRef={ref} />;\n  });\n}\n\n// A simple input component that supports ref forwarding\nconst MyInput = React.forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} placeholder={props.placeholder} />;\n});\n\n// Create a logged version of MyInput\nconst LoggedInput = withLogging(MyInput);\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n      console.log('Input focused via forwarded ref in HOC!');\n    }\n  }, []);\n\n  return (\n    <div>\n      <h1>HOC Ref Forwarding Demo</h1>\n      <LoggedInput ref={inputRef} placeholder=\"Enter text here\" />\n    </div>\n  );\n}",
              "explanation": "This example demonstrates how to correctly forward refs through a Higher-Order Component (`withLogging`). `withLogging` takes `MyInput` (which itself uses `React.forwardRef`) and returns a new component `LoggedInput`. The key is that `withLogging` wraps `MyInput` with `React.forwardRef` to intercept the parent's ref and pass it down as a regular prop (`forwardedRef`) to its internal `WithLogging` component, which then attaches it to the `WrappedComponent` (`MyInput`). This allows `App` to directly focus the actual `<input>` element.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "HOCs",
            "Ref Forwarding",
            "Advanced React",
            "Component Patterns"
          ],
          "technology": "React",
          "prerequisites": [
            "react_hocs",
            "react_forwardRef",
            "react_class_components",
            "react_functional_components"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "custom_hooks",
            "render_props_vs_hocs",
            "performance_optimization_react"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_uncontrolled_components_1",
          "topic": "Uncontrolled Components",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary mechanism used to access data from an uncontrolled component in React?",
          "answer": "Refs",
          "options": [],
          "analysisPoints": [
            "Uncontrolled components directly interact with the DOM.",
            "Refs provide a way to access the underlying DOM nodes."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Refs",
            "DOM Interaction"
          ],
          "evaluationCriteria": [
            "Recall of fundamental concepts.",
            "Understanding of ref purpose."
          ],
          "example": "Refs are used to get the current value of an input field in an uncontrolled component, for example, `this.inputRef.current.value`.",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Refs"
          ],
          "prerequisites": [
            "react_basics",
            "react_refs"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_uncontrolled_components_2",
          "topic": "Uncontrolled Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is **most** suitable for using an uncontrolled component in React?",
          "answer": "Integrating React with an existing jQuery-based form.",
          "options": [
            "Implementing a live search filter with immediate feedback.",
            "Building a multi-step form with complex validation rules.",
            "Creating a custom controlled input component for a design system.",
            "Integrating React with an existing jQuery-based form."
          ],
          "analysisPoints": [
            "Uncontrolled components shine when React isn't the sole owner of the DOM.",
            "Scenarios requiring immediate feedback or complex logic are better suited for controlled components.",
            "Custom components for design systems typically aim for controlled behavior for consistency."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Controlled Components",
            "Use Cases",
            "Interoperability"
          ],
          "evaluationCriteria": [
            "Ability to identify appropriate use cases for different component types.",
            "Understanding of React's paradigm for forms."
          ],
          "example": "Uncontrolled components are ideal when you need to integrate React with non-React DOM manipulation, such as a legacy form handled by jQuery, where you don't want React to fully manage the input's state.",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Use Cases",
            "Integration"
          ],
          "prerequisites": [
            "react_forms",
            "controlled_components"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_components_3",
          "topic": "Uncontrolled Components",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference in how `defaultValue` is used in uncontrolled components versus `value` in controlled components. Why does React make this distinction?",
          "answer": "In uncontrolled components, `defaultValue` is used to set the initial value of an input field. After the component mounts, the DOM element manages its own state, and React doesn't control subsequent updates. You access the current value directly from the DOM using a ref when needed (e.g., on form submission).\n\nIn controlled components, `value` is used to set the current value of an input field. The `value` prop is typically tied to a piece of React state, and an `onChange` event handler is used to update that state. React is the 'single source of truth' for the input's value, and every render reflects the state. This allows React to control the input's behavior programmatically, enabling features like immediate validation, formatting, or conditional disabling.\n\nReact makes this distinction to clearly separate the 'source of truth' for form data. For controlled components, React state is the source of truth, enabling full declarative control. For uncontrolled components, the DOM itself is the source of truth, facilitating simpler integration with non-React code or for simple use cases where full control isn't necessary, like file inputs.",
          "options": [],
          "analysisPoints": [
            "Understanding of data flow in controlled vs. uncontrolled.",
            "Role of React state in controlled components.",
            "Role of DOM in uncontrolled components.",
            "Reasons for React's design choices (control vs. simplicity/interop)."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "defaultValue",
            "value",
            "State Management",
            "DOM as Source of Truth"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Accuracy of concepts.",
            "Depth of understanding on design principles."
          ],
          "example": "```jsx\n// Uncontrolled:\n<input type=\"text\" defaultValue=\"Initial Name\" ref={nameRef} />\n\n// Controlled:\n<input type=\"text\" value={this.state.name} onChange={this.handleChange} />\n```",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Uncontrolled Components",
            "State"
          ],
          "prerequisites": [
            "react_state",
            "controlled_components_vs_uncontrolled"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_components_4",
          "topic": "Uncontrolled Components",
          "level": "hard",
          "type": "code",
          "question": "Given the following controlled component, refactor it into an uncontrolled component. The component should still submit the username and password, but now by directly accessing DOM values via refs. Ensure `event.preventDefault()` is called.",
          "answer": "```typescript\nimport React, { useRef } from 'react';\n\nfunction LoginFormUncontrolled({ onSubmit }) {\n  const usernameRef = useRef(null);\n  const passwordRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const username = usernameRef.current.value;\n    const password = passwordRef.current.value;\n    onSubmit({ username, password });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input type=\"text\" id=\"username\" ref={usernameRef} defaultValue=\"\" />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" ref={passwordRef} defaultValue=\"\" />\n      </div>\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\n// Example usage:\n// function App() {\n//   const handleLogin = (data) => {\n//     console.log('Uncontrolled Login Data:', data);\n//     alert(`Login attempt for: ${data.username}`);\n//   };\n//   return <LoginFormUncontrolled onSubmit={handleLogin} />;\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `useRef` hook (or `React.createRef` for class components).",
            "Attaching refs to the correct input elements.",
            "Accessing `current.value` from the refs.",
            "Replacing `value` and `onChange` with `defaultValue`.",
            "Properly preventing default form submission."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Refs",
            "Form Handling",
            "Functional Components",
            "useRef"
          ],
          "evaluationCriteria": [
            "Correct application of refs for data access.",
            "Appropriate removal of controlled component patterns.",
            "Functional correctness."
          ],
          "example": "```typescript\n// Original controlled component (for context, not part of the question's provided content)\n// import React, { useState } from 'react';\n// function LoginFormControlled({ onSubmit }) {\n//   const [username, setUsername] = useState('');\n//   const [password, setPassword] = useState('');\n//   const handleSubmit = (event) => {\n//     event.preventDefault();\n//     onSubmit({ username, password });\n//   };\n//   return (\n//     <form onSubmit={handleSubmit}>\n//       <div>\n//         <label htmlFor=\"username\">Username:</label>\n//         <input type=\"text\" id=\"username\" value={username} onChange={(e) => setUsername(e.target.value)} />\n//       </div>\n//       <div>\n//         <label htmlFor=\"password\">Password:</label>\n//         <input type=\"password\" id=\"password\" value={password} onChange={(e) => setPassword(e.target.value)} />\n//       </div>\n//       <button type=\"submit\">Login</button>\n//     </form>\n//   );\n// }\n\n// Refactored uncontrolled component provided in the answer section.\n```",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Code Challenge",
            "Refactoring"
          ],
          "prerequisites": [
            "react_forms",
            "react_refs",
            "controlled_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ref_forwarding_1",
          "topic": "Ref Forwarding",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `React.forwardRef()`?",
          "answer": "To allow a component to pass a ref it receives down to one of its children, typically a DOM element.",
          "options": [],
          "analysisPoints": [
            "Focus on the 'passing down' aspect of refs.",
            "Distinction from regular refs on custom components."
          ],
          "keyConcepts": [
            "Ref Forwarding",
            "React.forwardRef",
            "Refs"
          ],
          "evaluationCriteria": [
            "Recall of API purpose."
          ],
          "example": "```jsx\nconst MyComponent = React.forwardRef((props, ref) => (\n  <input ref={ref} type=\"text\" />\n));\n// Parent uses: <MyComponent ref={inputRef} />\n```",
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding"
          ],
          "prerequisites": [
            "react_refs"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ref_forwarding_2",
          "topic": "Ref Forwarding",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following component:\n\n```jsx\nfunction CustomButton(props) {\n  return <button className=\"btn\">{props.children}</button>;\n}\n\n// Parent component wants to focus the button:\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.buttonRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // This will currently try to focus the CustomButton component instance, not the DOM button\n    // this.buttonRef.current.focus(); \n  }\n\n  render() {\n    return <CustomButton ref={this.buttonRef}>Click Me</CustomButton>;\n  }\n}\n```\n\nTo allow `App` to directly focus the underlying `<button>` DOM element inside `CustomButton`, what modification is required for `CustomButton`?",
          "answer": "Wrap `CustomButton` with `React.forwardRef` and pass the received ref to the `<button>` element.",
          "options": [
            "Add a `ref` prop to `CustomButton` and pass it down as `props.ref` to the `<button>` element.",
            "Change `CustomButton` to a class component and make the `<button>` a class property.",
            "Wrap `CustomButton` with `React.forwardRef` and pass the received ref to the `<button>` element.",
            "Use `document.getElementById` in `App` to get the button element directly."
          ],
          "analysisPoints": [
            "Refs are not regular props and are not automatically passed down.",
            "`React.forwardRef` is the explicit API for this purpose.",
            "Accessing DOM directly outside React (e.g., `getElementById`) is discouraged when React provides a mechanism.",
            "Class components can receive refs, but `forwardRef` is specifically for passing them *through* a component to its children.",
            "The second argument of the `forwardRef` render function is the ref to be forwarded."
          ],
          "keyConcepts": [
            "Ref Forwarding",
            "React.forwardRef",
            "Refs",
            "DOM Interaction",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Understanding of `forwardRef` mechanics.",
            "Ability to identify incorrect ref handling patterns.",
            "Problem-solving in component interaction."
          ],
          "example": "```jsx\n// Corrected CustomButton:\nconst CustomButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"btn\">{props.children}</button>\n));\n\n// Parent usage remains the same:\n// <CustomButton ref={this.buttonRef}>Click Me</CustomButton>\n```",
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding",
            "MCQ",
            "Component Interaction"
          ],
          "prerequisites": [
            "react_refs",
            "functional_components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ref_forwarding_3",
          "topic": "Ref Forwarding",
          "level": "hard",
          "type": "code",
          "question": "Implement a `FocusableInput` functional component in React that takes a `label` prop and an arbitrary `type` prop (e.g., 'text', 'password'). This component should render a `label` and an `input` element. Critically, it must expose the `input` element's DOM node via ref forwarding, so a parent component can programmatically focus the input. Provide an example of how a parent component would use and focus this `FocusableInput`.",
          "answer": "```typescript\nimport React, { useRef, useEffect } from 'react';\n\n// FocusableInput component using React.forwardRef\nconst FocusableInput = React.forwardRef(({ label, type, ...props }, ref) => {\n  return (\n    <div>\n      <label>{label}: </label>\n      <input type={type} ref={ref} {...props} />\n    </div>\n  );\n});\n\n// Parent component to demonstrate usage\nfunction ParentComponent() {\n  const usernameInputRef = useRef(null);\n  const passwordInputRef = useRef(null);\n\n  useEffect(() => {\n    // Focus the username input when the component mounts\n    if (usernameInputRef.current) {\n      usernameInputRef.current.focus();\n    }\n  }, []);\n\n  const handleFocusPassword = () => {\n    if (passwordInputRef.current) {\n      passwordInputRef.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <h1>Login Form</h1>\n      <FocusableInput ref={usernameInputRef} label=\"Username\" type=\"text\" placeholder=\"Enter username\" />\n      <FocusableInput ref={passwordInputRef} label=\"Password\" type=\"password\" placeholder=\"Enter password\" style={{ marginTop: '10px' }} />\n      <button onClick={handleFocusPassword} style={{ marginLeft: '10px' }}>Focus Password Field</button>\n    </div>\n  );\n}\n\n// Example usage: <ParentComponent />\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `React.forwardRef` with two arguments (`props`, `ref`).",
            "Passing the `ref` argument directly to the `input` element.",
            "Destructuring `label` and `type` from `props` and spreading `...props` to allow other HTML attributes.",
            "Demonstrating parent component's use of `useRef` to interact with the forwarded ref.",
            "Ability to programmatically focus the input.",
            "Handles arbitrary `type` prop correctly."
          ],
          "keyConcepts": [
            "Ref Forwarding",
            "React.forwardRef",
            "Functional Components",
            "useRef Hook",
            "Imperative Handles"
          ],
          "evaluationCriteria": [
            "Correct implementation of ref forwarding.",
            "Clear demonstration of usage in parent component.",
            "Handling of props and DOM attributes.",
            "Code readability and best practices."
          ],
          "example": "The solution code above serves as the example.",
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding",
            "Code Challenge",
            "Component Design",
            "Hooks"
          ],
          "prerequisites": [
            "react_functional_components",
            "useRef_hook"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_ref_forwarding_1",
          "topic": "Ref Forwarding in HOCs",
          "level": "medium",
          "type": "mcq",
          "question": "When applying a Higher-Order Component (HOC) like `withAuth` to `MyComponent` (`const EnhancedComponent = withAuth(MyComponent);`), and then attempting to attach a ref to `EnhancedComponent` (`<EnhancedComponent ref={myRef} />`), what does `myRef.current` typically refer to by default, without any special handling?",
          "answer": "The instance of the wrapper component created by the `withAuth` HOC.",
          "options": [
            "The DOM element of `MyComponent`.",
            "The instance of `MyComponent` itself.",
            "An error, as refs cannot be used with HOCs.",
            "The instance of the wrapper component created by the `withAuth` HOC."
          ],
          "analysisPoints": [
            "Refs are not regular props; they are handled specially by React.",
            "Without `forwardRef`, the ref attaches to the immediate element it's applied to.",
            "In an HOC, the immediate element is the wrapper component.",
            "The problem `React.forwardRef` in HOCs solves."
          ],
          "keyConcepts": [
            "HOCs",
            "Refs",
            "Ref Forwarding",
            "Wrapper Components"
          ],
          "evaluationCriteria": [
            "Understanding of default ref behavior with HOCs.",
            "Knowledge of React's special handling of refs."
          ],
          "example": "```jsx\nfunction withAuth(Component) {\n  class AuthWrapper extends React.Component {\n    render() {\n      return <Component {...this.props} />;\n    }\n  }\n  return AuthWrapper;\n}\nconst EnhancedComponent = withAuth(MyComponent);\n// If you do <EnhancedComponent ref={myRef} />, myRef.current will be an instance of AuthWrapper, not MyComponent.\n```",
          "tags": [
            "React",
            "HOCs",
            "Refs",
            "Ref Forwarding",
            "MCQ"
          ],
          "prerequisites": [
            "react_hocs",
            "react_refs"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_ref_forwarding_2",
          "topic": "Ref Forwarding in HOCs",
          "level": "medium",
          "type": "open",
          "question": "Describe the problem that occurs when trying to pass a ref through a Higher-Order Component (HOC) by default, and explain how `React.forwardRef` resolves this problem.",
          "answer": "The problem with passing a ref through a HOC by default is that `ref` is a special prop in React, not a regular prop. When you attach a ref to a component wrapped by an HOC (e.g., `<MyHOCWrappedComponent ref={myRef} />`), `myRef` will receive the instance of the *outermost wrapper component* created by the HOC, not the `WrappedComponent` or its internal DOM node that you might intend to reference. This means you cannot directly access or manipulate the underlying component's instance or its elements.\n\n`React.forwardRef` resolves this problem by explicitly allowing the HOC to receive the ref from its parent and then pass it down to the actual `WrappedComponent`. Here's how:\n1.  The HOC function, instead of directly returning a wrapper component, returns the result of `React.forwardRef((props, ref) => { ... })`.\n2.  Inside this `forwardRef`'s render function, the `ref` argument is the actual ref passed by the parent component.\n3.  This `ref` is then passed as a *regular prop* (e.g., `forwardedRef`) to the internal wrapper component (e.g., a class component inside the HOC).\n4.  Finally, the internal wrapper component renders the original `WrappedComponent` and attaches the `forwardedRef` prop to it using the standard `ref` attribute (e.g., `<WrappedComponent ref={forwardedRef} />`).\n\nThis chain ensures that the ref from the parent correctly reaches and attaches to the target `WrappedComponent`, allowing the parent to interact with it directly.",
          "options": [],
          "analysisPoints": [
            "Identification of the core issue: `ref` not being a regular prop.",
            "Understanding that the ref attaches to the HOC's wrapper.",
            "Step-by-step explanation of `forwardRef`'s mechanism within an HOC.",
            "Role of passing `forwardedRef` as a regular prop."
          ],
          "keyConcepts": [
            "HOCs",
            "Refs",
            "Ref Forwarding",
            "React.forwardRef",
            "Wrapper Components"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of problem description.",
            "Clarity and correctness of the solution explanation.",
            "Demonstration of in-depth React understanding."
          ],
          "example": "See the `logProps` HOC example in `theory_ref_forwarding_hocs` for practical implementation.",
          "tags": [
            "React",
            "HOCs",
            "Refs",
            "Ref Forwarding",
            "Problem Solving",
            "Architecture"
          ],
          "prerequisites": [
            "react_hocs",
            "react_forwardRef"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_ref_forwarding_3",
          "topic": "Ref Forwarding in HOCs",
          "level": "hard",
          "type": "code",
          "question": "Create an HOC named `withHighlightOnMount` that takes a component (`WrappedComponent`). This HOC should add a CSS class `highlight` to the `WrappedComponent`'s root DOM element for 2 seconds immediately after mounting, then remove it. Ensure that the HOC correctly forwards any ref passed to it by its parent, allowing the parent to still interact with `WrappedComponent`'s underlying DOM element after the highlight effect fades. Assume `WrappedComponent` is a functional component that accepts a ref.",
          "answer": "```typescript\nimport React, { useEffect, useRef } from 'react';\n\n// HOC: withHighlightOnMount\nfunction withHighlightOnMount(WrappedComponent) {\n  const HighlightWrapper = React.forwardRef((props, ref) => {\n    const innerRef = useRef(null);\n    \n    // Combine the forwarded ref with our internal ref\n    const combinedRef = (node) => {\n      innerRef.current = node; // Our internal ref\n      if (typeof ref === 'function') {\n        ref(node); // Parent's ref (function form)\n      } else if (ref) {\n        ref.current = node; // Parent's ref (object form)\n      }\n    };\n\n    useEffect(() => {\n      if (innerRef.current) {\n        const element = innerRef.current;\n        element.classList.add('highlight');\n\n        const timer = setTimeout(() => {\n          element.classList.remove('highlight');\n        }, 2000);\n\n        return () => clearTimeout(timer);\n      }\n    }, []);\n\n    return <WrappedComponent ref={combinedRef} {...props} />;\n  });\n  HighlightWrapper.displayName = `withHighlightOnMount(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return HighlightWrapper;\n}\n\n// A sample component that accepts a ref\nconst MyDiv = React.forwardRef((props, ref) => (\n  <div ref={ref} style={{ padding: '10px', border: '1px solid gray', margin: '5px' }} className={props.className}>\n    {props.children}\n  </div>\n));\n\n// Create the enhanced component\nconst HighlightedDiv = withHighlightOnMount(MyDiv);\n\n// Parent component to demonstrate usage\nfunction App() {\n  const divRef = useRef(null);\n\n  useEffect(() => {\n    // After 3 seconds, log the content of the div via the forwarded ref\n    const logTimer = setTimeout(() => {\n      if (divRef.current) {\n        console.log('Content via forwarded ref after highlight:', divRef.current.innerText);\n      }\n    }, 3000);\n    return () => clearTimeout(logTimer);\n  }, []);\n\n  return (\n    <div>\n      <style>\n        {`\n          .highlight {\n            border: 2px solid red !important;\n            background-color: yellow;\n            transition: all 0.3s ease-in-out;\n          }\n        `}\n      </style>\n      <h1>HOC with Ref Forwarding and Effect</h1>\n      <HighlightedDiv ref={divRef}>This div will highlight briefly on mount.</HighlightedDiv>\n      <button onClick={() => divRef.current?.innerText = 'Updated via ref!'}>Update Div via Ref</button>\n    </div>\n  );\n}\n\n// To use this, render <App />\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `React.forwardRef` as the return of the HOC.",
            "Properly combining internal refs (for the HOC's logic) with the external (forwarded) ref.",
            "Implementing `useEffect` for the highlight logic (adding/removing class, cleanup).",
            "Ensuring the `WrappedComponent` receives the combined ref.",
            "Demonstrating parent component's ability to interact with the ref *after* the HOC's effect.",
            "Handling `displayName` for better debugging."
          ],
          "keyConcepts": [
            "HOCs",
            "Ref Forwarding",
            "React.forwardRef",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "CSS in JS"
          ],
          "evaluationCriteria": [
            "Correct HOC implementation with ref forwarding.",
            "Effective use of React Hooks for side effects.",
            "Proper cleanup of effects.",
            "Demonstration of parent interaction.",
            "Code quality and robust ref handling."
          ],
          "example": "The solution code above serves as the example.",
          "tags": [
            "React",
            "HOCs",
            "Ref Forwarding",
            "Code Challenge",
            "Advanced React",
            "Hooks"
          ],
          "prerequisites": [
            "react_hocs",
            "react_forwardRef",
            "useRef_hook",
            "useEffect_hook"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_uncontrolled_form_builder",
          "title": "Build a Simple Uncontrolled Registration Form",
          "description": "\nCreate a React component `UncontrolledRegistrationForm` that handles user registration using uncontrolled components. The form should include:\n\n1.  **Username Input:** A text input for the username.\n2.  **Email Input:** A text input for the user's email.\n3.  **Password Input:** A password input field.\n4.  **Agree to Terms Checkbox:** A checkbox for agreeing to terms and conditions.\n5.  **Submit Button:** A button to submit the form.\n\nWhen the form is submitted, prevent the default browser behavior and log all input values (username, email, password, and whether terms were agreed) to the console. All inputs must utilize refs to access their values upon submission. Use `defaultValue` and `defaultChecked` where appropriate for initial states.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef } from 'react';\n\nfunction UncontrolledRegistrationForm() {\n  // Create refs here for each input\n  const usernameRef = useRef(null);\n  const emailRef = useRef(null);\n  const passwordRef = useRef(null);\n  const termsRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    // TODO: Prevent default form submission\n    // TODO: Access values from refs\n    // TODO: Log values to console\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px', maxWidth: '300px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input type=\"text\" id=\"username\" /* TODO: Attach ref and set defaultValue */ />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input type=\"email\" id=\"email\" /* TODO: Attach ref and set defaultValue */ />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" /* TODO: Attach ref and set defaultValue */ />\n      </div>\n      <div>\n        <input type=\"checkbox\" id=\"terms\" /* TODO: Attach ref and set defaultChecked */ />\n        <label htmlFor=\"terms\"> I agree to the terms and conditions</label>\n      </div>\n      <button type=\"submit\" style={{ padding: '8px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>Register</button>\n    </form>\n  );\n}\n\n// Example usage:\n// function App() {\n//   return <UncontrolledRegistrationForm />;\n// }\n",
          "solutionCode": "import React, { useRef } from 'react';\n\nfunction UncontrolledRegistrationForm() {\n  const usernameRef = useRef(null);\n  const emailRef = useRef(null);\n  const passwordRef = useRef(null);\n  const termsRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault(); // Prevent default form submission\n    \n    const username = usernameRef.current.value;\n    const email = emailRef.current.value;\n    const password = passwordRef.current.value;\n    const agreedToTerms = termsRef.current.checked;\n\n    console.log('Registration Data:', {\n      username,\n      email,\n      password,\n      agreedToTerms,\n    });\n    alert(`User ${username} registered (check console for details)!`);\n    // In a real app, you would send this data to a backend server\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px', maxWidth: '300px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input type=\"text\" id=\"username\" ref={usernameRef} defaultValue=\"\" />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input type=\"email\" id=\"email\" ref={emailRef} defaultValue=\"\" />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" ref={passwordRef} defaultValue=\"\" />\n      </div>\n      <div>\n        <input type=\"checkbox\" id=\"terms\" ref={termsRef} defaultChecked={false} />\n        <label htmlFor=\"terms\"> I agree to the terms and conditions</label>\n      </div>\n      <button type=\"submit\" style={{ padding: '8px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>Register</button>\n    </form>\n  );\n}\n",
          "testCases": [
            "Submitting with all fields filled: Should log correct username, email, password, and `agreedToTerms: true/false`.",
            "Submitting with empty fields: Should log empty strings for text fields and correct boolean for checkbox.",
            "Verify `event.preventDefault()`: Page should not reload after submission.",
            "Initial state: Text inputs should be empty, checkbox unchecked by default."
          ],
          "hints": [
            "Remember to use `useRef` for each input element.",
            "Attach the created ref to the `ref` prop of the input elements.",
            "For a checkbox, the value is accessed via `ref.current.checked`, not `ref.current.value`.",
            "Don't forget `event.preventDefault()` inside `handleSubmit`."
          ],
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Refs",
            "Form Handling"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_functional_components",
            "useRef_hook",
            "react_forms_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "controlled_components",
            "form_validation"
          ]
        },
        {
          "id": "task_focusable_button_component",
          "title": "Create a Reusable Focusable Button Component",
          "description": "\nImplement a `FocusableButton` React component. This component should:\n\n1.  Render a native `<button>` HTML element.\n2.  Accept a `children` prop to display text inside the button.\n3.  Crucially, it must support ref forwarding, allowing a parent component to obtain a direct reference to the underlying `<button>` DOM element and programmatically interact with it (e.g., call `focus()` or `click()`).\n4.  Demonstrate its usage in a parent `App` component where a `FocusableButton` is rendered, and an effect or an event handler programmatically focuses or clicks it after a short delay.\n\nYour solution should use `React.forwardRef` and functional components/hooks.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef, useEffect } from 'react';\n\n// TODO: Implement FocusableButton component using React.forwardRef\nconst FocusableButton = /* ... */;\n\nfunction App() {\n  const buttonRef = useRef(null);\n\n  useEffect(() => {\n    // TODO: Programmatically focus or click the button after a delay\n    // Hint: buttonRef.current will be the DOM element\n  }, []);\n\n  const handleClick = () => {\n    alert('Button was clicked!');\n  };\n\n  return (\n    <div>\n      <h1>Focusable Button Demo</h1>\n      {/* TODO: Render FocusableButton and pass the ref */}\n      <button onClick={() => buttonRef.current && buttonRef.current.blur()}>Blur Button (manual)</button>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useRef, useEffect } from 'react';\n\n// FocusableButton component using React.forwardRef\nconst FocusableButton = React.forwardRef(({ children, ...props }, ref) => (\n  <button ref={ref} {...props}>\n    {children}\n  </button>\n));\n\nfunction App() {\n  const buttonRef = useRef(null);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      if (buttonRef.current) {\n        console.log('Programmatically focusing button...');\n        buttonRef.current.focus(); // Focus the button\n        \n        // Optional: Programmatically click the button after another delay\n        setTimeout(() => {\n          console.log('Programmatically clicking button...');\n          buttonRef.current.click(); // Trigger click event\n        }, 1000);\n      }\n    }, 2000); // Focus after 2 seconds\n\n    return () => clearTimeout(timer);\n  }, []);\n\n  const handleClick = () => {\n    alert('Button was clicked via user interaction or programmatically!');\n  };\n\n  return (\n    <div style={{ display: 'flex', flexDirection: 'column', gap: '15px', padding: '20px' }}>\n      <h1>Focusable Button Demo</h1>\n      <p>The button below will be focused and then clicked programmatically after a delay.</p>\n      <FocusableButton ref={buttonRef} onClick={handleClick} style={{ padding: '10px 20px', fontSize: '1.2em' }}>\n        My Awesome Button\n      </FocusableButton>\n      <button onClick={() => buttonRef.current && buttonRef.current.blur()} style={{ padding: '8px 15px' }}>Blur Button (manual)</button>\n    </div>\n  );\n}\n",
          "testCases": [
            "Button is rendered with correct text.",
            "Button is programmatically focused after initial mount (check browser focus indicator).",
            "Button is programmatically clicked after focus (check `alert` or console message).",
            "Manual 'Blur Button' click correctly unfocuses the `FocusableButton`."
          ],
          "hints": [
            "Remember that `React.forwardRef` takes a render function with two arguments: `props` and `ref`.",
            "The `ref` argument needs to be attached directly to the native DOM element you want to expose.",
            "Use `useEffect` with `setTimeout` for timed actions in the parent component.",
            "Ensure cleanup for `setTimeout` using the return function of `useEffect`."
          ],
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding",
            "Component Design",
            "Hooks",
            "DOM Interaction"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_functional_components",
            "useRef_hook",
            "useEffect_hook"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "imperative_react",
            "higher_order_components"
          ]
        },
        {
          "id": "task_hoc_autofocus_input",
          "title": "Create a `withAutoFocus` HOC with Ref Forwarding",
          "description": "\nDevelop a Higher-Order Component (HOC) called `withAutoFocus`. This HOC should:\n\n1.  Take any React component (`WrappedComponent`) as an argument.\n2.  Return a new component that automatically focuses the `WrappedComponent`'s root DOM element when it mounts.\n3.  Crucially, ensure that the `withAutoFocus` HOC correctly forwards any ref passed to it by its parent component. This means the parent should still be able to get a direct reference to the `WrappedComponent`'s underlying DOM element.\n4.  Provide a `WrappedComponent` (e.g., a simple `Input` component) that uses `React.forwardRef` to expose its internal input element.\n5.  Demonstrate the usage by applying `withAutoFocus` to your `Input` component and rendering it in an `App` component. Verify that the input is focused on mount and that you can still log its value via a ref from `App`.\n\n**Assumptions:** The `WrappedComponent` you pass to `withAutoFocus` will itself support `React.forwardRef` if it's a functional component that needs ref access to its DOM children.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useRef, useEffect } from 'react';\n\n// TODO: Implement the withAutoFocus HOC\nfunction withAutoFocus(WrappedComponent) {\n  // Remember to use React.forwardRef here for the HOC's return\n  // and pass the received ref down as a prop.\n  return /* ... */;\n}\n\n// A sample WrappedComponent that supports ref forwarding\nconst MyInput = React.forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} placeholder={props.placeholder} {...props} />;\n});\n\n// Apply the HOC\nconst AutoFocusedInput = withAutoFocus(MyInput);\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // TODO: Verify the input is focused automatically.\n    // TODO: After a delay, log the input's current value using inputRef.\n  }, []);\n\n  const handleButtonClick = () => {\n    if (inputRef.current) {\n      alert('Current value: ' + inputRef.current.value);\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Auto-Focused Input Demo (HOC with Ref Forwarding)</h1>\n      <AutoFocusedInput ref={inputRef} placeholder=\"Type something...\" />\n      <button onClick={handleButtonClick} style={{ marginLeft: '10px' }}>Get Value via Parent Ref</button>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useRef, useEffect } from 'react';\n\n// HOC: withAutoFocus\nfunction withAutoFocus(WrappedComponent) {\n  class FocusWrapper extends React.Component {\n    componentDidMount() {\n      // Check if the forwardedRef exists and has a current property (DOM node)\n      if (this.props.forwardedRef && this.props.forwardedRef.current) {\n        console.log('AutoFocus HOC: Focusing input!');\n        this.props.forwardedRef.current.focus();\n      }\n    }\n\n    render() {\n      const { forwardedRef, ...restProps } = this.props;\n      // Pass the forwardedRef to the WrappedComponent as its 'ref' prop\n      return <WrappedComponent ref={forwardedRef} {...restProps} />;\n    }\n  }\n\n  // Use React.forwardRef to pass the parent's ref into the HOC's wrapper component\n  const ComponentWithRef = React.forwardRef((props, ref) => {\n    // Here, 'ref' is the ref from the component that consumes AutoFocusedInput.\n    // We pass it to FocusWrapper as a regular prop named 'forwardedRef'.\n    return <FocusWrapper {...props} forwardedRef={ref} />;\n  });\n\n  // Good practice for debugging: give the HOC a display name\n  ComponentWithRef.displayName = `withAutoFocus(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return ComponentWithRef;\n}\n\n// A sample WrappedComponent that supports ref forwarding\nconst MyInput = React.forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} placeholder={props.placeholder} {...props} />;\n});\n\n// Apply the HOC\nconst AutoFocusedInput = withAutoFocus(MyInput);\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // The input should be focused automatically by the HOC\n    console.log('App component mounted. Input should be auto-focused.');\n\n    const timer = setTimeout(() => {\n      if (inputRef.current) {\n        console.log('App: Current input value via forwarded ref:', inputRef.current.value);\n      }\n    }, 3000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  const handleButtonClick = () => {\n    if (inputRef.current) {\n      alert('Current value from parent ref: ' + inputRef.current.value);\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Auto-Focused Input Demo (HOC with Ref Forwarding)</h1>\n      <p>The input below should be automatically focused on page load.</p>\n      <AutoFocusedInput ref={inputRef} placeholder=\"Type something...\" />\n      <button onClick={handleButtonClick} style={{ marginLeft: '10px', padding: '8px 15px' }}>Get Value via Parent Ref</button>\n      <p style={{ marginTop: '20px', fontSize: '0.9em', color: '#666' }}>Try typing something and then click 'Get Value via Parent Ref'.</p>\n    </div>\n  );\n}\n",
          "testCases": [
            "Input field is automatically focused on component mount (visually confirm cursor in input).",
            "Typing into the input field works normally.",
            "Clicking 'Get Value via Parent Ref' button correctly displays the current value of the input, proving the ref forwarding works.",
            "No console errors or warnings related to refs or HOCs."
          ],
          "hints": [
            "The HOC must return `React.forwardRef(...)`.",
            "Inside the `forwardRef` render function, the second argument is the `ref` from the parent. Pass this as a regular prop (e.g., `forwardedRef`) to your HOC's internal wrapper component.",
            "The internal wrapper component (a class component for `componentDidMount` or a functional one with `useEffect`) then uses `this.props.forwardedRef` (or just `forwardedRef` for functional) and attaches it to the `WrappedComponent` via its `ref` prop.",
            "Remember to check `ref.current` before trying to access properties like `focus()` or `value`."
          ],
          "tags": [
            "React",
            "HOCs",
            "Ref Forwarding",
            "Code Challenge",
            "Advanced React",
            "Hooks"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "react_hocs",
            "react_forwardRef",
            "useRef_hook",
            "useEffect_hook",
            "react_class_components"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "expert",
          "relatedConcepts": [
            "render_props",
            "custom_hooks",
            "imperative_handles"
          ]
        }
      ]
    }
  },
  {
    "id": "9f907456-bdef-4313-855f-6f398f6b2d8c",
    "startLine": 4100,
    "endLine": 4199,
    "processedDate": "2025-06-17T09:03:46.656Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_forward_ref",
          "title": "React.forwardRef: Forwarding Refs in React",
          "content": "Refs in React provide a way to access DOM nodes or React components created in the render method. However, when you use Higher-Order Components (HOCs) or render props, refs are not automatically passed through to the wrapped component or the component rendered by the render prop. This is because `ref` is a special prop, handled directly by React, and it's not simply passed down like other props.\n\n`React.forwardRef` is a React utility that addresses this limitation. It allows your component to receive a ref and pass it further down to one of its children.\n\n## Key Concepts\n- **Problem Statement**: Standard props are passed down, but `ref` is a special prop that is consumed by React itself when attaching to a component instance or DOM node. When a component wraps another component (e.g., via HOCs or render props), the ref placed on the wrapper component refers to the *wrapper component itself*, not the inner component you might intend to reference.\n- **Solution**: `React.forwardRef` creates a React component that takes `props` and `ref` as arguments in its render function. The `ref` argument is the actual ref that was passed from the parent component.\n- **Syntax**: `React.forwardRef((props, ref) => <MyComponent ref={ref} {...props} />)`\n- **Use Cases**: Primarily used when building reusable component libraries, HOCs, or render prop components where you need to expose an underlying DOM element or component instance to a parent component for imperative actions (e.g., `focus()`, `measure()`).\n\n## Note on Refs with HOCs\nRefs are *not* passed through HOCs (Higher Order Components) by default. If you try to place a ref on a HOC-wrapped component, you will get a ref to the *outer wrapper component* (the HOC itself), not the wrapped component. `React.forwardRef` is essential to enable ref forwarding through HOCs, allowing the HOC to 'see' the ref and pass it to its `WrappedComponent`.",
          "examples": [
            {
              "id": "example_forward_ref_1",
              "title": "Forwarding Ref with a Higher-Order Component",
              "code": "import React from 'react';\n\n// A Higher-Order Component (HOC) that logs props.\n// It needs to be ref-aware to forward refs.\nfunction logProps(WrappedComponent) {\n  class LogProps extends React.Component {\n    // This is where React.forwardRef injects the ref\n    // The ref passed by the parent component will be assigned to this.ref\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n      // console.log('Props:', rest);\n      return <WrappedComponent ref={forwardedRef} {...rest} />;\n    }\n  }\n\n  // Using React.forwardRef to pass the ref to the internal WrappedComponent\n  // The second argument 'ref' is the ref passed by the parent.\n  return React.forwardRef((props, ref) => {\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n// A functional component (or class component) that needs its ref forwarded.\n// It receives the ref as the second argument if wrapped by forwardRef.\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.label}\n  </button>\n));\n\n// Original class component, before forwarding ref was applied directly\n// class FancyButton extends React.Component {\n//   focus() {\n//     // Implementation for focusing\n//     console.log('FancyButton focused!');\n//     this.buttonRef.current.focus();\n//   }\n//\n//   constructor(props) {\n//     super(props);\n//     this.buttonRef = React.createRef();\n//   }\n//\n//   render() {\n//     return <button ref={this.buttonRef}>Click me!</button>;\n//   }\n// }\n\n// Export wrapped component\nconst EnhancedFancyButton = logProps(FancyButton);\n\n// Consumer component\nfunction App() {\n  const ref = React.createRef();\n  \n  // The ref will be forwarded to the FancyButton component\n  const handleFocus = () => {\n    if (ref.current) {\n      // This calls the .focus() method of the underlying HTML button element\n      ref.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <EnhancedFancyButton ref={ref} label=\"Click Me\" />\n      <button onClick={handleFocus}>Focus the fancy button</button>\n    </div>\n  );\n}\n\n// To demonstrate the original class component with internal ref and its focus method:\nclass OriginalFancyButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.buttonRef = React.createRef();\n  }\n  \n  focus() {\n    // Implementation\n    console.log('OriginalFancyButton focused!');\n    this.buttonRef.current.focus();\n  }\n  \n  render() {\n    return <button ref={this.buttonRef}>Click me!</button>;\n  }\n}\n\n// Export wrapped component (if we were using the original class)\n// const EnhancedOriginalFancyButton = logProps(OriginalFancyButton);\n\n// // Consumer component demonstrating original class focus\n// function AppOriginal() {\n//   const ref = React.createRef();\n//   return (\n//     <div>\n//       {/* Without forwardRef on the OriginalFancyButton itself, this ref \n//           would refer to the LogProps instance, not the FancyButton. */}\n//       <EnhancedOriginalFancyButton ref={ref} label=\"Click Me\" />\n//       <button onClick={() => ref.current.focus()}>Focus the fancy button (Original)</button>\n//     </div>\n//   );\n// }",
              "explanation": "This example demonstrates how `React.forwardRef` is used to allow a parent component (`App`) to obtain a ref to an underlying DOM element (the `<button>` inside `FancyButton`), even when `FancyButton` is wrapped by a Higher-Order Component (`logProps`).\n\n1.  `FancyButton` is defined using `React.forwardRef`. This makes `FancyButton` a 'ref-aware' component, meaning it accepts a `ref` prop as its second argument in the render function. This `ref` is then passed directly to the `<button>` element.\n2.  The `logProps` HOC also uses `React.forwardRef`. Inside `logProps`, a wrapper component (`LogProps` class) is created. The `ref` argument from `React.forwardRef` is passed as a regular prop (`forwardedRef`) to this internal `LogProps` component. `LogProps` then renders the `WrappedComponent` (`FancyButton`) and attaches `forwardedRef` to its `ref` prop.\n3.  In `App`, `React.createRef()` creates a ref object. When `EnhancedFancyButton` (the HOC-wrapped `FancyButton`) is rendered with `ref={ref}`, this ref is forwarded through `logProps` and eventually reaches the `<button>` element inside `FancyButton`.\n4.  Clicking 'Focus the fancy button' calls `ref.current.focus()`. Because the ref points directly to the HTML button element, its native `focus()` method is invoked, demonstrating successful ref forwarding.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Refs",
            "forwardRef",
            "HOCs",
            "Composition"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "react_refs"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "custom_form_controls",
            "third_party_integrations"
          ]
        },
        {
          "id": "theory_higher_order_components",
          "title": "Higher-Order Components (HOCs)",
          "content": "A Higher-Order Component (HOC) is an advanced technique in React for reusing component logic. HOCs are *not* part of the React API; rather, they are a pattern that emerges from React's compositional nature. They are a powerful way to share reusable functionality between components without modifying the components themselves.\n\n## Definition\nA HOC is a function that takes a component and returns a new enhanced component.\n\n```typescript\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n\nHOCs solve the problem of code reuse across components with shared functionality, avoiding issues like:\n- **Cross-cutting concerns**: Logic that applies to many components (e.g., data fetching, authentication, logging, styling).\n- **Repetitive logic**: Avoiding writing the same `componentDidMount`, `setState` logic, or rendering conditionals in multiple components.\n- **Render prop and Hook alternatives**: Before Hooks became standard, HOCs (along with render props) were the primary way to share stateful logic.\n\n## Common HOC Patterns\nThere are generally two ways HOCs manipulate the `WrappedComponent`:\n\n### 1. Proxy Props (or Props Proxy)\nThis pattern involves the HOC rendering the `WrappedComponent` and passing additional props to it. It can also read, manipulate, or inject props, or even control the rendering of the `WrappedComponent` (e.g., conditional rendering).\n\n**Characteristics:**\n- The HOC returns a class or functional component that renders the `WrappedComponent`.\n- It receives props from its parent and forwards them to the `WrappedComponent`.\n- It can inject new props, modify existing props, or filter props.\n\n### 2. State Injection (or HOCs for State Management)\nThis pattern focuses on injecting state and methods related to that state into the `WrappedComponent`. The HOC manages its own internal state and passes relevant parts of that state (and possibly updater functions) as props to the `WrappedComponent`.\n\n**Characteristics:**\n- The HOC typically manages state and lifecycle methods (for class HOCs).\n- It subscribes to external data sources or performs data fetching.\n- It passes the derived data as props to the `WrappedComponent`.\n\n## Naming Conventions\nIt's common to prefix HOCs with `with` (e.g., `withRouter`, `withTheme`, `withSubscription`) to clearly indicate that they are higher-order components.",
          "examples": [
            {
              "id": "example_hoc_proxy_props",
              "title": "Creating HOCs with Proxy Props",
              "code": "import React from 'react';\n\nfunction withExtraProps(WrappedComponent) {\n  return class EnhancedComponent extends React.Component {\n    render() {\n      // Pass through existing props and add new ones\n      const newProps = {\n        title: 'New Header',\n        footer: false,\n        showFeatureX: false,\n        showFeatureY: true\n      };\n      // Ensure existing props are spread first to allow them to be overridden\n      // by newProps if desired, or newProps first to allow overrides from parent\n      // (depends on desired precedence). Here, newProps can override this.props.\n      return <WrappedComponent {...this.props} {...newProps} />;\n    }\n  };\n}\n\n// Usage Example:\nfunction MyComponent(props) {\n  return (\n    <div>\n      <h1>{props.title || 'Default Title'}</h1>\n      <p>Hello, {props.name}!</p>\n      {props.showFeatureY && <p>Feature Y is enabled.</p>}\n      {!props.footer && <p>No footer here.</p>}\n    </div>\n  );\n}\n\nconst EnhancedMyComponent = withExtraProps(MyComponent);\n\n// In your App or another component:\n// function App() {\n//   return <EnhancedMyComponent name=\"World\" />;\n// }",
              "explanation": "This example demonstrates the 'Proxy Props' pattern. The `withExtraProps` HOC takes `WrappedComponent` and returns `EnhancedComponent`. `EnhancedComponent`'s `render` method simply renders `WrappedComponent`, but importantly, it injects a set of predefined `newProps` along with all the props it received from its parent (`this.props`). This allows the HOC to provide default values, additional features, or override props for the `WrappedComponent` without `WrappedComponent` itself needing to be aware of these injected props directly. The `MyComponent` then receives `name`, `title`, `footer`, `showFeatureX`, and `showFeatureY` as its props, even if the parent only passed `name`.",
              "language": "typescript"
            },
            {
              "id": "example_hoc_state_injection",
              "title": "Creating HOCs with State Injection",
              "code": "import React from 'react';\n\n// A mock data source for demonstration purposes\nconst DataSource = {\n  data: 'Initial Data',\n  listeners: [],\n  getData: function(props) {\n    // Simulate data selection based on props\n    return `Data for ${props.id || 'default'}: ${this.data}`;\n  },\n  addChangeListener: function(callback) {\n    this.listeners.push(callback);\n  },\n  removeChangeListener: function(callback) {\n    this.listeners = this.listeners.filter(cb => cb !== callback);\n  },\n  // Simulate data changes\n  changeData: function(newData) {\n    this.data = newData;\n    this.listeners.forEach(cb => cb());\n  }\n};\n\nfunction withSubscription(WrappedComponent, selectData) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // Subscribe to changes\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      // Clean up subscription\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange = () => {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    };\n\n    render() {\n      // Pass all props and inject state as additional prop\n      // The 'data' prop is injected from the HOC's state.\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n\n// Usage Example:\nfunction MyDataComponent(props) {\n  return (\n    <div>\n      <h2>Subscribed Data:</h2>\n      <p>{props.data}</p>\n      <p>Component ID: {props.id}</p>\n    </div>\n  );\n}\n\n// This HOC will subscribe MyDataComponent to changes in DataSource\nconst MyEnhancedDataComponent = withSubscription(MyDataComponent, (source, props) => source.getData(props));\n\n// To use it in an App:\n// function App() {\n//   React.useEffect(() => {\n//     // Simulate data changing after some time\n//     const timer = setTimeout(() => {\n//       DataSource.changeData('Updated Data from HOC!');\n//     }, 2000);\n//     return () => clearTimeout(timer);\n//   }, []);\n//\n//   return (\n//     <div>\n//       <MyEnhancedDataComponent id=\"123\" />\n//       <button onClick={() => DataSource.changeData('Manual Data Update!')}>Manual Update</button>\n//     </div>\n//   );\n// }",
              "explanation": "This example illustrates the 'State Injection' pattern. The `withSubscription` HOC is responsible for managing data subscription. It creates an internal state (`this.state.data`), subscribes to `DataSource` changes in `componentDidMount`, updates its state on change (`handleChange`), and cleans up in `componentWillUnmount`. Finally, it renders the `WrappedComponent` (`MyDataComponent`), passing the managed `data` as a prop. This abstracts away the data fetching/subscription logic from `MyDataComponent`, allowing `MyDataComponent` to be a purely presentational component that just receives `data` as a prop.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "HOCs",
            "Code Reuse",
            "Design Patterns",
            "Component Composition",
            "Higher Order Functions"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "react_state",
            "react_lifecycle_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "scalable_applications",
            "custom_libraries",
            "legacy_codebases"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_forward_ref_1",
          "topic": "React.forwardRef Fundamentals",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of `React.forwardRef`?",
          "answer": "To allow a parent component to obtain a ref to an underlying DOM element or React component instance inside a child component, especially when using HOCs or render props.",
          "options": [
            "To allow a parent component to obtain a ref to an underlying DOM element or React component instance inside a child component, especially when using HOCs or render props.",
            "To create a Higher-Order Component that injects a ref prop into the wrapped component.",
            "To optimize component re-renders by preventing unnecessary ref updates.",
            "To explicitly pass a ref from a functional component to its immediate child."
          ],
          "analysisPoints": [
            "`React.forwardRef` explicitly addresses the limitation of refs not being automatically passed through intermediate components.",
            "It's crucial for component libraries or when abstracting DOM access behind reusable components.",
            "While HOCs might be involved, `forwardRef`'s purpose is broader than just HOCs; it's about ref 'tunneling'."
          ],
          "keyConcepts": [
            "React.forwardRef",
            "Refs",
            "Higher-Order Components (HOCs)",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Understanding of the core problem `forwardRef` solves.",
            "Distinguishing its purpose from HOC creation or performance optimization."
          ],
          "example": "```typescript\nconst MyInput = React.forwardRef((props, ref) => (\n  <input ref={ref} {...props} />\n));\n\nfunction ParentComponent() {\n  const inputRef = React.useRef(null);\n\n  const handleClick = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <div>\n      <MyInput ref={inputRef} placeholder=\"Type here...\" />\n      <button onClick={handleClick}>Focus Input</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Refs",
            "forwardRef",
            "HOCs"
          ],
          "prerequisites": [
            "react_refs",
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_forward_ref_2",
          "topic": "Ref Passing through HOCs",
          "level": "hard",
          "type": "open",
          "question": "Explain why refs are not automatically passed through Higher-Order Components (HOCs) by default, and provide a detailed explanation of how `React.forwardRef` addresses this limitation with a suitable code example.",
          "answer": "Refs are a special prop in React. Unlike regular props, `ref` is handled directly by React's reconciliation process to attach to a component instance or DOM node. When you place a `ref` on a component `MyHOC(MyComponent)`, React attaches the ref to the instance of `MyHOC`'s internal wrapper component, not to `MyComponent` itself. This is because `MyHOC` acts as an intermediate layer, obscuring `MyComponent` from the parent's direct ref assignment.\n\n`React.forwardRef` solves this by creating a component that explicitly forwards the `ref` prop it receives to an inner component. When you wrap `MyComponent` with `React.forwardRef` (or create your HOC to use `React.forwardRef`), it allows React to 'see' the ref prop and make it available as a second argument (`ref`) in the component's render function. This `ref` argument can then be explicitly passed down to the intended inner component or DOM element. The HOC itself would also need to be ref-aware, often by also wrapping its returned component with `React.forwardRef` and passing the ref as a regular prop internally before applying it.",
          "analysisPoints": [
            "Understanding of React's special handling of the `ref` prop.",
            "Ability to explain the 'ref-chain' break caused by intermediate components (HOCs).",
            "Clear articulation of `forwardRef`'s role in breaking this limitation.",
            "Correct implementation of `forwardRef` in both the wrapped component and potentially the HOC."
          ],
          "keyConcepts": [
            "React.forwardRef",
            "Refs",
            "Higher-Order Components",
            "Special Props"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of the explanation.",
            "Demonstrated understanding of React's internal ref mechanism.",
            "Correct and illustrative code example."
          ],
          "example": "```typescript\nimport React from 'react';\n\n// HOC that logs props, now also forwards refs\nfunction withLogger(WrappedComponent) {\n  class Logger extends React.Component {\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n      console.log('Props received by HOC:', rest);\n      return <WrappedComponent ref={forwardedRef} {...rest} />;\n    }\n  }\n  \n  // This ensures the HOC itself is ref-aware\n  return React.forwardRef((props, ref) => {\n    return <Logger {...props} forwardedRef={ref} />;\n  });\n}\n\n// Component that needs its ref forwarded\nconst TextInput = React.forwardRef((props, ref) => (\n  <input type=\"text\" ref={ref} placeholder={props.placeholder} />\n));\n\n// Applying the HOC to the ref-aware component\nconst EnhancedTextInput = withLogger(TextInput);\n\nfunction App() {\n  const inputRef = React.useRef(null);\n\n  const handleFocus = () => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <EnhancedTextInput ref={inputRef} placeholder=\"Enter text...\" />\n      <button onClick={handleFocus}>Focus Input via Ref</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Refs",
            "forwardRef",
            "HOCs",
            "Advanced React"
          ],
          "prerequisites": [
            "react_refs",
            "higher_order_components"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_1",
          "topic": "Higher-Order Components Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a Higher-Order Component (HOC) in React?",
          "answer": "To reuse component logic across multiple components.",
          "analysisPoints": [
            "Focus on the core concept of code reuse.",
            "HOCs allow sharing behaviors without altering component structure."
          ],
          "keyConcepts": [
            "Higher-Order Components",
            "Code Reuse",
            "Design Patterns"
          ],
          "evaluationCriteria": [
            "Ability to recall the fundamental definition."
          ],
          "example": "A HOC like `withRouter` adds routing capabilities to any component it wraps, without the component itself needing to implement routing logic.",
          "tags": [
            "React",
            "HOCs",
            "Definition"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_2",
          "topic": "HOC Characteristics",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements is TRUE about Higher-Order Components (HOCs) in React?",
          "answer": "A HOC is a function that takes a component as an argument and returns a new, enhanced component.",
          "options": [
            "A HOC is a function that takes a component as an argument and returns a new, enhanced component.",
            "HOCs are part of the core React API and are specifically designed for state management.",
            "HOCs should always modify the passed component's prototype directly.",
            "HOCs are primarily used for rendering conditional JSX based on props."
          ],
          "analysisPoints": [
            "The definition of HOC as a function transforming components is central.",
            "HOCs are a pattern, not part of the core React API.",
            "Modifying prototypes is an anti-pattern for HOCs (side effects, hard to debug).",
            "While HOCs *can* do conditional rendering, it's not their *primary* distinguishing feature."
          ],
          "keyConcepts": [
            "Higher-Order Components",
            "React API",
            "Functional Programming Pattern"
          ],
          "evaluationCriteria": [
            "Accurate understanding of HOC definition and nature.",
            "Distinguishing HOCs from other React concepts or anti-patterns."
          ],
          "example": "```typescript\n// Correct HOC pattern\nfunction withLogger(WrappedComponent) {\n  return function LoggedComponent(props) {\n    console.log(`Rendering ${WrappedComponent.name} with props:`, props);\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Incorrect (anti-pattern: mutating original component)\n// function badHOC(Component) {\n//   Component.prototype.someMethod = () => console.log('Bad idea');\n//   return Component;\n// }\n```",
          "tags": [
            "React",
            "HOCs",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_3",
          "topic": "HOC Patterns",
          "level": "medium",
          "type": "open",
          "question": "Describe two common patterns for implementing Higher-Order Components (HOCs): Proxy Props and State Injection. For each, provide a brief explanation of how it works and a typical use case.",
          "answer": "1.  **Proxy Props (or Props Proxy)**:\n    *   **How it works**: The HOC renders the `WrappedComponent` and passes through (proxies) the original props, while also having the ability to inject new props, modify existing ones, or filter them out. The HOC itself doesn't typically manage significant state related to the `WrappedComponent`'s behavior, but rather augments its rendering context.\n    *   **Typical Use Case**: Adding common props like `theme` data, user roles, or global configurations. For instance, a `withAuthorization` HOC that injects an `isAuthorized` prop based on the current user, or a `withStyles` HOC that injects styling props.\n\n2.  **State Injection (or HOCs for State Management)**:\n    *   **How it works**: The HOC manages its own internal state, often involving side effects like data fetching, subscriptions, or lifecycle methods. It then passes a portion of this managed state, along with any relevant state-updating methods, as props to the `WrappedComponent`. This offloads stateful logic from the `WrappedComponent`.\n    *   **Typical Use Case**: Connecting to external data stores (e.g., Redux `connect`, a `withSubscription` HOC to a global `DataSource`), handling form input state, or managing UI states like toggles or loading indicators. For example, a `withLoading` HOC that fetches data and injects `isLoading` and `data` props.",
          "analysisPoints": [
            "Clear distinction between prop manipulation and state management roles.",
            "Accurate description of the mechanism for each pattern.",
            "Relevant and distinct use cases for both patterns."
          ],
          "keyConcepts": [
            "Higher-Order Components",
            "Proxy Props",
            "State Injection",
            "Code Reusability"
          ],
          "evaluationCriteria": [
            "Thoroughness of explanation.",
            "Ability to connect patterns to practical scenarios.",
            "Clarity and conciseness."
          ],
          "example": "```typescript\n// Proxy Props example (from theory)\nfunction withExtraProps(WrappedComponent) { \n  return class EnhancedComponent extends React.Component { \n    render() {\n      const newProps = { \n        timestamp: Date.now() \n      }\n      return <WrappedComponent {...this.props} {...newProps} />\n    }\n  }\n}\n\n// State Injection example (simplified)\nfunction withToggle(WrappedComponent) {\n  return class ToggleComponent extends React.Component {\n    state = { isOn: false };\n    toggle = () => this.setState(prevState => ({ isOn: !prevState.isOn }));\n    render() {\n      return <WrappedComponent {...this.props} isOn={this.state.isOn} toggle={this.toggle} />;\n    }\n  };\n}\n```",
          "tags": [
            "React",
            "HOCs",
            "Patterns",
            "Design"
          ],
          "prerequisites": [
            "react_state",
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_4",
          "topic": "HOC Use Cases",
          "level": "hard",
          "type": "coding",
          "question": "Implement a Higher-Order Component named `withAuthentication` that checks if a user is authenticated. If the user is authenticated, it should render the `WrappedComponent`. If not, it should render a `<p>` tag displaying 'Please log in to view this content.' For simplicity, `isAuthenticated` can be a boolean passed as a prop to the HOC's returned component. Demonstrate its usage with a `Dashboard` component.",
          "answer": "```typescript\nimport React from 'react';\n\nfunction withAuthentication(WrappedComponent) {\n  return function AuthenticatedComponent(props) {\n    const { isAuthenticated, ...restProps } = props;\n\n    if (isAuthenticated) {\n      return <WrappedComponent {...restProps} />;\n    } else {\n      return <p>Please log in to view this content.</p>;\n    }\n  };\n}\n\n// Example WrappedComponent\nfunction Dashboard(props) {\n  return (\n    <div>\n      <h2>Welcome to your Dashboard, {props.username || 'Guest'}!</h2>\n      <p>Here's some secret content.</p>\n    </div>\n  );\n}\n\nconst AuthenticatedDashboard = withAuthentication(Dashboard);\n\n// How to use it:\nfunction App() {\n  const [loggedIn, setLoggedIn] = React.useState(false);\n\n  return (\n    <div>\n      <h1>My Application</h1>\n      <button onClick={() => setLoggedIn(!loggedIn)}>\n        {loggedIn ? 'Log Out' : 'Log In'}\n      </button>\n      <hr />\n      <AuthenticatedDashboard isAuthenticated={loggedIn} username=\"Alice\" />\n    </div>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "analysisPoints": [
            "Correct implementation of a HOC (function returning a component).",
            "Proper prop spreading (`...restProps`) to ensure original props are passed.",
            "Conditional rendering based on injected logic.",
            "Demonstration of usage with a sample component."
          ],
          "keyConcepts": [
            "Higher-Order Components",
            "Conditional Rendering",
            "Props Spreading",
            "Code Reuse"
          ],
          "evaluationCriteria": [
            "Functional correctness of the HOC.",
            "Adherence to HOC pattern.",
            "Clarity of demonstration."
          ],
          "example": "The HOC `withAuthentication` takes `Dashboard` and returns `AuthenticatedDashboard`. `AuthenticatedDashboard` then conditionally renders `Dashboard` or a login message based on the `isAuthenticated` prop it receives from its parent (`App`). This encapsulates the authentication logic, keeping `Dashboard` clean and focused on its content.",
          "tags": [
            "React",
            "HOCs",
            "Authentication",
            "Conditional Rendering",
            "Coding"
          ],
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_forward_ref_3",
          "topic": "React.forwardRef vs. React.useRef",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `React.createRef()` (or `useRef`) and `React.forwardRef`?",
          "answer": "`React.createRef()` (or `useRef` for functional components) is used to *create* a ref object that can hold a mutable value. `React.forwardRef` is used to *pass* a ref created by a parent component *through* a component to an underlying DOM element or another component.",
          "analysisPoints": [
            "Distinguishes between creating and propagating refs.",
            "Highlights their different roles in the ref mechanism."
          ],
          "keyConcepts": [
            "React.createRef",
            "React.useRef",
            "React.forwardRef",
            "Refs"
          ],
          "evaluationCriteria": [
            "Accurate differentiation of ref utilities."
          ],
          "example": "```typescript\n// Creating a ref\nconst myRef = React.createRef(); // For class components\nconst myRefHook = React.useRef(null); // For functional components\n\n// Passing a ref using forwardRef\nconst ChildComponent = React.forwardRef((props, ref) => (\n  <input ref={ref} />\n));\n```",
          "tags": [
            "React",
            "Refs",
            "forwardRef",
            "useRef",
            "createRef"
          ],
          "prerequisites": [
            "react_refs"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_forward_ref_hoc_integration",
          "title": "Implement a Ref-Forwarding Input Component with a Validation HOC",
          "description": "\nCreate a `CustomInput` component that renders an `<input>` element. This `CustomInput` should be ref-aware, meaning it can receive a ref from its parent and forward it to the internal `<input>` element.\n\nNext, implement a Higher-Order Component named `withValidation`.\nThis HOC should:\n1.  Take a `WrappedComponent` as an argument.\n2.  Manage an internal `isValid` state, initialized to `true`.\n3.  Provide a `validate` method (e.g., through a prop to the `WrappedComponent` or via an exposed `useImperativeHandle` for complex validation).\n4.  Render the `WrappedComponent`, passing along all original props and potentially injecting a prop like `isValid`.\n5.  The `withValidation` HOC itself must also correctly forward refs to its `WrappedComponent`.\n\nFinally, demonstrate how to use `CustomInput` wrapped by `withValidation` in an `App` component. The `App` component should:\n-   Render the `ValidatedInput` (the HOC-wrapped `CustomInput`).\n-   Have a button that, when clicked, focuses the `ValidatedInput` using a ref *obtained from the `App` component*.\n-   Have another button that triggers a simple validation logic (e.g., check if input is not empty) via the `withValidation` HOC.\n\n**Requirements:**\n-   `CustomInput` uses `React.forwardRef`.\n-   `withValidation` HOC uses `React.forwardRef` to correctly pass refs to the `CustomInput`.\n-   The `App` component should successfully focus the input via the ref.\n-   The `withValidation` HOC should manage a simple validation state (e.g., `isValid` based on input value not being empty).\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useRef, useImperativeHandle } from 'react';\n\n// 1. Create CustomInput using React.forwardRef\nconst CustomInput = React.forwardRef((props, ref) => {\n  // TODO: Render an <input> element and forward the ref\n  return <input {...props} ref={ref} />;\n});\n\n// 2. Create withValidation HOC that also uses React.forwardRef\nfunction withValidation(WrappedComponent) {\n  class WithValidationLogic extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = { isValid: true };\n      this.inputRef = React.createRef(); // Internal ref to wrapped component\n      // Expose validate method if needed using useImperativeHandle on outer component\n    }\n\n    // Example validation method\n    validate = (value) => {\n      const valid = value.trim() !== ''; // Simple check for non-empty\n      this.setState({ isValid: valid });\n      return valid;\n    };\n\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n      return (\n        <WrappedComponent\n          ref={forwardedRef}\n          isValid={this.state.isValid}\n          validate={this.validate}\n          {...rest}\n        />\n      );\n    }\n  }\n\n  return React.forwardRef((props, ref) => (\n    <WithValidationLogic {...props} forwardedRef={ref} />\n  ));\n}\n\n// 3. Apply the HOC\nconst ValidatedInput = withValidation(CustomInput);\n\n// 4. Demonstrate in App component\nfunction App() {\n  const inputRef = useRef(null);\n  const [inputValue, setInputValue] = useState('');\n\n  const handleFocus = () => {\n    // TODO: Focus the input using inputRef\n    inputRef.current.focus();\n  };\n\n  const handleValidate = () => {\n    // TODO: Trigger validation. This might require accessing the HOC's instance or specific props.\n    // For this example, we'll assume `validate` prop is passed down and accessible.\n    // A more robust solution might expose validation logic via useImperativeHandle.\n    if (inputRef.current && inputRef.current.validate) {\n      const isValid = inputRef.current.validate(inputValue);\n      alert(`Input is ${isValid ? 'valid' : 'invalid'}`);\n    } else {\n        // Fallback for simple direct DOM element validation if validate isn't exposed through ref\n        const isValid = inputValue.trim() !== '';\n        alert(`Direct DOM element check: Input is ${isValid ? 'valid' : 'invalid'}`);\n    }\n  };\n\n  return (\n    <div>\n      <h1>Ref Forwarding with HOC Validation</h1>\n      <ValidatedInput\n        ref={inputRef}\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"Type something...\"\n        style={{ borderColor: inputRef.current?.isValid === false ? 'red' : 'green' }}\n      />\n      <button onClick={handleFocus}>Focus Input</button>\n      <button onClick={handleValidate}>Validate Input</button>\n      <p>Is Valid: {inputRef.current?.isValid ? 'Yes' : 'No'}</p>\n    </div>\n  );\n}\n\nexport default App;",
          "solutionCode": "import React, { useState, useRef, useImperativeHandle } from 'react';\n\n// 1. Create CustomInput using React.forwardRef\nconst CustomInput = React.forwardRef((props, ref) => {\n  const { isValid, ...restProps } = props;\n  return (\n    <input\n      {...restProps}\n      ref={ref}\n      style={{ borderColor: isValid === false ? 'red' : 'initial', borderWidth: '2px', padding: '5px' }}\n    />\n  );\n});\n\n// 2. Create withValidation HOC that also uses React.forwardRef\nfunction withValidation(WrappedComponent) {\n  class WithValidationLogic extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = { isValid: true };\n      this.internalRef = React.createRef(); // Ref to the WrappedComponent instance\n    }\n\n    // This method is called by the HOC's consumer (e.g., App) via the forwarded ref.\n    // It exposes the WrappedComponent's focus method and the HOC's validate logic.\n    exposeMethods = () => ({\n      focus: () => {\n        if (this.internalRef.current && typeof this.internalRef.current.focus === 'function') {\n          this.internalRef.current.focus();\n        } else if (this.internalRef.current && this.internalRef.current.nodeType === 1) {\n           // If ref is a DOM element (like in CustomInput), focus directly\n           this.internalRef.current.focus();\n        }\n      },\n      validate: (value) => {\n        const valid = value.trim() !== '';\n        this.setState({ isValid: valid });\n        return valid;\n      },\n      // Expose current isValid state\n      get isValid() {\n        return this.state.isValid;\n      }\n    });\n\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n\n      // Use useImperativeHandle to expose methods through the forwardedRef\n      // This must be inside a functional component or use a wrapper class's instance method directly.\n      // Here, we adapt for a class component HOC by using a ref callback.\n      const setRef = instance => {\n        this.internalRef.current = instance;\n        if (forwardedRef) {\n          if (typeof forwardedRef === 'function') {\n            forwardedRef(this.exposeMethods()); // Pass methods to the forwarded ref\n          } else {\n            forwardedRef.current = this.exposeMethods();\n          }\n        }\n      };\n\n      return (\n        <WrappedComponent\n          ref={setRef} // Pass our internal ref callback to the WrappedComponent\n          isValid={this.state.isValid}\n          {...rest}\n        />\n      );\n    }\n  }\n\n  // The outer HOC function which creates the ref-aware component\n  return React.forwardRef((props, ref) => (\n    <WithValidationLogic {...props} forwardedRef={ref} />\n  ));\n}\n\n// 3. Apply the HOC\nconst ValidatedInput = withValidation(CustomInput);\n\n// 4. Demonstrate in App component\nfunction App() {\n  const inputRef = useRef(null);\n  const [inputValue, setInputValue] = useState('');\n\n  const handleFocus = () => {\n    if (inputRef.current && typeof inputRef.current.focus === 'function') {\n      inputRef.current.focus();\n    } else {\n      console.warn(\"Focus method not available on ref.current.\");\n    }\n  };\n\n  const handleValidate = () => {\n    if (inputRef.current && typeof inputRef.current.validate === 'function') {\n      const isValid = inputRef.current.validate(inputValue);\n      alert(`Input is ${isValid ? 'valid' : 'invalid'}`);\n    } else {\n      console.warn(\"Validate method not available on ref.current.\");\n    }\n  };\n\n  return (\n    <div>\n      <h1>Ref Forwarding with HOC Validation</h1>\n      <ValidatedInput\n        ref={inputRef}\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"Type something...\"\n      />\n      <p>Current input value: {inputValue}</p>\n      <p>Input Validity: {inputRef.current?.isValid ? 'Valid' : 'Invalid'}</p>\n      <button onClick={handleFocus} style={{ marginRight: '10px' }}>Focus Input</button>\n      <button onClick={handleValidate}>Validate Input</button>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "**Test Case 1: Initial Render**\n- **Input**: Render `App`.\n- **Expected Output**: Input field is rendered, 'Is Valid: Yes' is displayed. Focus button and Validate button are visible. Input border is default (or green if style applied).\n\n**Test Case 2: Focus Functionality**\n- **Input**: Click 'Focus Input' button.\n- **Expected Output**: The input field receives focus (cursor appears, field highlights).\n\n**Test Case 3: Empty Input Validation**\n- **Input**: Type nothing into the input. Click 'Validate Input' button.\n- **Expected Output**: An alert 'Input is invalid' appears. The 'Is Valid:' text changes to 'No'. Input border turns red.\n\n**Test Case 4: Valid Input Validation**\n- **Input**: Type 'hello' into the input. Click 'Validate Input' button.\n- **Expected Output**: An alert 'Input is valid' appears. The 'Is Valid:' text changes to 'Yes'. Input border turns green (or default).\n\n**Test Case 5: Ref Access (Console Check)**\n- **Input**: Inspect `inputRef.current` in browser console after `App` renders.\n- **Expected Output**: `inputRef.current` should be an object containing `focus()` and `validate()` methods, and an `isValid` getter, demonstrating `useImperativeHandle`'s effect (or equivalent for class HOC). It should NOT be `null` or point to the HOC instance directly if `forwardRef` isn't properly used on the HOC.",
            "**Test Case 6: Typing updates validity visually**\n- **Input**: Type some text into the input, then delete it to make it empty.\n- **Expected Output**: The border color should dynamically change between green/default and red as the content becomes valid/invalid (assuming `onChange` is linked to validation or `isValid` prop affects styling)."
          ],
          "hints": [
            "Remember that `React.forwardRef` takes two arguments: `props` and `ref`.",
            "When a HOC needs to forward a ref, the component returned by the HOC function should itself be wrapped in `React.forwardRef`.",
            "To expose specific methods (like `focus` or `validate`) from the `WrappedComponent` or the HOC's internal logic via the ref, consider using `useImperativeHandle` within the `WrappedComponent` (if it's functional) or by manually exposing them from the HOC's internal ref (for class-based HOCs). In this case, exposing HOC's methods through the `forwardedRef` is key.",
            "Ensure proper prop spreading (`{...props}`) to pass all original props down the chain.",
            "The `isValid` prop can be used by `CustomInput` to change its appearance (e.g., border color)."
          ],
          "tags": [
            "React",
            "forwardRef",
            "HOCs",
            "Refs",
            "Validation",
            "Composition",
            "Advanced React"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_react_forward_ref",
            "theory_higher_order_components",
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "useImperativeHandle",
            "Controlled Components"
          ]
        },
        {
          "id": "task_data_fetching_hoc",
          "title": "Implement a Data Fetching HOC",
          "description": "\nCreate a Higher-Order Component named `withDataFetching` that abstracts data fetching logic. This HOC should:\n\n1.  Accept two arguments: a `url` string (the API endpoint to fetch data from) and the `WrappedComponent`.\n2.  Manage three pieces of state internally: `data` (for the fetched data, initially `null`), `isLoading` (boolean, initially `true`), and `error` (for any fetch errors, initially `null`).\n3.  Perform the data fetch when the component mounts. Use `fetch` API.\n4.  Update its internal state based on the fetch operation's success, loading status, or failure.\n5.  Pass `data`, `isLoading`, and `error` as props to the `WrappedComponent`.\n6.  Handle unmounting gracefully (e.g., aborting fetch requests if component unmounts).\n\nDemonstrate its usage by wrapping a `UserList` component that expects `data` (an array of users) and displays it. The `UserList` component should also conditionally render based on `isLoading` and `error` props.\n\n**Requirements:**\n-   The HOC should be a class component to demonstrate lifecycle methods (or a functional component with `useEffect` for a modern approach, but stick to class for this task if it clarifies HOC concepts).\n-   Error handling should be present.\n-   The HOC should pass all original props to the `WrappedComponent`.\n-   A mock API can be used if a real one isn't available (e.g., `https://jsonplaceholder.typicode.com/users`).\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// HOC for data fetching\nfunction withDataFetching(WrappedComponent, url) {\n  return class DataFetcher extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: null,\n        isLoading: true,\n        error: null,\n      };\n      this.abortController = new AbortController(); // For handling unmount\n    }\n\n    componentDidMount() {\n      // TODO: Implement data fetching logic\n      // Use this.abortController.signal for fetch options to enable aborting\n      // Update state based on fetch outcome\n    }\n\n    componentWillUnmount() {\n      // TODO: Abort any pending fetch requests\n      this.abortController.abort();\n    }\n\n    render() {\n      // TODO: Pass data, isLoading, error, and original props to WrappedComponent\n      return <WrappedComponent {...this.props} {...this.state} />;\n    }\n  };\n}\n\n// Example WrappedComponent\nfunction UserList({ data, isLoading, error, title }) {\n  if (isLoading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (!data || data.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>{title}</h2>\n      <ul>\n        {data.map((user) => (\n          <li key={user.id}>{user.name} ({user.email})</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Apply the HOC\nconst EnhancedUserList = withDataFetching(UserList, 'https://jsonplaceholder.typicode.com/users');\n\n// Demonstrate in App\nfunction App() {\n  return (\n    <div>\n      <h1>Data Fetching with HOC</h1>\n      <EnhancedUserList title=\"List of Users\" />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\n\n// HOC for data fetching\nfunction withDataFetching(WrappedComponent, url) {\n  return class DataFetcher extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: null,\n        isLoading: true,\n        error: null,\n      };\n      this.abortController = new AbortController(); // For handling unmount\n    }\n\n    componentDidMount() {\n      const signal = this.abortController.signal;\n\n      fetch(url, { signal })\n        .then(response => {\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          return response.json();\n        })\n        .then(data => {\n          if (!signal.aborted) { // Check if not aborted before setting state\n            this.setState({\n              data: data,\n              isLoading: false,\n            });\n          }\n        })\n        .catch(error => {\n          if (error.name === 'AbortError') {\n            console.log('Fetch aborted');\n            return; // Do nothing if fetch was aborted on unmount\n          }\n          if (!signal.aborted) { // Check if not aborted before setting state\n            this.setState({\n              error: error,\n              isLoading: false,\n            });\n          }\n        });\n    }\n\n    componentWillUnmount() {\n      this.abortController.abort();\n    }\n\n    render() {\n      // Pass data, isLoading, error, and original props to WrappedComponent\n      return <WrappedComponent {...this.props} {...this.state} />;\n    }\n  };\n}\n\n// Example WrappedComponent\nfunction UserList({ data, isLoading, error, title }) {\n  if (isLoading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (!data || data.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>{title}</h2>\n      <ul>\n        {data.map((user) => (\n          <li key={user.id}>{user.name} ({user.email})</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Apply the HOC\nconst EnhancedUserList = withDataFetching(UserList, 'https://jsonplaceholder.typicode.com/users');\n\n// Demonstrate in App\nfunction App() {\n  return (\n    <div>\n      <h1>Data Fetching with HOC</h1>\n      <EnhancedUserList title=\"List of Users\" />\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "**Test Case 1: Successful Data Fetch**\n- **Input**: Render `App` component.\n- **Expected Output**: Initially displays 'Loading users...', then after a short delay, displays 'List of Users' title followed by a list of user names and emails (e.g., Leanne Graham (Sincere@april.biz)).\n\n**Test Case 2: Error Handling**\n- **Input**: Modify the `url` in `withDataFetching` to an invalid or non-existent endpoint (e.g., `https://jsonplaceholder.typicode.com/invalid-users`). Render `App`.\n- **Expected Output**: Displays an error message in red, e.g., 'Error: HTTP error! status: 404' or a network error.\n\n**Test Case 3: Empty Data**\n- **Input**: Modify the mock API or simulate an empty response (e.g., fetch from an endpoint that returns `[]`).\n- **Expected Output**: Displays 'No users found.'\n\n**Test Case 4: Component Unmount (manual check)**\n- **Input**: Render `App`, then quickly unmount it (e.g., via conditional rendering in a parent component, or using a dev tool to remove it from DOM) while the fetch is still pending.\n- **Expected Output**: No errors in the console related to setting state on an unmounted component. Console should log 'Fetch aborted' if `AbortError` is caught, confirming clean-up.",
            "**Test Case 5: Prop Transparency**\n- **Input**: Ensure `UserList` receives the `title` prop passed from `App`.",
            "- **Expected Output**: The `h2` tag should display 'List of Users'."
          ],
          "hints": [
            "Use `fetch` for the API call.",
            "Remember to use `componentDidMount` for initial data fetching and `componentWillUnmount` for cleanup.",
            "The `AbortController` is critical for preventing 'Can't perform a React state update on an unmounted component' warnings/errors.",
            "Ensure `response.ok` is checked after `fetch` to handle HTTP errors (like 404, 500) correctly, before parsing JSON.",
            "Spread `this.props` to ensure any props passed to the `EnhancedComponent` are also passed down to the `WrappedComponent`."
          ],
          "tags": [
            "React",
            "HOCs",
            "Data Fetching",
            "API Integration",
            "Lifecycle Methods",
            "Error Handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_higher_order_components",
            "react_lifecycle_methods",
            "javascript_async_await_fetch"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "State Injection Pattern",
            "Controlled Components",
            "fetch API"
          ]
        }
      ]
    }
  },
  {
    "id": "24e2797c-36a4-4004-88b8-52a028a351a1",
    "startLine": 4200,
    "endLine": 4299,
    "processedDate": "2025-06-17T09:05:03.762Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_high_order_components",
          "title": "High-Order Components (HOCs)",
          "content": "High-Order Components (HOCs) in React are an advanced technique for reusing component logic. A Higher-Order Component is a function that takes a component as an argument and returns a new component. They are not React components themselves, but rather functions that transform components.\n\n## Core Concept\nAn HOC wraps the original component, enhancing it with additional props, state, or behavior, without modifying the original component itself. This allows for clean separation of concerns and efficient code reuse.\n\n```typescript\ntype HOC<P extends object, T extends object> = (WrappedComponent: React.ComponentType<P>) => React.ComponentType<P & T>;\n\n// Example structure:\nfunction withLogger<P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> {\n  class WithLogger extends React.Component<P> {\n    componentDidMount() {\n      console.log(`${getDisplayName(WrappedComponent)} mounted`);\n    }\n    componentWillUnmount() {\n      console.log(`${getDisplayName(WrappedComponent)} unmounted`);\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n  WithLogger.displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n  return WithLogger;\n}\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n\n## Common HOC Use Cases\nHOCs are powerful for addressing cross-cutting concerns and abstracting state or props. Key use cases include:\n\n1.  **Code Reuse and Cross-Cutting Concerns:**\n    *   **Authentication/Authorization:** Wrapping components to check user permissions or redirect unauthenticated users.\n    *   **Data Fetching and Loading States:** Providing data from an external source and managing loading/error states.\n    *   **Measuring Performance:** Logging render times or tracking component interactions.\n    *   **Error Handling:** Catching errors in child components and displaying fallback UI.\n    *   **Analytics:** Injecting analytics tracking logic.\n\n2.  **State Abstraction:**\n    *   **Managing Form State:** Handling form input values and validation logic.\n    *   **Managing Subscription Data:** Subscribing to external data sources (e.g., Redux store, external APIs) and passing updates as props.\n    *   **Managing Global UI State:** Controlling modals, tooltips, or themes.\n\n3.  **Prop Manipulation:**\n    *   **Filtering or Transforming Props:** Modifying the props passed to the wrapped component.\n    *   **Adding Extra Props:** Injecting additional props that the wrapped component needs (e.g., `theme`, `currentUser`).\n    *   **Renaming Props for Compatibility:** Adapting prop names to fit a specific component's interface.\n\n## HOC Best Practices\nTo leverage HOCs effectively and avoid common pitfalls, follow these best practices:\n\n1.  **Don't Mutate the Original Component:**\n    *   HOCs should aim for pure functions, meaning they don't modify the input component. Instead, they should return a *new* component that wraps the original. Mutating the original component can lead to side effects, make debugging harder, and break component reusability.\n    ```typescript\n    // Bad - mutates the original component (e.g., adding lifecycle methods directly)\n    function withStylesBad<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      // This modifies the prototype of the original component, affecting all instances.\n      // This is generally an anti-pattern in React.\n      (WrappedComponent.prototype as any).componentDidMount = function() { /* ... */ };\n      return WrappedComponent;\n    }\n    \n    // Good - creates a new component that wraps the original\n    function withStylesGood<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      return class extends React.Component<P> {\n        componentDidMount() { \n          console.log(`Component ${getDisplayName(WrappedComponent)} styled.`);\n        }\n        render() {\n          // Passes all original props to the wrapped component\n          return <WrappedComponent {...this.props} />;\n        }\n      };\n    }\n    ```\n\n2.  **Pass Unrelated Props Through:**\n    *   HOCs should pass all props that are not specifically consumed or injected by the HOC itself directly to the wrapped component. This ensures flexibility and prevents unintended prop loss, allowing the wrapped component to receive all necessary external props.\n    ```typescript\n    function withMousePosition<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      interface MouseState {\n        x: number;\n        y: number;\n      }\n      // Defines the props that the HOC adds to the wrapped component\n      interface InjectedProps {\n        mousePosition: MouseState;\n      }\n\n      type Props = P & InjectedProps;\n\n      return class WithMousePosition extends React.Component<Props> {\n        state: MouseState = { x: 0, y: 0 };\n\n        handleMouseMove = (event: MouseEvent) => {\n          this.setState({ x: event.clientX, y: event.clientY });\n        };\n\n        componentDidMount() {\n          window.addEventListener('mousemove', this.handleMouseMove);\n        }\n\n        componentWillUnmount() {\n          window.removeEventListener('mousemove', this.handleMouseMove);\n        }\n\n        render() {\n          // Injects mousePosition but passes through all other props (P type)\n          const { mousePosition, ...restProps } = this.props;\n          return <WrappedComponent mousePosition={this.state} {...(restProps as P)} />;\n        }\n      };\n    }\n    ```\n\n3.  **Maximize Composability:**\n    *   HOCs are designed to be composed together. You can chain them to apply multiple concerns to a single component. For better readability and maintainability, especially with many HOCs, consider using a `compose` utility function (e.g., from Redux or Lodash) which applies HOCs from right to left.\n    ```typescript\n    // Compose multiple HOCs by chaining them\n    const EnhancedComponent = withRouter(withTheme(withAuth(MyComponent)));\n    \n    // Or using a compose utility for cleaner syntax and right-to-left application\n    // (MyComponent -> withAuth -> withTheme -> withRouter)\n    type ComposeFunction = (...fns: Function[]) => (x: any) => any;\n\n    const compose: ComposeFunction = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n\n    const enhance = compose(\n      withRouter,\n      withTheme,\n      withAuth\n    );\n    const EnhancedComponent = enhance(MyComponent);\n    ```\n\n4.  **Convention: Include Display Name for Debugging:**\n    *   Setting a `displayName` for the HOC-returned component helps immensely with debugging in React Developer Tools. It makes the component tree more understandable by providing meaningful names for the wrapped components.\n    ```typescript\n    function withSubscription<P extends object, InjectedProps extends object>(\n      WrappedComponent: React.ComponentType<P & InjectedProps>,\n      selectData: (dataSource: any, props: P) => InjectedProps\n    ): React.ComponentType<P> {\n      interface SubscriptionState extends InjectedProps {}\n\n      class WithSubscription extends React.Component<P, SubscriptionState> {\n        state: SubscriptionState = {} as SubscriptionState; // Initial state based on injected props\n        dataSource: any; // Assume DataSource is defined elsewhere\n\n        componentDidMount() {\n          this.dataSource = {}; // Placeholder for actual data source\n          this.setState(selectData(this.dataSource, this.props));\n        }\n        \n        render() {\n          return <WrappedComponent {...this.props} {...this.state} />;\n        }\n      }\n      \n      // Add a proper displayName for dev tools\n      WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n      \n      return WithSubscription;\n    }\n    \n    function getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n      return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    }\n\n    // Usage Example:\n    interface CommentListProps {\n      postId: string;\n      comments: string[]; // Injected by HOC\n    }\n\n    const CommentList: React.FC<CommentListProps> = ({ postId, comments }) => (\n      <div>\n        <h2>Comments for Post #{postId}</h2>\n        {comments.map((comment, index) => <p key={index}>{comment}</p>)}\n      </div>\n    );\n\n    // Assume a DataSource exists globally or is passed in\n    const DataSource = {\n      getComments: (postId: string) => {\n        console.log(`Fetching comments for post ${postId}`);\n        return { comments: [`Comment 1 for ${postId}`, `Comment 2 for ${postId}`] };\n      }\n    };\n\n    const CommentListWithSubscription = withSubscription(\n      CommentList,\n      (source, props) => DataSource.getComments(props.postId)\n    );\n\n    // Example of how it would be rendered:\n    // <CommentListWithSubscription postId=\"123\" />\n    ```\n\n## Limitations of HOCs\nWhile powerful, HOCs have certain limitations:\n\n*   **Don't use HOCs inside the `render` method:** Creating a new HOC-returned component inside `render` will cause the component to unmount and remount every time the parent renders. This leads to performance issues (lost state, unnecessary re-renders) and identity problems (e.g., `shouldComponentUpdate` failing).\n*   **Static methods must be copied over manually or with a utility:** If your wrapped component has static methods (e.g., `MyComponent.someStaticMethod`), these are not automatically copied to the new component returned by the HOC. You need to copy them explicitly or use a utility like `hoist-non-react-statics`.\n*   **Refs aren't passed through automatically (use `React.forwardRef`):** Refs created on the HOC-returned component will refer to the HOC instance, not the instance of the wrapped component. To get a ref to the actual wrapped component, you must use `React.forwardRef` within your HOC to pass the ref down.\n",
          "examples": [
            {
              "id": "example_hoc_basic_usage",
              "title": "Basic HOC Usage: `withSubscription`",
              "code": "import React from 'react';\n\ninterface CommentListProps {\n  postId: string;\n  comments: string[]; // This prop is injected by the HOC\n}\n\nconst CommentList: React.FC<CommentListProps> = ({ postId, comments }) => (\n  <div>\n    <h3>Comments for Post #{postId}</h3>\n    {comments.length > 0 ? (\n      <ul>\n        {comments.map((comment, index) => (\n          <li key={index}>{comment}</li>\n        ))}\n      </ul>\n    ) : (\n      <p>No comments available.</p>\n    )}\n  </div>\n);\n\n// Placeholder for a data source. In a real app, this would be more sophisticated.\nconst DataSource = {\n  getComments: (postId: string) => {\n    // Simulate API call\n    return { comments: [`Comment A for ${postId}`, `Comment B for ${postId}`] };\n  },\n  // Other data fetching methods...\n};\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface InjectedSubscriptionProps {\n  comments: string[];\n}\n\n// HOC definition\nfunction withSubscription<P extends object>(\n  WrappedComponent: React.ComponentType<P & InjectedSubscriptionProps>,\n  selectData: (dataSource: typeof DataSource, props: P) => InjectedSubscriptionProps\n): React.ComponentType<P> {\n  class WithSubscription extends React.Component<P, InjectedSubscriptionProps> {\n    static displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n\n    state: InjectedSubscriptionProps = { comments: [] };\n\n    componentDidMount() {\n      this.setState(selectData(DataSource, this.props));\n    }\n\n    render() {\n      // Pass down all original props AND the injected state (comments)\n      return <WrappedComponent {...this.props} {...this.state} />;\n    }\n  }\n  return WithSubscription;\n}\n\n// Usage\nconst CommentListWithSubscription = withSubscription(\n  CommentList,\n  (source, props) => source.getComments(props.postId)\n);\n\n// How you would use CommentListWithSubscription in your application:\n// <CommentListWithSubscription postId=\"1\" />\n",
              "explanation": "This example demonstrates a common HOC pattern: data subscription. The `withSubscription` HOC takes a `CommentList` component and a `selectData` function. It then internally manages fetching 'comments' based on `props.postId` using a `DataSource`. The fetched `comments` are then injected as props into the `CommentList`. This separates data fetching logic from the presentational component, making `CommentList` reusable and focused solely on rendering comments.",
              "language": "typescript"
            },
            {
              "id": "example_hoc_prop_passthrough",
              "title": "HOC: Passing Unrelated Props Through",
              "code": "import React from 'react';\n\ninterface MyComponentProps {\n  message: string;\n  value: number; // This prop is passed through by the HOC\n  timestamp: Date; // This prop is added by the HOC\n}\n\nconst MyComponent: React.FC<MyComponentProps> = ({ message, value, timestamp }) => (\n  <div>\n    <p>Message: {message}</p>\n    <p>Value from parent: {value}</p>\n    <p>Timestamp from HOC: {timestamp.toLocaleString()}</p>\n  </div>\n);\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface WithTimestampProps {\n  timestamp: Date;\n}\n\nfunction withTimestamp<P extends object>(WrappedComponent: React.ComponentType<P & WithTimestampProps>): React.ComponentType<P> {\n  class WithTimestamp extends React.Component<P> {\n    static displayName = `WithTimestamp(${getDisplayName(WrappedComponent)})`;\n\n    render() {\n      // The HOC injects a 'timestamp' prop.\n      // All other props (of type P) are passed through using {...this.props}.\n      return <WrappedComponent {...this.props as P} timestamp={new Date()} />;\n    }\n  }\n  return WithTimestamp;\n}\n\n// Usage\nconst EnhancedMyComponent = withTimestamp(MyComponent);\n\n// Example of how it would be rendered:\n// <EnhancedMyComponent message=\"Hello HOC!\" value={42} />\n",
              "explanation": "This example showcases the best practice of passing unrelated props through an HOC. The `withTimestamp` HOC adds a `timestamp` prop to `MyComponent`. Critically, `MyComponent` also expects `message` and `value` props directly from its parent. The `WithTimestamp` HOC ensures that `message` and `value` are correctly passed down to `MyComponent` by using `{...this.props}` in its `render` method, alongside the newly injected `timestamp` prop.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_hoc_definition_1",
            "question_hoc_use_cases_mcq_1",
            "question_hoc_best_practice_mutation_1",
            "question_hoc_props_passthrough_open_1",
            "question_hoc_limitations_render_1",
            "question_hoc_forwardref_mcq_1",
            "question_hoc_static_methods_open_1",
            "question_hoc_composability_mcq_1",
            "question_hoc_displayname_flashcard_1"
          ],
          "relatedTasks": [
            "task_hoc_logger",
            "task_hoc_data_loader",
            "task_hoc_access_control",
            "task_hoc_combine_features"
          ],
          "tags": [
            "React",
            "HOC",
            "Higher-Order Components",
            "Component Patterns",
            "Code Reuse",
            "State Management",
            "Prop Manipulation",
            "Best Practices"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "JavaScript Functions",
            "Props",
            "State",
            "Lifecycle Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Custom Hooks",
            "Advanced React Patterns",
            "Component Architecture"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_hoc_definition_1",
          "topic": "High-Order Components (HOCs) Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a High-Order Component (HOC) in React?",
          "answer": "A function that takes a component as an argument and returns a new component with enhanced capabilities.",
          "options": [],
          "analysisPoints": [
            "Identifies HOCs as functions, not components.",
            "Recognizes their role in transforming/enhancing components."
          ],
          "keyConcepts": [
            "HOC",
            "Function as Component Transformer"
          ],
          "evaluationCriteria": [
            "Basic recall of HOC definition",
            "Understanding of its functional nature"
          ],
          "example": "",
          "tags": [
            "HOC",
            "Definition",
            "React Basics"
          ],
          "prerequisites": [
            "React Components",
            "JavaScript Functions"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoc_use_cases_mcq_1",
          "topic": "Common HOC Use Cases",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is LEAST likely to be a common use case for a High-Order Component (HOC)?",
          "answer": "Directly manipulating the DOM structure of a component's children without using React's declarative API.",
          "options": [
            "Implementing authentication checks and redirecting unauthenticated users.",
            "Managing data fetching logic and displaying loading/error states.",
            "Injecting analytics tracking code into multiple components.",
            "Directly manipulating the DOM structure of a component's children without using React's declarative API."
          ],
          "analysisPoints": [
            "Tests understanding of HOC's primary purpose (logic reuse, prop/state enhancement).",
            "Identifies scenarios where HOCs are typically applied (cross-cutting concerns, data, state).",
            "Recognizes that direct DOM manipulation is generally an anti-pattern in React and not a role for HOCs, which work at the component level."
          ],
          "keyConcepts": [
            "HOC Use Cases",
            "Cross-Cutting Concerns",
            "Data Fetching",
            "Authentication",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Ability to differentiate appropriate vs. inappropriate HOC use",
            "Understanding of React's declarative nature"
          ],
          "example": "HOCs abstract logic and enhance components by providing props or state, or wrapping them with additional behavior. Direct DOM manipulation typically violates React's declarative paradigm and is usually handled through refs or imperative APIs when absolutely necessary, not via an HOC.",
          "tags": [
            "HOC",
            "Use Cases",
            "Anti-patterns"
          ],
          "prerequisites": [
            "React Components",
            "HOC Concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_best_practice_mutation_1",
          "topic": "HOC Best Practices: No Mutation",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following High-Order Component implementation:\n```typescript\nfunction withLogger(WrappedComponent) {\n  WrappedComponent.prototype.componentDidMount = function() {\n    console.log(`${WrappedComponent.name} mounted.`);\n  };\n  return WrappedComponent;\n}\n\nclass MyComponent extends React.Component {\n  render() {\n    return <div>Hello</div>;\n  }\n}\n\nconst EnhancedMyComponent = withLogger(MyComponent);\n```\nWhat is the primary best practice violation in the `withLogger` HOC?",
          "answer": "It mutates the original `WrappedComponent` by directly modifying its prototype.",
          "options": [
            "It doesn't pass through unrelated props.",
            "It doesn't set a `displayName` for debugging.",
            "It mutates the original `WrappedComponent` by directly modifying its prototype.",
            "It cannot be composed with other HOCs."
          ],
          "analysisPoints": [
            "Identifies the core issue of mutating the original component.",
            "Understands why direct prototype modification is harmful (side effects, unexpected behavior)."
          ],
          "keyConcepts": [
            "HOC Best Practices",
            "Immutability",
            "Component Mutation",
            "Prototype Chain"
          ],
          "evaluationCriteria": [
            "Recognition of HOC anti-patterns",
            "Understanding of JavaScript prototype behavior"
          ],
          "example": "The HOC `withLogger` directly adds a `componentDidMount` method to the `WrappedComponent`'s prototype. This is bad because it changes the original component itself, leading to unintended side effects on all instances of `MyComponent`, even those not wrapped by `withLogger`. A good HOC should always return a *new* component that wraps the original, preserving the original component's integrity.",
          "tags": [
            "HOC",
            "Best Practices",
            "Mutation",
            "Anti-pattern"
          ],
          "prerequisites": [
            "React HOCs",
            "JavaScript Prototypes"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_props_passthrough_open_1",
          "topic": "HOC Best Practices: Prop Passthrough",
          "level": "medium",
          "type": "open",
          "question": "Explain why it's a critical best practice for High-Order Components (HOCs) to pass through all unrelated props to the wrapped component. Provide a small code snippet demonstrating this.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explains that HOCs should not block props from reaching the wrapped component.",
            "Highlights the importance of flexibility and reusability.",
            "Demonstrates `spread` operator (`{...this.props}`) for prop passthrough.",
            "Mentions avoiding unexpected behavior or prop loss."
          ],
          "keyConcepts": [
            "HOC Best Practices",
            "Prop Passthrough",
            "Component Flexibility",
            "Spread Operator"
          ],
          "evaluationCriteria": [
            "Clarity of explanation",
            "Correct code demonstration",
            "Understanding of HOC's role in prop management"
          ],
          "example": "It's critical for HOCs to pass through all unrelated props to the wrapped component to maintain the wrapped component's flexibility and reusability. If an HOC consumes some props (e.g., `data` for data fetching) and adds others (e.g., `isLoading`), it should still pass through any other props that the parent component might provide and that the wrapped component expects. Failing to do so would lead to 'prop drilling' issues, where parent components would need to know which props an HOC consumes, or worse, wrapped components would mysteriously lose expected props.\n\n```typescript\nfunction withFeatureToggle<P extends object>(WrappedComponent: React.ComponentType<P & { isFeatureEnabled: boolean }>) {\n  return class WithFeatureToggle extends React.Component<P> {\n    render() {\n      const isFeatureEnabled = Math.random() > 0.5; // Example toggle logic\n      // Pass the new 'isFeatureEnabled' prop AND all original props down\n      return <WrappedComponent {...this.props as P} isFeatureEnabled={isFeatureEnabled} />;\n    }\n  };\n}\n```",
          "tags": [
            "HOC",
            "Best Practices",
            "Props",
            "Reusability"
          ],
          "prerequisites": [
            "HOC Fundamentals",
            "React Props"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_limitations_render_1",
          "topic": "HOC Limitations: Usage in Render",
          "level": "medium",
          "type": "open",
          "question": "Why should you avoid creating a High-Order Component (HOC) inside the `render` method of another component?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explains that HOCs in `render` create a *new* component class on every render.",
            "Discusses the implications: unnecessary unmounting/remounting.",
            "Mentions loss of state and performance degradation.",
            "Connects it to React's reconciliation process and component identity."
          ],
          "keyConcepts": [
            "HOC Limitations",
            "Render Method",
            "Performance",
            "Component Lifecycle",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Understanding of React's internal mechanisms",
            "Ability to articulate performance implications"
          ],
          "example": "Creating an HOC inside the `render` method of another component is an anti-pattern because it causes a *new component class* to be created on every render. React's reconciliation algorithm relies on component identity to determine if it should update an existing component instance or unmount the old one and mount a new one. When a new component class is created each time, React sees it as a completely new component, even if its props haven't changed. This leads to:\n\n1.  **Lost State:** The component's internal state (from `useState` or `this.state`) and any DOM state will be reset.\n2.  **Performance Issues:** Unnecessary unmounting and remounting incurs overhead and can trigger costly re-renders of the component's entire subtree.\n3.  **Ref Issues:** Any refs attached to the component will break or point to newly created instances.\n\nInstead, HOCs should be defined outside the `render` method, typically at the top level of a module, so that the component class they return is stable across renders.",
          "tags": [
            "HOC",
            "Limitations",
            "Performance",
            "Anti-pattern"
          ],
          "prerequisites": [
            "React Component Lifecycle",
            "React Reconciliation"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_forwardref_mcq_1",
          "topic": "HOC Limitations: Refs",
          "level": "hard",
          "type": "mcq",
          "question": "You've created a High-Order Component `withAuth` that wraps `MyButton`. If you try to attach a ref directly to `EnhancedMyButton = withAuth(MyButton)`, like `<EnhancedMyButton ref={myRef} />`, what will `myRef.current` typically refer to?",
          "answer": "An instance of the `withAuth` HOC component itself, not `MyButton`.",
          "options": [
            "An instance of the `MyButton` component.",
            "An instance of the `withAuth` HOC component itself, not `MyButton`.",
            "A DOM element if `MyButton` is a native HTML element.",
            "The ref will be `null` because HOCs prevent refs from being passed."
          ],
          "analysisPoints": [
            "Tests understanding of how refs interact with HOCs.",
            "Identifies `React.forwardRef` as the solution.",
            "Distinguishes between the HOC instance and the wrapped component instance."
          ],
          "keyConcepts": [
            "HOC Limitations",
            "Refs",
            "React.forwardRef",
            "Component Instances"
          ],
          "evaluationCriteria": [
            "Deep understanding of React refs and HOC interaction",
            "Knowledge of `forwardRef` solution"
          ],
          "example": "When you attach a ref to a component wrapped by an HOC, the ref by default points to the *instance of the HOC component*, not the instance of the component it wraps. This is because the HOC creates a new component that renders the wrapped component as its child. To get a ref to the `MyButton` component (the wrapped component), you need to explicitly forward the ref using `React.forwardRef` within your HOC. Without `forwardRef`, `myRef.current` would refer to the internal instance of the `WithAuth` class component.",
          "tags": [
            "HOC",
            "Limitations",
            "Refs",
            "React.forwardRef"
          ],
          "prerequisites": [
            "React Refs",
            "HOCs"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_static_methods_open_1",
          "topic": "HOC Limitations: Static Methods",
          "level": "medium",
          "type": "open",
          "question": "A component `MyForm` has a static method `MyForm.validateInput()`. If `MyForm` is wrapped by an HOC `withFormState`, will `EnhancedMyForm.validateInput()` be accessible automatically? If not, how can you make it accessible?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explains that static methods are not automatically copied.",
            "Describes the reason: HOC returns a new component, not the original.",
            "Provides solutions: manual copy or `hoist-non-react-statics`.",
            "Includes a code snippet for manual copying."
          ],
          "keyConcepts": [
            "HOC Limitations",
            "Static Methods",
            "Component Properties",
            "hoist-non-react-statics"
          ],
          "evaluationCriteria": [
            "Understanding of static method behavior with HOCs",
            "Knowledge of practical solutions"
          ],
          "example": "No, `EnhancedMyForm.validateInput()` will not be accessible automatically. When an HOC wraps a component, it returns a *new* component class. Static methods defined on the original `MyForm` component are properties of that specific class constructor, not its instances. The HOC's returned component is a different class, so it won't inherit `MyForm`'s static methods by default.\n\nTo make them accessible, you need to explicitly copy the static methods from the `WrappedComponent` to the `NewComponent` returned by the HOC. This can be done manually or by using a utility like `hoist-non-react-statics`.\n\n**Manual Copying:**\n```typescript\nfunction withFormState<P extends object>(WrappedComponent: React.ComponentType<P>) {\n  class WithFormState extends React.Component<P> {\n    // ... HOC logic ...\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  // Manually copy static methods\n  for (let key in WrappedComponent) {\n    if (typeof (WrappedComponent as any)[key] === 'function') {\n      (WithFormState as any)[key] = (WrappedComponent as any)[key];\n    }\n  }\n\n  return WithFormState;\n}\n```\n\nFor more robust solutions, `hoist-non-react-statics` is commonly used as it correctly handles all React-specific static properties.",
          "tags": [
            "HOC",
            "Limitations",
            "Static Methods",
            "hoist-non-react-statics"
          ],
          "prerequisites": [
            "HOCs",
            "JavaScript Classes",
            "Static Methods"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_composability_mcq_1",
          "topic": "HOC Best Practices: Composability",
          "level": "medium",
          "type": "mcq",
          "question": "You have three HOCs: `withAuth`, `withLogger`, and `withTheme`. You want to apply them to `MyComponent` in a way that `withAuth` is applied first, then `withLogger`, then `withTheme`. Which of the following correctly demonstrates a highly composable and readable way to achieve this?\n\nAssume a `compose` utility function is available that applies functions from right to left.\n\n```typescript\nconst compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n```",
          "answer": "```typescript\nconst enhance = compose(\n  withTheme,\n  withLogger,\n  withAuth\n);\nconst EnhancedComponent = enhance(MyComponent);\n```",
          "options": [
            "```typescript\nconst EnhancedComponent = withAuth(withLogger(withTheme(MyComponent)));\n```",
            "```typescript\nconst EnhancedComponent = withTheme(withLogger(withAuth(MyComponent)));\n```",
            "```typescript\nconst enhance = compose(\n  withTheme,\n  withLogger,\n  withAuth\n);\nconst EnhancedComponent = enhance(MyComponent);\n```",
            "```typescript\nconst enhance = compose(\n  withAuth,\n  withLogger,\n  withTheme\n);\nconst EnhancedComponent = enhance(MyComponent);\n```"
          ],
          "analysisPoints": [
            "Tests understanding of HOC chaining/composition.",
            "Verifies knowledge of `compose` utility's typical right-to-left application.",
            "Recognizes that `compose(f, g, h)(x)` is equivalent to `f(g(h(x)))`."
          ],
          "keyConcepts": [
            "HOC Composability",
            "Function Composition",
            "Compose Utility"
          ],
          "evaluationCriteria": [
            "Correct application of functional composition principles",
            "Readability and best practices in HOC usage"
          ],
          "example": "The `compose` function typically applies its arguments from right to left. So, `compose(f, g, h)(x)` means `f(g(h(x)))`. To apply `withAuth` first to `MyComponent`, then `withLogger`, then `withTheme`, the order of application should be `withTheme(withLogger(withAuth(MyComponent)))`. Therefore, `withAuth` should be the rightmost argument to `compose`, followed by `withLogger`, and then `withTheme` as the leftmost argument.",
          "tags": [
            "HOC",
            "Composability",
            "Functional Programming",
            "Compose"
          ],
          "prerequisites": [
            "HOCs",
            "JavaScript Functions",
            "Functional Programming Concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_displayname_flashcard_1",
          "topic": "HOC Best Practices: Display Name",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of setting a `displayName` property for the component returned by an HOC?",
          "answer": "It improves debugging experience in React Developer Tools by providing meaningful names in the component tree.",
          "options": [],
          "analysisPoints": [
            "Connects `displayName` to debugging tools.",
            "Highlights the clarity it adds to the component tree."
          ],
          "keyConcepts": [
            "HOC Best Practices",
            "Debugging",
            "React Developer Tools",
            "DisplayName"
          ],
          "evaluationCriteria": [
            "Basic recall of `displayName` purpose"
          ],
          "example": "",
          "tags": [
            "HOC",
            "Debugging",
            "Best Practices"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_hoc_logger",
          "title": "Implement a `withLogger` HOC",
          "description": "\nImplement a High-Order Component `withLogger` that logs when a wrapped component mounts and unmounts. This HOC should:\n\n1.  Take a `WrappedComponent` as an argument.\n2.  Return a new component that renders the `WrappedComponent`.\n3.  Log a message to the console in `componentDidMount` indicating the component has mounted (e.g., \"MyComponent mounted\").\n4.  Log a message in `componentWillUnmount` indicating the component has unmounted (e.g., \"MyComponent unmounted\").\n5.  Ensure all props passed to the HOC are correctly forwarded to the `WrappedComponent`.\n6.  Set a proper `displayName` for the returned component for better debugging.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// Helper to get component display name\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n// Your task: Implement withLogger HOC\nfunction withLogger<P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> {\n  // TODO: Implement the HOC logic here\n  return class extends React.Component<P> {\n    // ...\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n}\n\n// Example Usage (for testing your HOC)\ninterface GreetProps {\n  name: string;\n}\n\nconst Greet: React.FC<GreetProps> = ({ name }) => {\n  return <div>Hello, {name}!</div>;\n};\n\nconst GreetWithLogger = withLogger(Greet);\n\n// To test, you might render GreetWithLogger within another component \n// that controls its mounting/unmounting or use a testing framework.\n// Example:\n/*\nconst App = () => {\n  const [show, setShow] = React.useState(true);\n  return (\n    <div>\n      <button onClick={() => setShow(!show)}>Toggle Greet</button>\n      {show && <GreetWithLogger name=\"World\" />}\n    </div>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById('root'));\n*/\n",
          "solutionCode": "import React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nfunction withLogger<P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> {\n  class WithLogger extends React.Component<P> {\n    static displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n\n    componentDidMount() {\n      console.log(`${getDisplayName(WrappedComponent)} mounted`);\n    }\n\n    componentWillUnmount() {\n      console.log(`${getDisplayName(WrappedComponent)} unmounted`);\n    }\n\n    render() {\n      // Pass all props through to the wrapped component\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return WithLogger;\n}\n\ninterface GreetProps {\n  name: string;\n}\n\nconst Greet: React.FC<GreetProps> = ({ name }) => {\n  return <div>Hello, {name}!</div>;\n};\n\nconst GreetWithLogger = withLogger(Greet);\n\n// Test component to demonstrate mounting/unmounting\nconst TestLoggerApp: React.FC = () => {\n  const [showGreet, setShowGreet] = React.useState(true);\n\n  React.useEffect(() => {\n    // Simulate unmounting after a delay\n    const timer = setTimeout(() => setShowGreet(false), 2000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return (\n    <div>\n      <h1>Logger HOC Test</h1>\n      {showGreet ? <GreetWithLogger name=\"User\" /> : <p>Greet component unmounted.</p>}\n    </div>\n  );\n};\n\n// Usage example for a real environment:\n// ReactDOM.render(<TestLoggerApp />, document.getElementById('root'));\n",
          "testCases": [
            "When `GreetWithLogger` is first rendered, 'Greet mounted' should appear in the console.",
            "When `GreetWithLogger` is removed from the DOM (e.g., by toggling its visibility), 'Greet unmounted' should appear in the console.",
            "Verify that props (e.g., `name=\"User\"`) are correctly passed to the `Greet` component.",
            "Check that the `displayName` for the component in React Dev Tools reflects `withLogger(Greet)`."
          ],
          "hints": [
            "Remember that lifecycle methods like `componentDidMount` and `componentWillUnmount` are class component methods.",
            "The `super(props)` call is crucial if you're writing a class component and using `this.props` in the constructor.",
            "The `getDisplayName` helper function is provided to assist with setting the `displayName`."
          ],
          "tags": [
            "React",
            "HOC",
            "Lifecycle Methods",
            "Logging",
            "Best Practices"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Class Components",
            "React Lifecycle",
            "HOC Fundamentals"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Lifecycle",
            "Cross-Cutting Concerns",
            "Debugging"
          ]
        },
        {
          "id": "task_hoc_data_loader",
          "title": "Implement a `withDataLoader` HOC",
          "description": "\nCreate a High-Order Component `withDataLoader` that fetches data from a simulated API and passes it as props to the wrapped component. This HOC should:\n\n1.  Accept a `WrappedComponent` and a `dataFetcher` function as arguments.\n2.  The `dataFetcher` function should take the HOC's props and return a Promise that resolves with the data.\n3.  Manage `loading` and `error` states internally.\n4.  Render a 'Loading...' message when data is being fetched.\n5.  Render an 'Error: [message]' if data fetching fails.\n6.  Once data is successfully fetched, pass the data (e.g., as a prop named `data`) along with `isLoading` and `error` flags to the `WrappedComponent`.\n7.  Ensure all other props are passed through.\n8.  Set a `displayName`.\n\n**Simulated API:**\n```typescript\nconst simulatedApi = {\n  fetchUserData: (userId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 'error') {\n        reject(new Error('Failed to fetch user data.'));\n      } else if (userId === '1') {\n        resolve({ id: '1', name: 'Alice', email: 'alice@example.com' });\n      } else if (userId === '2') {\n        resolve({ id: '2', name: 'Bob', email: 'bob@example.com' });\n      } else {\n        resolve(null);\n      }\n    }, 1000);\n  }),\n  fetchProductData: (productId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (productId === 'error') {\n        reject(new Error('Product data not found.'));\n      } else if (productId === 'P1') {\n        resolve({ id: 'P1', name: 'Laptop', price: 1200 });\n      } else {\n        resolve(null);\n      }\n    }, 800);\n  })\n};\n```\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\n// Helper to get component display name\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n// Simulated API (provided in description)\nconst simulatedApi = {\n  fetchUserData: (userId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 'error') {\n        reject(new Error('Failed to fetch user data.'));\n      } else if (userId === '1') {\n        resolve({ id: '1', name: 'Alice', email: 'alice@example.com' });\n      } else if (userId === '2') {\n        resolve({ id: '2', name: 'Bob', email: 'bob@example.com' });\n      } else {\n        resolve(null);\n      }\n    }, 1000);\n  }),\n  fetchProductData: (productId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (productId === 'error') {\n        reject(new Error('Product data not found.'));\n      } else if (productId === 'P1') {\n        resolve({ id: 'P1', name: 'Laptop', price: 1200 });\n      } else {\n        resolve(null);\n      }\n    }, 800);\n  })\n};\n\n// Your task: Implement withDataLoader HOC\n// P: Props for the HOC (which are also passed to the dataFetcher)\n// D: Type of the data fetched\n// InjectedProps: { data: D | null, isLoading: boolean, error: Error | null }\nfunction withDataLoader<P extends object, D>(\n  WrappedComponent: React.ComponentType<P & { data: D | null, isLoading: boolean, error: Error | null }>,\n  dataFetcher: (props: P) => Promise<D | null>\n): React.ComponentType<P> {\n  // TODO: Implement the HOC logic here\n  // Consider initial state, lifecycle methods for fetching, and error handling.\n\n  return class extends React.Component<P> {\n    // ...\n    render() {\n      // This is a placeholder. You'll need to manage loading/error/data states.\n      return <WrappedComponent {...this.props} data={null} isLoading={false} error={null} />;\n    }\n  };\n}\n\n// Example usage component 1:\ninterface UserDisplayProps {\n  userId: string;\n  data: { id: string; name: string; email: string } | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nconst UserDisplay: React.FC<UserDisplayProps> = ({ userId, data, isLoading, error }) => {\n  if (isLoading) return <p>Loading user {userId}...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n  if (!data) return <p>User {userId} not found.</p>;\n  return (\n    <div>\n      <h3>User Details (ID: {data.id})</h3>\n      <p>Name: {data.name}</p>\n      <p>Email: {data.email}</p>\n    </div>\n  );\n};\n\n// Example usage component 2:\ninterface ProductDisplayProps {\n  productId: string;\n  data: { id: string; name: string; price: number } | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nconst ProductDisplay: React.FC<ProductDisplayProps> = ({ productId, data, isLoading, error }) => {\n  if (isLoading) return <p>Loading product {productId}...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n  if (!data) return <p>Product {productId} not found.</p>;\n  return (\n    <div>\n      <h3>Product Details (ID: {data.id})</h3>\n      <p>Name: {data.name}</p>\n      <p>Price: ${data.price}</p>\n    </div>\n  );\n};\n\nconst UserDataLoader = withDataLoader(UserDisplay, (props: { userId: string }) => simulatedApi.fetchUserData(props.userId));\nconst ProductDataLoader = withDataLoader(ProductDisplay, (props: { productId: string }) => simulatedApi.fetchProductData(props.productId));\n\n// Example of how to use the DataLoader HOCs in a parent component:\n/*\nconst App = () => (\n  <div>\n    <UserDataLoader userId=\"1\" />\n    <hr />\n    <ProductDataLoader productId=\"P1\" />\n    <hr />\n    <UserDataLoader userId=\"error\" />\n    <hr />\n    <ProductDataLoader productId=\"non-existent\" />\n  </div>\n);\n\nReactDOM.render(<App />, document.getElementById('root'));\n*/\n",
          "solutionCode": "import React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nconst simulatedApi = {\n  fetchUserData: (userId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 'error') {\n        reject(new Error('Failed to fetch user data.'));\n      } else if (userId === '1') {\n        resolve({ id: '1', name: 'Alice', email: 'alice@example.com' });\n      } else if (userId === '2') {\n        resolve({ id: '2', name: 'Bob', email: 'bob@example.com' });\n      } else {\n        resolve(null);\n      }\n    }, 1000);\n  }),\n  fetchProductData: (productId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (productId === 'error') {\n        reject(new Error('Product data not found.'));\n      } else if (productId === 'P1') {\n        resolve({ id: 'P1', name: 'Laptop', price: 1200 });\n      } else {\n        resolve(null);\n      }\n    }, 800);\n  })\n};\n\ninterface DataLoaderState<D> {\n  data: D | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nfunction withDataLoader<P extends object, D>(\n  WrappedComponent: React.ComponentType<P & DataLoaderState<D>>,\n  dataFetcher: (props: P) => Promise<D | null>\n): React.ComponentType<P> {\n  class WithDataLoader extends React.Component<P, DataLoaderState<D>> {\n    static displayName = `withDataLoader(${getDisplayName(WrappedComponent)})`;\n\n    state: DataLoaderState<D> = {\n      data: null,\n      isLoading: false,\n      error: null,\n    };\n\n    private mounted = false; // To prevent setting state on unmounted component\n\n    componentDidMount() {\n      this.mounted = true;\n      this.fetchData();\n    }\n\n    componentDidUpdate(prevProps: P) {\n      // Re-fetch data if relevant props change\n      if (JSON.stringify(this.props) !== JSON.stringify(prevProps)) {\n        this.fetchData();\n      }\n    }\n\n    componentWillUnmount() {\n      this.mounted = false;\n    }\n\n    fetchData = async () => {\n      if (!this.mounted) return;\n      this.setState({ isLoading: true, error: null });\n      try {\n        const result = await dataFetcher(this.props);\n        if (this.mounted) {\n          this.setState({ data: result, isLoading: false });\n        }\n      } catch (err: any) {\n        if (this.mounted) {\n          this.setState({ error: err, isLoading: false });\n        }\n      }\n    };\n\n    render() {\n      const { data, isLoading, error } = this.state;\n      return (\n        <WrappedComponent\n          {...this.props as P}\n          data={data}\n          isLoading={isLoading}\n          error={error}\n        />\n      );\n    }\n  }\n\n  return WithDataLoader;\n}\n\ninterface UserDisplayProps {\n  userId: string;\n  data: { id: string; name: string; email: string } | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nconst UserDisplay: React.FC<UserDisplayProps> = ({ userId, data, isLoading, error }) => {\n  if (isLoading) return <p>Loading user {userId}...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n  if (!data) return <p>User {userId} not found.</p>;\n  return (\n    <div>\n      <h3>User Details (ID: {data.id})</h3>\n      <p>Name: {data.name}</p>\n      <p>Email: {data.email}</p>\n    </div>\n  );\n};\n\ninterface ProductDisplayProps {\n  productId: string;\n  data: { id: string; name: string; price: number } | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nconst ProductDisplay: React.FC<ProductDisplayProps> = ({ productId, data, isLoading, error }) => {\n  if (isLoading) return <p>Loading product {productId}...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n  if (!data) return <p>Product {productId} not found.</p>;\n  return (\n    <div>\n      <h3>Product Details (ID: {data.id})</h3>\n      <p>Name: {data.name}</p>\n      <p>Price: ${data.price}</p>\n    </div>\n  );\n};\n\nconst UserDataLoader = withDataLoader(UserDisplay, (props: { userId: string }) => simulatedApi.fetchUserData(props.userId));\nconst ProductDataLoader = withDataLoader(ProductDisplay, (props: { productId: string }) => simulatedApi.fetchProductData(props.productId));\n\nconst App: React.FC = () => (\n  <div>\n    <UserDataLoader userId=\"1\" />\n    <hr />\n    <ProductDataLoader productId=\"P1\" />\n    <hr />\n    <UserDataLoader userId=\"error\" />\n    <hr />\n    <ProductDataLoader productId=\"non-existent\" />\n    <hr />\n    {/* Test re-fetching on prop change */}\n    <UserDataLoader userId=\"2\" />\n  </div>\n);\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n",
          "testCases": [
            "Render `UserDataLoader` with `userId=\"1\"`. It should show 'Loading...' then 'User Details (ID: 1)'.",
            "Render `ProductDataLoader` with `productId=\"P1\"`. It should show 'Loading...' then 'Product Details (ID: P1)'.",
            "Render `UserDataLoader` with `userId=\"error\"`. It should show 'Loading...' then 'Error: Failed to fetch user data.'.",
            "Render `ProductDataLoader` with `productId=\"non-existent\"`. It should show 'Loading...' then 'Product P1 not found.' (or similar for null data).",
            "Render a component wrapped by `withDataLoader` where the data-fetching prop changes. Verify that data is re-fetched and states update correctly.",
            "Ensure `displayName` is set correctly for debugging.",
            "Verify that unrelated props are passed correctly if `WrappedComponent` expects them (e.g., `<UserDataLoader userId=\"1\" extraProp=\"test\" />`)."
          ],
          "hints": [
            "Use `componentDidMount` to initiate the initial data fetch.",
            "Use `componentDidUpdate` to handle re-fetching data when the HOC's props change.",
            "Remember to handle the `Promise` resolution and rejection for success and error states.",
            "Set `isLoading` to `true` before fetching and `false` after the promise resolves or rejects.",
            "Don't forget to pass all existing `this.props` to the `WrappedComponent` along with the new `data`, `isLoading`, and `error` props.",
            "Consider adding a flag like `this.mounted` in `componentDidMount` and setting it to `false` in `componentWillUnmount` to prevent setting state on an unmounted component, which can lead to memory leaks or warnings."
          ],
          "tags": [
            "React",
            "HOC",
            "Data Fetching",
            "Loading States",
            "Error Handling",
            "Async Operations"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Class Components",
            "React Lifecycle",
            "Promises",
            "HOC Fundamentals",
            "TypeScript Generics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Fetch API",
            "Component Composition",
            "State Management Patterns"
          ]
        },
        {
          "id": "task_hoc_access_control",
          "title": "Build a `withAccessControl` HOC",
          "description": "\nDevelop a High-Order Component `withAccessControl` that enforces access permissions based on user roles. This HOC should:\n\n1.  Take a `WrappedComponent` and an array of `requiredRoles` (e.g., `['admin', 'editor']`) as arguments.\n2.  Assume there's a `UserContext` or a global `authService` that provides the `currentUser` object, which has a `roles` array (e.g., `['viewer']`).\n3.  If the `currentUser` has at least one of the `requiredRoles`:\n    *   Render the `WrappedComponent` with all its original props.\n4.  If the `currentUser` does NOT have any of the `requiredRoles`:\n    *   Render a fallback `Unauthorized` message (e.g., `<div>Access Denied</div>`).\n    *   Alternatively, accept an optional `fallbackComponent` prop to render instead.\n5.  Ensure all props are passed through.\n6.  Set a `displayName`.\n\n**Mock `AuthService` (for context):**\n```typescript\ninterface User {\n  id: string;\n  name: string;\n  roles: string[];\n}\n\nconst authService = {\n  currentUser: null as User | null,\n  login: (user: User) => { authService.currentUser = user; },\n  logout: () => { authService.currentUser = null; },\n  getCurrentUser: () => authService.currentUser,\n  hasRole: (role: string) => authService.currentUser?.roles.includes(role) || false,\n  hasAnyRole: (roles: string[]) => roles.some(role => authService.hasRole(role)),\n};\n\n// Simulate different users\nconst adminUser: User = { id: 'u1', name: 'Admin User', roles: ['admin', 'viewer'] };\nconst editorUser: User = { id: 'u2', name: 'Editor User', roles: ['editor', 'viewer'] };\nconst viewerUser: User = { id: 'u3', name: 'Viewer User', roles: ['viewer'] };\nconst noRoleUser: User = { id: 'u4', name: 'Guest User', roles: [] };\n```\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// Helper to get component display name\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface User {\n  id: string;\n  name: string;\n  roles: string[];\n}\n\n// Mock AuthService (provided in description)\nconst authService = {\n  currentUser: null as User | null,\n  login: (user: User) => { authService.currentUser = user; },\n  logout: () => { authService.currentUser = null; },\n  getCurrentUser: () => authService.currentUser,\n  hasRole: (role: string) => authService.currentUser?.roles.includes(role) || false,\n  hasAnyRole: (roles: string[]) => roles.some(role => authService.hasRole(role)),\n};\n\n// Simulate different users (provided in description)\nconst adminUser: User = { id: 'u1', name: 'Admin User', roles: ['admin', 'viewer'] };\nconst editorUser: User = { id: 'u2', name: 'Editor User', roles: ['editor', 'viewer'] };\nconst viewerUser: User = { id: 'u3', name: 'Viewer User', roles: ['viewer'] };\nconst noRoleUser: User = { id: 'u4', name: 'Guest User', roles: [] };\n\n// Your task: Implement withAccessControl HOC\n// P: Props for the HOC\n// FallbackComponentProps: Optional props for the fallback component (if applicable)\nfunction withAccessControl<P extends object>(\n  WrappedComponent: React.ComponentType<P>,\n  requiredRoles: string[],\n  FallbackComponent?: React.ComponentType<any> // Optional fallback component\n): React.ComponentType<P> {\n  // TODO: Implement the HOC logic here\n\n  return class extends React.Component<P> {\n    render() {\n      // This is a placeholder. Implement actual access control logic.\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n}\n\n// Example Usage Components\nconst AdminDashboard: React.FC = () => <div>Welcome to the Admin Dashboard!</div>;\nconst EditorPanel: React.FC = () => <div>Edit content here.</div>;\nconst ViewerContent: React.FC = () => <div>View general content.</div>;\n\n// Apply HOCs\nconst AuthenticatedAdminDashboard = withAccessControl(AdminDashboard, ['admin']);\nconst AuthenticatedEditorPanel = withAccessControl(EditorPanel, ['editor']);\nconst AuthenticatedViewerContent = withAccessControl(ViewerContent, ['viewer']);\n\nconst FallbackMessage: React.FC = () => <div style={{ color: 'orange' }}>Please log in with sufficient privileges.</div>;\nconst SpecificFallbackAdminDashboard = withAccessControl(AdminDashboard, ['admin'], FallbackMessage);\n\n// Test application:\n/*\nconst App = () => {\n  const [user, setUser] = React.useState<User | null>(null);\n\n  React.useEffect(() => {\n    authService.login(adminUser); // Set initial user\n    setUser(authService.getCurrentUser());\n  }, []);\n\n  return (\n    <div>\n      <h1>Access Control Demo (Current User: {user?.name || 'None'})</h1>\n      <button onClick={() => { authService.login(adminUser); setUser(authService.getCurrentUser()); }}>Login as Admin</button>\n      <button onClick={() => { authService.login(editorUser); setUser(authService.getCurrentUser()); }}>Login as Editor</button>\n      <button onClick={() => { authService.login(viewerUser); setUser(authService.getCurrentUser()); }}>Login as Viewer</button>\n      <button onClick={() => { authService.login(noRoleUser); setUser(authService.getCurrentUser()); }}>Login as Guest</button>\n      <button onClick={() => { authService.logout(); setUser(authService.getCurrentUser()); }}>Logout</button>\n      \n      <hr/>\n      <h2>Admin Section:</h2>\n      <AuthenticatedAdminDashboard />\n      <hr/>\n      <h2>Editor Section:</h2>\n      <AuthenticatedEditorPanel />\n      <hr/>\n      <h2>Viewer Section:</h2>\n      <AuthenticatedViewerContent />\n      <hr/>\n      <h2>Admin Section with Custom Fallback:</h2>\n      <SpecificFallbackAdminDashboard />\n    </div>\n  );\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/\n",
          "solutionCode": "import React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface User {\n  id: string;\n  name: string;\n  roles: string[];\n}\n\nconst authService = {\n  currentUser: null as User | null,\n  login: (user: User) => { authService.currentUser = user; },\n  logout: () => { authService.currentUser = null; },\n  getCurrentUser: () => authService.currentUser,\n  hasRole: (role: string) => authService.currentUser?.roles.includes(role) || false,\n  hasAnyRole: (roles: string[]) => roles.some(role => authService.hasRole(role)),\n};\n\nconst adminUser: User = { id: 'u1', name: 'Admin User', roles: ['admin', 'viewer'] };\nconst editorUser: User = { id: 'u2', name: 'Editor User', roles: ['editor', 'viewer'] };\nconst viewerUser: User = { id: 'u3', name: 'Viewer User', roles: ['viewer'] };\nconst noRoleUser: User = { id: 'u4', name: 'Guest User', roles: [] };\n\nfunction withAccessControl<P extends object>(\n  WrappedComponent: React.ComponentType<P>,\n  requiredRoles: string[],\n  FallbackComponent?: React.ComponentType<any> \n): React.ComponentType<P> {\n  class WithAccessControl extends React.Component<P> {\n    static displayName = `withAccessControl(${getDisplayName(WrappedComponent)})`;\n\n    render() {\n      const hasAccess = authService.hasAnyRole(requiredRoles);\n\n      if (!hasAccess) {\n        if (FallbackComponent) {\n          return <FallbackComponent {...this.props} />; // Pass props to fallback too\n        } else {\n          return <div style={{ color: 'red', fontWeight: 'bold' }}>Access Denied! Required roles: {requiredRoles.join(', ')}</div>;\n        }\n      }\n\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return WithAccessControl;\n}\n\nconst AdminDashboard: React.FC = () => <div>Welcome to the Admin Dashboard!</div>;\nconst EditorPanel: React.FC = () => <div>Edit content here.</div>;\nconst ViewerContent: React.FC = () => <div>View general content.</div>;\n\nconst AuthenticatedAdminDashboard = withAccessControl(AdminDashboard, ['admin']);\nconst AuthenticatedEditorPanel = withAccessControl(EditorPanel, ['editor']);\nconst AuthenticatedViewerContent = withAccessControl(ViewerContent, ['viewer']);\n\nconst FallbackMessage: React.FC = () => <div style={{ color: 'orange' }}>Please log in with sufficient privileges.</div>;\nconst SpecificFallbackAdminDashboard = withAccessControl(AdminDashboard, ['admin'], FallbackMessage);\n\nconst App: React.FC = () => {\n  const [user, setUser] = React.useState<User | null>(authService.getCurrentUser());\n\n  const handleLogin = (userToLogin: User) => {\n    authService.login(userToLogin);\n    setUser(authService.getCurrentUser());\n  };\n\n  const handleLogout = () => {\n    authService.logout();\n    setUser(authService.getCurrentUser());\n  };\n\n  return (\n    <div>\n      <h1>Access Control Demo (Current User: {user?.name || 'None'})</h1>\n      <button onClick={() => handleLogin(adminUser)}>Login as Admin</button>\n      <button onClick={() => handleLogin(editorUser)}>Login as Editor</button>\n      <button onClick={() => handleLogin(viewerUser)}>Login as Viewer</button>\n      <button onClick={() => handleLogin(noRoleUser)}>Login as Guest</button>\n      <button onClick={handleLogout}>Logout</button>\n      \n      <hr/>\n      <h2>Admin Section:</h2>\n      <AuthenticatedAdminDashboard />\n      <hr/>\n      <h2>Editor Section:</h2>\n      <AuthenticatedEditorPanel />\n      <hr/>\n      <h2>Viewer Section:</h2>\n      <AuthenticatedViewerContent />\n      <hr/>\n      <h2>Admin Section with Custom Fallback:</h2>\n      <SpecificFallbackAdminDashboard />\n    </div>\n  );\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n",
          "testCases": [
            "Login as `adminUser`: `AuthenticatedAdminDashboard`, `AuthenticatedEditorPanel`, `AuthenticatedViewerContent`, and `SpecificFallbackAdminDashboard` should all render their respective components.",
            "Login as `editorUser`: `AuthenticatedAdminDashboard` should show 'Access Denied', `AuthenticatedEditorPanel` should render, `AuthenticatedViewerContent` should render, `SpecificFallbackAdminDashboard` should show the `FallbackMessage`.",
            "Login as `viewerUser`: `AuthenticatedAdminDashboard` and `AuthenticatedEditorPanel` should show 'Access Denied' / `FallbackComponent`, `AuthenticatedViewerContent` should render.",
            "Login as `noRoleUser` (Guest): All protected components (`AuthenticatedAdminDashboard`, `AuthenticatedEditorPanel`, `AuthenticatedViewerContent`) should show 'Access Denied' / `FallbackComponent`.",
            "Logout: All protected components should show 'Access Denied' / `FallbackComponent`.",
            "Verify `displayName` is set for debugging.",
            "Ensure props passed to `withAccessControl` (e.g., `<AuthenticatedAdminDashboard someProp=\"value\" />`) are correctly forwarded to `AdminDashboard` when access is granted, or to `FallbackComponent` if provided."
          ],
          "hints": [
            "The `authService.hasAnyRole` method is crucial for checking permissions.",
            "Access the current user's roles via `authService.getCurrentUser()`.",
            "The logic for rendering the `WrappedComponent` or the fallback should reside directly in the HOC's `render` method.",
            "Remember to pass `this.props` to both `WrappedComponent` and `FallbackComponent` to maintain flexibility."
          ],
          "tags": [
            "React",
            "HOC",
            "Authentication",
            "Authorization",
            "Access Control",
            "Security"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Components",
            "HOC Fundamentals",
            "Conditional Rendering"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Context API",
            "Security Patterns",
            "Conditional UI"
          ]
        },
        {
          "id": "task_hoc_combine_features",
          "title": "Compose HOCs for Enhanced Component",
          "description": "\nThis task requires you to combine multiple Higher-Order Components (HOCs) to create a single, enhanced component, demonstrating the power of HOC composability and adherence to best practices.\n\n**Given the following HOCs (you don't need to implement them, just use them as if they exist):**\n1.  `withAuth(WrappedComponent)`: Injects an `isAuthenticated: boolean` prop. Renders a `SignInMessage` if not authenticated.\n2.  `withTheme(WrappedComponent)`: Injects a `theme: { primaryColor: string, secondaryColor: string }` prop.\n3.  `withLogger(WrappedComponent)`: Logs component mount/unmount (from previous task, assume it works).\n\n**Your Goal:**\nCreate an `EnhancedDashboard` component by composing `Dashboard` with `withAuth`, `withTheme`, and `withLogger`. The order of application should be:\n\n*   First, `withAuth` to handle authentication.\n*   Second, `withTheme` to provide theming.\n*   Third, `withLogger` for logging.\n\n**Requirements:**\n1.  Define a simple `Dashboard` functional component that accepts `isAuthenticated`, `theme`, and other standard props.\n2.  Implement the `compose` utility function (if not provided).\n3.  Use the `compose` utility to chain the HOCs in the specified order.\n4.  Render `EnhancedDashboard` and verify its behavior (e.g., authentication status, theme colors, and console logs).\n\n**Mock HOCs to use:**\n```typescript\nimport React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n// Mock HOC 1: withAuth\ninterface WithAuthProps { isAuthenticated: boolean; }\nconst SignInMessage: React.FC = () => <div style={{ padding: '10px', background: '#ffe0b2', border: '1px solid orange' }}>Please sign in to view this content.</div>;\nconst withAuth = <P extends object>(WrappedComponent: React.ComponentType<P & WithAuthProps>): React.ComponentType<P> => {\n  return class WithAuth extends React.Component<P> {\n    static displayName = `withAuth(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const isAuthenticated = true; // Simulate authentication for now\n      if (!isAuthenticated) {\n        return <SignInMessage />;\n      }\n      return <WrappedComponent {...this.props as P} isAuthenticated={isAuthenticated} />;\n    }\n  };\n};\n\n// Mock HOC 2: withTheme\ninterface Theme { primaryColor: string; secondaryColor: string; }\ninterface WithThemeProps { theme: Theme; }\nconst withTheme = <P extends object>(WrappedComponent: React.ComponentType<P & WithThemeProps>): React.ComponentType<P> => {\n  return class WithTheme extends React.Component<P> {\n    static displayName = `withTheme(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const theme = { primaryColor: '#2196F3', secondaryColor: '#FFC107' }; // Default theme\n      return <WrappedComponent {...this.props as P} theme={theme} />;\n    }\n  };\n};\n\n// Mock HOC 3: withLogger (from previous task, simplified for this one)\nconst withLogger = <P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> => {\n  return class WithLogger extends React.Component<P> {\n    static displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n    componentDidMount() { console.log(`${getDisplayName(WrappedComponent)} mounted.`); }\n    componentWillUnmount() { console.log(`${getDisplayName(WrappedComponent)} unmounted.`); }\n    render() { return <WrappedComponent {...this.props} />; }\n  };\n};\n\n// Compose utility (if not provided by a library)\nconst compose = (...fns: Function[]) => (x: any) => fns.reduceRight((v, f) => f(v), x);\n\n// Your Dashboard component and composition logic goes here.\n```\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// Helper to get component display name\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n// Mock HOCs (Provided in description - copy them here for local testing)\n// Mock HOC 1: withAuth\ninterface WithAuthProps { isAuthenticated: boolean; }\nconst SignInMessage: React.FC = () => <div style={{ padding: '10px', background: '#ffe0b2', border: '1px solid orange' }}>Please sign in to view this content.</div>;\nconst withAuth = <P extends object>(WrappedComponent: React.ComponentType<P & WithAuthProps>): React.ComponentType<P> => {\n  return class WithAuth extends React.Component<P> {\n    static displayName = `withAuth(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const isAuthenticated = true; // Simulate authentication for now\n      if (!isAuthenticated) {\n        return <SignInMessage />;\n      }\n      return <WrappedComponent {...this.props as P} isAuthenticated={isAuthenticated} />;\n    }\n  };\n};\n\n// Mock HOC 2: withTheme\ninterface Theme { primaryColor: string; secondaryColor: string; }\ninterface WithThemeProps { theme: Theme; }\nconst withTheme = <P extends object>(WrappedComponent: React.ComponentType<P & WithThemeProps>): React.ComponentType<P> => {\n  return class WithTheme extends React.Component<P> {\n    static displayName = `withTheme(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const theme = { primaryColor: '#2196F3', secondaryColor: '#FFC107' }; // Default theme\n      return <WrappedComponent {...this.props as P} theme={theme} />;\n    }\n  };\n};\n\n// Mock HOC 3: withLogger\nconst withLogger = <P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> => {\n  return class WithLogger extends React.Component<P> {\n    static displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n    componentDidMount() { console.log(`${getDisplayName(WrappedComponent)} mounted.`); }\n    componentWillUnmount() { console.log(`${getDisplayName(WrappedComponent)} unmounted.`); }\n    render() { return <WrappedComponent {...this.props} />; }\n  };\n};\n\n// Compose utility (Provided in description)\nconst compose = (...fns: Function[]) => (x: any) => fns.reduceRight((v, f) => f(v), x);\n\n// Your task: Define Dashboard component and compose HOCs\n\ninterface DashboardProps {\n  isAuthenticated: boolean;\n  theme: Theme;\n  welcomeMessage?: string; // An example of an unrelated prop\n}\n\nconst Dashboard: React.FC<DashboardProps> = ({ isAuthenticated, theme, welcomeMessage }) => {\n  // TODO: Implement Dashboard component to display injected props\n  return <div>Your Dashboard Content Here</div>;\n};\n\n// TODO: Compose HOCs to create EnhancedDashboard\n// const EnhancedDashboard = ...;\n\n// Example Usage:\n/*\nconst App: React.FC = () => {\n  return (\n    <div>\n      <h1>Composed Dashboard:</h1>\n      <EnhancedDashboard welcomeMessage=\"Hello User!\" />\n    </div>\n  );\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/\n",
          "solutionCode": "import React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface WithAuthProps { isAuthenticated: boolean; }\nconst SignInMessage: React.FC = () => <div style={{ padding: '10px', background: '#ffe0b2', border: '1px solid orange' }}>Please sign in to view this content.</div>;\nconst withAuth = <P extends object>(WrappedComponent: React.ComponentType<P & WithAuthProps>): React.ComponentType<P> => {\n  return class WithAuth extends React.Component<P> {\n    static displayName = `withAuth(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const isAuthenticated = true; // Simulate authentication: true for main test\n      if (!isAuthenticated) {\n        return <SignInMessage />;\n      }\n      return <WrappedComponent {...this.props as P} isAuthenticated={isAuthenticated} />;\n    }\n  };\n};\n\ninterface Theme { primaryColor: string; secondaryColor: string; }\ninterface WithThemeProps { theme: Theme; }\nconst withTheme = <P extends object>(WrappedComponent: React.ComponentType<P & WithThemeProps>): React.ComponentType<P> => {\n  return class WithTheme extends React.Component<P> {\n    static displayName = `withTheme(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const theme = { primaryColor: '#2196F3', secondaryColor: '#FFC107' }; // Default theme\n      return <WrappedComponent {...this.props as P} theme={theme} />;\n    }\n  };\n};\n\nconst withLogger = <P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> => {\n  return class WithLogger extends React.Component<P> {\n    static displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n    componentDidMount() { console.log(`${getDisplayName(WrappedComponent)} mounted.`); }\n    componentWillUnmount() { console.log(`${getDisplayName(WrappedComponent)} unmounted.`); }\n    render() { return <WrappedComponent {...this.props} />; }\n  };\n};\n\nconst compose = (...fns: Function[]) => (x: any) => fns.reduceRight((v, f) => f(v), x);\n\ninterface DashboardProps {\n  isAuthenticated: boolean;\n  theme: Theme;\n  welcomeMessage?: string; // An example of an unrelated prop\n}\n\nconst Dashboard: React.FC<DashboardProps> = ({ isAuthenticated, theme, welcomeMessage }) => {\n  return (\n    <div style={{ padding: '20px', border: `2px solid ${theme.primaryColor}`, color: theme.primaryColor }}>\n      <h2 style={{ color: theme.secondaryColor }}>{welcomeMessage || 'Welcome to your Dashboard!'}</h2>\n      <p>Authentication Status: {isAuthenticated ? 'Authenticated' : 'Not Authenticated'}</p>\n      <p>Primary Color: {theme.primaryColor}</p>\n      <p>Secondary Color: {theme.secondaryColor}</p>\n      <p>This component is enhanced by multiple HOCs!</p>\n    </div>\n  );\n};\n\n// Compose HOCs in the specified order (right-to-left for compose)\n// Order: Dashboard -> withAuth -> withTheme -> withLogger\nconst EnhancedDashboard = compose(\n  withLogger,\n  withTheme,\n  withAuth\n)(Dashboard);\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <h1>Composed Dashboard:</h1>\n      <EnhancedDashboard welcomeMessage=\"Hello User!\" />\n      <br/>\n      <p>Check console for mount/unmount logs. Inspect component in DevTools for display name.</p>\n    </div>\n  );\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n",
          "testCases": [
            "Render `EnhancedDashboard` and verify that the 'Dashboard mounted.' message appears in the console (due to `withLogger`).",
            "Inspect `EnhancedDashboard` in React Developer Tools and confirm its `displayName` is correctly chained (e.g., `withLogger(withTheme(withAuth(Dashboard)))`).",
            "Verify that `isAuthenticated` is `true` and the theme colors (`primaryColor`, `secondaryColor`) are displayed correctly on the `Dashboard` component.",
            "Pass an additional prop like `welcomeMessage` to `EnhancedDashboard` and confirm it renders correctly on `Dashboard` (ensuring prop passthrough)."
          ],
          "hints": [
            "Remember that `compose` utilities typically apply functions from right to left.",
            "Think about the order of HOCs: the inner-most HOC (closest to `Dashboard`) is applied first.",
            "Ensure your `Dashboard` component explicitly accepts all the props that the HOCs will inject (`isAuthenticated`, `theme`).",
            "Don't forget to pass through any extra props given to `EnhancedDashboard` itself."
          ],
          "tags": [
            "React",
            "HOC",
            "Composability",
            "Best Practices",
            "Authentication",
            "Theming",
            "Logging"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "HOC Fundamentals",
            "Functional Composition",
            "React Props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Middleware",
            "Design Patterns",
            "Cross-Cutting Concerns"
          ]
        }
      ]
    }
  },
  {
    "id": "490712d0-c1e6-4e05-a990-a4acc94397b7",
    "startLine": 4300,
    "endLine": 4399,
    "processedDate": "2025-06-17T09:06:43.622Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_component_lifecycle_overview",
          "title": "React Component Lifecycle Overview and Phases",
          "content": "React components undergo a series of phases throughout their existence in the DOM, collectively known as their lifecycle. Understanding these phases and their associated methods is crucial for building robust and efficient React applications. Each phase provides specific 'hooks' where developers can execute code.\n\n## Component Lifecycle Phases\nThere are three primary phases in a React component's lifecycle:\n\n1.  **Mounting:** This is the phase when an instance of a component is being created and inserted into the DOM. This happens for the very first time a component is rendered.\n\n2.  **Updating:** This phase occurs when a component is being re-rendered due to changes in its props or state. This is the most frequently occurring phase in an active application.\n\n3.  **Unmounting:** This is the final phase when a component is being removed from the DOM. This happens when the component is no longer needed or its parent decides to unmount it.\n\nEach phase has a specific set of lifecycle methods that are called in a predictable order, allowing developers to manage side effects, optimize performance, and interact with the DOM at appropriate times.\n\n## React Component Rendering Process\nReact's rendering process is carefully designed to be efficient and predictable. It involves:\n*   **Reconciliation:** React builds a 'virtual DOM' representation of the UI. When state or props change, React creates a new virtual DOM tree and compares it with the previous one. This comparison process is called reconciliation.\n*   **Diffing Algorithm:** React uses a diffing algorithm to identify the minimal set of changes needed to update the actual DOM, rather than re-rendering the entire tree. This makes updates very fast.\n*   **Batching:** React often batches multiple state updates into a single re-render for performance, especially when updates happen within the same event loop tick.",
          "examples": [],
          "relatedQuestions": [
            "question_lifecycle_phases_1",
            "question_lifecycle_flashcard_1",
            "question_lifecycle_open_1"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "lifecycle",
            "fundamentals",
            "rendering"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "dom_manipulation"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "component_optimization",
            "side_effects"
          ]
        },
        {
          "id": "theory_legacy_lifecycle_methods",
          "title": "Legacy (Deprecated) React Lifecycle Methods",
          "content": "Before React v16.3, certain lifecycle methods were commonly used but later deprecated due to potential misuse leading to bugs, performance issues, or hindering future React features like async rendering. While they can still be used with the `UNSAFE_` prefix, it is strongly advised to migrate away from them as they will be removed in future major versions of React.\n\n## Deprecated Lifecycle Methods in React v16\n\n1.  `componentWillMount()` / `UNSAFE_componentWillMount()`\n    *   **Problem:** This method was often misused for side effects like data fetching or subscriptions that should occur *after* the component has mounted and is present in the DOM (`componentDidMount`). Running side effects here meant they could be executed multiple times if React paused, aborted, or restarted a render, leading to inconsistencies.\n    *   **Replacement:** For initialization logic or setting initial state, the `constructor()` is suitable. For side effects that require DOM access or subscriptions, `componentDidMount()` is the correct place.\n\n2.  `componentWillReceiveProps(nextProps)` / `UNSAFE_componentWillReceiveProps()`\n    *   **Problem:** This method was frequently misused for updating state based on prop changes. Its frequent calling (even if props hadn't *semantically* changed) often led to bugs, infinite loops, and made reasoning about state updates difficult. It was also called before `render`, meaning it could trigger an unnecessary re-render.\n    *   **Replacement:** `static getDerivedStateFromProps(props, state)` is the recommended replacement for deriving state from props. For side effects triggered by prop changes (e.g., fetching new data), `componentDidUpdate()` should be used.\n\n3.  `componentWillUpdate(nextProps, nextState)` / `UNSAFE_componentWillUpdate()`\n    *   **Problem:** This method was often misused for pre-render calculations or DOM manipulations *before* the update. Like `componentWillMount`, it could be called multiple times before an actual commit, leading to wasted work or inconsistent state.\n    *   **Replacement:** `getSnapshotBeforeUpdate(prevProps, prevState)` is used for reading DOM properties right before an update, and `componentDidUpdate(prevProps, prevState, snapshot)` for post-update side effects and DOM manipulations.\n\nUsing the `UNSAFE_` prefix serves as a warning that these methods are unsafe for async React and encourages developers to refactor their code.",
          "examples": [
            {
              "id": "example_deprecated_willmount",
              "title": "Misuse of componentWillMount (Deprecated)",
              "code": "class DeprecatedComponent extends React.Component {\n  // Bad practice: Side effect in componentWillMount\n  // This can run multiple times and might not be useful before mount\n  UNSAFE_componentWillMount() {\n    console.log('Component will mount - fetching data (bad practice)');\n    // This is problematic if fetching data here causes state updates\n    // that are then discarded by React's async rendering\n  }\n\n  componentDidMount() {\n    console.log('Component did mount - fetching data (good practice)');\n    // Good practice: Fetch data here as component is in DOM\n    this.fetchInitialData();\n  }\n\n  fetchInitialData() {\n    // Simulate API call\n    setTimeout(() => {\n      this.setState({ data: 'Loaded data' });\n    }, 500);\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Deprecated Method Example</h2>\n        <p>{this.state.data || 'Loading...'}</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This example shows the `UNSAFE_componentWillMount` method being used. While it might seem to work in some synchronous React versions, it's problematic in modern React due to potential for multiple executions before commit or being called when an async render is aborted. The `componentDidMount` is the correct place for initial data fetching and subscriptions because it guarantees the component is mounted in the DOM and ready for side effects.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_deprecated_methods_1",
            "question_deprecated_methods_open_1",
            "question_deprecated_methods_mcq_1",
            "question_deprecated_methods_flashcard_1"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "lifecycle",
            "deprecated",
            "migration",
            "async_rendering"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "component_lifecycle_overview"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_react_development",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_modern_lifecycle_react163",
          "title": "Modern React Lifecycle Methods (React 16.3+)",
          "content": "React 16.3 introduced significant changes to the component lifecycle to better support new features like async rendering and to promote more robust and predictable component behavior. The changes primarily involved replacing problematic legacy methods with safer alternatives and clarifying the different phases of rendering.\n\n## React 16.3+ Lifecycle Phases Diagram\n![React 16.3+ Lifecycle Methods Diagram](images/phases16.3.jpg)\n\n## Lifecycle Division into Phases:\nEach lifecycle can be divided into three logical parts:\n\n1.  **Render Phase:**\n    *   This phase involves methods that are **pure** and **have no side effects**. They should only calculate the next state or JSX to be rendered.\n    *   React may **pause, abort, or restart** this phase multiple times before committing the changes to the DOM, especially with concurrent mode features.\n    *   Methods in this phase: `constructor()`, `static getDerivedStateFromProps()`, `render()`.\n\n2.  **Pre-commit Phase:**\n    *   This phase occurs right before React commits the changes to the actual DOM.\n    *   Methods in this phase can **read the DOM**, allowing you to capture information from the DOM (e.g., scroll position) before React potentially changes it.\n    *   Method in this phase: `getSnapshotBeforeUpdate()`.\n\n3.  **Commit Phase:**\n    *   This phase is where React **works with the actual DOM**, applying all calculated changes.\n    *   Methods here can **run side effects**, such as network requests, subscriptions, or direct DOM manipulations.\n    *   These methods are guaranteed to be called only once per update cycle and only after the DOM has been updated.\n    *   Methods in this phase: `componentDidMount()`, `componentDidUpdate()`, `componentWillUnmount()`, `componentDidCatch()`.\n\n## Key New and Modified Lifecycle Methods:\n\n*   `static getDerivedStateFromProps(props, state)`:\n    *   **Purpose:** A static method called right before `render()` on both initial mount and subsequent updates.\n    *   **Usage:** Its primary purpose is to update state based on prop changes. It should return an object to update the state, or `null` to indicate no state change is needed.\n    *   **Benefit:** Being static, it doesn't have access to the component instance (`this`), preventing side effects. It encourages a clear separation of concerns: deriving state from props vs. performing side effects.\n    *   **Replaces:** `componentWillReceiveProps()` for state derivation.\n\n*   `getSnapshotBeforeUpdate(prevProps, prevState)`:\n    *   **Purpose:** Called right before the changes from `render()` are committed to the DOM.\n    *   **Usage:** It allows your component to capture some information from the DOM (e.g., scroll position) *before* it is potentially changed by the update.\n    *   **Return Value:** The value returned by `getSnapshotBeforeUpdate` will be passed as the third argument to `componentDidUpdate`.\n    *   **Replaces:** `componentWillUpdate()` for pre-render DOM reads.\n\n*   Error Boundaries (`static getDerivedStateFromError()` and `componentDidCatch()`):\n    *   **Purpose:** These methods are used to create Error Boundaries, which are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application.\n    *   `static getDerivedStateFromError(error)`: A static method called after an error is thrown by a descendant component. It should return an object to update the state, which will then trigger a re-render with the fallback UI.\n    *   `componentDidCatch(error, info)`: Called after an error has been caught. It's used for side effects like logging the error information.\n\nThese changes encourage more explicit and safer ways to manage state and side effects, making components more resilient and easier to debug.",
          "examples": [
            {
              "id": "example_getderivedstatefromprops",
              "title": "Using static getDerivedStateFromProps",
              "code": "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      count: props.initialCount || 0,\n      lastPropsCount: props.initialCount || 0 \n    };\n  }\n\n  // This method is called on every render, both on mount and update.\n  // It should return an object to update state, or null.\n  static getDerivedStateFromProps(props, state) {\n    // Only update state if the initialCount prop has changed\n    if (props.initialCount !== state.lastPropsCount) {\n      return {\n        count: props.initialCount,\n        lastPropsCount: props.initialCount\n      };\n    }\n    return null; // No state update needed\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState(prevState => ({ count: prevState.count + 1 }))}>\n          Increment Internal Count\n        </button>\n        <p>Prop Initial Count: {this.props.initialCount}</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates `static getDerivedStateFromProps`. It's used to synchronize the component's internal `count` state with the `initialCount` prop *only when the prop actually changes*. This prevents the common bug where prop changes don't update internal state correctly, while allowing internal state to be mutated independently (e.g., by the increment button). The `lastPropsCount` in state is used to compare with the new `props.initialCount` to avoid infinite loops or unnecessary updates.",
              "language": "typescript"
            },
            {
              "id": "example_getsnapshotbeforeupdate",
              "title": "Using getSnapshotBeforeUpdate and componentDidUpdate for Scroll Position",
              "code": "class ScrollableList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef();\n    this.state = { messages: [] };\n  }\n\n  componentDidMount() {\n    // Simulate initial message load\n    this.setState({ messages: Array.from({ length: 20 }, (_, i) => `Message ${i + 1}`) });\n  }\n\n  // Called right before the DOM is updated\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // If we're adding new messages, capture scroll position\n    if (prevState.messages.length < this.state.messages.length) {\n      const list = this.listRef.current;\n      // Return scrollHeight - scrollTop to maintain bottom position\n      return list.scrollHeight - list.scrollTop;\n    }\n    return null;\n  }\n\n  // Called after the DOM is updated\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // If a snapshot was returned (meaning new messages were added)\n    // and the user was at the bottom, maintain scroll position at the bottom\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      list.scrollTop = list.scrollHeight - snapshot;\n    }\n  }\n\n  addMessage = () => {\n    this.setState(prevState => ({\n      messages: [...prevState.messages, `New Message ${prevState.messages.length + 1}`]\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <div\n          ref={this.listRef}\n          style={{ height: '200px', overflowY: 'scroll', border: '1px solid gray' }}\n        >\n          {this.state.messages.map((msg, index) => (\n            <p key={index}>{msg}</p>\n          ))}\n        </div>\n        <button onClick={this.addMessage}>Add New Message</button>\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates `getSnapshotBeforeUpdate` in conjunction with `componentDidUpdate`. `getSnapshotBeforeUpdate` is used to capture the current scroll height and scroll position *before* the new messages are added and the DOM is updated. This 'snapshot' value is then passed to `componentDidUpdate`, allowing us to restore the scroll position such that the user remains at the bottom of the list when new messages are added, providing a better user experience for chat-like interfaces.",
              "language": "typescript"
            },
            {
              "id": "example_error_boundary",
              "title": "Implementing an Error Boundary",
              "code": "class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  // This static method is called when an error is thrown in a child component.\n  // It should return an object to update the state.\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true };\n  }\n\n  // This method is called after an error has been caught.\n  // It's used for side effects like logging the error.\n  componentDidCatch(error, errorInfo) {\n    console.error(\"Error caught by Error Boundary:\", error, errorInfo);\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return (\n        <div>\n          <h1>Something went wrong.</h1>\n          {this.props.showDetails && this.state.error && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              {this.state.error && this.state.error.toString()}\n              <br />\n              {this.state.errorInfo.componentStack}\n            </details>\n          )}\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage of the ErrorBoundary\nfunction FaultyComponent() {\n  throw new Error('I crashed!');\n  return <p>This will not be rendered.</p>;\n}\n\n// Example: Wrap a potentially faulty component with the ErrorBoundary\n// class App extends React.Component {\n//   render() {\n//     return (\n//       <ErrorBoundary showDetails={true}>\n//         <FaultyComponent />\n//       </ErrorBoundary>\n//     );\n//   }\n// }",
              "explanation": "This example demonstrates how to create an Error Boundary component using `static getDerivedStateFromError` and `componentDidCatch`. `getDerivedStateFromError` is used to update the component's state to `hasError: true` when a child component throws an error, which then triggers a re-render of the fallback UI. `componentDidCatch` is used for side effects, such as logging the error to an analytics service. This pattern prevents the entire application from crashing due to errors in a sub-tree.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_modern_lifecycle_1",
            "question_modern_lifecycle_open_1",
            "question_modern_lifecycle_mcq_1",
            "question_modern_lifecycle_mcq_2",
            "question_modern_lifecycle_flashcard_1",
            "question_modern_lifecycle_flashcard_2"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_scroll_position_sync",
            "task_error_boundary_implementation"
          ],
          "tags": [
            "react",
            "lifecycle",
            "react16.3",
            "getDerivedStateFromProps",
            "getSnapshotBeforeUpdate",
            "error_boundaries",
            "side_effects"
          ],
          "technology": "React",
          "prerequisites": [
            "component_lifecycle_overview",
            "legacy_lifecycle_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_react",
            "performance_optimization",
            "error_handling"
          ]
        },
        {
          "id": "theory_specific_lifecycle_methods_detailed",
          "title": "Detailed Breakdown of React Lifecycle Methods",
          "content": "This section provides a more granular look at the individual lifecycle methods, their purpose, and when they are invoked within the three main phases of a React component's existence.\n\n## Mounting Phase Methods\nThese methods are called in sequence when an instance of a component is being created and inserted into the DOM:\n\n*   **`constructor(props)`**\n    *   **Purpose:** The very first method called when a component is initialized. Used for initializing local state by assigning an object to `this.state` and for binding event handler methods.\n    *   **Important:** `super(props)` must be called. Do not cause side effects or subscriptions here.\n\n*   **`static getDerivedStateFromProps(props, state)`**\n    *   **Purpose:** Called right before `render()` on both initial mount and subsequent updates. It's a static method, so it doesn't have access to `this`.\n    *   **Usage:** Should return an object to update the state, or `null` to indicate no state change is needed. Its sole purpose is to derive state from props.\n\n*   **`render()`**\n    *   **Purpose:** The only required method in a class component. It reads `this.props` and `this.state` and returns JSX (React elements) that React will render to the DOM.\n    *   **Important:** Must be a pure function; it should not modify component state, interact with the DOM, or perform side effects. It should return elements, fragments, portals, strings, or numbers, or `null`/`false` for nothing.\n\n*   **`componentDidMount()`**\n    *   **Purpose:** Called immediately after the component is mounted (i.e., inserted into the DOM tree).\n    *   **Usage:** Ideal for performing side effects that require DOM nodes (e.g., integrating with third-party libraries that need DOM, setting up subscriptions, fetching initial data from an API). You can call `setState()` here, but it will trigger an extra render.\n    *   **Diagram:** ![React Mounting Phase](images/react_mounting.png)\n\n## Updating Phase Methods\nThese methods are called when a component is being re-rendered as a result of changes to its props or state:\n\n*   **`static getDerivedStateFromProps(props, state)`**\n    *   **Purpose:** (As described above) Called on every update before `render()` to potentially update state based on new props.\n\n*   **`shouldComponentUpdate(nextProps, nextState)`**\n    *   **Purpose:** Called before `render()` when new props or state are received. It's used for performance optimization.\n    *   **Usage:** Returns a `boolean` value. If `false`, React will skip calling `render()` and `componentDidUpdate()` for this update cycle. Default is `true`.\n    *   **Important:** Should be a pure function and not cause side effects.\n\n*   **`render()`**\n    *   **Purpose:** (As described above) Called again to determine what to display based on updated props and state.\n\n*   **`getSnapshotBeforeUpdate(prevProps, prevState)`**\n    *   **Purpose:** Called right before the most recently rendered output is committed to the DOM. Allows capturing information from the DOM (e.g., scroll position) before it's potentially changed.\n    *   **Usage:** Returns a value that will be passed as the third argument to `componentDidUpdate()`. Return `null` if nothing is needed.\n\n*   **`componentDidUpdate(prevProps, prevState, snapshot)`**\n    *   **Purpose:** Called immediately after updating occurs.\n    *   **Usage:** Ideal for performing side effects related to updates, such as network requests (e.g., fetching new data when a prop changes), DOM manipulation based on new state/props, or interacting with third-party libraries. This is also where you would use the `snapshot` returned by `getSnapshotBeforeUpdate`.\n    *   **Important:** You can call `setState()` here, but it must be wrapped in a condition (e.g., `if (nextProps.something !== this.props.something)`) to prevent an infinite loop.\n    *   **Diagram:** ![React Updating Phase](images/react_updating.png)\n\n## Unmounting Phase Method\nThis method is called when a component is being removed from the DOM:\n\n*   **`componentWillUnmount()`**\n    *   **Purpose:** Called immediately before a component is unmounted and destroyed.\n    *   **Usage:** Perform necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions created in `componentDidMount()`.\n    *   **Important:** Do not call `setState()` here as the component will not be re-rendered.\n    *   **Diagram:** ![React Unmounting Phase](images/react_unmounting.png)\n\n## Error Handling Methods (Error Boundaries)\nThese methods are used to catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI.\n\n*   **`static getDerivedStateFromError(error)`**\n    *   **Purpose:** Called after an error is thrown by a descendant component. It's static and used to update state (e.g., `hasError: true`) to trigger a re-render with a fallback UI.\n\n*   **`componentDidCatch(error, info)`**\n    *   **Purpose:** Called after an error has been caught. Used for side effects like logging error information to an error reporting service.\n\nIt is crucial to use the appropriate lifecycle method for each task to ensure component predictability, performance, and correctness.",
          "examples": [
            {
              "id": "example_componentdidmount",
              "title": "Using componentDidMount for Data Fetching",
              "code": "class DataFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null, loading: true, error: null };\n  }\n\n  // Called once after the component is mounted\n  componentDidMount() {\n    console.log('ComponentDidMount: Fetching data...');\n    this.fetchData();\n  }\n\n  async fetchData() {\n    try {\n      const response = await fetch('https://api.example.com/data'); // Replace with a real API if needed\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ data, loading: false });\n    } catch (error) {\n      this.setState({ error, loading: false });\n    }\n  }\n\n  render() {\n    if (this.state.loading) {\n      return <p>Loading data...</p>;\n    }\n    if (this.state.error) {\n      return <p>Error: {this.state.error.message}</p>;\n    }\n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <pre>{JSON.stringify(this.state.data, null, 2)}</pre>\n      </div>\n    );\n  }\n}",
              "explanation": "This example uses `componentDidMount` to perform an asynchronous data fetch when the component is first rendered and inserted into the DOM. This is the recommended place for API calls because the component is guaranteed to be available in the DOM, and it only runs once per mount, preventing unnecessary network requests.",
              "language": "typescript"
            },
            {
              "id": "example_shouldcomponentupdate",
              "title": "Optimizing with shouldComponentUpdate",
              "code": "class OptimizedComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'value' prop changes or the internal 'count' state changes\n    if (nextProps.value !== this.props.value || nextState.count !== this.state.count) {\n      console.log('OptimizedComponent: Re-rendering!');\n      return true;\n    }\n    console.log('OptimizedComponent: Skipping re-render.');\n    return false; // Prevent re-render\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  incrementCount = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <h3>Optimized Component</h3>\n        <p>Prop Value: {this.props.value}</p>\n        <p>Internal Count: {this.state.count}</p>\n        <button onClick={this.incrementCount}>Increment Internal Count</button>\n      </div>\n    );\n  }\n}\n\n// Example Parent Component to demonstrate `shouldComponentUpdate`\n// class ParentComponent extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { parentValue: 'Initial', irrelevant: 0 };\n//   }\n\n//   componentDidMount() {\n//     setInterval(() => {\n//       this.setState(prevState => ({ irrelevant: prevState.irrelevant + 1 }));\n//     }, 1000);\n//   }\n\n//   render() {\n//     return (\n//       <div>\n//         <OptimizedComponent value={this.state.parentValue} />\n//         <button onClick={() => this.setState({ parentValue: 'New Value' })}>Change Parent Value</button>\n//         <p>Irrelevant Parent State: {this.state.irrelevant}</p>\n//       </div>\n//     );\n//   }\n// }",
              "explanation": "This example shows how `shouldComponentUpdate` can be used for performance optimization. By implementing a custom check, the component only re-renders if the `value` prop or the `count` state actually changes. If the parent component re-renders but passes the same `value` prop and the internal `count` hasn't changed, `shouldComponentUpdate` will return `false`, preventing the `render` method and subsequent `componentDidUpdate` from being called, thus saving CPU cycles.",
              "language": "typescript"
            },
            {
              "id": "example_componentwillunmount",
              "title": "Using componentWillUnmount for Cleanup",
              "code": "class TimerComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { seconds: 0 };\n    this.timerId = null;\n  }\n\n  componentDidMount() {\n    // Start a timer when the component mounts\n    this.timerId = setInterval(() => {\n      this.setState(prevState => ({ seconds: prevState.seconds + 1 }));\n    }, 1000);\n    console.log('Timer started.');\n  }\n\n  componentWillUnmount() {\n    // Clear the timer when the component unmounts to prevent memory leaks\n    clearInterval(this.timerId);\n    console.log('Timer cleared.');\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Seconds: {this.state.seconds}</p>\n        <p>Watch the console for 'Timer cleared.' when this component is removed.</p>\n      </div>\n    );\n  }\n}\n\n// Example usage (e.g., in a parent component that conditionally renders TimerComponent):\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { showTimer: true };\n//   }\n\n//   toggleTimer = () => {\n//     this.setState(prevState => ({ showTimer: !prevState.showTimer }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={this.toggleTimer}>\n//           {this.state.showTimer ? 'Hide Timer' : 'Show Timer'}\n//         </button>\n//         {this.state.showTimer && <TimerComponent />}\n//       </div>\n//     );\n//   }\n// }",
              "explanation": "This example demonstrates `componentWillUnmount`. It sets up an interval timer in `componentDidMount`. If the component were to be removed from the DOM without cleaning up this timer, it would continue to run in the background, consuming memory and potentially causing errors, leading to a 'memory leak'. `componentWillUnmount` is the ideal place to perform such cleanup (e.g., `clearInterval`, `cancelSubscription`, `removeEventListener`) to prevent these issues, ensuring resources are released when the component is destroyed.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_specific_lifecycle_mcq_1",
            "question_specific_lifecycle_mcq_2",
            "question_specific_lifecycle_open_1",
            "question_specific_lifecycle_code_1",
            "question_specific_lifecycle_flashcard_1",
            "question_specific_lifecycle_flashcard_2",
            "question_specific_lifecycle_flashcard_3"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_performance_optimization_sCU",
            "task_scroll_position_sync",
            "task_error_boundary_implementation"
          ],
          "tags": [
            "react",
            "lifecycle",
            "constructor",
            "render",
            "componentDidMount",
            "componentDidUpdate",
            "componentWillUnmount",
            "shouldComponentUpdate"
          ],
          "technology": "React",
          "prerequisites": [
            "modern_react_lifecycle_react163"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_component_design",
            "performance_tuning"
          ]
        },
        {
          "id": "theory_method_ordering_best_practices",
          "title": "Consistent Method Ordering in React Components",
          "content": "Following a consistent and logical order for methods within your React class components is a best practice that significantly improves code readability, maintainability, and collaboration, especially in larger codebases. It makes it easier for developers (including yourself in the future) to quickly understand a component's structure and behavior.\n\nWhile React doesn't enforce a specific order, a commonly accepted convention groups methods by their purpose and lifecycle phase. This creates a predictable structure that makes navigating components intuitive.\n\n## Recommended Method Ordering:\n\n1.  **Static methods and properties:** (e.g., `static defaultProps`, `static propTypes`, `static getDerivedStateFromProps`, `static getDerivedStateFromError`)\n    *   These are class-level properties and methods, independent of component instances, and thus logically come first.\n\n2.  **`constructor()`:**\n    *   The constructor is the first instance-level method called and sets up the initial state and binds methods.\n\n3.  **`getChildContext()`:** (Deprecated for Context API, but if used for legacy code, placed here)\n\n4.  **Lifecycle Methods (Mounting Order):**\n    *   `componentWillMount()` / `UNSAFE_componentWillMount()` (Deprecated - avoid)\n    *   `componentDidMount()`\n\n5.  **Lifecycle Methods (Updating Order):**\n    *   `componentWillReceiveProps()` / `UNSAFE_componentWillReceiveProps()` (Deprecated - avoid)\n    *   `shouldComponentUpdate()`\n    *   `componentWillUpdate()` / `UNSAFE_componentWillUpdate()` (Deprecated - avoid)\n    *   `getSnapshotBeforeUpdate()`\n    *   `componentDidUpdate()`\n\n6.  **Lifecycle Methods (Unmounting Order):**\n    *   `componentWillUnmount()`\n\n7.  **Lifecycle Methods (Error Handling):**\n    *   `componentDidCatch()`\n\n8.  **Event handlers:** (e.g., `onClickSubmit()`, `onChangeDescription()`, `handleSubmit()`)\n    *   These are methods that respond to user interactions or other events. Grouping them makes it easy to find component interactivity logic.\n    *   It's common to use arrow functions for these to automatically bind `this`.\n\n9.  **Getter methods for render:** (e.g., `getSelectReason()`, `getFooterContent()`, `getClasses()`)\n    *   Methods that calculate and return values specifically for the `render` method, often breaking down complex JSX generation.\n\n10. **Optional render methods:** (e.g., `renderNavigation()`, `renderProfilePicture()`, `renderItem()`)\n    *   If your `render` method is large, you might split it into smaller, private helper `render` methods for better readability.\n\n11. **`render()`:**\n    *   The `render` method is the core of the component's UI, and placing it last makes it the final destination for understanding what the component visually outputs, relying on all the methods defined above it.\n\nBy adhering to this or a similar consistent order, you create a standard blueprint for all your class components, which aids in code comprehension, debugging, and onboarding new team members.",
          "examples": [
            {
              "id": "example_method_ordering",
              "title": "Example of Recommended Method Ordering",
              "code": "class UserProfile extends React.Component {\n  // 1. Static methods and properties\n  static defaultProps = {\n    userId: 'default'\n  };\n\n  static propTypes = {\n    userId: PropTypes.string.isRequired\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (nextProps.userId !== prevState.currentUserId) {\n      return {\n        userData: null, // Clear data on user change\n        isLoading: true,\n        currentUserId: nextProps.userId\n      };\n    }\n    return null;\n  }\n\n  // 2. constructor()\n  constructor(props) {\n    super(props);\n    this.state = {\n      userData: null,\n      isLoading: true,\n      error: null,\n      currentUserId: props.userId\n    };\n  }\n\n  // 3. componentDidMount()\n  componentDidMount() {\n    this.fetchUserProfile(this.props.userId);\n  }\n\n  // 4. shouldComponentUpdate()\n  shouldComponentUpdate(nextProps, nextState) {\n    return (\n      nextProps.userId !== this.props.userId ||\n      nextState.userData !== this.state.userData ||\n      nextState.isLoading !== this.state.isLoading\n    );\n  }\n\n  // 5. componentDidUpdate()\n  componentDidUpdate(prevProps, prevState) {\n    if (this.props.userId !== prevProps.userId) {\n      this.fetchUserProfile(this.props.userId);\n    } else if (this.state.userData && !prevState.userData) {\n      console.log('User data loaded.');\n    }\n  }\n\n  // 6. componentWillUnmount()\n  componentWillUnmount() {\n    // Cleanup if any subscriptions/timers were here\n    console.log('UserProfile component unmounted.');\n  }\n\n  // 7. Event handlers\n  handleRefreshClick = () => {\n    this.fetchUserProfile(this.props.userId);\n  };\n\n  // 8. Getter methods for render\n  getDisplayUserName = () => {\n    return this.state.userData ? this.state.userData.name : 'N/A';\n  };\n\n  // 9. Optional render methods\n  renderLoading = () => {\n    if (this.state.isLoading) {\n      return <p>Loading user data...</p>;\n    }\n    return null;\n  };\n\n  renderError = () => {\n    if (this.state.error) {\n      return <p style={{ color: 'red' }}>Error: {this.state.error.message}</p>;\n    }\n    return null;\n  };\n\n  // 10. render()\n  render() {\n    const { userData } = this.state;\n    return (\n      <div className=\"user-profile-card\">\n        <h2>User Profile: {this.getDisplayUserName()}</h2>\n        {this.renderLoading()}\n        {this.renderError()}\n        {userData && !this.state.isLoading && (\n          <div>\n            <p>Email: {userData.email}</p>\n            <p>ID: {userData.id}</p>\n            <button onClick={this.handleRefreshClick}>Refresh Profile</button>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Helper method (private, not a lifecycle or event handler)\n  async fetchUserProfile(userId) {\n    this.setState({ isLoading: true, error: null });\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`); // Placeholder API\n      if (!response.ok) {\n        throw new Error(`Failed to fetch user ${userId}`);\n      }\n      const data = await response.json();\n      this.setState({ userData: data, isLoading: false });\n    } catch (error) {\n      this.setState({ error, isLoading: false, userData: null });\n    }\n  }\n}\n\n// Note: PropTypes requires 'prop-types' package\n// import PropTypes from 'prop-types';",
              "explanation": "This example demonstrates the recommended method ordering within a React class component. Methods are grouped logically, starting with static properties and the constructor, followed by lifecycle methods in their natural flow (mount, update, unmount), then event handlers, getter methods, optional render helpers, and finally the main `render` method. This structure enhances clarity and makes it easier for anyone reading the code to quickly locate specific functionalities.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_method_ordering_open_1",
            "question_method_ordering_mcq_1",
            "question_method_ordering_flashcard_1"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "best_practices",
            "code_style",
            "maintainability",
            "readability"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "specific_lifecycle_methods_detailed"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "professional_react_development",
            "team_collaboration"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lifecycle_phases_1",
          "topic": "React Component Lifecycle Phases",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following are the three main phases of a React component's lifecycle?",
          "answer": "Mounting, Updating, and Unmounting",
          "options": [
            "Initialization, Configuration, and Destruction",
            "Creation, Re-rendering, and Removal",
            "Mounting, Updating, and Unmounting",
            "Setup, Interaction, and Cleanup"
          ],
          "analysisPoints": [
            "Tests basic knowledge of React lifecycle terminology.",
            "Ensures understanding of the fundamental stages a component goes through."
          ],
          "keyConcepts": [
            "Mounting Phase",
            "Updating Phase",
            "Unmounting Phase",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct identification of the standard React lifecycle phases."
          ],
          "example": "The three main phases are Mounting (component created and inserted into DOM), Updating (component re-rendered due to prop/state changes), and Unmounting (component removed from DOM).",
          "tags": [
            "react",
            "lifecycle",
            "phases",
            "fundamentals",
            "mcq"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_flashcard_1",
          "topic": "React Component Lifecycle Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "What happens during the 'Mounting' phase of a React component's lifecycle?",
          "answer": "A component instance is created and inserted into the DOM for the first time.",
          "analysisPoints": [
            "Tests recall of the definition of the Mounting phase.",
            "Verifies understanding of initial component rendering."
          ],
          "keyConcepts": [
            "Mounting Phase",
            "DOM Insertion",
            "Initial Render"
          ],
          "evaluationCriteria": [
            "Ability to define the Mounting phase concisely."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "mounting",
            "flashcard"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_open_1",
          "topic": "React Component Lifecycle Phases",
          "level": "medium",
          "type": "open",
          "question": "Describe the primary difference between the 'Mounting' and 'Updating' phases of a React component. Provide a common use case for a lifecycle method in each phase.",
          "answer": "During the 'Mounting' phase, a component is created and inserted into the DOM for the very first time. A common use case is fetching initial data from an API in `componentDidMount`.\n\nIn contrast, the 'Updating' phase occurs when a component is re-rendered due to changes in its props or state after it has already been mounted. A common use case is re-fetching data when a specific prop changes in `componentDidUpdate`.",
          "analysisPoints": [
            "Tests ability to differentiate between lifecycle phases.",
            "Assesses knowledge of appropriate use cases for lifecycle methods in each phase.",
            "Encourages understanding of why each phase exists."
          ],
          "keyConcepts": [
            "Mounting Phase",
            "Updating Phase",
            "componentDidMount",
            "componentDidUpdate",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Clear distinction between phases.",
            "Relevant and correct examples of method usage.",
            "Demonstration of understanding of side effect placement."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "mounting",
            "updating",
            "componentDidMount",
            "componentDidUpdate",
            "open-ended"
          ],
          "prerequisites": [
            "theory_component_lifecycle_overview",
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deprecated_methods_1",
          "topic": "Deprecated React Lifecycle Methods",
          "level": "medium",
          "type": "open",
          "question": "Explain why `componentWillReceiveProps` was deprecated in React 16.3+ and what problems it commonly led to. What is its modern replacement, and how does it address these issues?",
          "answer": "`componentWillReceiveProps` was deprecated because it was often misused, leading to bugs and performance issues. Its main problems were:\n1.  **Frequent Calling:** It could be called multiple times for a single update, even if props hadn't semantically changed, leading to unnecessary re-renders or side effects.\n2.  **State Synchronization Issues:** Developers often updated state directly based on props here, which could lead to infinite loops or inconsistent state if not handled carefully, especially when also combined with internal state updates.\n3.  **Ambiguity with Async React:** It was problematic in React's async rendering model because it could run multiple times before a render was committed, making side effects unpredictable.\n\nThe modern replacement for deriving state from props is `static getDerivedStateFromProps(props, state)`. It addresses these issues by:\n1.  **Being Static:** It doesn't have access to `this`, preventing direct side effects or accidental state mutations outside its intended purpose.\n2.  **Pure Function:** It's a pure function that *only* returns an object to update state (or `null`). This makes its behavior predictable and avoids infinite loops.\n3.  **Clear Separation of Concerns:** It separates the logic for deriving state from props from other side effects (which belong in `componentDidUpdate`).",
          "analysisPoints": [
            "Tests understanding of deprecation rationale.",
            "Assesses knowledge of specific problems caused by legacy methods.",
            "Verifies awareness of modern replacements and their advantages.",
            "Requires explanation of `static` nature and `pure` function concept."
          ],
          "keyConcepts": [
            "componentWillReceiveProps",
            "static getDerivedStateFromProps",
            "Deprecation",
            "Pure Functions",
            "Side Effects",
            "State Synchronization"
          ],
          "evaluationCriteria": [
            "Accuracy of reasons for deprecation.",
            "Correct identification of replacement method.",
            "Thorough explanation of how the new method solves old problems."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "deprecated",
            "getDerivedStateFromProps",
            "state_management",
            "interview"
          ],
          "prerequisites": [
            "theory_legacy_lifecycle_methods",
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deprecated_methods_mcq_1",
          "topic": "Deprecated React Lifecycle Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the primary problem with using `componentWillMount` for side effects like data fetching?",
          "answer": "It can run multiple times if React pauses, aborts, or restarts a render, leading to inconsistencies.",
          "options": [
            "It blocks the main thread, causing UI freezes.",
            "It cannot access `this.props` or `this.state`.",
            "It can run multiple times if React pauses, aborts, or restarts a render, leading to inconsistencies.",
            "It is called after the component has been unmounted."
          ],
          "analysisPoints": [
            "Tests specific understanding of `componentWillMount`'s deprecation.",
            "Highlights the issue with side effects in render-phase methods.",
            "Distinguishes between correct and incorrect reasons for deprecation."
          ],
          "keyConcepts": [
            "componentWillMount",
            "Deprecated Methods",
            "Side Effects",
            "Async Rendering",
            "Render Phase"
          ],
          "evaluationCriteria": [
            "Correct identification of the core problem with `componentWillMount`."
          ],
          "example": "The core issue with `componentWillMount` is its placement in the 'render phase' which React can start and stop. If you initiate side effects here (like API calls or subscriptions), they might be duplicated or left in an inconsistent state if the render is aborted before being committed to the DOM. `componentDidMount` is the correct place as it's guaranteed to run only once after the component is fully mounted.",
          "tags": [
            "react",
            "lifecycle",
            "deprecated",
            "componentWillMount",
            "mcq"
          ],
          "prerequisites": [
            "theory_legacy_lifecycle_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deprecated_methods_flashcard_1",
          "topic": "Deprecated React Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Name two lifecycle methods that were deprecated in React 16.3+ and are now prefixed with `UNSAFE_`.",
          "answer": "Any two of: `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`.",
          "analysisPoints": [
            "Tests recall of specific deprecated methods.",
            "Verifies basic awareness of the `UNSAFE_` prefix."
          ],
          "keyConcepts": [
            "Deprecated Methods",
            "UNSAFE_ prefix",
            "React 16.3"
          ],
          "evaluationCriteria": [
            "Ability to list deprecated methods."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "deprecated",
            "flashcard"
          ],
          "prerequisites": [
            "theory_legacy_lifecycle_methods"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_modern_lifecycle_1",
          "topic": "Modern React Lifecycle Methods (React 16.3+)",
          "level": "hard",
          "type": "open",
          "question": "React 16.3+ introduced `getSnapshotBeforeUpdate` to replace certain use cases of `componentWillUpdate`. Explain its purpose, what it returns, and how its return value is utilized. Provide a concrete example of a scenario where `getSnapshotBeforeUpdate` is essential.",
          "answer": "`getSnapshotBeforeUpdate(prevProps, prevState)` is a lifecycle method called right before the changes from `render()` are committed to the DOM. Its purpose is to capture information from the DOM *before* it is potentially modified by React's update.\n\nIt returns a value, which will then be passed as the third argument (`snapshot`) to `componentDidUpdate(prevProps, prevState, snapshot)`.\n\n**Scenario Example:** Maintaining scroll position in a chat application or a dynamic list where new items are added to the top or bottom.\n\nLet's say you have a chat window, and new messages arrive. If you simply update the state with new messages, the scroll position might jump, or the user might lose their place. `getSnapshotBeforeUpdate` can be used to capture the current scroll height and position of the scrollable container *before* the new messages are added and the DOM updates. For instance, it can return `scrollHeight - scrollTop`. Then, in `componentDidUpdate`, you can use this `snapshot` value to adjust `scrollTop` back to maintain the user's view, ensuring they remain at the bottom (or wherever they were) as new messages appear.",
          "analysisPoints": [
            "Tests in-depth understanding of `getSnapshotBeforeUpdate`.",
            "Requires knowledge of its return value and interaction with `componentDidUpdate`.",
            "Demands a practical and detailed use case explanation.",
            "Assesses ability to connect theoretical concepts to real-world problems."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "DOM manipulation",
            "Scroll position",
            "Pre-commit Phase",
            "Lifecycle Interaction"
          ],
          "evaluationCriteria": [
            "Accurate description of purpose and mechanics.",
            "Clear and relevant example.",
            "Demonstration of understanding the flow between `getSnapshotBeforeUpdate` and `componentDidUpdate`."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "dom",
            "performance",
            "interview"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163",
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_modern_lifecycle_open_1",
          "topic": "React 16.3+ Lifecycle Phases",
          "level": "medium",
          "type": "open",
          "question": "React 16.3+ categorizes lifecycle methods into 'Render Phase', 'Pre-commit Phase', and 'Commit Phase'. Describe what characterizes each phase and provide one example method for each.",
          "answer": "1.  **Render Phase:**\n    *   **Characteristics:** Pure and has no side effects. Methods in this phase should only calculate the next state or JSX. React may pause, abort, or restart this phase multiple times.\n    *   **Example Method:** `render()` (or `static getDerivedStateFromProps()`, `constructor()`).\n\n2.  **Pre-commit Phase:**\n    *   **Characteristics:** Occurs right before React commits the changes to the actual DOM. Methods in this phase can read the DOM (e.g., measure scroll position) before updates are applied.\n    *   **Example Method:** `getSnapshotBeforeUpdate()`.\n\n3.  **Commit Phase:**\n    *   **Characteristics:** This is where React works with the actual DOM, applying all calculated changes. Methods here can run side effects (e.g., network requests, subscriptions, direct DOM manipulations) and are guaranteed to be called only once per update cycle after the DOM is updated.\n    *   **Example Method:** `componentDidMount()` (for initial side effects), `componentDidUpdate()` (for update-related side effects), or `componentWillUnmount()` (for cleanup).",
          "analysisPoints": [
            "Tests understanding of the new lifecycle categorization.",
            "Requires accurate description of each phase's purpose and constraints.",
            "Demands correct examples of methods fitting each phase."
          ],
          "keyConcepts": [
            "Render Phase",
            "Pre-commit Phase",
            "Commit Phase",
            "Pure Functions",
            "Side Effects",
            "DOM interaction"
          ],
          "evaluationCriteria": [
            "Correctly outlines characteristics of each phase.",
            "Provides accurate method examples for each phase."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "phases",
            "react16.3",
            "interview"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_modern_lifecycle_mcq_1",
          "topic": "Modern React Lifecycle Methods (React 16.3+)",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about `static getDerivedStateFromProps` is TRUE?",
          "answer": "It is a static method used to derive state from props, and it should return an object to update state or null.",
          "options": [
            "It has access to `this` and can perform side effects.",
            "It is called after the component has mounted and is ready for API calls.",
            "It is a static method used to derive state from props, and it should return an object to update state or null.",
            "It replaces `componentDidUpdate` for all state updates based on props."
          ],
          "analysisPoints": [
            "Tests understanding of `getDerivedStateFromProps`'s static nature.",
            "Verifies knowledge of its return value and purpose.",
            "Differentiates its role from `componentDidUpdate`."
          ],
          "keyConcepts": [
            "static getDerivedStateFromProps",
            "Static Methods",
            "State Derivation",
            "Side Effects",
            "Render Phase"
          ],
          "evaluationCriteria": [
            "Accurate identification of `getDerivedStateFromProps` characteristics."
          ],
          "example": "The key characteristic of `static getDerivedStateFromProps` is that it's static and cannot access `this`, meaning it can't perform side effects. Its only job is to return an object to update the component's state based on the new props and current state, or `null` if no state change is needed. It runs before `render` on both mount and update.",
          "tags": [
            "react",
            "lifecycle",
            "getDerivedStateFromProps",
            "state_management",
            "mcq"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_modern_lifecycle_mcq_2",
          "topic": "Error Boundaries",
          "level": "medium",
          "type": "mcq",
          "question": "To create a React Error Boundary that catches JavaScript errors in its child component tree and displays a fallback UI, which two lifecycle methods must you implement?",
          "answer": "`static getDerivedStateFromError` and `componentDidCatch`",
          "options": [
            "`componentDidMount` and `componentWillUnmount`",
            "`static getDerivedStateFromProps` and `componentDidUpdate`",
            "`static getDerivedStateFromError` and `componentDidCatch`",
            "`shouldComponentUpdate` and `render`"
          ],
          "analysisPoints": [
            "Tests knowledge of Error Boundary implementation.",
            "Requires identifying the specific methods used for error handling."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Error Handling",
            "static getDerivedStateFromError",
            "componentDidCatch"
          ],
          "evaluationCriteria": [
            "Correctly identifies the pair of methods required for Error Boundaries."
          ],
          "example": "Error Boundaries are special React components that implement `static getDerivedStateFromError(error)` to update state when an error occurs (to show fallback UI) and `componentDidCatch(error, info)` for side effects like logging the error.",
          "tags": [
            "react",
            "error_boundaries",
            "lifecycle",
            "mcq"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_modern_lifecycle_flashcard_1",
          "topic": "Modern React Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which new static lifecycle method was introduced in React 16.3 to replace `componentWillReceiveProps` for state derivation?",
          "answer": "`static getDerivedStateFromProps`",
          "analysisPoints": [
            "Tests direct recall of the modern replacement for a deprecated method.",
            "Focuses on a key change in React 16.3+."
          ],
          "keyConcepts": [
            "static getDerivedStateFromProps",
            "componentWillReceiveProps",
            "React 16.3",
            "State Derivation"
          ],
          "evaluationCriteria": [
            "Ability to name the specific replacement method."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "getDerivedStateFromProps",
            "flashcard"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_modern_lifecycle_flashcard_2",
          "topic": "React Lifecycle Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "In which React lifecycle phase are methods like `constructor()`, `static getDerivedStateFromProps()`, and `render()` executed? What is a key characteristic of this phase?",
          "answer": "Render Phase. Key characteristic: Pure and has no side effects; may be paused, aborted, or restarted by React.",
          "analysisPoints": [
            "Tests recall of methods associated with the Render Phase.",
            "Verifies understanding of the 'purity' requirement for the Render Phase."
          ],
          "keyConcepts": [
            "Render Phase",
            "Pure Functions",
            "constructor",
            "getDerivedStateFromProps",
            "render"
          ],
          "evaluationCriteria": [
            "Correctly identifies the phase and its main characteristic."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "render_phase",
            "flashcard"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_mcq_1",
          "topic": "Specific Lifecycle Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```jsx\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: 'Initial Data' };\n  }\n\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({ data: 'Updated Data after Mount' });\n    }, 100);\n  }\n\n  render() {\n    return <div>{this.state.data}</div>;\n  }\n}\n```\n\nWhat will be the sequence of text displayed in the div element during the initial mount of `MyComponent`?",
          "answer": "Initial Data, then Updated Data after Mount",
          "options": [
            "Initial Data",
            "Updated Data after Mount",
            "Initial Data, then Updated Data after Mount",
            "Nothing, it will throw an error"
          ],
          "analysisPoints": [
            "Tests understanding of component rendering flow.",
            "Assesses knowledge of `constructor` and `componentDidMount` execution order.",
            "Confirms understanding of `setState` triggering re-renders."
          ],
          "keyConcepts": [
            "constructor",
            "componentDidMount",
            "setState",
            "Render",
            "Mounting Phase"
          ],
          "evaluationCriteria": [
            "Accurate prediction of UI rendering sequence based on lifecycle events."
          ],
          "example": "Initially, the `constructor` sets `data` to 'Initial Data', and `render` is called, displaying 'Initial Data'. After the component mounts, `componentDidMount` is called, which schedules a `setTimeout`. After 100ms, `setState` is called, which updates the `data` state, triggering a re-render, and then 'Updated Data after Mount' is displayed.",
          "tags": [
            "react",
            "lifecycle",
            "componentDidMount",
            "state",
            "rendering",
            "mcq"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_mcq_2",
          "topic": "Specific Lifecycle Methods",
          "level": "hard",
          "type": "mcq",
          "question": "Which lifecycle method is specifically designed for performance optimization by allowing you to control whether a component should re-render or not, based on changes in props and state?",
          "answer": "`shouldComponentUpdate`",
          "options": [
            "`componentDidUpdate`",
            "`render`",
            "`shouldComponentUpdate`",
            "`static getDerivedStateFromProps`"
          ],
          "analysisPoints": [
            "Tests knowledge of performance-related lifecycle methods.",
            "Checks understanding of `shouldComponentUpdate`'s specific role.",
            "Distinguishes `shouldComponentUpdate` from other methods that can impact performance (e.g., `render` or `getDerivedStateFromProps`'s efficiency)."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Re-rendering",
            "Lifecycle Control"
          ],
          "evaluationCriteria": [
            "Correctly identifies the method responsible for render control."
          ],
          "example": "The `shouldComponentUpdate(nextProps, nextState)` method returns a boolean. If it returns `false`, React will skip the re-rendering of the component and its children for that specific update, which can lead to significant performance improvements when dealing with complex or frequently updated component trees where not all changes necessitate a visual update.",
          "tags": [
            "react",
            "lifecycle",
            "shouldComponentUpdate",
            "performance",
            "optimization",
            "mcq"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_specific_lifecycle_open_1",
          "topic": "Specific Lifecycle Methods",
          "level": "medium",
          "type": "open",
          "question": "When would you typically use `componentWillUnmount()`? Provide at least three distinct types of operations or cleanup activities that are best performed in this method.",
          "answer": "`componentWillUnmount()` is typically used to perform cleanup operations right before a component is unmounted and destroyed from the DOM. It's crucial for preventing memory leaks and ensuring that resources are properly released.\n\nThree distinct types of operations/cleanup activities:\n1.  **Clearing timers:** Any `setTimeout` or `setInterval` that was initiated in `componentDidMount` should be cleared here to prevent them from continuing to run in the background after the component is gone.\n2.  **Canceling network requests:** If a component initiated a network request (e.g., an `fetch` or `axios` call) in `componentDidMount` or `componentDidUpdate`, and the component is unmounted before the request completes, the promise might resolve and try to update state on a non-existent component, leading to errors. Requests can be canceled using `AbortController`.\n3.  **Removing event listeners:** Any custom event listeners (e.g., `window.addEventListener`, `document.addEventListener`) or subscriptions to external services (like a Redux store or a WebSocket) that were set up in `componentDidMount` should be removed/unsubscribed here to avoid memory leaks and prevent callbacks on unmounted components.",
          "analysisPoints": [
            "Tests understanding of `componentWillUnmount`'s purpose.",
            "Requires specific examples of cleanup operations.",
            "Emphasizes the importance of preventing memory leaks."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "Cleanup",
            "Memory Leaks",
            "Timers",
            "Network Requests",
            "Event Listeners",
            "Subscriptions"
          ],
          "evaluationCriteria": [
            "Correct explanation of purpose.",
            "Provision of multiple, distinct, and appropriate cleanup examples.",
            "Understanding of the consequences of not performing cleanup."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "componentWillUnmount",
            "cleanup",
            "memory_management",
            "interview"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_code_1",
          "topic": "Specific Lifecycle Methods",
          "level": "medium",
          "type": "code",
          "question": "Implement a React class component named `TypingIndicator` that displays 'User is typing...' for 3 seconds after its `isTyping` prop changes from `false` to `true`. If `isTyping` changes back to `false` before 3 seconds, or the component unmounts, the indicator should hide immediately. Use appropriate lifecycle methods.",
          "answer": "```typescript\nimport React from 'react';\n\nclass TypingIndicator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      showIndicator: false\n    };\n    this.typingTimeout = null;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.isTyping && !prevProps.isTyping) {\n      // isTyping changed from false to true\n      this.setState({ showIndicator: true });\n      // Clear any existing timeout to avoid multiple indicators\n      if (this.typingTimeout) {\n        clearTimeout(this.typingTimeout);\n      }\n      // Set a new timeout to hide the indicator after 3 seconds\n      this.typingTimeout = setTimeout(() => {\n        this.setState({ showIndicator: false });\n        this.typingTimeout = null;\n      }, 3000);\n    } else if (!this.props.isTyping && prevProps.isTyping) {\n      // isTyping changed from true to false\n      // Immediately hide indicator and clear any pending timeout\n      if (this.typingTimeout) {\n        clearTimeout(this.typingTimeout);\n        this.typingTimeout = null;\n      }\n      this.setState({ showIndicator: false });\n    }\n  }\n\n  componentWillUnmount() {\n    // Clear timeout if component unmounts while indicator is visible\n    if (this.typingTimeout) {\n      clearTimeout(this.typingTimeout);\n      this.typingTimeout = null;\n    }\n  }\n\n  render() {\n    if (this.state.showIndicator) {\n      return <p>User is typing...</p>;\n    }\n    return null;\n  }\n}\n\n// Example Usage:\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { userTyping: false };\n//   }\n\n//   toggleTyping = () => {\n//     this.setState(prevState => ({ userTyping: !prevState.userTyping }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={this.toggleTyping}>\n//           {this.state.userTyping ? 'Stop Typing' : 'Start Typing'}\n//         </button>\n//         <TypingIndicator isTyping={this.state.userTyping} />\n//       </div>\n//     );\n//   }\n// }\n```",
          "analysisPoints": [
            "Tests ability to use `componentDidUpdate` for prop-triggered side effects.",
            "Assesses understanding of `setTimeout` and `clearTimeout` for timed actions.",
            "Verifies correct usage of `componentWillUnmount` for cleanup.",
            "Requires handling multiple state transitions and edge cases (clearing timeout)."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "componentWillUnmount",
            "setTimeout",
            "clearTimeout",
            "Side Effects",
            "Conditional Rendering",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correct implementation of `componentDidUpdate` logic.",
            "Proper cleanup in `componentWillUnmount`.",
            "Accurate management of the timer.",
            "Handles `isTyping` state changes correctly."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "componentDidUpdate",
            "componentWillUnmount",
            "timers",
            "code_challenge"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_flashcard_1",
          "topic": "Specific Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which lifecycle method is the ideal place to perform initial DOM manipulations or fetch data from an API after the component has rendered for the first time?",
          "answer": "`componentDidMount()`",
          "analysisPoints": [
            "Tests recall of the primary use case for `componentDidMount`.",
            "Focuses on side effects that require the component to be in the DOM."
          ],
          "keyConcepts": [
            "componentDidMount",
            "Mounting Phase",
            "Side Effects",
            "API Calls",
            "DOM Interaction"
          ],
          "evaluationCriteria": [
            "Correctly identifies the method for post-mount side effects."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "componentDidMount",
            "flashcard"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_specific_lifecycle_flashcard_2",
          "topic": "Specific Lifecycle Methods",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the return value of `shouldComponentUpdate`? What does returning `false` from this method signify?",
          "answer": "It returns a `boolean`. Returning `false` signifies that React should skip the re-rendering of this component and its children for the current update cycle.",
          "analysisPoints": [
            "Tests knowledge of `shouldComponentUpdate`'s return type.",
            "Verifies understanding of its effect on the rendering process."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Boolean Return",
            "Performance Optimization",
            "Re-rendering Control"
          ],
          "evaluationCriteria": [
            "Accurate description of return value and consequence."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "shouldComponentUpdate",
            "flashcard",
            "performance"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_flashcard_3",
          "topic": "Specific Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which lifecycle method is called exactly once after the component is first created and mounted, and is typically used for initializing local state and binding event handlers?",
          "answer": "`constructor(props)`",
          "analysisPoints": [
            "Tests recall of the earliest lifecycle method.",
            "Focuses on its primary responsibilities."
          ],
          "keyConcepts": [
            "constructor",
            "Initial State",
            "Binding Methods",
            "Mounting Phase"
          ],
          "evaluationCriteria": [
            "Correctly identifies the constructor's role and timing."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "constructor",
            "flashcard"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_method_ordering_open_1",
          "topic": "Consistent Method Ordering",
          "level": "medium",
          "type": "open",
          "question": "Why is it considered a best practice to follow a consistent method ordering within React class components? Provide at least two benefits this practice offers.",
          "answer": "Following a consistent method ordering within React class components is a best practice because it significantly improves code readability, maintainability, and collaboration.\n\n**Two benefits are:**\n1.  **Improved Readability and Understanding:** When developers know where to look for specific types of logic (e.g., lifecycle methods, event handlers, render helpers), they can quickly grasp the component's structure and behavior without having to search through disorganized code. This is particularly helpful in larger components or when onboarding new team members.\n2.  **Easier Maintenance and Debugging:** A predictable structure makes it simpler to locate and modify relevant code sections. When debugging, you can quickly trace the flow of execution or isolate issues to specific lifecycle phases or event handling logic, reducing the time spent on troubleshooting.",
          "analysisPoints": [
            "Tests understanding of code organization principles.",
            "Requires articulation of benefits beyond just 'good style'.",
            "Connects practice to real-world development advantages."
          ],
          "keyConcepts": [
            "Code Readability",
            "Maintainability",
            "Best Practices",
            "Code Organization",
            "Collaboration",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Clear and concise explanation of benefits.",
            "Demonstration of understanding the practical impact of code structure."
          ],
          "example": "",
          "tags": [
            "react",
            "best_practices",
            "code_style",
            "maintainability",
            "readability",
            "open-ended"
          ],
          "prerequisites": [
            "theory_method_ordering_best_practices"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_method_ordering_mcq_1",
          "topic": "Consistent Method Ordering",
          "level": "easy",
          "type": "mcq",
          "question": "According to best practices for method ordering in React class components, which group of methods should generally appear first?",
          "answer": "Static methods and properties",
          "options": [
            "Event handlers",
            "Lifecycle methods like `render()`",
            "Static methods and properties",
            "Getter methods for render"
          ],
          "analysisPoints": [
            "Tests recall of the recommended order.",
            "Focuses on the top-level grouping of methods."
          ],
          "keyConcepts": [
            "Method Ordering",
            "Best Practices",
            "Static Methods",
            "Class Properties"
          ],
          "evaluationCriteria": [
            "Correctly identifies the initial section of a well-ordered component."
          ],
          "example": "The recommended order often starts with static methods and properties (like `static getDerivedStateFromProps`, `defaultProps`, `propTypes`) because they are class-level and independent of instance-specific data or behavior, providing an overview of the component's setup.",
          "tags": [
            "react",
            "best_practices",
            "code_style",
            "mcq"
          ],
          "prerequisites": [
            "theory_method_ordering_best_practices"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_method_ordering_flashcard_1",
          "topic": "Consistent Method Ordering",
          "level": "easy",
          "type": "flashcard",
          "question": "In a well-structured React class component, where would you typically find the main `render()` method in the method ordering?",
          "answer": "Typically, the `render()` method is placed last, or near the end, after all other lifecycle methods, event handlers, and helper methods.",
          "analysisPoints": [
            "Tests recall of the `render` method's common placement.",
            "Reinforces the idea of `render` being the 'output' method."
          ],
          "keyConcepts": [
            "Method Ordering",
            "render()",
            "Code Structure"
          ],
          "evaluationCriteria": [
            "Correctly identifies the usual position of the `render` method."
          ],
          "example": "",
          "tags": [
            "react",
            "best_practices",
            "code_style",
            "flashcard"
          ],
          "prerequisites": [
            "theory_method_ordering_best_practices"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_data_fetching_component",
          "title": "Implement a Data Fetching and Display Component with Lifecycle Methods",
          "description": "\nCreate a React class component called `UserCard` that fetches user data from a placeholder API and displays it. The component should:\n\n1.  Fetch user data when it **mounts** using `componentDidMount`.\n2.  Display a 'Loading...' message while data is being fetched.\n3.  Display the user's name and email if the fetch is successful.\n4.  Display an error message if the fetch fails.\n5.  Include a `userId` prop. If this prop **changes**, the component should re-fetch the data for the new `userId` using `componentDidUpdate`.\n6.  Ensure any pending network requests are canceled if the `userId` changes or the component **unmounts**.\n\nUse `https://jsonplaceholder.typicode.com/users/{userId}` as your API endpoint. Assume `userId` will be a number from 1 to 10.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass UserCard extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true,\n      error: null\n    };\n    this.abortController = null; // For cancelling fetch requests\n  }\n\n  // TODO: Implement componentDidMount to fetch initial data\n\n  // TODO: Implement componentDidUpdate to re-fetch data if userId prop changes\n\n  // TODO: Implement componentWillUnmount to clean up any pending requests\n\n  fetchUserData = async (userId) => {\n    // Implement actual fetch logic here, use abortController\n    // ...\n  };\n\n  render() {\n    const { user, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '8px' }}>\n        <h3>User Details</h3>\n        <p><strong>Name:</strong> {user.name}</p>\n        <p><strong>Email:</strong> {user.email}</p>\n      </div>\n    );\n  }\n}\n\n// Example usage in a parent component (for testing):\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { currentUserId: 1 };\n//   }\n\n//   changeUser = () => {\n//     this.setState(prevState => ({ \n//       currentUserId: prevState.currentUserId < 10 ? prevState.currentUserId + 1 : 1\n//     }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={this.changeUser}>Next User ({this.state.currentUserId})</button>\n//         <UserCard userId={this.state.currentUserId} />\n//       </div>\n//     );\n//   }\n// }\n",
          "solutionCode": "import React from 'react';\n\nclass UserCard extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true,\n      error: null\n    };\n    this.abortController = null; // For cancelling fetch requests\n  }\n\n  componentDidMount() {\n    this.fetchUserData(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.userId !== prevProps.userId) {\n      // Cancel previous request if any\n      if (this.abortController) {\n        this.abortController.abort();\n      }\n      this.setState({ loading: true, error: null, user: null }); // Reset state for new fetch\n      this.fetchUserData(this.props.userId);\n    }\n  }\n\n  componentWillUnmount() {\n    // Cancel any pending request if the component unmounts\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n  }\n\n  fetchUserData = async (userId) => {\n    this.abortController = new AbortController();\n    const signal = this.abortController.signal;\n    try {\n      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`, { signal });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ user: data, loading: false });\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        console.log('Fetch aborted for user:', userId);\n        // Do not update state if the fetch was intentionally aborted\n      } else {\n        this.setState({ error: error, loading: false });\n      }\n    }\n  };\n\n  render() {\n    const { user, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '8px' }}>\n        <h3>User Details</h3>\n        <p><strong>Name:</strong> {user.name}</p>\n        <p><strong>Email:</strong> {user.email}</p>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "UserCard with userId=1 should display 'Leanne Graham' and 'Sincere@april.biz'.",
            "Changing userId from 1 to 2 should trigger a new fetch and display 'Ervin Howell'.",
            "Changing userId multiple times quickly should handle aborting previous requests correctly.",
            "UserCard with an invalid userId (e.g., 999) should display an error message.",
            "Unmounting the component while a fetch is in progress should cancel the request and not cause errors."
          ],
          "hints": [
            "Remember `componentDidMount` is for initial setup, `componentDidUpdate` for reactions to prop/state changes, and `componentWillUnmount` for cleanup.",
            "Use `AbortController` to cancel `fetch` requests. Create a new controller for each request and abort it in `componentDidUpdate` (if `userId` changes) and `componentWillUnmount`.",
            "Don't forget to reset loading and error states when a new fetch starts in `componentDidUpdate`."
          ],
          "tags": [
            "react",
            "lifecycle",
            "componentDidMount",
            "componentDidUpdate",
            "componentWillUnmount",
            "data_fetching",
            "api_integration",
            "cleanup",
            "async"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "fetch_api",
            "abort_controller",
            "side_effects",
            "state_management"
          ]
        },
        {
          "id": "task_performance_optimization_sCU",
          "title": "Optimize Component Re-renders with `shouldComponentUpdate`",
          "description": "\nCreate a `DisplayNumber` React class component that receives a `value` prop (a number) and displays it. The component should also maintain an internal `clickCount` state, which increments when a button inside the component is clicked.\n\nYour task is to optimize this component using `shouldComponentUpdate` such that:\n\n1.  The component **only re-renders** if the `value` prop changes OR the internal `clickCount` state changes.\n2.  It should NOT re-render if its parent component re-renders but passes the exact same `value` prop and the internal `clickCount` hasn't changed.\n\nInclude console logs within `render()` and `shouldComponentUpdate()` to demonstrate when they are called (or skipped).\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass DisplayNumber extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clickCount: 0 };\n  }\n\n  // TODO: Implement shouldComponentUpdate for optimization\n\n  incrementClick = () => {\n    this.setState(prevState => ({ clickCount: prevState.clickCount + 1 }));\n  };\n\n  render() {\n    console.log('DisplayNumber: render called');\n    return (\n      <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n        <h3>Display Number Component</h3>\n        <p>Prop Value: {this.props.value}</p>\n        <p>Internal Click Count: {this.state.clickCount}</p>\n        <button onClick={this.incrementClick}>Increment Internal Count</button>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing (no need to modify this)\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = {\n//       externalValue: 10,\n//       irrelevantParentState: 0\n//     };\n//   }\n\n//   componentDidMount() {\n//     // Simulate parent re-renders due to irrelevant state changes\n//     setInterval(() => {\n//       this.setState(prevState => ({\n//         irrelevantParentState: prevState.irrelevantParentState + 1\n//       }));\n//     }, 2000);\n//   }\n\n//   changeExternalValue = () => {\n//     this.setState(prevState => ({ externalValue: prevState.externalValue + 1 }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <h2>Parent Component</h2>\n//         <p>Parent Irrelevant State: {this.state.irrelevantParentState}</p>\n//         <button onClick={this.changeExternalValue}>Change External Value</button>\n//         <DisplayNumber value={this.state.externalValue} />\n//       </div>\n//     );\n//   }\n// }\n",
          "solutionCode": "import React from 'react';\n\nclass DisplayNumber extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clickCount: 0 };\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('DisplayNumber: shouldComponentUpdate called');\n    // Only re-render if 'value' prop changes OR 'clickCount' state changes\n    if (\n      nextProps.value !== this.props.value ||\n      nextState.clickCount !== this.state.clickCount\n    ) {\n      console.log('DisplayNumber: shouldComponentUpdate returns TRUE (re-render)');\n      return true;\n    }\n    console.log('DisplayNumber: shouldComponentUpdate returns FALSE (skip re-render)');\n    return false;\n  }\n\n  incrementClick = () => {\n    this.setState(prevState => ({ clickCount: prevState.clickCount + 1 }));\n  };\n\n  render() {\n    console.log('DisplayNumber: render called');\n    return (\n      <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n        <h3>Display Number Component</h3>\n        <p>Prop Value: {this.props.value}</p>\n        <p>Internal Click Count: {this.state.clickCount}</p>\n        <button onClick={this.incrementClick}>Increment Internal Count</button>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial mount: `render` should be called once.",
            "Clicking 'Increment Internal Count' button: `shouldComponentUpdate` should return `true`, then `render` should be called.",
            "Parent component re-rendering with the SAME `value` prop (e.g., due to `irrelevantParentState` changing): `shouldComponentUpdate` should be called, return `false`, and `render` should NOT be called.",
            "Parent component changing `externalValue` prop: `shouldComponentUpdate` should return `true`, then `render` should be called."
          ],
          "hints": [
            "`shouldComponentUpdate` receives `nextProps` and `nextState` as arguments.",
            "You need to compare `nextProps.value` with `this.props.value` and `nextState.clickCount` with `this.state.clickCount`.",
            "Remember that `shouldComponentUpdate` must return a boolean: `true` to re-render, `false` to skip."
          ],
          "tags": [
            "react",
            "lifecycle",
            "shouldComponentUpdate",
            "performance",
            "optimization",
            "code_challenge"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "pure_component",
            "memoization"
          ]
        },
        {
          "id": "task_scroll_position_sync",
          "title": "Maintain Scroll Position in a Dynamic List",
          "description": "\nCreate a `ChatWindow` React class component that simulates a chat application. It should display a list of messages. When new messages are added, the scroll position of the chat window should automatically adjust to keep the user at the bottom if they were already scrolled to the bottom before the update.\n\nUse `getSnapshotBeforeUpdate` to capture the necessary DOM information before the update, and `componentDidUpdate` to apply the scroll adjustment.\n\n**Requirements:**\n1.  The component should render a scrollable `div` containing messages.\n2.  Include a button to `Add New Message` to the list.\n3.  When new messages are added:\n    *   If the user was scrolled to the very bottom, keep them at the bottom.\n    *   If the user was scrolled up (not at the bottom), maintain their current view relative to the bottom (e.g., if they were 50px from the bottom, keep them 50px from the bottom).\n\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\nclass ChatWindow extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { messages: [] };\n    this.chatRef = React.createRef(); // Reference to the scrollable div\n  }\n\n  componentDidMount() {\n    // Simulate initial messages\n    this.setState({\n      messages: Array.from({ length: 15 }, (_, i) => `Initial Message ${i + 1}`)\n    });\n  }\n\n  // TODO: Implement getSnapshotBeforeUpdate\n\n  // TODO: Implement componentDidUpdate\n\n  addMessage = () => {\n    this.setState(prevState => ({\n      messages: [...prevState.messages, `New Message ${prevState.messages.length + 1}`]\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ padding: '20px' }}>\n        <div\n          ref={this.chatRef}\n          style={{\n            height: '300px',\n            overflowY: 'scroll',\n            border: '1px solid #ddd',\n            padding: '10px',\n            marginBottom: '10px'\n          }}\n        >\n          {this.state.messages.map((msg, index) => (\n            <p key={index} style={{ margin: '5px 0' }}>\n              {msg}\n            </p>\n          ))}\n        </div>\n        <button onClick={this.addMessage}>Add New Message</button>\n      </div>\n    );\n  }\n}\n",
          "solutionCode": "import React from 'react';\n\nclass ChatWindow extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { messages: [] };\n    this.chatRef = React.createRef(); // Reference to the scrollable div\n  }\n\n  componentDidMount() {\n    // Simulate initial messages\n    this.setState({\n      messages: Array.from({ length: 15 }, (_, i) => `Initial Message ${i + 1}`)\n    });\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    const chatElement = this.chatRef.current;\n    if (chatElement) {\n      // Check if we were scrolled to the bottom before the update\n      const isScrolledToBottom = \n        chatElement.scrollTop + chatElement.clientHeight >= chatElement.scrollHeight;\n      \n      // If new messages are being added, capture scroll info\n      if (this.state.messages.length > prevState.messages.length) {\n        return {\n          scrollHeight: chatElement.scrollHeight,\n          scrollTop: chatElement.scrollTop,\n          isScrolledToBottom: isScrolledToBottom\n        };\n      }\n    }\n    return null; // No snapshot needed\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (snapshot !== null) {\n      const chatElement = this.chatRef.current;\n      if (chatElement) {\n        // Calculate the difference in scroll height (due to new messages)\n        const scrollHeightDelta = chatElement.scrollHeight - snapshot.scrollHeight;\n        \n        if (snapshot.isScrolledToBottom) {\n          // If user was at the bottom, scroll them to the new bottom\n          chatElement.scrollTop = chatElement.scrollHeight;\n        } else {\n          // If user was scrolled up, maintain their relative position\n          chatElement.scrollTop = snapshot.scrollTop + scrollHeightDelta;\n        }\n      }\n    }\n  }\n\n  addMessage = () => {\n    this.setState(prevState => ({\n      messages: [...prevState.messages, `New Message ${prevState.messages.length + 1}`]\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ padding: '20px' }}>\n        <div\n          ref={this.chatRef}\n          style={{\n            height: '300px',\n            overflowY: 'scroll',\n            border: '1px solid #ddd',\n            padding: '10px',\n            marginBottom: '10px'\n          }}\n        >\n          {this.state.messages.map((msg, index) => (\n            <p key={index} style={{ margin: '5px 0' }}>\n              {msg}\n            </p>\n          ))}\n        </div>\n        <button onClick={this.addMessage}>Add New Message</button>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial render: Messages fill the scrollable area, scrollbar appears if content overflows.",
            "Add new messages when scrolled to the top: Scroll position should remain at the top.",
            "Add new messages when scrolled to the middle: Scroll position should remain relatively the same (relative to the old content).",
            "Add new messages when scrolled to the very bottom: Scroll position should jump to the new bottom (new messages become visible)."
          ],
          "hints": [
            "In `getSnapshotBeforeUpdate`, you'll need `this.chatRef.current.scrollHeight` (total height of content) and `this.chatRef.current.scrollTop` (current scroll position from top).",
            "To check if the user is at the bottom, compare `scrollTop + clientHeight` with `scrollHeight`. `clientHeight` is the visible height of the element.",
            "The value returned by `getSnapshotBeforeUpdate` will be the third argument (`snapshot`) to `componentDidUpdate`.",
            "In `componentDidUpdate`, if `snapshot` is not null, calculate the difference in `scrollHeight` between the previous and current state to adjust `scrollTop`."
          ],
          "tags": [
            "react",
            "lifecycle",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "dom_manipulation",
            "ux",
            "scroll",
            "code_challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_modern_lifecycle_react163",
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "chat_application",
            "user_experience",
            "virtual_dom"
          ]
        },
        {
          "id": "task_error_boundary_implementation",
          "title": "Build a Reusable React Error Boundary Component",
          "description": "\nCreate a generic `ErrorBoundary` React class component that can catch JavaScript errors anywhere in its child component tree and display a fallback UI instead of crashing the entire application.\n\n**Requirements:**\n1.  The `ErrorBoundary` component should implement `static getDerivedStateFromError` to update its state when an error occurs.\n2.  It should implement `componentDidCatch` to log the error information (e.g., to the console or an external service).\n3.  If an error is caught, it should render a fallback message (e.g., \"Something went wrong.\").\n4.  If no error is caught, it should render its children normally.\n\nProvide a simple `BuggyComponent` that intentionally throws an error to demonstrate your `ErrorBoundary` in action.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  // TODO: Implement static getDerivedStateFromError\n\n  // TODO: Implement componentDidCatch\n\n  render() {\n    if (this.state.hasError) {\n      // Fallback UI when an error occurs\n      return (\n        <div style={{ border: '2px solid red', padding: '20px', margin: '20px', backgroundColor: '#ffe6e6' }}>\n          <h1>Oops! Something went wrong.</h1>\n          {/* Optional: display error details for debugging */}\n          {/* <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo && this.state.errorInfo.componentStack}\n          </details> */}\n        </div>\n      );\n    }\n\n    return this.props.children; // Render children normally if no error\n  }\n}\n\n// A component that will intentionally throw an error\nclass BuggyComponent extends React.Component {\n  render() {\n    if (this.props.shouldThrowError) {\n      throw new Error('I am a buggy component that crashed!');\n    }\n    return <p>This component is working fine.</p>;\n  }\n}\n\n// Example usage for testing:\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { throwError: false };\n//   }\n\n//   toggleError = () => {\n//     this.setState(prevState => ({ throwError: !prevState.throwError }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={this.toggleError}>\n//           {this.state.throwError ? 'Reset Error' : 'Trigger Error'}\n//         </button>\n//         <ErrorBoundary>\n//           <BuggyComponent shouldThrowError={this.state.throwError} />\n//         </ErrorBoundary>\n//         <p>This part of the app should continue to work.</p>\n//       </div>\n//     );\n//   }\n// }\n",
          "solutionCode": "import React from 'react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true, error: error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    console.error(\"Error caught by Error Boundary:\", error, errorInfo);\n    this.setState({\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Fallback UI when an error occurs\n      return (\n        <div style={{ border: '2px solid red', padding: '20px', margin: '20px', backgroundColor: '#ffe6e6' }}>\n          <h1>Oops! Something went wrong.</h1>\n          {/* Optional: display error details for debugging */}\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo && this.state.errorInfo.componentStack}\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children; // Render children normally if no error\n  }\n}\n\n// A component that will intentionally throw an error\nclass BuggyComponent extends React.Component {\n  render() {\n    if (this.props.shouldThrowError) {\n      throw new Error('I am a buggy component that crashed!');\n    }\n    return <p>This component is working fine.</p>;\n  }\n}\n",
          "testCases": [
            "BuggyComponent `shouldThrowError=false`: ErrorBoundary should render BuggyComponent normally.",
            "BuggyComponent `shouldThrowError=true`: ErrorBoundary should catch the error and display its fallback UI. The console should show the logged error.",
            "Other components outside the ErrorBoundary should continue to function normally when an error is thrown inside.",
            "After an error, changing `shouldThrowError` back to `false` should reset the ErrorBoundary (by unmounting the old `BuggyComponent` instance and mounting a new one that doesn't throw)."
          ],
          "hints": [
            "`static getDerivedStateFromError(error)` is a static method and should return an object to update the state (e.g., `hasError: true`).",
            "`componentDidCatch(error, errorInfo)` is for side effects like logging. It receives the error and an object with `componentStack`.",
            "Remember that Error Boundaries only catch errors in their *descendant* components, not errors within themselves."
          ],
          "tags": [
            "react",
            "error_boundaries",
            "error_handling",
            "lifecycle",
            "getDerivedStateFromError",
            "componentDidCatch",
            "code_challenge"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "fault_tolerance",
            "application_stability",
            "logging"
          ]
        }
      ]
    }
  },
  {
    "id": "7179922c-a12a-4675-8c25-3dae01672c05",
    "startLine": 4400,
    "endLine": 4499,
    "processedDate": "2025-06-17T09:08:55.472Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_component_lifecycle_flow",
          "title": "React Component Lifecycle and Rendering Flow",
          "content": "Understanding the lifecycle of a React component is fundamental for building robust and efficient applications. A component goes through distinct phases: **mounting** (when it's first created and inserted into the DOM), **updating** (when its props or state change), and **unmounting** (when it's removed from the DOM). React provides special methods, called lifecycle methods, that allow developers to execute code at specific points in these phases.\n\n## Component Creation and Mounting Flow\n\n1.  **Component Definition**: This is the initial step where you define your React component, either as a class component or a functional component. For class components, this involves defining a class that extends `React.Component`.\n2.  **Component Usage**: The component is used within another component's `render` method or, for the root component, directly with `ReactDOM.render`.\n3.  **Instance Creation**: React creates an instance of the component's element. For class components, this is where `this.props` becomes accessible.\n4.  **Constructor Execution**: If a `constructor` method is defined in a class component, it is the *first* lifecycle method called. It's used for initializing state and binding event handlers.\n5.  **Virtual DOM Processing (Render)**: React calls the component's `render` method. This method returns a new React element tree (the Virtual DOM representation) that describes what the UI should look like.\n6.  **DOM Interaction (Mounting)**: For the initial render, React interacts with the browser's DOM to display the elements described by the Virtual DOM. This process is called \"mounting.\"\n7.  **`componentDidMount` Call**: After the component has been mounted and rendered to the actual DOM, `componentDidMount` is called. This is an ideal place for side effects like fetching data, setting up subscriptions, or interacting directly with the DOM.\n\n## Component Update Cycle\n\nWhen a component's props or state change, React initiates an update process:\n\n1.  **State/Prop Change**: The update cycle is triggered when `setState()` is called (either internally or from a parent component) or when a parent component re-renders and passes new props.\n2.  **Pre-Update Methods (`componentWillReceiveProps`, `getDerivedStateFromProps`)**: If props change, legacy class components would call `componentWillReceiveProps`. In modern React, `static getDerivedStateFromProps(nextProps, prevState)` is used. It's called right before `render` on every update and returns an object to update state, or `null` to update nothing. It should be a pure function.\n3.  **Update Decision (`shouldComponentUpdate`)**: React calls `shouldComponentUpdate(nextProps, nextState)`. This method returns a boolean indicating whether React should proceed with the update. It's a crucial optimization point; returning `false` prevents re-rendering of the component and its children, but can lead to stale UI if not used carefully.\n4.  **Pre-Rendering (`componentWillUpdate`, `getSnapshotBeforeUpdate`)**: If `shouldComponentUpdate` returns `true`, legacy class components would call `componentWillUpdate`. In newer React, `getSnapshotBeforeUpdate(prevProps, prevState)` is called right before the changes from the Virtual DOM are applied to the actual DOM. It returns a snapshot value (or `null`) that is passed to `componentDidUpdate`.\n5.  **Re-render**: The component's `render` method is called again to generate a new Virtual DOM tree based on the updated props/state.\n6.  **Diffing**: React performs a diffing algorithm, comparing the new Virtual DOM tree with the previous one. It identifies the minimal set of changes needed to update the actual DOM.\n7.  **DOM Update**: Only the necessary changes are applied to the actual DOM, optimizing performance.\n8.  **`componentDidUpdate` Call**: After the component has been updated and the changes have been flushed to the DOM, `componentDidUpdate(prevProps, prevState, snapshot)` is called. This is a good place to perform side effects after an update, such as network requests based on prop changes or interacting with the updated DOM. The `snapshot` value from `getSnapshotBeforeUpdate` is available here.\n\n## Component Unmounting Phase\n\nWhen a component is removed from the DOM (e.g., due to a conditional render, or its parent unmounting):\n\n1.  **`componentWillUnmount` Call**: Before the component is actually removed from the DOM, `componentWillUnmount()` is called. This is the ideal place to perform cleanup activities, such as invalidating timers, cancelling network requests, or removing event listeners that were set up in `componentDidMount`.\n\n",
          "examples": [
            {
              "id": "example_lifecycle_1",
              "title": "Basic Class Component with Lifecycle Methods",
              "code": "import React from 'react';\n\nclass LifecycleDemo extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('1. Constructor: Initializing state and binding methods.');\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('2. getDerivedStateFromProps: Called before render, returns state update.');\n    // Example: Update state based on props\n    if (nextProps.initialCount && nextProps.initialCount !== prevState.count) {\n      return { count: nextProps.initialCount };\n    }\n    return null; // No state update needed\n  }\n\n  componentDidMount() {\n    console.log('4. componentDidMount: Component mounted to DOM. Good for data fetching.');\n    this.timer = setInterval(() => {\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n    }, 1000);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(`5. shouldComponentUpdate: Current count ${this.state.count}, Next count ${nextState.count}.`);\n    // Only update if count changes\n    return nextState.count !== this.state.count;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('6. getSnapshotBeforeUpdate: Called right before DOM updates.');\n    // Example: Capture scroll position before update\n    return 'captured snapshot';\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log(`8. componentDidUpdate: Component updated. Snapshot: ${snapshot}`);\n    console.log(`   Previous state: ${prevState.count}, Current state: ${this.state.count}`);\n  }\n\n  componentWillUnmount() {\n    console.log('9. componentWillUnmount: Cleanup before component unmounts.');\n    clearInterval(this.timer);\n  }\n\n  render() {\n    console.log('3 & 7. Render: Building the Virtual DOM.');\n    return (\n      <div>\n        <h2>Lifecycle Demo</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState({ count: this.state.count + 10 })}>Add 10 (Manual Update)</button>\n      </div>\n    );\n  }\n}\n\nexport default LifecycleDemo;",
              "explanation": "This example demonstrates a class component integrating various lifecycle methods. The console logs illustrate the order of execution for mounting and updating phases. `constructor` initializes state. `getDerivedStateFromProps` potentially updates state based on new props. `componentDidMount` sets up a timer. `shouldComponentUpdate` provides a performance optimization. `getSnapshotBeforeUpdate` captures information before DOM updates. `componentDidUpdate` acts after DOM updates. `componentWillUnmount` performs cleanup.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_lifecycle_1",
            "question_lifecycle_2",
            "question_lifecycle_3",
            "question_lifecycle_4",
            "question_lifecycle_5",
            "question_lifecycle_6",
            "question_lifecycle_7",
            "question_lifecycle_8"
          ],
          "relatedTasks": [
            "task_lifecycle_component_management"
          ],
          "tags": [
            "React",
            "Component Lifecycle",
            "Mounting",
            "Updating",
            "Unmounting",
            "Class Components"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Basics",
            "ES6 Classes",
            "React Basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "State Management",
            "Performance Optimization",
            "Side Effects in React"
          ]
        },
        {
          "id": "theory_state_reconciliation",
          "title": "React State Updates and Reconciliation Process",
          "content": "State is a core concept in React that allows components to maintain and manage their own data. When a component's state changes, React efficiently updates the UI through a process called **reconciliation**.\n\n## State Updates with `setState()`\n\nWhen you call `this.setState()`, React initiates a series of steps:\n\n1.  **State Merging**: React merges the object you passed into `setState()` with the component's current state. This means `setState()` performs a shallow merge; it doesn't replace the entire state object, but rather updates the properties you specify.\n2.  **Asynchronous Nature**: `setState()` calls are asynchronous. React may batch multiple `setState()` calls into a single update for performance reasons. This means that if you log `this.state` immediately after calling `setState()`, you might not see the updated value.\n3.  **Functional `setState` for Reliability**: For updates that depend on the previous state or props, it is crucial to use the functional form of `setState`. This form receives the `prevState` and `props` as arguments, ensuring you are always working with the most up-to-date values, especially when multiple updates are batched.\n    ```javascript\n    this.setState(prevState => {\n      return { count: prevState.count + 1 };\n    });\n    \n    // Or with props\n    this.setState((prevState, props) => {\n      return { counter: prevState.counter + props.step };\n    });\n    ```\n4.  **Callback Function**: `setState()` accepts an optional callback function as its second argument. This function executes *after* the state has been updated and the component has been re-rendered. It's useful for performing actions that rely on the updated state.\n    ```javascript\n    this.setState({ data: [1, 2, 3] }, () => {\n      console.log('State updated and component re-rendered:', this.state.data);\n    });\n    ```\n5.  **Preventing Unnecessary Updates**: You can prevent state updates (and thus re-renders) by returning `null` from the functional `setState` if the new state is identical to the current state, or by using `shouldComponentUpdate`.\n    ```javascript\n    this.setState(state => {\n      if (state.address === latestAddress) {\n        return null; // No update needed, prevents re-render\n      } else {\n        return { address: latestAddress };\n      }\n    });\n    ```\n\n## Reconciliation Process\n\nReconciliation is the algorithm React uses to update the browser's DOM. It's React's way of efficiently responding to changes in state or props without re-rendering the entire page. Here's how it works:\n\n1.  **New Virtual DOM Tree**: When `setState()` is called (or new props are received), React constructs a new tree of React elements (Virtual DOM) that represents the desired UI based on the new state/props.\n2.  **Diffing Algorithm**: React then compares this new Virtual DOM tree with the previous one. This comparison process is called \"diffing.\"\n    *   **Element Type**: If the root elements have different types (e.g., `<div>` to `<span>`), React tears down the old tree and builds the new one from scratch.\n    *   **Keys**: When reconciling children elements, React uses `key` props to identify which items have changed, been added, or removed. Keys should be stable and unique among siblings.\n    *   **Attributes/Props**: For elements of the same type, React compares attributes/props and only updates what has changed in the actual DOM.\n3.  **Minimal DOM Operations**: Based on the diffing result, React calculates the minimal set of changes (additions, deletions, updates) required to make the actual DOM reflect the new Virtual DOM. This optimization is key to React's performance.\n4.  **Actual DOM Update**: Finally, React applies only these necessary changes to the actual browser DOM, making it very efficient.\n\nThis entire process ensures that React only touches the parts of the DOM that absolutely need to change, minimizing expensive DOM manipulations.",
          "examples": [
            {
              "id": "example_state_1",
              "title": "Asynchronous setState and Functional Form",
              "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  // Demonstrates asynchronous nature\n  handleBadIncrement = () => {\n    this.setState({ count: this.state.count + 1 });\n    console.log('After setState (may not be updated):', this.state.count); // Logs old value\n  }\n\n  // Demonstrates functional setState for reliability\n  handleGoodIncrement = () => {\n    this.setState(prevState => {\n      console.log('Inside functional setState (prevState):', prevState.count);\n      return { count: prevState.count + 1 };\n    });\n    console.log('After functional setState (still may be old value outside):', this.state.count); // Logs old value\n  }\n\n  // Demonstrates setState with callback\n  handleIncrementWithCallback = () => {\n    this.setState(\n      prevState => ({ count: prevState.count + 1 }),\n      () => {\n        console.log('Callback fired (state is updated):', this.state.count);\n      }\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Counter: {this.state.count}</h3>\n        <button onClick={this.handleBadIncrement}>Bad Increment (Async)</button>\n        <button onClick={this.handleGoodIncrement}>Good Increment (Functional)</button>\n        <button onClick={this.handleIncrementWithCallback}>Increment with Callback</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;",
              "explanation": "This example showcases the different ways to use `setState`. `handleBadIncrement` illustrates the asynchronous nature, where `console.log` immediately after `setState` might show an outdated value. `handleGoodIncrement` uses the functional form, which is crucial for updates based on `prevState` to avoid race conditions. `handleIncrementWithCallback` demonstrates how to execute code reliably after the state update and re-render have completed.",
              "language": "typescript"
            },
            {
              "id": "example_state_2",
              "title": "Preventing Redundant Updates with Functional setState",
              "code": "import React from 'react';\n\nclass DataDisplay extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { dataVersion: 0, content: 'Initial Content' };\n  }\n\n  updateContent = (newContent) => {\n    this.setState(prevState => {\n      // Only update if newContent is actually different\n      if (prevState.content === newContent) {\n        console.log('Content is the same, no update needed.');\n        return null; // Prevents state update and re-render\n      }\n      console.log('Content changed, updating state.');\n      return { content: newContent, dataVersion: prevState.dataVersion + 1 };\n    });\n  }\n\n  render() {\n    console.log('Rendered DataDisplay. Version:', this.state.dataVersion);\n    return (\n      <div>\n        <p>{this.state.content}</p>\n        <button onClick={() => this.updateContent('Updated Content')}>Update Content</button>\n        <button onClick={() => this.updateContent('Initial Content')}>Set Initial Content</button>\n      </div>\n    );\n  }\n}\n\nexport default DataDisplay;",
              "explanation": "This example demonstrates how to use the functional `setState` to conditionally prevent a state update. By checking if `newContent` is the same as `prevState.content` and returning `null` from the functional `setState` callback, we avoid unnecessary state changes and subsequent re-renders, optimizing performance. The `render` method's `console.log` will only fire when an actual update occurs.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_state_1",
            "question_state_2",
            "question_state_3",
            "question_state_4",
            "question_state_5",
            "question_state_6",
            "question_state_7"
          ],
          "relatedTasks": [
            "task_state_counter_management",
            "task_reconciliation_optimization"
          ],
          "tags": [
            "React",
            "State Management",
            "setState",
            "Reconciliation",
            "Virtual DOM",
            "Performance",
            "Asynchronous",
            "Functional setState"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Closures",
            "React Basics"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "Debugging React Apps",
            "Building Interactive UIs",
            "Optimizing React Performance"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lifecycle_1",
          "topic": "React Component Mounting Phase",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following lifecycle methods is called *after* a React component has been mounted and rendered to the actual DOM?",
          "answer": "componentDidMount",
          "options": [
            "constructor",
            "render",
            "componentDidMount",
            "componentWillUnmount"
          ],
          "analysisPoints": [
            "Identifies the correct lifecycle method for post-mount operations.",
            "Distinguishes `componentDidMount` from methods called earlier (constructor, render) or later (componentWillUnmount)."
          ],
          "keyConcepts": [
            "Component Lifecycle",
            "Mounting Phase",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental lifecycle phases."
          ],
          "example": "The `componentDidMount` method is the ideal place to perform side effects that require the component to be fully rendered in the DOM, such as fetching data from an API, setting up subscriptions, or directly manipulating the DOM using third-party libraries.",
          "tags": [
            "React",
            "Lifecycle",
            "Mounting",
            "componentDidMount"
          ],
          "prerequisites": [
            "React Component Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_2",
          "topic": "React Component Unmounting Phase",
          "level": "medium",
          "type": "mcq",
          "question": "You have a React component that sets up a global event listener in `componentDidMount`. Which lifecycle method should you use to clean up this event listener to prevent memory leaks?",
          "answer": "componentWillUnmount",
          "options": [
            "componentDidUpdate",
            "render",
            "componentWillUnmount",
            "constructor"
          ],
          "analysisPoints": [
            "Tests knowledge of proper cleanup practices in React lifecycle.",
            "Highlights the purpose of `componentWillUnmount`."
          ],
          "keyConcepts": [
            "Component Lifecycle",
            "Unmounting Phase",
            "Memory Leaks",
            "Cleanup"
          ],
          "evaluationCriteria": [
            "Ability to apply lifecycle methods for resource management.",
            "Understanding of common pitfalls like memory leaks."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    // Set up event listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    // Clean up event listener\n    window.removeEventListener('resize', this.handleResize);\n  }\n\n  handleResize = () => {\n    console.log('Window resized!');\n  };\n\n  render() {\n    return <div>My Component</div>;\n  }\n}\n```\n`componentWillUnmount` is the last method called before a component is removed from the DOM, making it the perfect place to clean up any subscriptions, timers, or event listeners initiated during the component's lifetime to prevent memory leaks.",
          "tags": [
            "React",
            "Lifecycle",
            "Unmounting",
            "componentWillUnmount",
            "Memory Leaks",
            "Cleanup"
          ],
          "prerequisites": [
            "Event Listeners",
            "React Component Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_3",
          "topic": "Optimizing React Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which lifecycle method is crucial for performance optimization in class components by allowing you to control whether a component re-renders?",
          "answer": "shouldComponentUpdate",
          "options": [
            "componentDidMount",
            "componentDidUpdate",
            "render",
            "shouldComponentUpdate"
          ],
          "analysisPoints": [
            "Identifies the key method for preventing unnecessary re-renders.",
            "Differentiates it from methods that always trigger during updates."
          ],
          "keyConcepts": [
            "Component Lifecycle",
            "Performance Optimization",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Understanding of performance best practices in React.",
            "Knowledge of how to control component updates."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass OptimizedComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'value' prop has changed\n    if (this.props.value !== nextProps.value) {\n      return true;\n    }\n    return false; // Prevent re-render\n  }\n\n  render() {\n    console.log('OptimizedComponent rendered');\n    return <div>Value: {this.props.value}</div>;\n  }\n}\n```\n`shouldComponentUpdate` allows you to define a condition under which the component should re-render. If it returns `false`, `render` and `componentDidUpdate` will not be called for that update cycle, effectively skipping the re-render. This is a powerful tool for performance optimization, especially for components that receive frequent prop or state changes but whose rendered output doesn't always need to change.",
          "tags": [
            "React",
            "Lifecycle",
            "Performance",
            "Optimization",
            "shouldComponentUpdate"
          ],
          "prerequisites": [
            "React Component Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_4",
          "topic": "React Lifecycle Method Order",
          "level": "hard",
          "type": "open",
          "question": "Describe the complete sequence of lifecycle methods (constructor, render, componentDidMount, getDerivedStateFromProps, shouldComponentUpdate, getSnapshotBeforeUpdate, componentDidUpdate, componentWillUnmount) called during the *initial mounting* of a class component and during a subsequent *update* triggered by new props. Clearly state the purpose of each method in the context of its execution.",
          "answer": "N/A",
          "analysisPoints": [
            "Tests comprehensive understanding of the React lifecycle.",
            "Requires accurate recall of method order for both mounting and updating.",
            "Demands concise explanation of each method's role.",
            "Checks for distinction between legacy and modern lifecycle methods (though not explicitly asked, a good answer would hint at it)."
          ],
          "keyConcepts": [
            "Component Lifecycle",
            "Mounting Phase",
            "Updating Phase",
            "Lifecycle Method Order",
            "Side Effects",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Accuracy of lifecycle method order.",
            "Clarity and correctness of purpose descriptions.",
            "Completeness of coverage for both mounting and updating."
          ],
          "example": "### Initial Mounting Phase:\n1.  **`constructor(props)`**: Called first. Used for initializing `state` and binding event handlers. `super(props)` must be called.\n2.  **`static getDerivedStateFromProps(nextProps, prevState)`**: Called before `render`. Used to update state based on props changes. Returns an object to update state or `null`.\n3.  **`render()`**: Called to create the component's Virtual DOM representation. Should be a pure function.\n4.  **React updates DOM**: React performs the actual DOM manipulation.\n5.  **`componentDidMount()`**: Called after the component has been mounted to the DOM. Ideal for side effects like data fetching, subscriptions, or direct DOM manipulation.\n\n### Update Triggered by New Props (assuming `shouldComponentUpdate` returns `true`):\n1.  **`static getDerivedStateFromProps(nextProps, prevState)`**: Called again before `render` due to new props. Updates state based on new props.\n2.  **`shouldComponentUpdate(nextProps, nextState)`**: Called to determine if the component should re-render. Returns `true` to proceed, `false` to skip.\n3.  **`render()`**: Called again to generate a new Virtual DOM.\n4.  **`getSnapshotBeforeUpdate(prevProps, prevState)`**: Called right before the changes are applied to the actual DOM. It can capture information (e.g., scroll position) from the DOM before it's updated. The return value is passed as the third argument to `componentDidUpdate`.\n5.  **React updates DOM**: React applies the diffed changes to the actual DOM.\n6.  **`componentDidUpdate(prevProps, prevState, snapshot)`**: Called after the component has been updated and re-rendered. Good for side effects that need access to the updated DOM or previous state/props.",
          "tags": [
            "React",
            "Lifecycle",
            "Mounting",
            "Updating",
            "Interview Question",
            "Advanced"
          ],
          "prerequisites": [
            "React Lifecycle Methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifecycle_5",
          "topic": "Lifecycle Method Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `render()` method in a React class component?",
          "answer": "To return the React elements (Virtual DOM) that represent the component's UI.",
          "analysisPoints": [
            "Tests recall of the core function of `render`."
          ],
          "keyConcepts": [
            "Component Rendering",
            "Virtual DOM"
          ],
          "evaluationCriteria": [
            "Basic understanding of component structure."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Lifecycle",
            "Render",
            "Flashcard"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_6",
          "topic": "Legacy vs. Modern Lifecycle",
          "level": "medium",
          "type": "open",
          "question": "What is the modern replacement for `componentWillReceiveProps` and `componentWillUpdate` in React class components, and what advantages do they offer?",
          "answer": "N/A",
          "analysisPoints": [
            "Tests knowledge of modern React lifecycle practices.",
            "Requires understanding of why legacy methods were deprecated.",
            "Evaluates ability to explain advantages of new methods (purity, snapshot capability)."
          ],
          "keyConcepts": [
            "Lifecycle Methods",
            "Deprecation",
            "Purity",
            "Snapshot",
            "getDerivedStateFromProps",
            "getSnapshotBeforeUpdate"
          ],
          "evaluationCriteria": [
            "Understanding of React's evolution.",
            "Ability to articulate reasons for design changes."
          ],
          "example": "`componentWillReceiveProps` is replaced by `static getDerivedStateFromProps(nextProps, prevState)`. This new static method is safer because it's pure and only used for state derivation, preventing side effects. `componentWillUpdate` is replaced by `getSnapshotBeforeUpdate(prevProps, prevState)`. This method is called right before the DOM is updated, allowing the component to capture information (e.g., scroll position) from the DOM before changes are applied, which can then be used in `componentDidUpdate`.",
          "tags": [
            "React",
            "Lifecycle",
            "Deprecation",
            "Modern React",
            "getDerivedStateFromProps",
            "getSnapshotBeforeUpdate"
          ],
          "prerequisites": [
            "React Lifecycle Methods",
            "Static Methods"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifecycle_7",
          "topic": "Lifecycle Method Timing",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React class component:\n\n```typescript\nimport React from 'react';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('Constructor Called');\n  }\n\n  componentDidMount() {\n    console.log('componentDidMount Called');\n    this.setState({ count: 1 });\n  }\n\n  componentDidUpdate() {\n    console.log('componentDidUpdate Called');\n  }\n\n  render() {\n    console.log('Render Called');\n    return <div>Count: {this.state.count}</div>;\n  }\n}\n\nexport default App;\n```\n\nWhat will be the exact sequence of console logs when this component is initially mounted?",
          "answer": "Constructor Called, Render Called, componentDidMount Called, Render Called, componentDidUpdate Called",
          "options": [
            "Constructor Called, componentDidMount Called, Render Called, componentDidUpdate Called",
            "Constructor Called, Render Called, componentDidMount Called",
            "Constructor Called, Render Called, componentDidMount Called, Render Called, componentDidUpdate Called",
            "Constructor Called, Render Called, componentDidUpdate Called, componentDidMount Called"
          ],
          "analysisPoints": [
            "Tests understanding of the mounting and initial update cycle triggered by `setState` in `componentDidMount`.",
            "Requires knowledge of `setState` causing a re-render and subsequent `componentDidUpdate` call."
          ],
          "keyConcepts": [
            "Component Lifecycle Order",
            "setState Triggering Update",
            "Mounting Phase"
          ],
          "evaluationCriteria": [
            "Accurate prediction of lifecycle method execution flow.",
            "Understanding of side effects of `setState`."
          ],
          "example": "1.  **Constructor Called**: The `constructor` is the first method called during instantiation.\n2.  **Render Called**: The `render` method is called to generate the initial Virtual DOM.\n3.  **componentDidMount Called**: After the component is mounted to the actual DOM, `componentDidMount` is called. Inside this method, `this.setState({ count: 1 })` is called.\n4.  **Render Called**: The `setState` call triggers an update. React re-renders the component with the new state.\n5.  **componentDidUpdate Called**: After the update (including the second render) is applied to the DOM, `componentDidUpdate` is called.",
          "tags": [
            "React",
            "Lifecycle",
            "Mounting",
            "Update",
            "setState",
            "Order"
          ],
          "prerequisites": [
            "React Lifecycle Methods",
            "React State"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_8",
          "topic": "Virtual DOM and DOM Interaction",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the term for the process where React communicates with the browser to display the element for the first time?",
          "answer": "Mounting",
          "analysisPoints": [
            "Tests recall of key terminology related to initial rendering."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Real DOM",
            "Mounting"
          ],
          "evaluationCriteria": [
            "Knowledge of basic React rendering concepts."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "DOM",
            "Mounting",
            "Virtual DOM",
            "Flashcard"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_1",
          "topic": "setState Asynchronous Behavior",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code snippet:\n\n```typescript\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  state = { count: 0 };\n\n  handleClick = () => {\n    this.setState({ count: this.state.count + 1 });\n    console.log(this.state.count); // Line A\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n}\n```\n\nIf the initial `count` is 0, what value will `console.log(this.state.count)` on Line A likely display immediately after the button is clicked for the first time?",
          "answer": "0",
          "options": [
            "0",
            "1",
            "Undefined",
            "It depends on React's batching"
          ],
          "analysisPoints": [
            "Tests understanding of `setState`'s asynchronous nature.",
            "Highlights the common pitfall of relying on `this.state` immediately after a `setState` call."
          ],
          "keyConcepts": [
            "setState",
            "Asynchronous Operations",
            "State Updates"
          ],
          "evaluationCriteria": [
            "Ability to predict output based on `setState` behavior.",
            "Understanding of React's internal update mechanisms."
          ],
          "example": "Because `setState` is asynchronous and React may batch updates for performance, `this.state.count` inside `handleClick` will often reflect the value *before* the `setState` call has been processed and the component has re-rendered. The updated value will only be reliably available in subsequent renders, in `componentDidUpdate`, or within the `setState` callback function.",
          "tags": [
            "React",
            "State",
            "setState",
            "Asynchronous",
            "Interview Question"
          ],
          "prerequisites": [
            "React State Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_2",
          "topic": "Functional setState",
          "level": "medium",
          "type": "mcq",
          "question": "When should you use the functional form of `setState` (i.e., `this.setState(prevState => { ... })`) instead of passing an object directly?",
          "answer": "When the new state depends on the previous state or props.",
          "options": [
            "Always, it's a best practice.",
            "When the state update is simple and doesn't depend on previous state.",
            "When the new state depends on the previous state or props.",
            "Only when you need to use a callback function."
          ],
          "analysisPoints": [
            "Identifies the primary use case for functional `setState`.",
            "Distinguishes it from direct object passing for independent updates."
          ],
          "keyConcepts": [
            "setState",
            "Functional setState",
            "Previous State",
            "Reliable Updates"
          ],
          "evaluationCriteria": [
            "Understanding of safe state update practices.",
            "Knowledge of handling batched updates correctly."
          ],
          "example": "```typescript\nthis.setState(prevState => {\n  // Correctly increments count based on the latest state, even if batched\n  return { count: prevState.count + 1 };\n});\n```\nUsing the functional form of `setState` ensures that you are working with the most up-to-date `prevState` and `props` values, even if React batches multiple `setState` calls. This prevents race conditions and ensures predictable state updates, especially for operations like incrementing a counter or toggling a boolean.",
          "tags": [
            "React",
            "State",
            "setState",
            "Functional setState",
            "Best Practices"
          ],
          "prerequisites": [
            "React State Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_3",
          "topic": "React Reconciliation",
          "level": "hard",
          "type": "open",
          "question": "Explain the concept of React's reconciliation process. Include details about the Virtual DOM, diffing algorithm, and how React optimizes actual DOM updates.",
          "answer": "N/A",
          "analysisPoints": [
            "Tests a deep understanding of React's core rendering mechanism.",
            "Requires explanation of Virtual DOM as an abstraction.",
            "Demands description of the diffing algorithm's role and its optimizations (element type, keys).",
            "Evaluates knowledge of how actual DOM updates are minimized."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Virtual DOM",
            "Diffing Algorithm",
            "DOM Manipulation",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of explanation.",
            "Clarity of technical concepts.",
            "Ability to connect different parts of the process."
          ],
          "example": "React's reconciliation is the process by which React updates the browser's DOM to match the latest state or props of your components. It does this by:\n\n1.  **Virtual DOM**: React maintains an in-memory representation of the UI called the Virtual DOM. When `setState` is called or new props are received, React generates a *new* Virtual DOM tree.\n2.  **Diffing Algorithm**: React then compares this new Virtual DOM tree with the previous one. This comparison, or \"diffing,\" is the core of reconciliation. React uses a heuristic algorithm to efficiently find differences:\n    *   **Different Element Types**: If the root elements have different types (e.g., `<div>` vs. `<span>`), React destroys the old component tree and builds a new one from scratch, discarding its state.\n    *   **Same Element Type**: If elements are of the same type, React looks at their attributes (props). Only attributes that have changed are updated on the real DOM.\n    *   **Lists and Keys**: For lists of elements, React uses the `key` prop to identify which items have changed, been added, or removed. Without stable keys, React might re-render the entire list or perform inefficient updates.\n3.  **Minimal DOM Operations**: After identifying the differences, React calculates the most efficient way to update the actual DOM. It batches multiple updates together to reduce expensive DOM manipulation operations.\n4.  **Actual DOM Update**: Finally, React applies only these necessary, optimized changes to the real browser DOM. This minimal direct DOM manipulation is why React is often perceived as fast, as it avoids direct, frequent manipulation of the costly browser DOM.",
          "tags": [
            "React",
            "Reconciliation",
            "Virtual DOM",
            "Diffing",
            "Performance",
            "Interview Question",
            "Advanced"
          ],
          "prerequisites": [
            "React State",
            "DOM Basics"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_state_4",
          "topic": "setState Callback",
          "level": "easy",
          "type": "flashcard",
          "question": "When does the callback function passed to `setState()` execute?",
          "answer": "After the state has been updated and the component has re-rendered.",
          "analysisPoints": [
            "Tests recall of `setState` callback timing."
          ],
          "keyConcepts": [
            "setState Callback",
            "Asynchronous State",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Basic understanding of `setState` functionality."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "State",
            "setState",
            "Callback",
            "Flashcard"
          ],
          "prerequisites": [
            "React State Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_5",
          "topic": "State Merging",
          "level": "medium",
          "type": "mcq",
          "question": "You have a component state `{ name: 'Alice', age: 30 }`. If you call `this.setState({ age: 31 })`, what will the state object be after the update?",
          "answer": "{ name: 'Alice', age: 31 }",
          "options": [
            "{ age: 31 }",
            "{ name: 'Alice', age: 31 }",
            "Undefined",
            "The state will not change as `name` is missing."
          ],
          "analysisPoints": [
            "Tests understanding of how `setState` merges objects.",
            "Clarifies that `setState` performs a shallow merge, not a replacement."
          ],
          "keyConcepts": [
            "setState",
            "State Merging",
            "Shallow Merge"
          ],
          "evaluationCriteria": [
            "Accurate prediction of state after an update.",
            "Understanding of `setState`'s merging behavior."
          ],
          "example": "React's `setState` performs a shallow merge of the object you provide into the current state. This means that only the keys explicitly present in the object passed to `setState` will be updated or added, while other existing keys in the state object remain unchanged.",
          "tags": [
            "React",
            "State",
            "setState",
            "Merging"
          ],
          "prerequisites": [
            "React State Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_6",
          "topic": "Reconciliation Keys",
          "level": "medium",
          "type": "open",
          "question": "Explain the importance of the `key` prop when rendering lists of elements in React. What problems can arise if `keys` are not used correctly or are unstable?",
          "answer": "N/A",
          "analysisPoints": [
            "Tests understanding of `key` prop's role in reconciliation.",
            "Requires explanation of issues like incorrect rendering, performance problems, and state issues."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Keys",
            "Lists",
            "Performance",
            "State Persistence"
          ],
          "evaluationCriteria": [
            "Clarity on `key`'s purpose.",
            "Ability to identify consequences of incorrect `key` usage."
          ],
          "example": "The `key` prop is a special string attribute you need to include when creating lists of elements in React (e.g., using `map` to render an array). Keys help React identify which items have changed, been added, or removed. They help React's reconciliation algorithm efficiently update the UI.\n\n### Importance:\n*   **Efficient Updates**: Keys allow React to uniquely identify each child in a list. When the list changes, React can use keys to quickly determine exactly which components need to be re-ordered, added, or removed, rather than re-rendering the entire list or destroying and recreating components unnecessarily.\n*   **Preserving State**: When items are reordered, keys help React preserve the component's internal state. If a component moves to a new position, but its key remains the same, React knows it's the same component instance and can reuse its state and DOM, rather than remounting it.\n\n### Problems with Incorrect/Unstable Keys:\n*   **Unpredictable UI**: If keys are missing or unstable (e.g., using array index as key when items can be reordered, added, or removed), React's diffing algorithm can get confused. This can lead to:\n    *   **Incorrect Rendering**: The wrong item might be displayed at a certain position.\n    *   **State Issues**: State associated with a component might be incorrectly applied to a different component if React thinks it's the same component due to a reused index key.\n    *   **Performance Degradation**: React might re-render more than necessary, leading to slower updates, as it can't efficiently identify changes and might rebuild large parts of the DOM unnecessarily.",
          "tags": [
            "React",
            "Reconciliation",
            "Keys",
            "Lists",
            "Performance"
          ],
          "prerequisites": [
            "React State",
            "Array Mapping"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_7",
          "topic": "setState Batching",
          "level": "medium",
          "type": "code",
          "question": "Given the following React class component, predict the final value of `count` displayed in the UI after the button is clicked. Explain your reasoning regarding `setState` batching.\n\n```typescript\nimport React from 'react';\n\nclass BatchingDemo extends React.Component {\n  state = { count: 0 };\n\n  handleClick = () => {\n    this.setState({ count: this.state.count + 1 });\n    this.setState({ count: this.state.count + 1 });\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment Three Times</button>\n      </div>\n    );\n  }\n}\n```\n",
          "answer": "N/A",
          "analysisPoints": [
            "Tests understanding of `setState` batching and the difference between object and functional updates.",
            "Requires logical deduction of the final state."
          ],
          "keyConcepts": [
            "setState",
            "Batching",
            "Asynchronous",
            "Functional setState",
            "Object setState"
          ],
          "evaluationCriteria": [
            "Correct prediction of the final state.",
            "Clear explanation of batching and its impact on state updates.",
            "Demonstration of understanding when to use functional `setState`."
          ],
          "example": "When the button is clicked, `handleClick` is called. React batches the `setState` calls within a single event handler. The initial `count` is 0.\n\n1.  `this.setState({ count: this.state.count + 1 });`\n    *   React sees `this.state.count` as 0. The pending state change is `{ count: 1 }`.\n2.  `this.setState({ count: this.state.count + 1 });`\n    *   React still sees `this.state.count` as 0 (because the previous `setState` hasn't been processed yet in the current batch). The pending state change becomes `{ count: 1 }` (overwriting the previous pending `count` update for the same key, effectively).\n3.  `this.setState(prevState => ({ count: prevState.count + 1 }));`\n    *   This is the functional form. React will queue this update. When the batch is processed, `prevState` for this specific update will be the result of the *previously batched updates*.\n\nDuring the batch processing:\n*   The first two object-based `setState` calls are effectively merged into one: `{ count: 1 }` (from `0 + 1`).\n*   Then, the functional `setState` call takes this intermediate result (`count: 1`) as `prevState` and increments it by 1.\n\nTherefore, the final `count` will be **2**.\n\n**Reasoning**: In React's synthetic event handlers, `setState` calls are batched. The first two `setState` calls use the `this.state.count` value from the *beginning* of the event loop (`0`). Since they both operate on the same property (`count`) and are passed objects, the second one overwrites the first's effect *within the same render cycle's state update queue*. The third `setState` call, being functional, correctly receives the *intermediate state* after the previous object-based `setState`s have been processed within the batch, ensuring it calculates `1 + 1 = 2`.\n",
          "tags": [
            "React",
            "State",
            "setState",
            "Batching",
            "Functional setState",
            "Interview Question"
          ],
          "prerequisites": [
            "React State Basics",
            "JavaScript Event Loop"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_lifecycle_component_management",
          "title": "Build a Component with Managed Side Effects",
          "description": "\nCreate a React class component named `TimerComponent` that demonstrates proper lifecycle management for side effects.\n\n**Requirements:**\n\n1.  **Mounting**: When `TimerComponent` mounts, it should start a timer that increments a `seconds` state variable every second. Display the current `seconds` value.\n2.  **Updating**: If a `limit` prop is passed to `TimerComponent`, the timer should automatically stop when `seconds` reaches `limit`.\n3.  **Unmounting**: When `TimerComponent` is removed from the DOM, ensure the timer is properly cleared to prevent memory leaks.\n4.  Add `console.log` statements in `constructor`, `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` to observe the lifecycle flow.\n\n**Bonus**: Implement `shouldComponentUpdate` to prevent unnecessary re-renders if a parent passes the same `limit` prop multiple times without an actual change.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass TimerComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      seconds: 0,\n      isRunning: false\n    };\n    this.timerId = null;\n    // console.log('Constructor Called');\n  }\n\n  // TODO: Implement componentDidMount to start the timer\n\n  // TODO: Implement componentDidUpdate to handle the 'limit' prop and stop the timer\n\n  // TODO: Implement componentWillUnmount to clear the timer\n\n  // Bonus: Implement shouldComponentUpdate\n\n  render() {\n    // console.log('Render Called');\n    return (\n      <div>\n        <h3>Timer: {this.state.seconds}s</h3>\n        {this.props.limit && <p>Limit: {this.props.limit}s</p>}\n      </div>\n    );\n  }\n}\n\nexport default TimerComponent;\n\n// To test, you might use an App component like this:\n/*\nimport React, { useState } from 'react';\nimport TimerComponent from './TimerComponent';\n\nfunction App() {\n  const [showTimer, setShowTimer] = useState(true);\n  const [timerLimit, setTimerLimit] = useState(10);\n\n  return (\n    <div>\n      <h1>Timer App</h1>\n      <button onClick={() => setShowTimer(!showTimer)}>\n        {showTimer ? 'Hide Timer' : 'Show Timer'}\n      </button>\n      <button onClick={() => setTimerLimit(prev => prev + 5)}>Increase Limit</button>\n      <button onClick={() => setTimerLimit(5)}>Set Limit to 5</button>\n\n      {showTimer && <TimerComponent limit={timerLimit} />}\n      {!showTimer && <p>Timer is hidden.</p>}\n    </div>\n  );\n}\n\nexport default App;\n*/",
          "solutionCode": "import React from 'react';\n\nclass TimerComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      seconds: 0,\n      isRunning: false\n    };\n    this.timerId = null;\n    console.log('Constructor Called');\n  }\n\n  componentDidMount() {\n    console.log('componentDidMount Called: Starting timer.');\n    this.timerId = setInterval(() => {\n      this.setState(prevState => {\n        const newSeconds = prevState.seconds + 1;\n        const isRunning = !this.props.limit || newSeconds <= this.props.limit;\n        if (!isRunning && this.timerId) {\n          clearInterval(this.timerId);\n          this.timerId = null;\n          console.log('Timer stopped due to limit.');\n        }\n        return { seconds: newSeconds, isRunning: isRunning };\n      });\n    }, 1000);\n    this.setState({ isRunning: true });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    console.log('componentDidUpdate Called');\n    // Handle limit prop changes or stopping the timer if limit is reached\n    if (this.props.limit !== prevProps.limit && this.state.seconds < this.props.limit) {\n        console.log(`Limit changed from ${prevProps.limit} to ${this.props.limit}.`);\n        // If timer was stopped and limit increased, restart if needed\n        if (!this.state.isRunning && this.timerId === null) {\n            this.componentDidMount(); // Re-start timer if it was stopped\n        }\n    }\n    // If the component reaches the limit AFTER componentDidMount check\n    if (this.props.limit && this.state.seconds > this.props.limit && this.timerId) {\n        clearInterval(this.timerId);\n        this.timerId = null;\n        this.setState({ isRunning: false });\n        console.log('Timer stopped by componentDidUpdate due to limit.');\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount Called: Clearing timer.');\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      this.timerId = null;\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Bonus: Only re-render if seconds or limit prop actually changes\n    const shouldUpdate = (\n      nextState.seconds !== this.state.seconds ||\n      nextProps.limit !== this.props.limit\n    );\n    console.log(`shouldComponentUpdate: ${shouldUpdate ? 'Re-rendering' : 'Skipping render'}`);\n    return shouldUpdate;\n  }\n\n  render() {\n    console.log('Render Called');\n    return (\n      <div>\n        <h3>Timer: {this.state.seconds}s</h3>\n        {this.props.limit !== undefined && <p>Limit: {this.props.limit}s</p>}\n      </div>\n    );\n  }\n}\n\nexport default TimerComponent;\n",
          "testCases": [
            "Initial mount: Verify `constructor`, `render`, `componentDidMount` logs appear in order. `seconds` should start incrementing.",
            "Unmount: Hide the component. Verify `componentWillUnmount` log appears and timer stops (no more `seconds` increments).",
            "Re-mount: Show the component again. Verify a new timer starts from 0.",
            "Limit prop: Pass `limit={5}`. Verify timer stops at 5s. Check `componentDidUpdate` logs.",
            "Change limit dynamically: Change `limit` prop from, e.g., 5 to 10 while timer is running. Verify timer continues past 5s and stops at 10s. Check `componentDidUpdate` logs.",
            "Bonus `shouldComponentUpdate`: Pass the same `limit` prop multiple times without an actual change. Verify `render` is not called and `shouldComponentUpdate` logs 'Skipping render'."
          ],
          "hints": [
            "Remember that `setInterval` returns an ID that you need to store to clear it later.",
            "`componentDidMount` is for initial setup, `componentDidUpdate` for handling changes after initial render, and `componentWillUnmount` for cleanup.",
            "Be careful when conditionally stopping the timer inside `setState`; you might need a separate check or rely on `componentDidUpdate` for a clearer separation of concerns regarding `limit` prop.",
            "For `shouldComponentUpdate`, ensure you compare both `nextProps` and `nextState` with `this.props` and `this.state` respectively."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Side Effects",
            "Timers",
            "Cleanup",
            "Performance",
            "Class Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Class Components",
            "JavaScript Timers"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "componentDidMount",
            "componentDidUpdate",
            "componentWillUnmount",
            "shouldComponentUpdate",
            "setState"
          ]
        },
        {
          "id": "task_state_counter_management",
          "title": "Implement a Smart Counter with State and Reconciliation Principles",
          "description": "\nCreate a React class component called `SmartCounter` that manages a count and demonstrates proper `setState` usage and basic reconciliation awareness.\n\n**Requirements:**\n\n1.  **Basic Counter**: Initialize a `count` state variable to 0. Display the current `count`.\n2.  **Increment Button**: Add a button that increments the `count` by 1. Use the **functional form** of `setState` to ensure reliable updates, even if the button is clicked rapidly multiple times.\n3.  **Decrement Button**: Add a button that decrements the `count` by 1. Also use the functional form.\n4.  **Async Update Demo**: Add another button that calls `this.setState({ count: this.state.count + 10 });` immediately followed by `console.log(this.state.count)`. In the `render` method, also `console.log` the `count`. Observe and explain the console output.\n5.  **Conditional Update**: Add a button that only increments `count` if it's currently an even number. Use the functional form of `setState` and return `null` if no update is needed.\n\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass SmartCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  handleIncrement = () => {\n    // TODO: Implement increment using functional setState\n  };\n\n  handleDecrement = () => {\n    // TODO: Implement decrement using functional setState\n  };\n\n  handleAsyncUpdate = () => {\n    // TODO: Implement async update demo\n  };\n\n  handleConditionalIncrement = () => {\n    // TODO: Implement conditional increment using functional setState and returning null\n  };\n\n  render() {\n    // TODO: Add console.log for render method\n    return (\n      <div>\n        <h2>Smart Counter: {this.state.count}</h2>\n        <button onClick={this.handleIncrement}>Increment</button>\n        <button onClick={this.handleDecrement}>Decrement</button>\n        <button onClick={this.handleAsyncUpdate}>Async +10 & Log</button>\n        <button onClick={this.handleConditionalIncrement}>Increment if Even</button>\n      </div>\n    );\n  }\n}\n\nexport default SmartCounter;\n",
          "solutionCode": "import React from 'react';\n\nclass SmartCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  handleIncrement = () => {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  handleDecrement = () => {\n    this.setState(prevState => ({\n      count: prevState.count - 1\n    }));\n  };\n\n  handleAsyncUpdate = () => {\n    // This demonstrates the asynchronous nature of setState\n    this.setState({ count: this.state.count + 10 });\n    console.log('Inside handleClick (state might not be updated yet):', this.state.count);\n    // The actual update will be reflected in the next render cycle.\n  };\n\n  handleConditionalIncrement = () => {\n    this.setState(prevState => {\n      if (prevState.count % 2 === 0) {\n        console.log('Count is even, incrementing.');\n        return { count: prevState.count + 1 };\n      } else {\n        console.log('Count is odd, no update needed.');\n        return null; // Return null to prevent update\n      }\n    });\n  };\n\n  render() {\n    console.log('Render Called. Current Count:', this.state.count);\n    return (\n      <div>\n        <h2>Smart Counter: {this.state.count}</h2>\n        <button onClick={this.handleIncrement}>Increment</button>\n        <button onClick={this.handleDecrement}>Decrement</button>\n        <button onClick={this.handleAsyncUpdate}>Async +10 & Log</button>\n        <button onClick={this.handleConditionalIncrement}>Increment if Even</button>\n      </div>\n    );\n  }\n}\n\nexport default SmartCounter;\n",
          "testCases": [
            "Basic Increment/Decrement: Click Increment/Decrement multiple times. Verify `count` updates correctly.",
            "Rapid Increment: Click Increment button very quickly. Verify `count` updates by the correct amount, showcasing the functional `setState`'s reliability.",
            "Async Update: Click 'Async +10 & Log'. Observe the console output: The `console.log` inside `handleAsyncUpdate` should show the old `count` value, while the `console.log` in `render` will eventually show the updated value (after React processes the `setState` and re-renders).",
            "Conditional Update (Even): Set `count` to an even number (e.g., 0, 2, 4) and click 'Increment if Even'. Verify `count` increments by 1. Check console for 'Count is even, incrementing.'.",
            "Conditional Update (Odd): Set `count` to an odd number (e.g., 1, 3, 5) and click 'Increment if Even'. Verify `count` does not change. Check console for 'Count is odd, no update needed.' and that `render` is not called again immediately after this click.",
            "Batching behavior: Click 'Async +10 & Log' then quickly click 'Increment' twice. Observe the sequence of `render` calls and final `count`."
          ],
          "hints": [
            "For functional `setState`, the function signature is `(prevState, props) => newState`.",
            "To prevent a `setState` call from triggering an update (and thus a re-render), the functional `setState` callback can return `null`.",
            "Remember that `setState` is asynchronous and React batches updates. The `this.state` value inside an event handler might not be the latest if you've called `setState` just before accessing it.",
            "Use `console.log` extensively to trace the execution flow and state values at different points."
          ],
          "tags": [
            "React",
            "State Management",
            "setState",
            "Functional setState",
            "Asynchronous",
            "Reconciliation",
            "Performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "JavaScript Closures"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "setState",
            "Reconciliation",
            "Virtual DOM",
            "Batching"
          ]
        }
      ]
    }
  },
  {
    "id": "a0930fb8-7690-4c3d-a834-760c9a8c7cc2",
    "startLine": 4500,
    "endLine": 4599,
    "processedDate": "2025-06-17T09:10:46.603Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_mounting_phase",
          "title": "React Component Mounting Phase",
          "content": "The Mounting Phase in React refers to the stage where an instance of your component is being created and inserted into the DOM. Understanding this phase is crucial for initializing component state, performing initial data fetching, and setting up necessary DOM interactions. The methods in this phase are called in a specific, predictable order:\n\n1.  `constructor(props)`\n2.  `static getDerivedStateFromProps(props, state)`\n3.  `render()`\n4.  `componentDidMount()`\n\nEach method serves a distinct purpose and has specific guidelines regarding what operations should and should not be performed within it.\n\n## Key Concepts\n-   **Initialization**: Setting up initial state and binding methods.\n-   **Side Effects**: Operations that interact with the outside world (e.g., API calls, subscriptions, direct DOM manipulation).\n-   **Purity of `render`**: Ensuring the `render` method is idempotent and only returns JSX.\n-   **DOM Insertion**: The point at which the component's output is actually placed into the browser's DOM.\n\n## Method Details\n\n### constructor(props)\n-   **Purpose**: Called before the component is mounted to the DOM. Its primary uses are to initialize local state by assigning an object to `this.state` and to bind event handler methods to the instance.\n-   **Execution**: It's the first method called in the mounting lifecycle.\n-   **Important Notes**: \n    -   Always call `super(props)` as the first statement, otherwise, `this.props` will be `undefined` in the constructor and potential other issues.\n    -   This is the *only* place where you can directly assign `this.state`. In all other methods, you must use `this.setState()`.\n    -   **Avoid** causing side effects (like API calls or subscriptions) in the constructor. It should be a pure function that sets up the initial state.\n\n### static getDerivedStateFromProps(props, state)\n-   **Purpose**: Called right before calling the `render` method, both on initial mount and on subsequent updates. Its purpose is to enable a component to update its internal state based on changes in props. It should return an object to update the state, or `null` to indicate that no state update is needed.\n-   **Execution**: Called after `constructor` (on mount) and before `render` (on mount and update).\n-   **Important Notes**:\n    -   It is a `static` method, which means it doesn't have access to the component instance (`this`). It operates purely on its `props` and `state` arguments.\n    -   It exists for rare use cases where the state *must* depend on changes in props over time (e.g., when a component needs to reset some of its internal state when a specific prop changes).\n    -   **Avoid** side effects in this method. It should be a pure function for derived state calculation.\n    -   It replaced deprecated lifecycle methods like `componentWillReceiveProps`.\n\n### render()\n-   **Purpose**: The only required method in a React class component. It reads `this.props` and `this.state` and returns React elements that will eventually be rendered to the DOM. It describes what should be rendered.\n-   **Execution**: Called after `static getDerivedStateFromProps` and before `componentDidMount`.\n-   **Important Notes**:\n    -   **Purity**: The `render()` method should be pure. It means it should not modify component state, perform side effects, or interact directly with the browser DOM. Given the same props and state, it should always return the same output.\n    -   **Return Types**: Can return React elements (JSX), arrays and fragments (must have a single parent key if an array), portals, strings, numbers, booleans (which render nothing), or `null` (renders nothing).\n    -   If returning arrays or fragments, they must have unique `key` props for each child element.\n\n### componentDidMount()\n-   **Purpose**: Called immediately after the component is mounted (i.e., inserted into the DOM tree). This is the ideal place to perform operations that require the component to be in the DOM.\n-   **Execution**: This is the last method called in the mounting sequence.\n-   **Important Notes**:\n    -   **Side Effects**: This is the best place to cause side effects such as:\n        -   Making network requests (API calls) to fetch data.\n        -   Setting up subscriptions (e.g., to an external data source or an event listener).\n        -   Directly manipulating the DOM (e.g., initializing a third-party library that needs DOM access, working with canvas or maps).\n    -   You *can* call `setState()` immediately in this method, but be aware that it will trigger an extra re-rendering. While this extra rendering isn't visible to the user (because it happens before the browser updates the screen), it might affect performance. It's generally preferred to initialize state in the constructor unless there's a specific reason to derive it from props or external sources *after* mount.",
          "examples": [
            {
              "id": "example_mounting_component",
              "title": "Basic Mounting Lifecycle Component",
              "code": "import React from 'react';\n\nclass LifecycleComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null, message: 'Loading...' };\n    console.log('1. Constructor: Initializing state and binding methods.');\n    this.handleClick = this.handleClick.bind(this);\n  }\n  \n  static getDerivedStateFromProps(props, state) {\n    console.log('2. getDerivedStateFromProps: Checking for prop changes to update state.');\n    // Example: If a prop 'reset' changes, reset internal message.\n    if (props.resetMessage && state.message !== 'Message Reset!') {\n        return { message: 'Message Reset!' };\n    }\n    return null; // No state update needed from props\n  }\n  \n  componentDidMount() {\n    console.log('4. componentDidMount: Component mounted to DOM. Performing side effects.');\n    // Best place for API calls, subscriptions, DOM manipulations\n    fetch('https://jsonplaceholder.typicode.com/todos/1') // Example API call\n      .then(response => response.json())\n      .then(json => {\n        console.log('API data fetched:', json);\n        this.setState({ data: json.title, message: 'Data loaded!' });\n      })\n      .catch(error => console.error('Error fetching data:', error));\n\n    // Example of adding an event listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    console.log('ComponentWillUnmount: Cleaning up event listener.');\n    window.removeEventListener('resize', this.handleResize);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({ message: prevState.message + ' Clicked!' }));\n  }\n\n  handleResize = () => {\n    console.log('Window resized!');\n  };\n  \n  render() {\n    console.log('3. render: Rendering component JSX.');\n    return (\n      <div>\n        <h2>Mounting Phase Demo</h2>\n        <p>Data: {this.state.data || 'No data yet'}</p>\n        <p>Message: {this.state.message}</p>\n        <button onClick={this.handleClick}>Click Me</button>\n      </div>\n    );\n  }\n}\n\nexport default LifecycleComponent;",
              "explanation": "This example demonstrates the core methods of the mounting phase. The `constructor` initializes the state and binds `handleClick`. `getDerivedStateFromProps` checks for a `resetMessage` prop to update the state. The `render` method simply displays the current state. `componentDidMount` is used to fetch data from an API and set up a window resize event listener, showcasing appropriate side effects. `componentWillUnmount` is included for completeness to show where to clean up `componentDidMount` effects. Console logs clearly show the order of execution.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_mounting_order_mcq",
            "question_constructor_purpose_mcq",
            "question_gDSFP_role_open",
            "question_render_purity_mcq",
            "question_CDM_side_effects_open",
            "question_side_effects_flashcard",
            "question_constructor_vs_setState_flashcard",
            "question_gDSFP_static_flashcard"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_dynamic_form_fields"
          ],
          "tags": [
            "React",
            "Lifecycle Methods",
            "Mounting",
            "Class Components",
            "State",
            "Props",
            "Side Effects"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "javascript_classes",
            "promises_and_fetch"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_hooks_lifecycle_equivalents",
            "performance_optimization_react"
          ]
        },
        {
          "id": "theory_updating_phase",
          "title": "React Component Updating Phase",
          "content": "The Updating Phase occurs when a component is being re-rendered as a result of changes to either its props or state. This phase is crucial for ensuring the component reflects the latest data, optimizing performance, and handling transitions smoothly. Understanding the order and purpose of these methods allows for efficient updates and prevents unnecessary re-renders.\n\n## Key Concepts\n-   **Re-rendering**: The process of updating the component's output due to changes in props or state.\n-   **Performance Optimization**: Preventing unnecessary re-renders to improve application responsiveness.\n-   **DOM Inspection/Snapshot**: Capturing current DOM state before an update to potentially restore it later.\n\n## Method Details\n\n### shouldComponentUpdate(nextProps, nextState)\n-   **Purpose**: Called before re-rendering when new props or state are received. It allows you to control whether a component should update or not. This is primarily used for performance optimization.\n-   **Execution**: Called first in the updating sequence, after new props/state are received but before `getDerivedStateFromProps` and `render`.\n-   **Important Notes**:\n    -   It must return a boolean value:\n        -   `true` (default): React proceeds with the update (calling `render`, etc.).\n        -   `false`: React skips the rendering process and all subsequent lifecycle methods in the update phase (i.e., `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`) for that specific update.\n    -   **Avoid** causing side effects in this method. It should be a pure function that compares `this.props` with `nextProps` and `this.state` with `nextState`.\n    -   Using `React.PureComponent` or `memo` (for functional components) automatically implements a shallow comparison in `shouldComponentUpdate`, often eliminating the need to write it manually.\n    -   Be careful when using this method, as premature optimization can lead to bugs if the component fails to update when it should.\n\n### static getDerivedStateFromProps(props, state)\n-   **Purpose**: As in the mounting phase, this method is called right before the `render` method, on both initial mount and updates. In the updating phase, its purpose is to update the component's internal state based on changes in incoming props.\n-   **Execution**: Called after `shouldComponentUpdate` (if it returns `true`) and before `render`.\n-   **Important Notes**: \n    -   It is `static` and does not have access to `this`.\n    -   It returns an object to update the state, or `null` if no state update is needed.\n    -   Its use case is specific: when state needs to be derived from props, and these props might change over time, requiring the state to be re-synchronized.\n    -   **Avoid** side effects.\n\n### render()\n-   **Purpose**: The `render()` method is called again during the updating phase to calculate the new React elements based on the updated props and state. React then diffs this new output with the previous one to determine the minimal changes needed in the actual DOM.\n-   **Execution**: Called after `static getDerivedStateFromProps` (if it returns an update) and before `getSnapshotBeforeUpdate`.\n-   **Important Notes**:\n    -   It must remain pure and free of side effects.\n    -   It should reflect the current state of the component's UI based on `this.props` and `this.state`.\n\n### getSnapshotBeforeUpdate(prevProps, prevState)\n-   **Purpose**: Invoked right before the changes from `render()` are committed to the DOM. This method allows your component to capture some information from the DOM (e.g., scroll position) before it is potentially changed by the update. The value returned by this method will be passed as the third parameter to `componentDidUpdate`.\n-   **Execution**: Called after `render` but before the DOM is actually updated.\n-   **Important Notes**:\n    -   This method is useful in scenarios like chat applications where you want to maintain scroll position even after new messages arrive.\n    -   It is rarely used, primarily for reading DOM properties just before an update.\n    -   It must return either a snapshot value (any type) or `null`.\n    -   **Avoid** side effects in this method. It should only read from the DOM.\n\n### componentDidUpdate(prevProps, prevState, snapshot)\n-   **Purpose**: Called immediately after updating occurs. This method is primarily used for performing side effects after a component has re-rendered and the DOM has been updated based on the new props and state. It is a good place to make network requests as long as you compare the current props to previous props.\n-   **Execution**: The last method called in the updating sequence, after the DOM has been updated.\n-   **Important Notes**:\n    -   You receive `prevProps`, `prevState`, and `snapshot` (the value returned from `getSnapshotBeforeUpdate`).\n    -   **Side Effects**: This is the ideal place for side effects triggered by updates, such as:\n        -   Making network requests (e.g., fetching new data if a prop like `userId` changes).\n        -   Interacting with the DOM that reflects the updated state (e.g., updating a D3 chart).\n        -   Calling `setState()` *conditionally* (e.g., inside an `if` statement that compares `prevProps` or `prevState` to current props/state) to avoid an infinite loop of re-renders. If `setState()` is called unconditionally, it will immediately trigger another update, leading to a loop.\n    -   Always compare `prevProps` and `prevState` with current props and state to avoid unnecessary re-renders or API calls.",
          "examples": [
            {
              "id": "example_updating_component",
              "title": "Basic Updating Lifecycle Component",
              "code": "import React from 'react';\n\nclass UpdatingComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0, showMore: false };\n    console.log('Constructor: Initializing state.');\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    console.log('getDerivedStateFromProps (Update): Deriving state from props.');\n    // Example: Reset count if a specific prop changes\n    if (props.resetCount && state.count !== 0) {\n      return { count: 0 };\n    }\n    return null;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate: Deciding whether to re-render.');\n    // Optimize: Only re-render if count or showMore state changes, or prop 'value' changes.\n    return (\n      nextProps.value !== this.props.value ||\n      nextState.count !== this.state.count ||\n      nextState.showMore !== this.state.showMore\n    );\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate: Capturing DOM info before update.');\n    // Example: Capture scroll position before list updates\n    if (this.props.list.length < prevProps.list.length) {\n        const list = document.getElementById('my-list');\n        if (list) {\n            return list.scrollHeight - list.scrollTop; // Amount of scrollable content below the visible part\n        }\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('componentDidUpdate: Component updated in DOM. Performing side effects.');\n    // Example: Fetch new data if 'value' prop changes\n    if (this.props.value !== prevProps.value) {\n      console.log(`Value prop changed from ${prevProps.value} to ${this.props.value}. Fetching new data...`);\n      // fetch(`/api/data?value=${this.props.value}`).then(...);\n    }\n\n    // Example: Use snapshot to adjust scroll position\n    if (snapshot !== null) {\n        console.log('Snapshot captured:', snapshot);\n        const list = document.getElementById('my-list');\n        if (list) {\n            list.scrollTop = list.scrollHeight - snapshot;\n        }\n    }\n\n    // Example: Conditionally update state (CAUTION: avoid infinite loops)\n    if (this.state.count < 5 && prevState.count === 0) {\n        // this.setState({ count: 1 }); // Would cause an extra re-render on initial update\n    }\n  }\n\n  handleClick = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  toggleShowMore = () => {\n    this.setState(prevState => ({ showMore: !prevState.showMore }));\n  };\n\n  render() {\n    console.log('render (Update): Rendering component JSX with updated props/state.');\n    return (\n      <div>\n        <h2>Updating Phase Demo</h2>\n        <p>Prop Value: {this.props.value}</p>\n        <p>State Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment Count</button>\n        <button onClick={this.toggleShowMore}>Toggle More Info</button>\n        {this.state.showMore && <p>More info is visible now!</p>}\n        <div id=\"my-list\" style={{ height: '100px', overflowY: 'scroll', border: '1px solid black' }}>\n          {this.props.list.map((item, index) => <p key={index}>{item}</p>)}\n        </div>\n      </div>\n    );\n  }\n}\n\n// Example usage from a parent component:\n/*\nclass App extends React.Component {\n  state = { dataValue: 'initial', listItems: ['Item 1', 'Item 2'] };\n\n  componentDidMount() {\n    setTimeout(() => this.setState({ dataValue: 'updated' }), 2000);\n    setTimeout(() => this.setState(prevState => ({ listItems: [...prevState.listItems, 'New Item'] })), 3000);\n  }\n\n  render() {\n    return <UpdatingComponent value={this.state.dataValue} list={this.state.listItems} />;\n  }\n}\n*/",
              "explanation": "This example showcases the methods involved in the updating phase. `shouldComponentUpdate` demonstrates a basic optimization strategy. `getDerivedStateFromProps` is present to illustrate its role if prop-derived state is needed. `render` re-evaluates the UI. `getSnapshotBeforeUpdate` captures scroll information from a simulated list before new items are potentially added and the DOM updates. Finally, `componentDidUpdate` uses the captured snapshot to adjust scroll position and checks for prop changes to simulate fetching new data, emphasizing the importance of conditional state updates/side effects.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_updating_order_mcq",
            "question_SCU_purpose_open",
            "question_snapshot_purpose_mcq",
            "question_CDU_setState_loop_open",
            "question_SCU_return_type_flashcard",
            "question_lifecycle_diagram_open",
            "question_gDSFP_update_mcq"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_optimizing_list_rendering",
            "task_chat_scroll_component"
          ],
          "tags": [
            "React",
            "Lifecycle Methods",
            "Updating",
            "Performance",
            "State",
            "Props",
            "Side Effects",
            "DOM Manipulation"
          ],
          "technology": "React",
          "prerequisites": [
            "react_mounting_phase",
            "react_state_management",
            "javascript_comparison"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_optimization_react",
            "complex_ui_interactions",
            "custom_hooks_implementation"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_mounting_order_mcq",
          "topic": "Mounting Phase Order",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct order of lifecycle methods called during the **Mounting Phase** of a React class component?",
          "answer": "constructor, static getDerivedStateFromProps, render, componentDidMount",
          "options": [
            "render, constructor, componentDidMount, static getDerivedStateFromProps",
            "constructor, static getDerivedStateFromProps, render, componentDidMount",
            "componentDidMount, constructor, render, static getDerivedStateFromProps",
            "constructor, render, componentDidMount, static getDerivedStateFromProps"
          ],
          "analysisPoints": [
            "Tests basic knowledge of React lifecycle method execution order.",
            "Highlights the initial setup (`constructor`), state derivation (`getDerivedStateFromProps`), rendering (`render`), and post-mount operations (`componentDidMount`)."
          ],
          "keyConcepts": [
            "Mounting Phase",
            "Lifecycle Order",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Ability to recall fundamental lifecycle order.",
            "Understanding of the sequence of component creation and DOM insertion."
          ],
          "example": "The mounting order is fixed and critical for understanding where to perform specific operations (e.g., state initialization in `constructor`, API calls in `componentDidMount`).",
          "tags": [
            "React",
            "Lifecycle",
            "Mounting",
            "Basic"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_constructor_purpose_mcq",
          "topic": "Constructor Method Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the `constructor(props)` method in a React class component?",
          "answer": "To initialize local state and bind event handler methods.",
          "options": [
            "To perform API calls and set up subscriptions.",
            "To update the DOM directly after component mounts.",
            "To initialize local state and bind event handler methods.",
            "To render JSX and return React elements."
          ],
          "analysisPoints": [
            "Tests understanding of the constructor's specific role.",
            "Distinguishes between state initialization/binding and side effects/rendering.",
            "Emphasizes that `this.state` can be directly assigned only here."
          ],
          "keyConcepts": [
            "Constructor",
            "State Initialization",
            "Method Binding",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Correctly identifies the core functions of the constructor.",
            "Avoids common misconceptions about side effects in constructor."
          ],
          "example": "```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 }; // Initialize state\n    this.handleClick = this.handleClick.bind(this); // Bind method\n  }\n  handleClick() { /* ... */ }\n  render() { return <button onClick={this.handleClick}>Click</button>; }\n}\n```\nThis example shows the correct use of the constructor for state initialization and method binding.",
          "tags": [
            "React",
            "Constructor",
            "State",
            "Binding",
            "Easy"
          ],
          "prerequisites": [
            "react_basics",
            "javascript_classes"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_gDSFP_role_open",
          "topic": "getDerivedStateFromProps Purpose",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of `static getDerivedStateFromProps(props, state)` and when you would typically use it. What are its key limitations?",
          "answer": "The `static getDerivedStateFromProps(props, state)` method is called right before calling the `render` method, both on initial mount and on subsequent updates. Its purpose is to enable a component to update its internal state based on changes in props. It should return an object to update the state, or `null` to indicate that no state update is needed.\n\nYou would typically use it for rare cases where the state *must* depend on changes in props over time. For example, if a component displays external data loaded via a `userId` prop, and if `userId` changes, the component's internal state (e.g., `loading` status or even the fetched data itself) might need to be reset or derived from the new `userId`.\n\nKey limitations include:\n1.  **Static Method**: Being static, it does not have access to the component instance (`this`). This means you cannot perform side effects, access other instance methods, or read from the DOM within this method.\n2.  **Pure Function**: It must be a pure function that only calculates and returns an object to update state. It should not cause any side effects (like API calls, subscriptions, or direct DOM manipulation).\n3.  **Specific Use Case**: It's meant for very specific scenarios where state *must* be a derivation of props. Often, `componentDidUpdate` (for side effects) or `setState` callbacks are more appropriate for handling prop changes.",
          "analysisPoints": [
            "Tests understanding of a less frequently used but important lifecycle method.",
            "Requires explaining its purpose, appropriate use cases, and strict limitations.",
            "Differentiates it from other lifecycle methods by highlighting its static nature and purity."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Derived State",
            "Static Methods",
            "Purity",
            "Limitations"
          ],
          "evaluationCriteria": [
            "Clear and accurate explanation of the method's purpose.",
            "Identification of valid use cases.",
            "Comprehensive listing of its limitations (static, no side effects)."
          ],
          "example": "A scenario where `getDerivedStateFromProps` might be used is a `Carousel` component that has `activeIndex` in its state. If a new `activeImageId` prop is passed, `getDerivedStateFromProps` could ensure `activeIndex` is reset or updated to reflect the new active image, assuming a mapping exists between ID and index. However, even this often has better solutions.",
          "tags": [
            "React",
            "Lifecycle",
            "Props",
            "State",
            "Medium"
          ],
          "prerequisites": [
            "react_props_state",
            "javascript_classes"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_purity_mcq",
          "topic": "Render Method Purity",
          "level": "medium",
          "type": "mcq",
          "question": "The `render()` method in a React class component should be 'pure'. What does 'pure' mean in this context?",
          "answer": "It should not modify component state, perform side effects, or interact directly with the browser DOM, and given the same props and state, it should always return the same output.",
          "options": [
            "It can only return primitive data types like strings or numbers.",
            "It must return a single root JSX element.",
            "It should only be called once during the component's lifetime.",
            "It should not modify component state, perform side effects, or interact directly with the browser DOM, and given the same props and state, it should always return the same output."
          ],
          "analysisPoints": [
            "Defines the concept of purity in the context of React's render method.",
            "Distinguishes between what `render` *does* (return JSX) and what it *should not do* (side effects, state mutation).",
            "Emphasizes the deterministic nature of pure functions."
          ],
          "keyConcepts": [
            "Render Method",
            "Purity",
            "Side Effects",
            "State Mutation",
            "Determinism"
          ],
          "evaluationCriteria": [
            "Accurate understanding of the 'purity' principle in React.",
            "Knowledge of restrictions on the `render` method."
          ],
          "example": "```javascript\nclass PureComponent extends React.Component {\n  render() {\n    // GOOD: Pure rendering based on props/state\n    return <div>Hello, {this.props.name}! Count: {this.state.count}</div>;\n  }\n}\n\nclass ImpureComponent extends React.Component {\n  render() {\n    // BAD: Modifying state directly in render (side effect)\n    // this.state.count++; // DO NOT DO THIS\n    \n    // BAD: Making an API call in render\n    // fetch('/api/data'); // DO NOT DO THIS\n    \n    return <div>Component Content</div>;\n  }\n}\n```\nThis example contrasts a pure `render` method with an impure one, demonstrating what to avoid.",
          "tags": [
            "React",
            "Render",
            "Purity",
            "Best Practices",
            "Medium"
          ],
          "prerequisites": [
            "react_basics",
            "functional_programming_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_CDM_side_effects_open",
          "topic": "componentDidMount for Side Effects",
          "level": "medium",
          "type": "open",
          "question": "Why is `componentDidMount()` considered the best place to perform side effects like API calls and subscriptions in a React class component?",
          "answer": "`componentDidMount()` is called immediately after a component is mounted (i.e., inserted into the DOM tree). This timing is crucial for several reasons:\n\n1.  **DOM Availability**: By the time `componentDidMount` is executed, the component's output has been rendered to the DOM. This means you have access to the actual DOM elements, which is essential for operations that interact directly with the DOM (e.g., initializing a D3 chart, setting up a map, measuring element dimensions).\n2.  **One-time Execution (on mount)**: For actions that should only occur once when the component first appears on the screen (like initial data fetching or setting up global event listeners), `componentDidMount` ensures they run precisely at that moment, avoiding unnecessary re-executions on updates.\n3.  **Avoiding Server-Side Issues**: When using server-side rendering (SSR), `componentDidMount` is not called on the server. This prevents side effects that depend on a browser environment (like DOM manipulation or fetching data via `window.fetch`) from running in a non-existent environment, which could lead to errors.\n4.  **No Blocking Render**: Performing API calls or other asynchronous operations here doesn't block the initial rendering of the component. The component can render a loading state first, and then update once the data is available, providing a better user experience.",
          "analysisPoints": [
            "Tests understanding of the practical implications of `componentDidMount`'s timing.",
            "Covers why specific operations (API, DOM, subscriptions) are suited for this method.",
            "Addresses concepts like DOM availability, one-time execution, and SSR compatibility."
          ],
          "keyConcepts": [
            "componentDidMount",
            "Side Effects",
            "API Calls",
            "DOM Manipulation",
            "Subscriptions",
            "SSR"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `componentDidMount`'s advantages for side effects.",
            "Demonstrates understanding of the React lifecycle's interaction with the browser environment."
          ],
          "example": "```javascript\nclass DataFetcher extends React.Component {\n  componentDidMount() {\n    // This is the ideal place for fetching data\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => this.setState({ data }))\n      .catch(error => console.error(error));\n\n    // Or setting up a resize listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    // Cleanup for componentDidMount effects\n    window.removeEventListener('resize', this.handleResize);\n  }\n}\n```",
          "tags": [
            "React",
            "Lifecycle",
            "Side Effects",
            "API",
            "DOM",
            "Medium",
            "Best Practices"
          ],
          "prerequisites": [
            "react_basics",
            "promises_and_fetch"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_side_effects_flashcard",
          "topic": "Side Effects in Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React lifecycle method is the primary place for performing side effects like API calls and setting up subscriptions during the mounting phase?",
          "answer": "componentDidMount()",
          "analysisPoints": [
            "Quick recall of method for side effects."
          ],
          "keyConcepts": [
            "Side Effects",
            "componentDidMount",
            "Mounting Phase"
          ],
          "evaluationCriteria": [
            "Ability to quickly identify the correct lifecycle method."
          ],
          "example": "Think of `componentDidMount` as the 'component is ready' signal, making it safe for external interactions.",
          "tags": [
            "React",
            "Lifecycle",
            "Side Effects",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_constructor_vs_setState_flashcard",
          "topic": "State Assignment",
          "level": "easy",
          "type": "flashcard",
          "question": "In a React class component, in which lifecycle method is it permissible to directly assign to `this.state` (e.g., `this.state = { key: value }`)?",
          "answer": "constructor(props)",
          "analysisPoints": [
            "Recalls the rule about direct state assignment."
          ],
          "keyConcepts": [
            "State Management",
            "Constructor",
            "setState"
          ],
          "evaluationCriteria": [
            "Correctly identifies the unique method for direct state assignment."
          ],
          "example": "Everywhere else, `this.setState()` is required to ensure React re-renders the component.",
          "tags": [
            "React",
            "State",
            "Constructor",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "react_state_management"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_gDSFP_static_flashcard",
          "topic": "Static getDerivedStateFromProps",
          "level": "medium",
          "type": "flashcard",
          "question": "True or False: `static getDerivedStateFromProps` has access to `this` (the component instance).",
          "answer": "False",
          "analysisPoints": [
            "Tests understanding of `static` methods in class components."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Static Methods",
            "Component Instance"
          ],
          "evaluationCriteria": [
            "Correctly identifies the static nature of the method."
          ],
          "example": "Because it's `static`, it operates only on its arguments (`props` and `state`) and cannot access `this.props` or `this.state` directly, nor other instance methods.",
          "tags": [
            "React",
            "Lifecycle",
            "Static",
            "Flashcard",
            "Medium"
          ],
          "prerequisites": [
            "javascript_classes"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_updating_order_mcq",
          "topic": "Updating Phase Order",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following sequences correctly represents the order of lifecycle methods called during the **Updating Phase** of a React class component, assuming `shouldComponentUpdate` returns `true`?",
          "answer": "shouldComponentUpdate, static getDerivedStateFromProps, render, getSnapshotBeforeUpdate, componentDidUpdate",
          "options": [
            "render, shouldComponentUpdate, componentDidUpdate, static getDerivedStateFromProps, getSnapshotBeforeUpdate",
            "shouldComponentUpdate, componentDidUpdate, render, static getDerivedStateFromProps, getSnapshotBeforeUpdate",
            "shouldComponentUpdate, static getDerivedStateFromProps, render, getSnapshotBeforeUpdate, componentDidUpdate",
            "static getDerivedStateFromProps, shouldComponentUpdate, render, componentDidUpdate, getSnapshotBeforeUpdate"
          ],
          "analysisPoints": [
            "Tests comprehensive knowledge of the updating lifecycle order.",
            "Crucial for understanding where optimizations and post-update logic fit.",
            "Includes less common methods like `getSnapshotBeforeUpdate`."
          ],
          "keyConcepts": [
            "Updating Phase",
            "Lifecycle Order",
            "shouldComponentUpdate",
            "getDerivedStateFromProps",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate"
          ],
          "evaluationCriteria": [
            "Accurate recall of the entire updating lifecycle flow.",
            "Understanding of the conditional nature introduced by `shouldComponentUpdate`."
          ],
          "example": "This order ensures React first determines if an update is needed, then prepares state based on new props, renders the new virtual DOM, captures pre-DOM update info, and finally performs post-DOM update effects.",
          "tags": [
            "React",
            "Lifecycle",
            "Updating",
            "Medium"
          ],
          "prerequisites": [
            "react_mounting_phase"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_SCU_purpose_open",
          "topic": "shouldComponentUpdate Purpose",
          "level": "medium",
          "type": "open",
          "question": "Describe the purpose of `shouldComponentUpdate(nextProps, nextState)` in React class components. When would you typically implement it, and what are the potential pitfalls?",
          "answer": "`shouldComponentUpdate(nextProps, nextState)` is a lifecycle method called before a component is re-rendered due to new props or state. Its primary purpose is **performance optimization**. It must return a boolean value:\n-   `true` (default): React will proceed with the re-rendering process (i.e., call `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`).\n-   `false`: React will skip the entire re-rendering process for this component and its children for that specific update.\n\nYou would typically implement it when you observe performance bottlenecks caused by unnecessary re-renders of a component. This often happens when a parent component re-renders, causing all its children to re-render, even if the child's props or state haven't effectively changed.\n\n**Potential Pitfalls:**\n1.  **Premature Optimization**: Don't implement `shouldComponentUpdate` unless you have identified an actual performance problem. It adds complexity and can sometimes be slower than React's default reconciliation if your comparison logic is inefficient.\n2.  **Bugs due to Incorrect Comparisons**: If your comparison logic is flawed (e.g., shallow comparison when a deep comparison is needed, or missing a prop/state change), the component might fail to update when it should, leading to stale UI. This is a common source of subtle bugs.\n3.  **Side Effects**: Like `render` and `getDerivedStateFromProps`, `shouldComponentUpdate` should be a pure function. Performing side effects within it can lead to unpredictable behavior and hard-to-debug issues.\n\nIn modern React, `React.PureComponent` (which implements a shallow `shouldComponentUpdate`) or `React.memo` (for functional components) are often preferred as they handle common optimization scenarios automatically.",
          "analysisPoints": [
            "Tests understanding of performance optimization in React.",
            "Covers the method's role, use cases, and critical considerations.",
            "Highlights the trade-offs and potential issues with manual implementation."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Re-rendering",
            "PureComponent",
            "React.memo",
            "Pitfalls"
          ],
          "evaluationCriteria": [
            "Clear explanation of purpose and return value.",
            "Identification of appropriate use cases (performance bottlenecks).",
            "Comprehensive listing and explanation of common pitfalls."
          ],
          "example": "```javascript\nclass OptimizedComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'value' prop changes or 'isActive' state changes.\n    // This is a shallow comparison; for nested objects/arrays, deep comparison or immutability is needed.\n    return nextProps.value !== this.props.value || nextState.isActive !== this.state.isActive;\n  }\n\n  render() {\n    console.log('OptimizedComponent rendered');\n    return <div>Value: {this.props.value}, Active: {this.state.isActive ? 'Yes' : 'No'}</div>;\n  }\n}\n```",
          "tags": [
            "React",
            "Lifecycle",
            "Performance",
            "Optimization",
            "Medium",
            "Best Practices"
          ],
          "prerequisites": [
            "react_props_state"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_snapshot_purpose_mcq",
          "topic": "getSnapshotBeforeUpdate Purpose",
          "level": "hard",
          "type": "mcq",
          "question": "What is the primary purpose of `getSnapshotBeforeUpdate(prevProps, prevState)` in the React lifecycle?",
          "answer": "To capture information from the DOM (e.g., scroll position) immediately before it is updated.",
          "options": [
            "To perform asynchronous data fetching before the component updates.",
            "To decide whether the component should re-render or not.",
            "To capture information from the DOM (e.g., scroll position) immediately before it is updated.",
            "To initialize component state based on new props."
          ],
          "analysisPoints": [
            "Tests knowledge of a less common but powerful lifecycle method.",
            "Distinguishes its role (pre-DOM update snapshot) from other methods (data fetching, re-render decision, state initialization).",
            "Emphasizes its synchronous nature and return value."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "DOM Manipulation",
            "Updating Phase",
            "Snapshot"
          ],
          "evaluationCriteria": [
            "Accurate identification of the specific purpose of the method.",
            "Understanding its position in the lifecycle relative to DOM updates."
          ],
          "example": "```javascript\nclass ChatBox extends React.Component {\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Are we adding new items?\n    if (this.props.messages.length > prevProps.messages.length) {\n      const list = this.listRef.current;\n      // Capture scroll height if user is near the bottom\n      if (list && list.scrollTop + list.clientHeight >= list.scrollHeight - 50) {\n        return list.scrollHeight;\n      }\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // If we received a snapshot, it means we were near the bottom, so maintain scroll\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      if (list) {\n        list.scrollTop = list.scrollHeight - snapshot;\n      }\n    }\n  }\n  render() {\n    return <div ref={this.listRef}>...messages...</div>;\n  }\n}\n```\nThis example shows how `getSnapshotBeforeUpdate` is used to capture the scroll position before new messages are rendered, allowing `componentDidUpdate` to adjust the scroll so the user stays at the bottom.",
          "tags": [
            "React",
            "Lifecycle",
            "DOM",
            "Advanced",
            "Hard"
          ],
          "prerequisites": [
            "react_updating_phase"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_CDU_setState_loop_open",
          "topic": "componentDidUpdate and setState",
          "level": "hard",
          "type": "open",
          "question": "Can you call `setState()` inside `componentDidUpdate()`? If so, what precautions must you take, and why?",
          "answer": "Yes, you can call `setState()` inside `componentDidUpdate()`, but you must do so **conditionally**. If `setState()` is called unconditionally in `componentDidUpdate()`, it will immediately trigger another update cycle for the component, leading to an **infinite loop** of re-renders.\n\n**Precautions to take:**\n1.  **Always wrap `setState()` in a condition**: The condition must compare the current props (`this.props`) or state (`this.state`) with the previous props (`prevProps`) or state (`prevState`) that were passed as arguments to `componentDidUpdate()`. For example, `if (this.props.userId !== prevProps.userId) { this.setState({ ... }); }`.\n2.  **Ensure the condition eventually evaluates to `false`**: The condition must ensure that the `setState` call will eventually stop. If the `setState` call itself causes the condition to remain true, you'll still have an infinite loop.\n\n**Why these precautions?**\n-   `componentDidUpdate()` is called *after* every re-render (triggered by props or state changes). If `setState()` is called without a condition, it will trigger a new re-render, which in turn calls `componentDidUpdate()` again, creating a continuous loop. This quickly exhausts the browser's resources and crashes the application.\n-   By comparing `prevProps` and `prevState`, you ensure that `setState()` is only called when there's a *meaningful* change that requires a subsequent state update, thus breaking the potential loop and ensuring predictable behavior.",
          "analysisPoints": [
            "Tests advanced understanding of lifecycle methods and state management.",
            "Requires knowledge of potential pitfalls (infinite loops) and how to prevent them.",
            "Emphasizes conditional logic for safe state updates."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "setState",
            "Infinite Loop",
            "Conditional Rendering",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Clear explanation of `setState`'s permissibility.",
            "Accurate identification and explanation of infinite loop risk.",
            "Detailed guidance on necessary conditional checks."
          ],
          "example": "```javascript\nclass UserProfile extends React.Component {\n  state = { userData: null, loading: false };\n\n  componentDidUpdate(prevProps) {\n    // CORRECT: Only fetch data if userId prop has changed\n    if (this.props.userId !== prevProps.userId) {\n      this.setState({ loading: true });\n      fetch(`/api/users/${this.props.userId}`)\n        .then(res => res.json())\n        .then(data => this.setState({ userData: data, loading: false }))\n        .catch(error => console.error(error));\n    }\n  }\n\n  render() {\n    if (this.state.loading) return <div>Loading user data...</div>;\n    return <div>{this.state.userData ? `User: ${this.state.userData.name}` : 'No user selected'}</div>;\n  }\n}\n```\nThis example correctly uses `setState` within `componentDidUpdate` by checking if `userId` has changed, preventing an infinite loop.",
          "tags": [
            "React",
            "Lifecycle",
            "State",
            "API",
            "Hard",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "react_state_management",
            "react_updating_phase"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_SCU_return_type_flashcard",
          "topic": "shouldComponentUpdate Return Value",
          "level": "easy",
          "type": "flashcard",
          "question": "What data type must `shouldComponentUpdate(nextProps, nextState)` return?",
          "answer": "Boolean",
          "analysisPoints": [
            "Quick recall of method return type."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Return Type",
            "Performance"
          ],
          "evaluationCriteria": [
            "Correctly identifies the required return type."
          ],
          "example": "Returning `true` means re-render, `false` means skip re-render.",
          "tags": [
            "React",
            "Lifecycle",
            "Performance",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_diagram_open",
          "topic": "React Class Component Lifecycle",
          "level": "hard",
          "type": "open",
          "question": "Draw or describe a complete diagram of the React class component lifecycle, including both mounting and updating phases. For each method, briefly state its purpose and whether side effects are allowed.",
          "answer": "```mermaid\ngraph TD\n    A[Constructor] --> B{static getDerivedStateFromProps}\n    B --> C[render]\n    C --> D[componentDidMount]\n\n    D --> E[Props/State Change]\n    E --> F{shouldComponentUpdate}\n    F -- returns false --> I[No Re-render]\n    F -- returns true --> B2{static getDerivedStateFromProps}\n    B2 --> G[render]\n    G --> H[getSnapshotBeforeUpdate]\n    H --> J[componentDidUpdate]\n\n    J --> E\n\n    D --> K[componentWillUnmount]\n    K --> L[Component Unmounted]\n\n    subgraph Mounting\n        A\n        B\n        C\n        D\n    end\n\n    subgraph Updating\n        E\n        F\n        B2\n        G\n        H\n        J\n    end\n\n    subgraph Unmounting\n        K\n        L\n    end\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n    style D fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n    style J fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n    style K fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n\n    classDef sideEffectMethods fill:#ffe,stroke:#333,stroke-width:2px,color:#000\n    class D,J,K sideEffectMethods\n\n    %% Method Details\n    note over A: Purpose: Initialize state, bind methods. Side Effects: NO.\n    note over B: Purpose: Derive state from props. Side Effects: NO.\n    note over C: Purpose: Return JSX. Side Effects: NO (pure).\n    note over D: Purpose: First place component is in DOM. Side Effects: YES (API calls, subscriptions).\n\n    note over E: Event: Props or state change.\n    note over F: Purpose: Optimize re-renders. Return boolean. Side Effects: NO (pure).\n    note over B2: Purpose: (Same as mount) Derive state from props. Side Effects: NO.\n    note over G: Purpose: (Same as mount) Return new JSX. Side Effects: NO (pure).\n    note over H: Purpose: Capture DOM info before update. Side Effects: NO (read only).\n    note over J: Purpose: After DOM update. Side Effects: YES (conditional API calls, DOM manipulation based on new state/props).\n\n    note over K: Purpose: Cleanup (remove event listeners, cancel subscriptions). Side Effects: YES.\n\n```\n\n**Brief Purpose and Side Effect Allowance:**\n\n**Mounting Phase:**\n1.  `constructor(props)`: Initializes state and binds methods. **NO** side effects.\n2.  `static getDerivedStateFromProps(props, state)`: Updates state based on prop changes. **NO** side effects (must be pure).\n3.  `render()`: Returns JSX to be rendered. **NO** side effects (must be pure).\n4.  `componentDidMount()`: Called after component is in DOM. Ideal for API calls, subscriptions, DOM manipulation. **YES** side effects.\n\n**Updating Phase:**\n1.  `static getDerivedStateFromProps(props, state)`: (Same as Mounting) Updates state based on prop changes. **NO** side effects.\n2.  `shouldComponentUpdate(nextProps, nextState)`: Determines if component should re-render. Returns boolean. **NO** side effects (must be pure).\n3.  `render()`: (Same as Mounting) Returns new JSX. **NO** side effects.\n4.  `getSnapshotBeforeUpdate(prevProps, prevState)`: Captures DOM information just before update. **NO** side effects (read-only).\n5.  `componentDidUpdate(prevProps, prevState, snapshot)`: Called after DOM update. Ideal for conditional API calls based on prop/state changes, DOM manipulation. **YES** side effects (with caution for `setState`).\n\n**Unmounting Phase:**\n1.  `componentWillUnmount()`: Called before component unmounts. Ideal for cleanup (remove listeners, cancel subscriptions). **YES** side effects (cleanup related).",
          "analysisPoints": [
            "Tests a holistic understanding of the entire class component lifecycle.",
            "Requires recalling the precise order and purpose of each method.",
            "Challenges the ability to differentiate where side effects are appropriate and where they are forbidden."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Mounting",
            "Updating",
            "Unmounting",
            "Side Effects",
            "Purity",
            "Order of Execution"
          ],
          "evaluationCriteria": [
            "Completeness and accuracy of the lifecycle diagram/description.",
            "Correct identification of purpose and side effect allowance for each method.",
            "Clarity of explanation and organization."
          ],
          "example": "Visualizing the lifecycle helps in understanding the flow of data and execution within a React component.",
          "tags": [
            "React",
            "Lifecycle",
            "Diagram",
            "Advanced",
            "Hard",
            "Theory"
          ],
          "prerequisites": [
            "react_mounting_phase",
            "react_updating_phase"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_gDSFP_update_mcq",
          "topic": "getDerivedStateFromProps in Update Phase",
          "level": "medium",
          "type": "mcq",
          "question": "In the Updating Phase, when `static getDerivedStateFromProps(props, state)` is called, what is its primary responsibility?",
          "answer": "To update the component's state based on changes in its props.",
          "options": [
            "To perform API calls if props have changed.",
            "To decide whether the component should re-render or not.",
            "To update the component's state based on changes in its props.",
            "To capture a snapshot of the DOM before rendering."
          ],
          "analysisPoints": [
            "Reinforces the understanding of `getDerivedStateFromProps`'s role across both mounting and updating.",
            "Differentiates its specific purpose from other methods (API calls, re-render decision, DOM snapshot).",
            "Emphasizes that it's about state derivation from props, not side effects."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Updating Phase",
            "Derived State",
            "Props",
            "State"
          ],
          "evaluationCriteria": [
            "Correctly identifies the function of `getDerivedStateFromProps` in the update phase.",
            "Avoids confusing it with methods for side effects or rendering control."
          ],
          "example": "If a component receives a new `itemId` prop, `getDerivedStateFromProps` could set a `loading` state to `true` if the `itemId` has changed, indicating that new data needs to be fetched based on the new prop.",
          "tags": [
            "React",
            "Lifecycle",
            "Updating",
            "Props",
            "State",
            "Medium"
          ],
          "prerequisites": [
            "react_mounting_phase"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_data_fetching_component",
          "title": "Implement a Data Fetching Component",
          "description": "\nCreate a React class component named `PostViewer` that fetches data from a public API and displays it. This task focuses on utilizing the **Mounting Phase** lifecycle methods correctly.\n\n**Requirements:**\n1.  The component should fetch a single post from `https://jsonplaceholder.typicode.com/posts/1`.\n2.  Initialize the component's state to manage `postData` (initially `null`) and `loading` (initially `true`).\n3.  Use the `constructor` to initialize the state and bind any necessary methods.\n4.  Use `componentDidMount` to perform the API call.\n5.  After the data is fetched successfully, update the `postData` state and set `loading` to `false`.\n6.  Display a 'Loading...' message while data is being fetched.\n7.  Once loaded, display the post's title and body.\n8.  Include basic error handling (e.g., `console.error`) for the fetch request.\n\n**Bonus:** Implement a `componentWillUnmount` to simulate cleanup, e.g., logging a message or clearing a hypothetical timer.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass PostViewer extends React.Component {\n  // TODO: Initialize state in constructor\n  // TODO: Fetch data in componentDidMount\n  // TODO: Implement render method to display loading/data\n  \n  constructor(props) {\n    super(props);\n    this.state = {\n      postData: null,\n      loading: true,\n      error: null\n    };\n    console.log('PostViewer: Constructor called');\n  }\n\n  // static getDerivedStateFromProps(props, state) { return null; }\n\n  componentDidMount() {\n    console.log('PostViewer: componentDidMount called. Fetching data...');\n    // TODO: Perform API call here\n    // fetch('https://jsonplaceholder.typicode.com/posts/1')\n    //   .then(response => response.json())\n    //   .then(data => this.setState({ postData: data, loading: false }))\n    //   .catch(error => this.setState({ error: error, loading: false }));\n  }\n\n  // Bonus: Add componentWillUnmount\n  // componentWillUnmount() {\n  //   console.log('PostViewer: componentWillUnmount called. Cleaning up...');\n  // }\n\n  render() {\n    console.log('PostViewer: render called');\n    const { postData, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading post...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div>\n        <h3>{postData.title}</h3>\n        <p>{postData.body}</p>\n      </div>\n    );\n  }\n}\n\nexport default PostViewer;",
          "solutionCode": "import React from 'react';\n\nclass PostViewer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      postData: null,\n      loading: true,\n      error: null\n    };\n    console.log('PostViewer: Constructor called');\n  }\n\n  componentDidMount() {\n    console.log('PostViewer: componentDidMount called. Fetching data...');\n    fetch('https://jsonplaceholder.typicode.com/posts/1')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({ postData: data, loading: false });\n        console.log('PostViewer: Data fetched successfully.');\n      })\n      .catch(error => {\n        this.setState({ error: error, loading: false });\n        console.error('PostViewer: Error fetching data:', error);\n      });\n  }\n\n  componentWillUnmount() {\n    console.log('PostViewer: componentWillUnmount called. Cleaning up any subscriptions/timers.');\n    // For example, if you had a WebSocket connection or a timer, you'd close/clear it here.\n  }\n\n  render() {\n    console.log('PostViewer: render called');\n    const { postData, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading post...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '8px' }}>\n        <h3>{postData.title}</h3>\n        <p>{postData.body}</p>\n      </div>\n    );\n  }\n}\n\nexport default PostViewer;",
          "testCases": [
            "Initial render displays 'Loading post...'.",
            "After fetch completes successfully, component displays post title and body.",
            "In case of a fetch error (e.g., network down or invalid URL), an error message is displayed.",
            "Console logs verify the order of `constructor`, `componentDidMount`, and `render`.",
            "(`componentWillUnmount` bonus) A message is logged to the console when the component is unmounted from the DOM (e.g., by conditional rendering in a parent component)."
          ],
          "hints": [
            "Remember to call `super(props)` in the `constructor`.",
            "`fetch` returns a Promise, so use `.then()` and `.catch()`.",
            "Update state using `this.setState()` once data is received.",
            "The `loading` state helps manage what to display before and after data arrives."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Mounting",
            "Data Fetching",
            "API",
            "State Management"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_basics",
            "promises_and_fetch",
            "theory_mounting_phase"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "componentDidMount",
            "constructor",
            "render",
            "setState"
          ]
        },
        {
          "id": "task_optimizing_list_rendering",
          "title": "Optimize List Re-rendering with shouldComponentUpdate",
          "description": "\nCreate a React class component named `OptimizedListItem` that represents an individual item in a list. This component should only re-render if its `itemData` prop or `isSelected` prop actually changes. This task focuses on utilizing the `shouldComponentUpdate` method for performance optimization in the **Updating Phase**.\n\n**Requirements:**\n1.  Create a `ListItem` class component that accepts `itemData` (an object with `id` and `text`) and `isSelected` (a boolean) as props.\n2.  Implement a `render` method that displays the `itemData.text` and visually indicates if `isSelected` is `true` (e.g., by changing background color or adding a border).\n3.  Implement `shouldComponentUpdate(nextProps, nextState)` to prevent unnecessary re-renders. The component should only re-render if:\n    *   `nextProps.itemData.id` is different from `this.props.itemData.id`\n    *   `nextProps.itemData.text` is different from `this.props.itemData.text`\n    *   `nextProps.isSelected` is different from `this.props.isSelected`\n4.  Add `console.log` statements inside `render` and `shouldComponentUpdate` to verify when they are called.\n5.  (Optional but recommended for testing): Create a parent component `App` that renders a list of `OptimizedListItem` components. Implement logic in `App` to periodically update some `itemData` or `isSelected` props for *some* items, and also trigger parent re-renders that *don't* change props for other items, to demonstrate the optimization working.\n\n**Hint:** A simple shallow comparison of primitive props is sufficient for `shouldComponentUpdate` in this case, but remember that for complex nested objects, a deeper comparison or immutability might be needed in real-world scenarios.",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass OptimizedListItem extends React.Component {\n  // TODO: Implement shouldComponentUpdate\n  // shouldComponentUpdate(nextProps, nextState) {\n  //   // Return true if re-render is needed, false otherwise\n  //   return false; \n  // }\n\n  render() {\n    console.log(`Rendering ListItem: ${this.props.itemData.id}`);\n    const { itemData, isSelected } = this.props;\n    const style = {\n      padding: '10px',\n      margin: '5px 0',\n      border: '1px solid #ddd',\n      backgroundColor: isSelected ? '#e6ffe6' : 'white'\n    };\n    return (\n      <div style={style}>\n        ID: {itemData.id} - {itemData.text}\n        {isSelected && ' (Selected)'}\n      </div>\n    );\n  }\n}\n\n// Parent component for testing (optional, but useful)\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      items: [\n        { id: 1, text: 'First item' },\n        { id: 2, text: 'Second item' },\n        { id: 3, text: 'Third item' }\n      ],\n      selectedId: 1,\n      // A dummy state to trigger parent re-renders without changing child props\n      dummyRenderTrigger: 0\n    };\n  }\n\n  componentDidMount() {\n    // Simulate updates\n    setInterval(() => {\n      this.setState(prevState => ({\n        // Change selected item periodically\n        selectedId: prevState.selectedId === 3 ? 1 : prevState.selectedId + 1,\n        // Update dummy state to trigger App's re-render\n        dummyRenderTrigger: prevState.dummyRenderTrigger + 1\n      }));\n    }, 2000);\n\n    // Simulate a text update for a specific item\n    setTimeout(() => {\n      this.setState(prevState => ({\n        items: prevState.items.map(item => \n          item.id === 2 ? { ...item, text: 'Second item - UPDATED!' } : item\n        )\n      }));\n    }, 4000);\n  }\n\n  render() {\n    console.log('App (Parent) rendering');\n    const { items, selectedId } = this.state;\n    return (\n      <div>\n        <h2>Optimized List Demo (Parent renders {this.state.dummyRenderTrigger} times without prop changes for all children)</h2>\n        {items.map(item => (\n          <OptimizedListItem\n            key={item.id}\n            itemData={item}\n            isSelected={item.id === selectedId}\n          />\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\n\nclass OptimizedListItem extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Log for demonstration purposes\n    console.log(`shouldComponentUpdate for ListItem ${this.props.itemData.id}`);\n    console.log(`  nextProps.itemData.id: ${nextProps.itemData.id} vs this.props.itemData.id: ${this.props.itemData.id}`);\n    console.log(`  nextProps.itemData.text: ${nextProps.itemData.text} vs this.props.itemData.text: ${this.props.itemData.text}`);\n    console.log(`  nextProps.isSelected: ${nextProps.isSelected} vs this.props.isSelected: ${this.props.isSelected}`);\n\n    // Only re-render if specific props have changed\n    if (nextProps.itemData.id !== this.props.itemData.id) {\n      return true;\n    }\n    if (nextProps.itemData.text !== this.props.itemData.text) {\n      return true;\n    }\n    if (nextProps.isSelected !== this.props.isSelected) {\n      return true;\n    }\n    \n    console.log(`  ListItem ${this.props.itemData.id} will NOT re-render.`);\n    return false; // No relevant prop changes, so skip re-render\n  }\n\n  render() {\n    console.log(`Rendering ListItem: ${this.props.itemData.id} - RENDERED!`);\n    const { itemData, isSelected } = this.props;\n    const style = {\n      padding: '10px',\n      margin: '5px 0',\n      border: '1px solid #ddd',\n      backgroundColor: isSelected ? '#e6ffe6' : 'white',\n      transition: 'background-color 0.3s ease'\n    };\n    return (\n      <div style={style}>\n        ID: {itemData.id} - {itemData.text}\n        {isSelected && ' (Selected)'}\n      </div>\n    );\n  }\n}\n\n// Parent component for testing\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      items: [\n        { id: 1, text: 'First item' },\n        { id: 2, text: 'Second item' },\n        { id: 3, text: 'Third item' },\n        { id: 4, text: 'Fourth item' } // Added an extra item to show untouched behavior\n      ],\n      selectedId: 1,\n      dummyRenderTrigger: 0\n    };\n  }\n\n  componentDidMount() {\n    // Simulate updates\n    setInterval(() => {\n      this.setState(prevState => ({\n        selectedId: prevState.selectedId === 4 ? 1 : prevState.selectedId + 1,\n        dummyRenderTrigger: prevState.dummyRenderTrigger + 1\n      }));\n    }, 1500); // Faster interval to see more frequent App re-renders\n\n    // Simulate a text update for a specific item\n    setTimeout(() => {\n      this.setState(prevState => ({\n        items: prevState.items.map(item => \n          item.id === 2 ? { ...item, text: 'Second item - TEXT UPDATED!' } : item\n        )\n      }));\n    }, 4000);\n\n    // Simulate another text update for a different item\n    setTimeout(() => {\n        this.setState(prevState => ({\n            items: prevState.items.map(item => \n                item.id === 3 ? { ...item, text: 'Third item - NEW TEXT!' } : item\n            )\n        }));\n    }, 7000);\n  }\n\n  render() {\n    console.log('App (Parent) rendering - Dummy Trigger:', this.state.dummyRenderTrigger);\n    const { items, selectedId } = this.state;\n    return (\n      <div style={{ fontFamily: 'Arial, sans-serif' }}>\n        <h2>Optimized List Demo (App Render Count: {this.state.dummyRenderTrigger})</h2>\n        <p>This demo shows how <code>shouldComponentUpdate</code> prevents individual list items from re-rendering unless their specific props change.</p>\n        {items.map(item => (\n          <OptimizedListItem\n            key={item.id}\n            itemData={item}\n            isSelected={item.id === selectedId}\n          />\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default App;",
          "testCases": [
            "Initially, all `OptimizedListItem` components render once.",
            "When `App`'s `selectedId` state changes, only the `OptimizedListItem` components whose `isSelected` prop changed (from true to false, or false to true) should have their `render` method called. Others should not.",
            "When `App`'s `dummyRenderTrigger` state changes (causing `App` to re-render), but no `OptimizedListItem`'s props change, no `OptimizedListItem`'s `render` method should be called.",
            "When an `itemData.text` property for a specific item changes, only that `OptimizedListItem` should re-render.",
            "Console logs clearly demonstrate when `shouldComponentUpdate` returns `true` (leading to a `render`) and when it returns `false` (skipping `render`)."
          ],
          "hints": [
            "Remember that `shouldComponentUpdate` receives `nextProps` and `nextState`.",
            "You need to compare `nextProps` with `this.props` for each relevant prop.",
            "Return `true` if any relevant prop has changed, `false` otherwise.",
            "For object props like `itemData`, you'll need to compare their individual properties (`id`, `text`) since `itemData !== nextProps.itemData` would likely always be true for new objects created during updates, defeating the purpose."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Updating",
            "Performance Optimization",
            "shouldComponentUpdate"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_props_state",
            "theory_updating_phase"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "shouldComponentUpdate",
            "PureComponent",
            "Re-rendering",
            "Performance"
          ]
        },
        {
          "id": "task_chat_scroll_component",
          "title": "Implement a Chat Message Scroller with Snapshot",
          "description": "\nCreate a React class component named `ChatMessageList` that displays a list of chat messages. The component should maintain scroll position when new messages are added, specifically by keeping the user at the bottom of the list if they were already near the bottom, otherwise preserving their current scroll position.\n\nThis task focuses on utilizing `getSnapshotBeforeUpdate` and `componentDidUpdate` in the **Updating Phase** for managing DOM state during updates.\n\n**Requirements:**\n1.  The `ChatMessageList` component should accept a `messages` prop (an array of strings).\n2.  Render the messages in a scrollable `div` with a fixed height and `overflow-y: auto`.\n3.  Implement `getSnapshotBeforeUpdate(prevProps, prevState)` to capture the scroll position before the DOM updates.\n    *   Specifically, if new messages are being added (i.e., `this.props.messages.length > prevProps.messages.length`), check if the user's current scroll position is within a small buffer (e.g., 50px) of the bottom of the scroll container.\n    *   If they are near the bottom, return the `scrollHeight` of the container.\n    *   Otherwise, return `null`.\n4.  Implement `componentDidUpdate(prevProps, prevState, snapshot)` to adjust the scroll position.\n    *   If a `snapshot` value was returned from `getSnapshotBeforeUpdate`, it means the user was near the bottom, so adjust `scrollTop` to maintain their position relative to the bottom (i.e., new `scrollTop` = new `scrollHeight` - old `scrollHeight` from snapshot).\n    *   If `snapshot` is `null`, do nothing, preserving the user's manual scroll position.\n5.  (Optional but recommended for testing): Create a parent `App` component that periodically adds new messages to the `ChatMessageList`'s `messages` prop to simulate a chat. Include buttons to manually scroll and observe behavior.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\nclass ChatMessageList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef(); // Create a ref to access the DOM element\n    console.log('ChatMessageList: Constructor');\n  }\n\n  // TODO: Implement getSnapshotBeforeUpdate\n  // getSnapshotBeforeUpdate(prevProps, prevState) {\n  //   if (this.props.messages.length > prevProps.messages.length) {\n  //     const list = this.listRef.current;\n  //     if (list) {\n  //       // Check if user is scrolled to bottom or near bottom\n  //       const isScrolledToBottom = list.scrollTop + list.clientHeight >= list.scrollHeight - 50; // 50px buffer\n  //       if (isScrolledToBottom) {\n  //         return list.scrollHeight; // Return scrollHeight from before update\n  //       }\n  //     }\n  //   }\n  //   return null; // No snapshot needed\n  // }\n\n  // TODO: Implement componentDidUpdate\n  // componentDidUpdate(prevProps, prevState, snapshot) {\n  //   if (snapshot !== null) {\n  //     const list = this.listRef.current;\n  //     if (list) {\n  //       // Adjust scroll to maintain position relative to bottom\n  //       list.scrollTop = list.scrollHeight - snapshot;\n  //     }\n  //   }\n  // }\n\n  render() {\n    console.log('ChatMessageList: Render');\n    const { messages } = this.props;\n    return (\n      <div\n        ref={this.listRef}\n        style={{\n          height: '250px',\n          border: '1px solid #ccc',\n          overflowY: 'auto',\n          padding: '10px',\n          fontFamily: 'monospace',\n          whiteSpace: 'pre-wrap'\n        }}\n      >\n        {messages.map((msg, index) => (\n          <div key={index} style={{ marginBottom: '5px' }}>{msg}</div>\n        ))}\n      </div>\n    );\n  }\n}\n\n// Parent for testing\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      messages: [\n        \"Hello!\",\n        \"Welcome to the chat.\",\n        \"This is an initial message.\",\n        \"Scroll down to see more.\",\n        \"More messages will appear automatically.\",\n        \"This is message 6\", \"This is message 7\", \"This is message 8\", \"This is message 9\", \"This is message 10\", \"This is message 11\", \"This is message 12\", \"This is message 13\", \"This is message 14\", \"This is message 15\", \"This is message 16\", \"This is message 17\", \"This is message 18\", \"This is message 19\", \"This is message 20\", \"This is message 21\", \"This is message 22\", \"This is message 23\", \"This is message 24\", \"This is message 25\"\n      ]\n    };\n  }\n\n  componentDidMount() {\n    this.messageInterval = setInterval(() => {\n      this.setState(prevState => ({\n        messages: [...prevState.messages, `New message ${prevState.messages.length + 1}`]\n      }));\n    }, 1000); // Add a new message every second\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.messageInterval);\n  }\n\n  render() {\n    return (\n      <div style={{ padding: '20px' }}>\n        <h2>Chat Application</h2>\n        <ChatMessageList messages={this.state.messages} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\n\nclass ChatMessageList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef();\n    console.log('ChatMessageList: Constructor');\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('ChatMessageList: getSnapshotBeforeUpdate');\n    // Are we adding new messages?\n    if (this.props.messages.length > prevProps.messages.length) {\n      const list = this.listRef.current;\n      if (list) {\n        // Check if the user was scrolled to the bottom (or very near the bottom)\n        const isScrolledToBottom = list.scrollTop + list.clientHeight >= list.scrollHeight - 20; // 20px buffer\n        if (isScrolledToBottom) {\n          return list.scrollHeight; // Return the current scrollHeight BEFORE the DOM update\n        }\n      }\n    }\n    return null; // If not adding messages or not at bottom, no snapshot needed\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('ChatMessageList: componentDidUpdate');\n    // If a snapshot was returned, it means we were scrolled to the bottom before the update\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      if (list) {\n        // Adjust scroll position to keep the user at the new bottom\n        // new scrollTop = current scrollHeight - (old scrollHeight from snapshot)\n        list.scrollTop = list.scrollHeight - snapshot;\n        console.log(`ChatMessageList: Adjusted scroll to new bottom. New scrollTop: ${list.scrollTop}`);\n      }\n    } else {\n        console.log('ChatMessageList: No snapshot, preserving user scroll position.');\n    }\n  }\n\n  render() {\n    console.log('ChatMessageList: Render');\n    const { messages } = this.props;\n    return (\n      <div\n        ref={this.listRef}\n        style={{\n          height: '250px',\n          border: '1px solid #ccc',\n          overflowY: 'auto',\n          padding: '10px',\n          fontFamily: 'monospace',\n          whiteSpace: 'pre-wrap',\n          display: 'flex',\n          flexDirection: 'column-reverse' // Optional: Renders messages from bottom up\n        }}\n      >\n        {[...messages].reverse().map((msg, index) => (\n          <div key={index} style={{ marginBottom: '5px' }}>{msg}</div>\n        ))}\n      </div>\n    );\n  }\n}\n\n// Parent for testing\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            messages: [\n                \"Hello!\",\n                \"Welcome to the chat.\",\n                \"This is an initial message.\",\n                \"Scroll down to see more.\",\n                \"More messages will appear automatically.\",\n                \"This is message 6\", \"This is message 7\", \"This is message 8\", \"This is message 9\", \"This is message 10\", \"This is message 11\", \"This is message 12\", \"This is message 13\", \"This is message 14\", \"This is message 15\", \"This is message 16\", \"This is message 17\", \"This is message 18\", \"This is message 19\", \"This is message 20\", \"This is message 21\", \"This is message 22\", \"This is message 23\", \"This is message 24\", \"This is message 25\"\n            ]\n        };\n        this.addMessageManually = this.addMessageManually.bind(this);\n    }\n\n    componentDidMount() {\n        this.messageInterval = setInterval(() => {\n            this.setState(prevState => ({\n                messages: [...prevState.messages, `Auto message ${prevState.messages.length + 1}`]\n            }));\n        }, 1000); // Add a new message every second\n    }\n\n    componentWillUnmount() {\n        clearInterval(this.messageInterval);\n    }\n\n    addMessageManually() {\n        this.setState(prevState => ({\n            messages: [...prevState.messages, `Manual message ${prevState.messages.length + 1}`]\n        }));\n    }\n\n    render() {\n        return (\n            <div style={{ padding: '20px' }}>\n                <h2>Chat Application</h2>\n                <button onClick={this.addMessageManually} style={{ marginBottom: '10px', padding: '10px' }}>Add Manual Message</button>\n                <ChatMessageList messages={this.state.messages} />\n                <p style={{ marginTop: '10px', fontSize: '0.9em', color: '#666' }}>Scroll to the bottom, and new messages will keep you there. Scroll up, and new messages won't disrupt your view.</p>\n            </div>\n        );\n    }\n}\n\nexport default App;\n",
          "testCases": [
            "Initial load: The list should be scrolled to the bottom automatically (if messages fill the container).",
            "Auto-add messages: If the user is scrolled to the very bottom, new messages should appear, and the scroll position should remain at the new bottom.",
            "Auto-add messages (scrolled up): If the user scrolls up in the list, new messages should be added at the bottom, but the user's scroll position should NOT change.",
            "Manual message add: The behavior should be consistent whether messages are added automatically or via a button click.",
            "Console logs should verify when `getSnapshotBeforeUpdate` and `componentDidUpdate` are called, and whether a `snapshot` was used."
          ],
          "hints": [
            "Use `React.createRef()` in the constructor and attach it to the scrollable `div` to access its DOM properties.",
            "Relevant DOM properties for scrolling are `scrollHeight`, `clientHeight`, and `scrollTop`.",
            "The condition `list.scrollTop + list.clientHeight >= list.scrollHeight - [BUFFER]` is key to checking if the user is near the bottom.",
            "The `snapshot` value returned from `getSnapshotBeforeUpdate` is passed directly as the third argument to `componentDidUpdate`.",
            "To maintain scroll position when new content is added to the bottom, the `scrollTop` needs to be adjusted by the difference between the new and old `scrollHeight`."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Updating",
            "DOM Manipulation",
            "UX",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "react_refs",
            "theory_updating_phase"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "Refs",
            "DOM manipulation",
            "Scroll behavior"
          ]
        }
      ]
    }
  },
  {
    "id": "750bddfc-a945-4c8a-b673-ca40a0faeeea",
    "startLine": 4600,
    "endLine": 4699,
    "processedDate": "2025-06-17T09:13:47.032Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_update_lifecycle_overview",
          "title": "React Component Lifecycle: Updating Phase Overview",
          "content": "The updating phase of a React component's lifecycle begins when a component receives new props or state. This phase is crucial for ensuring that the UI reflects the latest data. The methods in this phase allow developers to react to changes, optimize performance, and manage side effects.\n\n### Triggers for Update Phase:\n- **New props**: Parent component re-renders and passes new props to the child.\n- **`setState()`**: The component's internal state changes via `this.setState()`.\n- **`forceUpdate()`**: Explicitly forces a re-render of the component.\n\nThe methods are called in a specific order, enabling a predictable flow of operations from prop/state changes to DOM updates and subsequent side effects.\n\n**Sequence of methods in the Updating Phase:**\n1.  `static getDerivedStateFromProps(props, state)`\n2.  `shouldComponentUpdate(nextProps, nextState)`\n3.  `render()`\n4.  `getSnapshotBeforeUpdate(prevProps, prevState)`\n5.  `componentDidUpdate(prevProps, prevState, snapshot)`",
          "examples": [
            {
              "id": "example_react_update_lifecycle_overview_1",
              "title": "Basic Component Update Flow",
              "code": "import React from 'react';\n\nclass UpdatingComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('1. Constructor (update)');\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    console.log('2. static getDerivedStateFromProps');\n    // Returning null means no state update from props\n    return null;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('3. shouldComponentUpdate');\n    // By default, returns true. For demonstration, let's always re-render.\n    return true;\n  }\n\n  render() {\n    console.log('4. render (update)');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Increment</button>\n      </div>\n    );\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('5. getSnapshotBeforeUpdate');\n    // This method returns a snapshot that will be passed to componentDidUpdate\n    return { prevCount: prevState.count };\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('6. componentDidUpdate');\n    console.log('Snapshot from getSnapshotBeforeUpdate:', snapshot);\n    if (this.state.count !== prevState.count) {\n      console.log(`Count changed from ${prevState.count} to ${this.state.count}`);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('7. componentWillUnmount');\n  }\n}\n\n// To see update in action, you'd render this component and interact with its button\n// or update its props from a parent component.\n\n/*\nExpected console output when button is clicked:\n2. static getDerivedStateFromProps\n3. shouldComponentUpdate\n4. render (update)\n5. getSnapshotBeforeUpdate\n6. componentDidUpdate\nCount changed from X to Y\n*/\n",
              "explanation": "This example demonstrates the typical flow of methods during the update phase when the component's state changes. Console logs illustrate the order of execution. Note that the constructor is only called during the initial mount, not subsequent updates.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_update_lifecycle_order_mcq",
            "question_update_triggers_open",
            "question_lifecycle_phases_flashcard"
          ],
          "relatedTasks": [
            "task_implement_update_lifecycle_logger"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Updating Phase",
            "Component",
            "Class Component"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "class_components",
            "state_props"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_optimization",
            "side_effects_management",
            "dom_manipulation"
          ]
        },
        {
          "id": "theory_static_get_derived_state_from_props",
          "title": "static getDerivedStateFromProps(props, state)",
          "content": "The `static getDerivedStateFromProps` method is part of React's render phase lifecycle methods, meaning it's called during render and should be pure with no side effects. It is invoked right before calling the `render` method, both on the initial mount and on subsequent updates.\n\n### Purpose:\nIts primary purpose is to allow a component to update its internal state based on changes in props. This is a rare use case, typically when the state needs to be a direct derivation of props over time.\n\n### Signature and Behavior:\n- **`props`**: The new props the component received.\n- **`state`**: The current state of the component.\n- It must be a `static` method, so it does not have access to `this`.\n- It returns an object to update the state, or `null` to indicate that nothing needs to be updated.\n\n### Important Considerations:\n- **Pure Function**: This method must be a pure function. It should not cause any side effects (e.g., network requests, DOM manipulation, `setState` calls).\n- **Infrequent Use**: This method is generally discouraged for common patterns. Most cases where you think you need `getDerivedStateFromProps` can be handled by `componentDidUpdate` (for side effects) or by making the component fully controlled (i.e., not managing its own state internally).\n- **Unconditional Calls**: It's called on *every* render, regardless of whether props have actually changed. This means it must carefully compare `props` and `state` to avoid unnecessary state updates if the derivation is conditional.\n\n### Anti-patterns:\n- Copying props to state for every render when `props` haven't changed leads to redundant state updates.\n- Using it for side effects; `componentDidUpdate` is the correct place for side effects based on prop/state changes.",
          "examples": [
            {
              "id": "example_get_derived_state_from_props_1",
              "title": "Updating State from Props (Controlled Input)",
              "code": "import React from 'react';\n\nclass ControlledInput extends React.Component {\n  state = {\n    internalValue: this.props.value || ''\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // Only update internalValue if the external prop 'value' has changed\n    if (nextProps.value !== prevState.internalValue) {\n      return {\n        internalValue: nextProps.value\n      };\n    }\n    // No state update needed\n    return null;\n  }\n\n  handleChange = (event) => {\n    this.setState({ internalValue: event.target.value });\n  };\n\n  render() {\n    return (\n      <input\n        type=\"text\"\n        value={this.state.internalValue}\n        onChange={this.handleChange}\n      />\n    );\n  }\n}\n\n// Usage:\n// <ControlledInput value=\"Hello\" />\n// The internal state `internalValue` will always reflect the `value` prop unless the user types in it.\n// If parent changes `value` prop, internal state will update accordingly.\n",
              "explanation": "This example shows a scenario where `getDerivedStateFromProps` is used to keep an internal state (`internalValue`) synchronized with a prop (`value`). This is typical for components like a controlled input field where the parent can dictate its value, but the component also manages its own input changes. The conditional check `nextProps.value !== prevState.internalValue` is crucial to prevent infinite loops or unnecessary updates.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_gdsfp_purpose_mcq",
            "question_gdsfp_conditions_open",
            "question_gdsfp_pure_function_flashcard",
            "question_gdsfp_incorrect_use_code"
          ],
          "relatedTasks": [
            "task_implement_gdsfp_prop_sync"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "static",
            "State",
            "Props",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "derived_state",
            "controlled_components"
          ]
        },
        {
          "id": "theory_should_component_update",
          "title": "shouldComponentUpdate(nextProps, nextState)",
          "content": "The `shouldComponentUpdate` method is a performance optimization hook. It's called before `render` when new props or state are received. By default, it returns `true`, meaning the component will re-render. If it returns `false`, React skips calling `render()`, `getSnapshotBeforeUpdate()`, and `componentDidUpdate()` for that update cycle.\n\n### Purpose:\n- **Performance Optimization**: Prevents unnecessary re-renders of a component and its children, which can be critical for complex UIs or large component trees.\n\n### Signature and Behavior:\n- **`nextProps`**: The next props the component will receive.\n- **`nextState`**: The next state the component will have.\n- Returns a `boolean`: `true` to allow re-render, `false` to prevent it.\n\n### Important Considerations:\n- **Not for Initial Render**: This method is not called for the initial render.\n- **`forceUpdate()` bypasses**: It is not called when `forceUpdate()` is used.\n- **PureComponent**: `React.PureComponent` implements `shouldComponentUpdate` with a shallow comparison of props and state. This makes `PureComponent` a convenient way to achieve basic performance optimization without manually implementing `shouldComponentUpdate`.\n- **Caveats**: Implementing `shouldComponentUpdate` manually requires careful consideration. A subtle bug (e.g., incorrect comparison) can lead to parts of the UI not updating when they should, causing inconsistencies. It's generally safer to rely on `PureComponent` or `React.memo` (for functional components) unless you have a deep understanding of the component's data flow and performance bottlenecks.\n- **No Side Effects**: This method should be pure and contain only a comparison logic. Do not perform side effects here.",
          "examples": [
            {
              "id": "example_should_component_update_1",
              "title": "Preventing Unnecessary Renders",
              "code": "import React from 'react';\n\nclass OptimizedList extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'items' prop has actually changed its length,\n    // or if the reference to the array has changed AND its contents are different.\n    // A deeper comparison might be needed for complex objects.\n    if (nextProps.items.length !== this.props.items.length) {\n      return true; // Length changed, definitely re-render\n    }\n    // If lengths are same, check if specific items changed (shallow check)\n    for (let i = 0; i < nextProps.items.length; i++) {\n      if (nextProps.items[i] !== this.props.items[i]) {\n        return true; // An item changed, re-render\n      }\n    }\n    return false; // No relevant change, don't re-render\n  }\n\n  render() {\n    console.log('OptimizedList rendered');\n    return (\n      <ul>\n        {this.props.items.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    );\n  }\n}\n\n// Usage example:\n/*\nclass ParentComponent extends React.Component {\n  state = { data: ['A', 'B'] };\n\n  componentDidMount() {\n    // This will trigger a re-render but OptimizedList won't update\n    // because the data array reference changed but its content is same.\n    setTimeout(() => this.setState({ data: ['A', 'B'] }), 1000);\n\n    // This will trigger a re-render and OptimizedList WILL update\n    // because the content changes.\n    setTimeout(() => this.setState({ data: ['A', 'B', 'C'] }), 2000);\n  }\n\n  render() {\n    return <OptimizedList items={this.state.data} />;\n  }\n}\n*/\n",
              "explanation": "This `shouldComponentUpdate` implementation prevents the `OptimizedList` from re-rendering if its `items` prop array has the same length and its elements are shallowly equal. This can be effective for lists where the data might be frequently passed down, but the actual content doesn't always change, thus avoiding costly DOM updates.",
              "language": "typescript"
            },
            {
              "id": "example_pure_component_optimization",
              "title": "PureComponent vs. shouldComponentUpdate",
              "code": "import React, { PureComponent } from 'react';\n\n// Using PureComponent for shallow comparison\nclass MyPureComponent extends PureComponent {\n  render() {\n    console.log('MyPureComponent rendered');\n    return <div>Value: {this.props.value}</div>;\n  }\n}\n\n// Equivalent using shouldComponentUpdate (simplified)\nclass MyRegularComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Manual shallow comparison\n    if (nextProps.value !== this.props.value || nextState.someProp !== this.state.someProp) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    console.log('MyRegularComponent rendered');\n    return <div>Value: {this.props.value}</div>;\n  }\n}\n\n/*\nIn most cases, MyPureComponent is preferred for simplicity if a shallow comparison is sufficient.\n*/\n",
              "explanation": "`PureComponent` (or `React.memo` for functional components) offers a built-in optimization by performing a shallow comparison of props and state. This example illustrates how `PureComponent` achieves similar behavior to manually implementing `shouldComponentUpdate` for simple cases, reducing boilerplate and potential errors.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_should_component_update_purpose_mcq",
            "question_pure_component_scu_open",
            "question_scu_drawbacks_flashcard",
            "question_scu_implement_performance_code"
          ],
          "relatedTasks": [
            "task_optimize_component_with_scu"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Performance",
            "Optimization",
            "shouldComponentUpdate",
            "PureComponent"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_tuning",
            "complex_ui_optimization"
          ]
        },
        {
          "id": "theory_render_update_phase",
          "title": "render() in Updating Phase",
          "content": "The `render()` method functions the same way in the updating phase as it does in the mounting phase. It's a pure function that returns the React elements to be rendered to the DOM.\n\n### When is it called?\n- It is called if `shouldComponentUpdate` returns `true` (or by default, if `shouldComponentUpdate` is not implemented or returns `true`).\n- It's also called when `forceUpdate()` is invoked, bypassing `shouldComponentUpdate`.\n\n### Important Considerations:\n- **Pure Function**: `render()` should remain a pure function. It should not modify component state, perform side effects (like network requests or DOM manipulations), or interact with the browser directly. Any such operations belong in `componentDidUpdate` or other lifecycle methods.\n- **Returns**: It returns a React element (JSX), `null`, `false`, or an array/fragment of elements.\n- **Read-only**: `this.props` and `this.state` are read-only within `render()`.",
          "examples": [
            {
              "id": "example_render_update_1",
              "title": "Render Method Example",
              "code": "import React from 'react';\n\nclass DisplayMessage extends React.Component {\n  state = { message: 'Initial Message' };\n\n  componentDidMount() {\n    // Simulate a state update after 2 seconds\n    setTimeout(() => {\n      this.setState({ message: 'Updated Message after 2s' });\n    }, 2000);\n  }\n\n  render() {\n    console.log('render method called with message:', this.state.message);\n    return (\n      <div>\n        <h1>{this.state.message}</h1>\n        <p>Current Prop Value: {this.props.title}</p>\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <DisplayMessage title=\"My App\" />\n",
              "explanation": "This example shows the `render` method simply displaying content based on `this.state` and `this.props`. When `setState` is called in `componentDidMount`, the component will update, `render` will be called again, and the displayed message will change. The `render` method itself does not perform any side effects.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_render_purity_mcq",
            "question_render_side_effects_open"
          ],
          "relatedTasks": [],
          "tags": [
            "React",
            "Lifecycle",
            "Render",
            "Pure Function"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "class_components"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "component_rendering"
          ]
        },
        {
          "id": "theory_get_snapshot_before_update",
          "title": "getSnapshotBeforeUpdate(prevProps, prevState)",
          "content": "The `getSnapshotBeforeUpdate` method is invoked right before the most recently rendered output is committed to the DOM. It's a method that enables components to capture some information from the DOM (e.g., scroll position, element dimensions) *before* the DOM is potentially changed.\n\n### Purpose:\n- **Capture Pre-Update DOM State**: Allows you to read layout information from the DOM, such as scroll position or element size, just before React is about to make changes to the DOM. This information can then be passed to `componentDidUpdate` to perform necessary adjustments *after* the DOM has been updated.\n\n### Signature and Behavior:\n- **`prevProps`**: The props before the current update.\n- **`prevState`**: The state before the current update.\n- It must return a `snapshot` value (any type, or `null` if nothing to pass). This `snapshot` value will be passed as the third argument to `componentDidUpdate`.\n\n### Important Considerations:\n- **Rare Use Case**: This method is rarely needed. It's specifically for scenarios where you need to preserve some ephemeral UI state (like scroll position) that might be lost during a DOM update.\n- **Replaces `componentWillUpdate`**: It replaces the deprecated `componentWillUpdate` method, which was problematic because it was called *before* the render method, and changes made there might not reflect in the snapshot accurately.\n- **Side Effects**: Like `render`, `getSnapshotBeforeUpdate` should not cause side effects. Its purpose is to read from the DOM, not to modify it.",
          "examples": [
            {
              "id": "example_get_snapshot_before_update_1",
              "title": "Preserving Scroll Position",
              "code": "import React from 'react';\n\nclass ScrollableList extends React.Component {\n  listRef = React.createRef();\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Are we adding new items to the top of the list?\n    // If so, we need to adjust scroll position.\n    if (prevProps.list.length < this.props.list.length && this.props.scrollFromTop) {\n      const list = this.listRef.current;\n      // Capture scrollHeight and scrollTop before DOM update\n      return list.scrollHeight - list.scrollTop;\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      // Adjust scroll position after DOM update\n      list.scrollTop = list.scrollHeight - snapshot;\n    }\n  }\n\n  render() {\n    return (\n      <div ref={this.listRef} style={{ height: '200px', overflowY: 'scroll', border: '1px solid black' }}>\n        {this.props.list.map((item, index) => (\n          <div key={index} style={{ padding: '5px', borderBottom: '1px dashed #ccc' }}>{item}</div>\n        ))}\n      </div>\n    );\n  }\n}\n\n// Parent component to demonstrate:\n/*\nclass App extends React.Component {\n  state = { items: Array.from({ length: 20 }, (_, i) => `Item ${i + 1}`) };\n\n  addItemsToTop = () => {\n    this.setState(prevState => ({\n      items: Array.from({ length: 5 }, (_, i) => `New Item ${i + 1}`).concat(prevState.items)\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.addItemsToTop}>Add Items to Top</button>\n        <ScrollableList list={this.state.items} scrollFromTop={true} />\n      </div>\n    );\n  }\n}\n*/\n",
              "explanation": "This example demonstrates how to use `getSnapshotBeforeUpdate` to maintain scroll position when new items are added to the top of a list. Before the DOM updates, `getSnapshotBeforeUpdate` captures the difference between the current scroll height and scroll top. This 'snapshot' is then used in `componentDidUpdate` to adjust the `scrollTop` so the user's view remains stable despite new content appearing above.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_gsbu_purpose_mcq",
            "question_gsbu_return_value_flashcard",
            "question_gsbu_vs_cwupdate_open",
            "question_gsbu_dom_interaction_code"
          ],
          "relatedTasks": [
            "task_preserve_scroll_position"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "DOM",
            "Snapshot",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "refs",
            "dom_manipulation_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_ui_interactions",
            "legacy_react_understanding"
          ]
        },
        {
          "id": "theory_component_did_update",
          "title": "componentDidUpdate(prevProps, prevState, snapshot)",
          "content": "The `componentDidUpdate` method is called immediately after updating. This method is not called for the initial render. It's a crucial place for performing side effects after a component has re-rendered and the DOM has been updated.\n\n### Purpose:\n- **Side Effects**: Ideal for performing side effects such as network requests, DOM manipulation, or interacting with third-party libraries based on changes in props or state.\n- **Conditional `setState`**: You can call `setState()` here, but it **must** be wrapped in a conditional statement (e.g., comparing `prevProps` with `this.props`) to prevent an infinite loop. Calling `setState` unconditionally would trigger another update, which calls `componentDidUpdate` again, leading to a loop.\n- **Using Snapshot**: Receives the `snapshot` value returned by `getSnapshotBeforeUpdate`, allowing you to use pre-update DOM information after the update has completed.\n\n### Signature and Behavior:\n- **`prevProps`**: The props before the current update.\n- **`prevState`**: The state before the current update.\n- **`snapshot`**: The value returned by `getSnapshotBeforeUpdate` (if implemented), otherwise `undefined`.\n\n### Important Considerations:\n- **Compare Props/State**: Always compare `prevProps` and `prevState` with `this.props` and `this.state` to ensure that side effects are only performed when necessary, preventing redundant operations and potential infinite loops when calling `setState`.\n- **DOM Operations**: This is the earliest point where you can reliably interact with the updated DOM, as `render` has completed and the DOM has been patched.",
          "examples": [
            {
              "id": "example_component_did_update_1",
              "title": "Fetching Data on Prop Change",
              "code": "import React from 'react';\n\nclass UserProfile extends React.Component {\n  state = {\n    userData: null,\n    loading: true,\n    error: null,\n  };\n\n  componentDidMount() {\n    // Initial data fetch on mount\n    this.fetchData(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Only re-fetch data if userId prop has changed\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchData(this.props.userId);\n    }\n  }\n\n  fetchData = async (userId) => {\n    this.setState({ loading: true, error: null });\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ userData: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching user data:', error);\n      this.setState({ error: error.message, loading: false });\n    }\n  };\n\n  render() {\n    const { userData, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n    if (error) {\n      return <div>Error: {error}</div>;\n    }\n    if (!userData) {\n      return <div>No user data available.</div>;\n    }\n\n    return (\n      <div>\n        <h2>{userData.name}</h2>\n        <p>Email: {userData.email}</p>\n        <p>ID: {userData.id}</p>\n      </div>\n    );\n  }\n}\n\n// Usage (e.g., in a parent component):\n// <UserProfile userId={1} />\n// <UserProfile userId={2} /> // This prop change will trigger a new fetch\n",
              "explanation": "This `UserProfile` component fetches user data. `componentDidMount` handles the initial fetch. `componentDidUpdate` then listens for changes in `userId` prop and re-fetches data only when it changes, preventing redundant API calls and potential infinite loops. It also includes basic loading and error handling.",
              "language": "typescript"
            },
            {
              "id": "example_component_did_update_2",
              "title": "Conditional setState to avoid infinite loop",
              "code": "import React from 'react';\n\nclass CounterDisplay extends React.Component {\n  state = { \n    count: 0,\n    message: '' \n  };\n\n  componentDidUpdate(prevProps, prevState) {\n    // Condition 1: Update message if count crosses 10\n    if (this.state.count > 10 && prevState.count <= 10) {\n      this.setState({ message: 'Count exceeded 10!' });\n    }\n\n    // Condition 2: Reset count if prop 'resetTrigger' changes\n    if (this.props.resetTrigger !== prevProps.resetTrigger && this.props.resetTrigger) {\n      // This setState will trigger another update, but the condition ensures\n      // it only happens once per resetTrigger change, avoiding infinite loop.\n      this.setState({ count: 0, message: 'Count reset!' });\n    }\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.message}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <CounterDisplay resetTrigger={false} />\n// <CounterDisplay resetTrigger={true} /> // will reset count\n",
              "explanation": "This example shows how `setState` can be safely used within `componentDidUpdate`. The first `setState` updates `message` only when `count` crosses 10. The second `setState` resets the `count` and `message` if `this.props.resetTrigger` changes to `true`. Both are guarded by conditions comparing current and previous states/props to prevent uncontrolled re-renders and infinite loops.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_cdu_purpose_mcq",
            "question_cdu_infinite_loop_open",
            "question_cdu_snapshot_flashcard",
            "question_cdu_data_fetch_code"
          ],
          "relatedTasks": [
            "task_fetch_data_on_prop_change",
            "task_implement_conditional_state_update"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Side Effects",
            "API Calls",
            "DOM Manipulation",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "state_props",
            "async_js"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_fetching",
            "complex_interactivity",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_react_unmount_lifecycle_overview",
          "title": "React Component Lifecycle: Unmounting Phase Overview",
          "content": "The unmounting phase is the final stage of a React component's lifecycle. It occurs when a component is being removed from the DOM, either because it's no longer needed, its parent unmounted, or its `render` method no longer includes it.\n\n### Purpose:\n- **Cleanup**: The primary purpose of this phase is to perform any necessary cleanup before the component is destroyed. This prevents memory leaks and ensures that resources are properly released.\n\n### Method in Unmounting Phase:\n1.  `componentWillUnmount()`",
          "examples": [
            {
              "id": "example_react_unmount_lifecycle_overview_1",
              "title": "Simulating Unmounting",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\n\nclass DisposableComponent extends React.Component {\n  componentWillUnmount() {\n    console.log('DisposableComponent: componentWillUnmount called!');\n  }\n\n  render() {\n    return <div>I am a component that will be unmounted.</div>;\n  }\n}\n\nclass App extends React.Component {\n  state = { showComponent: true };\n\n  toggleComponent = () => {\n    this.setState(prevState => ({ showComponent: !prevState.showComponent }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.toggleComponent}>\n          {this.state.showComponent ? 'Unmount Component' : 'Mount Component'}\n        </button>\n        {this.state.showComponent && <DisposableComponent />}\n      </div>\n    );\n  }\n}\n\n// To see this in action:\n// ReactDOM.render(<App />, document.getElementById('root'));\n// Click the 'Unmount Component' button and observe the console log.\n",
              "explanation": "This example demonstrates how a component (`DisposableComponent`) is unmounted from the DOM. When the `toggleComponent` button is clicked and `showComponent` becomes `false`, `DisposableComponent` is no longer rendered. At this point, its `componentWillUnmount` method is called, which logs a message to the console, signifying the cleanup phase.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_unmount_phase_purpose_mcq",
            "question_unmount_trigger_open"
          ],
          "relatedTasks": [],
          "tags": [
            "React",
            "Lifecycle",
            "Unmounting Phase",
            "Cleanup"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "class_components"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "resource_management"
          ]
        },
        {
          "id": "theory_component_will_unmount",
          "title": "componentWillUnmount()",
          "content": "The `componentWillUnmount` method is invoked immediately before a component is unmounted and destroyed from the DOM. It's the ideal and last opportunity to perform any necessary cleanup for the component.\n\n### Purpose:\n- **Cleanup**: This is the designated place to tear down or clean up any resources that were set up in `componentDidMount` (or other lifecycle methods) to prevent memory leaks and ensure proper resource management.\n\n### Common Cleanup Tasks:\n- **Canceling network requests**: Prevents `setState` on an unmounted component, which would cause a warning or error.\n- **Invalidating timers**: Clear `setTimeout` and `setInterval` calls.\n- **Removing event listeners**: Unsubscribe from `window`, `document`, or other non-React DOM elements' events.\n- **Cleaning up subscriptions**: Unsubscribe from global event buses or Redux store subscriptions.\n- **Destroying non-React DOM elements**: If you manually created any DOM nodes outside of React's control, destroy them here.\n\n### Important Considerations:\n- **No `setState()`**: You should **NOT** call `setState()` in `componentWillUnmount()` because the component is about to be unmounted and will never re-render. Calling `setState` here is pointless and can lead to warnings or errors in development mode.\n- **Final Opportunity**: After `componentWillUnmount` executes, the component instance is destroyed and will not be remounted.\n- **Memory Leaks**: Failure to perform proper cleanup (e.g., leaving event listeners or timers active) can lead to memory leaks, where resources are consumed by components that are no longer part of the active application.",
          "examples": [
            {
              "id": "example_component_will_unmount_1",
              "title": "Cleaning Up Timers and Event Listeners",
              "code": "import React from 'react';\n\nclass TimerAndResizeTracker extends React.Component {\n  state = { \n    seconds: 0,\n    windowWidth: window.innerWidth\n  };\n  timerId = null;\n\n  componentDidMount() {\n    // Set up a timer\n    this.timerId = setInterval(() => {\n      this.setState(prevState => ({ seconds: prevState.seconds + 1 }));\n    }, 1000);\n\n    // Add a resize event listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount: Cleaning up resources');\n    // Clean up the timer\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log('Timer cleared.');\n    }\n    // Remove the event listener\n    window.removeEventListener('resize', this.handleResize);\n    console.log('Resize event listener removed.');\n  }\n\n  handleResize = () => {\n    this.setState({ windowWidth: window.innerWidth });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Seconds: {this.state.seconds}</p>\n        <p>Window Width: {this.state.windowWidth}px</p>\n        <p>Resize your browser window or wait for timer.</p>\n      </div>\n    );\n  }\n}\n\n/*\nTo test:\n1. Render <TimerAndResizeTracker />\n2. Open console and observe seconds updating.\n3. Resize window and observe width updating.\n4. Unmount the component (e.g., using a parent toggle as in the previous example).\n5. Observe the 'Cleaning up resources' logs and confirm timer/listener are stopped.\n*/\n",
              "explanation": "This example shows a component that sets up a `setInterval` timer and a `window.resize` event listener in `componentDidMount`. Crucially, `componentWillUnmount` is used to call `clearInterval` and `removeEventListener`. This ensures that when the component is removed from the DOM, these background processes are stopped, preventing memory leaks and errors (e.g., trying to `setState` on an unmounted component).",
              "language": "typescript"
            },
            {
              "id": "example_component_will_unmount_2",
              "title": "Canceling Network Request (Example)",
              "code": "import React from 'react';\n\n// This is a simplified example. In a real app, you'd use AbortController or a library.\nconst cancellableFetch = (url, options) => {\n  let controller = new AbortController();\n  let signal = controller.signal;\n\n  const promise = fetch(url, { ...options, signal });\n\n  return {\n    promise: promise,\n    cancel: () => controller.abort() // Abort the fetch request\n  };\n};\n\nclass DataFetcher extends React.Component {\n  state = { data: null, loading: true, error: null };\n  fetchRequest = null;\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    // If a fetch request is pending, cancel it to avoid setting state on unmounted component\n    if (this.fetchRequest) {\n      this.fetchRequest.cancel();\n      console.log('Network request cancelled in componentWillUnmount.');\n    }\n  }\n\n  fetchData = async () => {\n    this.setState({ loading: true, error: null });\n    try {\n      this.fetchRequest = cancellableFetch('https://api.example.com/data');\n      const response = await this.fetchRequest.promise;\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ data, loading: false });\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        console.log('Fetch aborted.');\n      } else {\n        console.error('Fetch error:', error);\n        this.setState({ error: error.message, loading: false });\n      }\n    }\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading...</div>;\n    if (this.state.error) return <div>Error: {this.state.error}</div>;\n    return <div>Data: {JSON.stringify(this.state.data)}</div>;\n  }\n}\n\n/*\nTo test:\n1. Mount <DataFetcher />\n2. Immediately unmount it before the fetch completes (e.g., via a parent toggle).\n3. Observe 'Network request cancelled' log, preventing 'setState on unmounted component' warning.\n*/\n",
              "explanation": "This example illustrates how to cancel a pending network request using `componentWillUnmount`. By leveraging an `AbortController` (or similar mechanism), the `fetchRequest` initiated in `componentDidMount` can be aborted if the component is unmounted before the request completes. This prevents common React warnings about trying to `setState` on an unmounted component, which can happen if the async operation resolves after the component is gone.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_cwunmount_purpose_mcq",
            "question_cwunmount_no_setstate_open",
            "question_cwunmount_memory_leaks_flashcard",
            "question_cwunmount_cleanup_code"
          ],
          "relatedTasks": [
            "task_implement_cleanup_in_cwu"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Cleanup",
            "Memory Leaks",
            "Event Listeners",
            "Timers",
            "Network Requests"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "async_js",
            "event_handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "resource_management",
            "bug_prevention",
            "performance_tuning"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_update_lifecycle_order_mcq",
          "topic": "React Updating Phase",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following represents the correct order of lifecycle methods called during the React component's updating phase?",
          "answer": "static getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate",
          "options": [
            "componentDidUpdate, render, shouldComponentUpdate, static getDerivedStateFromProps, getSnapshotBeforeUpdate",
            "static getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate",
            "render, static getDerivedStateFromProps, componentDidUpdate, shouldComponentUpdate, getSnapshotBeforeUpdate",
            "shouldComponentUpdate, render, componentDidUpdate, static getDerivedStateFromProps, getSnapshotBeforeUpdate"
          ],
          "analysisPoints": [
            "Tests knowledge of the precise order of execution for React's updating lifecycle methods.",
            "Differentiates between methods called before render (getDerivedStateFromProps, shouldComponentUpdate) and after render (getSnapshotBeforeUpdate, componentDidUpdate).",
            "Confirms understanding that `static getDerivedStateFromProps` is the first method called in the update cycle (after new props/state trigger).",
            "Highlights the position of `getSnapshotBeforeUpdate` immediately before DOM commit and its relationship with `componentDidUpdate`."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Updating Phase",
            "Method Order",
            "getDerivedStateFromProps",
            "shouldComponentUpdate",
            "render",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate"
          ],
          "evaluationCriteria": [
            "Accurate recall of lifecycle method sequence.",
            "Ability to distinguish between render-phase and commit-phase methods."
          ],
          "example": "The update lifecycle methods follow a strict sequence to ensure proper state derivation, rendering optimization, UI updates, and side effect management.",
          "tags": [
            "React",
            "Lifecycle",
            "Updating Phase",
            "Order"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_update_triggers_open",
          "topic": "React Updating Phase Triggers",
          "level": "medium",
          "type": "open",
          "question": "What are the primary triggers that initiate the 'updating' phase of a React class component's lifecycle? Explain how each trigger leads to an update.",
          "answer": "The primary triggers that initiate the updating phase of a React class component's lifecycle are:\n\n1.  **New props from parent:** When a parent component re-renders and passes new props to its child component, the child component will undergo an update cycle. React's reconciliation process will compare the new props with the existing ones, and if differences are found (or if `shouldComponentUpdate` allows), the child will update.\n\n2.  **`this.setState()` calls:** When `this.setState()` is called within a component (or any of its children, which then causes the parent to re-render), React schedules an update for that component. This method is the primary way for a component's internal state to change, leading to a re-render to reflect the new state.\n\n3.  **`this.forceUpdate()` calls:** This method explicitly forces a component to re-render, bypassing `shouldComponentUpdate()`. While generally discouraged due to its potential to hide performance issues, it can be used in rare cases where the component's state or props haven't nominally changed but its output needs to update (e.g., when deeply nested mutable data changes without a state or prop reference change).",
          "analysisPoints": [
            "Tests comprehensive understanding of the events that cause a React component to re-render.",
            "Assesses ability to articulate the mechanism behind each trigger.",
            "Evaluates awareness of `forceUpdate` as an explicit, less common trigger."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Updating Phase",
            "Props",
            "State",
            "setState",
            "forceUpdate",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Completeness of triggers listed.",
            "Accuracy of explanation for each trigger.",
            "Clarity and conciseness of response."
          ],
          "example": "Understanding these triggers is fundamental to predicting component behavior and debugging rendering issues.",
          "tags": [
            "React",
            "Lifecycle",
            "Updating Phase",
            "Props",
            "State",
            "forceUpdate"
          ],
          "prerequisites": [
            "react_basics",
            "state_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_phases_flashcard",
          "topic": "React Lifecycle Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the three main phases of a React class component's lifecycle?",
          "answer": "Mounting, Updating, and Unmounting.",
          "analysisPoints": [
            "Tests basic recall of React component lifecycle phases."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Mounting Phase",
            "Updating Phase",
            "Unmounting Phase"
          ],
          "evaluationCriteria": [
            "Correct identification of all three phases."
          ],
          "example": "Knowing these phases helps understand when different lifecycle methods are called.",
          "tags": [
            "React",
            "Lifecycle",
            "Phases"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_gdsfp_purpose_mcq",
          "topic": "static getDerivedStateFromProps",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of `static getDerivedStateFromProps(props, state)`?",
          "answer": "To update the component's internal state based on changes in props, immediately before rendering.",
          "options": [
            "To perform side effects like data fetching after props change.",
            "To update the component's internal state based on changes in props, immediately before rendering.",
            "To prevent unnecessary re-renders of the component.",
            "To capture DOM information before the component updates the DOM."
          ],
          "analysisPoints": [
            "Distinguishes `getDerivedStateFromProps` from other lifecycle methods like `componentDidUpdate` (side effects), `shouldComponentUpdate` (optimization), and `getSnapshotBeforeUpdate` (DOM snapshot).",
            "Emphasizes its role in state derivation from props.",
            "Highlights its execution during the render phase."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Derived State",
            "Props to State",
            "Pure Function"
          ],
          "evaluationCriteria": [
            "Correct identification of method's specific purpose.",
            "Understanding of its timing in the lifecycle."
          ],
          "example": "```typescript\nclass MyComponent extends React.Component {\n  state = { count: 0 };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // If the 'maxCount' prop changes, reset the internal count\n    if (nextProps.maxCount !== prevState.derivedMaxCount) {\n      return {\n        count: 0,\n        derivedMaxCount: nextProps.maxCount\n      };\n    }\n    return null;\n  }\n\n  render() {\n    return <p>Count: {this.state.count}, Max: {this.props.maxCount}</p>;\n  }\n}\n```\nThis example shows `getDerivedStateFromProps` being used to reset the internal `count` state when the `maxCount` prop changes.",
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "State",
            "Props"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gdsfp_conditions_open",
          "topic": "static getDerivedStateFromProps Usage",
          "level": "hard",
          "type": "open",
          "question": "Explain the concept of 'derived state' and when `static getDerivedStateFromProps` is an appropriate (though rare) tool to manage it. What are its critical constraints and why should it be used with caution?",
          "answer": "Derived state refers to a component's internal state that is computed or synchronized based on its props. `static getDerivedStateFromProps` is a lifecycle method that allows a component to update its state based on prop changes just before every render. It's an appropriate tool when:\n\n*   **The state truly needs to be a direct 'derivation' of props:** For example, an `AlertDialog` component that needs to manage an `isOpen` state, but also needs to `reset` internal form data whenever the `dialogId` prop changes.\n*   **You need to 'reset' internal state when props change:** If a prop effectively changes the 'identity' of the data the component is displaying (e.g., `userId` prop changes on a profile component), you might derive a new loading state or clear previous data.\n\n**Critical Constraints:**\n\n1.  **Static Method, No `this`:** It's a static method, meaning it does not have access to `this` (the component instance). This prevents accessing instance properties, methods, or directly triggering side effects.\n2.  **Pure Function:** It must be a pure function. It should only compute state based on `props` and `state`, and return an object or `null`. It must not cause any side effects (e.g., network requests, DOM mutations, calling `setState` inside it).\n3.  **Called on Every Render:** It is called on *every* render, regardless of whether props have actually changed. This means any logic inside it needs to be carefully conditionalized to prevent redundant or incorrect state updates. Without proper `if (nextProps.someProp !== prevState.someDerivedProp)` checks, you can create performance issues or bugs.\n\n**Why use with caution?**\n\n*   **Complexity:** It adds complexity and can make it harder to trace state flow, especially if the derived state logic is not trivial.\n*   **Potential for Bugs:** Incorrect implementation (e.g., not properly checking for changes, introducing side effects) can lead to infinite loops, inconsistent UI, or performance degradation.\n*   **Alternatives Often Better:** Most use cases can often be handled more cleanly with:\n    *   **`componentDidUpdate`**: For side effects triggered by prop/state changes.\n    *   **Fully Controlled Components**: Where the parent component fully manages the state and passes it down as props, making the child purely presentational.\n    *   **Memoization**: For expensive computations based on props, perform them directly in `render` using memoization libraries like `reselect` or `useMemo` hooks (for functional components).",
          "analysisPoints": [
            "Defines derived state accurately.",
            "Identifies valid (though rare) use cases for `getDerivedStateFromProps`.",
            "Articulates the strict constraints (static, pure, called on every render).",
            "Explains the pitfalls and why caution is advised.",
            "Suggests alternative patterns for common scenarios."
          ],
          "keyConcepts": [
            "Derived State",
            "getDerivedStateFromProps",
            "Pure Function",
            "Side Effects",
            "Performance",
            "Controlled Components",
            "componentDidUpdate"
          ],
          "evaluationCriteria": [
            "Depth of explanation for 'derived state'.",
            "Thoroughness of constraints and caveats.",
            "Clarity on when to use vs. avoid.",
            "Ability to propose alternative solutions."
          ],
          "example": "Misusing `getDerivedStateFromProps` can lead to complex state management that is difficult to debug and maintain.",
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "Derived State",
            "Best Practices",
            "Anti-patterns"
          ],
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_gdsfp_pure_function_flashcard",
          "topic": "static getDerivedStateFromProps",
          "level": "medium",
          "type": "flashcard",
          "question": "Why must `static getDerivedStateFromProps` be a pure function, and what does this imply about its behavior?",
          "answer": "It must be a pure function because it runs during the 'render' phase of React's lifecycle. This implies it should only compute state based on inputs (props and state) and return an object or null, without causing any side effects (e.g., network requests, DOM manipulation, or calls to `setState`).",
          "analysisPoints": [
            "Tests understanding of the 'pure function' concept in the context of React lifecycle.",
            "Connects purity to the render phase.",
            "Identifies what actions are forbidden within this method due to its pure nature."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Pure Function",
            "Render Phase",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Correctly defines purity in this context.",
            "Lists examples of forbidden side effects."
          ],
          "example": "If `getDerivedStateFromProps` were not pure, it could introduce unpredictable behavior or break React's rendering optimizations.",
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "Pure Function",
            "Side Effects"
          ],
          "prerequisites": [
            "react_basics",
            "pure_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gdsfp_incorrect_use_code",
          "topic": "static getDerivedStateFromProps Misuse",
          "level": "hard",
          "type": "code",
          "question": "Consider the following component intended to fetch user data when the `userId` prop changes. Identify the incorrect use of `static getDerivedStateFromProps` and explain why it's problematic. Rewrite the component using the correct lifecycle method for this use case.",
          "answer": "The incorrect usage is attempting to perform a side effect (data fetching) directly within `static getDerivedStateFromProps`. This method is designed to be pure and should only return state updates or `null`; it has no access to `this` (instance methods like `fetchUserData`) and should not perform async operations or DOM manipulations.\n\n**Problematic Code:**\n```typescript\nimport React from 'react';\n\nclass UserProfileProblem extends React.Component {\n  state = { userData: null, loading: false };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (nextProps.userId !== prevState.currentUserId) {\n      // PROBLEMATIC: Attempting side effect (data fetch) in a pure, static method\n      // This method does not have 'this' context needed for fetchData.\n      // Even if it did, it's the wrong place for side effects.\n      // this.fetchData(nextProps.userId); // This would not work as 'this' is undefined\n      return {\n        loading: true,\n        userData: null, // Clear previous data\n        currentUserId: nextProps.userId // Store for comparison\n      };\n    }\n    return null;\n  }\n\n  fetchData = async (userId) => {\n    this.setState({ loading: true });\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`);\n      const data = await response.json();\n      this.setState({ userData: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching data:', error);\n      this.setState({ loading: false });\n    }\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading user data...</div>;\n    if (!this.state.userData) return <div>No user selected.</div>;\n    return (\n      <div>\n        <h2>{this.state.userData.name}</h2>\n        <p>Email: {this.state.userData.email}</p>\n      </div>\n    );\n  }\n}\n```\n\n**Corrected Component using `componentDidUpdate`:**\n`componentDidUpdate` is the correct lifecycle method for performing side effects like data fetching after a component has updated and its props/state have changed.\n\n```typescript\nimport React from 'react';\n\nclass UserProfileCorrected extends React.Component {\n  state = { userData: null, loading: false };\n\n  componentDidMount() {\n    // Initial fetch when component mounts\n    this.fetchData(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Correct: Fetch data here when userId prop changes\n    if (this.props.userId !== prevProps.userId) {\n      this.fetchData(this.props.userId);\n    }\n  }\n\n  fetchData = async (userId) => {\n    this.setState({ loading: true });\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`);\n      const data = await response.json();\n      this.setState({ userData: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching data:', error);\n      this.setState({ loading: false });\n    }\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading user data...</div>;\n    if (!this.state.userData) return <div>No user selected.</div>;\n    return (\n      <div>\n        <h2>{this.state.userData?.name}</h2>\n        <p>Email: {this.state.userData?.email}</p>\n      </div>\n    );\n  }\n}\n```",
          "analysisPoints": [
            "Identifies the anti-pattern of side effects in `getDerivedStateFromProps`.",
            "Explains the reasons for the problem (static context, purity requirement).",
            "Demonstrates the correct application of `componentDidUpdate` for data fetching.",
            "Shows how to handle initial data fetch and subsequent fetches on prop changes.",
            "Highlights the importance of `prevProps` comparison in `componentDidUpdate`."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "componentDidUpdate",
            "Side Effects",
            "Data Fetching",
            "Pure Function",
            "Anti-pattern",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Correct identification of the problem.",
            "Clear explanation of why it's problematic.",
            "Accurate and idiomatic refactoring using the appropriate lifecycle method.",
            "Consideration of both initial and subsequent data fetches."
          ],
          "example": "This is a common mistake for developers new to the modern React lifecycle, highlighting the strict separation of concerns.",
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "componentDidUpdate",
            "Data Fetching",
            "Anti-pattern",
            "Code Refactoring"
          ],
          "prerequisites": [
            "react_class_components",
            "async_js"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_should_component_update_purpose_mcq",
          "topic": "shouldComponentUpdate",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of the `shouldComponentUpdate(nextProps, nextState)` lifecycle method?",
          "answer": "To allow React to know if a component's output is not affected by the current change in props or state, thereby preventing unnecessary re-renders.",
          "options": [
            "To perform API calls before the component updates.",
            "To update the component's internal state based on new props.",
            "To allow React to know if a component's output is not affected by the current change in props or state, thereby preventing unnecessary re-renders.",
            "To clean up resources before the component is removed from the DOM."
          ],
          "analysisPoints": [
            "Tests understanding of `shouldComponentUpdate` as a performance optimization.",
            "Distinguishes its role from data fetching (`componentDidUpdate`), state derivation (`getDerivedStateFromProps`), and cleanup (`componentWillUnmount`).",
            "Focuses on its return value's impact on the rendering process."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Re-render",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct identification of the method's core function.",
            "Differentiation from other lifecycle method purposes."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass OptimizedButton extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    // Only re-render if the 'label' or 'onClick' prop changes\n    return nextProps.label !== this.props.label || nextProps.onClick !== this.props.onClick;\n  }\n\n  render() {\n    console.log('Button rendered:', this.props.label);\n    return <button onClick={this.props.onClick}>{this.props.label}</button>;\n  }\n}\n```\nThis `shouldComponentUpdate` ensures the button only re-renders if its visible label or click handler has genuinely changed, saving rendering cycles if other unrelated props of its parent change.",
          "tags": [
            "React",
            "Lifecycle",
            "shouldComponentUpdate",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pure_component_scu_open",
          "topic": "PureComponent and shouldComponentUpdate",
          "level": "medium",
          "type": "open",
          "question": "Explain the relationship between `React.PureComponent` and `shouldComponentUpdate`. In what scenarios would you choose one over the other, and what are the limitations of `PureComponent`?",
          "answer": "`React.PureComponent` is a base class for React components that internally implements the `shouldComponentUpdate` lifecycle method with a shallow comparison of `props` and `state`. This means that if the props and state of a `PureComponent` are shallowly equal to the previous props and state, `shouldComponentUpdate` will return `false`, preventing an unnecessary re-render of the component and its children.\n\n**Relationship:** `PureComponent` essentially provides an opinionated, built-in `shouldComponentUpdate` logic, saving you from writing it manually.\n\n**Choosing one over the other:**\n\n*   **Choose `React.PureComponent` (or `React.memo` for functional components):**\n    *   When your component's props and state are simple (primitive values like numbers, strings, booleans) or immutable objects/arrays. Shallow comparison works well here.\n    *   When you want a quick and easy performance optimization without writing custom logic.\n    *   When you are confident that changes in nested data structures will always result in new object/array references.\n\n*   **Choose custom `shouldComponentUpdate`:**\n    *   When `PureComponent`'s shallow comparison is insufficient because your component deals with deeply nested data structures, and you need a custom deep comparison logic (though deep comparison can be expensive itself).\n    *   When you need highly specific or complex logic to determine if a re-render is necessary that goes beyond simple equality checks (e.g., checking only specific keys, or comparing only a subset of props).\n    *   When you inherit from `React.Component` and have a specific performance bottleneck that `PureComponent` doesn't address.\n\n**Limitations of `PureComponent`:**\n\n1.  **Shallow Comparison Only:** This is the main limitation. If your props or state contain deeply nested objects or arrays, and a property within those nested structures changes, `PureComponent` will *not* detect this change because the top-level reference to the object/array remains the same. This can lead to your component not updating when it should.\n    ```javascript\n    // If user object changes like this, PureComponent WILL NOT re-render:\n    const prevProps = { user: { name: 'Alice', age: 30 } };\n    const nextProps = { user: { name: 'Alice', age: 31 } }; // 'user' reference is same\n    ```\n2.  **Context API:** `PureComponent` does not optimize updates related to `contextType` or `useContext`. A component using context will still re-render when context values change, regardless of `PureComponent`.\n3.  **Performance cost of comparison:** While it optimizes rendering, the shallow comparison itself still has a small cost. For very simple components that rarely update, the overhead might not be worth it compared to a regular `React.Component`.\n\nIn modern React, `React.memo` (for functional components) is the equivalent of `PureComponent` and often preferred for its simplicity with hooks.",
          "analysisPoints": [
            "Clearly defines `PureComponent` and its internal implementation of `shouldComponentUpdate`.",
            "Compares and contrasts scenarios for using `PureComponent` vs. a custom `shouldComponentUpdate`.",
            "Highlights the critical limitation of shallow comparison with concrete examples.",
            "Mentions other limitations like Context API and overhead."
          ],
          "keyConcepts": [
            "PureComponent",
            "shouldComponentUpdate",
            "Shallow Comparison",
            "Deep Comparison",
            "Performance Optimization",
            "React.memo",
            "Context API"
          ],
          "evaluationCriteria": [
            "Accurate description of relationship.",
            "Comprehensive list of use case scenarios.",
            "Clear explanation of `PureComponent` limitations with examples."
          ],
          "example": "Understanding the shallow comparison is critical to effectively using `PureComponent` and `React.memo`.",
          "tags": [
            "React",
            "PureComponent",
            "shouldComponentUpdate",
            "Performance",
            "Optimization",
            "Shallow Comparison",
            "Limitations"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_scu_drawbacks_flashcard",
          "topic": "shouldComponentUpdate Caveats",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the main risk or drawback of manually implementing `shouldComponentUpdate` incorrectly?",
          "answer": "The main risk is that an incorrect implementation (e.g., a buggy comparison logic) can prevent a component from re-rendering when it *should* have, leading to a stale or inconsistent UI that doesn't reflect the latest data.",
          "analysisPoints": [
            "Tests understanding of the potential negative consequences of misusing `shouldComponentUpdate`.",
            "Focuses on the critical outcome: UI inconsistencies."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Bugs",
            "UI Inconsistency",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Identifies the core problem of incorrect implementation."
          ],
          "example": "A button that doesn't update its text after a prop change because `shouldComponentUpdate` always returns `false` would be a common example of this drawback.",
          "tags": [
            "React",
            "Lifecycle",
            "shouldComponentUpdate",
            "Bugs",
            "UI"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_scu_implement_performance_code",
          "topic": "shouldComponentUpdate Implementation",
          "level": "medium",
          "type": "code",
          "question": "You have a `ProgressBar` component that receives a `progress` (number from 0-100) and a `label` string. The `ProgressBar` also has an internal `animationActive` boolean state. Implement `shouldComponentUpdate` for this component to prevent unnecessary re-renders. The component should only re-render if the `progress` prop changes significantly (e.g., by more than 1 unit), the `label` prop changes, or the `animationActive` state changes. Consider edge cases where `progress` might be a float.",
          "answer": "```typescript\nimport React from 'react';\n\nclass ProgressBar extends React.Component {\n  state = { animationActive: false };\n\n  // Assume some method that toggles animation, e.g., on hover\n  toggleAnimation = () => {\n    this.setState(prevState => ({ animationActive: !prevState.animationActive }));\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Check if label prop has changed\n    if (nextProps.label !== this.props.label) {\n      console.log('SCU: Label changed');\n      return true;\n    }\n\n    // Check if animationActive state has changed\n    if (nextState.animationActive !== this.state.animationActive) {\n      console.log('SCU: Animation state changed');\n      return true;\n    }\n\n    // Check if progress prop has changed significantly\n    // Using Math.abs to handle small float differences and comparing with 1 unit threshold\n    if (Math.abs(nextProps.progress - this.props.progress) > 1) {\n      console.log('SCU: Progress changed significantly');\n      return true;\n    }\n\n    console.log('SCU: No significant change, preventing re-render');\n    return false; // No significant change, prevent re-render\n  }\n\n  render() {\n    console.log(`ProgressBar rendered: ${this.props.label} - ${this.props.progress}%`);\n    const barStyle = {\n      width: `${this.props.progress}%`,\n      backgroundColor: this.state.animationActive ? 'orange' : 'skyblue',\n      height: '20px',\n      transition: this.state.animationActive ? 'width 0.3s ease-in-out' : 'none'\n    };\n    return (\n      <div style={{ border: '1px solid #ccc', width: '300px' }}>\n        <div style={barStyle}></div>\n        <p>{this.props.label}: {this.props.progress.toFixed(1)}% {this.state.animationActive ? '(Animating)' : ''}</p>\n        <button onClick={this.toggleAnimation}>Toggle Animation</button>\n      </div>\n    );\n  }\n}\n\n// Example Usage:\n/*\nclass App extends React.Component {\n  state = { currentProgress: 0 };\n\n  componentDidMount() {\n    // Simulate frequent small updates\n    this.interval = setInterval(() => {\n      this.setState(prevState => ({\n        currentProgress: (prevState.currentProgress + 0.5) % 101 // small change\n      }));\n    }, 50);\n\n    // Simulate larger changes\n    setTimeout(() => this.setState({ currentProgress: 50 }), 2000);\n    setTimeout(() => this.setState({ currentProgress: 95 }), 4000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    return <ProgressBar progress={this.state.currentProgress} label=\"Task Progress\" />;\n  }\n}\n*/\n```",
          "analysisPoints": [
            "Demonstrates conditional logic within `shouldComponentUpdate` based on specific prop and state changes.",
            "Handles numerical comparisons with a tolerance for floats (`Math.abs` and threshold).",
            "Correctly returns `true` or `false` based on the comparison results.",
            "Shows how `console.log` can be used to observe `shouldComponentUpdate`'s behavior.",
            "Illustrates a practical use case for performance optimization.",
            "Covers both prop and state changes as criteria."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Conditional Rendering",
            "Props Comparison",
            "State Comparison",
            "Floating Point Comparison"
          ],
          "evaluationCriteria": [
            "Correct implementation of `shouldComponentUpdate`.",
            "Accurate handling of numerical comparison (especially floats).",
            "Logical conditions for re-rendering.",
            "Prevention of unnecessary re-renders as per requirements."
          ],
          "example": "This task requires careful comparison logic to ensure the component re-renders only when truly necessary, optimizing performance for frequently changing props.",
          "tags": [
            "React",
            "Lifecycle",
            "shouldComponentUpdate",
            "Performance",
            "Optimization",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_class_components",
            "props_state"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_purity_mcq",
          "topic": "render() Method",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following operations should NOT be performed inside the `render()` method of a React class component?",
          "answer": "Modifying component state using `this.setState()`.",
          "options": [
            "Returning JSX elements.",
            "Accessing `this.props` to display data.",
            "Modifying component state using `this.setState()`.",
            "Using `map()` to render a list of items."
          ],
          "analysisPoints": [
            "Tests fundamental understanding of `render` method's purity.",
            "Identifies `setState` as a side effect that should not occur in `render`.",
            "Distinguishes allowed (pure rendering logic) from disallowed operations (side effects)."
          ],
          "keyConcepts": [
            "render method",
            "Pure Function",
            "Side Effects",
            "setState"
          ],
          "evaluationCriteria": [
            "Correctly identifies the forbidden operation.",
            "Understanding of the pure nature of `render`."
          ],
          "example": "If `setState` is called inside `render`, it can lead to an infinite loop of re-renders and errors, as `setState` triggers an update, which calls `render` again, and so on.",
          "tags": [
            "React",
            "Lifecycle",
            "render",
            "Pure Function",
            "Side Effects"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_side_effects_open",
          "topic": "render() Side Effects",
          "level": "medium",
          "type": "open",
          "question": "Why is it considered an anti-pattern to perform side effects (like data fetching, DOM manipulation, or `setState`) directly within the `render()` method in React? What are the potential consequences, and which lifecycle methods are appropriate for such operations?",
          "answer": "It is considered an anti-pattern to perform side effects directly within the `render()` method because `render()` is expected to be a **pure function**. This means it should only compute the output based on `props` and `state` and not cause any observable changes outside its scope.\n\n**Potential Consequences:**\n\n1.  **Infinite Loops:** If `setState()` is called directly within `render()`, it will trigger another re-render, which calls `render()` again, leading to an uncontrolled infinite loop and a crash.\n2.  **Performance Issues:** `render()` can be called frequently (on every state or prop update of the component or its ancestors). Performing expensive operations like data fetching or complex DOM manipulations in `render()` would cause severe performance degradation and unnecessary resource consumption.\n3.  **Unpredictable Behavior/Bugs:** The order of rendering is not strictly guaranteed across different components or during initial vs. update renders. Side effects performed non-deterministically in `render()` can lead to hard-to-debug inconsistencies and race conditions.\n4.  **Violation of React Principles:** It breaks React's fundamental principle of a predictable, declarative UI. React expects `render()` to simply describe *what* the UI should look like, not *how* to achieve side effects.\n\n**Appropriate Lifecycle Methods for Side Effects:**\n\n*   **`componentDidMount()`**: For side effects that should run once after the initial render (e.g., initial data fetching, setting up subscriptions, adding event listeners).\n*   **`componentDidUpdate(prevProps, prevState, snapshot)`**: For side effects that should run after subsequent re-renders, typically in response to prop or state changes (e.g., re-fetching data when an ID prop changes, updating DOM based on new state, conditional `setState`).\n*   **`componentWillUnmount()`**: For cleaning up any resources (e.g., removing event listeners, clearing timers, canceling network requests) that were set up in `componentDidMount` or `componentDidUpdate`.",
          "analysisPoints": [
            "Explains the 'pure function' concept for `render`.",
            "Lists and explains common consequences of violating `render`'s purity (infinite loops, performance, unpredictability).",
            "Identifies the correct lifecycle methods for various types of side effects (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`)."
          ],
          "keyConcepts": [
            "render method",
            "Pure Function",
            "Side Effects",
            "Anti-pattern",
            "componentDidMount",
            "componentDidUpdate",
            "componentWillUnmount",
            "Performance"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of the 'why'.",
            "Detailed list of consequences.",
            "Accurate mapping of side effects to appropriate lifecycle methods."
          ],
          "example": "A classic example of a `render` anti-pattern is `fetchData()` or `this.setState()` directly inside the `render` method, which inevitably leads to an infinite loop of fetches/renders.",
          "tags": [
            "React",
            "Lifecycle",
            "render",
            "Side Effects",
            "Anti-pattern",
            "Best Practices",
            "Performance"
          ],
          "prerequisites": [
            "react_basics",
            "lifecycle_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_gsbu_purpose_mcq",
          "topic": "getSnapshotBeforeUpdate",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of `getSnapshotBeforeUpdate(prevProps, prevState)`?",
          "answer": "To capture information from the DOM (e.g., scroll position) right before React commits the updated output to the DOM, which can then be used in `componentDidUpdate`.",
          "options": [
            "To decide if the component should re-render or not.",
            "To perform asynchronous data fetching before the component mounts.",
            "To capture information from the DOM (e.g., scroll position) right before React commits the updated output to the DOM, which can then be used in `componentDidUpdate`.",
            "To synchronize internal state with new props."
          ],
          "analysisPoints": [
            "Tests understanding of `getSnapshotBeforeUpdate`'s unique role in reading pre-DOM-update information.",
            "Distinguishes it from `shouldComponentUpdate` (re-render decision), `componentDidMount` (initial fetch), and `getDerivedStateFromProps` (state sync).",
            "Highlights its direct relationship with `componentDidUpdate` via the `snapshot` parameter."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "DOM Snapshot",
            "componentDidUpdate",
            "Lifecycle",
            "Scroll Position"
          ],
          "evaluationCriteria": [
            "Correct identification of its specific use case.",
            "Understanding of its timing relative to DOM updates."
          ],
          "example": "The most common use case for `getSnapshotBeforeUpdate` is managing scroll positions in chat applications or lists where new items are added, and the user's current view needs to be maintained.",
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "DOM",
            "Snapshot"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gsbu_return_value_flashcard",
          "topic": "getSnapshotBeforeUpdate Return Value",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `getSnapshotBeforeUpdate` return, and where is this returned value used?",
          "answer": "It returns a 'snapshot' value (which can be any type, or `null`). This value is then passed as the third argument to `componentDidUpdate`.",
          "analysisPoints": [
            "Tests recall of the `getSnapshotBeforeUpdate`'s return type.",
            "Confirms understanding of the data flow between `getSnapshotBeforeUpdate` and `componentDidUpdate`."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "Snapshot",
            "componentDidUpdate",
            "Return Value"
          ],
          "evaluationCriteria": [
            "Accurate description of return value.",
            "Correct identification of its destination."
          ],
          "example": "If `getSnapshotBeforeUpdate` returns `100`, then `componentDidUpdate(prevProps, prevState, 100)`.",
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "Snapshot",
            "componentDidUpdate"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gsbu_vs_cwupdate_open",
          "topic": "getSnapshotBeforeUpdate vs componentWillUpdate",
          "level": "hard",
          "type": "open",
          "question": "React's `getSnapshotBeforeUpdate` replaced the deprecated `componentWillUpdate`. Explain why `componentWillUpdate` was problematic and how `getSnapshotBeforeUpdate` addresses these issues, making it a safer alternative for capturing DOM information.",
          "answer": "`componentWillUpdate` was deprecated because it was called *before* the `render` method and before React applied any changes to the DOM. This meant that any DOM reads performed in `componentWillUpdate` would be based on the *previous* DOM state, not the state immediately *before* the current render's DOM changes were applied. If the `render` method or a child component in `render` caused a synchronous DOM mutation (e.g., due to a layout effect or third-party library), the snapshot taken in `componentWillUpdate` could be stale and incorrect.\n\n**Problems with `componentWillUpdate`:**\n\n1.  **Timing Issue:** It was called *before* `render` and *before* React potentially updated the DOM. If `render` itself or a child component triggered synchronous DOM changes, the snapshot taken in `componentWillUpdate` would be based on an outdated DOM.\n2.  **Unreliable DOM Reads:** The DOM might be in an inconsistent state during `componentWillUpdate` if React's internal processes or external factors modified it after `componentWillUpdate` but before the actual commit.\n\n**How `getSnapshotBeforeUpdate` Addresses These Issues:**\n\n`getSnapshotBeforeUpdate` is called right after `render` (and `static getDerivedStateFromProps`, `shouldComponentUpdate`), but *before* the rendered output is committed (i.e., actually applied) to the DOM. This precise timing ensures:\n\n1.  **Consistent DOM State for Snapshot:** When `getSnapshotBeforeUpdate` is called, React has just calculated the new virtual DOM tree, but the browser's actual DOM has *not yet* been updated. This means you can reliably read the current (pre-update) DOM properties (like scroll position, element dimensions) knowing that these values represent the state immediately before React's pending DOM mutations are applied.\n2.  **Direct Data Flow:** Any value returned by `getSnapshotBeforeUpdate` is explicitly passed as a `snapshot` argument to `componentDidUpdate`. This creates a clear, reliable channel to pass pre-update DOM information to the post-update phase, where you can then apply necessary adjustments (e.g., reset scroll position). This avoids relying on instance variables or indirect state updates.\n\nIn essence, `getSnapshotBeforeUpdate` provides a reliable 'last chance' to inspect the DOM *before* it changes, bridging the gap between the render phase and the commit phase, and solving the timing problem inherent in `componentWillUpdate`.",
          "analysisPoints": [
            "Explains the fundamental timing problem of `componentWillUpdate`.",
            "Highlights how `render` or synchronous DOM changes could invalidate `componentWillUpdate`'s snapshot.",
            "Describes the precise timing of `getSnapshotBeforeUpdate` (after render, before DOM commit).",
            "Explains how this timing ensures reliable DOM reads.",
            "Emphasizes the clear data flow from `getSnapshotBeforeUpdate` to `componentDidUpdate`.",
            "Relates the deprecation to the solution provided by the new method."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "componentWillUpdate",
            "Deprecation",
            "DOM Manipulation",
            "Timing",
            "Render Phase",
            "Commit Phase",
            "Snapshot"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of `componentWillUpdate`'s flaws.",
            "Clear articulation of `getSnapshotBeforeUpdate`'s advantages and solution.",
            "Understanding of React's render and commit phases."
          ],
          "example": "If you had a chat window and needed to maintain scroll position when new messages arrived, `componentWillUpdate` might give you a stale scroll position if the new messages were rendered and affected DOM size *before* `componentWillUpdate` finished. `getSnapshotBeforeUpdate` ensures you get the position just before the new messages become visible.",
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "componentWillUpdate",
            "Deprecation",
            "DOM",
            "Advanced"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_gsbu_dom_interaction_code",
          "topic": "getSnapshotBeforeUpdate Usage",
          "level": "medium",
          "type": "code",
          "question": "Implement a component called `AnimatedBox` that changes its width based on a prop `targetWidth`. Use `getSnapshotBeforeUpdate` to capture the *initial* width of the box just before the update occurs. Then, in `componentDidUpdate`, log the initial width, the new width, and the difference. This demonstrates reading a DOM property before it changes.",
          "answer": "```typescript\nimport React from 'react';\n\nclass AnimatedBox extends React.Component {\n  boxRef = React.createRef();\n\n  // State to manage current width for animation (optional, but makes it clear)\n  state = { currentWidth: this.props.initialWidth || 100 };\n\n  componentDidMount() {\n    // Ensure initial width is set\n    if (this.props.initialWidth) {\n      this.setState({ currentWidth: this.props.initialWidth });\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // If targetWidth prop changes, update currentWidth state\n    if (nextProps.targetWidth !== prevState.currentWidth) {\n      return { currentWidth: nextProps.targetWidth };\n    }\n    return null;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Capture the current width of the box element *before* the DOM updates\n    const boxElement = this.boxRef.current;\n    if (boxElement) {\n      const initialWidth = boxElement.offsetWidth;\n      console.log(`getSnapshotBeforeUpdate: Captured initial width: ${initialWidth}px`);\n      return initialWidth; // Pass this value as snapshot\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    const boxElement = this.boxRef.current;\n    if (boxElement && snapshot !== null) {\n      const finalWidth = boxElement.offsetWidth;\n      const widthDifference = finalWidth - snapshot;\n      console.log(`componentDidUpdate: Final width: ${finalWidth}px`);\n      console.log(`componentDidUpdate: Width difference (Final - Initial): ${widthDifference}px`);\n      \n      // Example of applying animation if needed after getting snapshot\n      // You could apply a class here to trigger a CSS transition\n      // this.boxRef.current.classList.add('animate-width');\n    }\n  }\n\n  render() {\n    const { currentWidth } = this.state;\n    console.log(`render: Rendering with width: ${currentWidth}px`);\n    return (\n      <div\n        ref={this.boxRef}\n        style={{\n          width: `${currentWidth}px`,\n          height: '50px',\n          backgroundColor: 'blue',\n          transition: 'width 0.5s ease-in-out'\n        }}\n      >\n        Box\n      </div>\n    );\n  }\n}\n\n// Example usage in a parent component:\n/*\nclass AppContainer extends React.Component {\n  state = { width: 100 };\n\n  componentDidMount() {\n    setInterval(() => {\n      this.setState(prevState => ({\n        width: prevState.width === 100 ? 300 : 100\n      }));\n    }, 2000);\n  }\n\n  render() {\n    return <AnimatedBox targetWidth={this.state.width} initialWidth={100} />;\n  }\n}\n*/\n```",
          "analysisPoints": [
            "Demonstrates the practical use of `React.createRef()` to access a DOM element.",
            "Shows how `getSnapshotBeforeUpdate` captures a DOM property (`offsetWidth`) immediately before the DOM update.",
            "Illustrates the transfer of the snapshot value to `componentDidUpdate`.",
            "Uses `componentDidUpdate` to compare the pre-update snapshot with the post-update DOM state.",
            "Includes `static getDerivedStateFromProps` to smoothly manage state transition from `targetWidth` prop.",
            "Incorporates console logs to visualize the timing of lifecycle methods and property changes."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "Refs",
            "DOM Manipulation",
            "Snapshot",
            "Lifecycle Order",
            "Animation"
          ],
          "evaluationCriteria": [
            "Correct use of `getSnapshotBeforeUpdate` for DOM reads.",
            "Effective passing and use of the snapshot in `componentDidUpdate`.",
            "Proper use of `React.createRef` for DOM access.",
            "Clear demonstration of before/after DOM state."
          ],
          "example": "This task simulates a scenario where understanding the DOM's state before a visual change is critical, often for smooth animations or layout adjustments.",
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "DOM",
            "Refs",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_class_components",
            "refs",
            "dom_manipulation_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_cdu_purpose_mcq",
          "topic": "componentDidUpdate",
          "level": "easy",
          "type": "mcq",
          "question": "What is the main responsibility of the `componentDidUpdate(prevProps, prevState, snapshot)` method?",
          "answer": "To perform side effects (e.g., API calls, DOM manipulation) after a component has updated, comparing previous and current props/state.",
          "options": [
            "To decide whether the component should re-render.",
            "To initialize state from props during mounting.",
            "To perform side effects (e.g., API calls, DOM manipulation) after a component has updated, comparing previous and current props/state.",
            "To clean up event listeners before the component is destroyed."
          ],
          "analysisPoints": [
            "Tests core understanding of `componentDidUpdate`'s role in handling post-render side effects.",
            "Emphasizes the importance of comparing `prevProps`/`prevState` to avoid infinite loops.",
            "Distinguishes it from `shouldComponentUpdate`, `constructor`/`getDerivedStateFromProps`, and `componentWillUnmount`."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "Side Effects",
            "API Calls",
            "DOM Manipulation",
            "Lifecycle",
            "prevProps",
            "prevState"
          ],
          "evaluationCriteria": [
            "Correct identification of the method's primary function.",
            "Understanding of its timing and parameters."
          ],
          "example": "A common use case is fetching new data when a `userId` prop changes: `if (this.props.userId !== prevProps.userId) { this.fetchData(this.props.userId); }`",
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "Side Effects",
            "API Calls"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cdu_infinite_loop_open",
          "topic": "componentDidUpdate and Infinite Loops",
          "level": "medium",
          "type": "open",
          "question": "Explain why calling `this.setState()` unconditionally inside `componentDidUpdate()` can lead to an infinite loop. Provide a simple code example of such a loop and explain how to correctly prevent it.",
          "answer": "Calling `this.setState()` unconditionally inside `componentDidUpdate()` creates an infinite loop because `setState()` itself triggers a component update. When `setState()` is called in `componentDidUpdate`, it causes the component to re-render, which in turn calls `componentDidUpdate` again, leading to a continuous cycle of updates and renders.\n\n**Example of an Infinite Loop:**\n```typescript\nimport React from 'react';\n\nclass InfiniteLoopComponent extends React.Component {\n  state = { count: 0 };\n\n  componentDidUpdate() {\n    console.log('componentDidUpdate called');\n    // PROBLEM: Unconditionally calls setState, causing an infinite loop\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    console.log('render called', this.state.count);\n    return <div>Count: {this.state.count}</div>;\n  }\n}\n\n// This component would crash the browser due to rapid, continuous re-renders.\n```\n\n**How to Correctly Prevent it:**\n\nTo prevent an infinite loop when calling `this.setState()` in `componentDidUpdate()`, you **must** wrap the `setState()` call in a conditional statement. This condition should check whether the relevant `props` or `state` values have actually changed in a way that warrants the new state update. By comparing `this.props` with `prevProps` or `this.state` with `prevState`, you ensure that `setState` is only called when a specific, meaningful change occurs, thus breaking the re-render cycle.\n\n**Corrected Example:**\n```typescript\nimport React from 'react';\n\nclass SafeUpdateComponent extends React.Component {\n  state = { count: 0, message: '' };\n\n  componentDidUpdate(prevProps, prevState) {\n    // GOOD: Conditionally call setState based on state change\n    if (this.state.count !== prevState.count && this.state.count >= 5) {\n      if (this.state.message === '') { // Only set message once\n        this.setState({ message: 'Count is 5 or more!' });\n      }\n    }\n\n    // GOOD: Conditionally call setState based on prop change\n    if (this.props.someProp !== prevProps.someProp) {\n      console.log('Prop changed, perhaps fetch new data or update state related to prop');\n      // Example: this.setState({ derivedFromProp: this.props.someProp * 2 });\n    }\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>{this.state.message}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n```",
          "analysisPoints": [
            "Clearly explains the mechanism of the infinite loop.",
            "Provides a concise and accurate problematic code example.",
            "Presents the correct solution: conditional `setState`.",
            "Offers a clear, runnable corrected code example.",
            "Emphasizes the role of `prevProps` and `prevState` for comparison."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "setState",
            "Infinite Loop",
            "Side Effects",
            "Conditional Logic",
            "prevProps",
            "prevState"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation for loop mechanism.",
            "Correctness and clarity of code examples.",
            "Demonstration of effective prevention strategy."
          ],
          "example": "This is one of the most common pitfalls when working with `componentDidUpdate`.",
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "setState",
            "Infinite Loop",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cdu_snapshot_flashcard",
          "topic": "componentDidUpdate Parameters",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the third parameter received by `componentDidUpdate`, and what is its origin?",
          "answer": "The third parameter is `snapshot`. It originates from the return value of `getSnapshotBeforeUpdate()`, which is called right before the DOM is updated. If `getSnapshotBeforeUpdate` is not implemented or returns `null`, `snapshot` will be `undefined`.",
          "analysisPoints": [
            "Tests recall of `componentDidUpdate` parameters.",
            "Confirms understanding of the `snapshot` parameter's purpose and its link to `getSnapshotBeforeUpdate`."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "snapshot",
            "getSnapshotBeforeUpdate",
            "Parameters"
          ],
          "evaluationCriteria": [
            "Correct identification of the parameter.",
            "Accurate explanation of its origin."
          ],
          "example": "You might use the `snapshot` to restore scroll position after a list update: `window.scrollTo(0, snapshot.scrollPos);`",
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "getSnapshotBeforeUpdate",
            "Snapshot"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cdu_data_fetch_code",
          "topic": "componentDidUpdate Data Fetching",
          "level": "medium",
          "type": "code",
          "question": "Create a React class component `UserPosts` that displays a list of posts for a given `userId` received as a prop. Implement data fetching in `componentDidUpdate` such that new posts are fetched only when the `userId` prop changes. Handle loading and error states.",
          "answer": "```typescript\nimport React from 'react';\n\nclass UserPosts extends React.Component {\n  state = {\n    posts: [],\n    loading: true,\n    error: null,\n  };\n\n  componentDidMount() {\n    // Initial data fetch when component mounts\n    this.fetchUserPosts(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Only fetch new posts if the userId prop has changed\n    if (this.props.userId !== prevProps.userId) {\n      this.fetchUserPosts(this.props.userId);\n    }\n  }\n\n  fetchUserPosts = async (userId) => {\n    this.setState({ loading: true, error: null, posts: [] }); // Reset state before new fetch\n    try {\n      // Simulate API call using JSONPlaceholder for example posts\n      const response = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${userId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ posts: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching posts:', error);\n      this.setState({ error: error.message, loading: false });\n    }\n  };\n\n  render() {\n    const { posts, loading, error } = this.state;\n    const { userId } = this.props;\n\n    if (loading) {\n      return <div>Loading posts for User ID: {userId}...</div>;\n    }\n\n    if (error) {\n      return <div>Error fetching posts for User ID: {userId}: {error}</div>;\n    }\n\n    if (posts.length === 0) {\n      return <div>No posts found for User ID: {userId}.</div>;\n    }\n\n    return (\n      <div>\n        <h3>Posts by User ID: {userId}</h3>\n        <ul>\n          {posts.map(post => (\n            <li key={post.id}>\n              <h4>{post.title}</h4>\n              <p>{post.body}</p>\n            </li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Example Parent Component for testing:\n/*\nclass App extends React.Component {\n  state = { currentUserId: 1 };\n\n  changeUser = (newId) => {\n    this.setState({ currentUserId: newId });\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.changeUser(1)}>Load User 1 Posts</button>\n        <button onClick={() => this.changeUser(2)}>Load User 2 Posts</button>\n        <button onClick={() => this.changeUser(999)}>Load Non-existent User Posts</button>\n        <UserPosts userId={this.state.currentUserId} />\n      </div>\n    );\n  }\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/\n```",
          "analysisPoints": [
            "Demonstrates proper use of `componentDidMount` for initial data fetch.",
            "Shows correct conditional data fetching in `componentDidUpdate` based on prop changes (`userId`).",
            "Includes robust error handling and loading states.",
            "Resets `posts` array and `error` state before new fetch to ensure correct UI during loading.",
            "Uses a public API (JSONPlaceholder) for realistic data fetching.",
            "Provides a clear `render` method to display posts or messages."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "componentDidMount",
            "Data Fetching",
            "API Calls",
            "Conditional Logic",
            "State Management",
            "Error Handling",
            "Loading State"
          ],
          "evaluationCriteria": [
            "Correct implementation of data fetching in lifecycle methods.",
            "Effective use of `prevProps` for conditional re-fetching.",
            "Proper handling of loading, error, and empty states.",
            "Clean and readable code structure."
          ],
          "example": "This is a very common interview task, demonstrating the ability to manage asynchronous operations and component updates.",
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "Data Fetching",
            "API",
            "Code Challenge",
            "State Management"
          ],
          "prerequisites": [
            "react_class_components",
            "async_js"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_unmount_phase_purpose_mcq",
          "topic": "React Unmounting Phase",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the 'unmounting' phase in a React component's lifecycle?",
          "answer": "To perform cleanup operations before the component is removed from the DOM.",
          "options": [
            "To initialize state and props for the component.",
            "To update the component's state based on new props.",
            "To render the component's UI to the DOM for the first time.",
            "To perform cleanup operations before the component is removed from the DOM."
          ],
          "analysisPoints": [
            "Tests basic understanding of the unmounting phase's role.",
            "Distinguishes cleanup from mounting, updating, and rendering phases."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Unmounting Phase",
            "Cleanup",
            "Memory Leaks"
          ],
          "evaluationCriteria": [
            "Correctly identifies the core purpose."
          ],
          "example": "This phase ensures resources like timers or event listeners are properly released.",
          "tags": [
            "React",
            "Lifecycle",
            "Unmounting Phase",
            "Cleanup"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_unmount_trigger_open",
          "topic": "React Unmounting Triggers",
          "level": "medium",
          "type": "open",
          "question": "Describe scenarios that would typically cause a React class component to enter its 'unmounting' phase.",
          "answer": "A React class component enters its 'unmounting' phase when it is removed from the DOM. Common scenarios that trigger unmounting include:\n\n1.  **Conditional Rendering:** A parent component stops rendering the child component, often controlled by a state or prop. For example, `render() { return this.state.showComponent ? <MyComponent /> : null; }` – when `showComponent` becomes `false`, `MyComponent` unmounts.\n\n2.  **Parent Component Unmounting:** If a parent component unmounts, all of its child components will also unmount, regardless of their own state or props.\n\n3.  **Key Changes in Lists:** When rendering a list of components using `map()` and assigning a `key` prop, if an item is removed from the list, or its `key` changes, the corresponding component instance will be unmounted and a new one might be mounted in its place. This is why stable `keys` are crucial.\n\n4.  **Routing Changes:** In single-page applications using client-side routing libraries (like React Router), navigating to a different route often means that components associated with the previous route are unmounted, and new components for the current route are mounted.\n\n5.  **Direct DOM Manipulation (Rare/Discouraged):** If external JavaScript or a library directly removes the DOM node that React is managing for the component, React will detect this and unmount the corresponding component instance. This is generally an anti-pattern as it bypasses React's reconciliation.",
          "analysisPoints": [
            "Identifies common and less common triggers for unmounting.",
            "Explains how each trigger leads to unmounting (e.g., `key` changes, conditional rendering).",
            "Demonstrates understanding of React's reconciliation process in context of unmounting."
          ],
          "keyConcepts": [
            "Unmounting Phase",
            "Conditional Rendering",
            "Keys",
            "Routing",
            "Reconciliation",
            "Parent-Child Relationship"
          ],
          "evaluationCriteria": [
            "Completeness and accuracy of scenarios.",
            "Clarity of explanation for each trigger.",
            "Understanding of underlying React mechanisms."
          ],
          "example": "Imagine a modal component that is shown/hidden based on a boolean prop. When the prop changes to `false`, the modal component unmounts.",
          "tags": [
            "React",
            "Lifecycle",
            "Unmounting Phase",
            "Triggers",
            "Conditional Rendering",
            "Keys",
            "Routing"
          ],
          "prerequisites": [
            "react_basics",
            "state_props"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cwunmount_purpose_mcq",
          "topic": "componentWillUnmount",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary function of `componentWillUnmount()` in a React class component?",
          "answer": "To perform necessary cleanup operations before the component is completely removed from the DOM.",
          "options": [
            "To re-render the component when new props are received.",
            "To set up initial state and event listeners for the component.",
            "To perform necessary cleanup operations before the component is completely removed from the DOM.",
            "To fetch data from an API after the component has rendered."
          ],
          "analysisPoints": [
            "Tests basic understanding of `componentWillUnmount`'s purpose.",
            "Distinguishes it from other lifecycle methods and their roles.",
            "Focuses on its role in preventing memory leaks."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "Cleanup",
            "Memory Leaks",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct identification of the method's core function."
          ],
          "example": "Clearing timers and removing event listeners are common tasks in `componentWillUnmount`.",
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "Cleanup",
            "Memory Leaks"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_cwunmount_no_setstate_open",
          "topic": "componentWillUnmount setState Restriction",
          "level": "medium",
          "type": "open",
          "question": "Why should you never call `this.setState()` inside `componentWillUnmount()`?",
          "answer": "You should never call `this.setState()` inside `componentWillUnmount()` because the component is about to be unmounted and destroyed from the DOM. After `componentWillUnmount` executes, the component instance is permanently removed from the render tree and will not be re-rendered. Therefore, any call to `setState()` would be pointless as it would trigger an update on a component that no longer exists in the DOM.\n\n**Reasons:**\n\n1.  **No Re-render:** The component instance is being destroyed. Even if `setState` were to update its internal state, there would be no subsequent `render()` call, and no effect on the DOM.\n2.  **Memory Leaks (Indirectly):** While `setState` itself doesn't directly cause a memory leak here, trying to perform actions on an 'about to be dead' component can sometimes indicate a larger issue or pattern that *could* lead to memory leaks if similar logic is applied elsewhere.\n3.  **Development Warnings/Errors:** React will often issue a warning in development mode (e.g., 'Can't perform a React state update on an unmounted component...') if you try to `setState` on an unmounted component, alerting you to a potential issue, even if it's not strictly a runtime error in all cases.\n\nThe primary purpose of `componentWillUnmount` is cleanup, not triggering new renders or state updates.",
          "analysisPoints": [
            "Explains the core reason: component is being destroyed and won't re-render.",
            "Articulates why `setState` would be pointless.",
            "Mentions potential development warnings/errors.",
            "Reinforces the correct purpose of `componentWillUnmount` (cleanup)."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "setState",
            "Unmounting",
            "Memory Leaks",
            "Lifecycle Restrictions"
          ],
          "evaluationCriteria": [
            "Clear and accurate explanation of the restriction.",
            "Understanding of component destruction process.",
            "Mention of practical implications (warnings)."
          ],
          "example": "If a `componentWillUnmount` tried to update a loading spinner state, it would be useless because the spinner component would already be gone.",
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "setState",
            "Restrictions"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cwunmount_memory_leaks_flashcard",
          "topic": "componentWillUnmount and Memory Leaks",
          "level": "medium",
          "type": "flashcard",
          "question": "What is a 'memory leak' in the context of React components, and how does `componentWillUnmount` help prevent them?",
          "answer": "A memory leak occurs when an application retains references to objects (like components, event listeners, timers, network requests) that are no longer needed, preventing them from being garbage-collected. This leads to increased memory usage over time. `componentWillUnmount` helps prevent memory leaks by providing a lifecycle hook to 'clean up' or 'tear down' these resources (e.g., removing event listeners, clearing timers, canceling subscriptions) before the component is destroyed, ensuring they are properly released.",
          "analysisPoints": [
            "Defines memory leak accurately.",
            "Explains how `componentWillUnmount` directly addresses the problem through cleanup."
          ],
          "keyConcepts": [
            "Memory Leak",
            "componentWillUnmount",
            "Cleanup",
            "Event Listeners",
            "Timers",
            "Subscriptions"
          ],
          "evaluationCriteria": [
            "Clear definition of memory leak.",
            "Correct explanation of method's preventative role.",
            "Examples of resources to clean up."
          ],
          "example": "If you add a `window.resize` event listener in `componentDidMount` but don't remove it in `componentWillUnmount`, that listener will persist even after the component is gone, leading to a memory leak.",
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "Memory Leaks",
            "Cleanup"
          ],
          "prerequisites": [
            "react_basics",
            "browser_events"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cwunmount_cleanup_code",
          "topic": "componentWillUnmount Cleanup",
          "level": "medium",
          "type": "code",
          "question": "Create a React class component `CountdownTimer` that displays a countdown from a given `initialSeconds` prop. It should update every second. Implement the necessary lifecycle methods to start the timer when the component mounts and ensure it is properly stopped and cleaned up when the component unmounts to prevent memory leaks. Also, log messages to the console for mount, update, and unmount events.",
          "answer": "```typescript\nimport React from 'react';\n\nclass CountdownTimer extends React.Component {\n  state = {\n    secondsLeft: this.props.initialSeconds,\n  };\n  timerId = null; // To store the interval ID for cleanup\n\n  componentDidMount() {\n    console.log('CountdownTimer: componentDidMount - Starting timer.');\n    // Start the countdown timer\n    this.timerId = setInterval(() => {\n      this.setState(prevState => {\n        if (prevState.secondsLeft <= 1) {\n          clearInterval(this.timerId);\n          console.log('CountdownTimer: Timer finished.');\n          return { secondsLeft: 0 };\n        }\n        return { secondsLeft: prevState.secondsLeft - 1 };\n      });\n    }, 1000);\n  }\n\n  // Optional: If initialSeconds can change during component's lifetime\n  componentDidUpdate(prevProps) {\n    if (this.props.initialSeconds !== prevProps.initialSeconds) {\n      console.log('CountdownTimer: componentDidUpdate - initialSeconds changed, resetting timer.');\n      // Clear existing timer if prop changes, then restart\n      if (this.timerId) {\n        clearInterval(this.timerId);\n      }\n      this.setState({ secondsLeft: this.props.initialSeconds });\n      this.componentDidMount(); // Re-call mount logic to restart timer\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('CountdownTimer: componentWillUnmount - Clearing timer.');\n    // Crucial: Clean up the timer to prevent memory leaks\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      this.timerId = null;\n    }\n  }\n\n  render() {\n    console.log('CountdownTimer: render');\n    const { secondsLeft } = this.state;\n    return (\n      <div>\n        <h2>Countdown: {secondsLeft} seconds</h2>\n        {secondsLeft <= 0 && <p>Time's Up!</p>}\n      </div>\n    );\n  }\n}\n\n// Example Parent Component to demonstrate mounting/unmounting\n/*\nimport ReactDOM from 'react-dom';\nclass App extends React.Component {\n  state = { showTimer: true, initialDuration: 10 };\n\n  toggleTimer = () => {\n    this.setState(prevState => ({ showTimer: !prevState.showTimer }));\n  };\n\n  resetTimer = () => {\n    // Changing the key forces remounting, which triggers componentWillUnmount and then componentDidMount\n    this.setState(prevState => ({ initialDuration: prevState.initialDuration === 10 ? 15 : 10 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.toggleTimer}>Toggle Timer</button>\n        <button onClick={this.resetTimer}>Reset Timer (Remount)</button>\n        {this.state.showTimer && <CountdownTimer key={this.state.initialDuration} initialSeconds={this.state.initialDuration} />}\n      </div>\n    );\n  }\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/\n```",
          "analysisPoints": [
            "Correctly uses `componentDidMount` to start the `setInterval` timer.",
            "Crucially implements `componentWillUnmount` to `clearInterval`, preventing memory leaks.",
            "Manages state updates for the countdown correctly, including stopping the timer when it reaches zero.",
            "Includes optional `componentDidUpdate` logic to handle prop changes and reset the timer.",
            "Uses console logs to track lifecycle events and demonstrate proper cleanup.",
            "Uses `timerId` to store and clear the interval reference."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "componentDidMount",
            "Timers",
            "setInterval",
            "clearInterval",
            "Memory Leaks",
            "Cleanup",
            "State Management",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct timer setup and cleanup in appropriate lifecycle methods.",
            "Prevention of memory leaks through `clearInterval`.",
            "Accurate state management for the countdown.",
            "Clear logging to demonstrate lifecycle flow."
          ],
          "example": "This task is a fundamental test of understanding resource management within React components.",
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "componentDidMount",
            "Timers",
            "Memory Leaks",
            "Cleanup",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_class_components",
            "javascript_timers"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_update_lifecycle_logger",
          "title": "Implement a Component Demonstrating Update Lifecycle",
          "description": "\nCreate a React class component named `LifecycleLogger` that displays a `count` in its state and a `message` received as a prop. Implement the following lifecycle methods to log their execution order during an update:\n\n1.  `static getDerivedStateFromProps`: Log its call, and if `message` prop changes, update a derived state `displayMessage`.\n2.  `shouldComponentUpdate`: Log its call and return `true` unconditionally for now.\n3.  `render`: Log its call.\n4.  `getSnapshotBeforeUpdate`: Log its call and return a simple string 'Snapshot taken'.\n5.  `componentDidUpdate`: Log its call, and also log the `snapshot` received and if `message` prop actually changed.\n\nInclude a button in `render` that increments the `count` state to trigger updates. The goal is to visually observe the sequence of lifecycle method calls in the browser console when the component updates.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass LifecycleLogger extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      displayMessage: props.message || 'No message'\n    };\n    console.log('Constructor (mount)');\n  }\n\n  // 1. static getDerivedStateFromProps\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('1. static getDerivedStateFromProps');\n    // TODO: Implement logic to update displayMessage if message prop changes\n    return null; // or an object to update state\n  }\n\n  // 2. shouldComponentUpdate\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('2. shouldComponentUpdate');\n    // TODO: Implement logic to return true\n    return true;\n  }\n\n  // 3. render\n  render() {\n    console.log('3. render');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.displayMessage}</p>\n        <button onClick={() => this.setState(prevState => ({ count: prevState.count + 1 }))}>\n          Increment Count\n        </button>\n      </div>\n    );\n  }\n\n  // 4. getSnapshotBeforeUpdate\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('4. getSnapshotBeforeUpdate');\n    // TODO: Implement logic to return 'Snapshot taken'\n    return null; // or a snapshot value\n  }\n\n  // 5. componentDidUpdate\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('5. componentDidUpdate');\n    // TODO: Log snapshot and check if message prop changed\n  }\n\n  // Optional: componentWillUnmount for completeness if component is removed\n  componentWillUnmount() {\n    console.log('componentWillUnmount (cleanup)');\n  }\n}\n\n// Parent component for demonstration:\n/*\nclass App extends React.Component {\n  state = { appMessage: 'Initial App Message' };\n\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({ appMessage: 'Updated App Message' });\n    }, 3000);\n  }\n\n  render() {\n    return <LifecycleLogger message={this.state.appMessage} />;\n  }\n}\n// Render <App /> to observe lifecycle\n*/",
          "solutionCode": "import React from 'react';\n\nclass LifecycleLogger extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      displayMessage: props.message || 'No message'\n    };\n    console.log('Constructor (mount)');\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('1. static getDerivedStateFromProps');\n    // Update displayMessage if message prop changes\n    if (nextProps.message !== prevState.displayMessage) {\n      return {\n        displayMessage: nextProps.message\n      };\n    }\n    return null; // No state update needed from props\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('2. shouldComponentUpdate');\n    // Return true to allow rendering for this task\n    return true;\n  }\n\n  render() {\n    console.log('3. render');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.displayMessage}</p>\n        <button onClick={() => this.setState(prevState => ({ count: prevState.count + 1 }))}>\n          Increment Count\n        </button>\n      </div>\n    );\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('4. getSnapshotBeforeUpdate');\n    // Return a simple snapshot string\n    return 'Snapshot taken: ' + prevState.count; // Example: Capture old count\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('5. componentDidUpdate');\n    console.log('Snapshot received:', snapshot);\n    if (this.props.message !== prevProps.message) {\n      console.log('Message prop changed from \"' + prevProps.message + '\" to \"' + this.props.message + '\"');\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount (cleanup)');\n  }\n}\n",
          "testCases": [
            "Initial mount: Constructor, getDerivedStateFromProps, render, componentDidMount should log in order.",
            "Clicking 'Increment Count' button: should trigger getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate.",
            "Changing `message` prop from parent component: should also trigger the update sequence and log the prop change in componentDidUpdate."
          ],
          "hints": [
            "Remember that `static getDerivedStateFromProps` does not have access to `this`.",
            "The value returned by `getSnapshotBeforeUpdate` is passed as the third argument to `componentDidUpdate`.",
            "Use `console.log` at the beginning of each method to observe the execution order clearly."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Updating Phase",
            "Logging",
            "Class Component"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_basics",
            "class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_update_lifecycle_overview",
            "static_get_derived_state_from_props",
            "should_component_update",
            "render_update_phase",
            "get_snapshot_before_update",
            "component_did_update"
          ]
        },
        {
          "id": "task_implement_gdsfp_prop_sync",
          "title": "Synchronize Internal State with Prop Changes using getDerivedStateFromProps",
          "description": "\nCreate a `ControlledInputWithReset` React class component. This component should display an input field whose value is controlled by its internal state. The internal state `inputValue` should be synchronized with a prop `externalValue`.\n\n**Requirements:**\n1.  The input's initial value should come from `externalValue` prop.\n2.  When `externalValue` prop changes, the internal `inputValue` state *must* update to reflect the new `externalValue`.\n3.  The user should be able to type into the input, and their input should update the `inputValue` state locally.\n4.  Use `static getDerivedStateFromProps` to handle the synchronization of `inputValue` with `externalValue`.\n5.  Ensure that `getDerivedStateFromProps` only updates the state when `externalValue` has actually changed, preventing unnecessary re-renders or infinite loops.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ControlledInputWithReset extends React.Component {\n  state = {\n    inputValue: '',\n  };\n\n  // TODO: Implement static getDerivedStateFromProps\n  // It should compare nextProps.externalValue with prevState.inputValue\n  // and return an object to update state or null.\n\n  handleChange = (event) => {\n    this.setState({ inputValue: event.target.value });\n  };\n\n  render() {\n    return (\n      <div>\n        <label>Input Value: </label>\n        <input\n          type=\"text\"\n          value={this.state.inputValue}\n          onChange={this.handleChange}\n        />\n        <p>Prop received: {this.props.externalValue}</p>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nclass App extends React.Component {\n  state = { parentValue: 'Hello' };\n\n  changeParentValue = () => {\n    this.setState(prevState => ({\n      parentValue: prevState.parentValue === 'Hello' ? 'World' : 'Hello'\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.changeParentValue}>Change External Value</button>\n        <ControlledInputWithReset externalValue={this.state.parentValue} />\n      </div>\n    );\n  }\n}\n// Render <App /> to test\n*/",
          "solutionCode": "import React from 'react';\n\nclass ControlledInputWithReset extends React.Component {\n  state = {\n    inputValue: this.props.externalValue || '',\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // Only update internal state if the externalValue prop has genuinely changed\n    // and is different from the current internal state (to avoid unnecessary updates).\n    if (nextProps.externalValue !== prevState.inputValue) {\n      return {\n        inputValue: nextProps.externalValue,\n      };\n    }\n    return null; // No state update needed\n  }\n\n  handleChange = (event) => {\n    this.setState({ inputValue: event.target.value });\n  };\n\n  render() {\n    return (\n      <div>\n        <label>Input Value: </label>\n        <input\n          type=\"text\"\n          value={this.state.inputValue}\n          onChange={this.handleChange}\n        />\n        <p>Prop received: {this.props.externalValue}</p>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial render: Input value should be 'Hello' if parent passes `externalValue=\"Hello\"`.",
            "User types: Typing 'XYZ' should change input to 'HelloXYZ', and `this.state.inputValue` should reflect 'HelloXYZ'.",
            "Parent changes `externalValue`: If parent changes `externalValue` from 'Hello' to 'World', the input field's value should automatically update to 'World', overriding any user input.",
            "Parent re-renders `externalValue` to same value: If `externalValue` prop is passed the same value, `getDerivedStateFromProps` should return `null` and not cause a re-render or state update.",
            "Empty `externalValue`: If `externalValue` is an empty string or undefined, input should handle it gracefully (e.g., show empty string)."
          ],
          "hints": [
            "Remember that `static getDerivedStateFromProps` is a `static` method and does not have access to `this` instance.",
            "The method should return an object to update state or `null` if no update is necessary.",
            "A critical part of the solution is comparing `nextProps.externalValue` with `prevState.inputValue` to prevent unnecessary updates or infinite loops if the prop hasn't changed.",
            "Consider how `inputValue` initially gets its value from `externalValue`."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "Controlled Component",
            "State Management",
            "Props"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_static_get_derived_state_from_props"
          ]
        },
        {
          "id": "task_optimize_component_with_scu",
          "title": "Optimize Component Re-renders with shouldComponentUpdate",
          "description": "\nCreate a `DataDisplay` React class component that receives a `data` prop (an array of objects: `{ id: number, value: string }`) and a `version` prop (a number). This component should simulate an expensive rendering process.\n\n**Requirements:**\n1.  The component should render the `data` prop as an unordered list.\n2.  Implement `shouldComponentUpdate(nextProps, nextState)` to optimize performance.\n3.  The component should **only** re-render if:\n    *   The `version` prop changes.\n    *   The *length* of the `data` array changes.\n    *   Any `value` property of an object within the `data` array changes (a shallow check is sufficient for object content, but deep check for array reference).\n4.  Add a `console.log` inside the `render` method to confirm when it actually renders.\n5.  Add a `console.log` inside `shouldComponentUpdate` to indicate why it returned `true` or `false`.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\nclass DataDisplay extends React.Component {\n  // Simulate an expensive rendering operation\n  simulateExpensiveRender() {\n    let sum = 0;\n    for (let i = 0; i < 10000000; i++) {\n      sum += Math.sqrt(i);\n    }\n    console.log(`Expensive calculation sum: ${sum.toFixed(2)}`);\n  }\n\n  // TODO: Implement shouldComponentUpdate\n  shouldComponentUpdate(nextProps, nextState) {\n    // Return true or false based on requirements\n    return true; // Default behavior\n  }\n\n  render() {\n    console.log('DataDisplay: render method called');\n    this.simulateExpensiveRender(); // Call the expensive function\n\n    return (\n      <div>\n        <h3>Data Version: {this.props.version}</h3>\n        <ul>\n          {this.props.data.map(item => (\n            <li key={item.id}>{item.value}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nclass App extends React.Component {\n  state = {\n    data: [{ id: 1, value: 'Item A' }, { id: 2, value: 'Item B' }],\n    version: 1,\n    unrelatedProp: 0\n  };\n\n  componentDidMount() {\n    setInterval(() => {\n      // This should NOT trigger a re-render of DataDisplay\n      this.setState(prevState => ({ unrelatedProp: prevState.unrelatedProp + 1 }));\n    }, 1000);\n\n    setTimeout(() => {\n      // This SHOULD trigger a re-render (version changes)\n      this.setState({ version: 2 });\n    }, 3000);\n\n    setTimeout(() => {\n      // This SHOULD trigger a re-render (data length changes)\n      this.setState(prevState => ({\n        data: [...prevState.data, { id: 3, value: 'Item C' }],\n        version: prevState.version + 1 // also change version to ensure update\n      }));\n    }, 6000);\n\n    setTimeout(() => {\n      // This SHOULD trigger a re-render (value of an item changes)\n      this.setState(prevState => ({\n        data: prevState.data.map(item => item.id === 1 ? { ...item, value: 'Updated Item A' } : item),\n        version: prevState.version + 1 // also change version to ensure update\n      }));\n    }, 9000);\n\n    setTimeout(() => {\n        // This should NOT trigger a re-render (data reference changes but content is shallowly identical)\n        this.setState(prevState => ({\n            data: prevState.data.map(item => ({...item})), // New array & new objects, but same content\n            version: prevState.version // Version is same\n        }));\n    }, 12000);\n\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Unrelated Prop: {this.state.unrelatedProp}</p>\n        <DataDisplay data={this.state.data} version={this.state.version} />\n      </div>\n    );\n  }\n}\n// Render <App /> to test\n*/",
          "solutionCode": "import React from 'react';\n\nclass DataDisplay extends React.Component {\n  // Simulate an expensive rendering operation\n  simulateExpensiveRender() {\n    let sum = 0;\n    for (let i = 0; i < 10000000; i++) {\n      sum += Math.sqrt(i);\n    }\n    console.log(`Expensive calculation sum: ${sum.toFixed(2)}`);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Check if version prop has changed\n    if (nextProps.version !== this.props.version) {\n      console.log('SCU: Returning true - version prop changed.');\n      return true;\n    }\n\n    // Check if data array length has changed\n    if (nextProps.data.length !== this.props.data.length) {\n      console.log('SCU: Returning true - data array length changed.');\n      return true;\n    }\n\n    // Check if any item's 'value' in data array has changed (shallow content comparison)\n    // Assuming order of items is stable and items are objects with 'id' and 'value'\n    for (let i = 0; i < nextProps.data.length; i++) {\n      // Check if item exists at index and its value has changed\n      if (!this.props.data[i] || nextProps.data[i].value !== this.props.data[i].value) {\n        console.log(`SCU: Returning true - data item at index ${i} value changed.`);\n        return true;\n      }\n    }\n\n    console.log('SCU: Returning false - no significant prop/state changes.');\n    return false; // No significant change, prevent re-render\n  }\n\n  render() {\n    console.log('DataDisplay: render method called');\n    this.simulateExpensiveRender(); // Call the expensive function\n\n    return (\n      <div>\n        <h3>Data Version: {this.props.version}</h3>\n        <ul>\n          {this.props.data.map(item => (\n            <li key={item.id}>{item.value}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial render: `render` should be called once.",
            "Parent changes an `unrelatedProp`: `DataDisplay`'s `render` should NOT be called (due to `shouldComponentUpdate`). Console log should indicate `SCU: Returning false`.",
            "`version` prop changes: `DataDisplay`'s `render` SHOULD be called. Console log should show `SCU: Returning true - version prop changed`.",
            "`data` array length changes: `DataDisplay`'s `render` SHOULD be called. Console log should show `SCU: Returning true - data array length changed`.",
            "An item's `value` within `data` array changes (same array length, same reference, but internal object content changes): `DataDisplay`'s `render` SHOULD be called. Console log should show `SCU: Returning true - data item at index X value changed`.",
            "`data` array reference changes, but content is shallowly identical: `DataDisplay`'s `render` should NOT be called. Console log should indicate `SCU: Returning false`.",
            "Empty `data` array: Should handle gracefully."
          ],
          "hints": [
            "Remember that `shouldComponentUpdate` receives `nextProps` and `nextState`.",
            "When comparing arrays of objects, you'll need to iterate through them. A shallow comparison of object properties is often sufficient for performance gains without going too deep.",
            "Make sure your `console.log` statements clearly indicate *why* `shouldComponentUpdate` decided to re-render or not.",
            "Consider edge cases like empty arrays.",
            "Using `PureComponent` would also implement a shallow comparison but wouldn't allow the custom logic for specific changes like `data.length` or `item.value`."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "shouldComponentUpdate",
            "Performance",
            "Optimization",
            "Code Challenge",
            "Arrays",
            "Props"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "array_methods",
            "javascript_objects"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_should_component_update",
            "pure_component"
          ]
        },
        {
          "id": "task_preserve_scroll_position",
          "title": "Preserve Scroll Position with getSnapshotBeforeUpdate",
          "description": "\nCreate a React class component `ChatWindow` that displays a list of messages. This component should handle new messages being added, especially at the top of the list, while ensuring the user's scroll position is preserved (i.e., the view doesn't jump).\n\n**Requirements:**\n1.  The `ChatWindow` component should receive an array of `messages` (strings) as a prop.\n2.  Use a `ref` to access the DOM element of the scrollable chat container.\n3.  Implement `getSnapshotBeforeUpdate(prevProps, prevState)` to capture necessary DOM information *before* the new messages are rendered.\n4.  Implement `componentDidUpdate(prevProps, prevState, snapshot)` to use the captured snapshot to adjust the scroll position, ensuring the view remains stable when new messages are added to the `messages` array from the *top*.\n5.  Add console logs to `getSnapshotBeforeUpdate` and `componentDidUpdate` to show the captured snapshot and the scroll adjustment.\n6.  The component should have `overflowY: 'scroll'` and a fixed height to enable scrolling.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\nclass ChatWindow extends React.Component {\n  chatContainerRef = React.createRef();\n\n  // Optional: Scroll to bottom on initial mount or when messages are added to bottom\n  componentDidMount() {\n    this.scrollToBottom();\n  }\n\n  scrollToBottom = () => {\n    const chatContainer = this.chatContainerRef.current;\n    if (chatContainer) {\n      chatContainer.scrollTop = chatContainer.scrollHeight;\n    }\n  };\n\n  // TODO: Implement getSnapshotBeforeUpdate\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Capture necessary information before update\n    return null; // Return snapshot or null\n  }\n\n  // TODO: Implement componentDidUpdate\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // Use snapshot to adjust scroll position\n  }\n\n  render() {\n    return (\n      <div\n        ref={this.chatContainerRef}\n        style={{\n          height: '300px',\n          overflowY: 'scroll',\n          border: '1px solid #ccc',\n          padding: '10px',\n          display: 'flex',\n          flexDirection: 'column-reverse' // To make new messages appear at top visually\n        }}\n      >\n        {this.props.messages.map((msg, index) => (\n          <div key={index} style={{ marginBottom: '5px', background: '#f0f0f0', padding: '5px' }}>\n            {msg}\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nclass App extends React.Component {\n  state = {\n    messages: Array.from({ length: 15 }, (_, i) => `Initial Message ${i + 1}`)\n  };\n\n  addMessageToTop = () => {\n    const newMessage = `New Message ${this.state.messages.length + 1}`;\n    this.setState(prevState => ({\n      messages: [newMessage, ...prevState.messages]\n    }));\n  };\n\n  addMessageToBottom = () => {\n    const newMessage = `Bottom Message ${this.state.messages.length + 1}`;\n    this.setState(prevState => ({\n      messages: [...prevState.messages, newMessage]\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.addMessageToTop}>Add Message to Top</button>\n        <button onClick={this.addMessageToBottom}>Add Message to Bottom (no scroll adjust)</button>\n        <ChatWindow messages={this.state.messages} />\n      </div>\n    );\n  }\n}\n// Render <App /> to test\n*/",
          "solutionCode": "import React from 'react';\n\nclass ChatWindow extends React.Component {\n  chatContainerRef = React.createRef();\n\n  // Optional: Scroll to bottom on initial mount or when messages are added to bottom\n  componentDidMount() {\n    this.scrollToBottom();\n  }\n\n  scrollToBottom = () => {\n    const chatContainer = this.chatContainerRef.current;\n    if (chatContainer) {\n      chatContainer.scrollTop = chatContainer.scrollHeight;\n    }\n  };\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    const chatContainer = this.chatContainerRef.current;\n\n    // Only capture snapshot if messages are being added and this is a scenario\n    // where we need to adjust scroll (e.g., adding to top).\n    // This condition checks if new messages were added and the component is scrollable.\n    if (chatContainer && this.props.messages.length > prevProps.messages.length) {\n      const scrollOffset = chatContainer.scrollHeight - chatContainer.scrollTop;\n      console.log(`getSnapshotBeforeUpdate: Captured scroll offset: ${scrollOffset}px`);\n      return scrollOffset;\n    }\n    return null; // No snapshot needed\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    const chatContainer = this.chatContainerRef.current;\n\n    // Only apply adjustment if a snapshot was captured\n    if (snapshot !== null && chatContainer) {\n      // Adjust scroll position to maintain user's view relative to the bottom\n      chatContainer.scrollTop = chatContainer.scrollHeight - snapshot;\n      console.log(`componentDidUpdate: Adjusted scroll to ${chatContainer.scrollTop}px using snapshot: ${snapshot}px`);\n    } else if (this.props.messages.length > prevProps.messages.length && snapshot === null) {\n      // If new messages are added but no snapshot was taken (e.g., adding to bottom),\n      // or it's an initial render, scroll to bottom.\n      this.scrollToBottom();\n    }\n  }\n\n  render() {\n    return (\n      <div\n        ref={this.chatContainerRef}\n        style={{\n          height: '300px',\n          overflowY: 'scroll',\n          border: '1px solid #ccc',\n          padding: '10px',\n          display: 'flex',\n          flexDirection: 'column-reverse' // To make new messages appear at top visually\n        }}\n      >\n        {/* Reverse order for chat messages: newest at bottom (but UI displays them top-down) */}\n        {/* To make messages appear at the bottom of the scroll container, and new messages push old ones up,*/}\n        {/* the flex-direction: column-reverse is used here, so the rendering order in JSX needs to be adjusted. */}\n        {/* If new messages are prepended to the array, they will appear visually at the top due to column-reverse. */}\n        {this.props.messages.slice().reverse().map((msg, index) => (\n          <div key={index} style={{ marginBottom: '5px', background: '#f0f0f0', padding: '5px' }}>\n            {msg}\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial mount: Chat window should scroll to the bottom.",
            "Add message to bottom: Chat window should scroll to the bottom to show the new message.",
            "Add message to top: Chat window's scroll position should be maintained relative to its original view (the content should shift without the scrollbar moving if you're not at the very bottom). Console logs should show snapshot capture and adjustment.",
            "No new messages, but parent re-renders: No scroll adjustment should occur, and `getSnapshotBeforeUpdate` should return `null`."
          ],
          "hints": [
            "To get the current scroll position and total scrollable height before the DOM updates, use `scrollHeight` and `scrollTop` properties of the DOM element.",
            "The snapshot should represent the 'distance from the bottom' or 'offset from the bottom' rather than a fixed `scrollTop` value, as the `scrollHeight` will change.",
            "The `flexDirection: 'column-reverse'` style is crucial for simulating chat behavior where new messages appear at the bottom but push older ones up, requiring `getSnapshotBeforeUpdate` for preservation when prepending messages.",
            "Remember to access the DOM element via `this.chatContainerRef.current`."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "DOM Manipulation",
            "Scroll",
            "Refs",
            "Chat"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "refs",
            "dom_manipulation_basics"
          ],
          "complexity": 9,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_get_snapshot_before_update",
            "theory_component_did_update"
          ]
        },
        {
          "id": "task_fetch_data_on_prop_change",
          "title": "Implement Data Fetching on Prop Change using componentDidUpdate",
          "description": "\nCreate a React class component `ProductDetail` that displays product information fetched from an API. The component should fetch data based on a `productId` prop.\n\n**Requirements:**\n1.  On initial mount, fetch product details for the given `productId`.\n2.  If the `productId` prop changes, re-fetch the new product details.\n3.  Implement loading and error states. Display 'Loading...' while fetching and an error message if the fetch fails.\n4.  Use `componentDidMount` for the initial fetch and `componentDidUpdate` for subsequent fetches.\n5.  Ensure that `componentDidUpdate` only triggers a fetch if `productId` has genuinely changed, preventing unnecessary API calls and infinite loops.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ProductDetail extends React.Component {\n  state = {\n    product: null,\n    loading: true,\n    error: null,\n  };\n\n  componentDidMount() {\n    // TODO: Initial data fetch\n  }\n\n  componentDidUpdate(prevProps) {\n    // TODO: Conditional data re-fetch based on productId prop change\n  }\n\n  fetchProductData = async (productId) => {\n    this.setState({ loading: true, error: null, product: null });\n    try {\n      // Simulate API call, replace with a real endpoint for testing\n      // Example: `https://fakestoreapi.com/products/${productId}`\n      const response = await fetch(`https://api.example.com/products/${productId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ product: data, loading: false });\n    } catch (error) {\n      console.error('Fetch error:', error);\n      this.setState({ error: error.message, loading: false });\n    }\n  };\n\n  render() {\n    const { product, loading, error } = this.state;\n    const { productId } = this.props;\n\n    if (loading) {\n      return <div>Loading product {productId} details...</div>;\n    }\n\n    if (error) {\n      return <div>Error loading product {productId}: {error}</div>;\n    }\n\n    if (!product) {\n      return <div>No product data available for ID: {productId}.</div>;\n    }\n\n    return (\n      <div>\n        <h2>{product.title}</h2>\n        <p>Category: {product.category}</p>\n        <p>Price: ${product.price}</p>\n        <img src={product.image} alt={product.title} style={{ width: '100px', height: '100px' }} />\n        <p>{product.description}</p>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nclass App extends React.Component {\n  state = { currentProductId: 1 };\n\n  changeProduct = (id) => {\n    this.setState({ currentProductId: id });\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.changeProduct(1)}>Load Product 1</button>\n        <button onClick={() => this.changeProduct(2)}>Load Product 2</button>\n        <button onClick={() => this.changeProduct(999)}>Load Non-existent Product</button>\n        <ProductDetail productId={this.state.currentProductId} />\n      </div>\n    );\n  }\n}\n// Render <App /> to test\n*/",
          "solutionCode": "import React from 'react';\n\nclass ProductDetail extends React.Component {\n  state = {\n    product: null,\n    loading: true,\n    error: null,\n  };\n\n  componentDidMount() {\n    // Initial data fetch when component mounts for the first time\n    this.fetchProductData(this.props.productId);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Only re-fetch data if the productId prop has changed\n    if (this.props.productId !== prevProps.productId) {\n      this.fetchProductData(this.props.productId);\n    }\n  }\n\n  fetchProductData = async (productId) => {\n    this.setState({ loading: true, error: null, product: null }); // Reset state before new fetch\n    try {\n      // Using a public API for demonstration: JSONPlaceholder or FakeStoreAPI\n      const response = await fetch(`https://fakestoreapi.com/products/${productId}`);\n      if (!response.ok) {\n        // For 404 or other non-200 responses, throw an error\n        throw new Error(`HTTP error! Status: ${response.status} for product ID: ${productId}`);\n      }\n      const data = await response.json();\n      this.setState({ product: data, loading: false });\n    } catch (error) {\n      console.error('Fetch error for product ID ' + productId + ':', error);\n      this.setState({ error: error.message, loading: false });\n    }\n  };\n\n  render() {\n    const { product, loading, error } = this.state;\n    const { productId } = this.props;\n\n    if (loading) {\n      return <div>Loading product {productId} details...</div>;\n    }\n\n    if (error) {\n      return <div>Error loading product {productId}: {error}</div>;\n    }\n\n    // Handle case where product might be null even if no error (e.g., initial state)\n    if (!product || Object.keys(product).length === 0) {\n        return <div>No product data found for ID: {productId}.</div>;\n    }\n\n    return (\n      <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '8px', maxWidth: '400px' }}>\n        <h2>{product.title}</h2>\n        <p style={{ color: '#555' }}>Category: {product.category}</p>\n        <p style={{ fontWeight: 'bold', fontSize: '1.2em' }}>Price: ${product.price?.toFixed(2)}</p>\n        <img src={product.image} alt={product.title} style={{ width: '100%', maxHeight: '200px', objectFit: 'contain', marginBottom: '10px' }} />\n        <p>{product.description}</p>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial mount with `productId=1`: Component should display product 1 details after loading.",
            "Change `productId` from 1 to 2: Component should show 'Loading...' then display product 2 details. No unnecessary re-fetches.",
            "Change `productId` to a non-existent ID (e.g., 999): Component should display an error message.",
            "Re-render with same `productId`: `componentDidUpdate` should not trigger a new fetch.",
            "Network error simulation: Component should display an appropriate error message (e.g., by mocking fetch or using an invalid URL)."
          ],
          "hints": [
            "Remember to clear previous data (e.g., `product: null`, `error: null`) in `fetchProductData` before making a new API call to ensure proper loading state display.",
            "The comparison `this.props.productId !== prevProps.productId` is crucial in `componentDidUpdate` to prevent infinite loops.",
            "Handle cases where the API might return an empty object or an error for non-existent IDs.",
            "Consider using a `try-catch` block within your `async` `fetchProductData` function for robust error handling."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "componentDidMount",
            "Data Fetching",
            "API",
            "State Management",
            "Error Handling",
            "Code Challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "async_js",
            "fetch_api"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_component_did_update"
          ]
        },
        {
          "id": "task_implement_conditional_state_update",
          "title": "Implement Conditional State Update in componentDidUpdate",
          "description": "\nCreate a `Scoreboard` React class component that displays a player's `score` (integer state) and a `status` message (string state). The `score` can be incremented by a button. The `status` message should update based on specific `score` thresholds.\n\n**Requirements:**\n1.  The component should have an initial `score` of 0 and an empty `status`.\n2.  Provide a button to increment the `score`.\n3.  Implement `componentDidUpdate(prevProps, prevState)`.\n4.  Inside `componentDidUpdate`, update the `status` state only when the `score` crosses these thresholds:\n    *   `score` becomes 10 or more: `status` should be \"Good Job!\"\n    *   `score` becomes 20 or more: `status` should be \"Excellent!\"\n    *   `score` becomes 30 or more: `status` should be \"Amazing!\"\n5.  Ensure that `setState` calls for `status` are strictly conditional to prevent infinite loops or redundant updates (e.g., don't set \"Good Job!\" every time `score` increases past 10, only when it *crosses* 10 from below).\n6.  Add console logs to `componentDidUpdate` to show when a status update occurs.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass Scoreboard extends React.Component {\n  state = {\n    score: 0,\n    status: '',\n  };\n\n  incrementScore = () => {\n    this.setState(prevState => ({ score: prevState.score + 1 }));\n  };\n\n  componentDidUpdate(prevProps, prevState) {\n    // TODO: Implement conditional setState for status message based on score thresholds\n    // Ensure no infinite loops and updates only when crossing threshold\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Score: {this.state.score}</h1>\n        <p>Status: {this.state.status}</p>\n        <button onClick={this.incrementScore}>Increment Score</button>\n      </div>\n    );\n  }\n}\n",
          "solutionCode": "import React from 'react';\n\nclass Scoreboard extends React.Component {\n  state = {\n    score: 0,\n    status: '',\n  };\n\n  incrementScore = () => {\n    this.setState(prevState => ({ score: prevState.score + 1 }));\n  };\n\n  componentDidUpdate(prevProps, prevState) {\n    const currentScore = this.state.score;\n    const previousScore = prevState.score;\n\n    // Check if score has increased\n    if (currentScore > previousScore) {\n      if (currentScore >= 30 && previousScore < 30) {\n        this.setState({ status: 'Amazing!' });\n        console.log(`Status updated: Amazing! (Score crossed 30 from ${previousScore})`);\n      } else if (currentScore >= 20 && previousScore < 20) {\n        this.setState({ status: 'Excellent!' });\n        console.log(`Status updated: Excellent! (Score crossed 20 from ${previousScore})`);\n      } else if (currentScore >= 10 && previousScore < 10) {\n        this.setState({ status: 'Good Job!' });\n        console.log(`Status updated: Good Job! (Score crossed 10 from ${previousScore})`);\n      }\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Score: {this.state.score}</h1>\n        <p>Status: {this.state.status}</p>\n        <button onClick={this.incrementScore}>Increment Score</button>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial state: Score 0, Status empty.",
            "Increment score from 0 to 9: Status remains empty.",
            "Increment score from 9 to 10: Status changes to 'Good Job!'. Console log confirms.",
            "Increment score from 10 to 19: Status remains 'Good Job!'. No new `setState` for status.",
            "Increment score from 19 to 20: Status changes to 'Excellent!'. Console log confirms.",
            "Increment score from 20 to 29: Status remains 'Excellent!'.",
            "Increment score from 29 to 30: Status changes to 'Amazing!'. Console log confirms.",
            "Further increments (e.g., to 35): Status remains 'Amazing!'. No new `setState` for status."
          ],
          "hints": [
            "The core of the solution lies in comparing `this.state.score` with `prevState.score`.",
            "You need to check if the score *crossed* a threshold, not just if it's *at or above* it.",
            "Order of `if/else if` statements matters for the thresholds.",
            "Avoid redundant `setState` calls by ensuring the `status` is only updated when it actually *needs* to change, not on every increment past a threshold."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "State Management",
            "Conditional Logic",
            "Performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_component_did_update"
          ]
        },
        {
          "id": "task_implement_cleanup_in_cwu",
          "title": "Implement Cleanup in componentWillUnmount",
          "description": "\nCreate a `BackgroundEffect` React class component that simulates a background animation or a continuously running process. This component should:\n\n**Requirements:**\n1.  On mounting, start a `setInterval` that logs a message to the console every 1 second (e.g., 'Background effect running...').\n2.  On mounting, add a global `mousemove` event listener to `window` that logs the mouse coordinates to the console (e.g., 'Mouse X: Y:').\n3.  Implement `componentWillUnmount()` to properly clean up **both** the `setInterval` timer and the `mousemove` event listener.\n4.  The component should display a simple message like 'Background Effect Active'.\n5.  Provide a way to mount and unmount this component (e.g., via a parent component's toggle button) to test the cleanup. Observe the console for logs disappearing upon unmount.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass BackgroundEffect extends React.Component {\n  timerId = null;\n\n  componentDidMount() {\n    console.log('BackgroundEffect: componentDidMount - Starting effects.');\n    // TODO: Start setInterval and add window.mousemove listener\n  }\n\n  handleMouseMove = (event) => {\n    console.log(`Mouse X: ${event.clientX}, Y: ${event.clientY}`);\n  };\n\n  componentWillUnmount() {\n    console.log('BackgroundEffect: componentWillUnmount - Cleaning up effects.');\n    // TODO: Clear setInterval and remove window.mousemove listener\n  }\n\n  render() {\n    return (\n      <div style={{ border: '1px dashed blue', padding: '20px', margin: '20px' }}>\n        <p>Background Effect Active. Check console for logs and move your mouse!</p>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nimport ReactDOM from 'react-dom';\n\nclass App extends React.Component {\n  state = { showEffect: true };\n\n  toggleEffect = () => {\n    this.setState(prevState => ({ showEffect: !prevState.showEffect }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.toggleEffect}>\n          {this.state.showEffect ? 'Hide Effect' : 'Show Effect'}\n        </button>\n        {this.state.showEffect && <BackgroundEffect />}\n      </div>\n    );\n  }\n}\n\n// Render <App /> to test in your environment\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/",
          "solutionCode": "import React from 'react';\n\nclass BackgroundEffect extends React.Component {\n  timerId = null;\n\n  componentDidMount() {\n    console.log('BackgroundEffect: componentDidMount - Starting effects.');\n    // Start setInterval\n    this.timerId = setInterval(() => {\n      console.log('Background effect running...');\n    }, 1000);\n\n    // Add global mousemove event listener\n    window.addEventListener('mousemove', this.handleMouseMove);\n  }\n\n  handleMouseMove = (event) => {\n    console.log(`Mouse X: ${event.clientX}, Y: ${event.clientY}`);\n  };\n\n  componentWillUnmount() {\n    console.log('BackgroundEffect: componentWillUnmount - Cleaning up effects.');\n    // Clear setInterval\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      this.timerId = null; // Good practice to nullify after clearing\n      console.log('BackgroundEffect: setInterval cleared.');\n    }\n\n    // Remove global mousemove event listener\n    window.removeEventListener('mousemove', this.handleMouseMove);\n    console.log('BackgroundEffect: mousemove listener removed.');\n  }\n\n  render() {\n    return (\n      <div style={{ border: '1px dashed blue', padding: '20px', margin: '20px' }}>\n        <p>Background Effect Active. Check console for logs and move your mouse!</p>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial mount: 'Background effect running...' logs should appear every second. Mouse coordinates should log on mouse move.",
            "Unmount component (via parent toggle): 'BackgroundEffect: componentWillUnmount - Cleaning up effects.' should log. 'Background effect running...' logs should STOP. Mouse coordinate logs should STOP. No console warnings about `setState` on unmounted components.",
            "Remount component: Effects should restart and logs should resume."
          ],
          "hints": [
            "Remember to store the ID returned by `setInterval` so you can clear it later.",
            "When removing an event listener, you must pass the exact same function reference that was used when adding it. Using an arrow function directly in `addEventListener` and `removeEventListener` can sometimes be tricky unless it's an instance method.",
            "The `handleMouseMove` method is already defined as an instance method, so `this.handleMouseMove` can be used directly for both `addEventListener` and `removeEventListener`."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "Cleanup",
            "Memory Leaks",
            "Timers",
            "Event Listeners",
            "Code Challenge"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "react_class_components",
            "javascript_timers",
            "browser_events"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_component_will_unmount"
          ]
        }
      ]
    }
  },
  {
    "id": "a06b08ae-b726-4420-b06e-425d85b96e3b",
    "startLine": 4700,
    "endLine": 4799,
    "processedDate": "2025-06-17T09:16:53.443Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_error_boundaries_overview",
          "title": "React Error Boundaries: Concept and Implementation",
          "content": "## Introduction to React Error Boundaries\nReact Error Boundaries are React components that **catch JavaScript errors** anywhere in their child component tree, **log those errors**, and **display a fallback UI** instead of the crashed component tree. They are a robust way to prevent an entire application from crashing due due to an error in a single component. Error Boundaries catch errors during:\n\n*   Rendering\n*   In lifecycle methods\n*   In constructors of the whole tree below them\n\nThey are class components that implement at least one of the two lifecycle methods: `static getDerivedStateFromError()` or `componentDidCatch()`.\n\n### Why Use Error Boundaries?\nBefore React 16, errors in components could lead to the unmounting of the entire React component tree, resulting in a blank page for the user. Error Boundaries provide a way to gracefully handle these errors, displaying a user-friendly message or fallback UI, thus improving the user experience and application resilience.\n\n### Basic Structure of an Error Boundary\nAn Error Boundary is typically a class component that maintains its own state to track whether an error has occurred in its children.\n\n```typescript\nimport React from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  errorInfo: React.ErrorInfo | null;\n}\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n}\n\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, errorInfo: null };\n  \n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    // Update state so the next render will show the fallback UI.\n    // This method is for handling errors during the render phase.\n    console.log('getDerivedStateFromError called with:', error);\n    return { hasError: true, errorInfo: null }; // errorInfo is typically null here as we only update hasError for immediate fallback\n  }\n  \n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n    // You can also log the error to an error reporting service\n    console.log('componentDidCatch called with:', error, errorInfo);\n    console.error('Error caught by Error Boundary:', error);\n    console.error('Error info:', errorInfo);\n    \n    // Update state to display error details (if desired) after the commit phase\n    this.setState({ errorInfo: errorInfo });\n    // logErrorToService(error, errorInfo); // Example of reporting to an external service\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      // Render fallback UI when an error occurs\n      return (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong.</h2>\n          {this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              <summary>Error Details</summary>\n              {/* errorInfo.componentStack provides the component stack trace */}\n              <pre>{this.state.errorInfo.componentStack}</pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    \n    // Otherwise, render children normally\n    return this.props.children;\n  }\n}\n```\n\n### Usage Example\n\n```typescript jsx\n// Using an error boundary around a component or a section of the UI\n<ErrorBoundary>\n  <MyProblematicComponent />\n</ErrorBoundary>\n\n// You can also wrap multiple components or even the entire application\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <h1>My Application</h1>\n      <MyHeader />\n      <MyContent />\n      <MyFooter />\n    </ErrorBoundary>\n  );\n}\n```\n\nBy placing an `ErrorBoundary` component around parts of your UI, you isolate potential errors. If `MyProblematicComponent` (or any of its descendants) throws an error during rendering, lifecycle methods, or constructors, the `ErrorBoundary` will catch it and display its fallback UI instead of crashing the whole application.",
          "examples": [
            {
              "id": "example_error_boundary_basic_usage",
              "title": "Basic Error Boundary and Usage",
              "code": "import React, { useState } from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  errorInfo: React.ErrorInfo | null;\n}\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n}\n\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, errorInfo: null };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    console.log('Error caught by getDerivedStateFromError:', error.message);\n    return { hasError: true, errorInfo: null };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n    console.error('Error caught by componentDidCatch:', error, errorInfo);\n    this.setState({ errorInfo: errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ padding: '20px', border: '1px solid red', color: 'red' }}>\n          <h3>Oops! Something went wrong in a child component.</h3>\n          {this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              <summary>Error Details (Click to expand)</summary>\n              <pre>{this.state.errorInfo.componentStack}</pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\nconst BuggyComponent: React.FC<{shouldThrow: boolean}> = ({ shouldThrow }) => {\n  if (shouldThrow) {\n    throw new Error('I am a simulated error from BuggyComponent!');\n  }\n  return <p>This component is working fine.</p>;\n};\n\nconst App: React.FC = () => {\n  const [showError, setShowError] = useState(false);\n\n  const triggerError = () => {\n    setShowError(true);\n  };\n\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <button onClick={triggerError}>Trigger Error</button>\n      \n      <ErrorBoundary>\n        <BuggyComponent shouldThrow={showError} />\n      </ErrorBoundary>\n\n      <p>Content outside the error boundary continues to work.</p>\n    </div>\n  );\n};\n\nexport default App;\n",
              "explanation": "This example demonstrates a complete `ErrorBoundary` component and how to use it. The `BuggyComponent` is designed to throw an error when `shouldThrow` is `true`. By wrapping `BuggyComponent` with `ErrorBoundary`, any error thrown inside `BuggyComponent` (or its descendants) is caught, and the `ErrorBoundary`'s fallback UI is rendered instead of crashing the entire `App`. The console logs show when `getDerivedStateFromError` and `componentDidCatch` are triggered.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_error_boundaries_purpose",
            "question_error_boundaries_why_class_component",
            "question_error_boundaries_catch_scope",
            "question_error_boundaries_mcq_basic_functionality"
          ],
          "relatedTasks": [
            "task_implement_error_boundary_component",
            "task_integrate_error_boundary_into_app"
          ],
          "tags": [
            "React",
            "Error Handling",
            "Class Components",
            "Component Lifecycle"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Class_Components",
            "React_State_and_Props",
            "React_Component_Lifecycle"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Robust_React_Applications",
            "Production_Ready_Frontends",
            "Advanced_React_Patterns"
          ]
        },
        {
          "id": "theory_get_derived_state_from_error",
          "title": "static getDerivedStateFromError(error)",
          "content": "## `static getDerivedStateFromError(error)` Lifecycle Method\n\nThis static method is a lifecycle hook in React class components specifically designed for error handling. It is called when a descendant component throws an error during the **render phase**.\n\n### Key Characteristics:\n\n*   **Static Method**: It's a static method, meaning it's called on the class itself, not on an instance. It does not have access to `this`.\n*   **Purpose**: Its primary purpose is to update the state of the Error Boundary component, allowing it to render a fallback UI. It receives the `error` that was thrown as its only argument.\n*   **Return Value**: It must return an object to update the state of the component, or `null` to indicate that the error has been handled and no state update is needed (though typically you'd return a state update like `{ hasError: true }`).\n*   **Render Phase**: This method is called during React's \"render phase.\" In this phase, React is calculating what changes need to be made to the DOM. Because it's purely about calculation, **side effects are not permitted** within `getDerivedStateFromError`. This means you should not perform actions like network requests, logging (beyond simple console logs for debugging), or setting timers here.\n*   **Immediate Fallback**: It's the ideal place to update state to immediately display a fallback UI, as it's called right before the render method.\n\n```typescript\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n  \n  static getDerivedStateFromError(error: Error) {\n    console.log('getDerivedStateFromError called with:', error.message);\n    // DO: Return new state based on error to show fallback UI\n    // DON'T: Cause side effects (e.g., API calls, subscriptions)\n    return { hasError: true };\n  }\n  \n  // ... rest of the component\n}\n```\n\n### The \"Render Phase\" Context\nIn React, the render phase is where React determines what changes need to be applied to the DOM. This phase can be interrupted or restarted by React (e.g., due to higher-priority updates). If side effects were allowed here, they could be executed multiple times or incompletely, leading to inconsistent or buggy behavior. `getDerivedStateFromError` is therefore restricted to pure state updates.",
          "examples": [
            {
              "id": "example_get_derived_state_from_error",
              "title": "Using getDerivedStateFromError for Fallback UI",
              "code": "import React from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n}\n\nclass SimpleErrorBoundary extends React.Component<{}, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false };\n\n  // This method is called when an error is thrown in a child component\n  // during rendering. It's a static method and doesn't have 'this'.\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    // Log the error (for development, don't do complex logging here)\n    console.log('Error caught by getDerivedStateFromError:', error.message);\n    // Update state to trigger fallback UI\n    return { hasError: true };\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>An error occurred in this section.</h1>; // Fallback UI\n    }\n    return this.props.children;\n  }\n}\n\nconst ComponentThatMightFail: React.FC<{ fail: boolean }> = ({ fail }) => {\n  if (fail) {\n    throw new Error('Oops, I failed!');\n  }\n  return <p>I am a component that can potentially fail.</p>;\n};\n\nconst App: React.FC = () => {\n  const [shouldFail, setShouldFail] = React.useState(false);\n\n  return (\n    <div>\n      <h2>getDerivedStateFromError Demo</h2>\n      <button onClick={() => setShouldFail(true)}>Make Component Fail</button>\n      <SimpleErrorBoundary>\n        <ComponentThatMightFail fail={shouldFail} />\n      </SimpleErrorBoundary>\n      <p>Application continues to run.</p>\n    </div>\n  );\n};\n\nexport default App;\n",
              "explanation": "This example showcases `getDerivedStateFromError`. When the 'Make Component Fail' button is clicked, `ComponentThatMightFail` throws an error during its render. `SimpleErrorBoundary`'s `getDerivedStateFromError` then catches it, updates `hasError` to `true`, and triggers a re-render to display the `<h1>An error occurred...</h1>` fallback, preventing the entire application from crashing.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_get_derived_state_from_error_purpose",
            "question_get_derived_state_from_error_side_effects",
            "question_error_boundary_phases",
            "question_get_derived_state_from_error_mcq_return_value"
          ],
          "relatedTasks": [
            "task_implement_error_boundary_component"
          ],
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle Methods",
            "Static Methods",
            "Render Phase"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Robust_React_Applications"
          ]
        },
        {
          "id": "theory_component_did_catch",
          "title": "componentDidCatch(error, errorInfo)",
          "content": "## `componentDidCatch(error, errorInfo)` Lifecycle Method\n\nThis lifecycle method is called after an error has been thrown by a descendant component. Unlike `getDerivedStateFromError`, `componentDidCatch` is called during React's **commit phase**.\n\n### Key Characteristics:\n\n*   **Instance Method**: It's an instance method, so it has access to `this` (the component instance).\n*   **Arguments**: It receives two arguments:\n    *   `error`: The error that was thrown.\n    *   `errorInfo`: An object with a `componentStack` property, providing information about which component caused the error, including the component stack trace.\n*   **Purpose**: This method is ideal for performing **side effects**, such as:\n    *   Logging the error to an error tracking service (e.g., Sentry, Bugsnag).\n    *   Logging to the console for debugging purposes.\n    *   Updating the component's state (e.g., to display more detailed error information to the user after the initial fallback UI is shown by `getDerivedStateFromError`).\n*   **Commit Phase**: This method is called during React's \"commit phase.\" In this phase, React has already applied all the changes to the DOM. Since the DOM updates are complete, it's safe to perform side effects here, as there's no risk of interrupting a critical rendering process.\n\n```typescript\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false, errorInfo: null };\n  \n  // ... getDerivedStateFromError method\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.log('componentDidCatch called with:', error, errorInfo);\n    // DO: Log error information, report to error tracking service\n    // Can also update state here to show more details\n    console.error('Error caught:', error);\n    console.error('Error info:', errorInfo); // errorInfo.componentStack contains the React component stack\n    \n    // Optional: update state with error details to display to the user\n    this.setState({ errorInfo: errorInfo });\n    // logErrorToService(error, errorInfo); // Example of reporting to an external service\n  }\n  \n  // ... render method\n}\n```\n\n### The `errorInfo` object\nThe `errorInfo` object provides context about where the error occurred in the React component tree. Its `componentStack` property is particularly useful as it shows the component hierarchy leading up to the error, similar to a JavaScript stack trace but specific to React components.\n\n```\n// Example of errorInfo.componentStack\n\"The above error occurred in the <BuggyComponent> component:\n    in BuggyComponent (at App.tsx:X)\n    in ErrorBoundary (at App.tsx:Y)\n    in App (at index.tsx:Z)\"\n```\n\n### Relationship with `getDerivedStateFromError`\nTypically, `getDerivedStateFromError` is used for the immediate state update (`{ hasError: true }`) to render a basic fallback UI, while `componentDidCatch` is used for side effects like logging and potentially setting more detailed error information in the state that can be displayed to the user later.",
          "examples": [
            {
              "id": "example_component_did_catch_logging",
              "title": "Using componentDidCatch for Error Logging and Details",
              "code": "import React from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n  errorInfo: React.ErrorInfo | null;\n}\n\nclass LoggingErrorBoundary extends React.Component<{}, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, error: null, errorInfo: null };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    console.log('getDerivedStateFromError triggered.');\n    return { hasError: true, error: error, errorInfo: null }; // Set hasError for immediate fallback\n  }\n\n  // This method is called after the error has been thrown and after the render phase.\n  // It's safe to perform side effects here.\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n    console.log('componentDidCatch triggered.');\n    // Log the error to an external service (simulated)\n    console.error('External Logging Service: Error Caught!', error, errorInfo.componentStack);\n    \n    // Update state to show detailed error info in the UI (optional)\n    this.setState({ errorInfo: errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ padding: '20px', border: '1px solid blue', color: 'blue' }}>\n          <h3>A critical error occurred.</h3>\n          {this.state.error && <p>Error message: {this.state.error.message}</p>}\n          {this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              <summary>Technical Details</summary>\n              <pre>{this.state.errorInfo.componentStack}</pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\nconst RiskyComponent: React.FC<{ trigger: boolean }> = ({ trigger }) => {\n  if (trigger) {\n    throw new Error('This component failed intentionally during render!');\n  }\n  return <p>This risky component is running smoothly.</p>;\n};\n\nconst App: React.FC = () => {\n  const [shouldTrigger, setShouldTrigger] = React.useState(false);\n\n  return (\n    <div>\n      <h2>componentDidCatch Demo</h2>\n      <button onClick={() => setShouldTrigger(true)}>Trigger Risky Component Error</button>\n      <LoggingErrorBoundary>\n        <RiskyComponent trigger={shouldTrigger} />\n      </LoggingErrorBoundary>\n    </div>\n  );\n};\n\nexport default App;\n",
              "explanation": "This example demonstrates `componentDidCatch`'s role in logging errors and optionally updating state with more detailed `errorInfo`. When `RiskyComponent` throws, `getDerivedStateFromError` sets `hasError`, and then `componentDidCatch` is called. Inside `componentDidCatch`, the error and `errorInfo.componentStack` are logged to the console (simulating an external logging service). The `ErrorBoundary` then renders its fallback, including the detailed `componentStack` for the user to view if they choose to expand the details.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_component_did_catch_purpose",
            "question_component_did_catch_side_effects",
            "question_error_info_object",
            "question_error_boundary_phases",
            "question_mcq_get_derived_state_from_error_vs_component_did_catch"
          ],
          "relatedTasks": [
            "task_implement_error_boundary_component",
            "task_integrate_error_boundary_with_logging"
          ],
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle Methods",
            "Side Effects",
            "Commit Phase",
            "Error Logging"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods",
            "React_State_and_Props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Production_Ready_React_Applications",
            "Debugging_React"
          ]
        },
        {
          "id": "theory_error_boundary_limitations",
          "title": "Important Limitations of React Error Boundaries",
          "content": "## When Error Boundaries DO NOT Catch Errors\n\nWhile powerful, React Error Boundaries are not omnipotent and have specific limitations. It's crucial to understand these scenarios where they will *not* catch errors:\n\n1.  **Event Handlers**: Errors thrown inside event handlers (e.g., `onClick`, `onChange`, `onSubmit`) are *not* caught by Error Boundaries. This is because event handlers are asynchronous and are not part of React's render or commit phases where Error Boundaries operate. For errors in event handlers, you should use standard JavaScript `try/catch` blocks.\n\n    ```typescript jsx\n    function MyComponent() {\n      const handleClick = () => {\n        try {\n          // Error here will NOT be caught by Error Boundary\n          throw new Error('Error in event handler!');\n        } catch (error) {\n          console.error('Caught by try/catch:', error);\n          // You can then update local state or re-throw if needed\n        }\n      };\n\n      return <button onClick={handleClick}>Click Me</button>;\n    }\n\n    // ... wrapped by ErrorBoundary\n    // <ErrorBoundary><MyComponent /></ErrorBoundary>\n    ```\n\n2.  **Asynchronous Code**: Errors in `setTimeout`, `requestAnimationFrame` callbacks, or any other asynchronous code (like `Promise.then()` or `async/await` blocks) are not caught by Error Boundaries. These operations execute outside of React's render/commit cycle.\n\n    ```typescript jsx\n    function AsyncComponent() {\n      React.useEffect(() => {\n        setTimeout(() => {\n          // Error here will NOT be caught by Error Boundary\n          throw new Error('Error in setTimeout!');\n        }, 1000);\n      }, []);\n      return <p>I'm an async component.</p>;\n    }\n\n    // ... wrapped by ErrorBoundary\n    // <ErrorBoundary><AsyncComponent /></ErrorBoundary>\n    ```\n\n3.  **Errors in the Error Boundary Itself**: An Error Boundary cannot catch errors that occur within itself. If the `render` method, `getDerivedStateFromError`, or `componentDidCatch` method of the Error Boundary component itself throws an error, React will propagate that error up the tree. To catch errors in an Error Boundary, you would need a parent Error Boundary, but this is usually not recommended and suggests an issue with the Error Boundary's implementation.\n\n4.  **Server-Side Rendering (SSR)**: Error Boundaries currently only work for client-side rendering. Errors during SSR are handled differently, typically by the server-side framework.\n\n### Consequences of Uncaught Errors\nAs of React 16, if an error is thrown in a component and is *not* caught by any Error Boundary, React will **unmount the entire React component tree**. This results in a blank page for the user, which is a very poor user experience. This behavior highlights the importance of strategically placing Error Boundaries to contain errors and preserve the rest of the application's functionality.",
          "examples": [
            {
              "id": "example_error_boundary_limitations_event_handler",
              "title": "Error in Event Handler (Not Caught by Error Boundary)",
              "code": "import React, { useState } from 'react';\n\nclass MyErrorBoundary extends React.Component<{}, { hasError: boolean }> {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error: Error) {\n    console.log('ErrorBoundary: getDerivedStateFromError caught an error:', error.message);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Error Boundary: componentDidCatch caught an error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1 style={{color: 'red'}}>Something went wrong in rendering children!</h1>;\n    }\n    return this.props.children;\n  }\n}\n\nconst ComponentWithEventHandlerError: React.FC = () => {\n  const [clicked, setClicked] = useState(false);\n\n  const handleClick = () => {\n    setClicked(true);\n    // This error is NOT caught by the ErrorBoundary\n    throw new Error('Error inside button onClick handler!');\n  };\n\n  if (clicked) {\n    return <p>Component was clicked. Check console for uncaught error!</p>;\n  }\n  return <button onClick={handleClick}>Click to trigger event handler error</button>;\n};\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <h2>Error Boundary Limitations Demo: Event Handlers</h2>\n      <MyErrorBoundary>\n        <ComponentWithEventHandlerError />\n      </MyErrorBoundary>\n      <p>Content below Error Boundary.</p>\n    </div>\n  );\n};\n\nexport default App;\n",
              "explanation": "This example demonstrates that errors in event handlers are not caught by Error Boundaries. When the button is clicked, `handleClick` throws an error. You'll observe that the `MyErrorBoundary`'s `getDerivedStateFromError` and `componentDidCatch` methods are *not* called. Instead, the error will propagate up and typically be caught by the browser's global error handler, or it will unmount the whole React tree if not handled by a global error listener, leading to a blank screen or a visible uncaught error in the console, depending on the environment.",
              "language": "typescript"
            },
            {
              "id": "example_error_boundary_limitations_async_code",
              "title": "Error in Asynchronous Code (Not Caught by Error Boundary)",
              "code": "import React, { useEffect, useState } from 'react';\n\nclass MyErrorBoundary extends React.Component<{}, { hasError: boolean }> {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error: Error) {\n    console.log('ErrorBoundary: getDerivedStateFromError caught an error:', error.message);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Error Boundary: componentDidCatch caught an error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1 style={{color: 'orange'}}>Something went wrong in rendering children!</h1>;\n    }\n    return this.props.children;\n  }\n}\n\nconst ComponentWithAsyncError: React.FC = () => {\n  const [triggered, setTriggered] = useState(false);\n\n  useEffect(() => {\n    if (triggered) {\n      console.log('Attempting to trigger async error in 1 second...');\n      setTimeout(() => {\n        // This error is NOT caught by the ErrorBoundary\n        throw new Error('Error from async setTimeout!');\n      }, 1000);\n    }\n  }, [triggered]);\n\n  return (\n    <div>\n      <p>Component with async operation.</p>\n      <button onClick={() => setTriggered(true)}>Trigger Async Error (after 1s)</button>\n    </div>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <h2>Error Boundary Limitations Demo: Asynchronous Code</h2>\n      <MyErrorBoundary>\n        <ComponentWithAsyncError />\n      </MyErrorBoundary>\n      <p>Content below Error Boundary.</p>\n    </div>\n  );\n};\n\nexport default App;\n",
              "explanation": "This example shows that errors thrown within asynchronous code (like `setTimeout`) are also not caught by Error Boundaries. After clicking the button, a `setTimeout` is initiated. One second later, an error is thrown inside its callback. Similar to event handlers, `MyErrorBoundary` does not intercept this error, and it propagates globally, likely resulting in a browser-level uncaught error.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_error_boundary_limitations_mcq",
            "question_error_boundary_uncaught_behavior",
            "question_error_handling_event_handlers",
            "question_error_handling_async_code",
            "question_error_boundary_self_error"
          ],
          "relatedTasks": [
            "task_handle_errors_outside_boundaries"
          ],
          "tags": [
            "React",
            "Error Handling",
            "Limitations",
            "Event Handlers",
            "Asynchronous JavaScript",
            "try-catch"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Component_Lifecycle",
            "JavaScript_Event_Loop",
            "JavaScript_Promises"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Production_Ready_React_Applications",
            "Debugging_Complex_Applications"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_error_boundaries_purpose",
          "topic": "React Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a React Error Boundary?",
          "answer": "To catch JavaScript errors in child components, log them, and display a fallback UI instead of crashing the entire application.",
          "analysisPoints": [
            "Identifies core function: catching errors.",
            "Highlights key outcomes: logging and fallback UI.",
            "Emphasizes benefit: preventing application crash."
          ],
          "keyConcepts": [
            "Error Handling",
            "Fallback UI",
            "Application Resilience"
          ],
          "evaluationCriteria": [
            "Basic understanding of Error Boundaries' role."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Basic"
          ],
          "prerequisites": [
            "React_Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundaries_why_class_component",
          "topic": "React Error Boundaries",
          "level": "medium",
          "type": "open",
          "question": "Why must a React Error Boundary be a class component, and what specific lifecycle methods are crucial for its functionality?",
          "answer": "Error Boundaries must be class components because the specific lifecycle methods required to catch errors, `static getDerivedStateFromError(error)` and `componentDidCatch(error, errorInfo)`, are currently only available in class components. Functional components and Hooks (like `useEffect` or `useState`) cannot directly implement this error-catching mechanism.",
          "analysisPoints": [
            "Correctly identifies the necessity of class components.",
            "Names the two key lifecycle methods for error handling.",
            "Explains that these methods are exclusive to class components (as of current React versions, though hooks for error boundaries are a frequent discussion point)."
          ],
          "keyConcepts": [
            "Class Components",
            "Lifecycle Methods",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Understanding of React component types and their capabilities.",
            "Knowledge of specific Error Boundary lifecycle methods."
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Error Handling",
            "Lifecycle Methods"
          ],
          "prerequisites": [
            "React_Class_Components",
            "React_Functional_Components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_get_derived_state_from_error_purpose",
          "topic": "getDerivedStateFromError",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of `static getDerivedStateFromError(error)` in an Error Boundary?",
          "answer": "Its primary role is to update the component's state to indicate that an error has occurred (`hasError: true`), allowing the next render cycle to display a fallback UI. It's called during the render phase and should not cause side effects.",
          "analysisPoints": [
            "Focuses on state update for fallback UI.",
            "Mentions 'render phase'.",
            "Highlights the 'no side effects' rule."
          ],
          "keyConcepts": [
            "Lifecycle Methods",
            "Render Phase",
            "State Update",
            "No Side Effects"
          ],
          "evaluationCriteria": [
            "Understanding of `getDerivedStateFromError`'s specific use case."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle Methods",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Lifecycle_Methods"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_get_derived_state_from_error_side_effects",
          "topic": "getDerivedStateFromError",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `static getDerivedStateFromError(error)` method in a React Error Boundary. Which of the following operations is **NOT** permissible within this method?",
          "answer": "Making an API call to log the error to a remote service.",
          "options": [
            "Returning an object to update the component's state.",
            "Logging the error to the console using `console.log()`.",
            "Setting a boolean flag in the component's state to `true`.",
            "Making an API call to log the error to a remote service."
          ],
          "analysisPoints": [
            "Tests knowledge of side effect restrictions in the render phase.",
            "Distinguishes between permissible (pure state updates, simple logging) and impermissible (API calls, subscriptions) actions.",
            "Reinforces understanding of React's lifecycle phases."
          ],
          "keyConcepts": [
            "Render Phase",
            "Side Effects",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Ability to identify correct and incorrect actions within a specific lifecycle method."
          ],
          "example": "The `static getDerivedStateFromError` method is called during React's 'render phase', which is a pure phase where React calculates what changes to make. Performing side effects like network requests (API calls) within this phase can lead to inconsistencies, bugs, or multiple executions if React re-renders. State updates and simple console logs are acceptable as they don't cause external changes or break the purity of the render phase.",
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle Methods",
            "MCQ"
          ],
          "prerequisites": [
            "React_Lifecycle_Methods",
            "React_Render_Phase"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_component_did_catch_purpose",
          "topic": "componentDidCatch",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main responsibility of `componentDidCatch(error, errorInfo)` in an Error Boundary?",
          "answer": "Its main responsibility is to perform side effects after an error has been caught, such as logging the error to an external service or updating the component's state with detailed error information.",
          "analysisPoints": [
            "Highlights 'side effects' as its core purpose.",
            "Provides examples of common side effects (logging, state update for details).",
            "Distinguishes it from `getDerivedStateFromError`'s primary role."
          ],
          "keyConcepts": [
            "Lifecycle Methods",
            "Commit Phase",
            "Side Effects",
            "Error Logging"
          ],
          "evaluationCriteria": [
            "Understanding of `componentDidCatch`'s specific use case."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle Methods",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Lifecycle_Methods"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_component_did_catch_side_effects",
          "topic": "componentDidCatch",
          "level": "medium",
          "type": "open",
          "question": "Explain why `componentDidCatch` is the appropriate place for side effects like logging errors to an analytics service, while `getDerivedStateFromError` is not.",
          "answer": "`getDerivedStateFromError` is called during the 'render phase', a pure phase where React computes what changes to make to the DOM. Performing side effects here is dangerous because React might pause, abandon, or restart this phase, leading to inconsistent or repeated side effects. \n\n`componentDidCatch`, on the other hand, is called during the 'commit phase', after React has already updated the DOM. At this point, the changes are committed, and it's safe to perform side effects like network requests (e.g., logging errors to a service) or updating the component's state, without interfering with the rendering process.",
          "analysisPoints": [
            "Clearly defines render vs. commit phases.",
            "Explains the implications of side effects in each phase.",
            "Connects the phase behavior directly to the suitability of each method for side effects."
          ],
          "keyConcepts": [
            "Render Phase",
            "Commit Phase",
            "Side Effects",
            "Lifecycle Methods",
            "Error Logging"
          ],
          "evaluationCriteria": [
            "Deep understanding of React's rendering pipeline and lifecycle phases.",
            "Ability to articulate reasons for design choices."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle Methods",
            "Advanced"
          ],
          "prerequisites": [
            "React_Lifecycle_Methods",
            "React_Phases_and_Render_Process"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_error_info_object",
          "topic": "componentDidCatch",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the significance of the `errorInfo` object passed to `componentDidCatch`, and what key property does it contain?",
          "answer": "The `errorInfo` object provides additional information about where the error occurred in the component tree. Its key property is `componentStack`, which offers a React-specific stack trace, detailing the component hierarchy that led to the error.",
          "analysisPoints": [
            "Defines `errorInfo`'s purpose.",
            "Identifies `componentStack` as the crucial property.",
            "Explains `componentStack`'s utility (React-specific trace)."
          ],
          "keyConcepts": [
            "Error Information",
            "Stack Trace",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Knowledge of `componentDidCatch` arguments and their utility."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Debugging",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Error_Boundaries"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_limitations_mcq",
          "topic": "Error Boundary Limitations",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios will a React Error Boundary **NOT** catch an error?",
          "answer": "An error thrown inside a `setTimeout` callback function within a component.",
          "options": [
            "An error occurring during the `render` method of a child component.",
            "An error thrown inside a `setTimeout` callback function within a component.",
            "An error occurring in the constructor of a deeply nested child component.",
            "An error in a child component's `componentDidMount` lifecycle method."
          ],
          "analysisPoints": [
            "Tests understanding of the boundaries of error boundary's error catching.",
            "Distinguishes between synchronous React lifecycle errors (caught) and asynchronous JS errors (not caught).",
            "Reinforces knowledge of what 'out of React's rendering cycle' means."
          ],
          "keyConcepts": [
            "Error Handling Limitations",
            "Asynchronous Code",
            "Event Handlers"
          ],
          "evaluationCriteria": [
            "Ability to identify common scenarios where Error Boundaries are ineffective.",
            "Distinguishing between React lifecycle and general JavaScript execution."
          ],
          "example": "Error Boundaries are designed to catch errors that occur during React's rendering process, including render methods, constructors, and synchronous lifecycle methods (like `componentDidMount` and `componentDidUpdate`). However, they do not catch errors in asynchronous code (like `setTimeout`, `Promises`) or in event handlers, because these execute outside of the React component tree's rendering and commit phases. For such cases, standard JavaScript `try/catch` blocks are required.",
          "tags": [
            "React",
            "Error Handling",
            "Limitations",
            "MCQ"
          ],
          "prerequisites": [
            "React_Error_Boundaries",
            "JavaScript_Event_Loop"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_uncaught_behavior",
          "topic": "Error Boundary Limitations",
          "level": "medium",
          "type": "open",
          "question": "What happens if a React component throws an error and there is no Error Boundary to catch it in its parent tree (as of React 16 and later)? How does this impact user experience?",
          "answer": "As of React 16 and later, if an error is thrown in a component and is not caught by any Error Boundary in its parent tree, React will **unmount the entire React component tree**. This leads to a blank page for the user, providing a very poor and uninformative user experience, as the application appears completely broken with no feedback.",
          "analysisPoints": [
            "Accurately describes the unmounting behavior.",
            "Highlights the negative user experience (blank page).",
            "Emphasizes the severity of unhandled errors."
          ],
          "keyConcepts": [
            "Uncaught Errors",
            "Application Crash",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Understanding the consequence of not using Error Boundaries.",
            "Awareness of modern React's error handling philosophy."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Consequences",
            "User Experience"
          ],
          "prerequisites": [
            "React_Error_Boundaries"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_handling_event_handlers",
          "topic": "Error Boundary Limitations",
          "level": "medium",
          "type": "code",
          "question": "An Error Boundary does not catch errors in event handlers. Write a simple React functional component that has a button. When the button is clicked, an error should be thrown in its `onClick` handler. Demonstrate how to gracefully handle this error using a standard JavaScript mechanism, ensuring the component doesn't crash the entire app if clicked.",
          "answer": "```typescript jsx\nimport React from 'react';\n\nconst ComponentWithSafeEventHandler: React.FC = () => {\n  const handleClick = () => {\n    try {\n      // This error will be caught by the try/catch block, not an Error Boundary\n      throw new Error('Simulated error in event handler!');\n    } catch (error: any) {\n      console.error('Error caught locally in event handler:', error.message);\n      alert(`An error occurred: ${error.message}. Check console.`);\n      // You could also update component state here to display an error message in the UI\n    }\n  };\n\n  return (\n    <div>\n      <h3>Event Handler Error Demo</h3>\n      <button onClick={handleClick}>\n        Click to trigger an error in handler (handled locally)\n      </button>\n      <p>This component remains functional because the error is caught within the handler itself.</p>\n    </div>\n  );\n};\n\nexport default ComponentWithSafeEventHandler;\n```",
          "analysisPoints": [
            "Correctly identifies `try/catch` as the solution for event handler errors.",
            "Implements a functional component with an event handler.",
            "Demonstrates a `throw new Error()` inside the handler.",
            "Uses `try/catch` to prevent the error from propagating.",
            "Provides feedback (console.error, alert) to show the error was handled."
          ],
          "keyConcepts": [
            "Error Handling",
            "Event Handlers",
            "try-catch",
            "JavaScript Basics"
          ],
          "evaluationCriteria": [
            "Ability to apply `try/catch` for specific error scenarios.",
            "Understanding of event handler execution context."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "JavaScript",
            "Code Challenge"
          ],
          "prerequisites": [
            "React_Event_Handling",
            "JavaScript_Error_Handling"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_self_error",
          "topic": "Error Boundary Limitations",
          "level": "hard",
          "type": "open",
          "question": "Can an Error Boundary catch an error that occurs within its own `render` method or one of its lifecycle methods? If not, what is the recommended way to handle such a scenario, and why is this design choice made?",
          "answer": "No, an Error Boundary cannot catch errors that occur within itself (i.e., its own `render` method, `static getDerivedStateFromError`, or `componentDidCatch`). If an error is thrown within the Error Boundary component itself, it will propagate up the component tree to the next nearest Error Boundary (if one exists) or cause the entire React tree to unmount.\n\nThe recommended way to handle such a scenario is to ensure that your Error Boundary itself is **robust and doesn't contain logic that can easily fail**. If an Error Boundary is failing, it suggests a fundamental flaw in its implementation. It should be a simple, highly reliable component whose sole purpose is to catch errors from its children and render a fallback.\n\nThis design choice is made to prevent infinite loops or unrecoverable states. If an Error Boundary could catch its own errors, it might enter a loop where it keeps trying to render a fallback, failing, catching its own error, and trying again. By preventing self-catching, React forces developers to ensure their error handling mechanism itself is sound, promoting stability.",
          "analysisPoints": [
            "Clearly states that Error Boundaries cannot self-catch.",
            "Explains the propagation behavior for self-errors.",
            "Provides the recommended approach: make the Error Boundary robust and simple.",
            "Justifies the design choice (preventing infinite loops/unrecoverable states).",
            "Demonstrates a deeper understanding of React's error handling philosophy."
          ],
          "keyConcepts": [
            "Error Boundary Design",
            "Robustness",
            "Self-Correction",
            "React Philosophy"
          ],
          "evaluationCriteria": [
            "Understanding of advanced error boundary behavior.",
            "Ability to articulate design principles."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Design Patterns",
            "Architecture"
          ],
          "prerequisites": [
            "React_Error_Boundaries",
            "Software_Design_Principles"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_mcq_get_derived_state_from_error_vs_component_did_catch",
          "topic": "getDerivedStateFromError vs componentDidCatch",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements accurately describes the primary difference between `static getDerivedStateFromError()` and `componentDidCatch()` in a React Error Boundary?",
          "answer": "`getDerivedStateFromError` is for rendering a fallback UI during the render phase, while `componentDidCatch` is for performing side effects like logging during the commit phase.",
          "options": [
            "`getDerivedStateFromError` is for logging errors, while `componentDidCatch` is for updating state.",
            "`getDerivedStateFromError` runs after the component renders, while `componentDidCatch` runs before.",
            "`getDerivedStateFromError` is for rendering a fallback UI during the render phase, while `componentDidCatch` is for performing side effects like logging during the commit phase.",
            "Both methods serve the exact same purpose and can be used interchangeably."
          ],
          "analysisPoints": [
            "Clearly differentiates the purpose of each method.",
            "Correctly identifies the lifecycle phase for each method.",
            "Highlights the side-effect allowance in `componentDidCatch` and restriction in `getDerivedStateFromError`."
          ],
          "keyConcepts": [
            "Lifecycle Methods",
            "Render Phase",
            "Commit Phase",
            "Side Effects",
            "State Management"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between similar but distinct lifecycle methods.",
            "Understanding of their specific roles and constraints."
          ],
          "example": "`getDerivedStateFromError` is a static method that returns a state object to update the component's state, primarily used to set a flag like `hasError: true` so the `render` method can switch to a fallback UI. It operates in the render phase, meaning no side effects. `componentDidCatch` is an instance method called after the error has been thrown and React has committed changes. It's the place for side effects like sending error reports to a server or updating state with more detailed error information, as it operates in the commit phase, where side effects are safe.",
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle Methods",
            "MCQ",
            "Comparison"
          ],
          "prerequisites": [
            "React_Lifecycle_Methods"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_flashcard_definition",
          "topic": "React Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "Define 'Error Boundary' in React.",
          "answer": "An Error Boundary is a React class component that gracefully catches JavaScript errors within its child component tree, logs them, and displays a fallback UI instead of crashing the entire application.",
          "analysisPoints": [
            "Concise definition.",
            "Mentions key characteristics: class component, error catching, logging, fallback UI."
          ],
          "keyConcepts": [
            "Error Handling",
            "Class Components",
            "Fallback UI"
          ],
          "evaluationCriteria": [
            "Basic recall of definition."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Definition",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundary_flashcard_methods",
          "topic": "React Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "Name the two lifecycle methods required to implement a React Error Boundary.",
          "answer": "`static getDerivedStateFromError(error)` and `componentDidCatch(error, errorInfo)`.",
          "analysisPoints": [
            "Correctly lists both required methods.",
            "Demonstrates basic recall."
          ],
          "keyConcepts": [
            "Lifecycle Methods",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Recall of key methods."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle Methods",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Lifecycle_Methods"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundary_flashcard_event_handlers",
          "topic": "Error Boundary Limitations",
          "level": "medium",
          "type": "flashcard",
          "question": "Do React Error Boundaries catch errors in event handlers? If not, what should be used?",
          "answer": "No, React Error Boundaries do not catch errors in event handlers. Standard JavaScript `try/catch` blocks should be used for error handling within event handlers.",
          "analysisPoints": [
            "Correctly states the limitation.",
            "Provides the appropriate alternative solution."
          ],
          "keyConcepts": [
            "Error Handling Limitations",
            "Event Handlers",
            "try-catch"
          ],
          "evaluationCriteria": [
            "Recall of a key limitation and its workaround."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Limitations",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Error_Boundaries"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_flashcard_async_code",
          "topic": "Error Boundary Limitations",
          "level": "medium",
          "type": "flashcard",
          "question": "Can React Error Boundaries catch errors in asynchronous code like `setTimeout` or Promises?",
          "answer": "No, React Error Boundaries do not catch errors in asynchronous code because such code executes outside of React's rendering and commit phases.",
          "analysisPoints": [
            "Correctly states the limitation.",
            "Provides the reason for the limitation (outside React's phases)."
          ],
          "keyConcepts": [
            "Error Handling Limitations",
            "Asynchronous Code"
          ],
          "evaluationCriteria": [
            "Recall of a key limitation and its reasoning."
          ],
          "example": null,
          "tags": [
            "React",
            "Error Handling",
            "Limitations",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Error_Boundaries",
            "JavaScript_Async"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_error_boundary_component",
          "title": "Implement a Reusable React Error Boundary Component",
          "description": "\nImplement a `ErrorBoundary` class component in React that fulfills the following requirements:\n\n1.  It should catch JavaScript errors in its child component tree during rendering, lifecycle methods, and constructors.\n2.  It must implement `static getDerivedStateFromError(error)` to update its state to indicate an error has occurred, enabling it to render a fallback UI.\n3.  It must implement `componentDidCatch(error, errorInfo)` to log the error and its `componentStack` to the console (simulating logging to an external service).\n4.  When an error is caught, it should display a generic \"Something went wrong.\" message as a fallback UI.\n5.  Optionally, the fallback UI should include a 'Details' section that, when expanded, shows the `componentStack` from `errorInfo`.\n6.  Provide a simple `BuggyComponent` that throws an error conditionally to test your `ErrorBoundary`.\n7.  Wrap the `BuggyComponent` with your `ErrorBoundary` in an `App` component to demonstrate its usage.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// --- ErrorBoundary Component (Your task to complete) ---\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  errorInfo: React.ErrorInfo | null;\n}\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n}\n\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, errorInfo: null };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    // TODO: Implement this method to update state for fallback UI\n    return { hasError: true, errorInfo: null };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n    // TODO: Implement this method for logging and optional detailed state update\n    console.error('Caught by Error Boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // TODO: Render fallback UI\n      return (\n        <div style={{ padding: '20px', border: '1px solid red', color: 'red' }}>\n          <h3>Something went wrong.</h3>\n          {/* Optional: display errorInfo.componentStack here */}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n// -----------------------------------------------------\n\n// --- BuggyComponent (Provided) ---\nconst BuggyComponent: React.FC<{ shouldThrow: boolean }> = ({ shouldThrow }) => {\n  if (shouldThrow) {\n    throw new Error('This is a simulated error from BuggyComponent.');\n  }\n  return <p>This component is working normally.</p>;\n};\n// -----------------------------------------------------\n\n// --- App Component (Your task to complete) ---\nconst App: React.FC = () => {\n  const [triggerError, setTriggerError] = useState(false);\n\n  return (\n    <div>\n      <h1>Error Boundary Implementation Task</h1>\n      <button onClick={() => setTriggerError(true)}>\n        Trigger Error in Buggy Component\n      </button>\n      \n      {/* TODO: Wrap BuggyComponent with your ErrorBoundary */}\n      <div>\n        <BuggyComponent shouldThrow={triggerError} />\n      </div>\n\n      <p>Content below the potentially failing component.</p>\n    </div>\n  );\n};\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  errorInfo: React.ErrorInfo | null;\n}\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n}\n\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, errorInfo: null };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    // Update state so the next render will show the fallback UI.\n    // This method is for handling errors during the render phase.\n    console.log('getDerivedStateFromError called:', error.message);\n    return { hasError: true, errorInfo: null }; // Set hasError, errorInfo can be null initially\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n    // You can also log the error to an error reporting service here\n    console.error('Error caught by Error Boundary:', error);\n    console.error('Error info (componentStack):', errorInfo.componentStack);\n    \n    // Update state to display error details (if desired) after the commit phase\n    this.setState({ errorInfo: errorInfo });\n    // logErrorToService(error, errorInfo); // Example of reporting to an external service\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Render fallback UI when an error occurs\n      return (\n        <div className=\"error-boundary\" style={{ padding: '20px', border: '1px solid red', color: 'red', backgroundColor: '#ffe6e6' }}>\n          <h2>Something went wrong.</h2>\n          {this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap', marginTop: '10px' }}>\n              <summary>Error Details (Click to expand)</summary>\n              <pre style={{ margin: '5px 0', fontSize: '0.8em', lineHeight: '1.4em' }}>\n                {this.state.errorInfo.componentStack}\n              </pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    \n    // Otherwise, render children normally\n    return this.props.children;\n  }\n}\n\nconst BuggyComponent: React.FC<{ shouldThrow: boolean }> = ({ shouldThrow }) => {\n  if (shouldThrow) {\n    // Simulate an error during render\n    throw new Error('This is a simulated error from BuggyComponent.');\n  }\n  return <p>This component is working normally.</p>;\n};\n\nconst App: React.FC = () => {\n  const [triggerError, setTriggerError] = useState(false);\n\n  return (\n    <div>\n      <h1>Error Boundary Implementation Task</h1>\n      <button onClick={() => setTriggerError(true)}>\n        Trigger Error in Buggy Component\n      </button>\n      \n      <ErrorBoundary>\n        <BuggyComponent shouldThrow={triggerError} />\n      </ErrorBoundary>\n\n      <p>Content below the potentially failing component (should remain visible).</p>\n    </div>\n  );\n};\n\nexport default App;\n",
          "testCases": [
            "Initial render: `BuggyComponent` should render normally, `ErrorBoundary` should show its children.",
            "Trigger error: Clicking the button should cause `BuggyComponent` to throw an error.",
            "Fallback UI: `ErrorBoundary` should catch the error and display its fallback UI with \"Something went wrong.\".",
            "Console logs: `getDerivedStateFromError` and `componentDidCatch` should log messages to the console.",
            "Error details: If implemented, expanding the 'Details' in the fallback UI should show the `componentStack`."
          ],
          "hints": [
            "Remember that `static getDerivedStateFromError` is a static method and doesn't have `this` context. It should only return a state object.",
            "`componentDidCatch` is an instance method, so `this` is available. It's the right place for side effects like logging.",
            "Make sure your `BuggyComponent`'s error throwing mechanism is tied to a state change (e.g., via a button click) to clearly demonstrate the boundary's effect."
          ],
          "tags": [
            "React",
            "Error Handling",
            "Class Components",
            "Lifecycle Methods",
            "Testing"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods",
            "React_State_and_Props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "React_Error_Boundaries_Overview",
            "get_derived_state_from_error",
            "component_did_catch"
          ]
        },
        {
          "id": "task_integrate_error_boundary_into_app",
          "title": "Integrate Error Boundaries Strategically in a Simulated Application",
          "description": "\nGiven a small React application with multiple components, integrate the `ErrorBoundary` component (from the previous task or provided) strategically to enhance error resilience. The application structure is as follows:\n\n`App`\n  `Header`\n  `MainContent`\n    `WidgetA` (might fail)\n    `WidgetB`\n  `Footer`\n\nYour tasks are:\n\n1.  Create a basic `ErrorBoundary` component (if not already done).\n2.  Implement `WidgetA` such that it can conditionally throw an error (e.g., when a button inside it is clicked, or based on a prop).\n3.  Wrap `WidgetA` individually with an `ErrorBoundary` so that its failure does not affect `WidgetB` or other parts of `MainContent`.\n4.  Also, wrap the entire `MainContent` component with *another* `ErrorBoundary`. This boundary should catch any errors from `WidgetB` or other direct children of `MainContent`.\n5.  Ensure that an error in `WidgetA` only shows the fallback for `WidgetA`, while an error in `WidgetB` shows the fallback for the entire `MainContent` area.\n6.  Add console logs within your Error Boundaries to demonstrate which boundary catches which error.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// --- Provided ErrorBoundary (use your solution from previous task or this one) ---\nclass ErrorBoundary extends React.Component<any, any> {\n  state = { hasError: false, errorInfo: null };\n\n  static getDerivedStateFromError(error: Error) {\n    console.log('ErrorBoundary: getDerivedStateFromError called.');\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('ErrorBoundary: componentDidCatch caught error:', error.message, errorInfo.componentStack);\n    this.setState({ errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ border: '2px dashed red', padding: '15px', margin: '10px 0' }}>\n          <h3>⚠️ Component Failed!</h3>\n          {this.state.errorInfo && (\n            <details>\n              <summary>Error Details</summary>\n              <pre style={{ whiteSpace: 'pre-wrap', fontSize: '0.75em' }}>\n                {this.state.errorInfo.componentStack}\n              </pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n// --------------------------------------------------------------------------\n\n// --- App Components (Your task to modify/complete) ---\nconst Header: React.FC = () => (\n  <header style={{ background: '#f0f0f0', padding: '20px', textAlign: 'center' }}>\n    <h2>Application Header</h2>\n  </header>\n);\n\nconst Footer: React.FC = () => (\n  <footer style={{ background: '#f0f0f0', padding: '15px', textAlign: 'center', marginTop: '20px' }}>\n    <p>© 2023 My App</p>\n  </footer>\n);\n\n// WidgetA: Can throw an error\nconst WidgetA: React.FC<{ triggerError: boolean }> = ({ triggerError }) => {\n  if (triggerError) {\n    throw new Error('Error in WidgetA!');\n  }\n  return (\n    <div style={{ border: '1px solid lightblue', padding: '10px', margin: '5px' }}>\n      <h4>Widget A</h4>\n      <p>This widget is fine.</p>\n    </div>\n  );\n};\n\n// WidgetB: Will throw error if trigger is true\nconst WidgetB: React.FC<{ triggerError: boolean }> = ({ triggerError }) => {\n  if (triggerError) {\n    throw new Error('Error in WidgetB!');\n  }\n  return (\n    <div style={{ border: '1px solid lightgreen', padding: '10px', margin: '5px' }}>\n      <h4>Widget B</h4>\n      <p>This widget is also fine.</p>\n    </div>\n  );\n};\n\nconst MainContent: React.FC = () => {\n  const [errorA, setErrorA] = useState(false);\n  const [errorB, setErrorB] = useState(false);\n\n  return (\n    <main style={{ padding: '20px', border: '1px solid gray', margin: '20px', minHeight: '300px' }}>\n      <h3>Main Application Content</h3>\n      <button onClick={() => setErrorA(true)} style={{ marginRight: '10px' }}>\n        Trigger Error in Widget A\n      </button>\n      <button onClick={() => setErrorB(true)}>\n        Trigger Error in Widget B\n      </button>\n\n      {/* TODO: Place Error Boundaries strategically */}\n      \n      <div>\n        {/* Widget A goes here */}\n        <WidgetA triggerError={errorA} />\n      </div>\n      <div>\n        {/* Widget B goes here */}\n        <WidgetB triggerError={errorB} />\n      </div>\n    </main>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <Header />\n      {/* TODO: MainContent needs an ErrorBoundary if WidgetB fails */}\n      <MainContent />\n      <Footer />\n    </div>\n  );\n};\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nclass ErrorBoundary extends React.Component<any, any> {\n  state = { hasError: false, errorInfo: null };\n  constructor(props: any) {\n    super(props);\n    // Adding a name prop to distinguish boundaries in logs\n    // This is not part of standard ErrorBoundary but useful for this task\n    this.state = { hasError: false, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    console.log(`ErrorBoundary (${this.name || 'Unnamed'}): getDerivedStateFromError called.`);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error(`ErrorBoundary (${(this.props as any).name || 'Unnamed'}): componentDidCatch caught error:`, error.message, errorInfo.componentStack);\n    this.setState({ errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ border: '2px dashed red', padding: '15px', margin: '10px 0', backgroundColor: '#ffe6e6' }}>\n          <h3>⚠️ Component Failed! (Boundary: {(this.props as any).name || 'Unnamed'})</h3>\n          {this.state.errorInfo && (\n            <details>\n              <summary>Error Details</summary>\n              <pre style={{ whiteSpace: 'pre-wrap', fontSize: '0.75em', maxHeight: '150px', overflowY: 'auto' }}>\n                {this.state.errorInfo.componentStack}\n              </pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\nconst Header: React.FC = () => (\n  <header style={{ background: '#f0f0f0', padding: '20px', textAlign: 'center' }}>\n    <h2>Application Header</h2>\n  </header>\n);\n\nconst Footer: React.FC = () => (\n  <footer style={{ background: '#f0f0f0', padding: '15px', textAlign: 'center', marginTop: '20px' }}>\n    <p>© 2023 My App</p>\n  </footer>\n);\n\nconst WidgetA: React.FC<{ triggerError: boolean }> = ({ triggerError }) => {\n  if (triggerError) {\n    throw new Error('Error in WidgetA!');\n  }\n  return (\n    <div style={{ border: '1px solid lightblue', padding: '10px', margin: '5px' }}>\n      <h4>Widget A</h4>\n      <p>This widget is fine.</p>\n    </div>\n  );\n};\n\nconst WidgetB: React.FC<{ triggerError: boolean }> = ({ triggerError }) => {\n  if (triggerError) {\n    throw new Error('Error in WidgetB!');\n  }\n  return (\n    <div style={{ border: '1px solid lightgreen', padding: '10px', margin: '5px' }}>\n      <h4>Widget B</h4>\n      <p>This widget is also fine.</p>\n    </div>\n  );\n};\n\nconst MainContent: React.FC = () => {\n  const [errorA, setErrorA] = useState(false);\n  const [errorB, setErrorB] = useState(false);\n\n  return (\n    <main style={{ padding: '20px', border: '1px solid gray', margin: '20px', minHeight: '300px' }}>\n      <h3>Main Application Content</h3>\n      <button onClick={() => setErrorA(true)} style={{ marginRight: '10px' }}>\n        Trigger Error in Widget A\n      </button>\n      <button onClick={() => setErrorB(true)}>\n        Trigger Error in Widget B\n      </button>\n      \n      {/* Individual Error Boundary for Widget A */}\n      <ErrorBoundary name=\"WidgetA-Boundary\">\n        <WidgetA triggerError={errorA} />\n      </ErrorBoundary>\n      \n      {/* Widget B is now directly under MainContent's boundary */}\n      <WidgetB triggerError={errorB} />\n\n    </main>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <Header />\n      {/* MainContent wrapped by its own ErrorBoundary */}\n      <ErrorBoundary name=\"MainContent-Boundary\">\n        <MainContent />\n      </ErrorBoundary>\n      <Footer />\n    </div>\n  );\n};\n\nexport default App;\n",
          "testCases": [
            "Initial render: All components (Header, MainContent, WidgetA, WidgetB, Footer) should render without errors.",
            "Error in WidgetA: Clicking 'Trigger Error in Widget A' should cause WidgetA's dedicated ErrorBoundary to show its fallback. WidgetB, Header, and Footer should remain visible and functional. Console should show logs from 'WidgetA-Boundary'.",
            "Error in WidgetB: Clicking 'Trigger Error in Widget B' should cause MainContent's ErrorBoundary to show its fallback. WidgetA, Header, and Footer should remain visible and functional. Console should show logs from 'MainContent-Boundary'.",
            "Multiple Errors: Trigger an error in WidgetA, then try to trigger an error in WidgetB (or vice versa). Observe how the different boundaries behave and which part of the UI is affected.",
            "No Errors: Confirm that without triggering errors, the application functions normally without any visible boundary fallbacks."
          ],
          "hints": [
            "Remember that an Error Boundary only catches errors in its *children*. It does not catch errors in itself or its siblings.",
            "You'll need two separate instances of `ErrorBoundary` for this task.",
            "Consider adding a `name` prop to your `ErrorBoundary` and logging that name in `componentDidCatch` to easily identify which boundary is triggered in the console.",
            "Think about the hierarchy: `App > MainContent-ErrorBoundary > MainContent > (WidgetA-ErrorBoundary > WidgetA), WidgetB`."
          ],
          "tags": [
            "React",
            "Error Handling",
            "Component Hierarchy",
            "Application Structure",
            "Nested Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_Component_Composition",
            "React_Error_Boundaries_Overview"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "React_Error_Boundaries_Overview",
            "Error_Boundary_Limitations"
          ]
        },
        {
          "id": "task_handle_errors_outside_boundaries",
          "title": "Handling Errors Outside React Error Boundaries",
          "description": "\nReact Error Boundaries have limitations and do not catch errors in event handlers or asynchronous code. This task focuses on implementing robust error handling for such scenarios.\n\nYour tasks are:\n\n1.  Create a functional React component called `ActionButtons`.\n2.  Inside `ActionButtons`, include two buttons:\n    *   One button, when clicked, should throw an error directly within its `onClick` handler.\n    *   Another button, when clicked, should trigger an asynchronous operation (e.g., a `setTimeout` or a `Promise` that rejects after a delay) that throws/rejects an error.\n3.  Implement `try/catch` blocks within the respective handlers to gracefully handle these errors. Do **not** rely on an `ErrorBoundary` for these specific errors.\n4.  Display a user-friendly message or update component state to show that an error occurred and was handled, without crashing the component or the application.\n5.  Include console logs to confirm when errors are caught locally by `try/catch`.\n6.  (Optional but recommended) Wrap `ActionButtons` with a generic `ErrorBoundary` to show that *other* types of errors (e.g., render-time errors) would still be caught by the boundary, but the button errors are not.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\n// Basic Error Boundary (for demonstrating its non-involvement)\nclass GenericErrorBoundary extends React.Component<any, any> {\n  state = { hasError: false };\n  static getDerivedStateFromError(error: Error) {\n    console.log('GenericErrorBoundary caught a render error:', error.message);\n    return { hasError: true };\n  }\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('GenericErrorBoundary componentDidCatch:', error, errorInfo.componentStack);\n  }\n  render() {\n    if (this.state.hasError) {\n      return <div style={{ border: '2px solid purple', padding: '10px' }}>\n               <p>A rendering error occurred in a child. (Caught by GenericErrorBoundary)</p>\n             </div>;\n    }\n    return this.props.children;\n  }\n}\n\n// Your component to implement\nconst ActionButtons: React.FC = () => {\n  const [status, setStatus] = useState<string>('Ready');\n\n  const handleSyncError = () => {\n    // TODO: Implement try/catch for synchronous error\n    setStatus('Attempting sync error...');\n    // throw new Error('Sync error!'); // This will be caught by try/catch\n  };\n\n  const handleAsyncError = () => {\n    // TODO: Implement try/catch for asynchronous error\n    setStatus('Attempting async error...');\n    // setTimeout(() => { throw new Error('Async error!'); }, 500); // This needs Promise.catch or try/catch around the setTimeout callback\n  };\n\n  return (\n    <div style={{ border: '1px solid gray', padding: '20px', margin: '20px' }}>\n      <h3>Action Buttons with Local Error Handling</h3>\n      <button onClick={handleSyncError} style={{ marginRight: '10px' }}>\n        Trigger Sync Error (Event Handler)\n      </button>\n      <button onClick={handleAsyncError}>\n        Trigger Async Error (setTimeout)\n      </button>\n      <p>Status: {status}</p>\n    </div>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <h1>Error Handling Outside Boundaries Task</h1>\n      <GenericErrorBoundary>\n        <ActionButtons />\n      </GenericErrorBoundary>\n      <p>Application continues to run.</p>\n    </div>\n  );\n};\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Basic Error Boundary (for demonstrating its non-involvement)\nclass GenericErrorBoundary extends React.Component<any, any> {\n  state = { hasError: false };\n  static getDerivedStateFromError(error: Error) {\n    console.log('GenericErrorBoundary caught a render error:', error.message);\n    return { hasError: true };\n  }\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('GenericErrorBoundary componentDidCatch (render error):', error, errorInfo.componentStack);\n  }\n  render() {\n    if (this.state.hasError) {\n      return <div style={{ border: '2px solid purple', padding: '10px', margin: '10px' }}>\n               <p>A rendering error occurred in a child. (Caught by GenericErrorBoundary)</p>\n             </div>;\n    }\n    return this.props.children;\n  }\n}\n\nconst ActionButtons: React.FC = () => {\n  const [status, setStatus] = useState<string>('Ready');\n\n  const handleSyncError = () => {\n    try {\n      // Error in event handler - caught by local try/catch\n      throw new Error('Simulated synchronous error in onClick!');\n    } catch (error: any) {\n      console.error('Locally caught sync error:', error.message);\n      setStatus(`Sync Error Handled: ${error.message}`);\n      // Optionally, show a temporary error message in the UI\n    }\n  };\n\n  const handleAsyncError = () => {\n    setStatus('Attempting async error...');\n    // Error in async code (setTimeout callback) - needs try/catch inside callback\n    setTimeout(() => {\n      try {\n        throw new Error('Simulated asynchronous error in setTimeout!');\n      } catch (error: any) {\n        console.error('Locally caught async error:', error.message);\n        setStatus(`Async Error Handled: ${error.message}`);\n      }\n    }, 1000);\n\n    // Example with Promise rejection\n    /*\n    new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(new Error('Simulated async promise rejection!'));\n      }, 1500);\n    })\n    .catch((error: any) => {\n      console.error('Locally caught promise error:', error.message);\n      setStatus(`Promise Error Handled: ${error.message}`);\n    });\n    */\n  };\n\n  // Example of an error that WOULD be caught by GenericErrorBoundary\n  const triggerRenderError = () => {\n    // Simulate a rendering error for the ErrorBoundary to catch\n    throw new Error('Simulated rendering error!');\n  };\n\n  return (\n    <div style={{ border: '1px solid gray', padding: '20px', margin: '20px' }}>\n      <h3>Action Buttons with Local Error Handling</h3>\n      <button onClick={handleSyncError} style={{ marginRight: '10px' }}>\n        Trigger Sync Error (Event Handler)\n      </button>\n      <button onClick={handleAsyncError} style={{ marginRight: '10px' }}>\n        Trigger Async Error (setTimeout)\n      </button>\n      {/* Optional button to demonstrate a render error caught by GenericErrorBoundary */}\n      <button onClick={triggerRenderError}>Trigger Render Error (for ErrorBoundary)</button>\n      <p style={{ marginTop: '15px', fontWeight: 'bold' }}>Status: {status}</p>\n    </div>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <h1>Error Handling Outside Boundaries Task</h1>\n      <GenericErrorBoundary>\n        <ActionButtons />\n      </GenericErrorBoundary>\n      <p>Application continues to run.</p>\n    </div>\n  );\n};\n\nexport default App;\n",
          "testCases": [
            "Initial state: `ActionButtons` should render normally, status is 'Ready'.",
            "Sync Error (Event Handler): Click 'Trigger Sync Error'. The component should NOT crash. The status message should update to 'Sync Error Handled...'. Console should show 'Locally caught sync error:', and `GenericErrorBoundary`'s logs should NOT appear.",
            "Async Error (setTimeout): Click 'Trigger Async Error'. Wait 1 second. The component should NOT crash. The status message should update to 'Async Error Handled...'. Console should show 'Locally caught async error:', and `GenericErrorBoundary`'s logs should NOT appear.",
            "Render Error (Optional): If implemented, clicking 'Trigger Render Error' should cause `GenericErrorBoundary` to display its fallback UI, and its logs should appear, demonstrating the different scopes of error handling."
          ],
          "hints": [
            "For event handlers, place the `try/catch` directly around the code that might throw inside the `onClick` handler function.",
            "For `setTimeout` callbacks, the `try/catch` must be *inside* the callback function passed to `setTimeout`, not around the `setTimeout` call itself.",
            "For Promises, use the `.catch()` method or an `async/await` block with `try/catch` around the `await` call.",
            "Ensure your `setStatus` calls provide clear feedback to the user about which error was handled and where."
          ],
          "tags": [
            "React",
            "Error Handling",
            "JavaScript",
            "try-catch",
            "Asynchronous JavaScript",
            "Event Handlers"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "React_Functional_Components",
            "React_State_and_Props",
            "JavaScript_Error_Handling",
            "JavaScript_Asynchronous_Programming"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Error_Boundary_Limitations"
          ]
        }
      ]
    }
  },
  {
    "id": "8a9ce561-4860-4372-a2b6-889b2e9662bb",
    "startLine": 4800,
    "endLine": 4899,
    "processedDate": "2025-06-17T09:18:34.805Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_lifecycle_best_practices",
          "title": "React Class Component Lifecycle Best Practices",
          "content": "React class components provide a set of lifecycle methods that allow you to execute code at specific points during a component's life: when it's created, updated, or destroyed. Understanding and correctly using these methods is crucial for building robust and performant React applications.\n\n## When to Make HTTP Requests\nIt is highly recommended to make HTTP requests inside the `componentDidMount` lifecycle method. This ensures that the component has been rendered to the DOM before the data fetching begins. Fetching data here prevents issues like trying to update state on an unmounted component or causing unnecessary re-renders during the initial render phase. It also guarantees that the data fetching only happens once when the component is initially mounted.\n\n## Updating State Based on Props\nDirectly using props to set state within `componentDidUpdate` without a condition can lead to infinite loops. This happens because `setState` triggers a re-render, which in turn calls `componentDidUpdate` again, creating a cycle. To avoid this, always compare current props (`this.props`) with previous props (`prevProps`) before updating state.\n\nFor deriving state from props, especially when the derived state needs to be re-calculated only when specific props change, `static getDerivedStateFromProps` is the appropriate lifecycle method. It is a static method, meaning it does not have access to `this` (the component instance), and it should return an object to update the state or `null` to indicate no state change. It's called right before `render`, on both initial mount and subsequent updates.\n\n## Optimizing Renders with `shouldComponentUpdate`\nBy default, React components re-render whenever their parent re-renders, or when their own state or props change. `shouldComponentUpdate` is a lifecycle method that allows you to control whether a component re-renders. It receives `nextProps` and `nextState` as arguments and should return `true` if the component should re-render, or `false` if it should not. This method is a powerful tool for performance optimization, especially for complex components or large lists, by preventing unnecessary re-renders. However, it requires careful implementation to avoid bugs from missed updates.",
          "examples": [
            {
              "id": "example_lifecycle_http_request",
              "title": "Making HTTP Requests in componentDidMount",
              "code": "import React, { Component } from 'react';\n\ninterface DataState {\n  data: any[] | null;\n  loading: boolean;\n  error: Error | null;\n}\n\nclass DataFetcher extends Component<{}, DataState> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      data: null,\n      loading: true,\n      error: null,\n    };\n  }\n\n  componentDidMount() {\n    console.log('ComponentDidMount: Fetching data...');\n    fetch('https://jsonplaceholder.typicode.com/posts?_limit=3')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({ data, loading: false });\n        console.log('Data fetched successfully:', data);\n      })\n      .catch(error => {\n        this.setState({ error, loading: false });\n        console.error('Error fetching data:', error);\n      });\n  }\n\n  render() {\n    const { data, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading data...</div>;\n    }\n    if (error) {\n      return <div>Error: {error.message}</div>;\n    }\n    if (!data || data.length === 0) {\n        return <div>No data available.</div>;\n    }\n\n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <ul>\n          {data.map((item: any) => (\n            <li key={item.id}>{item.title}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <DataFetcher />\n",
              "explanation": "This example demonstrates fetching data within `componentDidMount`. The component's `loading` state is set to `true` initially and then updated to `false` (along with the fetched data or error) once the fetch operation completes. This ensures the data is only fetched once the component is ready to display it, preventing unnecessary network requests or state updates during the initial render cycle.",
              "language": "typescript"
            },
            {
              "id": "example_lifecycle_update_props",
              "title": "Updating State from Props Safely (componentDidUpdate vs. getDerivedStateFromProps)",
              "code": "import React, { Component } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  active: boolean;\n}\n\ninterface FilteredListProps {\n  items: Item[];\n}\n\ninterface FilteredListState {\n  filteredItems: Item[];\n  prevItems: Item[] | null; // Used with getDerivedStateFromProps\n}\n\n// Approach 1: Using componentDidUpdate safely\nclass FilteredListA extends Component<FilteredListProps, FilteredListState> {\n  constructor(props: FilteredListProps) {\n    super(props);\n    this.state = {\n      filteredItems: this.props.items.filter(item => item.active),\n      prevItems: null\n    };\n  }\n\n  componentDidUpdate(prevProps: FilteredListProps) {\n    // GOOD: Check if props actually changed to avoid infinite loop\n    if (prevProps.items !== this.props.items) {\n      console.log('FilteredListA: Items prop changed, updating state via componentDidUpdate');\n      this.setState({\n        filteredItems: this.props.items.filter(item => item.active)\n      });\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Filtered List (componentDidUpdate)</h3>\n        <ul>\n          {this.state.filteredItems.map(item => (\n            <li key={item.id}>{item.name} (Active: {String(item.active)})</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Approach 2: Using static getDerivedStateFromProps (Recommended for prop-derived state)\nclass FilteredListB extends Component<FilteredListProps, FilteredListState> {\n  constructor(props: FilteredListProps) {\n    super(props);\n    this.state = {\n      filteredItems: [], // Initial state, will be updated by getDerivedStateFromProps\n      prevItems: null,   // Store previous items to detect changes\n    };\n  }\n\n  static getDerivedStateFromProps(props: FilteredListProps, state: FilteredListState) {\n    // Check if the items prop has changed since the last render\n    if (props.items !== state.prevItems) {\n      console.log('FilteredListB: Items prop changed, deriving new state via getDerivedStateFromProps');\n      return {\n        filteredItems: props.items.filter(item => item.active),\n        prevItems: props.items, // Update prevItems for the next comparison\n      };\n    }\n    // No change in props, no state update needed\n    return null;\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Filtered List (getDerivedStateFromProps)</h3>\n        <ul>\n          {this.state.filteredItems.map(item => (\n            <li key={item.id}>{item.name} (Active: {String(item.active)})</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Usage example (e.g., in a parent component):\n/*\nconst allItems = [\n  { id: 1, name: 'Apple', active: true },\n  { id: 2, name: 'Banana', active: false },\n  { id: 3, name: 'Cherry', active: true },\n];\n\n<FilteredListA items={allItems} />\n<FilteredListB items={allItems} />\n*/\n",
              "explanation": "This example compares two approaches for updating state based on prop changes. `FilteredListA` uses `componentDidUpdate` with a crucial `if (prevProps.items !== this.props.items)` check to prevent an infinite loop. `FilteredListB` uses the static `getDerivedStateFromProps`, which is the preferred way to derive state from props. It's a pure function that returns the new state object or `null` if no update is needed. Notice how `prevItems` is stored in state to track changes for `getDerivedStateFromProps`.",
              "language": "typescript"
            },
            {
              "id": "example_lifecycle_should_component_update",
              "title": "Optimizing Renders with shouldComponentUpdate",
              "code": "import React, { Component } from 'react';\n\ninterface OptimizableComponentProps {\n  id: number;\n  name: string;\n  value: number;\n}\n\ninterface OptimizableComponentState {\n  counter: number;\n}\n\nclass OptimizableComponent extends Component<OptimizableComponentProps, OptimizableComponentState> {\n  constructor(props: OptimizableComponentProps) {\n    super(props);\n    this.state = { counter: 0 };\n  }\n\n  shouldComponentUpdate(nextProps: OptimizableComponentProps, nextState: OptimizableComponentState): boolean {\n    // Only re-render if 'id' prop or 'counter' state changes.\n    // 'name' and 'value' prop changes will NOT trigger a re-render.\n    if (nextProps.id !== this.props.id || nextState.counter !== this.state.counter) {\n      console.log(`OptimizableComponent (${this.props.name}): Re-rendering due to relevant change.`);\n      return true;\n    }\n    console.log(`OptimizableComponent (${this.props.name}): Skipping re-render (no relevant change).`);\n    return false;\n  }\n\n  render() {\n    console.log(`OptimizableComponent (${this.props.name}): Rendered.`);\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '5px' }}>\n        <h4>Optimized Component: {this.props.name} (ID: {this.props.id})</h4>\n        <p>Prop Value: {this.props.value}</p>\n        <p>State Counter: {this.state.counter}</p>\n        <button onClick={() => this.setState(prevState => ({ counter: prevState.counter + 1 }))}>\n          Increment Counter\n        </button>\n      </div>\n    );\n  }\n}\n\n// Usage example (e.g., in a parent component):\n/*\ninterface AppState {\n    id: number;\n    name: string;\n    value: number;\n    triggerRender: boolean;\n}\n\nclass App extends Component<{}, AppState> {\n    state = {\n        id: 1,\n        name: 'Component A',\n        value: 10,\n        triggerRender: false,\n    };\n\n    render() {\n        return (\n            <div>\n                <button onClick={() => this.setState(prev => ({ value: prev.value + 1 }))}>\n                    Change Irrelevant Prop (Value)\n                </button>\n                <button onClick={() => this.setState(prev => ({ id: prev.id + 1 }))}>\n                    Change Relevant Prop (ID)\n                </button>\n                <OptimizableComponent id={this.state.id} name={this.state.name} value={this.state.value} />\n            </div>\n        );\n    }\n}\n*/\n",
              "explanation": "This example shows how `shouldComponentUpdate` can prevent unnecessary renders. The component only re-renders if its `id` prop or `counter` state changes. Changes to the `name` or `value` props will not trigger a re-render because they are explicitly ignored in the `shouldComponentUpdate` logic. This can significantly improve performance for components that receive frequently changing props, but only a subset of those props affects their visual output.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_lifecycle_http_location",
            "question_lifecycle_getderivedstatefromprops_usage",
            "question_lifecycle_shouldcomponentupdate_function",
            "question_lifecycle_anti_pattern",
            "question_lifecycle_infinite_loop_fix",
            "question_lifecycle_gdsfp_side_effects",
            "question_lifecycle_shouldcomponentupdate_caution",
            "question_lifecycle_order_of_methods",
            "question_lifecycle_api_call_why_cdm",
            "question_lifecycle_props_to_state_pattern"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_filterable_list_gdsfp",
            "task_optimize_component_scu"
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "componentDidUpdate",
            "getDerivedStateFromProps",
            "shouldComponentUpdate",
            "Performance Optimization",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "JavaScript Promises/Fetch API"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced React Components",
            "Performance Tuning"
          ]
        },
        {
          "id": "theory_pure_component",
          "title": "React.PureComponent for Performance Optimization",
          "content": "React.PureComponent is a base class that extends `React.Component` but includes a built-in implementation of `shouldComponentUpdate`. Instead of requiring you to write custom logic in `shouldComponentUpdate`, `PureComponent` automatically performs a shallow comparison of the component's props and state. If this shallow comparison reveals no changes, `PureComponent` prevents the component from re-rendering.\n\n## How Shallow Comparison Works\n*   **Props**: It compares the current props with the next props. For primitive values (numbers, strings, booleans, null, undefined), it checks for equality (`===`). For objects and arrays, it checks if the *references* are the same. If the reference is different, it assumes the content might have changed and triggers a re-render. It does *not* deep-compare the contents of objects or arrays.\n*   **State**: Similar to props, it performs a shallow comparison of the current state with the next state.\n\n## Benefits and Limitations\n**Benefits:**\n*   **Reduced Boilerplate**: Eliminates the need to manually implement `shouldComponentUpdate` for many common use cases.\n*   **Performance Improvement**: Prevents unnecessary re-renders, leading to better performance in applications with many components or frequently updated parent components.\n\n**Limitations:**\n*   **Deeply Nested Data**: If your props or state contain deeply nested objects or arrays, `PureComponent`'s shallow comparison might miss changes within those nested structures. In such cases, you might still need to implement a custom `shouldComponentUpdate` or use immutable data structures.\n*   **Functions**: Functions passed as props are often re-created on every render in the parent component. Since `PureComponent` does a shallow comparison, a new function reference will always be considered a 'change', potentially nullifying the optimization unless memoized with `useCallback` (in functional components) or bound once in the constructor (in class components).\n\n`PureComponent` is most effective when your component's props and state are simple, or when you are using immutable data patterns.",
          "examples": [
            {
              "id": "example_pure_component",
              "title": "Using React.PureComponent",
              "code": "import React, { PureComponent } from 'react';\n\ninterface DisplayValueProps {\n  id: number;\n  value: string;\n  data: { timestamp: number }; // Object prop\n}\n\nclass MyPureComponent extends PureComponent<DisplayValueProps> {\n  render() {\n    console.log(`MyPureComponent (${this.props.id}): Rendered. Value: ${this.props.value}`);\n    return (\n      <div style={{ border: '1px dashed blue', margin: '5px', padding: '5px' }}>\n        <h3>Pure Component (ID: {this.props.id})</h3>\n        <p>Value: {this.props.value}</p>\n        <p>Timestamp in data: {this.props.data.timestamp}</p>\n      </div>\n    );\n  }\n}\n\n// Usage example (e.g., in a parent component):\n/*\nimport React, { Component } from 'react';\n\ninterface AppState {\n  counter: number;\n  text: string;\n  objData: { timestamp: number };\n}\n\nclass App extends Component<{}, AppState> {\n  state = {\n    counter: 0,\n    text: 'Initial Text',\n    objData: { timestamp: Date.now() },\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.setState(prevState => ({\n            counter: prevState.counter + 1,\n            // NOTE: Updating objData by creating a NEW object reference\n            objData: { timestamp: Date.now() } \n        }))}>\n          Update State & Object Prop (Triggers PureComponent)\n        </button>\n        <button onClick={() => this.setState(prevState => ({\n            // This won't trigger PureComponent if only 'text' changes\n            // because 'id' and 'objData' (shallow) haven't changed yet.\n            text: prevState.text === 'Initial Text' ? 'Changed Text' : 'Initial Text'\n        }))}>\n          Update Text Prop (Won't trigger if other props don't change)\n        </button>\n        <MyPureComponent id={1} value={this.state.text} data={this.state.objData} />\n        <p>App Counter: {this.state.counter}</p>\n      </div>\n    );\n  }\n}\n*/\n",
              "explanation": "This example shows `MyPureComponent` which extends `React.PureComponent`. When the `App` component updates its state:\n1.  If `objData` is updated by creating a *new object reference* (e.g., `{ timestamp: Date.now() }`), `MyPureComponent` will re-render because the shallow comparison detects a change in the `data` prop's reference.\n2.  If only the `text` state is updated in the `App` component, and `objData` remains the *same object reference*, `MyPureComponent` will *not* re-render because `id`, `value` (if the string content is the same), and `data` (object reference) are shallowly equal. This demonstrates the automatic `shouldComponentUpdate` behavior.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_purecomponent_definition",
            "question_purecomponent_vs_component",
            "question_purecomponent_shallow_comparison",
            "question_purecomponent_deep_objects",
            "question_purecomponent_when_to_use",
            "question_purecomponent_function_prop",
            "question_purecomponent_benefits",
            "question_purecomponent_limitations"
          ],
          "relatedTasks": [
            "task_purecomponent_demonstration"
          ],
          "tags": [
            "React",
            "PureComponent",
            "Performance Optimization",
            "Shallow Comparison",
            "Class Components"
          ],
          "technology": "React",
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "shouldComponentUpdate"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Performance Tuning",
            "Optimized React Development"
          ]
        },
        {
          "id": "theory_react_memo",
          "title": "React.memo (Functional Component Memoization)",
          "content": "React.memo is a higher-order component (HOC) introduced in React 16.6 that serves a similar purpose to `React.PureComponent` but for functional components. It memoizes the component's render output and will only re-render the component if its props have shallowly changed.\n\n## Basic Usage\nWhen you wrap a functional component with `React.memo`, React will perform a shallow comparison of its props. If the new props are shallowly equal to the previous props, React will skip rendering the component and reuse the last rendered result.\n\n## Custom Comparison Function\nBy default, `React.memo` performs a shallow comparison. However, you can provide a custom comparison function as the second argument to `React.memo`. This function receives `prevProps` and `nextProps` as arguments. Unlike `shouldComponentUpdate` (which returns `true` to re-render), this comparison function should return `true` if the props are *equal* (meaning, no re-render is needed) and `false` if they are *different* (meaning, a re-render is needed).\n\nThis custom comparison is useful when:\n*   You need to perform a deep comparison for specific props.\n*   You want to ignore certain props when determining if a re-render is necessary.\n*   You have complex object props that are not stable (e.g., new object reference every render) but their relevant content hasn't changed.\n\n## Relationship with `useCallback` and `useMemo`\nFor `React.memo` to be effective with props that are functions or objects/arrays created in the parent component's render, you often need to use `useCallback` for functions and `useMemo` for objects/arrays. These hooks memoize the function or object itself, ensuring that its reference remains stable across renders, thus allowing `React.memo`'s shallow comparison to work as intended.",
          "examples": [
            {
              "id": "example_react_memo_basic",
              "title": "Basic Usage of React.memo",
              "code": "import React from 'react';\n\ninterface DisplayMessageProps {\n  message: string;\n  count: number;\n}\n\nconst MessageDisplay: React.FC<DisplayMessageProps> = ({ message, count }) => {\n  console.log(`MessageDisplay (basic memo): Rendered with message \"${message}\", count: ${count}`);\n  return (\n    <div style={{ border: '1px solid green', margin: '5px', padding: '5px' }}>\n      <h4>Memoized Component (Basic)</h4>\n      <p>Message: {message}</p>\n      <p>Count: {count}</p>\n    </div>\n  );\n};\n\n// Wrap the component with React.memo\nconst MemoizedMessageDisplay = React.memo(MessageDisplay);\n\n// Usage example (e.g., in a parent component):\n/*\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [value, setValue] = useState(0);\n  const [text, setText] = useState('Hello');\n\n  return (\n    <div>\n      <button onClick={() => setValue(value + 1)}>\n        Update Counter (Triggers Parent, but not MemoizedMessageDisplay if text is stable)\n      </button>\n      <button onClick={() => setText(text === 'Hello' ? 'World' : 'Hello')}>\n        Update Text (Triggers MemoizedMessageDisplay)\n      </button>\n      <MemoizedMessageDisplay message={text} count={value} />\n    </div>\n  );\n}\n*/\n",
              "explanation": "This example shows `React.memo` in its basic form. `MemoizedMessageDisplay` will only re-render if its `message` or `count` props shallowly change. If the parent component (`App` in the commented usage) re-renders, but `text` and `value` props passed to `MemoizedMessageDisplay` are referentially equal to their previous values, the memoized component will not re-render, thus saving computation.",
              "language": "typescript"
            },
            {
              "id": "example_react_memo_custom_comparison",
              "title": "React.memo with Custom Comparison Function",
              "code": "import React from 'react';\n\ninterface UserProfileProps {\n  user: {\n    id: number;\n    name: string;\n    email: string;\n    lastLogin: Date; // A prop that might frequently change but not impact display\n  };\n}\n\nconst UserProfile: React.FC<UserProfileProps> = ({ user }) => {\n  console.log(`UserProfile (custom memo): Rendered for user ${user.name} (ID: ${user.id})`);\n  return (\n    <div style={{ border: '1px solid orange', margin: '5px', padding: '5px' }}>\n      <h4>Memoized User Profile (Custom Comparison)</h4>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n      <p>Last Login: {user.lastLogin.toLocaleTimeString()}</p>\n    </div>\n  );\n};\n\n// Custom comparison function for React.memo\n// Returns true if props are EQUAL (i.e., no re-render needed)\n// We want to re-render ONLY if id, name, or email changes, ignoring lastLogin.\nconst arePropsEqual = (prevProps: UserProfileProps, nextProps: UserProfileProps): boolean => {\n  return (\n    prevProps.user.id === nextProps.user.id &&\n    prevProps.user.name === nextProps.user.name &&\n    prevProps.user.email === nextProps.user.email\n    // We explicitly IGNORE prevProps.user.lastLogin === nextProps.user.lastLogin\n    // This means changes to lastLogin won't trigger a re-render.\n  );\n};\n\nconst MemoizedUserProfile = React.memo(UserProfile, arePropsEqual);\n\n// Usage example (e.g., in a parent component):\n/*\nimport React, { useState, useEffect } from 'react';\n\nfunction App() {\n  const [currentUser, setCurrentUser] = useState({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com',\n    lastLogin: new Date(),\n  });\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // This updates 'lastLogin' frequently, but won't cause UserProfile to re-render\n      // because of the custom comparison function.\n      setCurrentUser(prevUser => ({\n        ...prevUser,\n        lastLogin: new Date(), // New object reference and new date, but ignored by memo\n      }));\n    }, 2000);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  const changeUserName = () => {\n    setCurrentUser(prevUser => ({ ...prevUser, name: prevUser.name === 'Alice' ? 'Bob' : 'Alice' }));\n  };\n\n  return (\n    <div>\n      <button onClick={changeUserName}>Change User Name (Triggers Re-render)</button>\n      <MemoizedUserProfile user={currentUser} />\n      <p>App will update lastLogin every 2 seconds, but UserProfile should only render if name/id/email changes.</p>\n    </div>\n  );\n}\n*/\n",
              "explanation": "This example demonstrates `React.memo` with a custom comparison function (`arePropsEqual`). The `UserProfile` component receives a `user` object with `lastLogin` which might change frequently (e.g., an 'online status' timestamp). The `arePropsEqual` function is designed to return `true` (skip re-render) if `id`, `name`, and `email` are the same, explicitly ignoring the `lastLogin` property. This prevents unnecessary re-renders when only `lastLogin` changes, optimizing performance while still ensuring updates for relevant data.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_memo_purpose",
            "question_react_memo_vs_purecomponent",
            "question_react_memo_custom_comparison_return",
            "question_react_memo_when_to_use",
            "question_react_memo_with_usecallback_usememo",
            "question_react_memo_functional_equivalent",
            "question_react_memo_nested_objects",
            "question_react_memo_function_prop_issue"
          ],
          "relatedTasks": [
            "task_memoized_counter_display",
            "task_custom_memoization_user_card"
          ],
          "tags": [
            "React",
            "React.memo",
            "Functional Components",
            "Higher-Order Components (HOC)",
            "Performance Optimization",
            "Memoization",
            "Shallow Comparison",
            "Custom Comparison"
          ],
          "technology": "React",
          "prerequisites": [
            "React Functional Components",
            "Props in React",
            "Basic JavaScript Functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Performance Tuning",
            "Hooks Best Practices",
            "Optimized React Development"
          ]
        },
        {
          "id": "theory_hooks_replacing_lifecycles",
          "title": "Replacing Class Lifecycle Methods with React Hooks",
          "content": "With the introduction of React Hooks, much of the functionality traditionally handled by class component lifecycle methods can now be achieved in functional components, often with more concise and readable code. The primary hook for managing side effects (which include data fetching, subscriptions, and manually changing the DOM) is `useEffect`.\n\n## `useEffect` as a Replacement\n`useEffect` can replace `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.\n\n*   **`componentDidMount` equivalent**: If you provide an empty dependency array (`[]`) as the second argument to `useEffect`, the effect will run only once after the initial render, similar to `componentDidMount`.\n    ```typescript\n    useEffect(() => {\n      // Runs once after initial render\n      console.log('Component Mounted (via useEffect)');\n      // Fetch data, set up subscriptions, etc.\n    }, []); // Empty dependency array\n    ```\n\n*   **`componentDidUpdate` equivalent**: If you omit the dependency array, the effect will run after every render (after every mount and update). This is generally not recommended as it can lead to performance issues or infinite loops if not carefully managed.\n    ```typescript\n    useEffect(() => {\n      // Runs after every render\n      console.log('Component Updated (via useEffect - no dependency array)');\n    }); // No dependency array\n    ```\n    To mimic `componentDidUpdate` for specific prop/state changes, you provide those values in the dependency array. The effect will re-run only when any of the values in the array change.\n    ```typescript\n    useEffect(() => {\n      // Runs when `someProp` or `someState` changes\n      console.log('Prop or State Updated (via useEffect)');\n    }, [someProp, someState]); // Dependency array with specific values\n    ```\n\n*   **`componentWillUnmount` equivalent**: `useEffect` can return a cleanup function. This function will run right before the component unmounts, and also before the effect re-runs (if dependencies change) to clean up the previous effect's setup.\n    ```typescript\n    useEffect(() => {\n      const subscription = subscribeToData();\n      return () => {\n        // Cleanup function: runs on unmount or before next effect run\n        unsubscribeFromData(subscription);\n        console.log('Cleanup performed (via useEffect return)');\n      };\n    }, []); // Empty dependency array for mount/unmount cleanup\n    ```\n\n## `useMemo` and `useCallback` for Optimization\nWhile not direct replacements for lifecycle methods, `useMemo` and `useCallback` are crucial for performance optimization in functional components, analogous to how `shouldComponentUpdate` and `PureComponent` work. They help in preventing unnecessary re-renders of child components that are wrapped in `React.memo` by providing stable references for props.\n*   **`useCallback`**: Memoizes functions. Prevents functions from being re-created on every render, which is vital when passing functions as props to memoized child components.\n*   **`useMemo`**: Memoizes values. Prevents expensive calculations from being re-run on every render and provides stable object/array references to memoized child components.",
          "examples": [
            {
              "id": "example_hooks_data_fetching",
              "title": "Data Fetching with useEffect (componentDidMount equivalent)",
              "code": "import React, { useState, useEffect } from 'react';\n\ninterface Post {\n  id: number;\n  title: string;\n  body: string;\n}\n\nconst PostsFetcher: React.FC = () => {\n  const [posts, setPosts] = useState<Post[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    console.log('useEffect: Component Mounted, fetching posts...');\n    const fetchPosts = async () => {\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data: Post[] = await response.json();\n        setPosts(data);\n      } catch (err) {\n        setError(err as Error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchPosts();\n\n    // Optional: Cleanup function if there was a subscription or timer\n    return () => {\n      console.log('useEffect: Cleanup on unmount (e.g., abort fetch request)');\n      // Example: If using AbortController for fetch cleanup:\n      // controller.abort(); \n    };\n  }, []); // Empty dependency array means run once on mount and cleanup on unmount\n\n  if (loading) return <div>Loading posts...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      <h2>Blog Posts (Fetched with useEffect)</h2>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>\n            <strong>{post.title}</strong>\n            <p>{post.body.substring(0, 50)}...</p>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\n// Usage:\n// <PostsFetcher />\n",
              "explanation": "`useEffect` with an empty dependency array (`[]`) replicates `componentDidMount`. The `fetchPosts` function runs once when the component mounts. The optional return function from `useEffect` acts as `componentWillUnmount`, allowing for cleanup operations like canceling network requests or removing event listeners.",
              "language": "typescript"
            },
            {
              "id": "example_hooks_update_and_cleanup",
              "title": "Updating with useEffect (componentDidUpdate/WillUnmount equivalent)",
              "code": "import React, { useState, useEffect } from 'react';\n\nconst DebouncedInput: React.FC = () => {\n  const [inputValue, setInputValue] = useState('');\n  const [debouncedValue, setDebouncedValue] = useState('');\n\n  useEffect(() => {\n    console.log(`useEffect: Input value changed to \"${inputValue}\", setting up debounce...`);\n    // Set up a debounce timer\n    const timerId = setTimeout(() => {\n      setDebouncedValue(inputValue);\n      console.log(`Debounced value set to: \"${inputValue}\"`);\n    }, 500);\n\n    // Cleanup function: Clear the previous timer if inputValue changes before timer fires\n    return () => {\n      console.log(`useEffect: Cleaning up previous debounce timer for \"${inputValue}\"`);\n      clearTimeout(timerId);\n    };\n  }, [inputValue]); // Dependency array: re-run effect when inputValue changes\n\n  return (\n    <div style={{ border: '1px solid purple', margin: '5px', padding: '5px' }}>\n      <h4>Debounced Input (useEffect for Updates & Cleanup)</h4>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"Type something...\"\n      />\n      <p>Current Input: {inputValue}</p>\n      <p>Debounced Value: {debouncedValue}</p>\n    </div>\n  );\n};\n\n// Usage:\n// <DebouncedInput />\n",
              "explanation": "This example shows `useEffect` acting as both `componentDidUpdate` and `componentWillUnmount`. The effect runs whenever `inputValue` changes (due to `[inputValue]` in the dependency array). Inside the effect, a debounce timer is set. The return function (`clearTimeout(timerId)`) acts as a cleanup mechanism. If `inputValue` changes again before the 500ms timer elapses, the previous timer is cleared, preventing outdated `debouncedValue` updates. This pattern is common for search inputs, auto-save features, etc.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_hooks_effect_empty_array",
            "question_hooks_effect_no_array",
            "question_hooks_effect_dependency_array",
            "question_hooks_effect_cleanup",
            "question_hooks_useeffect_replacements",
            "question_hooks_usecallback_usememo_role",
            "question_hooks_lifecycle_mapping",
            "question_hooks_state_from_props_equivalent",
            "question_hooks_render_optimization"
          ],
          "relatedTasks": [
            "task_refactor_class_to_hooks_counter",
            "task_refactor_class_to_hooks_data_fetch"
          ],
          "tags": [
            "React",
            "React Hooks",
            "useEffect",
            "useCallback",
            "useMemo",
            "Functional Components",
            "Lifecycle Mapping",
            "Side Effects",
            "Cleanup"
          ],
          "technology": "React",
          "prerequisites": [
            "React Functional Components",
            "State Hook (useState)",
            "JavaScript Closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Modern React Development",
            "Hooks Best Practices",
            "State Management with Hooks"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lifecycle_http_location",
          "topic": "Lifecycle Methods: HTTP Requests",
          "level": "easy",
          "type": "mcq",
          "question": "In a React class component, which lifecycle method is the recommended place to make HTTP requests?",
          "answer": "`componentDidMount`",
          "options": [
            "`constructor`",
            "`render`",
            "`componentDidMount`",
            "`componentDidUpdate`"
          ],
          "analysisPoints": [
            "`constructor`: Only for initializing state and binding methods. Side effects like data fetching are not suitable here because the component has not yet mounted to the DOM.",
            "`render`: Should be a pure function that only returns JSX. Making HTTP requests here would cause side effects during rendering, potentially leading to infinite loops or unexpected behavior as it runs on every re-render.",
            "`componentDidMount`: Guarantees the component is mounted to the DOM, making it safe to interact with the DOM or initiate network requests. It runs only once after the initial render.",
            "`componentDidUpdate`: Runs after every update. Making initial HTTP requests here would require complex conditional logic to prevent re-fetching on every update, and it's generally not the primary place for initial data loads."
          ],
          "keyConcepts": [
            "componentDidMount",
            "Lifecycle Methods",
            "Side Effects",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Understanding of lifecycle method purposes",
            "Knowledge of best practices for data fetching"
          ],
          "example": "```typescript\nimport React, { Component } from 'react';\n\nclass MyComponent extends Component {\n  componentDidMount() {\n    // This is the best place to make API calls\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => this.setState({ data }))\n      .catch(error => console.error(error));\n  }\n  render() {\n    return <div>My Component</div>;\n  }\n}\n```",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "HTTP"
          ],
          "prerequisites": [
            "React Class Components",
            "Basic API calls"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_anti_pattern",
          "topic": "Lifecycle Methods: Updating State from Props",
          "level": "medium",
          "type": "code",
          "question": "The following `componentDidUpdate` implementation leads to an infinite loop. Explain why this happens and provide the corrected version.",
          "answer": "The provided `componentDidUpdate` causes an infinite loop because `this.setState` triggers a re-render, which in turn calls `componentDidUpdate` again, leading to a continuous cycle. The corrected version adds a condition to check if `this.props.items` has actually changed before calling `this.setState`.",
          "options": [],
          "analysisPoints": [
            "Identify the anti-pattern: Calling `setState` unconditionally in `componentDidUpdate`.",
            "Explain the loop mechanism: `setState` -> re-render -> `componentDidUpdate` -> `setState`...",
            "Provide the correct conditional logic: `if (prevProps.items !== this.props.items)`.",
            "Explain `getDerivedStateFromProps` as the preferred modern approach for deriving state from props."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "setState",
            "Infinite Loop",
            "Props vs State",
            "getDerivedStateFromProps"
          ],
          "evaluationCriteria": [
            "Ability to debug React lifecycle issues",
            "Knowledge of correct state update patterns",
            "Understanding of component re-rendering flow"
          ],
          "example": "```typescript\n// Original problematic code:\nclass MyComponent extends React.Component<{ items: any[] }, { filteredItems: any[] }> {\n  state = { filteredItems: [] };\n\n  componentDidUpdate(prevProps: { items: any[] }) {\n    // PROBLEM: This causes an infinite loop!\n    this.setState({ filteredItems: this.props.items.filter(item => item.active) });\n  }\n  render() { /* ... */ }\n}\n\n// Corrected version using componentDidUpdate:\nclass MyComponentCorrected extends React.Component<{ items: any[] }, { filteredItems: any[] }> {\n  state = { filteredItems: [] };\n\n  componentDidUpdate(prevProps: { items: any[] }) {\n    if (prevProps.items !== this.props.items) {\n      this.setState({ filteredItems: this.props.items.filter(item => item.active) });\n    }\n  }\n  render() { /* ... */ }\n}\n\n// Preferred modern approach using getDerivedStateFromProps:\nclass MyComponentGDSP extends React.Component<{ items: any[] }, { filteredItems: any[]; prevItems: any[] | null }> {\n  constructor(props: { items: any[] }) {\n    super(props);\n    this.state = { filteredItems: [], prevItems: null };\n  }\n\n  static getDerivedStateFromProps(props: { items: any[] }, state: { prevItems: any[] | null }) {\n    if (props.items !== state.prevItems) {\n      return {\n        filteredItems: props.items.filter(item => item.active),\n        prevItems: props.items\n      };\n    }\n    return null;\n  }\n  render() { /* ... */ }\n}\n```",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidUpdate",
            "State Management",
            "Debugging"
          ],
          "prerequisites": [
            "React Class Components",
            "State and Props"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_getderivedstatefromprops_usage",
          "topic": "Lifecycle Methods: getDerivedStateFromProps",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose and correct usage of `static getDerivedStateFromProps(props, state)`. What must it return, and what kind of side effects, if any, are allowed within it?",
          "answer": "The `static getDerivedStateFromProps(props, state)` lifecycle method is used to update the component's state based on changes in props. Its primary purpose is to derive new state values from props before a re-render. It is a static method, meaning it does not have access to the component instance (`this`).\n\nIt *must* return an object to update the state, or `null` if no state update is needed. This method is pure; it should not cause any side effects (like network requests, DOM manipulations, or calling `setState`). Its only role is to calculate and return the new state based on props and the current state.",
          "analysisPoints": [
            "Purpose: Derive state from props, triggered on mount and update.",
            "Static nature: No access to `this`.",
            "Return value: An object to update state, or `null` to do nothing.",
            "Purity: Must be side-effect free. No `setState`, no network calls, no DOM interaction."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Static Methods",
            "Pure Functions",
            "State Derivation",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Detailed explanation of `getDerivedStateFromProps`'s role",
            "Correct understanding of its static nature and return value",
            "Awareness of allowed/disallowed operations (purity)"
          ],
          "example": "```typescript\nimport React, { Component } from 'react';\n\ninterface MyComponentProps {\n  value: number;\n}\n\ninterface MyComponentState {\n  derivedValue: number;\n  lastValue: number | null;\n}\n\nclass MyComponent extends Component<MyComponentProps, MyComponentState> {\n  constructor(props: MyComponentProps) {\n    super(props);\n    this.state = {\n      derivedValue: props.value * 2,\n      lastValue: props.value,\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: MyComponentProps, prevState: MyComponentState) {\n    // Only update derivedValue if the 'value' prop has actually changed\n    if (nextProps.value !== prevState.lastValue) {\n      return {\n        derivedValue: nextProps.value * 2,\n        lastValue: nextProps.value,\n      };\n    }\n    // No change in 'value' prop, so no state update is needed\n    return null;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Original Value: {this.props.value}</p>\n        <p>Derived Value (from state): {this.state.derivedValue}</p>\n      </div>\n    );\n  }\n}\n```",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "getDerivedStateFromProps",
            "State Management"
          ],
          "prerequisites": [
            "React Class Components",
            "State and Props"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_shouldcomponentupdate_function",
          "topic": "Lifecycle Methods: shouldComponentUpdate",
          "level": "medium",
          "type": "mcq",
          "question": "Consider a React class component `MyComponent`. If `shouldComponentUpdate` is implemented as shown below, when will `MyComponent` re-render?\n\n```typescript\nclass MyComponent extends React.Component<{ id: number, name: string }, { count: number }> {\n  shouldComponentUpdate(nextProps: { id: number, name: string }, nextState: { count: number }) {\n    return nextProps.id !== this.props.id || nextState.count !== this.state.count;\n  }\n\n  render() {\n    console.log('MyComponent Rendered');\n    return <div>{this.props.name} - {this.props.id} - {this.state.count}</div>;\n  }\n}\n```\n\nA. When `id` prop changes or `count` state changes.\nB. When `name` prop changes or `count` state changes.\nC. Only when `id` prop changes.\nD. When `id`, `name` props or `count` state changes.",
          "answer": "A. When `id` prop changes or `count` state changes.",
          "options": [
            "A. When `id` prop changes or `count` state changes.",
            "B. When `name` prop changes or `count` state changes.",
            "C. Only when `id` prop changes.",
            "D. When `id`, `name` props or `count` state changes."
          ],
          "analysisPoints": [
            "The `shouldComponentUpdate` method explicitly checks `nextProps.id !== this.props.id` and `nextState.count !== this.state.count`.",
            "The `||` (OR) operator means the component will re-render if *either* condition is true.",
            "The `name` prop is explicitly *not* included in the comparison, so changes to `name` alone will *not* trigger a re-render.",
            "This demonstrates how `shouldComponentUpdate` provides granular control over re-rendering."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Component Re-rendering",
            "Props Comparison",
            "State Comparison"
          ],
          "evaluationCriteria": [
            "Understanding of `shouldComponentUpdate`'s return logic",
            "Ability to interpret conditional rendering logic"
          ],
          "example": "The code snippet provided in the question perfectly illustrates the concept. It shows that only explicitly checked props/state changes lead to a re-render.",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "shouldComponentUpdate",
            "Performance"
          ],
          "prerequisites": [
            "React Class Components",
            "Props and State"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_purecomponent_definition",
          "topic": "PureComponent",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between `React.Component` and `React.PureComponent`?",
          "answer": "`React.PureComponent` automatically implements `shouldComponentUpdate` with a shallow comparison of props and state, whereas `React.Component` does not, always re-rendering by default when parent renders or state/props change.",
          "analysisPoints": [],
          "keyConcepts": [
            "PureComponent",
            "shouldComponentUpdate",
            "Shallow Comparison"
          ],
          "evaluationCriteria": [
            "Recall of core difference"
          ],
          "example": "",
          "tags": [
            "React",
            "PureComponent",
            "Performance"
          ],
          "prerequisites": [
            "React Class Components"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_purecomponent_shallow_comparison",
          "topic": "PureComponent: Shallow Comparison",
          "level": "medium",
          "type": "mcq",
          "question": "A `PureComponent` receives `props.data = { value: 10 }`. In the next render, the parent component passes `props.data = { value: 10 }` again. Will the `PureComponent` re-render if `props.data` refers to a *new* object (even with the same content)?\n\n```typescript\nimport React, { PureComponent } from 'react';\n\ninterface MyProps {\n  data: { value: number };\n}\n\nclass MyPureComponent extends PureComponent<MyProps> {\n  render() {\n    console.log('MyPureComponent Rendered');\n    return <div>Value: {this.props.data.value}</div>;\n  }\n}\n\n// Parent component example:\nclass Parent extends React.Component<{}, { obj: { value: number } }> {\n  state = { obj: { value: 10 } };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.setState({ obj: { value: this.state.obj.value } })}>Update (new object reference)</button>\n        <MyPureComponent data={this.state.obj} />\n      </div>\n    );\n  }\n}\n```\n\nA. No, because the `value` property is the same (10).\nB. Yes, because `PureComponent` performs a deep comparison.\nC. Yes, because `PureComponent` performs a shallow comparison, and the object reference has changed.\nD. No, `PureComponent` would only re-render if the primitive `value` itself changed.",
          "answer": "C. Yes, because `PureComponent` performs a shallow comparison, and the object reference has changed.",
          "options": [
            "A. No, because the `value` property is the same (10).",
            "B. Yes, because `PureComponent` performs a deep comparison.",
            "C. Yes, because `PureComponent` performs a shallow comparison, and the object reference has changed.",
            "D. No, `PureComponent` would only re-render if the primitive `value` itself changed."
          ],
          "analysisPoints": [
            "`PureComponent` relies on shallow comparison.",
            "For objects and arrays, shallow comparison checks if the references are identical (`===`).",
            "Even if the *content* of the object is the same, if it's a *new object instance* (different reference), `PureComponent` considers it a change and re-renders.",
            "This is a common gotcha with `PureComponent` and `React.memo` when dealing with non-primitive props."
          ],
          "keyConcepts": [
            "PureComponent",
            "Shallow Comparison",
            "Object References",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding of shallow comparison for objects",
            "Recognition of reference vs. value equality"
          ],
          "example": "The provided code snippet and explanation clearly demonstrate this behavior.",
          "tags": [
            "React",
            "PureComponent",
            "Shallow Comparison",
            "Performance",
            "Gotchas"
          ],
          "prerequisites": [
            "PureComponent",
            "JavaScript Object References"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memo_purpose",
          "topic": "React.memo",
          "level": "easy",
          "type": "flashcard",
          "question": "What is `React.memo` used for, and what type of components does it optimize?",
          "answer": "`React.memo` is a Higher-Order Component (HOC) used for memoizing functional components. It optimizes performance by preventing unnecessary re-renders of functional components if their props have not shallowly changed.",
          "analysisPoints": [],
          "keyConcepts": [
            "React.memo",
            "Memoization",
            "Functional Components",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Recall of purpose and target components"
          ],
          "example": "",
          "tags": [
            "React",
            "React.memo",
            "Functional Components",
            "Performance"
          ],
          "prerequisites": [
            "React Functional Components"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_memo_vs_purecomponent",
          "topic": "React.memo vs. PureComponent",
          "level": "medium",
          "type": "open",
          "question": "Compare `React.memo` and `React.PureComponent`. What are their similarities and key differences, particularly regarding the components they apply to and their underlying optimization mechanism?",
          "answer": "### Similarities:\n*   Both `React.memo` and `React.PureComponent` are used for performance optimization in React by preventing unnecessary re-renders.\n*   Both implement a default *shallow comparison* of props (and state for `PureComponent`) to determine if a re-render is necessary. If the props/state are shallowly equal, the render is skipped.\n\n### Key Differences:\n*   **Component Type:** `React.PureComponent` is a base class used for *class components*. `React.memo` is a Higher-Order Component (HOC) used for *functional components*.\n*   **State Comparison:** `React.PureComponent` performs a shallow comparison on *both props and state*. `React.memo` *only* performs a shallow comparison on *props* (functional components manage state with hooks like `useState`, which inherently handles state updates efficiently).\n*   **Custom Comparison:** `React.PureComponent` can be overridden by implementing `shouldComponentUpdate` manually. `React.memo` allows for a custom comparison function as its second argument, which offers similar granular control.\n\nIn essence, `React.memo` is the functional component equivalent to `React.PureComponent`'s default behavior.",
          "analysisPoints": [
            "Similarities: Performance optimization, shallow comparison.",
            "Differences: Class vs. functional components.",
            "Differences: PureComponent checks state and props, memo only props (as state is managed differently).",
            "Differences: How custom comparison/rendering logic is applied (shouldComponentUpdate vs. second arg to memo)."
          ],
          "keyConcepts": [
            "React.memo",
            "PureComponent",
            "Shallow Comparison",
            "Functional Components",
            "Class Components",
            "Higher-Order Components",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Clear distinction between class and functional component application",
            "Accurate explanation of shallow comparison scope",
            "Understanding of their respective roles in optimization"
          ],
          "example": "```typescript\n// PureComponent (Class Component)\nclass MyClassComponent extends React.PureComponent<{ value: number }> {\n  render() { return <div>Class Value: {this.props.value}</div>; }\n}\n\n// React.memo (Functional Component)\nconst MyFunctionComponent = React.memo((props: { value: number }) => {\n  return <div>Function Value: {props.value}</div>;\n});\n```",
          "tags": [
            "React",
            "React.memo",
            "PureComponent",
            "Comparison",
            "Functional Components",
            "Class Components"
          ],
          "prerequisites": [
            "React Class Components",
            "React Functional Components",
            "Memoization"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memo_custom_comparison_return",
          "topic": "React.memo: Custom Comparison",
          "level": "medium",
          "type": "mcq",
          "question": "When providing a custom comparison function to `React.memo`, what should the function return to prevent the component from re-rendering?",
          "answer": "True",
          "options": [
            "True",
            "False",
            "Null",
            "Undefined"
          ],
          "analysisPoints": [
            "The custom comparison function for `React.memo` (`(prevProps, nextProps) => boolean`) returns `true` if the props are *equal*, meaning React should *skip* the re-render.",
            "This is the opposite logic of `shouldComponentUpdate` which returns `true` to *allow* a re-render.",
            "Understanding this inverse logic is crucial to correctly implementing custom memoization."
          ],
          "keyConcepts": [
            "React.memo",
            "Custom Comparison",
            "Memoization",
            "Performance Optimization",
            "shouldComponentUpdate vs. React.memo callback"
          ],
          "evaluationCriteria": [
            "Knowledge of `React.memo`'s custom comparison signature",
            "Correct interpretation of its return value for re-rendering control"
          ],
          "example": "```typescript\nconst MyComponent = React.memo(\n  function MyComponent(props: { id: number; name: string }) {\n    console.log('MyComponent Rendered');\n    return <div>{props.name} - {props.id}</div>;\n  },\n  // Returns true if props are EQUAL (skip re-render), false if DIFFERENT (re-render)\n  (prevProps, nextProps) => prevProps.id === nextProps.id && prevProps.name === nextProps.name\n);\n```",
          "tags": [
            "React",
            "React.memo",
            "Custom Comparison",
            "Functional Components"
          ],
          "prerequisites": [
            "React.memo"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_effect_empty_array",
          "topic": "Hooks: useEffect",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you use `useEffect` to replicate the behavior of `componentDidMount` in a functional component?",
          "answer": "By providing an empty dependency array (`[]`) as the second argument to `useEffect`. This ensures the effect runs only once after the initial render.",
          "analysisPoints": [],
          "keyConcepts": [
            "useEffect",
            "componentDidMount",
            "Dependency Array",
            "Hooks"
          ],
          "evaluationCriteria": [
            "Recall of basic useEffect usage"
          ],
          "example": "```typescript\nimport React, { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    console.log('Component Mounted!');\n    // This code runs once, similar to componentDidMount\n  }, []); // Empty dependency array\n  return <div>Hello</div>;\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "componentDidMount"
          ],
          "prerequisites": [
            "React Functional Components"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_effect_cleanup",
          "topic": "Hooks: useEffect Cleanup",
          "level": "medium",
          "type": "open",
          "question": "Explain how `useEffect` can be used to perform cleanup operations, similar to `componentWillUnmount`. Provide a simple code example.",
          "answer": "`useEffect` can perform cleanup operations by returning a function from the effect callback. This returned function will be executed when the component unmounts, or before the effect re-runs due to a change in its dependencies. This mechanism is ideal for unsubscribing from event listeners, clearing timers, or canceling network requests to prevent memory leaks or unexpected behavior.\n\nExample:\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction TimerComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Setting up timer...');\n    const intervalId = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n\n    // Cleanup function: runs on unmount or before the effect re-runs\n    return () => {\n      console.log('Cleaning up timer...');\n      clearInterval(intervalId);\n    };\n  }, []); // Empty dependency array means the effect runs once on mount, and cleanup on unmount\n\n  return <div>Timer: {count}</div>;\n}\n```\nIn this example, `clearInterval(intervalId)` will be called when `TimerComponent` is unmounted from the DOM, preventing the timer from continuing to run in the background and updating state on a non-existent component, which would lead to memory leaks.",
          "analysisPoints": [
            "Cleanup is done by returning a function from the `useEffect` callback.",
            "This function runs on unmount and before subsequent effect re-runs.",
            "Common use cases: unsubscribing, clearing timers, canceling requests.",
            "Prevents memory leaks and side effects on unmounted components."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "componentWillUnmount",
            "Side Effects",
            "Memory Leaks"
          ],
          "evaluationCriteria": [
            "Correct understanding of `useEffect`'s return value for cleanup",
            "Ability to provide a relevant code example",
            "Explanation of the benefits of cleanup"
          ],
          "example": "The code snippet provided in the answer serves as the example.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup",
            "componentWillUnmount",
            "Memory Management"
          ],
          "prerequisites": [
            "React Functional Components",
            "useState"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_lifecycle_mapping",
          "topic": "Hooks: Lifecycle Mapping",
          "level": "hard",
          "type": "code",
          "question": "Given the following class component with various lifecycle methods, refactor it into a functional component using React Hooks, specifically `useState`, `useEffect`, `useCallback`, and `useMemo` where appropriate. Explain how each original lifecycle responsibility is mapped to hooks.\n\n```typescript\nimport React, { Component } from 'react';\n\ninterface ClassComponentProps {\n  userId: number;\n  onUserClick: (id: number) => void;\n}\n\ninterface ClassComponentState {\n  userData: any | null;\n  loading: boolean;\n  internalCounter: number;\n}\n\nclass MyComplexClassComponent extends Component<ClassComponentProps, ClassComponentState> {\n  private intervalId: number | undefined;\n\n  constructor(props: ClassComponentProps) {\n    super(props);\n    this.state = {\n      userData: null,\n      loading: true,\n      internalCounter: 0,\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  componentDidMount() {\n    console.log('ClassComponent: componentDidMount - Fetching data');\n    this.fetchUserData(this.props.userId);\n    this.intervalId = window.setInterval(() => {\n      this.setState(prevState => ({ internalCounter: prevState.internalCounter + 1 }));\n    }, 1000);\n  }\n\n  componentDidUpdate(prevProps: ClassComponentProps, prevState: ClassComponentState) {\n    console.log('ClassComponent: componentDidUpdate');\n    if (prevProps.userId !== this.props.userId) {\n      console.log('ClassComponent: userId changed, re-fetching data');\n      this.fetchUserData(this.props.userId);\n    }\n    if (prevState.internalCounter !== this.state.internalCounter) {\n      console.log(`ClassComponent: Counter updated to ${this.state.internalCounter}`);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('ClassComponent: componentWillUnmount - Clearing interval');\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  fetchUserData = async (userId: number) => {\n    this.setState({ loading: true });\n    try {\n      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n      const data = await response.json();\n      this.setState({ userData: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching user data:', error);\n      this.setState({ loading: false, userData: null });\n    }\n  };\n\n  handleClick() {\n    this.props.onUserClick(this.props.userId);\n  }\n\n  render() {\n    const { userData, loading, internalCounter } = this.state;\n    const { userId } = this.props;\n\n    if (loading) return <div>Loading user data...</div>;\n    if (!userData) return <div>Failed to load user data.</div>;\n\n    return (\n      <div style={{ border: '2px solid navy', padding: '15px', margin: '15px' }}>\n        <h3>User Profile (Class Component)</h3>\n        <p>User ID: {userId}</p>\n        <p>Name: {userData.name}</p>\n        <p>Email: {userData.email}</p>\n        <p>Counter: {internalCounter}</p>\n        <button onClick={this.handleClick}>View Details (Class)</button>\n      </div>\n    );\n  }\n}\n```",
          "answer": "```typescript\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\n\ninterface FunctionalComponentProps {\n  userId: number;\n  onUserClick: (id: number) => void;\n}\n\nconst MyComplexFunctionalComponent: React.FC<FunctionalComponentProps> = ({ userId, onUserClick }) => {\n  const [userData, setUserData] = useState<any | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [internalCounter, setInternalCounter] = useState(0);\n\n  // componentDidMount + componentDidUpdate (for userId change) + Cleanup\n  useEffect(() => {\n    console.log('FunctionalComponent: useEffect for data fetching (mount + userId change)');\n    const fetchUserData = async () => {\n      setLoading(true);\n      try {\n        const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        setUserData(data);\n      } catch (error) {\n        console.error('Error fetching user data:', error);\n        setUserData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUserData();\n\n    // Cleanup for data fetching (e.g., abort controller if fetch was cancellable)\n    // For this simple fetch, no explicit cleanup needed, but conceptually it would be here.\n\n  }, [userId]); // Dependency array: re-run effect when userId changes\n\n  // componentDidMount + componentWillUnmount (for interval)\n  useEffect(() => {\n    console.log('FunctionalComponent: useEffect for interval (mount + unmount cleanup)');\n    const intervalId = window.setInterval(() => {\n      setInternalCounter(prevCount => prevCount + 1);\n    }, 1000);\n\n    // Cleanup function: clears interval on unmount or before re-running (if dependencies existed)\n    return () => {\n      console.log('FunctionalComponent: Clearing interval on unmount');\n      clearInterval(intervalId);\n    };\n  }, []); // Empty dependency array: runs once on mount, cleanup on unmount\n\n  // Mimic componentDidUpdate for internalCounter for logging purposes (optional)\n  useEffect(() => {\n    if (internalCounter > 0) { // To prevent running on initial mount\n        console.log(`FunctionalComponent: Counter updated to ${internalCounter}`);\n    }\n  }, [internalCounter]);\n\n  // Memoize handleClick function to prevent unnecessary re-creation\n  // Similar to binding in constructor, but for functional components\n  const handleClick = useCallback(() => {\n    onUserClick(userId);\n  }, [onUserClick, userId]); // Dependencies for useCallback\n\n  // Memoize derived data or expensive calculations if needed (not strictly required here)\n  const displayUserName = useMemo(() => {\n      if (!userData) return 'N/A';\n      console.log('FunctionalComponent: Recomputing display user name');\n      return userData.name.toUpperCase(); // Example of expensive computation\n  }, [userData]); // Recompute only if userData changes\n\n  if (loading) return <div>Loading user data...</div>;\n  if (!userData) return <div>Failed to load user data.</div>;\n\n  return (\n    <div style={{ border: '2px solid green', padding: '15px', margin: '15px' }}>\n      <h3>User Profile (Functional Component - Hooks)</h3>\n      <p>User ID: {userId}</p>\n      <p>Name: {displayUserName}</p>\n      <p>Email: {userData.email}</p>\n      <p>Counter: {internalCounter}</p>\n      <button onClick={handleClick}>View Details (Hooks)</button>\n    </div>\n  );\n};\n```\n\n### Mapping Explanation:\n*   **State (`userData`, `loading`, `internalCounter`)**: All state variables are managed using the `useState` hook. Each call to `useState` initializes a piece of state and provides a setter function.\n*   **`componentDidMount` (Initial Data Fetching & Interval Setup)**:\n    *   The data fetching logic is moved into a `useEffect` hook with `[userId]` as its dependency array. On initial mount, `userId` is available, so it fetches the data. If `userId` ever changes, it re-runs, serving as the `componentDidUpdate` equivalent for `userId` changes.\n    *   The `setInterval` logic is placed in a separate `useEffect` hook with an empty dependency array (`[]`). This ensures it runs only once after the initial render. Its cleanup function (`return () => clearInterval(intervalId);`) handles `componentWillUnmount` behavior for the interval.\n*   **`componentDidUpdate` (Conditional Data Re-fetching)**: This responsibility is integrated into the first `useEffect` hook by including `userId` in its dependency array. The effect will re-run whenever `userId` changes, effectively replacing the `if (prevProps.userId !== this.props.userId)` check.\n*   **`componentWillUnmount` (Clearing Interval)**: The cleanup function returned by the second `useEffect` hook (the one managing the interval) directly replaces `componentWillUnmount`'s responsibility for clearing the interval.\n*   **Method Binding (`handleClick`)**: In class components, `this.handleClick = this.handleClick.bind(this)` is often used for method binding. In functional components, `useCallback` is used to memoize functions (`handleClick` in this case). This prevents the function from being re-created on every render, which is beneficial when passing it as a prop to child components (especially memoized ones) to prevent unnecessary re-renders of children.\n*   **Derived Data/Expensive Calculations (e.g., `displayUserName`)**: While not explicitly in the original class component's lifecycle methods, for optimizing derived values or expensive computations that depend on specific state/props, `useMemo` is used. It memoizes the result and only re-computes if its dependencies change, similar to `shouldComponentUpdate` for values.",
          "analysisPoints": [
            "Correctly identifies `useState` for all state variables.",
            "Maps `componentDidMount` to `useEffect` with `[]`.",
            "Maps `componentDidUpdate` conditional logic to `useEffect` with specific dependencies.",
            "Maps `componentWillUnmount` to `useEffect`'s cleanup return function.",
            "Uses `useCallback` for memoizing event handlers.",
            "Uses `useMemo` for memoizing derived values (optional but good practice for completeness).",
            "Explains the rationale for each hook mapping.",
            "Handles the interval cleanup correctly."
          ],
          "keyConcepts": [
            "React Hooks",
            "useState",
            "useEffect",
            "useCallback",
            "useMemo",
            "Class to Functional Component Refactoring",
            "Lifecycle Methods",
            "Side Effects",
            "Memoization"
          ],
          "evaluationCriteria": [
            "Accuracy of hook usage for lifecycle responsibilities",
            "Correct handling of dependencies in `useEffect` and `useCallback`/`useMemo`",
            "Clarity of explanation for mapping concepts",
            "Ability to implement practical, performant hooks solution"
          ],
          "example": "The provided refactored code and detailed explanation.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "useCallback",
            "useMemo",
            "Refactoring",
            "Class Components",
            "Functional Components",
            "Advanced"
          ],
          "prerequisites": [
            "All React Hooks",
            "Class Component Lifecycles"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifecycle_order_of_methods",
          "topic": "Lifecycle Methods Order",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following represents the correct order of execution for these React class component lifecycle methods during the initial mounting phase?",
          "answer": "constructor -> static getDerivedStateFromProps -> render -> componentDidMount",
          "options": [
            "constructor -> render -> componentDidMount -> componentDidUpdate",
            "constructor -> static getDerivedStateFromProps -> render -> componentDidMount",
            "static getDerivedStateFromProps -> constructor -> render -> componentDidMount",
            "render -> componentDidMount -> constructor -> componentDidUpdate"
          ],
          "analysisPoints": [
            "During mounting, the sequence starts with `constructor` for initialization.",
            "Then `static getDerivedStateFromProps` is called to update state based on props before rendering.",
            "`render` is then called to create the React elements.",
            "Finally, `componentDidMount` is called after the component has been rendered to the DOM.",
            "`componentDidUpdate` is not part of the initial mounting phase."
          ],
          "keyConcepts": [
            "Lifecycle Methods",
            "Mounting Phase",
            "constructor",
            "getDerivedStateFromProps",
            "render",
            "componentDidMount"
          ],
          "evaluationCriteria": [
            "Knowledge of React component lifecycle phases",
            "Correct ordering of mounting lifecycle methods"
          ],
          "example": "```typescript\nimport React, { Component } from 'react';\n\nclass LifecycleOrderComponent extends Component {\n  constructor(props: {}) {\n    super(props);\n    console.log('1. Constructor');\n    this.state = {};\n  }\n\n  static getDerivedStateFromProps(props: {}, state: {}) {\n    console.log('2. static getDerivedStateFromProps');\n    return null; // Or return state update\n  }\n\n  componentDidMount() {\n    console.log('4. componentDidMount');\n  }\n\n  render() {\n    console.log('3. Render');\n    return <div>Check console for order.</div>;\n  }\n}\n// When <LifecycleOrderComponent /> is mounted, the console will show the expected order.\n```",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Mounting"
          ],
          "prerequisites": [
            "React Class Components"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_api_call_why_cdm",
          "topic": "Lifecycle Methods: Data Fetching Rationale",
          "level": "medium",
          "type": "open",
          "question": "Why is `componentDidMount` considered the 'best place' for API calls in a React class component, rather than the `constructor` or `render` method?",
          "answer": "`componentDidMount` is the best place for API calls because:\n1.  **Component is Mounted:** At this point, the component has been rendered to the DOM, and it's safe to perform operations that interact with the DOM or require the component to be fully initialized.\n2.  **Prevents Unnecessary Renders/Loops:** Unlike `render`, which runs on every update, `componentDidMount` runs only once after the initial render. Placing API calls here prevents the component from re-fetching data on every re-render (which `render` would do) or getting into infinite loops (`setState` in `render` or unconditional `setState` in `componentDidUpdate`).\n3.  **State Available:** You can safely call `this.setState` within `componentDidMount` to update the component's state with the fetched data, triggering a re-render with the new data. In the `constructor`, `setState` is not available, and directly modifying `this.state` outside of `constructor` is an anti-pattern.\n\nIn contrast:\n*   **`constructor`**: Used only for initial state setup and method binding. The component is not yet mounted to the DOM, so side effects like API calls are inappropriate and cannot update the rendered UI immediately.\n*   **`render`**: Must be a pure function. Side effects like API calls are prohibited as they can lead to unpredictable behavior, performance issues, and infinite re-render loops.",
          "analysisPoints": [
            "Component mounted status.",
            "Prevention of infinite loops/unnecessary fetches.",
            "Availability of `setState`.",
            "Purity of `render` method.",
            "Limitations of `constructor` for side effects."
          ],
          "keyConcepts": [
            "componentDidMount",
            "constructor",
            "render",
            "Side Effects",
            "Data Fetching",
            "Lifecycle Phases",
            "Performance"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of reasons for `componentDidMount`",
            "Clear contrast with `constructor` and `render`",
            "Understanding of side effects in React"
          ],
          "example": "See `theory_lifecycle_best_practices` and `example_lifecycle_http_request` for context.",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "Data Fetching",
            "Best Practices"
          ],
          "prerequisites": [
            "React Class Components",
            "Lifecycle Overview"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_props_to_state_pattern",
          "topic": "Lifecycle Methods: Prop-to-State Derivation",
          "level": "medium",
          "type": "flashcard",
          "question": "You have a class component where part of its state should be derived from props, and updated whenever those props change. What is the recommended lifecycle method for this pattern, and why not use `componentDidUpdate` unconditionally?",
          "answer": "The recommended lifecycle method is `static getDerivedStateFromProps`. You should not use `componentDidUpdate` unconditionally because calling `this.setState` inside it without a condition comparing `prevProps` to `this.props` would lead to an infinite re-render loop.",
          "analysisPoints": [],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "componentDidUpdate",
            "Prop-Derived State",
            "Infinite Loop",
            "Lifecycle Patterns"
          ],
          "evaluationCriteria": [
            "Recall of recommended pattern and anti-pattern"
          ],
          "example": "See `example_lifecycle_update_props` for reference.",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "getDerivedStateFromProps",
            "componentDidUpdate",
            "State Management"
          ],
          "prerequisites": [
            "React Class Components",
            "State and Props"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_effect_no_array",
          "topic": "Hooks: useEffect without Dependency Array",
          "level": "easy",
          "type": "mcq",
          "question": "What is the behavior of a `useEffect` hook if no dependency array is provided?",
          "answer": "It runs after every render, on both mount and every update.",
          "options": [
            "It runs only once on mount, like `componentDidMount`.",
            "It runs after every render, on both mount and every update.",
            "It throws an error, as a dependency array is always required.",
            "It only runs if the component's state changes, but not if props change."
          ],
          "analysisPoints": [
            "Omitting the dependency array means the effect runs after *every* successful render cycle.",
            "This is generally discouraged due to potential performance issues or infinite loops if the effect modifies state without a proper condition."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Side Effects",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect`'s default behavior",
            "Knowledge of dependency array's importance"
          ],
          "example": "```typescript\nimport React, { useEffect, useState } from 'react';\n\nfunction LoggerComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect without dependency array (runs on every render)');\n  }); // No dependency array\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <p>Count: {count}</p>\n    </div>\n  );\n}\n// Every click will cause 'Effect without dependency array' to log.\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependency Array"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_effect_dependency_array",
          "topic": "Hooks: useEffect with Dependency Array",
          "level": "medium",
          "type": "open",
          "question": "Describe the role of the dependency array in `useEffect`. How does it influence when the effect function executes, and what is the consequence of incorrectly specifying or omitting dependencies?",
          "answer": "The dependency array (the second argument to `useEffect`) controls when the effect function re-executes. React will re-run the effect only if any of the values in the dependency array have changed between renders (compared using strict equality, `===`).\n\n*   **Empty array (`[]`)**: The effect runs only once after the initial render and the cleanup function runs only on unmount. This is similar to `componentDidMount`.\n*   **No array (omitted)**: The effect runs after every render (mount and all updates). This is rarely what you want and can lead to performance issues or infinite loops.\n*   **Array with values (`[dep1, dep2]`)**: The effect runs after the initial render and then re-runs whenever `dep1` or `dep2` (or both) change. The cleanup function runs before the new effect is applied and also on unmount.\n\n**Consequences of incorrect dependencies:**\n*   **Omitting a dependency that *is* used inside the effect**: Leads to stale closures. The effect might capture old values of state or props from the render when it was first created, even if those values have since changed. This can result in bugs, incorrect calculations, or outdated UI.\n*   **Including too many dependencies**: Causes the effect to run more often than necessary, potentially leading to performance bottlenecks from unnecessary re-renders or side effects. This can negate the benefits of memoization.",
          "analysisPoints": [
            "Control execution frequency based on changes.",
            "Behavior with empty array (`[]`).",
            "Behavior with no array.",
            "Behavior with specific dependencies.",
            "Consequence of missing dependencies (stale closures).",
            "Consequence of too many dependencies (over-rendering)."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Stale Closures",
            "Performance Optimization",
            "Side Effects",
            "Hooks Best Practices"
          ],
          "evaluationCriteria": [
            "Thorough explanation of dependency array's role",
            "Clear differentiation of behaviors based on array content",
            "Accurate description of consequences of incorrect dependencies"
          ],
          "example": "See `theory_hooks_replacing_lifecycles` for code examples.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependency Array",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_usecallback_usememo_role",
          "topic": "Hooks: useCallback and useMemo",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of `useCallback` and `useMemo` in conjunction with `React.memo` for optimizing functional components. When and why would you use them?",
          "answer": "`useCallback` and `useMemo` are memoization hooks that work in tandem with `React.memo` to optimize functional components by ensuring stable references for functions and values, respectively.\n\n*   **`useCallback`**: This hook memoizes a *function*. When a functional component re-renders, any function defined inside it is re-created, leading to a new reference. If this function is passed as a prop to a child component wrapped in `React.memo`, the child would unnecessarily re-render because `React.memo`'s shallow comparison would see a new function reference. `useCallback` returns a memoized version of the callback function that only changes if one of its dependencies has changed. This prevents child components from re-rendering just because a function prop's reference changed.\n    *   **When to use**: When passing callback functions to optimized child components (e.g., `React.memo`, `PureComponent`), or when a function is a dependency of another `useEffect` or `useMemo` hook.\n\n*   **`useMemo`**: This hook memoizes a *value* (the result of a computation). Similar to functions, objects and arrays created inline during a render will have a new reference on every re-render, even if their content is identical. If such an object/array is passed as a prop to a `React.memo`'d child, it would cause an unnecessary re-render. `useMemo` computes its value only when one of its dependencies changes. It returns the memoized value.\n    *   **When to use**: For expensive calculations whose results are stable across renders, or when passing objects/arrays as props to optimized child components to ensure a stable reference.\n\n**Why use them?** They prevent `React.memo` (and `PureComponent`) from failing its shallow comparison due to constantly changing references of non-primitive props (functions, objects, arrays), thereby ensuring that memoized components only re-render when their *relevant* props truly change, leading to better performance.",
          "analysisPoints": [
            "Define `useCallback` (memoizes functions).",
            "Define `useMemo` (memoizes values/results).",
            "Explain how they prevent reference changes from triggering `React.memo` re-renders.",
            "Provide clear use cases for each.",
            "Emphasize their role in conjunction with `React.memo` for effective optimization."
          ],
          "keyConcepts": [
            "useCallback",
            "useMemo",
            "React.memo",
            "Memoization",
            "Performance Optimization",
            "Stable References",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Accurate definitions and distinctions between the two hooks",
            "Clear explanation of their purpose in optimization",
            "Understanding of their relationship with `React.memo`"
          ],
          "example": "See `theory_hooks_replacing_lifecycles` for example snippets.",
          "tags": [
            "React",
            "Hooks",
            "useCallback",
            "useMemo",
            "React.memo",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "React Hooks",
            "React.memo"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_data_fetching_component",
          "title": "Implement a Basic Data Fetching Component (Class Component)",
          "description": "\nCreate a React class component that fetches a list of items from a public API (`https://jsonplaceholder.typicode.com/todos?_limit=5`) and displays them. The component should:\n\n1.  Initialize state to handle `todos` (an empty array), `loading` (true), and `error` (null).\n2.  Perform the API call in the correct lifecycle method.\n3.  Update the state based on the fetch result (success or error).\n4.  Render a 'Loading...' message while fetching.\n5.  Render an 'Error: [message]' if the fetch fails.\n6.  Render the list of fetched todo titles once successful.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Component } from 'react';\n\ninterface Todo {\n  userId: number;\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\ninterface TodoListState {\n  todos: Todo[];\n  loading: boolean;\n  error: Error | null;\n}\n\nclass TodoListFetcher extends Component<{}, TodoListState> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      todos: [],\n      loading: true,\n      error: null,\n    };\n  }\n\n  // TODO: Implement componentDidMount for API call\n\n  render() {\n    const { todos, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading todos...</div>;\n    }\n\n    if (error) {\n      return <div>Error: {error.message}</div>;\n    }\n\n    return (\n      <div>\n        <h2>Fetched Todos</h2>\n        <ul>\n          {todos.map(todo => (\n            <li key={todo.id}>{todo.title}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default TodoListFetcher;\n",
          "solutionCode": "import React, { Component } from 'react';\n\ninterface Todo {\n  userId: number;\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\ninterface TodoListState {\n  todos: Todo[];\n  loading: boolean;\n  error: Error | null;\n}\n\nclass TodoListFetcher extends Component<{}, TodoListState> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      todos: [],\n      loading: true,\n      error: null,\n    };\n  }\n\n  componentDidMount() {\n    console.log('Fetching todos...');\n    fetch('https://jsonplaceholder.typicode.com/todos?_limit=5')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then((data: Todo[]) => {\n        this.setState({ todos: data, loading: false });\n        console.log('Todos fetched successfully.');\n      })\n      .catch(error => {\n        this.setState({ error, loading: false });\n        console.error('Error fetching todos:', error);\n      });\n  }\n\n  render() {\n    const { todos, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading todos...</div>;\n    }\n\n    if (error) {\n      return <div>Error: {error.message}</div>;\n    }\n\n    return (\n      <div>\n        <h2>Fetched Todos</h2>\n        <ul>\n          {todos.map(todo => (\n            <li key={todo.id}>{todo.title}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default TodoListFetcher;\n",
          "testCases": [
            "Component should display 'Loading todos...' initially.",
            "After successful fetch, component should display 5 todo titles.",
            "If fetch fails (e.g., API returns 404), component should display an error message.",
            "Network request should only occur once upon component mount."
          ],
          "hints": [
            "Remember to place network requests in `componentDidMount`.",
            "Handle both success (`.then()`) and error (`.catch()`) cases for the `fetch` promise.",
            "Update the `loading` state to `false` in both success and error handlers.",
            "Ensure `this.setState` is used correctly to update state."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "Data Fetching",
            "State Management"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Class Components",
            "Fetch API",
            "State and Props"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "relatedConcepts": [
            "componentDidMount",
            "State Management",
            "Error Handling"
          ]
        },
        {
          "id": "task_filterable_list_gdsfp",
          "title": "Implement a Filterable List with Prop-Derived State (Class Component)",
          "description": "\nCreate a React class component named `FilterableItemList` that displays a filtered list of items. The component should:\n\n1.  Accept an array of `items` as a prop. Each item has `id: number`, `name: string`, and `isActive: boolean`.\n2.  Maintain a state variable `filteredItems` that contains only the `isActive: true` items from the `items` prop.\n3.  Use `static getDerivedStateFromProps` to update `filteredItems` whenever the `items` prop changes. Ensure it correctly handles initial mount and subsequent prop updates.\n4.  The component should only re-derive state if the `items` prop array reference itself changes. You'll need to store the previous `items` prop in state to achieve this correctly.\n5.  Render the `filteredItems`.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Component } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  isActive: boolean;\n}\n\ninterface FilterableItemListProps {\n  items: Item[];\n}\n\ninterface FilterableItemListState {\n  filteredItems: Item[];\n  // TODO: Add state to track previous items prop for comparison\n  prevItemsProp: Item[] | null;\n}\n\nclass FilterableItemList extends Component<FilterableItemListProps, FilterableItemListState> {\n  constructor(props: FilterableItemListProps) {\n    super(props);\n    this.state = {\n      filteredItems: [],\n      prevItemsProp: null,\n    };\n  }\n\n  // TODO: Implement static getDerivedStateFromProps\n  // It should update filteredItems ONLY if props.items has changed\n  // Remember to store the current props.items for the next comparison\n\n  render() {\n    return (\n      <div>\n        <h3>Filtered Items</h3>\n        {this.state.filteredItems.length === 0 ? (\n          <p>No active items.</p>\n        ) : (\n          <ul>\n            {this.state.filteredItems.map(item => (\n              <li key={item.id}>{item.name}</li>\n            ))}\n          </ul>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default FilterableItemList;\n",
          "solutionCode": "import React, { Component } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  isActive: boolean;\n}\n\ninterface FilterableItemListProps {\n  items: Item[];\n}\n\ninterface FilterableItemListState {\n  filteredItems: Item[];\n  prevItemsProp: Item[] | null; // Used to track previous items prop\n}\n\nclass FilterableItemList extends Component<FilterableItemListProps, FilterableItemListState> {\n  constructor(props: FilterableItemListProps) {\n    super(props);\n    this.state = {\n      filteredItems: [],\n      prevItemsProp: null,\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: FilterableItemListProps, prevState: FilterableItemListState) {\n    // Check if the items prop has changed (by reference)\n    if (nextProps.items !== prevState.prevItemsProp) {\n      console.log('getDerivedStateFromProps: Items prop changed, recalculating filteredItems');\n      return {\n        filteredItems: nextProps.items.filter(item => item.isActive),\n        prevItemsProp: nextProps.items, // Update prevItemsProp for the next comparison\n      };\n    }\n    // If items prop has not changed, return null to indicate no state update\n    return null;\n  }\n\n  render() {\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '10px' }}>\n        <h3>Filtered Items (Active)</h3>\n        {this.state.filteredItems.length === 0 ? (\n          <p>No active items.</p>\n        ) : (\n          <ul>\n            {this.state.filteredItems.map(item => (\n              <li key={item.id}>{item.name}</li>\n            ))}\n          </ul>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default FilterableItemList;\n",
          "testCases": [
            "Initial render: If `items` prop contains active items, `filteredItems` should correctly reflect them.",
            "Prop update (same reference): If parent re-renders passing the *same* `items` array reference, `getDerivedStateFromProps` should return `null` and not re-calculate.",
            "Prop update (new reference): If parent passes a *new* `items` array reference (even if contents are similar), `getDerivedStateFromProps` should correctly re-filter and update `filteredItems`.",
            "Prop update (no active items): If the new `items` prop contains no active items, `filteredItems` should be empty and display 'No active items.'",
            "Prop update (all active items): If the new `items` prop contains all active items, all items should be displayed."
          ],
          "hints": [
            "Remember that `getDerivedStateFromProps` is a `static` method.",
            "It receives `nextProps` and `prevState` as arguments.",
            "It must return an object to update state, or `null` if no update is needed.",
            "To detect changes in the `items` prop, you'll need to store the *previous* `items` prop in the component's state and compare against it."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "getDerivedStateFromProps",
            "State Management",
            "Props"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "JavaScript Array Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "getDerivedStateFromProps",
            "State Derivation",
            "Prop Immutability"
          ]
        },
        {
          "id": "task_optimize_component_scu",
          "title": "Optimize a Component with shouldComponentUpdate or PureComponent",
          "description": "\nCreate two React components: `ParentComponent` and `ChildComponent`.\n\n`ParentComponent` should:\n1.  Maintain a state `counter` and `statusMessage`.\n2.  Render `ChildComponent` and pass `counter` as an `id` prop and `statusMessage` as a `message` prop.\n3.  Have a button to increment `counter`.\n4.  Have a button to change `statusMessage`.\n\n`ChildComponent` should initially be a regular `React.Component` that logs 'ChildComponent Rendered' on every render. Your task is to optimize `ChildComponent` so that:\n\n1.  It *only* re-renders when its `id` prop changes, and *not* when its `message` prop changes.\n2.  You can achieve this using either `shouldComponentUpdate` or by extending `React.PureComponent` (if PureComponent meets the requirement, explain why/why not).\n\nIf using `shouldComponentUpdate`, implement the custom logic. If using `PureComponent`, explain why it does or does not meet the specific requirement of ignoring `message` prop changes.",
          "difficulty": "medium",
          "startingCode": "import React, { Component } from 'react';\n\ninterface ChildProps {\n  id: number;\n  message: string;\n}\n\n// ChildComponent (initially a regular Component)\nclass ChildComponent extends Component<ChildProps> {\n  render() {\n    console.log(`ChildComponent (ID: ${this.props.id}, Message: ${this.props.message}): Rendered`);\n    return (\n      <div style={{ border: '1px solid lightblue', padding: '10px', margin: '5px' }}>\n        <h4>Child Component</h4>\n        <p>ID: {this.props.id}</p>\n        <p>Message: {this.props.message}</p>\n      </div>\n    );\n  }\n}\n\ninterface ParentState {\n  counter: number;\n  statusMessage: string;\n}\n\nclass ParentComponent extends Component<{}, ParentState> {\n  state = {\n    counter: 0,\n    statusMessage: 'Initial Status',\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n        <h2>Parent Component</h2>\n        <button onClick={() => this.setState(prevState => ({ counter: prevState.counter + 1 }))}>\n          Increment Counter (Changes ID Prop)\n        </button>\n        <button onClick={() => this.setState({ statusMessage: `Status Update ${Math.random().toFixed(2)}` })}>\n          Change Status Message (Changes Message Prop)\n        </button>\n        <p>Parent Counter: {this.state.counter}</p>\n        <ChildComponent id={this.state.counter} message={this.state.statusMessage} />\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n",
          "solutionCode": "import React, { Component, PureComponent } from 'react';\n\ninterface ChildProps {\n  id: number;\n  message: string;\n}\n\n// Option 1: Using shouldComponentUpdate\nclass OptimizedChildComponentSCU extends Component<ChildProps> {\n  shouldComponentUpdate(nextProps: ChildProps, nextState: {}) {\n    // Only re-render if 'id' prop changes, ignore 'message' prop changes\n    const shouldUpdate = nextProps.id !== this.props.id;\n    console.log(`OptimizedChildComponentSCU (ID: ${this.props.id}, Message: ${this.props.message}): shouldComponentUpdate returned ${shouldUpdate}`);\n    return shouldUpdate;\n  }\n\n  render() {\n    console.log(`OptimizedChildComponentSCU (ID: ${this.props.id}, Message: ${this.props.message}): Rendered`);\n    return (\n      <div style={{ border: '1px solid lightgreen', padding: '10px', margin: '5px' }}>\n        <h4>Optimized Child (using shouldComponentUpdate)</h4>\n        <p>ID: {this.props.id}</p>\n        <p>Message: {this.props.message}</p>\n      </div>\n    );\n  }\n}\n\n// Option 2: Using PureComponent (and explaining its behavior for this specific case)\nclass OptimizedChildComponentPure extends PureComponent<ChildProps> {\n  render() {\n    console.log(`OptimizedChildComponentPure (ID: ${this.props.id}, Message: ${this.props.message}): Rendered`);\n    return (\n      <div style={{ border: '1px solid lightcoral', padding: '10px', margin: '5px' }}>\n        <h4>Optimized Child (using PureComponent)</h4>\n        <p>ID: {this.props.id}</p>\n        <p>Message: {this.props.message}</p>\n      </div>\n    );\n  }\n}\n/*\nExplanation for PureComponent:\nPureComponent performs a shallow comparison of ALL props. In this case, if 'message' prop changes, \nPureComponent WILL detect that change (since 'message' is a string, a primitive, it will be referentially different)\nand WILL trigger a re-render. Therefore, PureComponent does NOT meet the specific requirement of \n*only* re-rendering when 'id' changes and ignoring 'message'. For that specific control, \nshouldComponentUpdate with custom logic is necessary.\n*/\n\ninterface ParentState {\n  counter: number;\n  statusMessage: string;\n}\n\nclass ParentComponent extends Component<{}, ParentState> {\n  state = {\n    counter: 0,\n    statusMessage: 'Initial Status',\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n        <h2>Parent Component</h2>\n        <button onClick={() => this.setState(prevState => ({ counter: prevState.counter + 1 }))}>\n          Increment Counter (Changes ID Prop)\n        </button>\n        <button onClick={() => this.setState({ statusMessage: `Status Update ${Math.random().toFixed(2)}` })}>\n          Change Status Message (Changes Message Prop)\n        </button>\n        <p>Parent Counter: {this.state.counter}</p>\n        \n        {/* Choose one of the optimized child components */}\n        <OptimizedChildComponentSCU id={this.state.counter} message={this.state.statusMessage} />\n        {/* <OptimizedChildComponentPure id={this.state.counter} message={this.state.statusMessage} /> */}\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n",
          "testCases": [
            "Initial render: `ChildComponent` should render once.",
            "Changing `statusMessage`: `ChildComponent` should NOT re-render (only `ParentComponent` and its children that are not optimized, or where the optimization fails).",
            "Changing `counter`: `ChildComponent` SHOULD re-render.",
            "Verify console logs to confirm render behavior for both test cases.",
            "If `PureComponent` is used, explain why it will re-render for `statusMessage` changes."
          ],
          "hints": [
            "The `shouldComponentUpdate` method receives `nextProps` and `nextState`.",
            "It should return `true` to allow a re-render, `false` to prevent it.",
            "Think carefully about what exact condition will prevent re-renders when only `message` changes but allow them when `id` changes.",
            "Consider how `PureComponent`'s shallow comparison works for primitive values like strings. Does it meet the specific requirement of ignoring *certain* prop changes?"
          ],
          "tags": [
            "React",
            "Class Components",
            "Performance Optimization",
            "shouldComponentUpdate",
            "PureComponent"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "Component Re-rendering"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "shouldComponentUpdate",
            "PureComponent",
            "Shallow Comparison",
            "Performance Tuning"
          ]
        },
        {
          "id": "task_purecomponent_demonstration",
          "title": "Demonstrate React.PureComponent Behavior",
          "description": "\nCreate a `ParentComponent` and two child components: `RegularChild` (extending `React.Component`) and `PureChild` (extending `React.PureComponent`).\n\n`ParentComponent` should:\n1.  Maintain a state variable `data` which is an object with a `value` property (e.g., `{ value: 'initial' }`).\n2.  Maintain another state variable `updateCount` which is a number.\n3.  Render both `RegularChild` and `PureChild`, passing the `data` object as a prop to both.\n4.  Include two buttons:\n    a.  One button to update `updateCount` (e.g., `this.setState({ updateCount: this.state.updateCount + 1 })`). This will cause the `ParentComponent` to re-render, but does not change the `data` object prop passed to children.\n    b.  Another button to update the `data` object, but *crucially*, recreate the object reference while keeping the `value` property the same (e.g., `this.setState({ data: { value: this.state.data.value } })`).\n\nBoth `RegularChild` and `PureChild` should:\n*   Simply display the `value` from their `data` prop.\n*   Log 'RegularChild Rendered' or 'PureChild Rendered' respectively in their `render` method.\n\nObserve and explain the differences in console logs when each button is clicked, highlighting how `PureComponent` behaves due to shallow comparison of the object prop.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Component, PureComponent } from 'react';\n\ninterface ChildProps {\n  data: { value: string };\n}\n\n// Regular Child Component\nclass RegularChild extends Component<ChildProps> {\n  render() {\n    console.log('RegularChild Rendered');\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '5px' }}>\n        <h3>Regular Child</h3>\n        <p>Value: {this.props.data.value}</p>\n      </div>\n    );\n  }\n}\n\n// Pure Child Component\nclass PureChild extends PureComponent<ChildProps> {\n  render() {\n    console.log('PureChild Rendered');\n    return (\n      <div style={{ border: '1px solid lightgreen', padding: '10px', margin: '5px' }}>\n        <h3>Pure Child</h3>\n        <p>Value: {this.props.data.value}</p>\n      </div>\n    );\n  }\n}\n\ninterface ParentState {\n  data: { value: string };\n  updateCount: number;\n}\n\nclass ParentComponent extends Component<{}, ParentState> {\n  state = {\n    data: { value: 'initial' },\n    updateCount: 0,\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n        <h2>Parent Component</h2>\n        <button onClick={() => this.setState(prevState => ({ updateCount: prevState.updateCount + 1 }))}>\n          Update Parent (No Prop Change to Data)\n        </button>\n        <button onClick={() => this.setState(prevState => ({\n          // TODO: Recreate 'data' object reference but keep 'value' same\n          data: { value: prevState.data.value }\n        }))}>\n          Update Data Prop (New Reference)\n        </button>\n        <p>Parent Update Count: {this.state.updateCount}</p>\n        <RegularChild data={this.state.data} />\n        <PureChild data={this.state.data} />\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n",
          "solutionCode": "import React, { Component, PureComponent } from 'react';\n\ninterface ChildProps {\n  data: { value: string };\n}\n\n// Regular Child Component\nclass RegularChild extends Component<ChildProps> {\n  render() {\n    console.log('RegularChild Rendered');\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '5px' }}>\n        <h3>Regular Child</h3>\n        <p>Value: {this.props.data.value}</p>\n      </div>\n    );\n  }\n}\n\n// Pure Child Component\nclass PureChild extends PureComponent<ChildProps> {\n  render() {\n    console.log('PureChild Rendered');\n    return (\n      <div style={{ border: '1px solid lightgreen', padding: '10px', margin: '5px' }}>\n        <h3>Pure Child</h3>\n        <p>Value: {this.props.data.value}</p>\n      </div>\n    );\n  }\n}\n\ninterface ParentState {\n  data: { value: string };\n  updateCount: number;\n}\n\nclass ParentComponent extends Component<{}, ParentState> {\n  state = {\n    data: { value: 'initial' },\n    updateCount: 0,\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n        <h2>Parent Component</h2>\n        <button onClick={() => this.setState(prevState => ({ updateCount: prevState.updateCount + 1 }))}>\n          Update Parent (No Prop Change to Data)\n        </button>\n        <button onClick={() => this.setState(prevState => ({\n          // Recreate 'data' object reference but keep 'value' same\n          data: { value: prevState.data.value }\n        }))}>\n          Update Data Prop (New Reference)\n        </button>\n        <p>Parent Update Count: {this.state.updateCount}</p>\n        <RegularChild data={this.state.data} />\n        <PureChild data={this.state.data} />\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n",
          "testCases": [
            "Initial Render: Both children should render and log to console.",
            "Click 'Update Parent (No Prop Change to Data)': Only `RegularChild` should re-render. `PureChild` should NOT re-render because its `data` prop reference remains the same.",
            "Click 'Update Data Prop (New Reference)': Both `RegularChild` and `PureChild` should re-render. `PureChild` re-renders because even though the *content* of `data.value` is the same, the *reference* to the `data` object itself has changed, triggering its shallow comparison.",
            "Verify console logs match expected render behavior."
          ],
          "hints": [
            "Focus on the concept of 'shallow comparison' for `PureComponent`.",
            "Remember that for objects (like `data`), shallow comparison checks if the memory address (reference) of the object is the same, not its deep content.",
            "To test `PureComponent`'s behavior, ensure you create a *new* object when updating the `data` prop, even if its internal `value` remains the same.",
            "A regular `Component` will always re-render if its parent re-renders, regardless of prop changes, unless `shouldComponentUpdate` is explicitly implemented."
          ],
          "tags": [
            "React",
            "PureComponent",
            "Shallow Comparison",
            "Performance Optimization",
            "Class Components"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "JavaScript Object References"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "PureComponent",
            "Shallow Comparison",
            "Component Re-rendering"
          ]
        },
        {
          "id": "task_memoized_counter_display",
          "title": "Implement a Memoized Counter Display (Functional Component)",
          "description": "\nCreate two functional components: `ParentCounter` and `DisplayCount`.\n\n`ParentCounter` should:\n1.  Maintain two state variables: `totalCount` (a number) and `message` (a string).\n2.  Have a button to increment `totalCount`.\n3.  Have a button to change `message` to a random string.\n4.  Render `DisplayCount` component, passing `totalCount` as `count` prop and `message` as `status` prop.\n\n`DisplayCount` should initially be a regular functional component. Your task is to:\n\n1.  Wrap `DisplayCount` with `React.memo`.\n2.  Ensure `DisplayCount` only re-renders when its `count` prop changes, and *not* when its `status` prop changes.\n3.  You will need to use a custom comparison function for `React.memo` to achieve this specific behavior.\n4.  Add a `console.log` inside `DisplayCount`'s render to confirm its render behavior.",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface DisplayCountProps {\n  count: number;\n  status: string;\n}\n\nconst DisplayCount: React.FC<DisplayCountProps> = ({ count, status }) => {\n  // TODO: Add console.log here\n  return (\n    <div style={{ border: '1px solid lightcoral', padding: '10px', margin: '5px' }}>\n      <h4>Display Count Component</h4>\n      <p>Count: {count}</p>\n      <p>Status: {status}</p>\n    </div>\n  );\n};\n\n// TODO: Wrap DisplayCount with React.memo and a custom comparison function\n// const MemoizedDisplayCount = React.memo(DisplayCount, customComparisonFunction);\n\nconst ParentCounter: React.FC = () => {\n  const [totalCount, setTotalCount] = useState(0);\n  const [message, setMessage] = useState('Idle');\n\n  return (\n    <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n      <h2>Parent Counter</h2>\n      <button onClick={() => setTotalCount(prev => prev + 1)}>\n        Increment Count (Changes 'count' prop)\n      </button>\n      <button onClick={() => setMessage(`Message ${Math.random().toFixed(2)}`)}>\n        Change Message (Changes 'status' prop)\n      </button>\n      <p>Total Count: {totalCount}</p>\n      {/* Use the memoized component here */}\n      <DisplayCount count={totalCount} status={message} />\n    </div>\n  );\n};\n\nexport default ParentCounter;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface DisplayCountProps {\n  count: number;\n  status: string;\n}\n\nconst DisplayCount: React.FC<DisplayCountProps> = ({ count, status }) => {\n  console.log(`DisplayCount (Count: ${count}, Status: ${status}): Rendered`);\n  return (\n    <div style={{ border: '1px solid lightcoral', padding: '10px', margin: '5px' }}>\n      <h4>Display Count Component</h4>\n      <p>Count: {count}</p>\n      <p>Status: {status}</p>\n    </div>\n  );\n};\n\n// Custom comparison function for React.memo\n// Returns true if props are EQUAL (i.e., no re-render needed)\n// We want to re-render ONLY if 'count' changes, ignoring 'status'.\nconst areDisplayCountPropsEqual = (prevProps: DisplayCountProps, nextProps: DisplayCountProps): boolean => {\n  return prevProps.count === nextProps.count;\n};\n\nconst MemoizedDisplayCount = React.memo(DisplayCount, areDisplayCountPropsEqual);\n\nconst ParentCounter: React.FC = () => {\n  const [totalCount, setTotalCount] = useState(0);\n  const [message, setMessage] = useState('Idle');\n\n  return (\n    <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n      <h2>Parent Counter</h2>\n      <button onClick={() => setTotalCount(prev => prev + 1)}>\n        Increment Count (Changes 'count' prop)\n      </button>\n      <button onClick={() => setMessage(`Message ${Math.random().toFixed(2)}`)}>\n        Change Message (Changes 'status' prop)\n      </button>\n      <p>Total Count: {totalCount}</p>\n      <MemoizedDisplayCount count={totalCount} status={message} />\n    </div>\n  );\n};\n\nexport default ParentCounter;\n",
          "testCases": [
            "Initial Render: `DisplayCount` should render once.",
            "Click 'Change Message': `DisplayCount` should NOT re-render (only `ParentCounter` should).",
            "Click 'Increment Count': `DisplayCount` SHOULD re-render.",
            "Verify console logs to confirm render behavior for both test cases.",
            "Ensure `MemoizedDisplayCount` is used in the `ParentCounter`."
          ],
          "hints": [
            "The second argument to `React.memo` is the custom comparison function.",
            "This comparison function receives `prevProps` and `nextProps`.",
            "Crucially, it should return `true` if the component should *not* re-render (i.e., the props are considered 'equal' for rendering purposes), and `false` if it *should* re-render.",
            "You only need to compare the `count` prop in your custom function."
          ],
          "tags": [
            "React",
            "React.memo",
            "Functional Components",
            "Performance Optimization",
            "Custom Comparison"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Functional Components",
            "useState",
            "React.memo"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "React.memo",
            "Custom Comparison",
            "Memoization"
          ]
        },
        {
          "id": "task_custom_memoization_user_card",
          "title": "Build a User Card with Custom `React.memo` Comparison",
          "description": "\nCreate a functional component `UserCard` that displays user information. The `UserCard` receives a `user` object as a prop, which includes `id`, `name`, `email`, and `lastActivity` (a `Date` object).\n\nYour task is to:\n1.  Define the `UserCard` component to display the user's `name`, `email`, and `lastActivity` time.\n2.  Wrap `UserCard` with `React.memo`.\n3.  Provide a custom comparison function to `React.memo` such that `UserCard` *only* re-renders if the `id`, `name`, or `email` properties of the `user` object change. Changes to `lastActivity` should *not* trigger a re-render.\n4.  Create a `ParentUserDashboard` component that displays the `UserCard`.\n5.  `ParentUserDashboard` should have a button to 'Update Last Activity' that updates the `user.lastActivity` property to the current time, ensuring a new `user` object reference is passed down (e.g., `{ ...currentUser, lastActivity: new Date() }`).\n6.  `ParentUserDashboard` should also have a button to 'Change User Name' that updates `user.name`.\n7.  Add console logs to `UserCard`'s render method to confirm when it renders.",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  lastActivity: Date;\n}\n\ninterface UserCardProps {\n  user: User;\n}\n\nconst UserCard: React.FC<UserCardProps> = ({ user }) => {\n  // TODO: Add console.log for rendering\n  return (\n    <div style={{ border: '1px solid orange', padding: '15px', margin: '10px' }}>\n      <h3>User Card</h3>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n      <p>Last Activity: {user.lastActivity.toLocaleTimeString()}</p>\n    </div>\n  );\n};\n\n// TODO: Define custom comparison function and wrap UserCard with React.memo\n// const MemoizedUserCard = React.memo(UserCard, yourCustomComparisonFunction);\n\nconst ParentUserDashboard: React.FC = () => {\n  const [currentUser, setCurrentUser] = useState<User>({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com',\n    lastActivity: new Date(),\n  });\n\n  const updateLastActivity = () => {\n    setCurrentUser(prevUser => ({\n      ...prevUser,\n      lastActivity: new Date(), // New Date object, new 'user' object reference\n    }));\n  };\n\n  const changeUserName = () => {\n    setCurrentUser(prevUser => ({\n      ...prevUser,\n      name: prevUser.name === 'Alice' ? 'Bob' : 'Alice', // New 'user' object reference\n    }));\n  };\n\n  return (\n    <div style={{ border: '1px solid purple', padding: '15px', margin: '15px' }}>\n      <h2>User Dashboard</h2>\n      <button onClick={updateLastActivity}>Update Last Activity (Should NOT Re-render UserCard)</button>\n      <button onClick={changeUserName}>Change User Name (SHOULD Re-render UserCard)</button>\n      <MemoizedUserCard user={currentUser} />\n    </div>\n  );\n};\n\nexport default ParentUserDashboard;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  lastActivity: Date;\n}\n\ninterface UserCardProps {\n  user: User;\n}\n\nconst UserCard: React.FC<UserCardProps> = ({ user }) => {\n  console.log(`UserCard (User ID: ${user.id}, Name: ${user.name}): Rendered`);\n  return (\n    <div style={{ border: '1px solid orange', padding: '15px', margin: '10px' }}>\n      <h3>User Card</h3>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n      <p>Last Activity: {user.lastActivity.toLocaleTimeString()}</p>\n    </div>\n  );\n};\n\n// Custom comparison function for React.memo\n// Returns true if props are EQUAL (i.e., no re-render needed)\n// We want to re-render ONLY if id, name, or email changes, ignoring lastActivity.\nconst areUserCardPropsEqual = (prevProps: UserCardProps, nextProps: UserCardProps): boolean => {\n  return (\n    prevProps.user.id === nextProps.user.id &&\n    prevProps.user.name === nextProps.user.name &&\n    prevProps.user.email === nextProps.user.email\n    // We explicitly IGNORE prevProps.user.lastActivity === nextProps.user.lastActivity\n    // This means changes to lastActivity won't trigger a re-render.\n  );\n};\n\nconst MemoizedUserCard = React.memo(UserCard, areUserCardPropsEqual);\n\nconst ParentUserDashboard: React.FC = () => {\n  const [currentUser, setCurrentUser] = useState<User>({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com',\n    lastActivity: new Date(),\n  });\n\n  const updateLastActivity = () => {\n    setCurrentUser(prevUser => ({\n      ...prevUser,\n      lastActivity: new Date(), // New Date object, new 'user' object reference\n    }));\n  };\n\n  const changeUserName = () => {\n    setCurrentUser(prevUser => ({\n      ...prevUser,\n      name: prevUser.name === 'Alice' ? 'Bob' : 'Alice', // New 'user' object reference\n    }));\n  };\n\n  return (\n    <div style={{ border: '1px solid purple', padding: '15px', margin: '15px' }}>\n      <h2>User Dashboard</h2>\n      <button onClick={updateLastActivity}>Update Last Activity (Should NOT Re-render UserCard)</button>\n      <button onClick={changeUserName}>Change User Name (SHOULD Re-render UserCard)</button>\n      <MemoizedUserCard user={currentUser} />\n    </div>\n  );\n};\n\nexport default ParentUserDashboard;\n",
          "testCases": [
            "Initial Render: `UserCard` should render once.",
            "Click 'Update Last Activity': `UserCard` should NOT re-render. Only the `ParentUserDashboard` re-renders. Verify console logs.",
            "Click 'Change User Name': `UserCard` SHOULD re-render. Verify console logs.",
            "Ensure the `lastActivity` time displayed in the `UserCard` updates when 'Update Last Activity' is clicked, even if the component itself doesn't re-render (as it's referencing the new `user` object). This confirms the data itself changes, but rendering is controlled by memoization."
          ],
          "hints": [
            "Remember that the custom comparison function passed to `React.memo` returns `true` if React should *skip* the re-render (i.e., the props are considered equal for rendering purposes).",
            "You need to compare `prevProps.user.id`, `prevProps.user.name`, and `prevProps.user.email` with their `nextProps` counterparts.",
            "Explicitly exclude `lastActivity` from your comparison logic.",
            "Even though `lastActivity` changes and the `user` object reference changes, your custom comparison should ignore the `lastActivity` difference."
          ],
          "tags": [
            "React",
            "React.memo",
            "Functional Components",
            "Custom Comparison",
            "Performance Optimization",
            "Memoization"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Functional Components",
            "useState",
            "React.memo"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "React.memo",
            "Custom Comparison",
            "Shallow vs Deep Comparison",
            "Immutable Updates"
          ]
        },
        {
          "id": "task_refactor_class_to_hooks_counter",
          "title": "Refactor a Class Counter to Functional Component with Hooks",
          "description": "\nRefactor the following simple React class component into a functional component using `useState` and `useEffect`.\n\nOriginal Class Component:\n```typescript\nimport React, { Component } from 'react';\n\nclass ClassCounter extends Component<{}, { count: number }> {\n  private intervalId: number | undefined;\n\n  constructor(props: {}) {\n    super(props);\n    this.state = { count: 0 };\n    this.increment = this.increment.bind(this);\n  }\n\n  componentDidMount() {\n    console.log('ClassCounter: Mounted');\n    this.intervalId = window.setInterval(() => {\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n    }, 1000);\n  }\n\n  componentDidUpdate(prevProps: {}, prevState: { count: number }) {\n    if (prevState.count !== this.state.count) {\n      console.log(`ClassCounter: Count updated to ${this.state.count}`);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('ClassCounter: Unmounted, clearing interval');\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  increment() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div style={{ border: '1px solid blue', padding: '10px' }}>\n        <h3>Class Counter: {this.state.count}</h3>\n        <button onClick={this.increment}>Increment Manually</button>\n      </div>\n    );\n  }\n}\n```\n\nYour functional component should:\n1.  Manage the `count` state using `useState`.\n2.  Implement the automatic incrementing interval using `useEffect` to mimic `componentDidMount` and `componentWillUnmount`.\n3.  Add a `useEffect` to log when `count` updates, mimicking `componentDidUpdate`.\n4.  Provide a manual increment button.",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// TODO: Refactor the ClassCounter component into a functional component here\n\n// Your refactored functional component should look something like this structure:\n// function FunctionalCounter() {\n//   const [count, setCount] = useState(0);\n\n//   // Effect for auto-incrementing interval (componentDidMount + componentWillUnmount)\n//   useEffect(() => {\n//     // TODO: Implement interval logic\n//     return () => { /* TODO: Cleanup */ };\n//   }, []);\n\n//   // Effect for logging count updates (componentDidUpdate)\n//   useEffect(() => {\n//     // TODO: Implement logging logic\n//   }, [count]);\n\n//   const incrementManually = () => {\n//     setCount(prev => prev + 1);\n//   };\n\n//   return (\n//     <div style={{ border: '1px solid green', padding: '10px' }}>\n//       <h3>Functional Counter: {count}</h3>\n//       <button onClick={incrementManually}>Increment Manually</button>\n//     </div>\n//   );\n// }\n\n// export default FunctionalCounter;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction FunctionalCounter() {\n  const [count, setCount] = useState(0);\n\n  // Effect for auto-incrementing interval (componentDidMount + componentWillUnmount)\n  useEffect(() => {\n    console.log('FunctionalCounter: Setting up auto-increment interval (mount)');\n    const intervalId = window.setInterval(() => {\n      setCount(prev => prev + 1);\n    }, 1000);\n\n    // Cleanup function: clears interval on unmount\n    return () => {\n      console.log('FunctionalCounter: Clearing interval (unmount)');\n      clearInterval(intervalId);\n    };\n  }, []); // Empty dependency array: runs once on mount, cleanup on unmount\n\n  // Effect for logging count updates (componentDidUpdate for 'count' state)\n  useEffect(() => {\n    // Only log if count has changed from its initial value (after initial mount)\n    if (count > 0) { \n        console.log(`FunctionalCounter: Count updated to ${count}`);\n    }\n  }, [count]); // Dependency array: re-run effect when 'count' changes\n\n  const incrementManually = () => {\n    setCount(prev => prev + 1);\n  };\n\n  return (\n    <div style={{ border: '1px solid green', padding: '10px' }}>\n      <h3>Functional Counter: {count}</h3>\n      <button onClick={incrementManually}>Increment Manually</button>\n    </div>\n  );\n}\n\nexport default FunctionalCounter;\n",
          "testCases": [
            "Component should start at `count: 0`.",
            "Count should automatically increment every second.",
            "Clicking 'Increment Manually' should increase the count.",
            "Console should log 'FunctionalCounter: Setting up auto-increment interval (mount)' once on mount.",
            "Console should log 'FunctionalCounter: Count updated to [new count]' whenever count changes (either automatically or manually).",
            "When the component is unmounted (e.g., by conditional rendering in a parent), 'FunctionalCounter: Clearing interval (unmount)' should be logged and the interval should stop."
          ],
          "hints": [
            "Use `useState` for the `count` variable.",
            "For `componentDidMount` and `componentWillUnmount` behavior, `useEffect` with an empty dependency array (`[]`) and a cleanup return function is key.",
            "For `componentDidUpdate` behavior based on `count`, use `useEffect` with `[count]` in the dependency array.",
            "Remember that `setCount` in `setInterval` should use the functional update form (`prev => prev + 1`) to avoid stale closures."
          ],
          "tags": [
            "React",
            "Hooks",
            "Refactoring",
            "useState",
            "useEffect",
            "Class Components",
            "Functional Components"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "React Hooks basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useState",
            "useEffect",
            "Lifecycle Mapping"
          ]
        },
        {
          "id": "task_refactor_class_to_hooks_data_fetch",
          "title": "Refactor a Class Data Fetcher to Functional Component with Hooks",
          "description": "\nRefactor the following React class component that fetches and displays user data into a functional component using `useState` and `useEffect`.\n\nOriginal Class Component:\n```typescript\nimport React, { Component } from 'react';\n\ninterface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface ClassUserFetcherProps {\n  userId: number;\n}\n\ninterface ClassUserFetcherState {\n  user: UserData | null;\n  loading: boolean;\n  error: string | null;\n}\n\nclass ClassUserFetcher extends Component<ClassUserFetcherProps, ClassUserFetcherState> {\n  constructor(props: ClassUserFetcherProps) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true,\n      error: null,\n    };\n  }\n\n  componentDidMount() {\n    this.fetchUser(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps: ClassUserFetcherProps) {\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchUser(this.props.userId);\n    }\n  }\n\n  fetchUser = async (id: number) => {\n    this.setState({ loading: true, error: null });\n    try {\n      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch user ${id}: ${response.statusText}`);\n      }\n      const data: UserData = await response.json();\n      this.setState({ user: data, loading: false });\n    } catch (err: any) {\n      this.setState({ error: err.message, loading: false, user: null });\n    }\n  };\n\n  render() {\n    const { user, loading, error } = this.state;\n\n    if (loading) return <div>Loading user {this.props.userId}...</div>;\n    if (error) return <div>Error: {error}</div>;\n    if (!user) return <div>No user data.</div>;\n\n    return (\n      <div style={{ border: '1px solid brown', padding: '15px' }}>\n        <h3>User Details (Class Component)</h3>\n        <p>ID: {user.id}</p>\n        <p>Name: {user.name}</p>\n        <p>Email: {user.email}</p>\n      </div>\n    );\n  }\n}\n```\n\nYour functional component should:\n1.  Manage `user`, `loading`, and `error` states using `useState`.\n2.  Implement the data fetching logic using `useEffect` to handle initial mount (`componentDidMount` equivalent) and re-fetching when `userId` prop changes (`componentDidUpdate` equivalent).\n3.  Ensure proper loading and error states are displayed.",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\ninterface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface FunctionalUserFetcherProps {\n  userId: number;\n}\n\nconst FunctionalUserFetcher: React.FC<FunctionalUserFetcherProps> = ({ userId }) => {\n  // TODO: Manage user, loading, error states with useState\n  // const [user, setUser] = useState<UserData | null>(null);\n  // const [loading, setLoading] = useState(true);\n  // const [error, setError] = useState<string | null>(null);\n\n  // TODO: Implement data fetching with useEffect\n  // This effect should run on mount AND when userId changes\n  // useEffect(() => {\n  //   const fetchUser = async () => {\n  //     // ... fetching logic, updating states\n  //   };\n  //   fetchUser();\n  // }, [/* TODO: Add dependencies */]);\n\n  // TODO: Render loading, error, or user data\n  return <div>{/* Your JSX here */}</div>;\n};\n\n// export default FunctionalUserFetcher;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\ninterface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface FunctionalUserFetcherProps {\n  userId: number;\n}\n\nconst FunctionalUserFetcher: React.FC<FunctionalUserFetcherProps> = ({ userId }) => {\n  const [user, setUser] = useState<UserData | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    console.log(`FunctionalUserFetcher: Fetching user ${userId}...`);\n    const fetchUser = async () => {\n      setLoading(true);\n      setError(null); // Clear previous errors\n      try {\n        const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch user ${userId}: ${response.statusText}`);\n        }\n        const data: UserData = await response.json();\n        setUser(data);\n      } catch (err: any) {\n        console.error('Error in fetch:', err);\n        setError(err.message || 'An unknown error occurred');\n        setUser(null); // Clear user data on error\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n\n    // Optional: Cleanup function if fetch was cancellable (e.g., AbortController)\n    return () => {\n        // console.log(`Cleanup for user ${userId} fetch`);\n        // if (controller) controller.abort();\n    };\n  }, [userId]); // Dependency array: re-run effect when userId changes\n\n  if (loading) return <div>Loading user {userId}...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return <div>No user data for ID: {userId}.</div>;\n\n  return (\n    <div style={{ border: '1px solid orange', padding: '15px' }}>\n      <h3>User Details (Functional Component)</h3>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n};\n\nexport default FunctionalUserFetcher;\n",
          "testCases": [
            "Initial render: Component should display 'Loading user [ID]...' and then user data for the initial `userId`.",
            "Change `userId` prop (e.g., from a parent component): Component should re-fetch data for the new `userId` and update the display.",
            "Simulate an API error (e.g., by trying to fetch `userId=99999`): Component should display the error message.",
            "Verify network requests happen only on mount and when `userId` changes."
          ],
          "hints": [
            "Each distinct piece of state (user data, loading status, error) should have its own `useState` call.",
            "The `useEffect` hook should contain the `fetch` logic.",
            "The `userId` prop needs to be in the `useEffect`'s dependency array so that the effect re-runs when `userId` changes.",
            "Remember to set `loading` and `error` states appropriately before and after the fetch operation.",
            "You might need to make the `fetchUser` function `async` and use `await` for cleaner async code inside `useEffect`."
          ],
          "tags": [
            "React",
            "Hooks",
            "Refactoring",
            "useState",
            "useEffect",
            "Data Fetching",
            "Class Components",
            "Functional Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Functional Components",
            "useState",
            "useEffect",
            "Fetch API",
            "Async/Await"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "useEffect",
            "Lifecycle Mapping",
            "Asynchronous Operations"
          ]
        }
      ]
    }
  },
  {
    "id": "4f07cbeb-e572-419a-97a0-563bc61e4192",
    "startLine": 4900,
    "endLine": 4999,
    "processedDate": "2025-06-17T09:21:20.457Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_hooks_state_effects_memoization",
          "title": "React Hooks: State Management, Side Effects, and Memoization",
          "content": "React Hooks are functions that let you \"hook into\" React state and lifecycle features from function components. They were introduced in React 16.8 to allow developers to use state and other React features without writing a class.\n\n## useState Hook\n`useState` is a Hook that lets you add React state to function components. It returns a pair: the current state value and a function that lets you update it. The update function is typically named `set[StateVariable]`. When the setter function is called, React re-renders the component.\n\n## useEffect Hook\n`useEffect` is a Hook that lets you perform side effects in function components. Side effects are operations that affect the world outside of the component, such as data fetching, subscriptions, or manually changing the DOM. `useEffect` runs after every render of the component by default, but its behavior can be controlled by a dependency array.\n\n*   **No dependency array**: The effect runs after every render, comparable to `componentDidMount` and `componentDidUpdate` combined.\n*   **Empty dependency array (`[]`)**: The effect runs only once after the initial render, and the cleanup function (if provided) runs only when the component unmounts. This is comparable to `componentDidMount` and `componentWillUnmount`.\n*   **Dependency array with values (`[dep1, dep2]`)**: The effect runs after the initial render and then only if any of the values in the dependency array change between renders. The cleanup function runs before the effect re-runs due to a dependency change, and when the component unmounts. This is comparable to `componentDidUpdate` for specific props/state.\n\n`useEffect` can optionally return a cleanup function. This function is called by React before the component unmounts, or before the effect re-runs (if dependencies change). This is crucial for cleaning up subscriptions, timers, or other resources to prevent memory leaks.\n\n### Handling Unmounted Components in useEffect\nWhen performing asynchronous operations (like data fetching) inside `useEffect`, it's possible that the component might unmount before the asynchronous operation completes. If the state update is attempted on an unmounted component, React will issue a warning or potentially cause errors. A common pattern to prevent this is to use a mutable flag (e.g., `isMounted`) that is set to `false` in the cleanup function. Before updating state, check the value of this flag.\n\n## useMemo Hook\n`useMemo` is a Hook that lets you memoize (cache) the result of a function computation. It returns a memoized value that is re-computed only when one of its dependencies has changed. This is useful for optimizing performance by avoiding expensive calculations on every render, especially when those calculations depend on values that don't change frequently. `useMemo` takes two arguments: a function that computes the value and a dependency array.\n\n### Relationship to Class Component Lifecycle Methods\n\n*   `useState` replaces `this.state` and `this.setState`.\n*   `useEffect` with an empty dependency array (`[]`) replaces `componentDidMount` for initial setup and `componentWillUnmount` for cleanup.\n*   `useEffect` with a dependency array (`[props.someValue]`) replaces `componentDidUpdate` for reacting to specific prop/state changes.\n*   `useMemo` can serve as a way to derive state from props or state efficiently, similar in concept to `getDerivedStateFromProps` in terms of deriving state, but for computed values rather than state itself, and without the associated pitfalls.\n",
          "examples": [
            {
              "id": "example_hooks_1",
              "title": "Basic useState and useEffect for Data Fetching",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction ProfilePage({ userId }) {\n  const [user, setUser] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    let isMounted = true; // Flag to track component mount status\n    setLoading(true); // Indicate loading state\n    setError(null); // Clear previous errors\n    \n    fetch(`/api/users/${userId}`)\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        if (isMounted) { // Only update if component is still mounted\n          setUser(data);\n          setLoading(false);\n        }\n      })\n      .catch(err => {\n        if (isMounted) { // Only update if component is still mounted\n          setError(err);\n          setLoading(false);\n        }\n      });\n    \n    return () => {\n      isMounted = false; // Set flag to false when component unmounts or effect re-runs\n    };\n  }, [userId]); // Re-run effect when userId changes\n\n  const userNameDisplay = user ? `${user.firstName} ${user.lastName}` : 'Loading...';\n\n  if (loading) return <div>Loading user profile...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  \n  return (\n    <div>\n      <h2>{userNameDisplay}</h2>\n      <div>Email: {user.email}</div>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates `useState` for managing `user`, `error`, and `loading` states. `useEffect` is used for data fetching; it runs when `userId` changes. The `isMounted` flag in the `useEffect`'s closure prevents state updates on an unmounted component, which is a common best practice for async operations in effects. The cleanup function sets `isMounted` to `false` when the component unmounts or when the effect re-runs due to `userId` changing.",
              "language": "javascript"
            },
            {
              "id": "example_hooks_2",
              "title": "Using useMemo for Memoized Calculations",
              "code": "import React, { useState, useMemo } from 'react';\n\nfunction ProductDisplay({ price, quantity }) {\n  const [discount, setDiscount] = useState(0.1);\n\n  // Calculate total price only when price, quantity, or discount change\n  const totalCost = useMemo(() => {\n    console.log('Calculating total cost...');\n    return (price * quantity) * (1 - discount);\n  }, [price, quantity, discount]);\n\n  return (\n    <div>\n      <p>Price per item: ${price}</p>\n      <p>Quantity: {quantity}</p>\n      <p>Discount: {discount * 100}%</p>\n      <h3>Total Cost: ${totalCost.toFixed(2)}</h3>\n      <button onClick={() => setDiscount(prev => prev === 0.1 ? 0.2 : 0.1)}>Toggle Discount</button>\n      <button onClick={() => console.log('Component re-rendered without total cost recalculation')}>Force Re-render (Check Console)</button>\n    </div>\n  );\n}",
              "explanation": "This example uses `useMemo` to calculate `totalCost`. The calculation only re-runs if `price`, `quantity`, or `discount` change. If the `ProductDisplay` component re-renders for other reasons (e.g., a parent component re-renders), the `totalCost` calculation is skipped unless its dependencies have changed, improving performance. The console log helps observe when the calculation actually occurs.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_hooks_1",
            "question_hooks_2",
            "question_hooks_3",
            "question_hooks_4",
            "question_hooks_5",
            "question_hooks_6",
            "question_hooks_7",
            "question_hooks_8",
            "question_hooks_9",
            "question_hooks_10",
            "question_hooks_11",
            "question_hooks_12"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_memoized_calculation"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "useMemo",
            "Side Effects",
            "Memoization",
            "Data Fetching",
            "Functional Components",
            "Lifecycle"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_basics",
            "React_components",
            "Promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced_React_Patterns",
            "Performance_Optimization"
          ]
        },
        {
          "id": "theory_deprecated_lifecycle_methods",
          "title": "Legacy React Class Component Lifecycle Methods (Deprecated)",
          "content": "Before React Hooks, class components were the primary way to use state and lifecycle features. React provides several lifecycle methods that allow developers to run code at specific points in a component's life cycle (mounting, updating, unmounting).\n\nOver time, some of these methods were identified as problematic, leading to their deprecation. These 'UNSAFE_' prefixed methods are considered legacy and should be avoided in new code due to potential for bugs, unexpected behavior, and making future concurrent React features difficult to implement. Using them might cause issues with Strict Mode and React's async rendering capabilities.\n\n## UNSAFE_componentWillMount()\n*   **When called:** Just before the component is mounted (i.e., before the first `render()`).\n*   **Why deprecated:** Performing side effects (like data fetching) here is discouraged because it can block the initial render. If `setState` is called here, it won't trigger a re-render but will overwrite the state, potentially leading to confusion and issues with server-side rendering (SSR) where it might run multiple times.\n*   **Recommended replacements:**\n    *   For initial state setup: Use the `constructor` or `useState` hook.\n    *   For side effects (like data fetching): Use `componentDidMount` or `useEffect` hook with an empty dependency array (`[]`).\n\n## UNSAFE_componentWillReceiveProps(nextProps)\n*   **When called:** When the component is receiving new props before a re-render.\n*   **Why deprecated:** This method was often misused for deriving state from props, leading to subtle bugs, especially when `setState` was called inside it. Calling `setState` unconditionally here could lead to infinite loops if not carefully managed. It also ran before `render`, which could cause inconsistencies if props changed mid-render.\n*   **Recommended replacements:**\n    *   For deriving state from props: Use static `getDerivedStateFromProps`.\n    *   For side effects that depend on props changes: Use `componentDidUpdate` or `useEffect` with a dependency array.\n\n## UNSAFE_componentWillUpdate(nextProps, nextState)\n*   **When called:** Just before rendering with new props or state, but not for the initial render.\n*   **Why deprecated:** Similar to `UNSAFE_componentWillReceiveProps`, this method was problematic because it ran before `render` and `componentDidUpdate`, making it difficult to guarantee that DOM operations would be consistent. It was also commonly misused for side effects that should have been in `componentDidUpdate`.\n*   **Recommended replacements:**\n    *   For inspecting DOM before updates: Use `getSnapshotBeforeUpdate`.\n    *   For side effects after updates: Use `componentDidUpdate` or `useEffect` with a dependency array.\n\nWhile these methods still technically work in older React versions, their use is strongly discouraged, and they are marked as `UNSAFE_` to highlight that they can cause issues with future React features like Async Rendering and Concurrent Mode. Migrating away from them to newer lifecycle methods or Hooks is best practice.\n",
          "examples": [
            {
              "id": "example_deprecated_lifecycle_1",
              "title": "Example of Legacy Deprecated Lifecycle Methods",
              "code": "import React from 'react';\n\nclass LegacyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n    console.log('1. Constructor: Initializing state');\n  }\n\n  // UNSAFE_componentWillMount is called before mounting occurs\n  // Avoid using this method in modern React applications.\n  UNSAFE_componentWillMount() {\n    console.log('2. UNSAFE_componentWillMount: Called before component mounts (avoid)');\n    // Example of what NOT to do: calling setState here will not trigger a re-render,\n    // but will update state before initial render. This can lead to issues.\n    // this.setState({ data: 'initial data set in cWM' });\n  }\n\n  // componentDidMount is ideal for side effects like data fetching\n  componentDidMount() {\n    console.log('3. componentDidMount: Component mounted, suitable for data fetching');\n    // Example: fetch('/api/data').then(res => this.setState({ data: res.data }));\n  }\n\n  // UNSAFE_componentWillReceiveProps is called when props update\n  // Avoid using this method in modern React applications.\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    console.log('4. UNSAFE_componentWillReceiveProps: Called when props update (avoid)');\n    // Example of what NOT to do: deriving state from props directly here often leads to bugs.\n    // if (nextProps.userId !== this.props.userId) {\n    //   this.setState({ data: null, loading: true });\n    // }\n  }\n\n  // getDerivedStateFromProps is the recommended way to derive state from props\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('getDerivedStateFromProps: Deriving state from props');\n    // Example: if (nextProps.userId !== prevState.userId) { return { data: null, userId: nextProps.userId }; } return null;\n    return null;\n  }\n\n  // shouldComponentUpdate can optimize performance by preventing unnecessary re-renders\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate: Deciding whether to re-render');\n    return true; // Always re-render for this example\n  }\n\n  // UNSAFE_componentWillUpdate is called before rendering with new props/state\n  // Avoid using this method in modern React applications.\n  UNSAFE_componentWillUpdate(nextProps, nextState) {\n    console.log('5. UNSAFE_componentWillUpdate: Called before re-render (avoid)');\n    // Example of what NOT to do: side effects here can cause issues.\n  }\n\n  // getSnapshotBeforeUpdate is useful for capturing DOM state before an update\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate: Capturing DOM snapshot');\n    return null;\n  }\n\n  // componentDidUpdate is ideal for side effects after updates\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('6. componentDidUpdate: Component updated, suitable for side effects');\n  }\n\n  // componentWillUnmount is for cleanup before component unmounts\n  componentWillUnmount() {\n    console.log('7. componentWillUnmount: Component is about to unmount');\n  }\n\n  render() {\n    console.log('8. Render: Rendering component UI');\n    return (\n      <div>\n        <h3>Legacy Component Example</h3>\n        <p>Data: {this.state.data || 'N/A'}</p>\n        <p>Props: {JSON.stringify(this.props)}</p>\n      </div>\n    );\n  }\n}\n\nexport default LegacyComponent;\n",
              "explanation": "This code snippet illustrates the deprecated lifecycle methods within a class component. Comments highlight where each method is called and, importantly, why `UNSAFE_` methods should be avoided. It also indicates the recommended modern alternatives (like `constructor`, `componentDidMount`, `getDerivedStateFromProps`, `getSnapshotBeforeUpdate`, and `componentDidUpdate`). Observing the console logs when this component mounts and updates would demonstrate the order of execution.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_legacy_lifecycle_1",
            "question_legacy_lifecycle_2",
            "question_legacy_lifecycle_3",
            "question_legacy_lifecycle_4",
            "question_legacy_lifecycle_5",
            "question_legacy_lifecycle_6",
            "question_legacy_lifecycle_7",
            "question_legacy_lifecycle_8"
          ],
          "relatedTasks": [
            "task_refactor_legacy_component"
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Deprecated",
            "UNSAFE",
            "Migration",
            "Hooks"
          ],
          "technology": "React",
          "prerequisites": [
            "React_class_components"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Maintaining_Legacy_Code",
            "Understanding_React_Evolution"
          ]
        },
        {
          "id": "theory_conditional_rendering",
          "title": "Conditional Rendering in React",
          "content": "Conditional rendering in React allows you to render different elements or components based on certain conditions. This is a fundamental concept for building dynamic and interactive user interfaces where the UI needs to change based on application state, user permissions, data availability, or other factors.\n\nReact components encapsulate their own logic, and conditional rendering is a powerful tool within this paradigm to control what gets rendered to the DOM.\n\n## Using `if` Statements\nThe most straightforward way to conditionally render components is by using standard JavaScript `if` statements. You can use them inside the component's function body (before the `return` statement) to return different JSX based on a condition.\n\n## Using Ternary Operators (`condition ? trueExpression : falseExpression`)\nFor inline conditional rendering, especially when you need to render one of two different elements, the ternary operator is a concise choice. It allows you to embed conditional logic directly within JSX.\n\n## Using Logical `&&` Operator (`condition && expression`)\nThe logical `&&` operator is useful when you want to render something only if a condition is true, and render nothing otherwise (or if the condition is false). If the `condition` is `true`, the `expression` to its right is evaluated and rendered. If the `condition` is `false`, React ignores the `expression` and renders nothing (because `false` is a valid renderable value that results in no output).\n\n## Other Approaches (Briefly Mentioned)\n*   **Element Variables:** You can declare a variable to hold an element and then conditionally assign components to it before returning that variable in JSX.\n*   **Switch Statements:** For multiple complex conditions, a `switch` statement can be used inside the component's function body to return different JSX, similar to `if` statements.\n\nChoosing the right method depends on the complexity of the condition and personal preference for readability.\n",
          "examples": [
            {
              "id": "example_conditional_rendering_1",
              "title": "Conditional Rendering with if Statement",
              "code": "import React from 'react';\n\nfunction UserHeader() {\n  return <h1>Welcome, User!</h1>;\n}\n\nfunction GuestHeader() {\n  return <h1>Welcome, Guest! Please Log In.</h1>;\n}\n\nfunction Header(props) {\n  if (props.isLoggedIn) {\n    return <UserHeader />;\n  }\n  return <GuestHeader />;\n}",
              "explanation": "This example uses a standard `if` statement to render either `UserHeader` or `GuestHeader` based on the `isLoggedIn` prop. This is a clear and readable way to handle distinct rendering paths.",
              "language": "javascript"
            },
            {
              "id": "example_conditional_rendering_2",
              "title": "Conditional Rendering with Ternary Operator",
              "code": "import React from 'react';\n\nfunction UserMessage() {\n  return <p>You have new messages!</p>;\n}\n\nfunction GuestMessage() {\n  return <p>Log in to view messages.</p>;\n}\n\nfunction Message(props) {\n  return (\n    <div>\n      {props.isLoggedIn ? <UserMessage /> : <GuestMessage />}\n    </div>\n  );\n}",
              "explanation": "Here, the ternary operator (`condition ? trueExpression : falseExpression`) is used for inline conditional rendering. It's concise and ideal when you need to switch between two different pieces of JSX directly within the return statement.",
              "language": "javascript"
            },
            {
              "id": "example_conditional_rendering_3",
              "title": "Conditional Rendering with Logical && Operator",
              "code": "import React from 'react';\n\nfunction AdminPanel() {\n  return (\n    <div style={{ border: '1px solid red', padding: '10px' }}>\n      <h3>Admin Controls</h3>\n      <button>Manage Users</button>\n      <button>View Reports</button>\n    </div>\n  );\n}\n\nfunction Dashboard({ userRole, isLoading }) {\n  return (\n    <div>\n      <h2>User Dashboard</h2>\n      {isLoading && <p>Loading dashboard data...</p>}\n      {userRole === 'admin' && <AdminPanel />}\n      <p>Your content goes here.</p>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the logical `&&` operator. `isLoading && <p>Loading...</p>` will render the loading message only if `isLoading` is true. Similarly, `userRole === 'admin' && <AdminPanel />` will render the `AdminPanel` component only if `userRole` is exactly 'admin'. This is particularly useful when you want to render an element or component only when a condition is true, and render nothing otherwise.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_conditional_rendering_1",
            "question_conditional_rendering_2",
            "question_conditional_rendering_3",
            "question_conditional_rendering_4",
            "question_conditional_rendering_5",
            "question_conditional_rendering_6"
          ],
          "relatedTasks": [
            "task_build_auth_ui"
          ],
          "tags": [
            "React",
            "Conditional Rendering",
            "JSX",
            "JavaScript",
            "UI/UX",
            "Control Flow"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_basics",
            "React_components",
            "JSX"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "requiredFor": [
            "Dynamic_UI",
            "Form_Validation"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_hooks_1",
          "topic": "React useState Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useState` hook in React?",
          "answer": "`useState` allows functional components to manage and update local state.",
          "options": [],
          "analysisPoints": [
            "Identifies `useState` with state management.",
            "Connects `useState` specifically to functional components."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useState` purpose"
          ],
          "example": "```javascript\nconst [count, setCount] = useState(0);\n```",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State"
          ],
          "prerequisites": [
            "React_components"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_2",
          "topic": "React useEffect Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `useEffect` hook. When will the effect inside it run?",
          "answer": "Only once after the initial render and before the component unmounts.",
          "options": [
            "After every render.",
            "Only once after the initial render and before the component unmounts.",
            "Only when the component mounts.",
            "Only when the component unmounts."
          ],
          "analysisPoints": [
            "Tests understanding of `useEffect` with an empty dependency array.",
            "Distinguishes between initial mount and subsequent renders.",
            "Recognizes the role of the cleanup function."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Lifecycle",
            "Cleanup Function"
          ],
          "evaluationCriteria": [
            "Correct interpretation of `useEffect` dependency array behavior",
            "Knowledge of `useEffect` cleanup"
          ],
          "example": "```javascript\nuseEffect(() => {\n  console.log('Component Mounted');\n  return () => {\n    console.log('Component Unmounted');\n  };\n}, []); // <-- Empty dependency array\n```\nThis specific setup for `useEffect` with an empty dependency array `([])` ensures that the effect function (the first argument) runs only once after the component's initial render. The cleanup function (the return value) then runs only when the component unmounts. This behavior makes it equivalent to `componentDidMount` and `componentWillUnmount` in class components.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Lifecycle"
          ],
          "prerequisites": [
            "React_components",
            "useEffect_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_3",
          "topic": "React useEffect Cleanup",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of the `return () => { isMounted = false; };` statement within the `useEffect` hook in the `ProfilePage` example. Why is this pattern used?",
          "answer": "The `return () => { isMounted = false; };` statement defines a cleanup function for the `useEffect` hook. This function is executed when the component unmounts or before the effect re-runs (if its dependencies change).\n\nIts purpose, in this specific data-fetching pattern, is to prevent 'memory leaks' or, more accurately, to prevent React from issuing warnings about state updates on unmounted components. When an asynchronous operation (like a `fetch` request) is initiated in `useEffect`, the component might unmount before the `fetch` request completes. If the `fetch` then resolves and tries to call `setUser` or `setError`, React will log a warning because you are trying to update state on a component that no longer exists in the DOM.\n\nThe `isMounted` flag pattern addresses this: `isMounted` is initially `true`. If the cleanup function runs (meaning the component unmounted or `userId` changed before the fetch finished), `isMounted` is set to `false`. Subsequent state updates within the `then` or `catch` blocks of the `fetch` promise will then check `if (isMounted)` and prevent the update if the component is no longer mounted, thus avoiding the warning.",
          "options": [],
          "analysisPoints": [
            "Defines the cleanup function's role.",
            "Explains the problem of updating state on unmounted components.",
            "Details how the `isMounted` flag solves this specific issue.",
            "Connects to memory leak prevention and warning avoidance."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Asynchronous Operations",
            "Memory Leaks",
            "State Management"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `useEffect` cleanup",
            "Understanding of async pitfalls in React",
            "Ability to explain common patterns"
          ],
          "example": "```javascript\nuseEffect(() => {\n  let isMounted = true;\n  fetchData().then(() => {\n    if (isMounted) {\n      // Update state\n    }\n  });\n  return () => {\n    isMounted = false;\n  };\n}, []);\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup",
            "Asynchronous",
            "Best Practices"
          ],
          "prerequisites": [
            "useEffect_basics",
            "Promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_4",
          "topic": "React useMemo Hook",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary benefit of using the `useMemo` hook?",
          "answer": "`useMemo` memoizes a computed value, preventing its recalculation on every render unless its dependencies change, which improves performance for expensive calculations.",
          "options": [],
          "analysisPoints": [
            "Identifies `useMemo` with memoization.",
            "Highlights performance optimization.",
            "Mentions dependency-based recalculation."
          ],
          "keyConcepts": [
            "useMemo",
            "Memoization",
            "Performance Optimization",
            "Dependencies"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useMemo` purpose"
          ],
          "example": "```javascript\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n```",
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "Performance"
          ],
          "prerequisites": [
            "React_functional_components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_5",
          "topic": "React Hooks vs. Class Components",
          "level": "medium",
          "type": "open",
          "question": "How do `useState`, `useEffect`, and `useMemo` collectively provide similar functionalities to class component lifecycle methods like `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`, and `getDerivedStateFromProps`?",
          "answer": "1.  **`useState` vs. `this.state`/`this.setState`**: `useState` provides local state management for functional components, directly replacing the `this.state` and `this.setState` paradigm found in class components.\n2.  **`useEffect` vs. `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`**: `useEffect` is a versatile hook that consolidates the functionalities of these three class lifecycle methods:\n    *   **`componentDidMount`**: Achieved by `useEffect` with an empty dependency array (`[]`). The effect runs once after the initial render.\n    *   **`componentDidUpdate`**: Achieved by `useEffect` with a dependency array containing specific values (`[dep1, dep2]`). The effect runs when any of these dependencies change, mimicking `componentDidUpdate`'s behavior for specific prop/state changes.\n    *   **`componentWillUnmount`**: Achieved by the cleanup function returned by `useEffect`. This function runs when the component unmounts, or before the effect re-runs due to dependency changes, allowing for resource cleanup.\n3.  **`useMemo` vs. `getDerivedStateFromProps` (conceptual overlap)**: While `useMemo` doesn't directly replace `getDerivedStateFromProps` (which is for deriving state, not just values), `useMemo` provides a mechanism to efficiently compute derived values based on dependencies. `getDerivedStateFromProps` is a static method to derive state from props/state changes, running before render. `useMemo` runs during rendering and memoizes the result of a calculation based on its dependencies, preventing recalculations. It allows for similar performance benefits when complex calculations depend on props or state, serving as a more flexible and often safer alternative for deriving *computed data* rather than directly manipulating state based on props.",
          "options": [],
          "analysisPoints": [
            "Correctly maps each hook to its class component equivalent(s).",
            "Explains the role of the `useEffect` dependency array and cleanup function.",
            "Clarifies the conceptual similarity between `useMemo` and `getDerivedStateFromProps` regarding derived values/state, while noting their differences."
          ],
          "keyConcepts": [
            "React Hooks",
            "Class Components",
            "Lifecycle Methods",
            "useState",
            "useEffect",
            "useMemo",
            "Comparison"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of hook equivalences",
            "Ability to articulate differences and best practices"
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Comparison",
            "Lifecycle"
          ],
          "prerequisites": [
            "React_hooks_basics",
            "React_class_components_lifecycle"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_6",
          "topic": "React useEffect Dependencies",
          "level": "hard",
          "type": "code",
          "question": "Given the `ProfilePage` component, what would happen if `userId` was omitted from the `useEffect` dependency array? Describe the implications and how it would affect data fetching.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Understands the consequence of omitting a dependency.",
            "Explains that the effect would only run once on mount.",
            "Identifies that data would not update when `userId` changes.",
            "Connects this to stale closures and potential bugs."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Stale Closures",
            "Data Fetching",
            "Bugs"
          ],
          "evaluationCriteria": [
            "Ability to identify and explain `useEffect` dependency issues",
            "Predicting behavior changes due to incorrect dependencies"
          ],
          "example": "```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction ProfilePageNoDep({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    // Problematic: userId is not in dependencies, so this effect will only run ONCE on mount.\n    // If userId changes later, the effect (and fetch) will NOT re-run.\n    setLoading(true);\n    fetch(`/api/users/${userId}`) // This userId is captured from the initial render\n      .then(response => response.json())\n      .then(data => {\n        setUser(data);\n        setLoading(false);\n      })\n      .catch(err => {\n        console.error(err);\n        setLoading(false);\n      });\n    \n    // Cleanup is still important but doesn't solve the stale dependency issue.\n    return () => {}; \n  }, []); // <-- userId is missing from here!\n  \n  if (loading) return <div>Loading...</div>;\n  return <div>User: {user ? user.name : 'N/A'}</div>;\n}\n\n// Implications:\n// If ProfilePageNoDep is used like: <ProfilePageNoDep userId=\"1\" />\n// And then later changes to: <ProfilePageNoDep userId=\"2\" />\n// The data fetch will *not* re-run, and the component will continue to display user 1's data.\n```\nIf `userId` were omitted from the `useEffect` dependency array (i.e., `[]` was used), the effect would only run once after the initial render of the `ProfilePageNoDep` component. This means that if the `userId` prop subsequently changes (e.g., the parent component passes a different `userId`), the `fetch` request inside `useEffect` would *not* be re-triggered. Consequently, the component would continue to display data for the *initial* `userId` it received, leading to stale and incorrect data being shown to the user. This is a classic 'stale closure' problem in Hooks, where the effect closes over the initial `userId` value and doesn't react to its changes.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependency Array",
            "Stale Closures",
            "Bugs",
            "Data Fetching"
          ],
          "prerequisites": [
            "useEffect_advanced"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_7",
          "topic": "React `useMemo` vs `useCallback`",
          "level": "hard",
          "type": "open",
          "question": "When would you use `useMemo` versus `useCallback`, and what problem do they both aim to solve in React?",
          "answer": "`useMemo` and `useCallback` are both memoization hooks that aim to solve performance problems related to unnecessary re-renders in React by preventing expensive computations or function re-creations.\n\n*   **`useMemo`**: This hook is used to memoize a *value*. It takes a function that computes a value and a dependency array. It will only re-compute the value when one of its dependencies changes. You should use `useMemo` when you have an expensive calculation that produces a specific value (e.g., filtering a large list, transforming data) and you want to avoid recalculating it on every render if the inputs (dependencies) haven't changed.\n\n    ```javascript\n    const memoizedValue = useMemo(() => calculateExpensiveValue(a, b), [a, b]);\n    ```\n\n*   **`useCallback`**: This hook is used to memoize a *function*. It takes a function definition and a dependency array. It returns a memoized version of the callback that only changes if one of the dependencies has changed. You should use `useCallback` primarily when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary re-renders (e.g., `React.memo` components or components using `shouldComponentUpdate`). Without `useCallback`, a new function instance would be created on every render, causing the child component to re-render even if its props haven't conceptually changed.\n\n    ```javascript\n    const memoizedCallback = useCallback(() => {\n      doSomething(a, b);\n    }, [a, b]);\n    ```\n\n**Common Problem Solved:** Both hooks address the issue of unnecessary re-renders of child components or re-execution of expensive operations. In React, components re-render whenever their state or props change. If a parent component re-renders, its child components also re-render by default. By memoizing values or functions, these hooks ensure that child components (especially those wrapped with `React.memo` or implementing `shouldComponentUpdate`) don't re-render if the props they receive (including functions) are referentially identical, thus optimizing the rendering performance of the application.",
          "options": [],
          "analysisPoints": [
            "Clearly defines the purpose of `useMemo` (memoize value) and `useCallback` (memoize function).",
            "Provides correct usage examples for both.",
            "Explains the core problem they both solve: unnecessary re-renders and expensive computations.",
            "Connects `useCallback` specifically to optimizing child components that rely on referential equality.",
            "Shows a strong understanding of React's rendering optimizations."
          ],
          "keyConcepts": [
            "useMemo",
            "useCallback",
            "Memoization",
            "Performance Optimization",
            "Referential Equality",
            "React.memo"
          ],
          "evaluationCriteria": [
            "Deep understanding of memoization hooks",
            "Ability to differentiate their use cases",
            "Knowledge of performance optimization in React"
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Optimization",
            "useMemo",
            "useCallback"
          ],
          "prerequisites": [
            "React_memoization",
            "React_functional_components"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_8",
          "topic": "React Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a correct rule for using React Hooks?",
          "answer": "Hooks can be called inside loops, conditions, or nested functions.",
          "options": [
            "Hooks must be called at the top level of function components.",
            "Hooks must be called from React function components or custom Hooks.",
            "Hooks can be called inside loops, conditions, or nested functions.",
            "The number of Hook calls must be stable across renders."
          ],
          "analysisPoints": [
            "Tests knowledge of the 'Rules of Hooks'.",
            "Identifies the core constraint that Hooks cannot be conditionally called.",
            "Reinforces that Hook calls must be consistent across renders."
          ],
          "keyConcepts": [
            "React Hooks",
            "Rules of Hooks",
            "useState",
            "useEffect",
            "Ordering"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental Hook usage rules"
          ],
          "example": "The 'Rules of Hooks' state that Hooks must be called at the top level of your React function components – this means you cannot call Hooks inside loops, conditions, or nested functions. This rule is crucial for React to correctly associate the state and effects with the component across multiple renders. If Hooks were called conditionally, React wouldn't be able to guarantee the order of Hook calls on subsequent renders, leading to inconsistencies and bugs. The other options are correct rules for using Hooks.",
          "tags": [
            "React",
            "Hooks",
            "Rules of Hooks"
          ],
          "prerequisites": [
            "React_hooks_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_9",
          "topic": "React Hooks",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following class component into a functional component using `useState` and `useEffect` to manage the counter.",
          "answer": "```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction FunctionalCounter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Component mounted or count updated:', count);\n    return () => {\n      console.log('Cleanup for count:', count);\n    };\n  }, [count]); // Re-run effect when count changes\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly converts class state to `useState`.",
            "Uses `useEffect` to mimic `componentDidMount` and `componentDidUpdate`.",
            "Demonstrates proper dependency array usage.",
            "Shows understanding of functional state updates (`prevCount`)."
          ],
          "keyConcepts": [
            "useState",
            "useEffect",
            "Refactoring",
            "Class to Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to refactor components",
            "Correct Hook implementation"
          ],
          "example": "```javascript\nimport React from 'react';\n\nclass ClassCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  componentDidMount() {\n    console.log('Component mounted:', this.state.count);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.count !== this.state.count) {\n      console.log('Component updated, count:', this.state.count);\n    }\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "Refactoring",
            "useState",
            "useEffect",
            "Class Components"
          ],
          "prerequisites": [
            "React_class_components",
            "React_hooks_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_10",
          "topic": "React useState",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct way to initialize state using `useState`?",
          "answer": "const [data, setData] = useState({});",
          "options": [
            "const data = useState({});",
            "const [data] = useState({});",
            "const [data, setData] = useState({});",
            "const { data, setData } = useState({});"
          ],
          "analysisPoints": [
            "Tests knowledge of destructuring array returned by `useState`.",
            "Verifies correct variable naming convention for state and setter."
          ],
          "keyConcepts": [
            "useState",
            "State Initialization",
            "Array Destructuring"
          ],
          "evaluationCriteria": [
            "Correct syntax for `useState`"
          ],
          "example": "The `useState` hook returns an array containing two elements: the current state value and a function to update it. Array destructuring `[stateVariable, setStateVariable]` is the standard way to assign these values to variables.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Syntax"
          ],
          "prerequisites": [
            "React_functional_components"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_11",
          "topic": "React useEffect",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the behavior of `useEffect` if no dependency array is provided?",
          "answer": "If no dependency array is provided, the `useEffect` callback will run after every render of the component.",
          "options": [],
          "analysisPoints": [
            "Identifies 'runs after every render' as the default behavior.",
            "Implies comparison to `componentDidMount` and `componentDidUpdate`."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect` default behavior"
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect"
          ],
          "prerequisites": [
            "useEffect_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_12",
          "topic": "React `useMemo`",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following component, which line would cause the `expensiveCalculation` to re-run?",
          "answer": "Changing the value of `propA` or `propB`.",
          "options": [
            "Any re-render of the `MyComponent` component, regardless of prop changes.",
            "Changing the value of `propC` (not used in calculation dependencies).",
            "Changing the value of `propA` or `propB`.",
            "Only when the component is initially mounted."
          ],
          "analysisPoints": [
            "Tests understanding of `useMemo`'s dependency array.",
            "Distinguishes between dependencies and other props.",
            "Connects dependency changes to re-computation."
          ],
          "keyConcepts": [
            "useMemo",
            "Memoization",
            "Dependencies",
            "Performance"
          ],
          "evaluationCriteria": [
            "Correctly identifies dependency triggering re-computation for `useMemo`"
          ],
          "example": "```javascript\nimport React, { useMemo } from 'react';\n\nfunction expensiveCalculation(a, b) {\n  console.log('Performing expensive calculation...');\n  return a * 2 + b * 3;\n}\n\nfunction MyComponent({ propA, propB, propC }) {\n  const result = useMemo(() => expensiveCalculation(propA, propB), [propA, propB]);\n\n  return (\n    <div>\n      <p>Result: {result}</p>\n      <p>Prop C: {propC}</p>\n    </div>\n  );\n}\n```\n`useMemo` will only re-run the `expensiveCalculation` function if any of the values in its dependency array `[propA, propB]` change. If `propC` changes, but `propA` and `propB` remain the same, `MyComponent` will re-render, but `expensiveCalculation` will not execute again. If no dependencies change, `useMemo` returns the previously memoized value.",
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "Performance",
            "Dependencies"
          ],
          "prerequisites": [
            "useMemo_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_1",
          "topic": "Deprecated Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React class component lifecycle method is called before mounting occurs and is now considered `UNSAFE_`?",
          "answer": "`UNSAFE_componentWillMount()`",
          "options": [],
          "analysisPoints": [
            "Recalls the specific deprecated method.",
            "Associates it with the 'before mounting' phase."
          ],
          "keyConcepts": [
            "Class Components",
            "Lifecycle Methods",
            "UNSAFE_componentWillMount",
            "Deprecated"
          ],
          "evaluationCriteria": [
            "Basic recall of deprecated methods"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated"
          ],
          "prerequisites": [
            "React_class_components"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_legacy_lifecycle_2",
          "topic": "Deprecated Lifecycle Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Which modern React feature is the recommended replacement for the functionality often misused in `UNSAFE_componentWillReceiveProps` for deriving state from props?",
          "answer": "`static getDerivedStateFromProps()`",
          "options": [
            "`componentDidMount()`",
            "`static getDerivedStateFromProps()`",
            "`useReducer()`",
            "`componentWillUnmount()`"
          ],
          "analysisPoints": [
            "Correctly identifies the static method for deriving state.",
            "Understands why `UNSAFE_componentWillReceiveProps` was problematic."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "getDerivedStateFromProps",
            "State Derivation"
          ],
          "evaluationCriteria": [
            "Knowledge of modern alternatives to deprecated methods"
          ],
          "example": "The `static getDerivedStateFromProps` lifecycle method is specifically designed for cases where state depends on changes in props over time. It runs before every render, both on the initial mount and on subsequent updates. It returns an object to update the state, or `null` to indicate no state update. This method replaced the problematic `UNSAFE_componentWillReceiveProps` for deriving state, as it prevents common anti-patterns like setting state asynchronously based on props, which could lead to infinite loops or inconsistent state.",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated",
            "getDerivedStateFromProps"
          ],
          "prerequisites": [
            "React_class_components_lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_3",
          "topic": "Deprecated Lifecycle Methods",
          "level": "hard",
          "type": "open",
          "question": "Why are lifecycle methods prefixed with `UNSAFE_` considered problematic in modern React, and what are the general risks associated with using them?",
          "answer": "Lifecycle methods prefixed with `UNSAFE_` (`UNSAFE_componentWillMount`, `UNSAFE_componentWillReceiveProps`, `UNSAFE_componentWillUpdate`) are problematic because they were often misused in ways that led to bugs and made future React features (like Async Rendering and Concurrent Mode) difficult to implement.\n\n**Reasons for deprecation and risks:**\n\n1.  **Race Conditions and Inconsistent State**: These methods execute before `render`. In a future asynchronous rendering environment (Concurrent Mode), React might pause, abort, or restart renders. If side effects (like data fetching or setting state) are performed in these `UNSAFE_` methods, they might run multiple times or at unexpected times, leading to inconsistent UI states, memory leaks, or race conditions if not handled extremely carefully.\n2.  **Blocking Rendering**: Performing expensive operations or data fetching in `UNSAFE_componentWillMount` can block the initial render of the component, leading to a poorer user experience (blank screen).\n3.  **Misuse for Side Effects**: Developers often placed side effects (subscriptions, data fetches, DOM manipulations) in `componentWillMount` or `componentWillUpdate` that should have occurred *after* rendering. This led to issues because the DOM might not yet be available or fully updated when these methods ran.\n4.  **Deriving State Issues**: `UNSAFE_componentWillReceiveProps` was frequently misused to derive state from props. This pattern often led to infinite loops if `setState` was called unconditionally, or subtle bugs due to state not being reset correctly when props changed. `getDerivedStateFromProps` was introduced to safely handle this specific use case.\n\nIn essence, these methods encouraged patterns that were incompatible with React's evolving rendering model, where rendering is not guaranteed to be synchronous and might be interrupted. Their deprecation nudges developers towards safer patterns (like using `componentDidMount`/`Update` or `useEffect` for side effects, and `getDerivedStateFromProps` for state derivation) that align with the core principles of React's reconciliation process.",
          "options": [],
          "analysisPoints": [
            "Explains the core problem (incompatibility with async React).",
            "Lists specific risks like race conditions, inconsistent state, blocking render.",
            "Connects misuse of side effects/state derivation to the deprecation.",
            "Demonstrates understanding of React's rendering model evolution."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "UNSAFE_",
            "Async React",
            "Concurrent Mode",
            "Side Effects",
            "State Management",
            "Performance"
          ],
          "evaluationCriteria": [
            "Deep understanding of deprecation rationale",
            "Ability to articulate potential pitfalls"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated",
            "Interview Question"
          ],
          "prerequisites": [
            "React_class_components_lifecycle_advanced"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_legacy_lifecycle_4",
          "topic": "Deprecated Lifecycle Methods",
          "level": "medium",
          "type": "code",
          "question": "Provide a class component snippet that uses a deprecated lifecycle method and briefly explain why it's problematic.",
          "answer": "```javascript\nimport React from 'react';\n\nclass DataFetcherComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null, loading: true };\n  }\n\n  // Problematic: This method is called before the component is mounted to the DOM.\n  // If data fetching is performed here, it blocks the initial render.\n  // In React's future concurrent mode, this method might also run multiple times \n  // or be interrupted, leading to inconsistent state or unexpected behavior.\n  // Side effects like data fetching should ideally happen after mounting (in componentDidMount or useEffect).\n  UNSAFE_componentWillMount() {\n    console.log('UNSAFE_componentWillMount: Fetching data...');\n    fetch('/api/some-data')\n      .then(response => response.json())\n      .then(data => this.setState({ data, loading: false }))\n      .catch(error => {\n        console.error('Fetch error:', error);\n        this.setState({ loading: false });\n      });\n  }\n\n  render() {\n    if (this.state.loading) {\n      return <div>Loading data...</div>;\n    }\n    if (!this.state.data) {\n      return <div>No data found.</div>;\n    }\n    return <div>Data: {JSON.stringify(this.state.data)}</div>;\n  }\n}\n```\n\n**Why it's problematic:** Using `UNSAFE_componentWillMount` for data fetching is problematic because it runs *before* the component is actually mounted to the DOM. This means if the data fetch takes time, it will block the initial render of the component, leading to a blank screen or a perceived delay for the user. Furthermore, in future React concurrent rendering modes, this method could be invoked multiple times or asynchronously, making side effects like data fetching unpredictable and prone to race conditions. The recommended approach for data fetching in class components is `componentDidMount` (or `useEffect` in functional components) because it ensures the DOM is ready and the side effect runs only once after the component is fully mounted.",
          "options": [],
          "analysisPoints": [
            "Provides a valid code snippet using an `UNSAFE_` method.",
            "Clearly explains the specific problem caused by using that method (e.g., blocking render for `UNSAFE_componentWillMount`).",
            "Mentions the implications for future React features.",
            "Suggests the correct alternative."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "UNSAFE_componentWillMount",
            "Data Fetching",
            "Performance",
            "Race Conditions"
          ],
          "evaluationCriteria": [
            "Ability to identify and explain a specific problem with deprecated methods in code"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated",
            "Code Example"
          ],
          "prerequisites": [
            "React_class_components",
            "Lifecycle_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_5",
          "topic": "Deprecated Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which `UNSAFE_` lifecycle method is called when new props are received, and what is its recommended replacement for side effects?",
          "answer": "`UNSAFE_componentWillReceiveProps`. For side effects reacting to prop changes, the recommended replacement is `componentDidUpdate` (or `useEffect` in functional components).",
          "options": [],
          "analysisPoints": [
            "Identifies `UNSAFE_componentWillReceiveProps`.",
            "Provides the correct replacement for side effects."
          ],
          "keyConcepts": [
            "UNSAFE_componentWillReceiveProps",
            "componentDidUpdate",
            "Side Effects",
            "Deprecated"
          ],
          "evaluationCriteria": [
            "Recall of deprecated method and its side-effect replacement"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated"
          ],
          "prerequisites": [
            "React_class_components"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_6",
          "topic": "Deprecated Lifecycle Methods",
          "level": "medium",
          "type": "open",
          "question": "In the context of class components, what is `getSnapshotBeforeUpdate` used for, and why was it introduced as a safer alternative compared to `UNSAFE_componentWillUpdate` for certain use cases?",
          "answer": "`getSnapshotBeforeUpdate(prevProps, prevState)` is a lifecycle method in React class components that is invoked right before the most recently rendered output is committed to the DOM. It enables your component to capture some information from the DOM (e.g., scroll position) *before* it is potentially changed by the upcoming update. The value returned by `getSnapshotBeforeUpdate` is then passed as a third parameter to `componentDidUpdate(prevProps, prevState, snapshot)`.\n\nIt was introduced as a safer alternative to `UNSAFE_componentWillUpdate` for situations where you need to read information from the DOM *before* an update. `UNSAFE_componentWillUpdate` was problematic because it ran before `render`, and in a future async React, `render` might be interrupted or re-run multiple times, making it unreliable to perform DOM-related operations. `getSnapshotBeforeUpdate` guarantees that you can read the DOM state synchronously *just before* the changes are painted, ensuring that you get a consistent snapshot of the DOM's state at that precise moment, avoiding potential race conditions or inconsistencies that could arise with `UNSAFE_componentWillUpdate` in concurrent scenarios.",
          "options": [],
          "analysisPoints": [
            "Clearly defines `getSnapshotBeforeUpdate`'s purpose (capture DOM info before update).",
            "Explains its position in the lifecycle and how its return value is used.",
            "Highlights the safety aspect compared to `UNSAFE_componentWillUpdate`.",
            "Connects to the consistency needed for DOM operations in async React."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "UNSAFE_componentWillUpdate",
            "DOM Manipulation",
            "Lifecycle",
            "Asynchronous React"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `getSnapshotBeforeUpdate`",
            "Understanding of its relation to deprecated methods and async rendering"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "Deprecated"
          ],
          "prerequisites": [
            "React_class_components_lifecycle_advanced"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_legacy_lifecycle_7",
          "topic": "Legacy Lifecycle Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Which pair correctly matches a deprecated lifecycle method with its primary replacement in functional components using Hooks?",
          "answer": "`UNSAFE_componentWillMount` -> `useEffect` with an empty dependency array (`[]`)",
          "options": [
            "`UNSAFE_componentWillReceiveProps` -> `useMemo`",
            "`UNSAFE_componentWillMount` -> `useEffect` with an empty dependency array (`[]`)",
            "`UNSAFE_componentWillUpdate` -> `useCallback`",
            "`componentWillUnmount` -> `useState`"
          ],
          "analysisPoints": [
            "Correctly identifies the direct Hook equivalent for `UNSAFE_componentWillMount` for initial setup.",
            "Recognizes that other options are incorrect or misaligned replacements."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "Hooks Equivalents",
            "useEffect",
            "useState",
            "useMemo",
            "useCallback"
          ],
          "evaluationCriteria": [
            "Accurate mapping of deprecated methods to Hook patterns"
          ],
          "example": "`UNSAFE_componentWillMount` was typically used for initial setup or data fetching before the first render. In functional components, this behavior is best replicated using `useEffect` with an empty dependency array (`[]`), which ensures the effect runs only once after the initial render, similar to `componentDidMount`. While `componentWillUnmount` is replaced by the cleanup function in `useEffect`, `useState` is for state, `useMemo` for memoized values, and `useCallback` for memoized functions, none of which directly replace the broad functionality of the deprecated 'will mount' method.",
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Lifecycle",
            "Comparison"
          ],
          "prerequisites": [
            "React_class_components_lifecycle",
            "React_hooks_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_8",
          "topic": "Deprecated Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "What common prefix is added to deprecated React class lifecycle methods to indicate they are unsafe?",
          "answer": "`UNSAFE_`",
          "options": [],
          "analysisPoints": [
            "Recalls the specific prefix used for deprecated methods."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "UNSAFE_"
          ],
          "evaluationCriteria": [
            "Basic knowledge of React deprecation conventions"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated"
          ],
          "prerequisites": [
            "React_class_components"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_1",
          "topic": "Conditional Rendering",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of conditional rendering in React?",
          "answer": "To render different UI elements or components based on certain conditions or application state.",
          "options": [],
          "analysisPoints": [
            "Defines conditional rendering with 'different UI' and 'conditions'."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "UI",
            "State"
          ],
          "evaluationCriteria": [
            "Basic understanding of conditional rendering concept"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "UI"
          ],
          "prerequisites": [
            "React_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_2",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following JSX snippets correctly uses the logical `&&` operator for conditional rendering?",
          "answer": "{isLoggedIn && <WelcomeMessage />}",
          "options": [
            "{isLoggedIn ? <WelcomeMessage />}",
            "{isLoggedIn && <WelcomeMessage />}",
            "{<WelcomeMessage /> if isLoggedIn}",
            "{if (isLoggedIn) { <WelcomeMessage /> }}"
          ],
          "analysisPoints": [
            "Identifies correct syntax for logical `&&` in JSX.",
            "Distinguishes from incorrect or non-JSX valid syntax."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "Logical && Operator",
            "JSX Syntax"
          ],
          "evaluationCriteria": [
            "Correct application of `&&` for conditional rendering"
          ],
          "example": "The logical `&&` operator works well when you want to render *something* only when a condition is `true`, and *nothing* otherwise. If `isLoggedIn` is `true`, `WelcomeMessage` will be rendered. If `isLoggedIn` is `false` (or `null`, `undefined`, `0`, `''`), React will render nothing because `false` (or the other falsy values) are valid renderable values in JSX that result in no output. The other options are either incorrect syntax for JSX or not the `&&` operator.",
          "tags": [
            "React",
            "Conditional Rendering",
            "JSX"
          ],
          "prerequisites": [
            "React_basics",
            "JavaScript_operators"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_3",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "code",
          "question": "Implement a `Notification` component that conditionally renders a message based on two props: `hasNotifications` (boolean) and `message` (string). If `hasNotifications` is true, display the `message` inside a `div`. Otherwise, display 'No new notifications.' Use both an `if` statement and a ternary operator in two separate examples.",
          "answer": "```javascript\nimport React from 'react';\n\n// Using if statement\nfunction NotificationIf({ hasNotifications, message }) {\n  if (hasNotifications) {\n    return <div style={{ color: 'blue' }}>{message}</div>;\n  }\n  return <div>No new notifications.</div>;\n}\n\n// Using ternary operator\nfunction NotificationTernary({ hasNotifications, message }) {\n  return (\n    <div>\n      {hasNotifications \n        ? <div style={{ color: 'green' }}>{message}</div> \n        : <div>No new notifications.</div>\n      }\n    </div>\n  );\n}\n\n// Example Usage:\n// <NotificationIf hasNotifications={true} message=\"You have 3 unread emails!\" />\n// <NotificationTernary hasNotifications={false} message=\"\" />\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `if` statement for conditional return.",
            "Correctly uses ternary operator for inline conditional rendering.",
            "Handles both true and false conditions."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "If Statement",
            "Ternary Operator",
            "JSX"
          ],
          "evaluationCriteria": [
            "Ability to implement conditional logic using different syntax"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "Code Example"
          ],
          "prerequisites": [
            "React_components",
            "JavaScript_control_flow"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_conditional_rendering_4",
          "topic": "Conditional Rendering",
          "level": "easy",
          "type": "flashcard",
          "question": "When is it generally preferred to use an `if` statement over a ternary operator for conditional rendering in React?",
          "answer": "An `if` statement is generally preferred when the conditional logic is complex, involves multiple distinct rendering paths, or when you need to return null (or nothing) for one of the conditions. It improves readability for more elaborate logic compared to a nested ternary.",
          "options": [],
          "analysisPoints": [
            "Connects `if` to complexity and multiple paths.",
            "Emphasizes readability."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "If Statement",
            "Readability"
          ],
          "evaluationCriteria": [
            "Understanding of best practices for choosing conditional rendering methods"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "Best Practices"
          ],
          "prerequisites": [
            "Conditional_rendering_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_5",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where using the logical `&&` operator for conditional rendering would be more concise or appropriate than a ternary operator or an `if` statement.",
          "answer": "The logical `&&` operator (`condition && expression`) is most appropriate and concise when you want to render an element *only if a condition is true*, and render *nothing* otherwise. It is particularly useful for small, inline conditions where there is no alternative UI to display when the condition is false.\n\n**Scenario:** Displaying a loading spinner only when data is being fetched, or showing an 'unread messages' badge only when there are unread messages.\n\nExample:\n```javascript\nfunction UserDashboard({ isLoading, unreadMessagesCount }) {\n  return (\n    <div>\n      <h2>Dashboard</h2>\n      {isLoading && <p>Loading data...</p>} {/* Only render loading message if isLoading is true */}\n      {unreadMessagesCount > 0 && \n        <span>You have {unreadMessagesCount} unread messages!</span> /* Only render if count > 0 */\n      }\n      <p>Welcome back!</p>\n    </div>\n  );\n}\n```\nIn this scenario, if `isLoading` is false, or `unreadMessagesCount` is 0, we don't want to render any alternative UI; we just want those elements to disappear. Using `&&` is cleaner than `isLoading ? <p>Loading...</p> : null` or an `if` statement for each small, optional element.",
          "options": [],
          "analysisPoints": [
            "Identifies the specific use case: render only if true, nothing otherwise.",
            "Provides a clear, practical scenario (e.g., loading spinners, badges).",
            "Demonstrates understanding of conciseness compared to alternatives."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "Logical && Operator",
            "Conciseness",
            "UI/UX"
          ],
          "evaluationCriteria": [
            "Ability to identify appropriate use cases for specific techniques",
            "Explaining benefits of chosen method"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "Logical &&",
            "Best Practices"
          ],
          "prerequisites": [
            "Conditional_rendering_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_conditional_rendering_6",
          "topic": "Conditional Rendering",
          "level": "hard",
          "type": "code",
          "question": "Create a `UserProfile` component that displays user information. It should handle three states:\n1.  **Loading**: Show 'Loading user data...' if `isLoading` is true.\n2.  **Error**: Show 'Error: [error message]' if `error` is present.\n3.  **Data Loaded**: Show user's name and email if `user` data is available.\n\nUse a combination of conditional rendering techniques (`if` statements, ternary, `&&` operator) as appropriate for each state, ensuring a clear priority (error > loading > data).",
          "answer": "```javascript\nimport React from 'react';\n\nfunction UserProfile({ user, isLoading, error }) {\n  // 1. Prioritize error state using an if statement for early exit\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  // 2. Prioritize loading state using an if statement for early exit\n  if (isLoading) {\n    return <div>Loading user data...</div>;\n  }\n\n  // 3. Render user data if available, using ternary for concise display or && for optional parts\n  // Using ternary for whether user exists, and && for optional email\n  return (\n    <div>\n      {user ? (\n        <>\n          <h2>Name: {user.firstName} {user.lastName}</h2>\n          {user.email && <p>Email: {user.email}</p>}\n          {/* Example of optional profile image */}\n          {user.profilePicUrl && <img src={user.profilePicUrl} alt=\"Profile\" style={{width: '100px', height: '100px'}} />}\n        </>\n      ) : (\n        <div>No user data available.</div> // Fallback if user is null/undefined after loading/error check\n      )}\n    </div>\n  );\n}\n\n/* Example Usage:\n<UserProfile user={null} isLoading={true} error={null} /> // Shows Loading\n<UserProfile user={null} isLoading={false} error={{ message: 'User not found' }} /> // Shows Error\n<UserProfile user={{ firstName: 'John', lastName: 'Doe', email: 'john@example.com' }} isLoading={false} error={null} /> // Shows User data\n<UserProfile user={{ firstName: 'Jane', lastName: 'Smith' }} isLoading={false} error={null} /> // Shows User data without email\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Correctly handles multiple, prioritized states (error, loading, data).",
            "Effectively uses `if` statements for early exits for primary states.",
            "Utilizes ternary operator for `user` existence or fallback.",
            "Applies logical `&&` for optional data fields (e.g., email, profilePicUrl).",
            "Demonstrates a comprehensive understanding of combining conditional rendering techniques."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "If Statement",
            "Ternary Operator",
            "Logical && Operator",
            "State Management",
            "UI Priority"
          ],
          "evaluationCriteria": [
            "Ability to combine multiple conditional rendering techniques effectively",
            "Handling priority in UI states",
            "Clean and readable code"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "Complex UI",
            "State Management",
            "Best Practices"
          ],
          "prerequisites": [
            "Conditional_rendering_basics",
            "React_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_data_fetching_component",
          "title": "Implement a Data Fetching User List Component",
          "description": "\nCreate a React functional component named `UserList` that fetches a list of users from a mock API endpoint (`/api/users`). The component should:\n\n1.  **Manage State**: Use `useState` for `users` (an array), `loading` (boolean), and `error` (object/string).\n2.  **Fetch Data**: Use `useEffect` to perform the data fetch when the component mounts. The `useEffect` should have an empty dependency array.\n3.  **Error Handling**: If the fetch fails, set the `error` state and display an error message.\n4.  **Loading State**: Display a 'Loading users...' message while fetching.\n5.  **Display Data**: Once data is successfully fetched, render a list (e.g., `<ul>`) of user names. If no users are found, display 'No users available.'\n6.  **Cleanup**: Implement a cleanup function in `useEffect` to prevent state updates on unmounted components (e.g., using an `isMounted` flag). Mimic the `ProfilePage` example's `useEffect` behavior for cleanup.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Assume a mock fetch function for testing\nconst mockFetchUsers = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const success = Math.random() > 0.3; // 70% chance of success\n      if (success) {\n        resolve([\n          { id: 1, name: 'Alice' },\n          { id: 2, name: 'Bob' },\n          { id: 3, name: 'Charlie' }\n        ]);\n      } else {\n        reject(new Error('Failed to fetch users.'));\n      }\n    }, 1000);\n  });\n};\n\nfunction UserList() {\n  // TODO: Implement state variables for users, loading, and error\n\n  // TODO: Implement useEffect for data fetching with cleanup\n\n  // TODO: Implement conditional rendering for loading, error, and data display\n\n  return (\n    <div>\n      {/* Your rendering logic here */}\n    </div>\n  );\n}\n\nexport default UserList;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nconst mockFetchUsers = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const success = Math.random() > 0.3; \n      if (success) {\n        // To test 'No users available' case, uncomment the empty array occasionally\n        resolve([\n          { id: 1, name: 'Alice' },\n          { id: 2, name: 'Bob' },\n          { id: 3, name: 'Charlie' }\n        ]);\n        // resolve([]); // Uncomment to test no users found\n      } else {\n        reject(new Error('Network request failed. Please try again.'));\n      }\n    }, 1000);\n  });\n};\n\nfunction UserList() {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true; // Flag to track mount status\n    setLoading(true);    // Set loading true before fetch\n    setError(null);      // Clear any previous errors\n\n    mockFetchUsers()\n      .then(data => {\n        if (isMounted) {\n          setUsers(data);\n          setLoading(false);\n        }\n      })\n      .catch(err => {\n        if (isMounted) {\n          setError(err);\n          setLoading(false);\n        }\n      });\n\n    return () => {\n      isMounted = false; // Cleanup: set flag to false when component unmounts\n    };\n  }, []); // Empty dependency array means this effect runs once on mount\n\n  if (loading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (users.length === 0) {\n    return <div>No users available.</div>;\n  }\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default UserList;\n",
          "testCases": [
            "Component should display 'Loading users...' initially.",
            "On successful fetch, component should display a list of user names.",
            "On failed fetch, component should display an error message.",
            "If `mockFetchUsers` resolves with an empty array, 'No users available.' should be displayed.",
            "Simulate unmounting the component before fetch completes; verify no console warnings about state updates."
          ],
          "hints": [
            "Remember to use `useState` for each piece of state (users, loading, error).",
            "The `useEffect` hook with an empty dependency array `[]` is crucial for 'run once on mount' behavior.",
            "Don't forget the cleanup function in `useEffect` to handle potential unmounted component issues during asynchronous operations.",
            "Consider the order of your conditional `if` statements for displaying loading, error, or data messages."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Data Fetching",
            "Error Handling",
            "Loading States",
            "Conditional Rendering"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_functional_components",
            "Promises",
            "useEffect_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Side Effects",
            "Asynchronous JavaScript",
            "Component Lifecycle"
          ]
        },
        {
          "id": "task_memoized_calculation",
          "title": "Build a Shopping Cart Item Component with Memoized Price Calculation",
          "description": "\nCreate a `CartItem` React functional component that displays details of a product in a shopping cart. The component should:\n\n1.  Accept `item` (an object with `name`, `price`, `quantity`) and `discountPercentage` as props.\n2.  Use `useState` for the `quantity` (making it editable) and a button to increase/decrease it.\n3.  Calculate the `totalPrice` for the item (price * quantity * (1 - discountPercentage)). This calculation can be expensive in a real-world scenario.\n4.  **Optimize Calculation**: Use `useMemo` to memoize the `totalPrice` calculation. Ensure it only re-calculates when `price`, `quantity`, or `discountPercentage` change, but not on other renders (e.g., parent re-renders).\n5.  Display the item's name, individual price, current quantity, discount, and the memoized total price.\n6.  Include a console log inside the `useMemo` calculation to prove when it re-runs.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useMemo } from 'react';\n\nfunction CartItem({ item, discountPercentage }) {\n  // item: { name: string, price: number, quantity: number (initial) }\n  // discountPercentage: number (e.g., 0.1 for 10%)\n\n  // TODO: Manage quantity state with useState\n\n  // TODO: Use useMemo for total price calculation\n\n  // TODO: Implement increase/decrease quantity buttons\n\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', borderRadius: '5px' }}>\n      {/* Your rendering logic here */}\n    </div>\n  );\n}\n\nexport default CartItem;\n\n// Example Usage (in a parent component):\n// <CartItem item={{ name: 'Laptop', price: 1200, quantity: 1 }} discountPercentage={0.05} />\n// <CartItem item={{ name: 'Mouse', price: 25, quantity: 2 }} discountPercentage={0.10} />\n",
          "solutionCode": "import React, { useState, useMemo } from 'react';\n\nfunction CartItem({ item, discountPercentage }) {\n  const [quantity, setQuantity] = useState(item.quantity);\n\n  // Use useMemo to memoize the totalPrice calculation\n  const totalPrice = useMemo(() => {\n    console.log(`Calculating total price for ${item.name}...`);\n    return item.price * quantity * (1 - discountPercentage);\n  }, [item.price, quantity, discountPercentage]); // Dependencies\n\n  const increaseQuantity = () => {\n    setQuantity(prevQuantity => prevQuantity + 1);\n  };\n\n  const decreaseQuantity = () => {\n    setQuantity(prevQuantity => Math.max(1, prevQuantity - 1)); // Ensure quantity doesn't go below 1\n  };\n\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', borderRadius: '5px' }}>\n      <h3>{item.name}</h3>\n      <p>Price per unit: ${item.price.toFixed(2)}</p>\n      <p>Quantity:\n        <button onClick={decreaseQuantity} disabled={quantity === 1}>-</button>\n        {' '}{quantity}{' '}\n        <button onClick={increaseQuantity}>+</button>\n      </p>\n      <p>Discount: {(discountPercentage * 100).toFixed(0)}%</p>\n      <p><strong>Total: ${totalPrice.toFixed(2)}</strong></p>\n      <small>Check console for 'Calculating total price...' log to see memoization in action.</small>\n    </div>\n  );\n}\n\nexport default CartItem;\n",
          "testCases": [
            "Initial render: 'Calculating total price...' should appear in console.",
            "Clicking 'Increase Quantity': 'Calculating total price...' should appear in console, total price should update.",
            "Clicking 'Decrease Quantity': 'Calculating total price...' should appear in console, total price should update (quantity >= 1).",
            "If a parent component re-renders `CartItem` without changing `item.price`, `quantity` (internal state), or `discountPercentage`, 'Calculating total price...' should *not* appear in console.",
            "Verify `totalPrice` calculation is correct with different quantities and discounts."
          ],
          "hints": [
            "The `useMemo` hook takes a function as its first argument and a dependency array as its second.",
            "The console log should be placed *inside* the function passed to `useMemo`.",
            "Remember that `useState`'s setter function can accept a callback to update state based on the previous state (`setQuantity(prev => prev + 1)`)."
          ],
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "useState",
            "Performance Optimization",
            "Memoization",
            "Shopping Cart"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_functional_components",
            "useMemo_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Optimization",
            "Derived State",
            "Referential Equality"
          ]
        },
        {
          "id": "task_refactor_legacy_component",
          "title": "Refactor a Class-Based Counter with Lifecycle Logging to Functional Component with Hooks",
          "description": "\nRefactor the provided `LegacyCounter` class component into a `FunctionalCounter` component using React Hooks. The new component should:\n\n1.  **State Management**: Use `useState` to manage the `count`.\n2.  **Lifecycle Logging**: Use `useEffect` to replicate the console logging behavior of `componentDidMount` and `componentDidUpdate` (i.e., log when the component mounts and when the count changes). Include a cleanup log resembling `componentWillUnmount`.\n3.  **Increment/Decrement**: Provide buttons to increment and decrement the count.\n4.  Ensure the component behaves identically in terms of functionality and logging.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Original Class Component for reference:\n/*\nclass LegacyCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  componentDidMount() {\n    console.log('Class: Component mounted, count:', this.state.count);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.count !== this.state.count) {\n      console.log('Class: Component updated, count:', this.state.count);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('Class: Component unmounting, count:', this.state.count);\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  decrement = () => {\n    this.setState(prevState => ({ count: Math.max(0, prevState.count - 1) }));\n  };\n\n  render() {\n    return (\n      <div>\n        <h2>Legacy Counter</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n        <button onClick={this.decrement}>Decrement</button>\n      </div>\n    );\n  }\n}\n*/\n\nfunction FunctionalCounter() {\n  // TODO: Implement state and lifecycle logging with hooks\n\n  return (\n    <div>\n      <h2>Functional Counter</h2>\n      {/* Your rendering logic here */}\n    </div>\n  );\n}\n\nexport default FunctionalCounter;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction FunctionalCounter() {\n  const [count, setCount] = useState(0);\n\n  // Effect for componentDidMount and componentDidUpdate logic\n  useEffect(() => {\n    if (count === 0) {\n      console.log('Functional: Component mounted, count:', count);\n    } else {\n      console.log('Functional: Component updated, count:', count);\n    }\n\n    // Cleanup function for componentWillUnmount\n    return () => {\n      console.log('Functional: Component unmounting, count (at unmount):', count);\n    };\n  }, [count]); // Re-run effect when count changes\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const decrement = () => {\n    setCount(prevCount => Math.max(0, prevCount - 1));\n  };\n\n  return (\n    <div>\n      <h2>Functional Counter</h2>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}\n\nexport default FunctionalCounter;\n",
          "testCases": [
            "On initial render, 'Functional: Component mounted, count: 0' should appear in the console.",
            "Clicking 'Increment' button: count should increase, and 'Functional: Component updated, count: [new count]' should appear in the console.",
            "Clicking 'Decrement' button: count should decrease (not below 0), and 'Functional: Component updated, count: [new count]' should appear in the console.",
            "Unmounting the component (e.g., navigating away or conditionally hiding it) should trigger 'Functional: Component unmounting, count (at unmount): [final count]' in the console."
          ],
          "hints": [
            "A single `useEffect` can handle both mount and update logic by checking dependencies.",
            "The `return` function inside `useEffect` is for cleanup (unmount logic).",
            "The `count` state variable should be included in the `useEffect`'s dependency array to trigger updates.",
            "For the initial mount log, you might check if `count` is `0` or use a `useRef` to track first render, though `count` in the dependency array often suffices for this simple case."
          ],
          "tags": [
            "React",
            "Hooks",
            "Refactoring",
            "useState",
            "useEffect",
            "Class Components",
            "Lifecycle",
            "Migration"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_class_components_lifecycle",
            "React_hooks_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Architecture",
            "State Management",
            "Side Effects"
          ]
        },
        {
          "id": "task_build_auth_ui",
          "title": "Build a User Authentication UI with Conditional Rendering",
          "description": "\nCreate a React functional component named `AuthStatus` that displays different UI elements based on a user's authentication status and role.\n\n1.  **State Management**: Use `useState` for `isLoggedIn` (boolean, default `false`), `userRole` (string, default 'guest'), and `showAdminPanel` (boolean, default `false`).\n2.  **Login/Logout**: Add buttons to toggle `isLoggedIn`. When logging in, set `userRole` to 'user' or 'admin' randomly for demonstration purposes. When logging out, reset `userRole` to 'guest'.\n3.  **Conditional UI**: Implement the following display logic:\n    *   If `isLoggedIn` is `false`, show a 'Login' button and a message 'Please log in to access features.'\n    *   If `isLoggedIn` is `true`:\n        *   Show a 'Logout' button and a 'Welcome, [Role]!' message.\n        *   If `userRole` is 'admin', also show a button 'Toggle Admin Panel'. Clicking this button should toggle the `showAdminPanel` state.\n        *   If `showAdminPanel` is `true` (and `userRole` is 'admin'), display a `div` with 'Admin Dashboard Controls'.\n        *   If `userRole` is 'user', show a simple 'User Dashboard' message.\n4.  **Techniques**: Use a mix of `if` statements, ternary operators, and logical `&&` operators where most appropriate for readability and conciseness.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction AuthStatus() {\n  // TODO: Implement state for isLoggedIn, userRole, showAdminPanel\n\n  // TODO: Implement login/logout logic\n\n  // TODO: Implement conditional rendering based on state\n\n  return (\n    <div style={{ border: '1px solid lightblue', padding: '20px', margin: '20px' }}>\n      <h2>Authentication Status</h2>\n      {/* Your conditional rendering logic here */}\n    </div>\n  );\n}\n\nexport default AuthStatus;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction AuthStatus() {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [userRole, setUserRole] = useState('guest'); // 'guest', 'user', 'admin'\n  const [showAdminPanel, setShowAdminPanel] = useState(false);\n\n  const handleLogin = () => {\n    setIsLoggedIn(true);\n    // Randomly assign user or admin role for demonstration\n    const roles = ['user', 'admin'];\n    const randomRole = roles[Math.floor(Math.random() * roles.length)];\n    setUserRole(randomRole);\n    console.log(`Logged in as: ${randomRole}`);\n  };\n\n  const handleLogout = () => {\n    setIsLoggedIn(false);\n    setUserRole('guest');\n    setShowAdminPanel(false); // Hide admin panel on logout\n    console.log('Logged out');\n  };\n\n  const toggleAdminPanel = () => {\n    setShowAdminPanel(prev => !prev);\n  };\n\n  return (\n    <div style={{ border: '1px solid lightblue', padding: '20px', margin: '20px' }}>\n      <h2>Authentication Status</h2>\n\n      {!isLoggedIn ? (\n        // Not logged in\n        <>\n          <p>Please log in to access features.</p>\n          <button onClick={handleLogin}>Login</button>\n        </>\n      ) : (\n        // Logged in\n        <>\n          <p>Welcome, {userRole.charAt(0).toUpperCase() + userRole.slice(1)}!</p>\n          <button onClick={handleLogout}>Logout</button>\n\n          {userRole === 'admin' && (\n            // Admin specific controls\n            <div style={{ marginTop: '10px' }}>\n              <button onClick={toggleAdminPanel}>\n                {showAdminPanel ? 'Hide Admin Panel' : 'Show Admin Panel'}\n              </button>\n              {showAdminPanel && (\n                <div style={{ border: '1px dashed grey', padding: '10px', marginTop: '10px' }}>\n                  <h3>Admin Dashboard Controls</h3>\n                  <p>Manage users, view reports, etc.</p>\n                </div>\n              )}\n            </div>\n          )}\n\n          {userRole === 'user' && (\n            // Regular user specific message\n            <p style={{ marginTop: '10px' }}>User Dashboard</p>\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default AuthStatus;\n",
          "testCases": [
            "Initial state: 'Login' button and 'Please log in' message should be displayed.",
            "Click 'Login': User status should change to 'Welcome, User!' or 'Welcome, Admin!', and 'Logout' button appears.",
            "If logged in as 'admin': 'Toggle Admin Panel' button should appear.",
            "Click 'Toggle Admin Panel' (as admin): 'Admin Dashboard Controls' div should appear/disappear.",
            "Click 'Logout': UI should revert to initial 'Please log in' state, admin panel should be hidden if it was open."
          ],
          "hints": [
            "Use `useState` for `isLoggedIn`, `userRole`, and `showAdminPanel`.",
            "For login, you can randomly assign 'user' or 'admin' role using `Math.random()`.",
            "Combine ternary operators for the main `isLoggedIn` switch, and logical `&&` for conditionally showing the admin panel or admin-specific buttons.",
            "Ensure the `showAdminPanel` state is reset when `isLoggedIn` becomes `false`."
          ],
          "tags": [
            "React",
            "Conditional Rendering",
            "useState",
            "UI/UX",
            "Authentication",
            "State Management",
            "Dynamic UI"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_functional_components",
            "Conditional_rendering_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "User Interface",
            "Role-Based Access Control"
          ]
        }
      ]
    }
  },
  {
    "id": "3ed597f2-5003-45ed-a919-b53494560025",
    "startLine": 5000,
    "endLine": 5099,
    "processedDate": "2025-06-17T09:23:21.675Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_testing_overview",
          "title": "React Component Testing Overview",
          "content": "Testing React components is crucial for ensuring the reliability, maintainability, and correctness of user interfaces. It helps catch bugs early in the development cycle, verifies that components behave as expected under various conditions, and provides confidence for future changes or refactoring. There are several approaches and libraries for testing React components, each with its own philosophy and strengths.\n\nKey aspects of React testing often involve:\n- **Rendering components:** Mounting components into a test environment.\n- **Finding elements:** Querying the rendered output to locate specific DOM nodes.\n- **Simulating user interactions:** Triggering events like clicks, input changes, or form submissions.\n- **Asserting component behavior:** Verifying that the component's state, rendered output, or side effects are correct.\n- **Mocking dependencies:** Isolating the component under test by replacing external dependencies (like API calls or third-party libraries) with controlled mock implementations.",
          "examples": [],
          "relatedQuestions": [
            "question_testing_general_1",
            "question_testing_general_2"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "testing",
            "frontend-development",
            "best-practices"
          ],
          "technology": "React",
          "prerequisites": [
            "react_fundamentals",
            "javascript_fundamentals"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_advanced_topics",
            "component_library_development"
          ]
        },
        {
          "id": "theory_react_testing_library",
          "title": "React Testing Library (RTL)",
          "content": "React Testing Library (RTL) is a lightweight and opinionated testing utility for React that promotes testing components in a way that mimics how users interact with them. Its core philosophy is: 'The more your tests resemble the way your software is used, the more confidence they can give you.'\n\n## Key Concepts\n- **User-Centric Testing:** Instead of testing implementation details (like component internal state or methods), RTL encourages testing the public API of a component, specifically its output rendered to the DOM and how it responds to user interactions.\n- **Accessibility Focus:** RTL's querying methods prioritize finding elements in a way that is accessible to users, such as by `role`, `label text`, or `alt text`.\n- **`render` function:** Used to render a React component into a virtual DOM for testing.\n- **`screen` object:** Provides various query methods to find elements in the rendered DOM.\n- **`fireEvent`:** Used to simulate DOM events (e.g., `click`, `change`, `submit`).\n- **`waitFor`:** Essential for testing asynchronous operations, allowing tests to wait for elements to appear or disappear in the DOM.\n- **`@testing-library/jest-dom`:** Extends Jest's `expect` matchers with useful DOM-specific assertions (e.g., `toBeInTheDocument`, `toHaveTextContent`).\n\n## Query Priorities (Best to Worst)\n1.  **`getByRole`**: Finds elements by their ARIA role (e.g., `button`, `checkbox`, `textbox`). Most robust and accessible.\n2.  **`getByLabelText`**: Finds form elements by their associated label text.\n3.  **`getByPlaceholderText`**: Finds input elements by their placeholder text.\n4.  **`getByText`**: Finds elements containing specific text content. Useful for general text elements.\n5.  **`getByDisplayValue`**: Finds form elements by their current value.\n6.  **`getByAltText`**: Finds elements by their `alt` attribute (e.g., images).\n7.  **`getByTitle`**: Finds elements by their `title` attribute.\n8.  **`getByTestId`**: Finds elements by a `data-testid` attribute. This is a fallback and generally discouraged for user-facing elements, as it couples tests to implementation details, but can be useful for elements that are not user-facing or for debugging.\n\nFor asynchronous operations, `waitFor` or `findBy*` queries (which are `getBy*` variants that return a Promise and wait for the element to appear) are critical. Mocking API calls using Jest's `jest.mock` is common practice to isolate component tests from network dependencies.",
          "examples": [
            {
              "id": "example_rtl_counter_test",
              "title": "Basic Counter Component Test with RTL",
              "code": "import { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport Counter from './Counter';\n\n// Assuming Counter.tsx looks like:\n// const Counter = () => {\n//   const [count, setCount] = useState(0);\n//   return (\n//     <div>\n//       <div data-testid=\"counter-value\">{count}</div>\n//       <button onClick={() => setCount(prev => prev + 1)}>Increment</button>\n//     </div>\n//   );\n// };\n\ntest('counter increments when button is clicked', () => {\n  // Render the component into the DOM\n  render(<Counter />);\n  \n  // Find elements using screen queries\n  // getByTestId is used here as 'counter-value' is not user-facing\n  const counterValue = screen.getByTestId('counter-value');\n  // getByRole is preferred for interactive elements like buttons\n  const incrementButton = screen.getByRole('button', { name: /increment/i });\n  \n  // Assert initial state\n  expect(counterValue).toHaveTextContent('0');\n  \n  // Interact with the component by simulating a click event\n  fireEvent.click(incrementButton);\n  \n  // Assert updated state after interaction\n  expect(counterValue).toHaveTextContent('1');\n});",
              "explanation": "This example demonstrates the core workflow of React Testing Library: rendering a component, querying for elements based on user-facing attributes (like button text or ARIA roles), simulating user interactions, and asserting the expected outcome in the DOM. The `fireEvent.click` simulates a user clicking the button, and `toHaveTextContent` asserts the visual change.",
              "language": "typescript"
            },
            {
              "id": "example_rtl_async_data_test",
              "title": "Testing Asynchronous Component with RTL",
              "code": "import { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport UserData from './UserData';\n\n// Assuming UserData.tsx looks like:\n// import { useEffect, useState } from 'react';\n// import { fetchUserData } from '../api'; // This is mocked\n// const UserData = ({ userId }) => {\n//   const [user, setUser] = useState(null);\n//   const [loading, setLoading] = useState(true);\n//   useEffect(() => {\n//     fetchUserData(userId).then(data => {\n//       setUser(data);\n//       setLoading(false);\n//     });\n//   }, [userId]);\n//   if (loading) return <div>Loading...</div>;\n//   if (!user) return <div>No user found.</div>;\n//   return <div>{user.name}</div>;\n// };\n\n// Mock the API call using Jest's mocking capabilities\njest.mock('../api', () => ({\n  fetchUserData: jest.fn(() =>\n    Promise.resolve({ id: 1, name: 'John Doe' }) // Mocked successful response\n  ),\n}));\n\ntest('loads and displays user data', async () => {\n  render(<UserData userId={1} />);\n  \n  // Initially shows loading state while data is being fetched\n  expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  // Wait for the user data to load and appear in the DOM\n  // waitFor polls the DOM until the condition is met or timeout\n  await waitFor(() => {\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\n  });\n  \n  // Ensure loading indicator is removed after data loads (optional, but good)\n  expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();\n});",
              "explanation": "This example demonstrates testing a component that fetches data asynchronously. `jest.mock` is used to intercept and control the `fetchUserData` function, ensuring the test doesn't rely on actual network requests. `waitFor` is crucial here; it allows the test to pause and wait for the component's state to update and for the expected content ('John Doe') to appear in the DOM, simulating the delay of an API call.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_rtl_1",
            "question_rtl_2",
            "question_rtl_3",
            "question_rtl_4",
            "question_rtl_5",
            "question_rtl_6",
            "question_rtl_7",
            "question_rtl_8",
            "question_rtl_9",
            "question_rtl_10",
            "question_rtl_11",
            "question_rtl_12"
          ],
          "relatedTasks": [
            "task_rtl_form_validation",
            "task_rtl_async_component"
          ],
          "tags": [
            "react",
            "testing",
            "react-testing-library",
            "rtl",
            "jest",
            "unit-testing",
            "integration-testing",
            "asynchronous-testing"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "jest_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "professional_react_development",
            "component_library_development"
          ]
        },
        {
          "id": "theory_enzyme",
          "title": "Enzyme",
          "content": "Enzyme is a JavaScript testing utility for React that makes it easier to test your React components' output. Developed by Airbnb, it provides a jQuery-like API for traversing, manipulating, and simulating runtime events on your React components' output. Unlike React Testing Library, Enzyme primarily focuses on testing component internals and implementation details.\n\n## Key Concepts\n- **Shallow Rendering (`shallow`):** Renders only the component itself, not its children. This is useful for unit testing a component in isolation, ensuring that changes to child components do not affect the parent component's tests. It does not interact with the DOM.\n- **Full DOM Rendering (`mount`):** Renders the component into a real DOM (JSDOM in Node.js environments). This is suitable for integration tests where you need to test component lifecycle methods, interactions with the DOM, or interactions between parent and child components.\n- **Static Markup Rendering (`render`):** Renders React components to static HTML strings. This is useful for checking the rendered HTML output of components.\n- **`wrapper` object:** The result of `shallow`, `mount`, or `render`. It provides methods to find elements (`.find()`), simulate events (`.simulate()`), access state/props (`.state()`, `.props()`), and debug (`.debug()`).\n- **Implementation-Specific Testing:** Enzyme allows direct access to a component's internal state, props, and methods, making it possible to test specific implementation details.\n\nWhile still used in many legacy projects, Enzyme has seen reduced development and community adoption in favor of React Testing Library due to RTL's emphasis on user-centric testing and better alignment with modern React practices.",
          "examples": [
            {
              "id": "example_enzyme_counter_test",
              "title": "Counter Component Test with Enzyme",
              "code": "import { shallow, mount } from 'enzyme';\nimport Counter from './Counter';\n\n// Assuming Counter.tsx looks like:\n// const Counter = () => {\n//   const [count, setCount] = useState(0);\n//   return (\n//     <div className=\"counter\">\n//       <div className=\"value\">{count}</div>\n//       <button className=\"increment\" onClick={() => setCount(prev => prev + 1)}>Increment</button>\n//     </div>\n//   );\n// };\n\ndescribe('Counter Component', () => {\n  it('renders correctly with shallow', () => {\n    // Shallow render the component, isolating it from child components\n    const wrapper = shallow(<Counter />);\n    expect(wrapper.find('.counter')).toHaveLength(1);\n    expect(wrapper.find('.value').text()).toEqual('0');\n  });\n\n  it('increments when button is clicked with mount', () => {\n    // Mount the component into a full DOM for interaction testing\n    const wrapper = mount(<Counter />);\n    // Find the button by its class name\n    wrapper.find('button.increment').simulate('click');\n    // Assert the text content of the value element\n    expect(wrapper.find('.value').text()).toEqual('1');\n  });\n});",
              "explanation": "This example demonstrates using both `shallow` and `mount` with Enzyme. `shallow` is used to test the component in isolation, verifying its structure and initial state without rendering its children. `mount` is used for interaction testing, allowing simulation of a click event on the button and then asserting the change in the displayed value. Enzyme's `.find()` uses CSS selectors, similar to jQuery, for locating elements.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_enzyme_1",
            "question_enzyme_2",
            "question_enzyme_3",
            "question_enzyme_4",
            "question_enzyme_5",
            "question_enzyme_6",
            "question_enzyme_7"
          ],
          "relatedTasks": [
            "task_enzyme_component_interaction",
            "task_enzyme_context_api"
          ],
          "tags": [
            "react",
            "testing",
            "enzyme",
            "jest",
            "unit-testing",
            "shallow-rendering",
            "full-dom-rendering"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "jest_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "maintaining_legacy_react_apps",
            "deep_understanding_of_react_lifecycle"
          ]
        },
        {
          "id": "theory_jest_snapshots",
          "title": "Jest Snapshot Testing",
          "content": "Jest's snapshot testing is a powerful tool designed to help ensure your UI (or any serializable data structure) doesn't change unexpectedly. It works by capturing a 'snapshot' of a rendered component (or a data structure) and saving it as a text file alongside your test. On subsequent test runs, Jest compares the new rendered output to the previously saved snapshot.\n\n## How It Works\n1.  **First Run:** When a snapshot test is run for the first time, Jest renders the component (e.g., using `react-test-renderer` or by React Testing Library's `render` which creates a DOM structure) and serializes its output into a human-readable `.snap` file.\n2.  **Subsequent Runs:** In subsequent runs, Jest re-renders the component and compares the new output against the existing snapshot file.\n3.  **Failure:** If the new output differs from the snapshot, the test fails, and Jest provides a diff, highlighting the changes.\n4.  **Updating Snapshots:** If the changes are intentional (e.g., a UI update), you can run Jest with the `-u` flag (`jest -u` or `npm test -- -u`) to update the snapshots.\n\n## Use Cases\n-   **UI Regression Testing:** Catching unintentional changes to the UI's structure or appearance.\n-   **Data Structure Consistency:** Testing that the output of a function or the structure of an object remains consistent.\n\n## Advantages\n-   **Quick Regression Detection:** Automatically highlights any visual or structural regressions.\n-   **Ease of Use:** Simple to set up and run.\n\n## Disadvantages/Considerations\n-   **False Positives:** Tests can fail even for intentional UI changes, requiring manual updates.\n-   **Brittleness:** Over-reliance can lead to snapshots becoming too large or difficult to review, making it hard to discern meaningful changes from trivial ones.\n-   **Not a Replacement for Functional Tests:** Snapshots only verify structure, not behavior. They don't replace tests that simulate user interactions or verify application logic.\n\nWhile the provided markdown only shows an `import React from 'react';`, a typical snapshot test would involve rendering a component and asserting its structure using `toMatchSnapshot()`.",
          "examples": [
            {
              "id": "example_jest_snapshot_basic",
              "title": "Basic Snapshot Test for a React Component",
              "code": "import React from 'react';\nimport renderer from 'react-test-renderer'; // Used for server-side rendering/snapshots\n\n// Assuming a simple Greeting component:\n// const Greeting = ({ name }) => <h1>Hello, {name}!</h1>;\n\n// Or, if using React Testing Library:\n// import { render } from '@testing-library/react';\n// const Greeting = ({ name }) => <h1>Hello, {name}!</h1>;\n\ndescribe('Greeting Component', () => {\n  it('renders correctly and matches snapshot using react-test-renderer', () => {\n    const tree = renderer.create(<Greeting name=\"World\" />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders correctly and matches snapshot using React Testing Library', () => {\n    // When using RTL, the default render output can also be snapshotted\n    const { asFragment } = render(<Greeting name=\"Jest\" />);\n    expect(asFragment()).toMatchSnapshot();\n  });\n});\n\n/* Example .snap file content:\n\nexports[`Greeting Component renders correctly and matches snapshot using react-test-renderer 1`] = `\n<h1>\n  Hello, \n  World\n  !\n</h1>\n`;\n\nexports[`Greeting Component renders correctly and matches snapshot using React Testing Library 1`] = `\n<DocumentFragment>\n  <h1>\n    Hello, \n    Jest\n    !\n  </h1>\n</DocumentFragment>\n`;\n*/",
              "explanation": "This example shows two ways to create a snapshot test for a simple `Greeting` component. The first uses `react-test-renderer`, which is commonly used for pure component snapshots outside of a browser environment. The second demonstrates how React Testing Library's `asFragment()` helper can also be used to create a DOM fragment suitable for snapshotting, ensuring consistency with your RTL tests. The `toMatchSnapshot()` matcher automatically handles the creation and comparison of the snapshot file.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_jest_snapshot_1",
            "question_jest_snapshot_2",
            "question_jest_snapshot_3",
            "question_jest_snapshot_4",
            "question_jest_snapshot_5",
            "question_jest_snapshot_6"
          ],
          "relatedTasks": [
            "task_jest_snapshot_component"
          ],
          "tags": [
            "jest",
            "snapshot-testing",
            "ui-testing",
            "regression-testing",
            "react"
          ],
          "technology": "Jest",
          "prerequisites": [
            "jest_basics",
            "react_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "ui_regression_prevention",
            "component_library_maintenance"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_testing_general_1",
          "topic": "Introduction to React Testing",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of writing tests for React components?",
          "answer": "Ensures reliability, catches bugs early, verifies behavior, and provides confidence for refactoring.",
          "options": [],
          "analysisPoints": [
            "Understanding the fundamental motivation for testing.",
            "Ability to articulate key advantages beyond just 'finding bugs'."
          ],
          "keyConcepts": [
            "software quality",
            "maintainability",
            "bug prevention",
            "refactoring confidence"
          ],
          "evaluationCriteria": [
            "Conceptual understanding",
            "Articulation of benefits"
          ],
          "example": "",
          "tags": [
            "testing",
            "react",
            "fundamentals"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_testing_general_2",
          "topic": "Mocking in Tests",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of 'mocking' in the context of component testing. Why is it important, especially for components that interact with external services?",
          "answer": "Mocking involves replacing real dependencies (like API calls, date functions, or third-party modules) with controlled, simulated versions during tests. It's crucial because:\n1.  **Isolation:** Mocks isolate the component under test from its dependencies, ensuring that the test fails only if there's a bug in the component itself, not in an external service.\n2.  **Predictability:** Mocks allow you to control the exact response of a dependency, making tests deterministic and reproducible, regardless of network conditions or external system states.\n3.  **Speed:** Mocked dependencies run instantly, avoiding the delays associated with real network requests or database queries.\n4.  **Edge Cases:** Mocks enable testing of various scenarios (e.g., successful response, error response, empty data) that might be difficult or impossible to simulate with real services.",
          "options": [],
          "analysisPoints": [
            "Definition of mocking.",
            "Reasons for its importance (isolation, predictability, speed, edge cases).",
            "Practical application in testing."
          ],
          "keyConcepts": [
            "mocking",
            "dependency injection",
            "unit testing",
            "isolation",
            "deterministic tests"
          ],
          "evaluationCriteria": [
            "Clear definition",
            "Comprehensive explanation of benefits",
            "Understanding of test isolation"
          ],
          "example": "",
          "tags": [
            "testing",
            "jest",
            "mocking",
            "api",
            "best-practices"
          ],
          "prerequisites": [
            "javascript_functions",
            "async_programming"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_1",
          "topic": "React Testing Library Philosophy",
          "level": "easy",
          "type": "mcq",
          "question": "What is the core philosophy behind React Testing Library (RTL)?",
          "answer": "The more your tests resemble the way your software is used, the more confidence they can give you.",
          "options": [
            "Focus on testing internal implementation details like component state and methods.",
            "The more your tests resemble the way your software is used, the more confidence they can give you.",
            "Ensure every line of code is covered by a test, regardless of user interaction.",
            "Prioritize speed of test execution over realistic user simulation."
          ],
          "analysisPoints": [
            "Understanding RTL's user-centric approach.",
            "Distinguishing RTL from implementation-detail focused libraries."
          ],
          "keyConcepts": [
            "RTL philosophy",
            "user-centric testing",
            "testing principles"
          ],
          "evaluationCriteria": [
            "Knowledge of RTL's core tenet"
          ],
          "example": "React Testing Library emphasizes interacting with the component's output (the DOM) in the same way a real user would, rather than poking into internal state or methods. This means querying for elements by accessible attributes like role, label, or text content.",
          "tags": [
            "react-testing-library",
            "rtl",
            "testing-philosophy"
          ],
          "prerequisites": [
            "react_testing_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_2",
          "topic": "React Testing Library Queries",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following `screen` queries is generally considered the **most preferred** for finding interactive elements in React Testing Library, due to its alignment with accessibility best practices?",
          "answer": "`getByRole`",
          "options": [
            "`getByTestId`",
            "`getByText`",
            "`getByRole`",
            "`getByClassName`"
          ],
          "analysisPoints": [
            "Knowledge of RTL query priority.",
            "Understanding of accessibility in testing.",
            "Distinguishing best practices from fallback options."
          ],
          "keyConcepts": [
            "RTL queries",
            "accessibility",
            "testing best practices",
            "DOM interaction"
          ],
          "evaluationCriteria": [
            "Understanding of RTL's query hierarchy",
            "Knowledge of accessible testing"
          ],
          "example": "The `getByRole` query is preferred because it mirrors how assistive technologies interact with the page. For example, a screen reader user navigates by roles (button, link, checkbox). Using `getByTestId` is generally a fallback when no other accessible query is suitable, as it ties your test to a specific non-user-facing attribute.",
          "tags": [
            "react-testing-library",
            "rtl",
            "queries",
            "accessibility"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_3",
          "topic": "React Testing Library Async",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following test scenario for an asynchronous component:\n\n```typescript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport UserProfile from './UserProfile';\n\njest.mock('../api', () => ({\n  fetchUserProfile: jest.fn(() =>\n    Promise.resolve({ name: 'Jane Doe', email: 'jane@example.com' })\n  ),\n}));\n\ntest('displays user profile after loading', async () => {\n  render(<UserProfile id={1} />);\n  \n  // A. What should be used here to wait for content?\n  // expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  // B. What should be asserted after content loads?\n});\n```\n\nWhich combination of code snippets correctly fills in `A` and `B` to properly test the asynchronous behavior?",
          "answer": "A: `expect(screen.getByText(/loading/i)).toBeInTheDocument();` B: `await waitFor(() => { expect(screen.getByText('Jane Doe')).toBeInTheDocument(); });`",
          "options": [
            "A: `expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();` B: `expect(screen.getByText('Jane Doe')).toBeInTheDocument();`",
            "A: `expect(screen.getByText(/loading/i)).toBeInTheDocument();` B: `await waitFor(() => { expect(screen.getByText('Jane Doe')).toBeInTheDocument(); });`",
            "A: `await waitFor(() => { expect(screen.getByText(/loading/i)).toBeInTheDocument(); });` B: `expect(screen.getByText('Jane Doe')).toBeInTheDocument();`",
            "A: `expect(screen.getByText('Jane Doe')).toBeInTheDocument();` B: `await waitFor(() => { expect(screen.getByText(/loading/i)).not.toBeInTheDocument(); });`"
          ],
          "analysisPoints": [
            "Understanding of initial loading state assertion.",
            "Correct use of `waitFor` for asynchronous updates.",
            "Knowledge of `getByText` vs `queryByText` for presence/absence.",
            "Order of assertions in async tests."
          ],
          "keyConcepts": [
            "async testing",
            "waitFor",
            "jest.mock",
            "screen.getByText",
            "screen.queryByText",
            "RTL queries"
          ],
          "evaluationCriteria": [
            "Ability to test asynchronous component behavior",
            "Correct use of RTL async utilities"
          ],
          "example": "In asynchronous tests, you first assert the initial state (e.g., 'Loading...'). Then, you use `await waitFor` to pause the test execution until the expected final state (e.g., the loaded data 'Jane Doe') appears in the DOM. `waitFor` repeatedly checks the callback until it no longer throws an error or a timeout occurs. Using `queryByText` for checking absence is also a good practice.",
          "tags": [
            "react-testing-library",
            "rtl",
            "asynchronous",
            "jest",
            "mocking"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "javascript_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_4",
          "topic": "React Testing Library `fireEvent`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `fireEvent` in React Testing Library?",
          "answer": "`fireEvent` is used to simulate user interactions or DOM events (e.g., clicks, input changes, key presses) on elements rendered by a component.",
          "options": [],
          "analysisPoints": [
            "Understanding of `fireEvent`'s role.",
            "Ability to list types of interactions it can simulate."
          ],
          "keyConcepts": [
            "fireEvent",
            "user interaction",
            "DOM events",
            "RTL"
          ],
          "evaluationCriteria": [
            "Knowledge of core RTL utilities"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "events"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_rtl_5",
          "topic": "RTL vs. Enzyme",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast React Testing Library and Enzyme. Discuss their different philosophies and when you might choose one over the other.",
          "answer": "**React Testing Library (RTL):**\n*   **Philosophy:** User-centric. Focuses on testing how users interact with your components (behavioral testing).\n*   **Methodology:** Works with the actual DOM (via JSDOM). Encourages querying elements by accessible attributes (role, label, text) rather than implementation details (component state, internal methods).\n*   **Strengths:** Higher confidence in tests because they resemble real usage, promotes accessibility, less brittle to refactoring internal component logic.\n*   **Weaknesses:** Can be harder to test specific internal state changes or call private methods (by design).\n*   **Use Cases:** Most common for modern React projects, integration tests, and ensuring user flows.\n\n**Enzyme:**\n*   **Philosophy:** Implementation-detail centric. Provides utilities to inspect and manipulate component internals.\n*   **Methodology:** Offers `shallow` rendering (component in isolation, no DOM) and `mount` rendering (full DOM). Provides a jQuery-like API (`find`, `simulate`) to interact with component instances.\n*   **Strengths:** Easy to access and assert on internal component state, props, and methods; convenient for unit testing individual components in isolation.\n*   **Weaknesses:** Tests can become brittle to internal refactoring; less emphasis on accessibility.\n*   **Use Cases:** Common in older React projects, specific unit tests where deep inspection of component internals is truly necessary.\n\n**When to choose:**\n*   **RTL:** For most modern React applications, especially when prioritizing user experience, accessibility, and robust integration tests. It's the recommended choice by the React team.\n*   **Enzyme:** If working with a legacy codebase that already uses Enzyme, or in very specific scenarios where deep inspection of component internals is unavoidable and justified (though often a sign of a testable component design issue).",
          "options": [],
          "analysisPoints": [
            "Ability to articulate the core philosophy of each library.",
            "Understanding their respective strengths and weaknesses.",
            "Providing clear scenarios for when to use each.",
            "Demonstrating knowledge of current industry trends (RTL being preferred)."
          ],
          "keyConcepts": [
            "RTL",
            "Enzyme",
            "user-centric testing",
            "implementation-detail testing",
            "shallow rendering",
            "full DOM rendering",
            "testing philosophy",
            "accessibility"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison",
            "Clear understanding of use cases",
            "Demonstration of expert knowledge"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "enzyme",
            "comparison",
            "testing-philosophy",
            "architecture"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "theory_enzyme"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_6",
          "topic": "RTL Query Methods",
          "level": "medium",
          "type": "mcq",
          "question": "You have a component displaying a list of items:\n\n```typescript\nfunction ItemList({ items }) {\n  return (\n    <div>\n      {items.length > 0 && \n        <ul data-testid=\"item-list\">\n          {items.map(item => <li key={item.id}>{item.name}</li>)}\n        </ul>\n      }\n    </div>\n  );\n}\n```\n\nWhich of the following would be the **most appropriate** way to check if the list itself (the `<ul>` element) is present in the document when `items` array is not empty, following RTL best practices?",
          "answer": "`expect(screen.getByTestId('item-list')).toBeInTheDocument();`",
          "options": [
            "`expect(screen.getByRole('list')).toBeInTheDocument();`",
            "`expect(screen.getByText('List')).toBeInTheDocument();`",
            "`expect(screen.getByTestId('item-list')).toBeInTheDocument();`",
            "`expect(screen.getByTagName('ul')).toBeInTheDocument();`"
          ],
          "analysisPoints": [
            "Understanding of `data-testid` usage as a fallback.",
            "Recognizing that `ul` element might not have a semantic role or accessible text by default for `getByRole` or `getByText` without additional props.",
            "Applying query priority knowledge correctly."
          ],
          "keyConcepts": [
            "RTL queries",
            "getByTestId",
            "getByRole",
            "accessibility vs testability",
            "DOM elements"
          ],
          "evaluationCriteria": [
            "Correct application of RTL query strategy",
            "Understanding of `data-testid` usage"
          ],
          "example": "While `getByRole('list')` might seem appropriate, an `<ul>` element often needs `role='list'` explicitly or a `role='listbox'` for more complex lists to be reliably found by `getByRole`. In this specific snippet, where `data-testid` is explicitly added for testing a non-interactive container element, `getByTestId` is the most direct and reliable way to target it without relying on potentially missing accessible attributes. `getByText('List')` would only work if 'List' was actual text content of the `<ul>` or an element within it.",
          "tags": [
            "react-testing-library",
            "rtl",
            "queries",
            "data-testid"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_7",
          "topic": "RTL `queryBy` vs `getBy` vs `findBy`",
          "level": "hard",
          "type": "open",
          "question": "React Testing Library provides `getBy*`, `queryBy*`, and `findBy*` variants for its queries. Explain the key differences between these variants and when you would use each one.",
          "answer": "**`getBy*`:**\n*   **Purpose:** Used to find an element that is expected to be present in the DOM *synchronously*. If the element is not found, it will throw an error immediately.\n*   **When to use:** For elements that are guaranteed to be in the document when the query is run (e.g., initial render content, static elements).\n*   **Example:** `screen.getByText('Submit Button')`\n\n**`queryBy*`:**\n*   **Purpose:** Used to find an element that may or may not be present in the DOM *synchronously*. If the element is not found, it returns `null` instead of throwing an error.\n*   **When to use:** For asserting the *absence* of an element (e.g., a loading spinner disappears, an error message is not shown) or when an element's presence is conditional and you want to handle both cases without an error.\n*   **Example:** `expect(screen.queryByText('Loading...')).not.toBeInTheDocument()`\n\n**`findBy*`:**\n*   **Purpose:** A combination of `getBy*` and `waitFor`. It returns a Promise that resolves when the element is found in the DOM (polling until found) or rejects if the element is not found within a default timeout (typically 1000ms).\n*   **When to use:** For elements that appear asynchronously (e.g., after an API call, a state update, or an animation completes). It implicitly uses `waitFor`.\n*   **Example:** `await screen.findByText('Loaded Data')`\n\nIn summary: `getBy` for synchronous presence, `queryBy` for synchronous absence, and `findBy` for asynchronous presence.",
          "options": [],
          "analysisPoints": [
            "Clear distinction between synchronous/asynchronous behavior.",
            "Correct use cases for each query type.",
            "Understanding of error handling (`getBy` throws, `queryBy` returns null, `findBy` returns Promise).",
            "Connection between `findBy` and `waitFor`."
          ],
          "keyConcepts": [
            "RTL queries",
            "synchronous testing",
            "asynchronous testing",
            "error handling",
            "waitFor"
          ],
          "evaluationCriteria": [
            "Depth of explanation",
            "Accuracy of usage scenarios",
            "Comprehensive comparison"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "queries",
            "asynchronous",
            "error-handling"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "javascript_promises"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_8",
          "topic": "React Testing Library Test Structure",
          "level": "medium",
          "type": "code",
          "question": "You have a simple `ToggleButton` component that shows 'ON' or 'OFF' and toggles its state on click. Write a React Testing Library test to verify its initial state and that it toggles correctly when clicked.\n\n```typescript\nimport React, { useState } from 'react';\n\nconst ToggleButton = () => {\n  const [isOn, setIsOn] = useState(false);\n\n  return (\n    <button onClick={() => setIsOn(!isOn)}>\n      {isOn ? 'ON' : 'OFF'}\n    </button>\n  );\n};\n\nexport default ToggleButton;\n\n// Your test code here\n```",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly render the component.",
            "Use appropriate `screen` query for the button's text content.",
            "Assert initial state.",
            "Simulate click event using `fireEvent.click`.",
            "Assert updated state after interaction."
          ],
          "keyConcepts": [
            "RTL render",
            "screen queries",
            "fireEvent",
            "assertion"
          ],
          "evaluationCriteria": [
            "Correct test implementation",
            "Adherence to RTL best practices",
            "Handling state changes"
          ],
          "example": "```typescript\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport ToggleButton from './ToggleButton';\n\ntest('ToggleButton toggles state correctly on click', () => {\n  render(<ToggleButton />);\n  \n  // 1. Assert initial state: button should show 'OFF'\n  const toggleButton = screen.getByRole('button', { name: /off/i });\n  expect(toggleButton).toBeInTheDocument();\n  expect(toggleButton).toHaveTextContent('OFF');\n  \n  // 2. Simulate a click event\n  fireEvent.click(toggleButton);\n  \n  // 3. Assert updated state: button should now show 'ON'\n  // Re-querying is important as the text content has changed\n  const toggledButton = screen.getByRole('button', { name: /on/i });\n  expect(toggledButton).toBeInTheDocument();\n  expect(toggledButton).toHaveTextContent('ON');\n\n  // 4. Click again to ensure it toggles back to OFF\n  fireEvent.click(toggledButton);\n  expect(screen.getByRole('button', { name: /off/i })).toBeInTheDocument();\n});\n```",
          "tags": [
            "react-testing-library",
            "rtl",
            "code-challenge",
            "state-management",
            "events"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_9",
          "topic": "RTL Best Practices - `getByTestId`",
          "level": "medium",
          "type": "open",
          "question": "React Testing Library recommends using `getByTestId` as a last resort. Explain why this is the case and provide an example where using `getByTestId` might still be justified.",
          "answer": "Using `getByTestId` is generally discouraged in React Testing Library because it ties your tests to an implementation detail (`data-testid` attribute) that a user doesn't see or interact with. The core philosophy of RTL is to test components the way a user would. A user doesn't know or care about `data-testid` attributes; they interact with buttons, links, text, labels, etc.\n\n**Why it's a 'last resort':**\n*   **Breaks User-Centricity:** It deviates from testing the user experience.\n*   **Brittleness to Refactoring:** If you change the `data-testid` (e.g., during a refactor), the test breaks even if the user experience hasn't changed.\n*   **Promotes Bad Habits:** Encourages adding non-semantic attributes purely for testing, potentially cluttering the DOM.\n\n**When it might be justified:**\n`getByTestId` can be justified for elements that are not directly accessible or visible to the user, but are still critical for testing purposes. Examples include:\n1.  **Internal Debugging Elements:** Components that render complex internal structures, where a specific, non-user-facing node needs to be targeted for internal state verification or complex calculations.\n2.  **Third-Party Components:** When a third-party library's component doesn't expose accessible roles, labels, or text, and you need a reliable way to select a specific part of its rendered output.\n3.  **Complex SVG/Canvas Elements:** Elements where accessible text or roles are difficult to apply or change frequently, but you need a stable hook for testing specific regions or shapes.\n\n**Example:** Testing a hidden `<span>` element that holds a serialized JSON string for internal logging, or a complex chart canvas where individual data points aren't semantically addressable but have a unique `data-testid` for internal testing.",
          "options": [],
          "analysisPoints": [
            "Understanding of RTL philosophy vs. `data-testid`.",
            "Clear explanation of disadvantages.",
            "Providing valid, nuanced exceptions where it's acceptable.",
            "Demonstrating critical thinking beyond simply stating rules."
          ],
          "keyConcepts": [
            "RTL best practices",
            "data-testid",
            "accessibility",
            "implementation details",
            "user-centric testing",
            "refactoring"
          ],
          "evaluationCriteria": [
            "Depth of reasoning",
            "Quality of examples",
            "Nuanced understanding of testing trade-offs"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "best-practices",
            "testing-strategy",
            "data-testid"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_10",
          "topic": "RTL Debugging",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the purpose of `screen.debug()` in React Testing Library?",
          "answer": "`screen.debug()` prints the current state of the rendered DOM to the console. It's useful for debugging tests, understanding what your component actually rendered, and verifying that queries are targeting the correct elements.",
          "options": [],
          "analysisPoints": [
            "Knowledge of RTL debugging tools.",
            "Understanding of how it helps in test development."
          ],
          "keyConcepts": [
            "RTL debugging",
            "screen.debug()",
            "DOM inspection"
          ],
          "evaluationCriteria": [
            "Knowledge of RTL utilities"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "debugging"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_11",
          "topic": "RTL `waitFor` vs `findBy`",
          "level": "hard",
          "type": "flashcard",
          "question": "When would you explicitly use `waitFor` instead of a `findBy*` query for asynchronous assertions in RTL?",
          "answer": "You would use `waitFor` when your assertion is not about the presence of an element, but rather about a non-DOM side effect, a change in an element's attribute, or when you need to assert that something *disappears* asynchronously. `findBy*` queries are specifically for *finding* an element that appears asynchronously. For example, `waitFor` is used to check if a mock function was called after an async operation, or if an element's class name changed, or if an element is removed from the DOM (`expect(queryByText(...)).not.toBeInTheDocument()`).",
          "options": [],
          "analysisPoints": [
            "Understanding the specific use cases for `waitFor`.",
            "Distinguishing between asserting element presence and other asynchronous changes.",
            "Knowledge of when `findBy*` is insufficient."
          ],
          "keyConcepts": [
            "waitFor",
            "findBy",
            "asynchronous testing",
            "RTL queries",
            "side effects"
          ],
          "evaluationCriteria": [
            "Nuanced understanding of async utilities",
            "Ability to differentiate specific use cases"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "asynchronous-testing"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_12",
          "topic": "RTL Role of `jest-dom`",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the role of `@testing-library/jest-dom/extend-expect` in a React Testing Library setup?",
          "answer": "It extends Jest's `expect` matchers with custom DOM-specific matchers from `@testing-library/jest-dom`. This provides more readable and semantically meaningful assertions for DOM elements, such as `toBeInTheDocument()`, `toHaveTextContent()`, `toBeVisible()`, `toBeDisabled()`, etc., making tests more expressive and easier to understand.",
          "options": [],
          "analysisPoints": [
            "Understanding the functionality of `jest-dom`.",
            "Knowledge of specific matchers it provides."
          ],
          "keyConcepts": [
            "jest-dom",
            "jest matchers",
            "RTL setup",
            "assertion"
          ],
          "evaluationCriteria": [
            "Knowledge of test environment setup",
            "Understanding of assertion libraries"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "jest",
            "setup"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_1",
          "topic": "Enzyme Rendering Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Which Enzyme rendering method would you use to test a component in isolation, without rendering its child components into a full DOM tree?",
          "answer": "`shallow`",
          "options": [
            "`mount`",
            "`render`",
            "`shallow`",
            "`static`"
          ],
          "analysisPoints": [
            "Understanding the purpose of `shallow` rendering.",
            "Distinguishing it from `mount` and `render`.",
            "Knowledge of isolation in unit testing."
          ],
          "keyConcepts": [
            "Enzyme",
            "shallow rendering",
            "unit testing",
            "component isolation"
          ],
          "evaluationCriteria": [
            "Knowledge of Enzyme's core utilities"
          ],
          "example": "```typescript\nimport { shallow } from 'enzyme';\nimport MyParentComponent from './MyParentComponent';\nimport MyChildComponent from './MyChildComponent';\n\ndescribe('MyParentComponent', () => {\n  it('renders MyChildComponent correctly', () => {\n    const wrapper = shallow(<MyParentComponent />);\n    // When using shallow, MyChildComponent is not fully rendered, only its JSX reference is present.\n    expect(wrapper.find(MyChildComponent)).toHaveLength(1);\n    // You cannot find elements *inside* MyChildComponent using shallow rendering of MyParentComponent.\n  });\n});\n```\nThis example shows that `shallow` allows you to assert that `MyParentComponent` renders `MyChildComponent`, but it doesn't delve into `MyChildComponent`'s own internal DOM structure, ensuring the test focuses solely on the parent.",
          "tags": [
            "enzyme",
            "shallow-rendering",
            "react-testing"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_2",
          "topic": "Enzyme DOM Interaction",
          "level": "medium",
          "type": "mcq",
          "question": "You need to test a React component's lifecycle methods, direct DOM interactions (like focus or scroll), or how it interacts with its child components in a realistic browser-like environment. Which Enzyme rendering method is most suitable for this scenario?",
          "answer": "`mount`",
          "options": [
            "`shallow`",
            "`mount`",
            "`render`",
            "`staticRender`"
          ],
          "analysisPoints": [
            "Understanding the capabilities of `mount` rendering.",
            "Recognition of scenarios requiring a full DOM.",
            "Comparison with other Enzyme methods."
          ],
          "keyConcepts": [
            "Enzyme",
            "mount rendering",
            "full DOM",
            "integration testing",
            "lifecycle methods",
            "DOM interaction"
          ],
          "evaluationCriteria": [
            "Knowledge of Enzyme's core utilities",
            "Understanding of full DOM rendering use cases"
          ],
          "example": "```typescript\nimport { mount } from 'enzyme';\nimport UserForm from './UserForm';\n\ndescribe('UserForm', () => {\n  it('updates state on input change and submits', () => {\n    const wrapper = mount(<UserForm />);\n    const nameInput = wrapper.find('input[name=\"name\"]');\n    \n    nameInput.simulate('change', { target: { value: 'John Doe' } });\n    \n    // With mount, you can access the component's state directly\n    expect(wrapper.state('name')).toEqual('John Doe');\n    \n    wrapper.find('form').simulate('submit');\n    // Assertions on onSubmit handler or further state changes\n  });\n});\n```\n`mount` creates a full DOM environment, allowing you to simulate complex interactions, access component instances, and verify lifecycle behavior, making it suitable for integration-style tests.",
          "tags": [
            "enzyme",
            "mount-rendering",
            "react-testing",
            "integration-testing"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_3",
          "topic": "Enzyme Assertion",
          "level": "easy",
          "type": "flashcard",
          "question": "How would you simulate a click event on a button with the class `submit-btn` using an Enzyme `wrapper`?",
          "answer": "`wrapper.find('.submit-btn').simulate('click');`",
          "options": [],
          "analysisPoints": [
            "Knowledge of Enzyme's `find` and `simulate` methods.",
            "Correct syntax for targeting elements by class and simulating events."
          ],
          "keyConcepts": [
            "Enzyme API",
            "simulate",
            "find",
            "event simulation"
          ],
          "evaluationCriteria": [
            "Practical application of Enzyme methods"
          ],
          "example": "",
          "tags": [
            "enzyme",
            "events",
            "simulation"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_4",
          "topic": "Enzyme vs. RTL Philosophy",
          "level": "medium",
          "type": "open",
          "question": "Enzyme allows direct access to a component's internal state and props via methods like `wrapper.state()` and `wrapper.props()`. How does this align (or conflict) with the modern testing philosophy promoted by React Testing Library, and what are the implications?",
          "answer": "Enzyme's ability to directly access and manipulate a component's internal state and props via `wrapper.state()` and `wrapper.props()` conflicts with the modern testing philosophy promoted by React Testing Library. \n\n**Conflict:**\n*   **Implementation Details vs. User Behavior:** RTL advocates for testing components from the user's perspective, interacting with the rendered output (the DOM) rather than internal implementation details. Directly accessing state and props violates this principle by focusing on *how* a component works internally, not just *what* it renders or *how* it behaves from a user's viewpoint.\n*   **Brittleness:** Tests that rely on internal state are brittle. If you refactor a component to use a different state management pattern (e.g., move from `useState` to `useReducer`, or change state variable names), these tests will break even if the component's external behavior (what the user sees and interacts with) remains unchanged.\n\n**Implications:**\n*   **Test Maintenance:** Tests written with Enzyme's internal access methods often require more frequent updates as component internals evolve, leading to higher maintenance overhead.\n*   **Less Confidence:** Such tests provide less confidence that the component works for a real user, as they don't simulate actual user interaction paths.\n*   **Accessibility:** Less emphasis on accessible querying means tests might not naturally promote accessible component design.\n\nWhile direct access can be convenient for unit-testing isolated logic, it shifts the focus away from the component's public interface and user experience, which is the primary concern for frontend testing.",
          "options": [],
          "analysisPoints": [
            "Clearly articulate the conflict with RTL's philosophy.",
            "Explain the negative implications (brittleness, maintenance, confidence).",
            "Contrast internal vs. external behavior testing."
          ],
          "keyConcepts": [
            "Enzyme",
            "RTL",
            "testing philosophy",
            "internal state",
            "props",
            "brittleness",
            "user experience"
          ],
          "evaluationCriteria": [
            "Depth of understanding of testing principles",
            "Ability to analyze implications",
            "Clear articulation of differences"
          ],
          "example": "",
          "tags": [
            "enzyme",
            "react-testing-library",
            "testing-philosophy",
            "best-practices"
          ],
          "prerequisites": [
            "theory_enzyme",
            "theory_react_testing_library"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_enzyme_5",
          "topic": "Enzyme `render` method",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary use case for Enzyme's `render` method, and how does it differ from `shallow` and `mount`?",
          "answer": "Enzyme's `render` method renders React components to static HTML strings using Cheerio, which is a lightweight implementation of jQuery for the server. Its primary use case is to inspect the static HTML output of a component, especially for snapshot testing or for analyzing the full rendered tree of a component hierarchy without the overhead of a full DOM environment or component lifecycle methods. Unlike `shallow` (which doesn't render children fully) and `mount` (which renders to a full DOM with lifecycle), `render` provides a complete, static HTML representation.",
          "options": [],
          "analysisPoints": [
            "Understanding of `render`'s output type (static HTML).",
            "Key differences from `shallow` and `mount` (no lifecycle, no full DOM).",
            "Specific use cases like snapshot testing."
          ],
          "keyConcepts": [
            "Enzyme",
            "render",
            "static HTML",
            "snapshot testing",
            "Cheerio"
          ],
          "evaluationCriteria": [
            "Knowledge of Enzyme's rendering options",
            "Understanding of their specific contexts"
          ],
          "example": "",
          "tags": [
            "enzyme",
            "rendering",
            "static-html",
            "snapshot-testing"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_6",
          "topic": "Enzyme Finders",
          "level": "medium",
          "type": "code",
          "question": "You have a component with a nested structure. Using Enzyme's `mount` method, how would you find a `<span>` element with the text 'Total:' inside a `<div>` with the class `summary-box`?\n\n```typescript\nimport React from 'react';\n\nconst Summary = ({ total }) => (\n  <div className=\"summary-box\">\n    <p>Report Summary</p>\n    <span>Total:</span>\n    <span className=\"total-value\">${total}</span>\n    <button>View Details</button>\n  </div>\n);\n\nexport default Summary;\n\n// Your test code here\n```",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correct use of `wrapper.find()` with CSS selectors.",
            "Ability to combine selectors for nested elements.",
            "Asserting text content."
          ],
          "keyConcepts": [
            "Enzyme find",
            "CSS selectors",
            "nested elements",
            "mount"
          ],
          "evaluationCriteria": [
            "Practical application of Enzyme selectors",
            "Accuracy of code snippet"
          ],
          "example": "```typescript\nimport { mount } from 'enzyme';\nimport Summary from './Summary';\n\ndescribe('Summary Component', () => {\n  it('displays the total correctly', () => {\n    const wrapper = mount(<Summary total={100} />);\n    \n    // Find the <span> element with 'Total:' text using a CSS selector for its parent.\n    const totalLabelSpan = wrapper.find('.summary-box span').at(0); // or filter by text\n    \n    // A more robust way to find by text if it's unique enough:\n    const totalLabelSpanByText = wrapper.find('span').filterWhere(n => n.text() === 'Total:');\n\n    expect(totalLabelSpan.text()).toEqual('Total:');\n    expect(totalLabelSpanByText).toHaveLength(1);\n\n    // You could also find the specific text node:\n    expect(wrapper.find('.summary-box').text()).toContain('Total:');\n  });\n});\n```",
          "tags": [
            "enzyme",
            "code-challenge",
            "selectors",
            "find"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_7",
          "topic": "Enzyme vs. RTL Ecosystem",
          "level": "hard",
          "type": "flashcard",
          "question": "Beyond their philosophical differences, what is a practical reason why React Testing Library has gained more traction and is often recommended over Enzyme for new React projects?",
          "answer": "A significant practical reason is that React Testing Library is actively maintained and evolves alongside React's development, particularly with Hooks. Enzyme, while once dominant, has seen slower updates and less active development, leading to compatibility issues with newer React features (like `act` for Hooks testing, or specific React 18 behaviors) and a smaller, less responsive community for newer issues. RTL's emphasis on DOM-based testing also means it's less affected by internal React rendering engine changes than Enzyme's component instance manipulation.",
          "options": [],
          "analysisPoints": [
            "Understanding of library maintenance and community support.",
            "Knowledge of compatibility with modern React features (Hooks, React 18).",
            "Recognition of the impact of internal React changes."
          ],
          "keyConcepts": [
            "RTL vs Enzyme",
            "maintenance",
            "community support",
            "React Hooks",
            "compatibility"
          ],
          "evaluationCriteria": [
            "Knowledge of the broader testing ecosystem",
            "Understanding of practical development concerns"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "enzyme",
            "ecosystem",
            "trends"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "theory_enzyme"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_jest_snapshot_1",
          "topic": "Jest Snapshot Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of Jest snapshot testing?",
          "answer": "To ensure your UI doesn't change unexpectedly over time.",
          "options": [
            "To verify component internal state mutations.",
            "To ensure your UI doesn't change unexpectedly over time.",
            "To test complex user interaction flows asynchronously.",
            "To measure component rendering performance."
          ],
          "analysisPoints": [
            "Understanding the core goal of snapshot testing (regression detection).",
            "Distinguishing it from other types of tests."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "regression testing",
            "UI testing"
          ],
          "evaluationCriteria": [
            "Knowledge of snapshot testing concept"
          ],
          "example": "Jest snapshot tests create a stored 'snapshot' of a component's rendered output (or any serializable data). In subsequent test runs, it compares the current output to the saved snapshot. If there's a difference, the test fails, alerting you to a potential unintended change in your UI.",
          "tags": [
            "jest",
            "snapshot-testing",
            "ui-testing"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jest_snapshot_2",
          "topic": "Jest Snapshot Workflow",
          "level": "medium",
          "type": "flashcard",
          "question": "How do you update a failing Jest snapshot if the change in the UI was intentional?",
          "answer": "You can update a failing Jest snapshot by running Jest with the `-u` flag (e.g., `jest -u` or `npm test -- -u`). This will overwrite the old snapshot file with the new, desired output.",
          "options": [],
          "analysisPoints": [
            "Knowledge of the command to update snapshots.",
            "Understanding when to update (intentional changes)."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "updating snapshots",
            "jest -u"
          ],
          "evaluationCriteria": [
            "Practical knowledge of Jest commands"
          ],
          "example": "",
          "tags": [
            "jest",
            "snapshot-testing",
            "workflow"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jest_snapshot_3",
          "topic": "Jest Snapshot Pros and Cons",
          "level": "medium",
          "type": "open",
          "question": "Discuss the advantages and disadvantages of using Jest snapshot testing. When might it be a good choice, and when should you be cautious?",
          "answer": "**Advantages:**\n1.  **Quick Regression Detection:** Automatically catches unexpected UI changes or data structure regressions with minimal effort.\n2.  **Ease of Use:** Simple to set up and write basic snapshot tests.\n3.  **Comprehensive Coverage:** Can cover large parts of the UI with relatively few lines of test code.\n4.  **Documentation:** Snapshots serve as a form of documentation for the rendered output of components.\n\n**Disadvantages/Cautions:**\n1.  **Brittleness:** Snapshots can be brittle. Even intentional UI changes (e.g., a simple text update, a new prop) will cause tests to fail, requiring manual review and updates (`jest -u`). This can lead to 'false positives' and 'blindly updating' snapshots without proper review.\n2.  **Not a Functional Test:** Snapshots only verify the rendered structure, not the behavior or functionality. They don't test user interactions, data fetching, or complex logic. They should complement, not replace, behavioral tests.\n3.  **Readability/Review:** Large snapshots can be difficult to review in pull requests, making it hard to identify significant changes from minor ones.\n4.  **Over-reliance:** Over-reliance can lead to a false sense of security, as tests pass based on structure, not actual user experience.\n\n**When to use:**\n*   **Presentational Components:** Ideal for simple, 'dumb' components that primarily render UI based on props, with little to no internal state or complex logic.\n*   **Data Structures:** To ensure complex objects or API responses maintain a consistent structure.\n*   **Regression Guard:** As a quick guard against unintended structural changes, especially in areas of the UI that are not frequently interacted with or have minimal dynamic behavior.\n\n**When to be cautious:**\n*   **Highly Dynamic Components:** Components with frequent changes, animations, or dynamic content that makes snapshots constantly change.\n*   **Business Logic:** Never use snapshots as the sole test for critical business logic or user flows; functional tests are required for these.\n*   **Large Snapshots:** Be wary of excessively large snapshots that are hard to review.",
          "options": [],
          "analysisPoints": [
            "Comprehensive list of pros and cons.",
            "Clear distinction between structural and functional testing.",
            "Understanding of when snapshots are appropriate and when they are not.",
            "Mention of brittleness and maintenance overhead."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "advantages",
            "disadvantages",
            "regression testing",
            "functional testing",
            "brittleness"
          ],
          "evaluationCriteria": [
            "Balanced perspective",
            "Practical advice",
            "Depth of analysis"
          ],
          "example": "",
          "tags": [
            "jest",
            "snapshot-testing",
            "best-practices",
            "testing-strategy"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_jest_snapshot_4",
          "topic": "Jest Snapshot vs. RTL",
          "level": "hard",
          "type": "open",
          "question": "Can Jest snapshot tests replace behavioral tests written with React Testing Library? Explain your reasoning.",
          "answer": "No, Jest snapshot tests cannot fully replace behavioral tests written with React Testing Library. While both are valuable tools in a testing strategy, they serve different purposes and provide different levels of confidence:\n\n*   **Jest Snapshots:** Primarily focus on **structural regression**. They capture the rendered output (HTML or a data structure) at a specific point in time and compare it against future renders. They tell you *what* the component looks like (its structure) but not *how* it behaves or *how* a user interacts with it.\n\n*   **React Testing Library (RTL):** Focuses on **behavioral testing** from a user's perspective. It enables you to simulate real user interactions (clicks, typing, form submissions) and assert that the component responds correctly in the DOM. RTL tests give confidence that the application works for a real user.\n\n**Reasoning:**\nAn application can render correctly (pass a snapshot test) but still be broken from a user's perspective. For example:\n*   A button might *look* like a button in the snapshot, but if its `onClick` handler is broken, a behavioral test simulating a click will fail, while a snapshot test might still pass.\n*   A form might have all its inputs present in the snapshot, but if the submission logic fails or the form doesn't display validation errors correctly after submission, a behavioral test will catch this, whereas a snapshot won't.\n\nTherefore, snapshots are a good complement to behavioral tests, providing a quick check for unintended UI changes, but they are not a substitute for verifying actual user flows and interactions.",
          "options": [],
          "analysisPoints": [
            "Clear distinction between structural and behavioral testing.",
            "Understanding the different types of confidence each provides.",
            "Providing concrete examples of why one cannot replace the other."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "RTL",
            "behavioral testing",
            "structural testing",
            "regression testing",
            "complementary testing"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison",
            "Clear logical reasoning",
            "Understanding of different testing levels"
          ],
          "example": "",
          "tags": [
            "jest",
            "snapshot-testing",
            "react-testing-library",
            "testing-strategy",
            "comparison"
          ],
          "prerequisites": [
            "theory_jest_snapshots",
            "theory_react_testing_library"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_jest_snapshot_5",
          "topic": "Jest Snapshot Configuration",
          "level": "medium",
          "type": "flashcard",
          "question": "Which Jest matcher is used to create and compare snapshots?",
          "answer": "`toMatchSnapshot()`",
          "options": [],
          "analysisPoints": [
            "Knowledge of the specific Jest matcher for snapshots.",
            "Understanding its role in the snapshot testing process."
          ],
          "keyConcepts": [
            "Jest matchers",
            "toMatchSnapshot",
            "snapshot testing"
          ],
          "evaluationCriteria": [
            "Knowledge of Jest API"
          ],
          "example": "",
          "tags": [
            "jest",
            "snapshot-testing",
            "matchers"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_jest_snapshot_6",
          "topic": "Jest Snapshot `react-test-renderer`",
          "level": "medium",
          "type": "code",
          "question": "Write a Jest snapshot test for a simple functional component called `WelcomeMessage` that receives a `username` prop and displays 'Welcome, [username]!'. Use `react-test-renderer`.\n\n```typescript\nimport React from 'react';\n\nconst WelcomeMessage = ({ username }) => (\n  <h1>Welcome, {username}!</h1>\n);\n\nexport default WelcomeMessage;\n\n// Your test code here\n```",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correct import of `react-test-renderer`.",
            "Using `renderer.create()` to render the component.",
            "Calling `.toJSON()` on the renderer output.",
            "Applying `toMatchSnapshot()` matcher."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "react-test-renderer",
            "toMatchSnapshot",
            "code-challenge"
          ],
          "evaluationCriteria": [
            "Correct implementation of snapshot test",
            "Adherence to `react-test-renderer` usage"
          ],
          "example": "```typescript\nimport React from 'react';\nimport renderer from 'react-test-renderer';\nimport WelcomeMessage from './WelcomeMessage';\n\ndescribe('WelcomeMessage Component', () => {\n  it('renders correctly and matches snapshot', () => {\n    // Create a Jest renderer tree of the WelcomeMessage component\n    const tree = renderer.create(<WelcomeMessage username=\"Alice\" />).toJSON();\n    \n    // Expect the tree to match the saved snapshot\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders with different username and matches snapshot', () => {\n    const tree = renderer.create(<WelcomeMessage username=\"Bob\" />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n\n/* Example .snap file content (for the first test):\n\nexports[`WelcomeMessage Component renders correctly and matches snapshot 1`] = `\n<h1>\n  Welcome, \n  Alice\n  !\n</h1>\n`;\n\nexports[`WelcomeMessage Component renders with different username and matches snapshot 1`] = `\n<h1>\n  Welcome, \n  Bob\n  !\n</h1>\n`;\n\n*/\n```",
          "tags": [
            "jest",
            "snapshot-testing",
            "react-test-renderer",
            "code-challenge"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_rtl_form_validation",
          "title": "Implement and Test a Simple User Registration Form with RTL",
          "description": "\nImplement a `RegistrationForm` component that includes a 'Username' input, 'Password' input, and a 'Submit' button. The form should have basic client-side validation:\n\n1.  Username: Must be at least 3 characters long.\n2.  Password: Must be at least 6 characters long.\n\nYour task is to:\n-   Create the `RegistrationForm` component.\n-   Write a test suite using React Testing Library to cover the following scenarios:\n    -   Initial render: Ensure inputs and button are present and button is initially disabled.\n    -   Invalid input: Typing short username/password should keep the button disabled and display an error message for each field when inputs are touched/blurred.\n    -   Valid input: Typing valid username/password should enable the button and hide error messages.\n    -   Form submission: Submitting a valid form should call a mock `onSubmit` handler with the correct data.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// RegistrationForm.tsx\nconst RegistrationForm = ({ onSubmit }) => {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [usernameError, setUsernameError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n\n  const validateUsername = (value) => {\n    if (value.length < 3) {\n      setUsernameError('Username must be at least 3 characters.');\n      return false;\n    } else {\n      setUsernameError('');\n      return true;\n    }\n  };\n\n  const validatePassword = (value) => {\n    if (value.length < 6) {\n      setPasswordError('Password must be at least 6 characters.');\n      return false;\n    } else {\n      setPasswordError('');\n      return true;\n    }\n  };\n\n  const isFormValid = username.length >= 3 && password.length >= 6;\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (isFormValid) {\n      onSubmit({ username, password });\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username-input\">Username:</label>\n        <input\n          id=\"username-input\"\n          type=\"text\"\n          value={username}\n          onChange={(e) => {\n            setUsername(e.target.value);\n            validateUsername(e.target.value);\n          }}\n          onBlur={() => validateUsername(username)} // Validate on blur too\n        />\n        {usernameError && <div data-testid=\"username-error\" style={{ color: 'red' }}>{usernameError}</div>}\n      </div>\n      <div>\n        <label htmlFor=\"password-input\">Password:</label>\n        <input\n          id=\"password-input\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => {\n            setPassword(e.target.value);\n            validatePassword(e.target.value);\n          }}\n          onBlur={() => validatePassword(password)} // Validate on blur too\n        />\n        {passwordError && <div data-testid=\"password-error\" style={{ color: 'red' }}>{passwordError}</div>}\n      </div>\n      <button type=\"submit\" disabled={!isFormValid}>Register</button>\n    </form>\n  );\n};\n\nexport default RegistrationForm;\n\n// RegistrationForm.test.tsx\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport RegistrationForm from './RegistrationForm';\n\ndescribe('RegistrationForm', () => {\n  const mockOnSubmit = jest.fn();\n\n  beforeEach(() => {\n    mockOnSubmit.mockClear();\n  });\n\n  // TODO: Implement test cases\n});\n",
          "solutionCode": "import React, { useState } from 'react';\n\nconst RegistrationForm = ({ onSubmit }) => {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [usernameError, setUsernameError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n\n  const validateUsername = (value) => {\n    if (value.length < 3) {\n      setUsernameError('Username must be at least 3 characters.');\n      return false;\n    } else {\n      setUsernameError('');\n      return true;\n    }\n  };\n\n  const validatePassword = (value) => {\n    if (value.length < 6) {\n      setPasswordError('Password must be at least 6 characters.');\n      return false;\n    } else {\n      setPasswordError('');\n      return true;\n    }\n  };\n\n  const isFormValid = username.length >= 3 && password.length >= 6;\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (isFormValid) {\n      onSubmit({ username, password });\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username-input\">Username:</label>\n        <input\n          id=\"username-input\"\n          type=\"text\"\n          value={username}\n          onChange={(e) => {\n            setUsername(e.target.value);\n            // Validate immediately on change for responsiveness, but also on blur for final check\n            validateUsername(e.target.value); \n          }}\n          onBlur={() => validateUsername(username)} \n        />\n        {usernameError && <div data-testid=\"username-error\" style={{ color: 'red' }}>{usernameError}</div>}\n      </div>\n      <div>\n        <label htmlFor=\"password-input\">Password:</label>\n        <input\n          id=\"password-input\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => {\n            setPassword(e.target.value);\n            // Validate immediately on change for responsiveness, but also on blur for final check\n            validatePassword(e.target.value); \n          }}\n          onBlur={() => validatePassword(password)} \n        />\n        {passwordError && <div data-testid=\"password-error\" style={{ color: 'red' }}>{passwordError}</div>}\n      </div>\n      <button type=\"submit\" disabled={!isFormValid}>Register</button>\n    </form>\n  );\n};\n\nexport default RegistrationForm;\n\n// RegistrationForm.test.tsx\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport RegistrationForm from './RegistrationForm';\n\ndescribe('RegistrationForm', () => {\n  const mockOnSubmit = jest.fn();\n\n  beforeEach(() => {\n    mockOnSubmit.mockClear();\n  });\n\n  it('renders with initial empty fields and disabled button', () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    expect(screen.getByLabelText(/username/i)).toHaveValue('');\n    expect(screen.getByLabelText(/password/i)).toHaveValue('');\n    expect(screen.getByRole('button', { name: /register/i })).toBeDisabled();\n    expect(screen.queryByTestId('username-error')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('password-error')).not.toBeInTheDocument();\n  });\n\n  it('shows error messages for invalid username on blur', async () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const usernameInput = screen.getByLabelText(/username/i);\n    fireEvent.change(usernameInput, { target: { value: 'ab' } }); // Less than 3 chars\n    fireEvent.blur(usernameInput);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('username-error')).toHaveTextContent('Username must be at least 3 characters.');\n    });\n    expect(screen.getByRole('button', { name: /register/i })).toBeDisabled();\n  });\n\n  it('shows error messages for invalid password on blur', async () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const passwordInput = screen.getByLabelText(/password/i);\n    fireEvent.change(passwordInput, { target: { value: '123' } }); // Less than 6 chars\n    fireEvent.blur(passwordInput);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('password-error')).toHaveTextContent('Password must be at least 6 characters.');\n    });\n    expect(screen.getByRole('button', { name: /register/i })).toBeDisabled();\n  });\n\n  it('enables button and hides errors with valid inputs', async () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const usernameInput = screen.getByLabelText(/username/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n\n    fireEvent.change(usernameInput, { target: { value: 'validuser' } });\n    fireEvent.change(passwordInput, { target: { value: 'validpass' } });\n    \n    // Trigger blur to ensure errors are gone if they were previously shown\n    fireEvent.blur(usernameInput);\n    fireEvent.blur(passwordInput);\n\n    await waitFor(() => {\n      expect(screen.getByRole('button', { name: /register/i })).toBeEnabled();\n    });\n    expect(screen.queryByTestId('username-error')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('password-error')).not.toBeInTheDocument();\n  });\n\n  it('calls onSubmit with correct data on valid submission', async () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const usernameInput = screen.getByLabelText(/username/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n    const registerButton = screen.getByRole('button', { name: /register/i });\n\n    fireEvent.change(usernameInput, { target: { value: 'testuser' } });\n    fireEvent.change(passwordInput, { target: { value: 'testpassword' } });\n\n    // Ensure button is enabled before clicking\n    await waitFor(() => { expect(registerButton).toBeEnabled(); });\n    \n    fireEvent.click(registerButton);\n\n    expect(mockOnSubmit).toHaveBeenCalledTimes(1);\n    expect(mockOnSubmit).toHaveBeenCalledWith({ username: 'testuser', password: 'testpassword' });\n  });\n\n  it('does not call onSubmit on invalid submission', () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const usernameInput = screen.getByLabelText(/username/i);\n    const registerButton = screen.getByRole('button', { name: /register/i });\n\n    fireEvent.change(usernameInput, { target: { value: 'sh' } }); // Invalid username\n    expect(registerButton).toBeDisabled(); // Should remain disabled\n    fireEvent.click(registerButton);\n\n    expect(mockOnSubmit).not.toHaveBeenCalled();\n  });\n});\n",
          "testCases": [
            "Initial render: inputs are empty, button disabled, no errors shown.",
            "Invalid username (less than 3 chars): typing and blurring shows error, button remains disabled.",
            "Invalid password (less than 6 chars): typing and blurring shows error, button remains disabled.",
            "Valid username but invalid password: button disabled, both errors shown on blur.",
            "Valid password but invalid username: button disabled, both errors shown on blur.",
            "Both valid: button enabled, no errors shown.",
            "Submit valid form: onSubmit handler is called with correct data.",
            "Submit invalid form: onSubmit handler is NOT called."
          ],
          "hints": [
            "Use `screen.getByLabelText` to select form inputs.",
            "Use `fireEvent.change` to simulate typing into inputs.",
            "Use `fireEvent.blur` to trigger validation on blur.",
            "Use `expect(element).toBeDisabled()` and `toBeEnabled()` for button state.",
            "Use `expect(mockFunction).toHaveBeenCalledWith()` to verify form submission data.",
            "Remember to use `await waitFor` for checking error messages that appear after user interaction and state updates."
          ],
          "tags": [
            "react",
            "form",
            "validation",
            "react-testing-library",
            "rtl",
            "jest",
            "unit-testing"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_react_testing_library",
            "react_forms",
            "jest_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "form_handling",
            "state_management",
            "event_handling",
            "client_side_validation"
          ]
        },
        {
          "id": "task_rtl_async_component",
          "title": "Test an Asynchronous Data Fetching Component with RTL",
          "description": "\nCreate a `UserList` component that fetches a list of users from a simulated API call and displays them. During the loading process, it should show a 'Loading...' message, and if there's an error, it should display an 'Error: ...' message. Otherwise, it should display a list of user names.\n\nYour task is to:\n-   Implement the `UserList` component using `useState` and `useEffect`.\n-   Create a mock API function (`fetchUsers`) that simulates successful data fetching and also a scenario for API errors.\n-   Write a test suite using React Testing Library to cover:\n    -   Initial loading state.\n    -   Successful data fetching and displaying the list of users.\n    -   Error handling: Displaying an error message if the API call fails.\n    -   No users found state (e.g., if API returns an empty array).\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Simulate API call (e.g., in api.js or in the test file)\nconst fetchUsers = async (shouldFail = false) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldFail) {\n        reject(new Error('Failed to fetch users.'));\n      } else {\n        resolve([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);\n      }\n    }, 100);\n  });\n};\n\n// UserList.tsx\nconst UserList = () => {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadUsers = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        const data = await fetchUsers(); // This will be mocked in tests\n        setUsers(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    loadUsers();\n  }, []);\n\n  if (loading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div data-testid=\"error-message\">Error: {error}</div>;\n  }\n\n  if (users.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => <li key={user.id}>{user.name}</li>)}\n      </ul>\n    </div>\n  );\n};\n\nexport default UserList;\n\n// UserList.test.tsx\nimport { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport UserList from './UserList';\n\n// Mock the fetchUsers API call globally or locally for tests\njest.mock('./UserList', () => ({\n  __esModule: true, // This is important for default exports\n  default: jest.fn(() => {\n    // Here you can control the mock behavior\n    return 'Mocked UserList'; // Placeholder, replace with actual component for testing\n  }),\n}));\n\ndescribe('UserList', () => {\n  // TODO: Implement test cases\n});\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// Simulate API call (e.g., in api.js or in the test file)\nconst fetchUsers = async (shouldFail = false, emptyResult = false) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldFail) {\n        reject(new Error('Failed to fetch users.'));\n      } else if (emptyResult) {\n        resolve([]);\n      } else {\n        resolve([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);\n      }\n    }, 100);\n  });\n};\n\n// UserList.tsx\nconst UserList = () => {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadUsers = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        // IMPORTANT: Use the actual fetchUsers function if it's imported correctly\n        // The test will mock this specific import path\n        const data = await fetchUsers(); \n        setUsers(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    loadUsers();\n  }, []);\n\n  if (loading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div data-testid=\"error-message\">Error: {error}</div>;\n  }\n\n  if (users.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => <li key={user.id}>{user.name}</li>)}\n      </ul>\n    </div>\n  );\n};\n\nexport default UserList;\n\n// UserList.test.tsx\nimport { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport UserList from './UserList';\n\n// Mock the specific `fetchUsers` function that UserList imports\n// We need to mock it in the context of the component under test.\n// The best way is to put fetchUsers in a separate file (e.g. api.ts) and mock that file.\n// For simplicity within a single file example, we can mock the module directly.\n\njest.mock('./UserList', () => {\n  // Get the actual module so we can mock specific functions within it\n  const originalModule = jest.requireActual('./UserList');\n  return {\n    __esModule: true,\n    ...originalModule,\n    fetchUsers: jest.fn(), // Mock the fetchUsers function imported by UserList\n  };\n});\n\n// If fetchUsers was in a separate file like `api.ts`:\n// import { fetchUsers } from '../api';\n// jest.mock('../api');\n\ndescribe('UserList', () => {\n  // Access the mocked function directly after mocking the module\n  const mockFetchUsers = require('./UserList').fetchUsers; // Adjust path if fetchUsers is elsewhere\n\n  beforeEach(() => {\n    mockFetchUsers.mockClear();\n  });\n\n  it('displays loading message initially', () => {\n    mockFetchUsers.mockReturnValueOnce(new Promise(() => {})); // Never resolve to keep loading\n    render(<UserList />);\n    expect(screen.getByText(/loading users/i)).toBeInTheDocument();\n  });\n\n  it('displays users after successful fetch', async () => {\n    const users = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n    mockFetchUsers.mockResolvedValueOnce(users);\n\n    render(<UserList />);\n    \n    // Wait for loading message to disappear and user names to appear\n    await waitFor(() => {\n      expect(screen.queryByText(/loading users/i)).not.toBeInTheDocument();\n      expect(screen.getByText('Alice')).toBeInTheDocument();\n      expect(screen.getByText('Bob')).toBeInTheDocument();\n    });\n    expect(screen.getByRole('heading', { name: /user list/i })).toBeInTheDocument();\n  });\n\n  it('displays error message on fetch failure', async () => {\n    mockFetchUsers.mockRejectedValueOnce(new Error('Network error!'));\n\n    render(<UserList />);\n\n    await waitFor(() => {\n      expect(screen.queryByText(/loading users/i)).not.toBeInTheDocument();\n      expect(screen.getByTestId('error-message')).toHaveTextContent('Error: Network error!');\n    });\n  });\n\n  it('displays no users found message when API returns empty array', async () => {\n    mockFetchUsers.mockResolvedValueOnce([]); // Mock an empty array response\n\n    render(<UserList />);\n\n    await waitFor(() => {\n      expect(screen.queryByText(/loading users/i)).not.toBeInTheDocument();\n      expect(screen.getByText('No users found.')).toBeInTheDocument();\n    });\n  });\n});\n",
          "testCases": [
            "Component renders 'Loading users...' initially.",
            "After successful API call, 'Loading users...' disappears and 'Alice' and 'Bob' are displayed.",
            "After API call fails, 'Loading users...' disappears and an 'Error: Failed to fetch users.' message is displayed.",
            "After API call returns an empty array, 'Loading users...' disappears and 'No users found.' message is displayed.",
            "Ensure `fetchUsers` mock is called exactly once for each test."
          ],
          "hints": [
            "Use `jest.mock()` to mock the `fetchUsers` function. Make sure to clear mocks (`mockClear()`) before each test.",
            "Use `mockResolvedValueOnce()` and `mockRejectedValueOnce()` to control the mock's return value for specific test cases.",
            "Employ `await waitFor()` to wait for asynchronous updates to the DOM, such as loading indicators disappearing or data appearing.",
            "Use `screen.queryByText()` to assert the *absence* of elements (like the loading message)."
          ],
          "tags": [
            "react",
            "asynchronous",
            "api-integration",
            "react-testing-library",
            "rtl",
            "jest",
            "mocking"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_react_testing_library",
            "javascript_async",
            "jest_mocking"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "useEffect",
            "useState",
            "error_handling",
            "api_integration"
          ]
        },
        {
          "id": "task_enzyme_component_interaction",
          "title": "Implement and Test a Tabs Component with Enzyme",
          "description": "\nImplement a `Tabs` component that manages multiple tab panels. The component should:\n\n1.  Render a list of tab headers (e.g., 'Tab 1', 'Tab 2').\n2.  Initially, only the first tab's content should be visible.\n3.  Clicking a tab header should display its corresponding content and hide others.\n\nYour task is to:\n-   Create the `Tabs` component, which accepts `tabs` as a prop (an array of `{ title: string, content: ReactNode }`).\n-   Write a test suite using Enzyme's `mount` method to cover the following scenarios:\n    -   Initial render: Verify the first tab header is active and its content is visible, while other content is hidden.\n    -   Tab selection: Clicking a different tab header makes it active and displays its content, hiding previously active content.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Tabs.tsx\nconst Tabs = ({ tabs }) => {\n  const [activeIndex, setActiveIndex] = useState(0);\n\n  return (\n    <div className=\"tabs-container\">\n      <div className=\"tab-headers\">\n        {tabs.map((tab, index) => (\n          <button\n            key={index}\n            className={`tab-header ${index === activeIndex ? 'active' : ''}`}\n            onClick={() => setActiveIndex(index)}\n          >\n            {tab.title}\n          </button>\n        ))}\n      </div>\n      <div className=\"tab-content\">\n        {tabs[activeIndex] && tabs[activeIndex].content}\n      </div>\n    </div>\n  );\n};\n\nexport default Tabs;\n\n// Tabs.test.tsx\nimport { mount } from 'enzyme';\nimport Tabs from './Tabs';\n\ndescribe('Tabs Component', () => {\n  const mockTabs = [\n    { title: 'Tab 1', content: <div>Content for Tab 1</div> },\n    { title: 'Tab 2', content: <div>Content for Tab 2</div> },\n    { title: 'Tab 3', content: <div>Content for Tab 3</div> },\n  ];\n\n  // TODO: Implement test cases\n});\n",
          "solutionCode": "import React, { useState } from 'react';\n\nconst Tabs = ({ tabs }) => {\n  const [activeIndex, setActiveIndex] = useState(0);\n\n  return (\n    <div className=\"tabs-container\">\n      <div className=\"tab-headers\">\n        {tabs.map((tab, index) => (\n          <button\n            key={index}\n            className={`tab-header ${index === activeIndex ? 'active' : ''}`}\n            onClick={() => setActiveIndex(index)}\n            data-testid={`tab-header-${index}`}\n          >\n            {tab.title}\n          </button>\n        ))}\n      </div>\n      <div className=\"tab-content\">\n        {tabs[activeIndex] && tabs[activeIndex].content}\n      </div>\n    </div>\n  );\n};\n\nexport default Tabs;\n\n// Tabs.test.tsx\nimport { mount } from 'enzyme';\nimport Tabs from './Tabs';\n\ndescribe('Tabs Component', () => {\n  const mockTabs = [\n    { title: 'Tab 1', content: <div data-testid=\"tab-content-0\">Content for Tab 1</div> },\n    { title: 'Tab 2', content: <div data-testid=\"tab-content-1\">Content for Tab 2</div> },\n    { title: 'Tab 3', content: <div data-testid=\"tab-content-2\">Content for Tab 3</div> },\n  ];\n\n  it('renders with the first tab active and its content visible initially', () => {\n    const wrapper = mount(<Tabs tabs={mockTabs} />);\n\n    // Check active header\n    expect(wrapper.find('.tab-header.active').text()).toEqual('Tab 1');\n    // Check visible content\n    expect(wrapper.find('[data-testid=\"tab-content-0\"]')).toHaveLength(1);\n    // Check other content is not visible\n    expect(wrapper.find('[data-testid=\"tab-content-1\"]')).toHaveLength(0);\n    expect(wrapper.find('[data-testid=\"tab-content-2\"]')).toHaveLength(0);\n  });\n\n  it('changes active tab and displays correct content on click', () => {\n    const wrapper = mount(<Tabs tabs={mockTabs} />);\n\n    // Simulate click on 'Tab 2'\n    wrapper.find('[data-testid=\"tab-header-1\"]').simulate('click');\n    \n    // Update wrapper's internal state (important for enzyme after state changes)\n    wrapper.update();\n\n    // Check active header\n    expect(wrapper.find('.tab-header.active').text()).toEqual('Tab 2');\n    // Check visible content\n    expect(wrapper.find('[data-testid=\"tab-content-1\"]')).toHaveLength(1);\n    // Check previous content is hidden\n    expect(wrapper.find('[data-testid=\"tab-content-0\"]')).toHaveLength(0);\n  });\n\n  it('handles clicking the already active tab (no change)', () => {\n    const wrapper = mount(<Tabs tabs={mockTabs} />);\n    \n    // Click on Tab 1 (already active)\n    wrapper.find('[data-testid=\"tab-header-0\"]').simulate('click');\n    wrapper.update();\n\n    expect(wrapper.find('.tab-header.active').text()).toEqual('Tab 1');\n    expect(wrapper.find('[data-testid=\"tab-content-0\"]')).toHaveLength(1);\n    expect(wrapper.find('[data-testid=\"tab-content-1\"]')).toHaveLength(0);\n  });\n});\n",
          "testCases": [
            "Initial state: First tab is active, its content is shown, others are hidden.",
            "Clicking Tab 2: Tab 2 becomes active, its content is shown, Tab 1's content is hidden.",
            "Clicking Tab 3: Tab 3 becomes active, its content is shown, Tab 2's content is hidden.",
            "Clicking an already active tab: State and content remain unchanged.",
            "No tabs provided: Component renders gracefully (e.g., empty state or message)."
          ],
          "hints": [
            "Use `mount` for full DOM rendering to test interactions and content visibility.",
            "Use `wrapper.find()` with class names or `data-testid` to locate tab headers and content.",
            "Simulate clicks using `wrapper.find('selector').simulate('click');`",
            "After a state update triggered by `simulate`, you might need `wrapper.update()` to re-render the wrapper and reflect changes before asserting, especially for `mount` tests.",
            "Assert active tab by checking class names (e.g., `active`).",
            "Assert content visibility by checking `toHaveLength(1)` for visible content and `toHaveLength(0)` for hidden content."
          ],
          "tags": [
            "react",
            "component-design",
            "tabs",
            "enzyme",
            "interaction-testing",
            "state-management"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_enzyme",
            "react_state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "conditional_rendering",
            "event_handling",
            "props_drilling"
          ]
        },
        {
          "id": "task_jest_snapshot_component",
          "title": "Create a Snapshot Test for a Card Component",
          "description": "\nImplement a `Card` component that displays a title, description, and an optional image. Then, write a Jest snapshot test for this component.\n\nYour task is to:\n-   Create a `Card` functional component that accepts `title`, `description`, and `imageUrl` (optional) props.\n-   Implement a basic snapshot test for the `Card` component using `react-test-renderer`.\n-   Include at least two snapshot tests: one for a card with an image and one for a card without an image.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\n// Card.tsx\nconst Card = ({ title, description, imageUrl }) => {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '16px', margin: '8px', borderRadius: '8px' }}>\n      {imageUrl && <img src={imageUrl} alt={title} style={{ maxWidth: '100%', height: 'auto', marginBottom: '8px' }} />}\n      <h3>{title}</h3>\n      <p>{description}</p>\n    </div>\n  );\n};\n\nexport default Card;\n\n// Card.test.tsx\nimport React from 'react';\nimport renderer from 'react-test-renderer';\nimport Card from './Card';\n\ndescribe('Card Component', () => {\n  // TODO: Implement snapshot tests\n});\n",
          "solutionCode": "import React from 'react';\n\nconst Card = ({ title, description, imageUrl }) => {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '16px', margin: '8px', borderRadius: '8px' }}>\n      {imageUrl && <img src={imageUrl} alt={title} style={{ maxWidth: '100%', height: 'auto', marginBottom: '8px' }} />}\n      <h3>{title}</h3>\n      <p>{description}</p>\n    </div>\n  );\n};\n\nexport default Card;\n\n// Card.test.tsx\nimport React from 'react';\nimport renderer from 'react-test-renderer';\nimport Card from './Card';\n\ndescribe('Card Component', () => {\n  it('renders correctly with an image and matches snapshot', () => {\n    const tree = renderer.create(\n      <Card \n        title=\"Product Title\"\n        description=\"This is a detailed description of the product.\"\n        imageUrl=\"https://example.com/image.jpg\"\n      />\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders correctly without an image and matches snapshot', () => {\n    const tree = renderer.create(\n      <Card \n        title=\"Another Product\"\n        description=\"This card has no image.\"\n      />\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders with long text content', () => {\n    const tree = renderer.create(\n      <Card\n        title=\"A Very Long Product Title That Wraps Across Multiple Lines\"\n        description=\"This is an extremely long description that might test how the card handles overflowing text content and ensures that the layout remains stable without breaking. It should demonstrate the component's robustness in various scenarios.\"\n      />\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n",
          "testCases": [
            "Card with title, description, and image.",
            "Card with title and description only (no image).",
            "Card with very long title and description to check text wrapping.",
            "Card with empty title/description (if allowed by component)."
          ],
          "hints": [
            "Remember to import `renderer` from `react-test-renderer`.",
            "Use `renderer.create(<Component />).toJSON()` to get a serializable JSON tree.",
            "The Jest matcher for snapshots is `toMatchSnapshot()`.",
            "Run Jest with `-u` (`jest -u` or `npm test -- -u`) on the first run or when intentional changes occur to generate/update snapshots."
          ],
          "tags": [
            "react",
            "component",
            "jest",
            "snapshot-testing",
            "ui-testing"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_jest_snapshots",
            "react_props"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "conditional_rendering",
            "props_drilling"
          ]
        }
      ]
    }
  },
  {
    "id": "268fd6b8-c384-42e6-b131-ccc273800cdd",
    "startLine": 5100,
    "endLine": 5199,
    "processedDate": "2025-06-17T09:25:34.682Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_testing_best_practices",
          "title": "React Component Testing Best Practices",
          "content": "Testing React components effectively ensures their reliability and maintainability. It's crucial to focus on robust testing practices.\n\n## Snapshot Testing\nSnapshot testing, often used with libraries like Jest and React Test Renderer, captures the rendered output of a component and compares it to a previously saved snapshot. If the new output differs, the test fails, indicating an unintentional change or requiring an update to the snapshot. It's useful for ensuring UI consistency.\n\n## Core Testing Best Practices\n1.  **Test behavior, not implementation**: Focus on *what* the component does and its observable outputs, rather than its internal methods or state management. This makes tests more resilient to refactoring.\n2.  **Use `data-testid` for test selectors**: Relying on CSS classes or IDs for selecting elements in tests can lead to brittle tests, as these might change for styling or refactoring purposes. `data-testid` attributes are specifically for testing and provide stable selectors.\n3.  **Mock external dependencies**: Isolate your component tests by mocking any external APIs, services, or modules (e.g., network requests, third-party libraries). This ensures tests are fast, deterministic, and only fail due to issues within the component under test.\n4.  **Test edge cases**: Thoroughly test your components with various scenarios, including empty states (e.g., empty arrays passed as props), error states (e.g., API call failure), and boundary conditions (e.g., minimum/maximum input values). This helps uncover unexpected bugs.\n5.  **Keep tests fast**: Slow tests discourage developers from running them frequently. Optimize test performance by avoiding unnecessary complex setups, limiting the scope of tests, and effectively mocking dependencies.",
          "examples": [
            {
              "id": "example_testing_snapshot",
              "title": "Basic Snapshot Test",
              "code": "import renderer from 'react-test-renderer';\nimport Button from './Button';\n\ntest('Button component renders correctly', () => {\n  const component = renderer.create(\n    <Button text=\"Click me\" onClick={() => {}} />\n  );\n  let tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n});",
              "explanation": "This example demonstrates a basic snapshot test for a `Button` component using `react-test-renderer` and Jest. The rendered component is serialized to a JSON snapshot file, and `toMatchSnapshot()` asserts that future renders match this saved snapshot, ensuring UI consistency.",
              "language": "typescript"
            },
            {
              "id": "example_testing_data_testid",
              "title": "Using data-testid for Selection",
              "code": "import { render, screen, fireEvent } from '@testing-library/react';\nimport React from 'react';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)} data-testid=\"increment-button\">Increment</button>\n      <p data-testid=\"count-display\">Count: {count}</p>\n    </div>\n  );\n}\n\ntest('Counter increments count on button click', () => {\n  render(<Counter />);\n  const button = screen.getByTestId('increment-button');\n  const countDisplay = screen.getByTestId('count-display');\n  \n  fireEvent.click(button);\n  expect(countDisplay).toHaveTextContent('Count: 1');\n});",
              "explanation": "This example illustrates the use of `data-testid` for reliably selecting elements in tests with `@testing-library/react`. Elements are given `data-testid` attributes, which are then used with `screen.getByTestId` to locate them, making tests resilient to changes in CSS classes or element structure.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_testing_data_testid_1",
            "question_testing_behavior_vs_implementation_1",
            "question_testing_mocking_rationale_1",
            "question_testing_fast_tests_1",
            "question_flashcard_snapshot_testing",
            "question_flashcard_data_testid",
            "question_flashcard_test_behavior"
          ],
          "relatedTasks": [
            "task_component_testing_with_best_practices"
          ],
          "tags": [
            "testing",
            "react",
            "jest",
            "react-testing-library",
            "best-practices",
            "snapshot-testing"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "javascript_fundamentals"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "component_development",
            "qa"
          ]
        },
        {
          "id": "theory_react_performance_core_concepts",
          "title": "React Performance Optimization: Core Concepts",
          "content": "Optimizing React application performance is crucial for a smooth user experience. The primary goal is to minimize unnecessary re-renders and reduce initial load times.\n\n## Key Optimization Techniques\n1.  **Preventing Unnecessary Re-renders**: React's re-rendering process can be costly if components re-render when their props or state haven't meaningfully changed. Techniques like `React.memo`, `React.PureComponent`, and `shouldComponentUpdate` help control this.\n    *   **`React.PureComponent` (Class Components)**: A base class for React components that automatically implements `shouldComponentUpdate` with a shallow comparison of props and state. If the shallow comparison finds no differences, the component will not re-render.\n    *   **`React.memo` (Function Components)**: A higher-order component (HOC) that memoizes the result of a function component. It works similarly to `PureComponent` by shallowly comparing props. If props are the same, it reuses the last rendered result.\n    *   **`shouldComponentUpdate` (Class Components)**: A lifecycle method in class components that allows manual control over when a component should re-render. It receives `nextProps` and `nextState` and must return `true` (re-render) or `false` (do not re-render).\n\n2.  **Code Splitting and Lazy Loading**: Large JavaScript bundles can significantly slow down initial page loads. Code splitting breaks the bundle into smaller chunks that can be loaded on demand.\n    *   **`React.lazy`**: A function that lets you render a dynamic `import()` as a regular component. It defers loading the component's code until it's actually rendered.\n    *   **`React.Suspense`**: A component that lets you 'wait' for some code to load and declaratively specify a loading indicator (fallback UI) while waiting.\n\n3.  **Other Optimization Strategies**:\n    *   **Avoid unnecessary re-renders**: Use React DevTools Profiler to identify components that re-render frequently without a good reason. This might involve restructuring state or using `useCallback`/`useMemo` hooks (though not directly mentioned in source, it's a critical related concept for function components).\n    *   **Optimize rendering**: Techniques like list virtualization (rendering only visible items in long lists), data immutability, and batch updates (React automatically batches state updates in event handlers) contribute to smoother rendering.\n    *   **Memoization and Caching**: Beyond `React.memo`, general memoization (e.g., with `useMemo` or custom memoization functions) and caching frequently computed values can prevent redundant calculations.",
          "examples": [],
          "relatedQuestions": [
            "question_performance_primary_goal_1",
            "question_performance_shallow_comparison_1",
            "question_performance_when_to_optimize_1",
            "question_performance_identify_re_renders_1",
            "question_flashcard_react_memo_purecomponent_difference",
            "question_flashcard_code_splitting_benefit",
            "question_flashcard_unnecessary_re_renders"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "performance",
            "optimization",
            "re-renders",
            "code-splitting",
            "memoization",
            "lazy-loading"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "high_performance_apps"
          ]
        },
        {
          "id": "theory_react_memo",
          "title": "Using React.memo for Function Components",
          "content": "`React.memo` is a higher-order component (HOC) designed to optimize the performance of functional components by preventing unnecessary re-renders. It works by memoizing the rendered output of the component and only re-rendering it if its props have changed.\n\n## How `React.memo` Works\nWhen a component is wrapped with `React.memo`, React performs a shallow comparison of its props with the previous props. If all props are shallowly equal, React skips rendering the component and reuses the last rendered result. This can lead to significant performance improvements for components that receive complex props or perform expensive computations.\n\n## Custom Comparison Function\nBy default, `React.memo` performs a shallow comparison. However, you can provide a custom comparison function as the second argument to `React.memo`. This function receives `prevProps` and `nextProps` and should return `true` if the props are equal (i.e., the component should *not* re-render) and `false` if they are different (i.e., the component *should* re-render).\n\nThis custom comparison is useful when:\n*   You need a deep comparison for certain props (though often it's better to make props immutable).\n*   You want to ignore specific props during the comparison.\n*   The default shallow comparison is not sufficient for your specific optimization needs.\n\n**Note**: `React.memo` only checks for prop changes. If a functional component uses `useState` or `useContext`, it will still re-render when its own state or context changes, regardless of `React.memo`.",
          "examples": [
            {
              "id": "example_react_memo_basic",
              "title": "Basic React.memo Usage",
              "code": "import React from 'react';\n\nconst ExpensiveComponent = React.memo(function ExpensiveComponent(props) {\n  // This component will only re-render if props change\n  console.log('ExpensiveComponent rendering...');\n  return (\n    <div>\n      <h3>Expensive Component</h3>\n      {/* Expensive rendering logic, e.g., mapping a large array */}\n      {props.data.map(item => <div key={item.id}>{item.name}</div>)}\n    </div>\n  );\n});\n\n// Usage in a parent component:\nfunction ParentComponent() {\n  const [count, setCount] = React.useState(0);\n  const data = React.useMemo(() => [{ id: 1, name: 'Item A' }, { id: 2, name: 'Item B' }], []);\n\n  return (\n    <div>\n      <button onClick={() => setCount(c => c + 1)}>Parent Count: {count}</button>\n      <ExpensiveComponent data={data} />\n    </div>\n  );\n}",
              "explanation": "In this example, `ExpensiveComponent` is wrapped with `React.memo`. When `ParentComponent` re-renders due to its `count` state changing, `ExpensiveComponent` will *not* re-render because its `data` prop (which is memoized with `useMemo`) remains referentially equal. The 'ExpensiveComponent rendering...' log will only appear on initial mount.",
              "language": "typescript"
            },
            {
              "id": "example_react_memo_custom_comparison",
              "title": "React.memo with Custom Comparison",
              "code": "import React from 'react';\n\nconst areEqual = (prevProps, nextProps) => {\n  // Return true if passing nextProps to render would return\n  // the same result as passing prevProps to render; otherwise return false\n  // Here, we only re-render if the length of the data array changes\n  return prevProps.data.length === nextProps.data.length;\n};\n\nconst MemoizedComponentWithCustomComparison = React.memo(function ExpensiveComponent(props) {\n  console.log('MemoizedComponentWithCustomComparison rendering...');\n  return (\n    <div>\n      <h4>Custom Memoized Component</h4>\n      {props.data.map(item => <div key={item.id}>{item.name}</div>)}\n    </div>\n  );\n}, areEqual);\n\n// Example usage:\nfunction ParentWithCustomMemo() {\n  const [value, setValue] = React.useState(0);\n  const [items, setItems] = React.useState([\n    { id: 1, name: 'Apple' },\n    { id: 2, name: 'Banana' }\n  ]);\n\n  // This will cause re-renders if the custom comparison only checks length\n  // while other properties of an object in the array change\n  const updateItemName = () => {\n    setItems(prev => prev.map(item => \n      item.id === 1 ? { ...item, name: 'New Apple ' + Math.random() } : item\n    ));\n  };\n\n  return (\n    <div>\n      <button onClick={() => setValue(v => v + 1)}>Parent Value: {value}</button>\n      <button onClick={updateItemName}>Change Item Name</button>\n      <MemoizedComponentWithCustomComparison data={items} />\n    </div>\n  );\n}",
              "explanation": "This example shows `React.memo` with a custom `areEqual` function. The component `MemoizedComponentWithCustomComparison` will only re-render if the `length` of its `data` prop array changes, even if individual items within the array are modified (e.g., their `name` property changes). This highlights how a custom comparison can be more specific than a shallow comparison, but also how it might miss changes if not implemented carefully.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_memo_purpose_1",
            "question_react_memo_custom_comparison_1",
            "question_react_memo_with_state_1",
            "question_react_memo_shallow_comparison_1",
            "question_flashcard_react_memo_arguments",
            "question_flashcard_react_memo_return_true_false"
          ],
          "relatedTasks": [
            "task_optimize_functional_component_with_memo"
          ],
          "tags": [
            "react",
            "performance",
            "optimization",
            "react-memo",
            "hoc",
            "functional-component",
            "shallow-comparison"
          ],
          "technology": "React",
          "prerequisites": [
            "react_hooks",
            "react_functional_components"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_tuning",
            "advanced_react"
          ]
        },
        {
          "id": "theory_react_purecomponent",
          "title": "Using PureComponent for Class Components",
          "content": "`React.PureComponent` is a base class that React class components can extend to gain automatic performance optimizations. It extends `React.Component` but includes a default implementation of the `shouldComponentUpdate` lifecycle method.\n\n## How `React.PureComponent` Works\n`React.PureComponent`'s `shouldComponentUpdate` performs a shallow comparison of the component's `props` and `state` with their previous values. If this shallow comparison determines that neither props nor state have changed, `shouldComponentUpdate` returns `false`, preventing the component from re-rendering. This is highly effective for components that have simple props and state structures or use immutable data.\n\n## Benefits and Considerations\n*   **Automatic Optimization**: It provides an easy way to optimize class components without manually implementing `shouldComponentUpdate`.\n*   **Shallow Comparison**: It only performs a shallow comparison. For deeply nested objects or arrays, it might not detect changes, leading to components *not* re-rendering when they should, or requiring immutable data structures.\n*   **Alternative to `shouldComponentUpdate`**: While you can still override `shouldComponentUpdate` in a `PureComponent`, doing so negates the benefit of `PureComponent`'s automatic comparison.\n\n**Comparison with `React.memo`**: `React.PureComponent` is to class components what `React.memo` is to functional components. Both provide performance optimization by preventing unnecessary re-renders based on shallow prop/state comparisons.",
          "examples": [
            {
              "id": "example_react_purecomponent_basic",
              "title": "Basic PureComponent Usage",
              "code": "import React from 'react';\n\nclass OptimizedList extends React.PureComponent {\n  // PureComponent automatically implements shouldComponentUpdate\n  // with a shallow comparison of props and state\n  render() {\n    console.log('OptimizedList rendering...');\n    return (\n      <ul>\n        {this.props.items.map(item => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    );\n  }\n}\n\n// Usage in a parent component:\nclass ParentComponentWithPure extends React.Component {\n  state = {\n    count: 0,\n    items: [{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }]\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Parent Count: {this.state.count}\n        </button>\n        <OptimizedList items={this.state.items} />\n      </div>\n    );\n  }\n}",
              "explanation": "In this example, `OptimizedList` extends `React.PureComponent`. When the `ParentComponentWithPure`'s `count` state changes, `OptimizedList` will not re-render because its `items` prop remains referentially the same (a shallow comparison will find no change). The 'OptimizedList rendering...' log will only appear on initial mount.",
              "language": "typescript"
            },
            {
              "id": "example_react_purecomponent_immutable_data",
              "title": "PureComponent with Immutable Data",
              "code": "import React from 'react';\n\nclass OptimizedDataDisplay extends React.PureComponent {\n  render() {\n    console.log('OptimizedDataDisplay rendering...');\n    return (\n      <div>\n        <h3>Data Display</h3>\n        <p>Value: {this.props.data.value}</p>\n        <p>Timestamp: {this.props.data.timestamp}</p>\n      </div>\n    );\n  }\n}\n\nclass AppWithImmutablePure extends React.Component {\n  state = {\n    data: { value: 10, timestamp: Date.now() },\n    toggle: false\n  };\n\n  updateData = () => {\n    // Create a new object for state update to trigger re-render in PureComponent\n    this.setState(prevState => ({\n      data: { ...prevState.data, value: prevState.data.value + 1, timestamp: Date.now() }\n    }));\n  };\n\n  toggleState = () => {\n    this.setState(prevState => ({ toggle: !prevState.toggle }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.updateData}>Update Data</button>\n        <button onClick={this.toggleState}>Toggle App State</button>\n        <p>App Toggle: {this.state.toggle ? 'On' : 'Off'}</p>\n        <OptimizedDataDisplay data={this.state.data} />\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates `PureComponent` used with immutable data. `OptimizedDataDisplay` will only re-render when its `data` prop object itself changes (i.e., a new object reference is passed). When `updateData` is called, a *new* `data` object is created, causing `OptimizedDataDisplay` to re-render. However, when `toggleState` is called, only `AppWithImmutablePure`'s own state changes, and `OptimizedDataDisplay` will *not* re-render because its `data` prop reference remains the same.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_purecomponent_how_it_works_1",
            "question_purecomponent_shallow_comparison_issue_1",
            "question_purecomponent_override_shouldcomponentupdate_1",
            "question_purecomponent_vs_memo_1",
            "question_flashcard_purecomponent_behavior"
          ],
          "relatedTasks": [
            "task_optimize_class_component_with_purecomponent"
          ],
          "tags": [
            "react",
            "performance",
            "optimization",
            "purecomponent",
            "class-component",
            "shallow-comparison",
            "shouldcomponentupdate"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_tuning",
            "legacy_react_apps"
          ]
        },
        {
          "id": "theory_react_lazy_suspense",
          "title": "React.lazy and React.Suspense for Code Splitting",
          "content": "Code splitting is a technique that allows you to split your code into various bundles which can then be loaded on demand. This improves the application's initial load time by reducing the amount of JavaScript that needs to be downloaded upfront. React provides built-in support for code splitting with `React.lazy` and `React.Suspense`.\n\n## `React.lazy`\n`React.lazy` is a function that lets you render a dynamic `import()` as a regular React component. It takes a function that returns a `Promise` (which resolves to a module with a default export containing a React component). The component will only be loaded when it's actually rendered for the first time.\n\n**Key Characteristics:**\n*   Works with default exports.\n*   Must be rendered inside a `Suspense` component.\n*   Not suitable for server-side rendering (SSR) unless specific solutions like `@loadable/component` are used.\n\n## `React.Suspense`\n`React.Suspense` is a component that lets you 'wait' for some code to load (e.g., a component loaded with `React.lazy`) and declaratively specify a loading indicator (fallback UI) while waiting. If multiple lazy components are rendered within the same `Suspense` boundary, `Suspense` waits for all of them to load before rendering the `children`.\n\n**Key Characteristics:**\n*   Requires a `fallback` prop, which can be any React elements (e.g., a loading spinner, skeleton UI).\n*   Can wrap multiple lazy components.\n*   Can be nested to provide more granular loading states.\n\n## Benefits of Code Splitting\n*   **Faster Initial Page Loads**: Users download less JavaScript upfront.\n*   **Improved User Experience**: A snappier initial load leads to better user satisfaction.\n*   **Better Resource Utilization**: Only necessary code is loaded, saving bandwidth.\n*   **Reduced Bundle Size**: The main bundle becomes smaller.",
          "examples": [
            {
              "id": "example_react_lazy_suspense_basic",
              "title": "Basic Code Splitting with React.lazy and Suspense",
              "code": "import React, { Suspense } from 'react';\n\n// Instead of importing directly:\n// import HeavyComponent from './HeavyComponent';\n\n// Use lazy loading for a potentially large component\nconst HeavyComponent = React.lazy(() => import('./HeavyComponent'));\n\nfunction App() {\n  const [showHeavy, setShowHeavy] = React.useState(false);\n\n  return (\n    <div>\n      <h1>Main Application</h1>\n      <button onClick={() => setShowHeavy(true)}>Load Heavy Component</button>\n      {showHeavy && (\n        <Suspense fallback={<div>Loading Heavy Component...</div>}>\n          <HeavyComponent />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Example HeavyComponent.js (in a separate file)\n/*\n// HeavyComponent.js\nimport React from 'react';\n\nconst HeavyComponent = () => {\n  // Simulate a heavy component with some rendering\n  const items = Array.from({ length: 1000 }, (_, i) => `Item ${i}`);\n  return (\n    <div style={{ border: '1px solid gray', padding: '10px', marginTop: '20px' }}>\n      <h2>This is a Heavy Component</h2>\n      <p>Loaded on demand!</p>\n      <ul>\n        {items.map(item => <li key={item}>{item}</li>)}\n      </ul>\n    </div>\n  );\n};\n\nexport default HeavyComponent;\n*/",
              "explanation": "This example demonstrates how to use `React.lazy` and `React.Suspense` for code splitting. The `HeavyComponent`'s code is not loaded until the `Load Heavy Component` button is clicked and `showHeavy` becomes `true`. While the component is loading, the `Suspense` fallback ('Loading Heavy Component...') is displayed. This helps improve the initial load time of the main `App` bundle.",
              "language": "typescript"
            },
            {
              "id": "example_react_lazy_suspense_multiple_components",
              "title": "Suspense with Multiple Lazy Components",
              "code": "import React, { Suspense } from 'react';\n\nconst LazyComponentA = React.lazy(() => import('./LazyComponentA'));\nconst LazyComponentB = React.lazy(() => import('./LazyComponentB'));\n\nfunction Dashboard() {\n  const [showComponents, setShowComponents] = React.useState(false);\n\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <button onClick={() => setShowComponents(true)}>Show Dashboard Components</button>\n      {showComponents && (\n        <Suspense fallback={<div>Loading Dashboard Widgets...</div>}>\n          <LazyComponentA />\n          <LazyComponentB />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Dummy LazyComponentA.js and LazyComponentB.js\n/*\n// LazyComponentA.js\nimport React from 'react';\nconst LazyComponentA = () => <p>Widget A Loaded!</p>;\nexport default LazyComponentA;\n\n// LazyComponentB.js\nimport React from 'react';\nconst LazyComponentB = () => <p>Widget B Loaded!</p>;\nexport default LazyComponentB;\n*/",
              "explanation": "This example shows how a single `Suspense` boundary can wrap multiple `React.lazy` components. The 'Loading Dashboard Widgets...' fallback will be displayed until *both* `LazyComponentA` and `LazyComponentB` have finished loading their respective code bundles. Once both are ready, they will render together.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_lazy_suspense_purpose_1",
            "question_lazy_suspense_fallback_1",
            "question_lazy_suspense_benefits_1",
            "question_lazy_suspense_ssr_1",
            "question_flashcard_react_lazy",
            "question_flashcard_react_suspense",
            "question_flashcard_code_splitting"
          ],
          "relatedTasks": [
            "task_implement_lazy_loading_with_suspense"
          ],
          "tags": [
            "react",
            "code-splitting",
            "lazy-loading",
            "suspense",
            "performance",
            "webpack"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "javascript_modules"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "large_scale_apps",
            "performance_optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_testing_data_testid_1",
          "topic": "React Component Testing Best Practices",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the recommended approach for selecting elements in React component tests to ensure stability against styling changes?",
          "answer": "Using `data-testid` attributes.",
          "options": [
            "Using CSS class names.",
            "Using element IDs.",
            "Using `data-testid` attributes.",
            "Using HTML tag names."
          ],
          "analysisPoints": [
            "CSS class names and element IDs are primarily for styling or JavaScript logic, and can change frequently.",
            "`data-testid` is specifically designed for testing, providing a stable hook that is less likely to change due to refactoring or styling updates.",
            "HTML tag names are too generic and don't provide specific identification for unique elements or interactions."
          ],
          "keyConcepts": [
            "data-testid",
            "test selectors",
            "test stability",
            "testing best practices"
          ],
          "evaluationCriteria": [
            "Understanding of best practices for test selectors.",
            "Ability to distinguish between robust and brittle testing methods."
          ],
          "example": "```html\n<button data-testid=\"submit-button\">Submit</button>\n```\nIn tests, you would use `screen.getByTestId('submit-button')` to find this button.",
          "tags": [
            "testing",
            "react-testing-library",
            "data-testid"
          ],
          "prerequisites": [
            "react_basics",
            "testing_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_testing_behavior_vs_implementation_1",
          "topic": "React Component Testing Best Practices",
          "level": "medium",
          "type": "open",
          "question": "Explain the principle of 'testing behavior, not implementation' in the context of React components. Why is this considered a best practice, and what are the potential pitfalls of violating it?",
          "answer": "The principle of 'testing behavior, not implementation' means that tests should focus on the observable outcomes and user interactions of a component (its behavior) rather than its internal working mechanisms (its implementation details, like state variables, private methods, or specific component lifecycle calls). \n\n**Why it's a best practice:**\n1.  **Resilience to Refactoring**: Tests become less brittle. If you refactor the internal logic of a component without changing its external behavior, the tests should still pass. This allows developers to improve code quality without breaking tests.\n2.  **Focus on User Experience**: It aligns tests with how a user interacts with the component. Users care about what the component *does*, not how it does it. This ensures the component meets functional requirements from a user's perspective.\n3.  **Encourages Better Design**: It encourages designing components with clear public APIs and predictable behavior, as these are what will be tested.\n\n**Potential pitfalls of violating it (testing implementation):**\n1.  **Brittle Tests**: Tests break frequently even when the component's user-facing functionality hasn't changed. This leads to developer frustration and a tendency to ignore failing tests.\n2.  **Maintenance Overhead**: Developers spend more time fixing tests after internal refactoring, slowing down development.\n3.  **False Confidence**: Passing tests might not truly reflect that the component works correctly from a user's perspective if the implementation details they test are not directly tied to observable behavior.",
          "analysisPoints": [
            "Defines the principle clearly.",
            "Explains benefits like refactoring resilience.",
            "Details pitfalls like brittle tests and maintenance overhead.",
            "Connects the practice to user experience and design."
          ],
          "keyConcepts": [
            "testing best practices",
            "behavioral testing",
            "implementation details",
            "refactoring",
            "test maintenance"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of explanation.",
            "Understanding of the rationale behind the best practice.",
            "Ability to articulate the negative consequences of violating the principle."
          ],
          "example": "A test for a 'Counter' component should assert that clicking an 'Increment' button *changes the displayed count* (behavior), not that a specific `setCount` function was called (implementation detail).",
          "tags": [
            "testing",
            "react",
            "best-practices",
            "software-design"
          ],
          "prerequisites": [
            "unit_testing",
            "react_component_lifecycle"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_testing_mocking_rationale_1",
          "topic": "React Component Testing Best Practices",
          "level": "medium",
          "type": "mcq",
          "question": "When testing a React component that makes an API call, why is it considered a best practice to mock the external API dependency?",
          "answer": "To isolate the component under test and ensure deterministic and fast tests.",
          "options": [
            "To make the tests more complex and realistic.",
            "To ensure the component always gets real-time data.",
            "To isolate the component under test and ensure deterministic and fast tests.",
            "To reduce the number of test cases needed."
          ],
          "analysisPoints": [
            "Mocking isolates the component, so its test only fails if there's an issue with the component itself, not the external API.",
            "Mocked API calls are faster than real network requests, speeding up the test suite.",
            "Mocking makes tests deterministic because the mocked response is predictable, unlike a real API which might vary or be unavailable.",
            "Making tests more complex or relying on real-time data goes against the principles of unit testing.",
            "Mocking does not necessarily reduce test cases; it just makes existing cases more reliable and efficient."
          ],
          "keyConcepts": [
            "mocking",
            "test isolation",
            "deterministic tests",
            "test speed",
            "external dependencies"
          ],
          "evaluationCriteria": [
            "Understanding of mocking's purpose in testing.",
            "Ability to identify the benefits of test isolation."
          ],
          "example": "```typescript\n// Example using Jest to mock a fetch call\nglobal.fetch = jest.fn(() =>\n  Promise.resolve({\n    json: () => Promise.resolve({ data: 'mocked data' }),\n  })\n);\n\ntest('Component fetches data correctly', async () => {\n  render(<DataFetcherComponent />);\n  expect(await screen.findByText('mocked data')).toBeInTheDocument();\n  expect(global.fetch).toHaveBeenCalledWith('/api/data');\n});\n```",
          "tags": [
            "testing",
            "jest",
            "mocking",
            "api"
          ],
          "prerequisites": [
            "javascript_async",
            "testing_fundamentals"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_testing_fast_tests_1",
          "topic": "React Component Testing Best Practices",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is it important to keep React component tests fast?",
          "answer": "Fast tests encourage developers to run them frequently, leading to quicker feedback loops and earlier detection of bugs.",
          "keyConcepts": [
            "test speed",
            "developer experience",
            "feedback loop",
            "bug detection"
          ],
          "evaluationCriteria": [
            "Recall of the importance of test suite performance."
          ],
          "tags": [
            "testing",
            "best-practices",
            "developer-experience"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_performance_primary_goal_1",
          "topic": "React Performance Optimization",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary goal of React performance optimization?",
          "answer": "To minimize unnecessary re-renders and reduce initial load times.",
          "keyConcepts": [
            "performance optimization",
            "re-renders",
            "initial load time"
          ],
          "evaluationCriteria": [
            "Recall of fundamental performance goals in React."
          ],
          "tags": [
            "react",
            "performance",
            "optimization"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_performance_shallow_comparison_1",
          "topic": "React Performance Optimization",
          "level": "medium",
          "type": "open",
          "question": "Explain what a 'shallow comparison' means in the context of React's performance optimizations (e.g., `React.memo` or `PureComponent`), and why it's used instead of a deep comparison. What are its limitations?",
          "answer": "A 'shallow comparison' in React's performance optimizations (like `React.memo` for function components or `React.PureComponent` for class components) refers to checking if the *references* of props and state values have changed, rather than comparing their actual content if they are objects or arrays.\n\n**How it works:**\n*   **Primitive values (numbers, strings, booleans, null, undefined)**: Compared by value.\n*   **Objects and Arrays**: Compared by reference. If the memory address of an object/array is the same, it's considered 'equal', even if its internal properties have changed. If a new object/array is created (even with the same content), it's considered 'different'.\n\n**Why it's used instead of deep comparison:**\n1.  **Performance**: Deep comparison, especially for large or deeply nested data structures, can be computationally expensive and time-consuming. It could negate the performance benefits that `memo`/`PureComponent` aim to provide.\n2.  **Simplicity**: Shallow comparison is much simpler and faster to implement than a recursive deep comparison.\n\n**Limitations:**\n1.  **Mutable Data**: If you mutate an object or array prop/state (e.g., `arr.push(item)` or `obj.prop = newValue`) instead of creating a new one (e.g., `[...arr, item]` or `{...obj, prop: newValue}`), a shallow comparison will *not* detect the change because the reference remains the same. This will prevent the component from re-rendering when it should, leading to stale UI.\n2.  **Deeply Nested Data**: For components that receive deeply nested objects or arrays as props, a shallow comparison will only check the top-level reference. If a nested property changes but the parent object's reference remains the same, the component will not re-render.",
          "analysisPoints": [
            "Clearly defines shallow comparison for primitives and objects/arrays.",
            "Explains the performance and simplicity reasons for using shallow comparison.",
            "Highlights the key limitations, especially with mutable data and deeply nested structures."
          ],
          "keyConcepts": [
            "shallow comparison",
            "deep comparison",
            "React.memo",
            "React.PureComponent",
            "immutability",
            "re-rendering"
          ],
          "evaluationCriteria": [
            "Accuracy of shallow comparison definition.",
            "Understanding of the trade-offs (performance vs. comprehensiveness).",
            "Identification of real-world pitfalls."
          ],
          "example": "```javascript\nconst obj1 = { a: 1, b: { c: 2 } };\nconst obj2 = { a: 1, b: { c: 2 } };\nconst obj3 = obj1;\n\nconsole.log(obj1 === obj2); // false (different references, even if content is deep-equal)\nconsole.log(obj1 === obj3); // true (same reference)\n```\n`React.memo` or `PureComponent` would treat `obj1` and `obj2` as different, but `obj1` and `obj3` as the same.",
          "tags": [
            "react",
            "performance",
            "optimization",
            "javascript",
            "data-structures"
          ],
          "prerequisites": [
            "javascript_object_references",
            "react_performance_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_performance_when_to_optimize_1",
          "topic": "React Performance Optimization",
          "level": "medium",
          "type": "open",
          "question": "When should you start thinking about optimizing React component performance? What tools or indicators might suggest that optimization is needed?",
          "answer": "Performance optimization should generally be a secondary concern, after achieving correct functionality and a clear architecture. The common adage is 'premature optimization is the root of all evil.'\n\n**When to start thinking about optimization:**\n1.  **Perceived Slowness**: Users report a slow or unresponsive application, especially during interactions or initial load.\n2.  **Quantitative Metrics**: When monitoring tools (like Lighthouse, Web Vitals) show poor performance scores (e.g., high FID, LCP, CLS, or slow TBT).\n3.  **Specific Bottlenecks**: When specific parts of the application, like complex lists, frequent animations, or large data tables, are visibly sluggish.\n\n**Tools or Indicators that suggest optimization is needed:**\n1.  **React DevTools Profiler**: This tool allows you to record rendering cycles and identify which components are re-rendering, how often, and why. It visually highlights expensive renders.\n2.  **Browser Developer Tools (Performance Tab)**: Can help identify long-running JavaScript tasks, layout thrashing, and paint bottlenecks.\n3.  **Lighthouse / Web Vitals**: Provides an objective score and actionable insights into various performance metrics.\n4.  **CPU/Memory Usage**: High CPU usage in the browser's task manager or increasing memory consumption can indicate inefficiencies.\n5.  **User Complaints**: Direct feedback from users about the application feeling slow or unresponsive is a strong indicator.\n6.  **Unresponsive UI**: Janky animations, delayed responses to clicks/inputs, or frozen UI segments.\n\nIn essence, you optimize when there's a *demonstrated* performance problem affecting the user experience, rather than pre-emptively optimizing every component.",
          "analysisPoints": [
            "Emphasizes optimizing based on actual problems, not prematurely.",
            "Lists clear indicators like user perception and quantitative metrics.",
            "Provides concrete tools for identifying performance bottlenecks.",
            "Connects optimization back to user experience."
          ],
          "keyConcepts": [
            "performance optimization",
            "profiling",
            "browser dev tools",
            "web vitals",
            "user experience",
            "premature optimization"
          ],
          "evaluationCriteria": [
            "Understanding of when to initiate performance work.",
            "Knowledge of common tools and indicators.",
            "Ability to articulate the 'why' behind optimization."
          ],
          "example": "Using React DevTools Profiler, if you see a component re-rendering many times when only a small piece of data changed, and its render time is significant, it's a candidate for optimization with `React.memo` or `PureComponent`.",
          "tags": [
            "react",
            "performance",
            "debugging",
            "tooling",
            "best-practices"
          ],
          "prerequisites": [
            "react_basics",
            "web_performance"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_performance_identify_re_renders_1",
          "topic": "React Performance Optimization",
          "level": "easy",
          "type": "flashcard",
          "question": "What tool can help you identify unnecessary re-renders in a React application?",
          "answer": "React DevTools Profiler (or the 'Highlight updates when components render' option in React DevTools settings).",
          "keyConcepts": [
            "re-renders",
            "react devtools",
            "profiling",
            "performance"
          ],
          "evaluationCriteria": [
            "Recall of basic React performance debugging tools."
          ],
          "tags": [
            "react",
            "performance",
            "tooling"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_react_memo_purecomponent_difference",
          "topic": "React Performance Optimization",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between `React.memo` and `React.PureComponent`?",
          "answer": "`React.memo` is used for functional components, while `React.PureComponent` is used for class components. Both perform shallow prop/state comparisons to prevent unnecessary re-renders.",
          "keyConcepts": [
            "React.memo",
            "React.PureComponent",
            "functional components",
            "class components",
            "shallow comparison"
          ],
          "evaluationCriteria": [
            "Recall of the distinction between `React.memo` and `PureComponent`."
          ],
          "tags": [
            "react",
            "performance",
            "optimization",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_memo_purpose_1",
          "topic": "React.memo",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of `React.memo`?",
          "answer": "To prevent a functional component from re-rendering if its props have not shallowly changed.",
          "options": [
            "To perform deep comparisons of props and state.",
            "To replace `shouldComponentUpdate` in class components.",
            "To lazy-load components.",
            "To prevent a functional component from re-rendering if its props have not shallowly changed."
          ],
          "analysisPoints": [
            "`React.memo` specifically targets functional components and uses shallow comparison.",
            "It does not perform deep comparisons by default.",
            "`shouldComponentUpdate` is for class components; `PureComponent` is its class equivalent for automatic shallow comparison.",
            "`React.lazy` is for lazy-loading, not `React.memo`."
          ],
          "keyConcepts": [
            "React.memo",
            "re-rendering",
            "functional components",
            "shallow comparison",
            "performance optimization"
          ],
          "evaluationCriteria": [
            "Understanding of `React.memo`'s core functionality.",
            "Ability to differentiate it from other optimization techniques."
          ],
          "example": "```typescript\nconst MyComponent = React.memo((props) => {\n  console.log('MyComponent rendered');\n  return <div>{props.value}</div>;\n});\n// MyComponent will only log 'MyComponent rendered' if `props.value` changes.\n```",
          "tags": [
            "react",
            "performance",
            "react-memo"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memo_custom_comparison_1",
          "topic": "React.memo",
          "level": "medium",
          "type": "open",
          "question": "When and why would you provide a custom comparison function as the second argument to `React.memo`? What should this function return?",
          "answer": "You would provide a custom comparison function as the second argument to `React.memo` when the default shallow comparison is not sufficient for your optimization needs. This is typically the case when:\n\n1.  **Deeply Nested Props**: If a prop is an object or array and changes within its nested structure should *not* trigger a re-render, but the default shallow comparison would always see the same reference.\n2.  **Ignoring Specific Props**: If certain props change frequently but do not affect the component's rendered output, you might want to exclude them from the comparison.\n3.  **Complex Comparison Logic**: When you need more nuanced control over the re-render condition than a simple shallow check provides (e.g., comparing only certain properties of an object prop, or using a custom equality check).\n\n**Why**: The goal is to prevent unnecessary re-renders in scenarios where the default shallow comparison would cause one, or to allow re-renders in cases where the default would prevent one mistakenly (e.g., with mutable data where the reference doesn't change but the content does).\n\n**Return Value**: The custom comparison function `areEqual(prevProps, nextProps)` should return:\n*   `true`: If passing `nextProps` to render would produce the *same result* as passing `prevProps`. This means the component should **NOT** re-render.\n*   `false`: If passing `nextProps` would produce a *different result*. This means the component **SHOULD** re-render.",
          "analysisPoints": [
            "Identifies scenarios for custom comparison (nested props, ignoring props, complex logic).",
            "Explains the 'why' (addressing default shallow comparison limitations).",
            "Correctly states the `true`/`false` return logic for `areEqual`.",
            "Highlights the counter-intuitive `true` for no re-render."
          ],
          "keyConcepts": [
            "React.memo",
            "custom comparison function",
            "areEqual",
            "re-rendering control",
            "shallow comparison limitations"
          ],
          "evaluationCriteria": [
            "Understanding of advanced `React.memo` usage.",
            "Clarity on the `areEqual` function's behavior.",
            "Ability to explain practical use cases."
          ],
          "example": "```typescript\nconst areEqual = (prevProps, nextProps) => {\n  // Only re-render if the 'id' of the user changes, ignore 'lastLogin' for re-renders\n  return prevProps.user.id === nextProps.user.id;\n};\n\nconst UserDisplay = React.memo(({ user }) => {\n  console.log('UserDisplay rendered');\n  return (\n    <div>\n      User: {user.name}, ID: {user.id}\n    </div>\n  );\n}, areEqual);\n```",
          "tags": [
            "react",
            "performance",
            "react-memo",
            "advanced-react"
          ],
          "prerequisites": [
            "react_memo",
            "javascript_functions"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_memo_with_state_1",
          "topic": "React.memo",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React functional component:\n\n```typescript\nimport React from 'react';\n\nconst MyMemoizedComponent = React.memo(({ data }) => {\n  const [internalCount, setInternalCount] = React.useState(0);\n  console.log('MyMemoizedComponent rendered');\n  return (\n    <div>\n      <p>Data: {data}</p>\n      <button onClick={() => setInternalCount(internalCount + 1)}>Increment Internal: {internalCount}</button>\n    </div>\n  );\n});\n\nfunction ParentComponent() {\n  const [parentData, setParentData] = React.useState('initial');\n  const [parentTrigger, setParentTrigger] = React.useState(0);\n\n  return (\n    <div>\n      <button onClick={() => setParentTrigger(parentTrigger + 1)}>Trigger Parent Re-render</button>\n      <MyMemoizedComponent data={parentData} />\n    </div>\n  );\n}\n```\nIf `setInternalCount` is called within `MyMemoizedComponent`, causing `internalCount` to change, what will happen to `MyMemoizedComponent`?",
          "answer": "It will re-render, as `React.memo` only checks props, not internal state changes.",
          "options": [
            "It will not re-render because it is wrapped with `React.memo`.",
            "It will re-render, as `React.memo` only checks props, not internal state changes.",
            "It will throw an error because `React.memo` cannot be used with components that have internal state.",
            "It will re-render only if `parentData` also changes."
          ],
          "analysisPoints": [
            "`React.memo` optimizes based on prop changes. It does not prevent re-renders caused by internal state updates within the memoized component itself.",
            "If `internalCount` changes, `MyMemoizedComponent` needs to re-render to reflect the new state, regardless of its props.",
            "The error option is incorrect; `React.memo` can be used with components having internal state.",
            "The re-render tied to `parentData` is about the parent component triggering a prop change, not an internal state change."
          ],
          "keyConcepts": [
            "React.memo",
            "internal state",
            "re-rendering",
            "functional components",
            "useState"
          ],
          "evaluationCriteria": [
            "Understanding of `React.memo`'s scope (props only).",
            "Knowledge of how state changes trigger re-renders in functional components."
          ],
          "example": "In the provided code, if you click the 'Increment Internal' button, `MyMemoizedComponent` will log 'MyMemoizedComponent rendered' even if `parentData` hasn't changed, because its own internal state has updated.",
          "tags": [
            "react",
            "performance",
            "react-memo",
            "state"
          ],
          "prerequisites": [
            "react_hooks",
            "react_memo"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memo_shallow_comparison_1",
          "topic": "React.memo",
          "level": "medium",
          "type": "code",
          "question": "Given the following React component setup:\n\n```typescript\nimport React from 'react';\n\nconst DisplayNumbers = React.memo(({ numbers }) => {\n  console.log('DisplayNumbers rendered');\n  return (\n    <div>\n      {numbers.map((num, index) => <span key={index}>{num} </span>)}\n    </div>\n  );\n});\n\nfunction App() {\n  const [count, setCount] = React.useState(0);\n  const [data, setData] = React.useState([1, 2, 3]);\n\n  const updateData = () => {\n    // OPTION 1: Mutate the existing array\n    // data.push(data.length + 1);\n    // setData(data);\n\n    // OPTION 2: Create a new array\n    setData([...data, data.length + 1]);\n  };\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Increment Parent Count ({count})</button>\n      <button onClick={updateData}>Add Number to Data</button>\n      <DisplayNumbers numbers={data} />\n    </div>\n  );\n}\n```\n\nWhich `updateData` implementation (OPTION 1 or OPTION 2) will correctly trigger a re-render of `DisplayNumbers` when the 'Add Number to Data' button is clicked, and why? Explain the behavior of the *other* option.",
          "answer": "The correct answer is OPTION 2:\n\n```typescript\n// OPTION 2: Create a new array\nsetData([...data, data.length + 1]);\n```\n\n**Explanation:**\n\n`DisplayNumbers` is wrapped with `React.memo`, which performs a shallow comparison of its props. \n\n*   **OPTION 2 (`setData([...data, data.length + 1]);`)**: This implementation creates a *new array* by spreading the existing `data` and adding a new element. When `setData` is called with this new array, the `numbers` prop passed to `DisplayNumbers` now has a different reference than its previous value. `React.memo`'s shallow comparison detects this change in reference, and thus `DisplayNumbers` will correctly re-render.\n\n*   **OPTION 1 (Commented out: `data.push(data.length + 1); setData(data);`)**: This implementation *mutates* the existing `data` array by using `push()` and then attempts to update the state with the *same array reference*. Because `React.memo` performs a shallow comparison (which checks if the `numbers` prop's reference has changed), it will see that the reference is still the same, even though the array's contents have changed. As a result, `React.memo` will incorrectly decide that the `numbers` prop has not changed, and `DisplayNumbers` will **not** re-render, leading to stale UI.",
          "analysisPoints": [
            "Demonstrates understanding of `React.memo`'s shallow comparison.",
            "Highlights the importance of immutability with memoized components.",
            "Explains why mutating an array and passing the same reference prevents re-renders.",
            "Explains why creating a new array reference triggers re-renders."
          ],
          "keyConcepts": [
            "React.memo",
            "shallow comparison",
            "immutability",
            "array mutation",
            "state update",
            "re-rendering"
          ],
          "evaluationCriteria": [
            "Ability to debug and explain re-render behavior with `React.memo`.",
            "Understanding of shallow comparison implications for complex data types.",
            "Knowledge of immutable updates in React state."
          ],
          "example": "To confirm, run the provided code with each option. With OPTION 1, 'DisplayNumbers rendered' will not log again after the initial render, even after clicking 'Add Number'. With OPTION 2, it will log every time 'Add Number' is clicked.",
          "tags": [
            "react",
            "performance",
            "react-memo",
            "state",
            "immutability",
            "javascript"
          ],
          "prerequisites": [
            "react_state",
            "javascript_array_methods",
            "react_memo"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_flashcard_react_memo_arguments",
          "topic": "React.memo",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two arguments that can be passed to `React.memo`?",
          "answer": "1. The functional component to be memoized. \n2. (Optional) A custom comparison function (`areEqual`) that determines if props are equal.",
          "keyConcepts": [
            "React.memo",
            "arguments",
            "functional component",
            "custom comparison"
          ],
          "evaluationCriteria": [
            "Recall of `React.memo`'s signature."
          ],
          "tags": [
            "react",
            "react-memo",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_react_memo_return_true_false",
          "topic": "React.memo",
          "level": "medium",
          "type": "flashcard",
          "question": "If you provide a custom comparison function to `React.memo`, what should it return if the component should *not* re-render?",
          "answer": "`true` (if `prevProps` and `nextProps` are considered equal, thus skipping re-render).",
          "keyConcepts": [
            "React.memo",
            "custom comparison",
            "areEqual",
            "re-rendering"
          ],
          "evaluationCriteria": [
            "Recall of `areEqual` function's return value logic."
          ],
          "tags": [
            "react",
            "react-memo",
            "flashcard"
          ],
          "prerequisites": [
            "react_memo"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_purecomponent_how_it_works_1",
          "topic": "React.PureComponent",
          "level": "easy",
          "type": "mcq",
          "question": "How does `React.PureComponent` automatically optimize re-renders for class components?",
          "answer": "It implements `shouldComponentUpdate` with a shallow comparison of props and state.",
          "options": [
            "It automatically memoizes the render function.",
            "It uses a deep comparison of all props and state.",
            "It only re-renders if the component's internal state changes.",
            "It implements `shouldComponentUpdate` with a shallow comparison of props and state."
          ],
          "analysisPoints": [
            "The core mechanism of `PureComponent` is its overridden `shouldComponentUpdate`.",
            "This `shouldComponentUpdate` performs a shallow comparison, not a deep one.",
            "It re-renders based on prop *or* state changes, not just state.",
            "Memoization is a concept, but specifically, it's about the `shouldComponentUpdate` check."
          ],
          "keyConcepts": [
            "React.PureComponent",
            "shouldComponentUpdate",
            "shallow comparison",
            "class components",
            "re-rendering"
          ],
          "evaluationCriteria": [
            "Understanding of `PureComponent`'s underlying mechanism.",
            "Differentiating shallow from deep comparison."
          ],
          "example": "```typescript\nclass MyPureComponent extends React.PureComponent {\n  render() {\n    // This will only render if props or state change shallowly\n    return <div>{this.props.value}</div>;\n  }\n}\n```",
          "tags": [
            "react",
            "performance",
            "purecomponent"
          ],
          "prerequisites": [
            "react_class_components",
            "react_lifecycle"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_purecomponent_shallow_comparison_issue_1",
          "topic": "React.PureComponent",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where using `React.PureComponent` (or `React.memo` without a custom comparison) might lead to a component *not* re-rendering when it logically should, and how to address this.",
          "answer": "This scenario typically occurs when a component receives a prop that is an object or an array, and that object/array is mutated *in place* rather than being replaced with a new one. Since `React.PureComponent` (and `React.memo`) performs a shallow comparison, it only checks if the reference of the prop has changed, not its internal contents.\n\n**Scenario Example:**\nConsider a `PureComponent` called `ItemList` that receives an array of `items` as a prop:\n\n```typescript\nclass ItemList extends React.PureComponent {\n  render() {\n    console.log('ItemList rendered');\n    return (\n      <ul>\n        {this.props.items.map(item => <li key={item.id}>{item.name}</li>)}\n      </ul>\n    );\n  }\n}\n\nclass Parent extends React.Component {\n  state = { \n    data: [{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }] \n  };\n\n  addItem = () => {\n    // Mutating the existing array\n    this.state.data.push({ id: this.state.data.length + 1, name: 'New Item' });\n    this.setState({ data: this.state.data }); // Setting state with the same reference\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.addItem}>Add Item (Faulty)</button>\n        <ItemList items={this.state.data} />\n      </div>\n    );\n  }\n}\n```\nWhen `addItem` is called, the `data` array is mutated directly (`push`). Then `setState` is called, but the `data` prop passed to `ItemList` still has the *same reference* as before. `ItemList` (being a `PureComponent`) will see that `prevProps.items` and `nextProps.items` are referentially equal, and thus `shouldComponentUpdate` will return `false`, preventing the component from re-rendering and displaying the new item.\n\n**How to address this:**\nThe solution is to always treat props and state as immutable when working with `PureComponent` or `React.memo`. Instead of mutating the original object/array, create a *new* object or array with the desired changes. This ensures that the reference changes, triggering `PureComponent`'s shallow comparison to return `true` and cause a re-render.\n\n**Corrected `addItem`:**\n```typescript\n  addItem = () => {\n    // Creating a new array to trigger re-render\n    this.setState(prevState => ({\n      data: [...prevState.data, { id: prevState.data.length + 1, name: 'New Item' }]\n    }));\n  };\n```\nThis creates a new array for `data`, so `ItemList` receives a new prop reference and re-renders correctly.",
          "analysisPoints": [
            "Clearly describes the mutable data scenario.",
            "Provides a concrete code example of the problem.",
            "Explains why the shallow comparison fails in this case.",
            "Offers the correct solution using immutability (spreading/new object creation)."
          ],
          "keyConcepts": [
            "React.PureComponent",
            "React.memo",
            "shallow comparison",
            "immutability",
            "mutable data",
            "re-rendering issues",
            "state management"
          ],
          "evaluationCriteria": [
            "Ability to identify and explain a common pitfall of shallow comparison.",
            "Provision of a clear example.",
            "Presentation of a correct and idiomatic React solution."
          ],
          "example": "See the provided code example in the answer.",
          "tags": [
            "react",
            "performance",
            "purecomponent",
            "immutability",
            "bugs",
            "state-management"
          ],
          "prerequisites": [
            "react_state_props",
            "javascript_objects_arrays"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_purecomponent_override_shouldcomponentupdate_1",
          "topic": "React.PureComponent",
          "level": "easy",
          "type": "flashcard",
          "question": "Can you override `shouldComponentUpdate` in a `React.PureComponent`? What is the consequence?",
          "answer": "Yes, you can. However, doing so overrides `PureComponent`'s built-in shallow comparison, effectively negating its primary benefit and making it behave like a regular `React.Component` unless your custom `shouldComponentUpdate` explicitly re-implements memoization logic.",
          "keyConcepts": [
            "React.PureComponent",
            "shouldComponentUpdate",
            "override",
            "performance",
            "consequences"
          ],
          "evaluationCriteria": [
            "Recall of `PureComponent`'s behavior with `shouldComponentUpdate`."
          ],
          "tags": [
            "react",
            "purecomponent",
            "lifecycle",
            "flashcard"
          ],
          "prerequisites": [
            "react_lifecycle"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_purecomponent_vs_memo_1",
          "topic": "React.PureComponent",
          "level": "medium",
          "type": "code",
          "question": "You have a complex class component that extends `React.Component`. You want to optimize its performance by preventing unnecessary re-renders. Refactor the component to use `React.PureComponent` instead. Provide a small code snippet demonstrating the change and explain why this is an improvement.",
          "answer": "Original Component (before optimization):\n```typescript\nimport React from 'react';\n\nclass UnoptimizedDisplay extends React.Component {\n  render() {\n    console.log('UnoptimizedDisplay rendered');\n    return (\n      <div>\n        <p>Value: {this.props.value}</p>\n        <p>Label: {this.props.label}</p>\n      </div>\n    );\n  }\n}\n\n// Parent usage example:\n// class Parent extends React.Component {\n//   state = { count: 0 };\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n//           Update Parent ({this.state.count})\n//         </button>\n//         <UnoptimizedDisplay value={10} label=\"Fixed Label\" />\n//       </div>\n//     );\n//   }\n// }\n```\n\nOptimized Component using `React.PureComponent`:\n\n```typescript\nimport React from 'react';\n\nclass OptimizedDisplay extends React.PureComponent {\n  render() {\n    console.log('OptimizedDisplay rendered');\n    return (\n      <div>\n        <p>Value: {this.props.value}</p>\n        <p>Label: {this.props.label}</p>\n      </div>\n    );\n  }\n}\n\n// Parent usage example:\nfunction ParentOptimized() {\n  const [count, setCount] = React.useState(0);\n  const fixedLabel = \"Fixed Label\";\n  const fixedValue = 10;\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>\n        Update Parent ({count})\n      </button>\n      <OptimizedDisplay value={fixedValue} label={fixedLabel} />\n    </div>\n  );\n}\n```\n\n**Explanation of Improvement:**\n\nBy changing `extends React.Component` to `extends React.PureComponent`, the `OptimizedDisplay` component automatically inherits a `shouldComponentUpdate` method. This method performs a shallow comparison of the component's current `props` and `state` with its next `props` and `state`.\n\nIn the `ParentOptimized` example, when the `count` state changes, `ParentOptimized` re-renders. However, the `value` (10) and `label` (\"Fixed Label\") props passed to `OptimizedDisplay` remain referentially (and value-wise) the same. Because `OptimizedDisplay` is a `PureComponent`, its `shouldComponentUpdate` will return `false`, preventing it from re-rendering unnecessarily. The `console.log('OptimizedDisplay rendered')` will therefore only appear on the initial mount, and not on subsequent parent re-renders when the props haven't changed.\n\nThis is an improvement because it saves React from performing the rendering work (reconciling the virtual DOM, potentially updating the real DOM) for `OptimizedDisplay` when its output would be identical, leading to better performance, especially for complex or deeply nested components.",
          "analysisPoints": [
            "Correctly refactors the class component to extend `React.PureComponent`.",
            "Clearly explains the mechanism (automatic shallow comparison via `shouldComponentUpdate`).",
            "Demonstrates the performance benefit with a clear example (prevents re-render when parent updates but props don't change).",
            "Highlights the 'why' behind the improvement (saving rendering work)."
          ],
          "keyConcepts": [
            "React.PureComponent",
            "shouldComponentUpdate",
            "re-rendering",
            "performance optimization",
            "class components",
            "shallow comparison"
          ],
          "evaluationCriteria": [
            "Ability to apply `PureComponent` for optimization.",
            "Understanding of the performance mechanism.",
            "Clarity of the explanation.",
            "Correctness of code snippet."
          ],
          "example": "See the code in the answer.",
          "tags": [
            "react",
            "performance",
            "purecomponent",
            "code-challenge",
            "refactoring"
          ],
          "prerequisites": [
            "react_class_components",
            "react_state_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flashcard_purecomponent_behavior",
          "topic": "React.PureComponent",
          "level": "easy",
          "type": "flashcard",
          "question": "What kind of comparison does `React.PureComponent` use for its props and state?",
          "answer": "Shallow comparison.",
          "keyConcepts": [
            "React.PureComponent",
            "shallow comparison",
            "props",
            "state"
          ],
          "evaluationCriteria": [
            "Recall of `PureComponent`'s comparison type."
          ],
          "tags": [
            "react",
            "purecomponent",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_lazy_suspense_purpose_1",
          "topic": "React.lazy and React.Suspense",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary benefit of using `React.lazy` and `React.Suspense` together?",
          "answer": "To enable code splitting, reducing initial bundle size and improving load times.",
          "options": [
            "To provide server-side rendering capabilities.",
            "To perform deep prop comparisons for performance.",
            "To enable code splitting, reducing initial bundle size and improving load times.",
            "To manage global state across the application."
          ],
          "analysisPoints": [
            "Code splitting is the core feature enabled by `React.lazy` and `Suspense`.",
            "Reducing initial bundle size and improving load times are the direct benefits.",
            "SSR requires more advanced setups (like `@loadable/component`) beyond basic `React.lazy`.",
            "Deep prop comparison is related to `shouldComponentUpdate` or custom `React.memo` functions, not `lazy`/`Suspense`.",
            "State management is handled by Context API, Redux, etc."
          ],
          "keyConcepts": [
            "React.lazy",
            "React.Suspense",
            "code splitting",
            "lazy loading",
            "bundle size",
            "performance"
          ],
          "evaluationCriteria": [
            "Understanding of the main purpose and benefits.",
            "Differentiating from other React features."
          ],
          "example": "```typescript\nconst MyLazyComponent = React.lazy(() => import('./MyHeavyComponent'));\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <MyLazyComponent />\n    </Suspense>\n  );\n}\n```\nHere, `MyHeavyComponent`'s code is only loaded when `MyLazyComponent` is first rendered.",
          "tags": [
            "react",
            "code-splitting",
            "lazy-loading",
            "suspense"
          ],
          "prerequisites": [
            "javascript_modules"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lazy_suspense_fallback_1",
          "topic": "React.lazy and React.Suspense",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `fallback` prop in `React.Suspense`?",
          "answer": "It specifies the UI to display while the lazy-loaded components within the `Suspense` boundary are loading.",
          "keyConcepts": [
            "React.Suspense",
            "fallback",
            "lazy loading",
            "loading indicator"
          ],
          "evaluationCriteria": [
            "Recall of `Suspense`'s primary prop and its function."
          ],
          "tags": [
            "react",
            "suspense",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_lazy_suspense_benefits_1",
          "topic": "React.lazy and React.Suspense",
          "level": "medium",
          "type": "open",
          "question": "Beyond initial load time, what other benefits does code splitting with `React.lazy` and `React.Suspense` offer to a React application?",
          "answer": "Beyond improving initial load time, code splitting with `React.lazy` and `React.Suspense` offers several other significant benefits:\n\n1.  **Improved User Experience**: A faster initial load translates directly to a better user experience. Users perceive the application as more responsive and snappier, reducing bounce rates and increasing engagement.\n2.  **Better Resource Utilization**: Only the code necessary for the current view or functionality is downloaded. This conserves user bandwidth and reduces the amount of data transferred, which is particularly beneficial for users on limited data plans or slower network connections.\n3.  **Reduced Memory Footprint**: Less JavaScript code is parsed and executed upfront, which can lead to lower memory consumption in the browser. This is helpful for devices with limited memory.\n4.  **Better Caching**: Smaller, separate chunks of code can be cached independently by the browser. If only a small part of the application changes, users only need to download the updated chunk, rather than the entire large bundle.\n5.  **Faster Subsequent Loads**: Once a chunk is downloaded and cached, subsequent visits to features requiring that chunk will load almost instantly.\n6.  **Error Isolation**: If there's an error in a dynamically loaded chunk, it might not prevent the rest of the application from rendering or functioning correctly, as opposed to a single monolithic bundle where a single error might crash the entire app.",
          "analysisPoints": [
            "Lists multiple benefits beyond just initial load time.",
            "Explains how each benefit contributes to a better application.",
            "Covers user experience, resource utilization, caching, and error handling."
          ],
          "keyConcepts": [
            "code splitting",
            "React.lazy",
            "React.Suspense",
            "user experience",
            "bandwidth",
            "caching",
            "memory consumption"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of code splitting advantages.",
            "Ability to articulate the impact on different aspects of application performance and user interaction."
          ],
          "example": "An e-commerce site might lazy-load the checkout page component only when a user clicks 'Checkout', preventing unnecessary code download for users who are just browsing products.",
          "tags": [
            "react",
            "code-splitting",
            "performance",
            "architecture"
          ],
          "prerequisites": [
            "web_performance",
            "javascript_modules"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lazy_suspense_ssr_1",
          "topic": "React.lazy and React.Suspense",
          "level": "hard",
          "type": "open",
          "question": "Are `React.lazy` and `React.Suspense` directly compatible with Server-Side Rendering (SSR)? If not, what considerations or alternative solutions exist?",
          "answer": "`React.lazy` and `React.Suspense` are primarily designed for client-side code splitting and hydration. They are **not directly compatible with traditional Server-Side Rendering (SSR)** out-of-the-box.\n\n**Why they are not directly compatible:**\nWhen a server renders a React application, it needs synchronous access to all components to generate the full HTML string. `React.lazy` relies on dynamic `import()` statements, which are asynchronous. The server wouldn't know which code chunks to load and would likely fail when trying to render a lazy component without its corresponding code being immediately available.\n\n**Considerations and Alternative Solutions:**\n1.  **Hydration Mismatch**: If the server renders a fallback (e.g., `Loading...`) while the client expects a full component (which is lazy-loaded), it can lead to a hydration mismatch, causing re-renders or even errors on the client side.\n\n2.  **External Libraries**: For SSR with code splitting, developers typically use specialized libraries that integrate with build tools (like Webpack) to handle this complexity:\n    *   **`@loadable/component`**: This is a very popular solution. It provides a `loadable` HOC that works similarly to `React.lazy` but is designed for SSR. It allows you to specify components to be loaded dynamically, and during SSR, it collects the necessary bundles so they can be synchronously rendered on the server and then preloaded on the client.\n    *   **Next.js Dynamic Imports**: Frameworks like Next.js have their own built-in `next/dynamic` feature, which is an abstraction over `@loadable/component` (or similar logic) to handle code splitting and SSR seamlessly. It allows you to import components dynamically while still ensuring they are properly rendered on the server.\n\n3.  **No Code Splitting on Server**: An alternative is to simply bundle all code together for server-side rendering, and only apply code splitting for the client-side bundle. This means the server-rendered HTML will include all components, and the client will then hydrate it, potentially downloading smaller chunks for future interactions. This sacrifices the 'smallest initial HTML' benefit but simplifies SSR setup.\n\nIn summary, while `React.lazy` and `Suspense` are powerful for client-side performance, SSR requires specific tooling or frameworks to handle the asynchronous nature of dynamic imports during the server-side rendering process.",
          "analysisPoints": [
            "Clearly states the incompatibility with traditional SSR.",
            "Explains the technical reason (asynchronous nature of `import()`).",
            "Discusses the hydration mismatch issue.",
            "Provides specific, widely used alternative solutions (`@loadable/component`, Next.js dynamic imports).",
            "Mentions the simpler workaround of no code splitting on the server side."
          ],
          "keyConcepts": [
            "React.lazy",
            "React.Suspense",
            "SSR (Server-Side Rendering)",
            "code splitting",
            "hydration",
            "loadable/component",
            "Next.js"
          ],
          "evaluationCriteria": [
            "Deep understanding of `lazy`/`Suspense` limitations.",
            "Knowledge of SSR principles and challenges.",
            "Familiarity with common solutions and trade-offs."
          ],
          "example": "Using `@loadable/component` for SSR-compatible lazy loading:\n```typescript\n// Client-side:\nimport loadable from '@loadable/component';\nconst MyComponent = loadable(() => import('./MyComponent'));\n\n// On the server, @loadable/server handles collecting chunks:\n// import { ChunkExtractor } from '@loadable/server';\n// const extractor = new ChunkExtractor({ statsFile });\n// const jsx = extractor.collectChunks(<MyComponent />);\n// const html = renderToString(jsx);\n```",
          "tags": [
            "react",
            "code-splitting",
            "ssr",
            "performance",
            "advanced-react"
          ],
          "prerequisites": [
            "react_lazy_suspense",
            "ssr_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_flashcard_react_lazy",
          "topic": "React.lazy and React.Suspense",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `React.lazy` allow you to do with components?",
          "answer": "It allows you to lazy-load (dynamically import) components, rendering a dynamic `import()` as a regular React component.",
          "keyConcepts": [
            "React.lazy",
            "lazy loading",
            "dynamic import",
            "code splitting"
          ],
          "evaluationCriteria": [
            "Recall of `React.lazy`'s function."
          ],
          "tags": [
            "react",
            "lazy-loading",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_react_suspense",
          "topic": "React.lazy and React.Suspense",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the role of `React.Suspense` in code splitting?",
          "answer": "It allows you to display a fallback UI while code for lazy-loaded components is being downloaded.",
          "keyConcepts": [
            "React.Suspense",
            "fallback",
            "code splitting",
            "loading state"
          ],
          "evaluationCriteria": [
            "Recall of `React.Suspense`'s role in the lazy loading pattern."
          ],
          "tags": [
            "react",
            "suspense",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_code_splitting",
          "topic": "React.lazy and React.Suspense",
          "level": "easy",
          "type": "flashcard",
          "question": "What is 'code splitting' in web development?",
          "answer": "Code splitting is a technique to break a large JavaScript bundle into smaller chunks that can be loaded on demand, improving initial page load times.",
          "keyConcepts": [
            "code splitting",
            "bundle size",
            "lazy loading",
            "performance"
          ],
          "evaluationCriteria": [
            "Recall of the definition of code splitting."
          ],
          "tags": [
            "web-performance",
            "webpack",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_snapshot_testing",
          "topic": "React Component Testing Best Practices",
          "level": "easy",
          "type": "flashcard",
          "question": "What is snapshot testing primarily used for?",
          "answer": "To ensure the UI of a component does not unintentionally change over time by comparing its rendered output to a saved snapshot.",
          "keyConcepts": [
            "snapshot testing",
            "UI consistency",
            "regression testing"
          ],
          "evaluationCriteria": [
            "Recall of snapshot testing's main purpose."
          ],
          "tags": [
            "testing",
            "jest",
            "snapshot"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_test_behavior",
          "topic": "React Component Testing Best Practices",
          "level": "easy",
          "type": "flashcard",
          "question": "What does 'test behavior, not implementation' mean in unit testing?",
          "answer": "It means testing what the component *does* from a user's perspective (its observable outputs) rather than *how* it does it (its internal methods or state).",
          "keyConcepts": [
            "behavioral testing",
            "unit testing",
            "implementation details",
            "refactoring"
          ],
          "evaluationCriteria": [
            "Recall of the core principle of behavioral testing."
          ],
          "tags": [
            "testing",
            "best-practices",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_unnecessary_re_renders",
          "topic": "React Performance Optimization",
          "level": "easy",
          "type": "flashcard",
          "question": "Why are unnecessary re-renders a performance concern in React?",
          "answer": "They cause React to perform redundant reconciliation and potentially DOM updates, wasting CPU cycles and leading to slower UI updates and a less responsive application.",
          "keyConcepts": [
            "re-renders",
            "performance",
            "reconciliation",
            "DOM updates"
          ],
          "evaluationCriteria": [
            "Recall of the impact of re-renders on performance."
          ],
          "tags": [
            "react",
            "performance",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_component_testing_with_best_practices",
          "title": "Implement a Toggle Button and Test with Best Practices",
          "description": "\nImplement a simple `ToggleButton` React component and write a comprehensive test suite for it, adhering to the specified testing best practices.\n\n**Component Requirements:**\n1.  The `ToggleButton` should accept `initialState` (boolean, default `false`) and `onToggle` (function) props.\n2.  It should display text indicating its current state (e.g., 'ON' or 'OFF').\n3.  Clicking the button should toggle its internal state and call the `onToggle` prop with the new state.\n\n**Testing Requirements:**\n1.  Use `@testing-library/react`.\n2.  **Snapshot Testing**: Include a snapshot test to ensure the component's structure remains consistent.\n3.  **Behavioral Testing**: Write a test that verifies the button toggles its state and calls `onToggle` correctly. Focus on user perception, not internal state details.\n4.  **`data-testid`**: Use `data-testid` for selecting elements in your behavioral tests.\n5.  **Edge Cases**: Test that the component correctly initializes with `initialState`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// --- Component File: ToggleButton.tsx ---\nexport function ToggleButton({ initialState = false, onToggle }) {\n  const [isOn, setIsOn] = React.useState(initialState);\n\n  const handleClick = () => {\n    const newState = !isOn;\n    setIsOn(newState);\n    onToggle(newState);\n  };\n\n  return (\n    <button onClick={handleClick} data-testid=\"toggle-button\">\n      {isOn ? 'ON' : 'OFF'}\n    </button>\n  );\n}\n\n// --- Test File: ToggleButton.test.tsx ---\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport renderer from 'react-test-renderer';\nimport { ToggleButton } from './ToggleButton';\n\ndescribe('ToggleButton', () => {\n  // Implement tests here\n\n  test('should render correctly and match snapshot', () => {\n    // TODO: Implement snapshot test\n    const component = renderer.create(\n      <ToggleButton onToggle={() => {}} />\n    );\n    let tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should toggle state and call onToggle when clicked', () => {\n    // TODO: Implement behavioral test using data-testid\n    const mockOnToggle = jest.fn();\n    render(<ToggleButton onToggle={mockOnToggle} initialState={false} />);\n    \n    const button = screen.getByTestId('toggle-button');\n    expect(button).toHaveTextContent('OFF');\n\n    fireEvent.click(button);\n    expect(button).toHaveTextContent('ON');\n    expect(mockOnToggle).toHaveBeenCalledWith(true);\n    expect(mockOnToggle).toHaveBeenCalledTimes(1);\n\n    fireEvent.click(button);\n    expect(button).toHaveTextContent('OFF');\n    expect(mockOnToggle).toHaveBeenCalledWith(false);\n    expect(mockOnToggle).toHaveBeenCalledTimes(2);\n  });\n\n  test('should initialize with provided initialState', () => {\n    // TODO: Implement test for initialState\n    const mockOnToggle = jest.fn();\n    render(<ToggleButton onToggle={mockOnToggle} initialState={true} />);\n    \n    const button = screen.getByTestId('toggle-button');\n    expect(button).toHaveTextContent('ON');\n\n    fireEvent.click(button);\n    expect(button).toHaveTextContent('OFF');\n    expect(mockOnToggle).toHaveBeenCalledWith(false);\n  });\n\n});\n",
          "solutionCode": "import React from 'react';\n\n// --- Component File: ToggleButton.tsx ---\nexport function ToggleButton({ initialState = false, onToggle }) {\n  const [isOn, setIsOn] = React.useState(initialState);\n\n  const handleClick = () => {\n    const newState = !isOn;\n    setIsOn(newState);\n    onToggle(newState);\n  };\n\n  return (\n    <button onClick={handleClick} data-testid=\"toggle-button\">\n      {isOn ? 'ON' : 'OFF'}\n    </button>\n  );\n}\n\n// --- Test File: ToggleButton.test.tsx ---\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport renderer from 'react-test-renderer';\nimport { ToggleButton } from './ToggleButton';\n\ndescribe('ToggleButton', () => {\n\n  test('should render correctly and match snapshot', () => {\n    const component = renderer.create(\n      <ToggleButton onToggle={() => {}} />\n    );\n    let tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should toggle state and call onToggle when clicked', () => {\n    const mockOnToggle = jest.fn();\n    render(<ToggleButton onToggle={mockOnToggle} initialState={false} />);\n    \n    const button = screen.getByTestId('toggle-button');\n    expect(button).toHaveTextContent('OFF');\n\n    fireEvent.click(button);\n    expect(button).toHaveTextContent('ON');\n    expect(mockOnToggle).toHaveBeenCalledWith(true);\n    expect(mockOnToggle).toHaveBeenCalledTimes(1);\n\n    fireEvent.click(button);\n    expect(button).toHaveTextContent('OFF');\n    expect(mockOnToggle).toHaveBeenCalledWith(false);\n    expect(mockOnToggle).toHaveBeenCalledTimes(2);\n  });\n\n  test('should initialize with provided initialState', () => {\n    const mockOnToggle = jest.fn();\n    render(<ToggleButton onToggle={mockOnToggle} initialState={true} />);\n    \n    const button = screen.getByTestId('toggle-button');\n    expect(button).toHaveTextContent('ON');\n\n    fireEvent.click(button);\n    expect(button).toHaveTextContent('OFF');\n    expect(mockOnToggle).toHaveBeenCalledWith(false);\n  });\n\n  test('should call onToggle with the correct new state after multiple clicks', () => {\n    const mockOnToggle = jest.fn();\n    render(<ToggleButton onToggle={mockOnToggle} initialState={false} />);\n    const button = screen.getByTestId('toggle-button');\n    \n    fireEvent.click(button); // OFF -> ON\n    fireEvent.click(button); // ON -> OFF\n    fireEvent.click(button); // OFF -> ON\n\n    expect(mockOnToggle).toHaveBeenCalledTimes(3);\n    expect(mockOnToggle).toHaveBeenLastCalledWith(true); // Last call was to set ON\n  });\n\n});\n",
          "testCases": [
            "The component should render 'OFF' by default and match its snapshot.",
            "Clicking the button should change its text from 'OFF' to 'ON' and call `onToggle` with `true`.",
            "Clicking again should change text from 'ON' to 'OFF' and call `onToggle` with `false`.",
            "The `onToggle` mock function should be called the correct number of times.",
            "The component should render 'ON' if `initialState` is set to `true`.",
            "After initializing with `true`, a click should change it to 'OFF' and call `onToggle` with `false`."
          ],
          "hints": [
            "Remember that `renderer.create` is used for snapshot testing, while `render` from `@testing-library/react` is for DOM-based tests.",
            "Use `jest.fn()` to create mock functions for callbacks like `onToggle` and assert on their calls.",
            "For `data-testid`, use `screen.getByTestId('your-id')` to select elements.",
            "Focus on `toHaveTextContent` for UI state and `toHaveBeenCalledWith`/`toHaveBeenCalledTimes` for function calls.",
            "Snapshot tests capture the full component tree, so ensure your component's rendering is stable."
          ],
          "tags": [
            "react",
            "testing",
            "unit-testing",
            "jest",
            "react-testing-library",
            "best-practices",
            "frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_react_testing_best_practices",
            "react_functional_components",
            "jest_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "snapshot_testing",
            "behavioral_testing",
            "data_testid",
            "mocking"
          ]
        },
        {
          "id": "task_optimize_functional_component_with_memo",
          "title": "Optimize a Functional Component using `React.memo`",
          "description": "\nCreate two React functional components: a `ParentComponent` and an `ExpensiveChild`. Optimize `ExpensiveChild` using `React.memo` to prevent unnecessary re-renders.\n\n**Component Requirements:**\n1.  **`ExpensiveChild` (Functional Component):**\n    *   Accepts a `data` prop (an array of objects: `{ id: number, name: string }`).\n    *   Logs 'ExpensiveChild rendered' to the console every time it renders.\n    *   Renders a list of items from its `data` prop.\n    *   **Optimize it using `React.memo`.**\n2.  **`ParentComponent` (Functional Component):**\n    *   Manages an `integer` state (`count`).\n    *   Manages an `array` state (`items`) which is passed as `data` to `ExpensiveChild`.\n    *   Has a button to increment `count`.\n    *   Has a button to add a new item to `items` (ensure this operation correctly triggers a re-render of `ExpensiveChild`).\n    *   Ensure the `items` prop passed to `ExpensiveChild` is stable using `useMemo` when it's not meant to change.\n\n**Verification:**\n*   Observe console logs: `ExpensiveChild` should *not* re-render when only `ParentComponent`'s `count` changes.\n*   `ExpensiveChild` *should* re-render when a new item is added to `items`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// --- ExpensiveChild.tsx ---\nfunction ExpensiveChild({ data }) {\n  console.log('ExpensiveChild rendered');\n  return (\n    <div style={{ border: '1px solid gray', padding: '10px', margin: '10px' }}>\n      <h3>Expensive Child Component</h3>\n      <ul>\n        {data.map(item => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// TODO: Wrap ExpensiveChild with React.memo here\nconst MemoizedExpensiveChild = ExpensiveChild; // Replace this line\n\n// --- ParentComponent.tsx ---\nexport function ParentComponent() {\n  const [count, setCount] = React.useState(0);\n  const [items, setItems] = React.useState([\n    { id: 1, name: 'Item A' },\n    { id: 2, name: 'Item B' }\n  ]);\n\n  // TODO: Ensure `fixedItems` doesn't cause unnecessary re-renders\n  const fixedItems = React.useMemo(() => [\n    { id: 100, name: 'Fixed Item X' },\n    { id: 101, name: 'Fixed Item Y' }\n  ], []);\n\n  const addNewItem = () => {\n    // TODO: Ensure this correctly updates the `items` array to trigger re-render in MemoizedExpensiveChild\n    setItems(prevItems => [...prevItems, { id: prevItems.length + 1, name: `New Item ${prevItems.length + 1}` }]);\n  };\n\n  return (\n    <div style={{ border: '1px solid blue', padding: '20px' }}>\n      <h2>Parent Component</h2>\n      <button onClick={() => setCount(count + 1)}>\n        Increment Parent Count: {count}\n      </button>\n      <button onClick={addNewItem}>Add New Item to Child Data</button>\n      \n      {/* Pass the optimized child here */}\n      <MemoizedExpensiveChild data={fixedItems} />\n      <hr />\n      <MemoizedExpensiveChild data={items} />\n    </div>\n  );\n}\n",
          "solutionCode": "import React from 'react';\n\n// --- ExpensiveChild.tsx ---\nfunction ExpensiveChild({ data }) {\n  console.log('ExpensiveChild rendered');\n  return (\n    <div style={{ border: '1px solid gray', padding: '10px', margin: '10px' }}>\n      <h3>Expensive Child Component</h3>\n      <ul>\n        {data.map(item => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Wrapped with React.memo for optimization\nconst MemoizedExpensiveChild = React.memo(ExpensiveChild);\n\n// --- ParentComponent.tsx ---\nexport function ParentComponent() {\n  const [count, setCount] = React.useState(0);\n  const [items, setItems] = React.useState([\n    { id: 1, name: 'Item A' },\n    { id: 2, name: 'Item B' }\n  ]);\n\n  // fixedItems is memoized using useMemo to ensure its reference doesn't change\n  // on ParentComponent re-renders, thereby not triggering MemoizedExpensiveChild.\n  const fixedItems = React.useMemo(() => [\n    { id: 100, name: 'Fixed Item X' },\n    { id: 101, name: 'Fixed Item Y' }\n  ], []);\n\n  const addNewItem = () => {\n    // Creating a new array reference to trigger re-render in MemoizedExpensiveChild\n    setItems(prevItems => [...prevItems, { id: prevItems.length + 1, name: `New Item ${prevItems.length + 1}` }]);\n  };\n\n  return (\n    <div style={{ border: '1px solid blue', padding: '20px' }}>\n      <h2>Parent Component</h2>\n      <button onClick={() => setCount(count + 1)}>\n        Increment Parent Count: {count}\n      </button>\n      <button onClick={addNewItem}>Add New Item to Child Data</button>\n      \n      {/* This instance will only re-render if fixedItems (reference) changes */}\n      <MemoizedExpensiveChild data={fixedItems} />\n      <hr />\n      {/* This instance will re-render if `items` (reference) changes */}\n      <MemoizedExpensiveChild data={items} />\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: Both 'ExpensiveChild rendered' logs should appear once.",
            "Click 'Increment Parent Count': Only 'Parent Component' should re-render. Neither 'ExpensiveChild rendered' log should appear again for `fixedItems` or `items` (before 'Add New Item' is clicked for `items`).",
            "Click 'Add New Item to Child Data': The `MemoizedExpensiveChild` receiving `items` should re-render. The `MemoizedExpensiveChild` receiving `fixedItems` should *not* re-render.",
            "Verify that new items are correctly displayed in the `items`-fed `ExpensiveChild`."
          ],
          "hints": [
            "Remember that `React.memo` by default performs a shallow comparison of props.",
            "To ensure a prop does not change its reference when the parent re-renders, consider using `React.useMemo` for static or memoized values.",
            "When updating an array or object in state, always create a *new* array/object reference; never mutate the existing one directly if you want `React.memo` (or `PureComponent`) to detect the change."
          ],
          "tags": [
            "react",
            "performance",
            "react-memo",
            "useMemo",
            "functional-component",
            "optimization"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_react_memo",
            "react_hooks_useState_useMemo"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "shallow_comparison",
            "immutability",
            "re-rendering"
          ]
        },
        {
          "id": "task_optimize_class_component_with_purecomponent",
          "title": "Optimize a Class Component using `React.PureComponent`",
          "description": "\nRefactor a standard `React.Component` class component into a `React.PureComponent` to demonstrate performance optimization. Observe the effect on re-renders.\n\n**Component Requirements:**\n1.  **`DataDisplay` (Class Component):**\n    *   Initially, make it extend `React.Component`.\n    *   It should accept a `data` prop (an object like `{ value: number, label: string }`).\n    *   Logs 'DataDisplay rendered' to the console every time it renders.\n    *   Displays the `value` and `label` from its `data` prop.\n    *   **Refactor it to extend `React.PureComponent`.**\n2.  **`App` (Class Component or Functional):**\n    *   Manages a `count` state.\n    *   Manages a `config` state (an object like `{ theme: string, options: { debug: boolean } }`).\n    *   Pass `config` as the `data` prop to `DataDisplay`.\n    *   Include a button to increment `count` (should not re-render `DataDisplay`).\n    *   Include a button to change `config.theme` (should re-render `DataDisplay`).\n    *   Include a button to change `config.options.debug` (should *not* re-render `DataDisplay` if `config` object reference remains same).\n\n**Verification:**\n*   Observe console logs: `DataDisplay` should *not* re-render when only `App`'s `count` changes.\n*   `DataDisplay` *should* re-render when `config.theme` changes (by creating a new `config` object).\n*   `DataDisplay` should *not* re-render when `config.options.debug` changes *if* the `config` object itself is mutated rather than replaced.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\n// --- DataDisplay.tsx ---\nclass DataDisplay extends React.Component { // TODO: Change to React.PureComponent\n  render() {\n    console.log('DataDisplay rendered');\n    const { data } = this.props;\n    return (\n      <div style={{ border: '1px solid green', padding: '10px', margin: '10px' }}>\n        <h3>Data Display Component</h3>\n        <p>Theme: {data.theme}</p>\n        <p>Debug: {data.options.debug ? 'Enabled' : 'Disabled'}</p>\n      </div>\n    );\n  }\n}\n\n// --- App.tsx ---\nexport class App extends React.Component {\n  state = {\n    count: 0,\n    config: {\n      theme: 'light',\n      options: {\n        debug: false\n      }\n    }\n  };\n\n  handleIncrementCount = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  handleChangeTheme = () => {\n    this.setState(prevState => ({\n      config: { ...prevState.config, theme: prevState.config.theme === 'light' ? 'dark' : 'light' }\n    }));\n  };\n\n  handleToggleDebug = () => {\n    // TODO: This operation will NOT trigger re-render if not handled correctly for PureComponent\n    // Need to ensure new object reference for `options` and `config`.\n    this.setState(prevState => ({\n      config: {\n        ...prevState.config,\n        options: { ...prevState.config.options, debug: !prevState.config.options.debug }\n      }\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid red', padding: '20px' }}>\n        <h2>App Component</h2>\n        <button onClick={this.handleIncrementCount}>\n          Increment App Count: {this.state.count}\n        </button>\n        <button onClick={this.handleChangeTheme}>\n          Change Theme ({this.state.config.theme})\n        </button>\n        <button onClick={this.handleToggleDebug}>\n          Toggle Debug ({this.state.config.options.debug ? 'On' : 'Off'})\n        </button>\n        \n        <DataDisplay data={this.state.config} />\n      </div>\n    );\n  }\n}\n",
          "solutionCode": "import React from 'react';\n\n// --- DataDisplay.tsx ---\nclass DataDisplay extends React.PureComponent { // Changed to React.PureComponent\n  render() {\n    console.log('DataDisplay rendered');\n    const { data } = this.props;\n    return (\n      <div style={{ border: '1px solid green', padding: '10px', margin: '10px' }}>\n        <h3>Data Display Component</h3>\n        <p>Theme: {data.theme}</p>\n        <p>Debug: {data.options.debug ? 'Enabled' : 'Disabled'}</p>\n      </div>\n    );\n  }\n}\n\n// --- App.tsx ---\nexport class App extends React.Component {\n  state = {\n    count: 0,\n    config: {\n      theme: 'light',\n      options: {\n        debug: false\n      }\n    }\n  };\n\n  handleIncrementCount = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  handleChangeTheme = () => {\n    this.setState(prevState => ({\n      // Create new config object to trigger re-render\n      config: { ...prevState.config, theme: prevState.config.theme === 'light' ? 'dark' : 'light' }\n    }));\n  };\n\n  handleToggleDebug = () => {\n    // To trigger re-render for nested object changes, both the nested object\n    // AND the parent object (config) must be new references.\n    this.setState(prevState => ({\n      config: {\n        ...prevState.config,\n        options: { ...prevState.config.options, debug: !prevState.config.options.debug }\n      }\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid red', padding: '20px' }}>\n        <h2>App Component</h2>\n        <button onClick={this.handleIncrementCount}>\n          Increment App Count: {this.state.count}\n        </button>\n        <button onClick={this.handleChangeTheme}>\n          Change Theme ({this.state.config.theme})\n        </button>\n        <button onClick={this.handleToggleDebug}>\n          Toggle Debug ({this.state.config.options.debug ? 'On' : 'Off'})\n        </button>\n        \n        <DataDisplay data={this.state.config} />\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial render: 'DataDisplay rendered' should appear once.",
            "Click 'Increment App Count': `DataDisplay` should *not* re-render (no new 'DataDisplay rendered' log).",
            "Click 'Change Theme': `DataDisplay` *should* re-render (a new 'DataDisplay rendered' log should appear), and the displayed theme should change.",
            "Click 'Toggle Debug': `DataDisplay` *should* re-render (a new 'DataDisplay rendered' log should appear), and the displayed debug status should change (due to correct immutable update).",
            "Verify that if `handleToggleDebug` was initially implemented without creating a new `options` object (e.g., `prevState.config.options.debug = !prevState.config.options.debug; this.setState(prevState.config);`), `DataDisplay` would *not* re-render, demonstrating the shallow comparison limitation."
          ],
          "hints": [
            "The key to `React.PureComponent` detecting changes in props (especially objects) is that the *reference* to the prop object must change.",
            "When updating nested objects in state, you must create new objects for every level of the nested structure that has changed, all the way up to the top-level state property. Use the spread operator (`...`) for this.",
            "Pay close attention to the console logs to verify re-render behavior."
          ],
          "tags": [
            "react",
            "performance",
            "purecomponent",
            "class-component",
            "immutability",
            "optimization",
            "frontend"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_react_purecomponent",
            "react_class_components",
            "javascript_objects_arrays"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "shallow_comparison",
            "state_management",
            "re-rendering"
          ]
        },
        {
          "id": "task_implement_lazy_loading_with_suspense",
          "title": "Implement Lazy Loading and Fallback UI with `React.lazy` and `React.Suspense`",
          "description": "\nCreate a React application that dynamically loads a 'heavy' component only when needed, using `React.lazy` and `React.Suspense`.\n\n**Component Requirements:**\n1.  **`App` Component (Main Application):**\n    *   Contains a button that, when clicked, sets a state variable (`showHeavyComponent`) to `true`.\n    *   Conditionally renders the `HeavyComponent` only when `showHeavyComponent` is `true`.\n2.  **`HeavyComponent` (Separate File):**\n    *   Simulate a 'heavy' component by performing a small, time-consuming operation (e.g., generating a large array) within its render function. \n    *   Logs 'HeavyComponent loaded and rendered' to the console upon rendering.\n    *   Export it as a `default` export.\n\n**Implementation Requirements:**\n1.  Use `React.lazy` to dynamically import `HeavyComponent`.\n2.  Wrap the `HeavyComponent` with `React.Suspense`.\n3.  Provide a clear `fallback` UI for `Suspense` (e.g., 'Loading Heavy Component...').\n\n**Verification:**\n*   Initial page load: `HeavyComponent`'s log should *not* appear.\n*   Clicking the button: The fallback UI should momentarily appear, followed by `HeavyComponent`'s content and its console log.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Suspense } from 'react';\n\n// --- App.tsx ---\n// TODO: Use React.lazy to import HeavyComponent dynamically\n// const HeavyComponent = ...\n\n// --- HeavyComponent.tsx (create this file separately) ---\n// const HeavyComponent = () => {\n//   // Simulate a heavy operation (e.g., generate a large array)\n//   const items = Array.from({ length: 5000 }, (_, i) => `Simulated Heavy Item ${i}`);\n//   console.log('HeavyComponent loaded and rendered');\n//   return (\n//     <div style={{ border: '1px dashed orange', padding: '15px', marginTop: '20px' }}>\n//       <h2>Heavy Component Content</h2>\n//       <p>This component was lazy-loaded!</p>\n//       {/* Render a small part or skip rendering the full list if too large */}\n//       <p>First item: {items[0]}</p>\n//     </div>\n//   );\n// };\n// export default HeavyComponent;\n\n// --- Main App Component ---\nexport function App() {\n  const [showHeavyComponent, setShowHeavyComponent] = React.useState(false);\n\n  return (\n    <div style={{ border: '1px solid purple', padding: '20px' }}>\n      <h1>Main Application</h1>\n      <button onClick={() => setShowHeavyComponent(true)}>\n        Load Heavy Component\n      </button>\n\n      {showHeavyComponent && (\n        // TODO: Wrap the dynamically imported component with Suspense\n        // <Suspense fallback={...}> \n        //   <HeavyComponent />\n        // </Suspense>\n        <div>Placeholder for Heavy Component</div> // Replace this\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { Suspense } from 'react';\n\n// --- App.tsx ---\n// Dynamically import HeavyComponent using React.lazy\nconst HeavyComponent = React.lazy(() => import('./HeavyComponent'));\n\n// --- HeavyComponent.tsx (in a separate file) ---\n/*\n// HeavyComponent.tsx\nimport React from 'react';\n\nconst HeavyComponent = () => {\n  // Simulate a heavy operation (e.g., generate a large array)\n  const items = Array.from({ length: 5000 }, (_, i) => `Simulated Heavy Item ${i}`);\n  console.log('HeavyComponent loaded and rendered');\n  return (\n    <div style={{ border: '1px dashed orange', padding: '15px', marginTop: '20px' }}>\n      <h2>Heavy Component Content</h2>\n      <p>This component was lazy-loaded!</p>\n      <p>First item: {items[0]}</p>\n      {/ * Render a small part or skip rendering the full list if too large * /}\n    </div>\n  );\n};\n\nexport default HeavyComponent;\n*/\n\n// --- Main App Component ---\nexport function App() {\n  const [showHeavyComponent, setShowHeavyComponent] = React.useState(false);\n\n  return (\n    <div style={{ border: '1px solid purple', padding: '20px' }}>\n      <h1>Main Application</h1>\n      <button onClick={() => setShowHeavyComponent(true)}>\n        Load Heavy Component\n      </button>\n\n      {showHeavyComponent && (\n        <Suspense fallback={<div>Loading Heavy Component...</div>}>\n          <HeavyComponent />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n",
          "testCases": [
            "Verify that 'HeavyComponent loaded and rendered' does NOT appear in the console on initial page load.",
            "Click the 'Load Heavy Component' button.",
            "Observe that 'Loading Heavy Component...' text appears briefly.",
            "Observe that 'HeavyComponent loaded and rendered' appears in the console after the fallback text disappears.",
            "Verify that the content of `HeavyComponent` (e.g., 'Heavy Component Content', 'This component was lazy-loaded!') is visible on the screen."
          ],
          "hints": [
            "Ensure `HeavyComponent.tsx` is in a separate file and exported as a `default` export.",
            "`React.lazy` takes a function that returns `import('./path/to/component')`.",
            "`React.Suspense` needs a `fallback` prop, which can be any valid React element.",
            "Use your browser's network tab to confirm that the `HeavyComponent`'s chunk is only downloaded after the button click."
          ],
          "tags": [
            "react",
            "code-splitting",
            "lazy-loading",
            "suspense",
            "performance",
            "frontend"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_react_lazy_suspense",
            "react_functional_components",
            "javascript_modules"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "dynamic_import",
            "webpack",
            "bundle_size"
          ]
        }
      ]
    }
  },
  {
    "id": "fa01e8b0-1fc1-4e16-a16b-6acd0002ad67",
    "startLine": 5200,
    "endLine": 5299,
    "processedDate": "2025-06-17T09:28:15.913Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_performance_hooks",
          "title": "React Performance Optimization with useMemo and useCallback",
          "content": "## Introduction to React Performance Hooks\nIn React, components re-render when their state or props change. While React is generally efficient, unnecessary re-renders of expensive computations or re-creation of callback functions can impact application performance, especially in large or frequently updated component trees. React provides `useMemo` and `useCallback` hooks to help optimize functional components by memoizing values and functions.\n\n## useMemo Hook\n`useMemo` is a React Hook that lets you cache the result of an expensive calculation between re-renders. It takes two arguments: a 'create' function and a dependency array. The 'create' function will only re-run if one of the dependencies in the array has changed. If the dependencies are the same as in the last render, `useMemo` returns the cached value.\n\n### When to use useMemo:\n-   **Expensive Calculations:** When you have a function that performs a computationally intensive task (e.g., heavy filtering, sorting, or data transformation) and its result is only needed when its inputs change.\n-   **Referential Equality:** When passing objects or arrays as props to child components that are wrapped in `React.memo`. `React.memo` performs a shallow comparison of props; if an object/array prop is re-created on every render (even if its content is the same), `React.memo` will see it as a new prop and trigger a re-render of the child. `useMemo` helps maintain referential equality.\n\n```typescript\nimport React, { useMemo } from 'react';\n\nfunction ComponentWithExpensiveCalculation({ data, filterCriteria }) {\n  // This calculation will only re-run if 'data' or 'filterCriteria' changes.\n  const filteredData = useMemo(() => {\n    console.log('Performing expensive filtering...');\n    return data.filter(item => item.includes(filterCriteria));\n  }, [data, filterCriteria]);\n\n  return (\n    <div>\n      {filteredData.map((item, index) => <p key={index}>{item}</p>)}\n    </div>\n  );\n}\n```\n\n## useCallback Hook\n`useCallback` is a React Hook that lets you cache a function definition between re-renders. Like `useMemo`, it takes a function and a dependency array. It returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is particularly useful when passing callbacks to optimized child components.\n\n### When to use useCallback:\n-   **Preventing Unnecessary Re-renders of Child Components:** When a parent component re-renders, any functions defined within it are re-created. If these functions are passed as props to child components (especially those optimized with `React.memo`), the child components will re-render because the prop (the function) is technically a new reference. `useCallback` ensures the function reference remains the same unless its dependencies change.\n-   **Optimizing Event Handlers:** Memoizing event handlers prevents them from being re-created on every render, which can be beneficial when passing them to many child elements or when they are part of a dependency array for another hook (like `useEffect`).\n\n```typescript\nimport React, { useState, useCallback, memo } from 'react';\n\nconst Button = memo(({ onClick, label }) => {\n  console.log(`Button '${label}' rendered`);\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  // This function will not be re-created on every render\n  // unless 'count' changes.\n  const increment = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []); // Empty dependency array means it's created once\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Button onClick={increment} label=\"Increment\" />\n      <button onClick={() => setCount(count + 1)}>Direct Increment</button>\n    </div>\n  );\n}\n```\n\n## Key Differences and Considerations\n-   `useMemo` memoizes a **value** returned by a function.\n-   `useCallback` memoizes a **function** itself.\n-   Both require a dependency array. An empty array `[]` means the memoized value/function will only be created once on the initial render.\n-   Overuse of `useMemo` and `useCallback` can introduce unnecessary overhead. They should be used strategically where actual performance bottlenecks are identified or when dealing with referential equality issues for `React.memo`'d components.",
          "examples": [
            {
              "id": "example_react_performance_hooks_1",
              "title": "Basic useMemo for Filtering",
              "code": "import React, { useState, useMemo } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  category: string;\n}\n\ninterface SearchResultsProps {\n  items: Item[];\n  query: string;\n}\n\nfunction SearchResults({ items, query }: SearchResultsProps) {\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...'); // This log helps identify re-runs\n    if (!query) return items;\n    return items.filter(item => \n      item.name.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [items, query]); // Recalculate only when items or query changes\n  \n  return (\n    <div>\n      <h2>Search Results for \"{query}\"</h2>\n      <ul>\n        {filteredItems.map(item => (\n          <li key={item.id}>{item.name} ({item.category})</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Example Usage (for demonstration, not part of the component itself)\nfunction App() {\n  const allItems: Item[] = [\n    { id: 1, name: 'Apple', category: 'Fruit' },\n    { id: 2, name: 'Banana', category: 'Fruit' },\n    { id: 3, name: 'Carrot', category: 'Vegetable' },\n    { id: 4, name: 'Broccoli', category: 'Vegetable' },\n  ];\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search items...\"\n        value={searchQuery}\n        onChange={(e) => setSearchQuery(e.target.value)}\n      />\n      <SearchResults items={allItems} query={searchQuery} />\n    </div>\n  );\n}\n",
              "explanation": "This example demonstrates `useMemo` for an `items` filtering operation. The `console.log` inside `useMemo` helps visualize when the filtering function re-executes. It will only re-run if `items` or `query` changes, preventing redundant filtering when other state in the `SearchResults` component or its parent causes a re-render.",
              "language": "typescript"
            },
            {
              "id": "example_react_performance_hooks_2",
              "title": "Basic useCallback for Event Handlers",
              "code": "import React, { useState, useCallback } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n}\n\ninterface SearchResultsProps {\n  items: Item[];\n  query: string;\n}\n\nfunction SearchResults({ items, query }: SearchResultsProps) {\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...');\n    return items.filter(item => \n      item.name.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [items, query]);\n  \n  // Memoize callback functions\n  const handleItemClick = useCallback((id: number) => {\n    console.log('Item clicked:', id);\n    // In a real application, this would dispatch an action, navigate, etc.\n  }, []); // Empty dependency array ensures this function reference never changes\n  \n  return (\n    <ul>\n      {filteredItems.map(item => (\n        <li key={item.id} onClick={() => handleItemClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Example Usage (for demonstration)\nfunction App() {\n  const allItems: Item[] = [\n    { id: 1, name: 'Laptop', },\n    { id: 2, name: 'Mouse', },\n    { id: 3, name: 'Keyboard', },\n  ];\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search items...\"\n        value={searchQuery}\n        onChange={(e) => setSearchQuery(e.target.value)}\n      />\n      <SearchResults items={allItems} query={searchQuery} />\n    </div>\n  );\n}\n",
              "explanation": "This example shows `useCallback` used to memoize the `handleItemClick` function. By providing an empty dependency array (`[]`), this function is created only once during the initial render. This is crucial if `SearchResults` passes `handleItemClick` to a `React.memo` optimized child component, as it prevents the child from re-rendering due to a new function reference being passed down.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_hooks_1",
            "question_react_hooks_2",
            "question_react_hooks_3",
            "question_react_hooks_4",
            "question_react_hooks_5",
            "question_react_hooks_6",
            "question_react_hooks_7",
            "question_react_hooks_8"
          ],
          "relatedTasks": [
            "task_react_performance_hooks_1"
          ],
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "useCallback",
            "Performance",
            "Optimization",
            "Frontend"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Functional_Components",
            "React_State_Hooks",
            "JavaScript_Closures"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced_React_Performance",
            "Custom_React_Hooks"
          ]
        },
        {
          "id": "theory_react_testing_library",
          "title": "React Component Testing with React Testing Library (RTL)",
          "content": "## Introduction to React Testing Library (RTL)\nReact Testing Library (RTL) is a set of utilities for testing React components. Its guiding principle is to help you write tests that resemble how your users would interact with your application. This is often summarized as: \"The more your tests resemble the way your software is used, the more confidence they can give you.\"\n\n### Key Principles of RTL:\n-   **User-centric Testing:** Focuses on querying the DOM as a user would, prioritizing accessibility attributes (e.g., `getByRole`, `getByLabelText`).\n-   **Avoids Implementation Details:** Discourages testing internal component state or methods, instead focusing on the component's output in the DOM.\n-   **Works with Real DOM:** Components are rendered into a real DOM environment (usually via `jsdom` in a Node.js environment like Jest), allowing for realistic interactions.\n\n### Core Utilities and API:\n-   `render`: Renders a React component into a container attached to `document.body`.\n-   `screen`: An object that contains all the queries exposed by RTL, making them globally accessible after a `render` call (e.g., `screen.getByText`).\n-   `fireEvent`: A utility for dispatching DOM events (e.g., `click`, `change`, `submit`) on elements. It mimics native browser events.\n-   Queries: Methods used to find elements in the rendered output. They are prioritized by accessibility:\n    -   `getByRole`: The primary way to find elements, as it reflects how assistive technologies perceive the page.\n    -   `getByLabelText`: Useful for form elements associated with a label.\n    -   `getByPlaceholderText`: For input fields with placeholder text.\n    -   `getByText`: For finding elements containing specific text content.\n    -   `getByDisplayValue`: For input, textarea, or select elements that currently have the given value.\n    -   `getByAltText`: For image elements (e.g., `<img>`) with `alt` attributes.\n    -   `getByTestId`: A fallback query, to be used only when other semantic queries are not possible.\n-   `@testing-library/jest-dom`: Provides custom Jest matchers that are specifically designed for testing the DOM (e.g., `toBeInTheDocument`, `toHaveTextContent`, `toBeDisabled`, `toBeVisible`).\n\n### Testing Event Handlers Workflow:\n1.  **Render the Component:** Use `render()` to mount your component.\n2.  **Mock Callbacks (if needed):** Use `jest.fn()` to create mock functions for any callbacks (props) that your component might invoke (e.g., `onSubmit`, `onClick`). This allows you to assert if and how they were called.\n3.  **Find Elements:** Use `screen` queries to locate the DOM elements you want to interact with (inputs, buttons).\n4.  **Simulate User Events:** Use `fireEvent` to trigger events on these elements, mimicking user interaction (typing, clicking, submitting).\n5.  **Assert Outcomes:** Use Jest's `expect` and `jest-dom` matchers to verify:\n    -   If the mock functions were called with the correct arguments.\n    -   If the DOM updated as expected (e.g., element text changed, element appeared/disappeared).\n\n```typescript\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect'; // For custom matchers\nimport LoginForm from './LoginForm'; // Assume this component exists\n\n// Mock component for LoginForm\n// type LoginFormProps = { onSubmit: (data: { username: string; password: string }) => void; };\n// function LoginForm({ onSubmit }: LoginFormProps) {\n//   const [username, setUsername] = useState('');\n//   const [password, setPassword] = useState('');\n//\n//   const handleSubmit = (e: React.FormEvent) => {\n//     e.preventDefault();\n//     onSubmit({ username, password });\n//   };\n//\n//   return (\n//     <form onSubmit={handleSubmit}>\n//       <div>\n//         <label htmlFor=\"username-input\">Username</label>\n//         <input id=\"username-input\" value={username} onChange={(e) => setUsername(e.target.value)} />\n//       </div>\n//       <div>\n//         <label htmlFor=\"password-input\">Password</label>\n//         <input id=\"password-input\" type=\"password\" value={password} onChange={(e) => setPassword(e.target.value)} />\n//       </div>\n//       <button type=\"submit\">Submit</button>\n//     </form>\n//   );\n// }\n\ntest('calls onSubmit with username and password when form is submitted', () => {\n  const handleSubmit = jest.fn(); // Create a mock function\n  render(<LoginForm onSubmit={handleSubmit} />); // Render the component\n  \n  // Fill out the form by finding elements via their associated labels\n  fireEvent.change(screen.getByLabelText(/username/i), { // Find username input (case-insensitive regex)\n    target: { value: 'testuser' }, // Simulate typing 'testuser'\n  });\n  \n  fireEvent.change(screen.getByLabelText(/password/i), { // Find password input\n    target: { value: 'password123' }, // Simulate typing 'password123'\n  });\n  \n  // Submit the form by finding the button by its role and name\n  fireEvent.click(screen.getByRole('button', { name: /submit/i }));\n  \n  // Assert that the onSubmit handler was called with correct arguments\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n  expect(handleSubmit).toHaveBeenCalledWith({\n    username: 'testuser',\n    password: 'password123',\n  });\n});\n```",
          "examples": [
            {
              "id": "example_react_testing_library_1",
              "title": "Testing a simple Button click",
              "code": "import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\n\ninterface MyButtonProps {\n  onClick: () => void;\n  label: string;\n}\n\nfunction MyButton({ onClick, label }: MyButtonProps) {\n  return <button onClick={onClick}>{label}</button>;\n}\n\ntest('MyButton calls onClick when clicked', () => {\n  const handleClick = jest.fn();\n  render(<MyButton onClick={handleClick} label=\"Click Me\" />);\n  \n  const buttonElement = screen.getByText(/Click Me/i);\n  fireEvent.click(buttonElement);\n  \n  expect(handleClick).toHaveBeenCalledTimes(1);\n});\n",
              "explanation": "This example shows how to test a simple button component. It renders the `MyButton`, finds it by its text content, simulates a click event using `fireEvent.click`, and then asserts that the `onClick` mock function was called exactly once.",
              "language": "typescript"
            },
            {
              "id": "example_react_testing_library_2",
              "title": "Testing input change and display",
              "code": "import React, { useState } from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\n\nfunction NameDisplay() {\n  const [name, setName] = useState('');\n\n  return (\n    <div>\n      <label htmlFor=\"name-input\">Enter Name:</label>\n      <input\n        id=\"name-input\"\n        type=\"text\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n      />\n      <p>Hello, {name || 'Guest'}!</p>\n    </div>\n  );\n}\n\ntest('NameDisplay updates greeting message on input change', () => {\n  render(<NameDisplay />);\n  \n  const inputElement = screen.getByLabelText(/Enter Name:/i);\n  const greetingElement = screen.getByText(/Hello, Guest!/i);\n  \n  // Initial state check\n  expect(greetingElement).toHaveTextContent('Hello, Guest!');\n  \n  // Simulate typing\n  fireEvent.change(inputElement, { target: { value: 'Alice' } });\n  \n  // Assert updated state\n  expect(inputElement).toHaveValue('Alice');\n  expect(greetingElement).toHaveTextContent('Hello, Alice!');\n});\n",
              "explanation": "This example tests a component that takes user input and displays it. It uses `getByLabelText` to find the input field and `getByText` to find the initial greeting. After simulating a change event with a new value, it asserts that the input's value has updated and that the greeting message reflects the new input.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_rtl_1",
            "question_rtl_2",
            "question_rtl_3",
            "question_rtl_4",
            "question_rtl_5",
            "question_rtl_6",
            "question_rtl_7",
            "question_rtl_8"
          ],
          "relatedTasks": [
            "task_react_testing_library_1"
          ],
          "tags": [
            "React",
            "Testing",
            "React Testing Library",
            "RTL",
            "Jest",
            "Frontend",
            "Unit Testing",
            "Integration Testing"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Functional_Components",
            "Jest_Basics",
            "DOM_Manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Test_Driven_Development",
            "Enterprise_React_Applications"
          ]
        },
        {
          "id": "theory_enzyme_testing",
          "title": "React Component Testing with Enzyme",
          "content": "## Introduction to Enzyme\nEnzyme is a JavaScript testing utility for React that makes it easier to test React Components' output. Developed by Airbnb, it provides a simpler API for interacting with React components during tests. Unlike React Testing Library, Enzyme focuses more on testing component internals and lifecycle methods rather than strictly user-centric behavior.\n\n### Key Concepts and API:\n-   **Wrapper Object:** Enzyme's `shallow`, `mount`, and `render` methods return a `Wrapper` object, which is an abstraction over the rendered component. This wrapper provides methods for finding elements, simulating events, accessing state/props, and inspecting component structure.\n-   **`find(selector)`:** Used to locate nodes within the component's output. Selectors can be CSS-like (e.g., `'button'`, `'.my-class'`, `'#my-id'`), component names (e.g., `MyComponent`), or prop selectors (`'[data-testid=\"count\"]'`).\n-   **`simulate(event, mockEvent)`:** Used to trigger events on elements. The `event` argument is a string (e.g., `'click'`, `'change'`, `'submit'`), and `mockEvent` can be an optional object to simulate event properties (e.g., `{ target: { value: 'newValue' } }`).\n-   **`text()`:** Returns the concatenated text contents of the current node and all its children.\n-   **`props()`:** Returns the props of the root component in the wrapper.\n-   **`state()`:** Returns the state of the root component in the wrapper.\n\n### Rendering Methods:\nEnzyme offers three distinct ways to render components for testing, each suitable for different scenarios:\n\n#### 1. Shallow Rendering (`shallow`)\n-   **Description:** Renders only the component being tested, without rendering its child components. Child components are represented as their React component types (e.g., `<ChildComponent />`) rather than their actual DOM output.\n-   **Use Cases:** Ideal for unit testing individual components in isolation. It prevents tests from being coupled to the implementation details of child components, making tests faster and more robust to changes in children.\n-   **Pros:** Fast, isolated, doesn't require a DOM environment, easier to test component's own logic and lifecycle methods.\n-   **Cons:** Cannot test interactions between parent and deeply nested children, or full DOM interactions.\n\n```typescript\nimport React from 'react';\nimport { shallow } from 'enzyme';\nimport Counter from './Counter';\n\ndescribe('Counter Component (Shallow)', () => {\n  it('renders initial count', () => {\n    const wrapper = shallow(<Counter initialCount={5} />);\n    expect(wrapper.find('[data-testid=\"count\"]').text()).toBe('5');\n  });\n\n  it('increments count when button is clicked', () => {\n    const wrapper = shallow(<Counter initialCount={0} />);\n    wrapper.find('button.increment').simulate('click'); // Assumes button has class 'increment'\n    expect(wrapper.find('[data-testid=\"count\"]').text()).toBe('1');\n  });\n\n  it('decrements count when button is clicked', () => {\n    const wrapper = shallow(<Counter initialCount={5} />);\n    wrapper.find('button.decrement').simulate('click'); // Assumes button has class 'decrement'\n    expect(wrapper.find('[data-testid=\"count\"]').text()).toBe('4');\n  });\n});\n```\n\n#### 2. Full DOM Rendering (`mount`)\n-   **Description:** Renders the component into a full DOM environment (like `jsdom`), including all of its children. This is closer to how a component would be rendered in a browser.\n-   **Use Cases:** Useful for integration testing, testing components that interact with the DOM API, or components that rely on their children's lifecycle methods.\n-   **Pros:** Tests component interactions with real DOM, provides access to lifecycle methods, allows testing of nested component interactions.\n-   **Cons:** Slower, requires a DOM environment, can lead to more brittle tests due to dependence on child component implementations.\n\n```typescript\nimport React from 'react';\nimport { mount } from 'enzyme';\nimport ParentComponent from './ParentComponent'; // Assumes ParentComponent renders ChildComponent\n\ndescribe('ParentComponent (Mount)', () => {\n  it('renders child component correctly', () => {\n    const wrapper = mount(<ParentComponent />);\n    expect(wrapper.find('ChildComponent').exists()).toBe(true);\n  });\n});\n```\n\n#### 3. Static Markup Rendering (`render`)\n-   **Description:** Renders React components to static HTML string. It's similar to `ReactDOMServer.renderToStaticMarkup`.\n-   **Use Cases:** For testing the rendered HTML output of a component, especially for components that don't need to interact with the DOM or have lifecycle methods.\n-   **Pros:** Very fast, simple, good for snapshot testing of rendered HTML.\n-   **Cons:** No access to React component instances, state, or lifecycle methods; cannot simulate events.\n\n**Note:** While Enzyme has been a popular choice, React Testing Library is now generally recommended by the React team for new projects due to its user-centric approach and better alignment with modern React practices.",
          "examples": [
            {
              "id": "example_enzyme_testing_1",
              "title": "Shallow Rendering with Counter Component",
              "code": "import React, { useState } from 'react';\nimport { shallow } from 'enzyme';\n\ninterface CounterProps {\n  initialCount?: number;\n}\n\nfunction Counter({ initialCount = 0 }: CounterProps) {\n  const [count, setCount] = useState(initialCount);\n\n  return (\n    <div>\n      <p data-testid=\"count\">{count}</p>\n      <button className=\"increment\" onClick={() => setCount(count + 1)}>Increment</button>\n      <button className=\"decrement\" onClick={() => setCount(count - 1)}>Decrement</button>\n    </div>\n  );\n}\n\ndescribe('Counter Component (Shallow)', () => {\n  it('renders initial count from props', () => {\n    const wrapper = shallow(<Counter initialCount={10} />);\n    expect(wrapper.find('[data-testid=\"count\"]').text()).toBe('10');\n  });\n\n  it('increments the count on button click', () => {\n    const wrapper = shallow(<Counter initialCount={0} />);\n    wrapper.find('button.increment').simulate('click');\n    expect(wrapper.find('[data-testid=\"count\"]').text()).toBe('1');\n  });\n\n  it('decrements the count on button click', () => {\n    const wrapper = shallow(<Counter initialCount={5} />);\n    wrapper.find('button.decrement').simulate('click');\n    expect(wrapper.find('[data-testid=\"count\"]').text()).toBe('4');\n  });\n});\n",
              "explanation": "This example shows how to use Enzyme's `shallow` rendering to test a `Counter` component. `shallow` ensures that only the `Counter` component itself is rendered, not any potential child components. We find elements using `data-testid` or CSS class selectors and simulate clicks to verify state updates and displayed text.",
              "language": "typescript"
            },
            {
              "id": "example_enzyme_testing_2",
              "title": "Mount Rendering with Parent-Child Interaction",
              "code": "import React, { useState } from 'react';\nimport { mount } from 'enzyme';\n\ninterface ChildProps {\n  onButtonClick: (value: string) => void;\n}\n\nfunction ChildComponent({ onButtonClick }: ChildProps) {\n  return (\n    <button onClick={() => onButtonClick('Hello from Child!')}>Child Button</button>\n  );\n}\n\nfunction ParentComponent() {\n  const [message, setMessage] = useState('No message yet');\n\n  const handleChildButtonClick = (msg: string) => {\n    setMessage(msg);\n  };\n\n  return (\n    <div>\n      <p data-testid=\"parent-message\">{message}</p>\n      <ChildComponent onButtonClick={handleChildButtonClick} />\n    </div>\n  );\n}\n\ndescribe('ParentComponent (Mount)', () => {\n  it('updates parent message when child button is clicked', () => {\n    const wrapper = mount(<ParentComponent />);\n    \n    // Verify initial state\n    expect(wrapper.find('[data-testid=\"parent-message\"]').text()).toBe('No message yet');\n    \n    // Simulate click on the button rendered by the ChildComponent\n    wrapper.find('button').simulate('click');\n    \n    // Assert that the parent's state (and displayed message) updated\n    expect(wrapper.find('[data-testid=\"parent-message\"]').text()).toBe('Hello from Child!');\n  });\n});\n",
              "explanation": "This example demonstrates `mount` rendering, which is necessary when testing interactions that cross component boundaries or involve the full DOM. Here, clicking a button inside `ChildComponent` triggers a prop function (`onButtonClick`), which in turn updates the state in `ParentComponent`. `mount` allows us to simulate the click on the child's button and then assert the visual change in the parent.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_enzyme_1",
            "question_enzyme_2",
            "question_enzyme_3",
            "question_enzyme_4",
            "question_enzyme_5",
            "question_enzyme_6",
            "question_enzyme_7",
            "question_enzyme_8"
          ],
          "relatedTasks": [
            "task_enzyme_testing_1"
          ],
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "Shallow",
            "Mount",
            "Jest",
            "Frontend",
            "Unit Testing"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Functional_Components",
            "Jest_Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Legacy_React_Projects",
            "Understanding_Testing_Approaches"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_hooks_1",
          "topic": "useMemo Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useMemo` hook in React?",
          "answer": "`useMemo` is used to memoize the result of an expensive calculation or value, preventing it from being re-calculated on every re-render unless its dependencies change.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useMemo",
            "Memoization",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of core hook purpose"
          ],
          "example": null,
          "tags": [
            "React",
            "useMemo",
            "Hooks",
            "Performance"
          ],
          "prerequisites": [
            "React_Functional_Components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_hooks_2",
          "topic": "useCallback Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useCallback` hook in React?",
          "answer": "`useCallback` is used to memoize a callback function, preventing it from being re-created on every re-render unless its dependencies change. This helps optimize performance, especially when passing callbacks to `React.memo` wrapped child components.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useCallback",
            "Memoization",
            "Performance",
            "Referential Equality"
          ],
          "evaluationCriteria": [
            "Understanding of core hook purpose"
          ],
          "example": null,
          "tags": [
            "React",
            "useCallback",
            "Hooks",
            "Performance"
          ],
          "prerequisites": [
            "React_Functional_Components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_hooks_3",
          "topic": "useMemo vs useCallback",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements accurately describes the difference between `useMemo` and `useCallback`?",
          "answer": "`useMemo` memoizes a value, while `useCallback` memoizes a function.",
          "options": [
            "`useMemo` memoizes a value, while `useCallback` memoizes a function.",
            "`useMemo` is for asynchronous operations, while `useCallback` is for synchronous ones.",
            "Both `useMemo` and `useCallback` memoize values, but `useCallback` is specifically for event handlers.",
            "`useMemo` runs only once, while `useCallback` runs on every render.",
            "They are interchangeable and serve the same purpose."
          ],
          "analysisPoints": [
            "The core distinction between the two hooks lies in what they memoize: `useMemo` for values, `useCallback` for functions.",
            "Understanding that both rely on dependency arrays for re-computation/re-creation.",
            "Recognizing that `useCallback` is often used for event handlers, but its fundamental purpose is function memoization."
          ],
          "keyConcepts": [
            "useMemo",
            "useCallback",
            "Memoization",
            "Value Memoization",
            "Function Memoization",
            "Referential Equality"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between the primary uses of `useMemo` and `useCallback`.",
            "Knowledge of what each hook returns/memoizes."
          ],
          "example": "```typescript\nimport React, { useMemo, useCallback, useState } from 'react';\n\nfunction MyComponent({ data }) {\n  // useMemo: memoizes the result of filter operation (a new array/value)\n  const filteredData = useMemo(() => {\n    return data.filter(item => item.isActive);\n  }, [data]);\n\n  // useCallback: memoizes the function itself\n  const handleClick = useCallback(() => {\n    console.log('Button clicked!');\n  }, []);\n\n  return (\n    <div>\n      {filteredData.length > 0 && <p>Active items: {filteredData.length}</p>}\n      <button onClick={handleClick}>Click Me</button>\n    </div>\n  );\n}\n```\nIn this example, `filteredData` holds a memoized array (a value), and `handleClick` holds a memoized function.",
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "useCallback",
            "Comparison",
            "MCQ"
          ],
          "prerequisites": [
            "theory_react_performance_hooks"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_hooks_4",
          "topic": "useMemo and useCallback Dependencies",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of the dependency array in `useMemo` and `useCallback`. What happens if it's omitted or if it's an empty array `[]`?",
          "answer": "The dependency array (`deps`) is a crucial second argument for both `useMemo` and `useCallback`. It tells React when the memoized value or function needs to be re-computed/re-created. \n\n-   **Role:** React will only re-run the `create` function (for `useMemo`) or re-create the callback function (for `useCallback`) if any of the values in the `deps` array have changed since the last render (compared using strict equality, `===`). If all dependencies are the same, the previously memoized value/function is returned.\n\n-   **Omitted Dependency Array:** If the dependency array is completely omitted, the `create` function (for `useMemo`) or the callback function (for `useCallback`) will **re-run/re-create on every single render** of the component. This effectively negates the purpose of using `useMemo` or `useCallback` for performance optimization, as you're not caching anything.\n\n-   **Empty Array `[]`:** If an empty array `[]` is provided, it means that the memoized value or function will **only be created once** on the initial render of the component and will never be re-computed/re-created on subsequent renders, regardless of how many times the component re-renders. This is useful for values or functions that truly do not depend on any props or state within the component's lifetime. However, care must be taken as it can lead to stale closures if the function or value relies on mutable variables from the component's scope that change over time.",
          "options": [],
          "analysisPoints": [
            "Understanding the core mechanism of memoization based on dependencies.",
            "Distinguishing between omitting the array (no memoization) and providing an empty array (memoize once).",
            "Awareness of potential 'stale closure' issues with empty dependency arrays."
          ],
          "keyConcepts": [
            "Dependency Array",
            "Memoization",
            "Stale Closures",
            "Referential Equality"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Correctness of behavior for omitted vs. empty array.",
            "Identification of potential pitfalls (stale closures)."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "Dependencies",
            "useMemo",
            "useCallback",
            "Open-Ended"
          ],
          "prerequisites": [
            "theory_react_performance_hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_hooks_5",
          "topic": "When not to use useMemo/useCallback",
          "level": "medium",
          "type": "mcq",
          "question": "Which scenario is LEAST likely to benefit significantly from `useMemo` or `useCallback`?",
          "answer": "A component with very few renders and simple calculations.",
          "options": [
            "A component with very few renders and simple calculations.",
            "Passing a callback to a `React.memo`'d child component.",
            "A computationally expensive data transformation inside a component that re-renders frequently.",
            "Rendering a large, dynamic list where each item has an `onClick` handler.",
            "Passing an object as a prop to a `React.memo`'d child component."
          ],
          "analysisPoints": [
            "The overhead of `useMemo`/`useCallback` (creating the memoized version, comparing dependencies) might outweigh the performance benefits for simple cases.",
            "Understanding that the primary benefits come from preventing redundant work (expensive calculations) or unnecessary re-renders of optimized children (due to referential equality)."
          ],
          "keyConcepts": [
            "Performance Optimization",
            "Overhead",
            "React.memo",
            "Premature Optimization"
          ],
          "evaluationCriteria": [
            "Ability to identify when memoization is not beneficial.",
            "Understanding the trade-offs of using these hooks."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Optimization",
            "Anti-Pattern",
            "MCQ"
          ],
          "prerequisites": [
            "theory_react_performance_hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_hooks_6",
          "topic": "useCallback practical application",
          "level": "hard",
          "type": "code",
          "question": "Consider a `Parent` component that renders a `Child` component. The `Child` component is wrapped with `React.memo`. The `Parent` passes a callback function to the `Child`. The `Parent` also has a counter state that updates frequently.\n\nWrite a minimal `Parent` and `Child` component. Demonstrate how `useCallback` can prevent unnecessary re-renders of the `Child` component when the `Parent`'s counter state updates.",
          "answer": "```typescript\nimport React, { useState, useCallback, memo } from 'react';\n\n// Child component wrapped with React.memo\ninterface ChildProps {\n  onAction: (message: string) => void;\n  someProp: string;\n}\n\nconst Child = memo(({ onAction, someProp }: ChildProps) => {\n  console.log('Child component rendered', { someProp });\n  return (\n    <button onClick={() => onAction(`Action from Child with prop: ${someProp}`)}>\n      Perform Action\n    </button>\n  );\n});\n\n// Parent component\nfunction Parent() {\n  const [counter, setCounter] = useState(0);\n  const [inputValue, setInputValue] = useState('');\n\n  // Scenario 1: Callback NOT memoized (will cause Child re-render on Parent counter change)\n  // const handleActionNonMemoized = (msg: string) => {\n  //   console.log('Non-memoized action:', msg, 'Counter:', counter);\n  // };\n\n  // Scenario 2: Callback memoized with useCallback\n  const handleActionMemoized = useCallback((msg: string) => {\n    console.log('Memoized action:', msg, 'Counter:', counter);\n  }, [counter]); // Dependency: re-create if 'counter' changes\n\n  return (\n    <div>\n      <h1>Parent Component</h1>\n      <p>Counter: {counter}</p>\n      <button onClick={() => setCounter(prev => prev + 1)}>\n        Increment Counter\n      </button>\n      <p>\n        <input \n          type=\"text\"\n          value={inputValue} \n          onChange={(e) => setInputValue(e.target.value)}\n          placeholder=\"Type something...\"\n        />\n      </p>\n\n      <h2>Child Component</h2>\n      {/* \n        If using handleActionNonMemoized, Child will re-render \n        every time Parent re-renders (e.g., counter change).\n        \n        If using handleActionMemoized, Child will only re-render \n        when 'counter' changes (due to its dependency).\n      */}\n      <Child onAction={handleActionMemoized} someProp={inputValue} />\n    </div>\n  );\n}\n\n// To run this in a React app:\n// export default Parent;\n\n// Expected Console Output (when only Increment Counter is clicked repeatedly):\n// Initial render: \"Child component rendered\" (once)\n// Subsequent clicks on Increment Counter: \"Memoized action:...\" only when child button clicked. \n//                                        \"Child component rendered\" only if `counter` changes (if `handleActionMemoized` depended on it). \n//                                        If `handleActionMemoized` had an empty `[]` dependency and child button wasn't clicked, \n//                                        `Child component rendered` would still only happen once.\n// With `[counter]` dependency, `Child` will re-render when `counter` changes.\n// To strictly prevent Child re-render with counter updates, `handleActionMemoized` would need `[]` if it doesn't depend on `counter`.\n// The question asks how `useCallback` *can* prevent re-renders, implying comparison.\n// The key is that `handleActionMemoized`'s reference *remains the same* as long as `counter` doesn't change.\n// If the goal is to prevent *any* re-render of Child unless `inputValue` changes, then the `onAction` should not depend on `counter`.\n// Corrected interpretation for strict non-re-render: The `useCallback` should have `[]` if the function *truly* does not need the latest `counter` value.\n// Or, the `handleActionMemoized` callback could take `counter` as a parameter if it needs it at the time of click.\n// The provided solution uses `[counter]` as a dependency, so `Child` *will* re-render if counter changes, but if it had `[]`, it would not.\n// Let's refine the solution and explanation for clarity.\n\n```typescript\nimport React, { useState, useCallback, memo } from 'react';\n\n// Child component wrapped with React.memo\ninterface ChildProps {\n  onAction: (message: string) => void;\n  someProp: string; // A prop that can change, affecting Child's re-render\n}\n\nconst Child = memo(({ onAction, someProp }: ChildProps) => {\n  console.log('Child component rendered (memoized)');\n  return (\n    <button onClick={() => onAction(`Action from Child with prop: ${someProp}`)}>\n      Perform Action\n    </button>\n  );\n});\n\n// Parent component\nfunction Parent() {\n  const [counter, setCounter] = useState(0);\n  const [inputValue, setInputValue] = useState('');\n\n  // This callback function reference will only change if inputValue changes.\n  // It does NOT depend on 'counter'.\n  const handleAction = useCallback((msg: string) => {\n    console.log(`Action: ${msg}. Current Parent counter (may be stale if no dependency): ${counter}`);\n  }, [inputValue]); // Depends on inputValue. If inputValue doesn't change, handleAction's ref is stable.\n  // If 'counter' was added here: `[inputValue, counter]`, then handleAction would re-create when counter changes.\n  // For demonstration of preventing re-render with `React.memo` on Child, `handleAction` needs a stable reference.\n  // An empty dependency array `[]` would make it most stable, but could lead to stale `counter` in its closure.\n  // Here, we demonstrate that even if `inputValue` changes, `handleAction` would still be stable *if* `inputValue` didn't change.\n  // The core point is that `useCallback` controls when the function reference changes.\n\n  // To make it truly independent of 'counter' for preventing Child re-renders, \n  // and also avoid stale 'counter' if needed for logic inside handleAction, \n  // a ref could be used, or the counter could be passed as a parameter.\n  // For the purpose of *preventing Child re-renders*, the key is a stable `onAction` reference.\n\n  const stableHandleAction = useCallback((msg: string) => {\n    // Here, if you need the latest counter, you might use a ref or pass it as a parameter\n    console.log(`Stable Action: ${msg}. Counter: ${counter} (from stable closure, potentially stale without ref)`);\n  }, []); // Empty dependency array: this function's reference is created only once.\n\n  return (\n    <div>\n      <h1>Parent Component</h1>\n      <p>Counter: {counter}</p>\n      <button onClick={() => setCounter(prev => prev + 1)}>\n        Increment Counter (causes Parent re-render)\n      </button>\n      <p>\n        <input \n          type=\"text\"\n          value={inputValue} \n          onChange={(e) => setInputValue(e.target.value)}\n          placeholder=\"Type something... (causes Parent re-render)\"\n        />\n      </p>\n\n      <h2>Child Component</h2>\n      {/* \n        If `stableHandleAction` is used with `[]` dependency, \n        Child component will only re-render if `someProp` (inputValue) changes. \n        It will NOT re-render when `counter` changes, because `onAction`'s reference remains stable.\n        Observe console.log('Child component rendered (memoized)')\n      */}\n      <Child onAction={stableHandleAction} someProp={inputValue} />\n      {/* \n        For comparison, if you used a non-memoized function like below,\n        Child would re-render on every Parent re-render (e.g., when counter changes).\n        <Child onAction={(msg) => console.log('Non-memoized action:', msg)} someProp={inputValue} />\n      */}\n    </div>\n  );\n}\n```\n\n**Explanation:**\n\n1.  **`Child` Component with `React.memo`:** The `Child` component is wrapped with `React.memo`. This means it will only re-render if its props (`onAction` or `someProp`) change (shallow comparison).\n2.  **`Parent` Component State:** `Parent` has `counter` state (updated by a button) and `inputValue` state (updated by an input field). Both cause `Parent` to re-render when changed.\n3.  **`stableHandleAction` with `useCallback([], [])`:**\n    *   The `onAction` prop passed to `Child` is `stableHandleAction`, which is memoized using `useCallback` with an **empty dependency array `[]`**.\n    *   This ensures that the `stableHandleAction` function's reference remains the **same across all re-renders of `Parent`**, unless the component unmounts and remounts.\n4.  **Observation:**\n    *   When you click \"Increment Counter\", the `Parent` component re-renders. However, because `stableHandleAction`'s reference has not changed and `someProp` (which is `inputValue`) has not changed, `React.memo` prevents the `Child` component from re-rendering.\n    *   You will see `console.log('Child component rendered (memoized)')` only when `inputValue` changes, or on initial mount. It will *not* log when only the `counter` is incremented. This demonstrates the performance benefit.\n\nThis example effectively shows how `useCallback` keeps the function reference stable, allowing `React.memo` to optimize child component re-renders, even when the parent component re-renders due to unrelated state changes.",
          "options": [],
          "analysisPoints": [
            "Correct implementation of `React.memo` on the child component.",
            "Proper usage of `useCallback` on the parent's function that is passed as a prop.",
            "Understanding that the dependency array determines when the memoized function is recreated.",
            "Ability to explain the observable performance benefit (reduced child re-renders)."
          ],
          "keyConcepts": [
            "useCallback",
            "React.memo",
            "Referential Equality",
            "Performance Optimization",
            "Child Re-renders",
            "Dependencies"
          ],
          "evaluationCriteria": [
            "Code correctness and functionality.",
            "Clear demonstration of the concept.",
            "Accurate explanation of the observed behavior.",
            "Understanding of the interaction between `useCallback` and `React.memo`."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useCallback",
            "React.memo",
            "Performance",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_react_performance_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_hooks_7",
          "topic": "useMemo practical application",
          "level": "hard",
          "type": "code",
          "question": "Imagine you have a component that displays a list of users. This list needs to be filtered based on a search term, and the filtering operation can be computationally expensive if the list is very large. The component also has a separate counter that updates frequently.\n\nWrite a React functional component that demonstrates how to use `useMemo` to optimize the filtering of the user list, ensuring the filtering only re-runs when the `users` array or `searchTerm` changes, but not when the unrelated `counter` state updates.",
          "answer": "```typescript\nimport React, { useState, useMemo } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Simulate a large user list\nconst ALL_USERS: User[] = Array.from({ length: 10000 }, (_, i) => ({\n  id: i + 1,\n  name: `User ${i + 1}`,\n  email: `user${i + 1}@example.com`,\n}));\n\nfunction UserListFilter() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [counter, setCounter] = useState(0); // Unrelated state\n\n  // Use useMemo to memoize the filtered users.\n  // This calculation will only re-run if ALL_USERS or searchTerm changes.\n  // It will NOT re-run when 'counter' changes.\n  const filteredUsers = useMemo(() => {\n    console.log('Filtering users...'); // This will log only when needed\n    if (!searchTerm) {\n      return ALL_USERS;\n    }\n    const lowerCaseSearchTerm = searchTerm.toLowerCase();\n    return ALL_USERS.filter(user => \n      user.name.toLowerCase().includes(lowerCaseSearchTerm) ||\n      user.email.toLowerCase().includes(lowerCaseSearchTerm)\n    );\n  }, [ALL_USERS, searchTerm]); // Dependencies: ALL_USERS and searchTerm\n\n  return (\n    <div>\n      <h1>User List Filter</h1>\n      \n      <label htmlFor=\"search-input\">Search Users:</label>\n      <input\n        id=\"search-input\"\n        type=\"text\"\n        placeholder=\"Search by name or email\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n      />\n\n      <p>Counter: {counter}</p>\n      <button onClick={() => setCounter(prev => prev + 1)}>\n        Increment Counter (unrelated to filtering)\n      </button>\n\n      <h2>Filtered Users ({filteredUsers.length} found)</h2>\n      <ul>\n        {filteredUsers.slice(0, 10).map(user => ( // Display first 10 for brevity\n          <li key={user.id}>{user.name} - {user.email}</li>\n        ))}\n      </ul>\n      {filteredUsers.length > 10 && <p>...</p>}\n    </div>\n  );\n}\n\n// To run this in a React app:\n// export default UserListFilter;\n\n// Expected Console Output:\n// 1. Initial render: \"Filtering users...\" (once)\n// 2. Typing in search box: \"Filtering users...\" (on each significant change)\n// 3. Clicking \"Increment Counter\": NO \"Filtering users...\" log (demonstrates optimization)\n",
          "options": [],
          "analysisPoints": [
            "Correct usage of `useMemo` for a data transformation.",
            "Proper identification of dependencies for the `useMemo` hook (only `searchTerm` and `ALL_USERS`).",
            "Demonstration that unrelated state changes do not trigger the memoized computation.",
            "Clear explanation of the performance benefit."
          ],
          "keyConcepts": [
            "useMemo",
            "Performance Optimization",
            "Data Transformation",
            "Dependencies",
            "Memoization"
          ],
          "evaluationCriteria": [
            "Code correctness and functionality.",
            "Effective use of `useMemo` to solve the stated problem.",
            "Clear demonstration of the optimization through `console.log` or similar.",
            "Understanding of when `useMemo` is appropriate."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "Performance",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_react_performance_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_hooks_8",
          "topic": "When to use React.memo",
          "level": "medium",
          "type": "flashcard",
          "question": "What is `React.memo` used for, and how does it relate to `useCallback` and `useMemo`?",
          "answer": "`React.memo` is a Higher-Order Component (HOC) used to memoize functional React components, preventing them from re-rendering if their props (and state, implicitly via internal hooks) have not changed. It performs a shallow comparison of props.\n\nIt relates to `useCallback` and `useMemo` because:\n-   If a `React.memo` wrapped component receives a function or object as a prop, and that prop's reference changes on every parent re-render (even if its content is the same), `React.memo` will see it as a new prop and still re-render the child.\n-   `useCallback` ensures that a function's reference remains stable, preventing unnecessary re-renders of `React.memo` wrapped child components when that function is passed as a prop.\n-   `useMemo` ensures that an object or array's reference remains stable, preventing unnecessary re-renders of `React.memo` wrapped child components when that object/array is passed as a prop.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React.memo",
            "HOC",
            "Memoization",
            "Referential Equality",
            "useCallback",
            "useMemo",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of `React.memo`'s role and its synergy with `useCallback`/`useMemo`."
          ],
          "example": null,
          "tags": [
            "React",
            "React.memo",
            "Hooks",
            "Performance",
            "Interview"
          ],
          "prerequisites": [
            "React_Functional_Components",
            "React_Props"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_1",
          "topic": "React Testing Library Philosophy",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core philosophy of React Testing Library (RTL)?",
          "answer": "The core philosophy of RTL is to write tests that resemble how users interact with the application, focusing on user behavior and accessibility, rather than implementation details.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Testing Library",
            "User-Centric Testing",
            "Accessibility"
          ],
          "evaluationCriteria": [
            "Understanding of RTL's guiding principle"
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Philosophy"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_rtl_2",
          "topic": "RTL Query Priority",
          "level": "medium",
          "type": "mcq",
          "question": "According to React Testing Library's best practices, which query method should you prioritize when trying to find an element in the DOM?",
          "answer": "`getByRole`",
          "options": [
            "`getByRole`",
            "`getByTestId`",
            "`getByClassName` (not an RTL query)",
            "`querySelector` (DOM API, not RTL)",
            "`getByText`"
          ],
          "analysisPoints": [
            "RTL prioritizes queries that mimic how users or assistive technologies interact with the page.",
            "`getByRole` is the highest priority as it's most aligned with accessibility.",
            "`getByTestId` is explicitly a fallback, used when other semantic queries are not possible.",
            "Incorrect options represent either non-RTL methods or lower-priority RTL methods."
          ],
          "keyConcepts": [
            "RTL Queries",
            "getByRole",
            "Accessibility",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Knowledge of RTL query hierarchy.",
            "Understanding of RTL's accessibility focus."
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Queries",
            "MCQ"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_3",
          "topic": "RTL `fireEvent`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `fireEvent` in React Testing Library?",
          "answer": "`fireEvent` is used to dispatch DOM events (like `click`, `change`, `submit`) on elements in the rendered component, simulating user interactions.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "fireEvent",
            "RTL",
            "Event Simulation"
          ],
          "evaluationCriteria": [
            "Basic understanding of `fireEvent`'s role"
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Events"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_rtl_4",
          "topic": "RTL `screen` object",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the `screen` object in React Testing Library, and why is it useful?",
          "answer": "The `screen` object is a global utility from RTL that provides access to all query functions (`getBy`, `queryBy`, `findBy`, etc.) without needing to destructure them from the `render` result. It is useful because it encourages finding elements as a user would (from the `document.body`), promoting more robust and user-centric tests.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "screen object",
            "RTL",
            "Queries"
          ],
          "evaluationCriteria": [
            "Understanding `screen`'s utility and philosophy"
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Queries"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_rtl_5",
          "topic": "Testing a form submission with RTL",
          "level": "medium",
          "type": "code",
          "question": "Write a test using React Testing Library for a simple form with an input field and a submit button. The test should:\n1.  Render the form component.\n2.  Type a value into the input field.\n3.  Click the submit button.\n4.  Assert that a mock `onSubmit` function was called with the correct value.",
          "answer": "```typescript\nimport React, { useState } from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\n\ninterface SimpleFormProps {\n  onSubmit: (value: string) => void;\n}\n\nfunction SimpleForm({ onSubmit }: SimpleFormProps) {\n  const [text, setText] = useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSubmit(text);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label htmlFor=\"text-input\">Enter Text:</label>\n      <input\n        id=\"text-input\"\n        type=\"text\"\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n      />\n      <button type=\"submit\">Submit Form</button>\n    </form>\n  );\n}\n\ndescribe('SimpleForm', () => {\n  test('calls onSubmit with the input value when submitted', () => {\n    const mockSubmit = jest.fn();\n    render(<SimpleForm onSubmit={mockSubmit} />);\n    \n    // 1. Find the input field by its label\n    const inputElement = screen.getByLabelText(/Enter Text:/i);\n    \n    // 2. Type a value into the input field\n    fireEvent.change(inputElement, { target: { value: 'Hello RTL' } });\n    expect(inputElement).toHaveValue('Hello RTL'); // Verify input value changed\n    \n    // 3. Find and click the submit button\n    const submitButton = screen.getByRole('button', { name: /Submit Form/i });\n    fireEvent.click(submitButton);\n    \n    // 4. Assert that the onSubmit mock function was called correctly\n    expect(mockSubmit).toHaveBeenCalledTimes(1);\n    expect(mockSubmit).toHaveBeenCalledWith('Hello RTL');\n  });\n});\n```",
          "options": [],
          "analysisPoints": [
            "Correct rendering of a component.",
            "Effective use of `jest.fn()` for mocking.",
            "Appropriate query methods (`getByLabelText`, `getByRole`) for finding elements.",
            "Correct simulation of `change` and `click` events with `fireEvent`.",
            "Accurate assertions on mock function calls (`toHaveBeenCalledTimes`, `toHaveBeenCalledWith`)."
          ],
          "keyConcepts": [
            "RTL",
            "Testing Forms",
            "fireEvent",
            "jest.fn",
            "Queries",
            "Assertions"
          ],
          "evaluationCriteria": [
            "Code correctness and adherence to RTL best practices.",
            "Completeness of the test steps.",
            "Understanding of mocking and assertion."
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Forms",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "Jest_Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_6",
          "topic": "When to use `getByTestId`",
          "level": "medium",
          "type": "open",
          "question": "React Testing Library discourages the use of `getByTestId` as a primary query. Explain why, and in what specific situations it might be an acceptable fallback.",
          "answer": "React Testing Library (RTL) discourages `getByTestId` as a primary query because its philosophy is to test components in a way that resembles user interaction. Users don't see or interact with `data-testid` attributes; they interact with visible text, labels, roles, and other accessibility features.\n\n**Why discouraged:**\n1.  **Breaks User-Centricity:** Using `data-testid` means your test is tied to an internal, non-user-facing implementation detail. If a UI refactor changes `data-testid` values but the user experience remains the same, your test will break unnecessarily.\n2.  **Ignores Accessibility:** It doesn't encourage writing accessible code. By prioritizing `getByRole`, `getByLabelText`, `getByText`, etc., RTL guides developers to add proper semantic HTML and accessibility attributes, which benefits real users.\n3.  **Encourages Brittle Tests:** Tests that rely on `data-testid` can be more brittle because they are coupled to implementation details. Changes to these details (even minor ones) can break tests even if the user functionality is intact.\n\n**Acceptable Fallback Situations:**\n`getByTestId` is considered an acceptable fallback in specific situations where other, more semantic queries are not feasible or would be overly complex. These situations typically involve:\n1.  **Non-Interactive Elements with No Semantic Role/Text:** When testing an element that doesn't have an accessible role, label, or meaningful text content, and it's not interactive (e.g., a simple `div` or `span` that displays dynamic data but has no semantic meaning beyond that).\n2.  **When Testing Libraries/Frameworks:** Sometimes, third-party components or very specific UI elements might not expose accessible names or roles, making other queries difficult without resorting to complex CSS selectors.\n3.  **For Snapshot Testing of Internal Structure:** Although less common for behavior tests, it can be used for snapshot testing if you specifically want to assert on the presence of a `data-testid` in the rendered output for debugging or internal tracking purposes.\n\nIn essence, `getByTestId` should be the last resort when all other user-centric queries fail to reliably locate an element.",
          "options": [],
          "analysisPoints": [
            "Understanding RTL's philosophy and how `getByTestId` deviates.",
            "Explanation of the negative consequences (brittleness, accessibility).",
            "Identification of valid, specific fallback scenarios.",
            "Emphasis on `getByTestId` as a last resort."
          ],
          "keyConcepts": [
            "RTL Queries",
            "getByTestId",
            "Best Practices",
            "Accessibility",
            "User-Centric Testing",
            "Brittle Tests"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of the 'why' behind the discouragement.",
            "Clear and specific examples of acceptable fallback use cases.",
            "Demonstration of deep understanding of RTL principles."
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Queries",
            "Best Practices",
            "Open-Ended"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_7",
          "topic": "Asynchronous Operations in RTL",
          "level": "medium",
          "type": "mcq",
          "question": "You have a React component that fetches data asynchronously and displays it. Which of the following RTL queries is best suited to wait for and find the data once it appears in the DOM?",
          "answer": "`findByText`",
          "options": [
            "`findByText`",
            "`getByText`",
            "`queryByText`",
            "`find(selector)` (Enzyme query)"
          ],
          "analysisPoints": [
            "Understanding the difference between `get`, `query`, and `find` variants.",
            "`get` queries throw an error if the element is not found immediately, suitable for synchronous rendering.",
            "`query` queries return null if not found immediately, suitable for checking absence.",
            "`find` queries return a Promise that resolves when the element is found (or rejects after a timeout), making them ideal for asynchronous operations.",
            "Knowing that `find(selector)` is an Enzyme method, not RTL."
          ],
          "keyConcepts": [
            "RTL Queries",
            "Asynchronous Testing",
            "findBy",
            "Promises"
          ],
          "evaluationCriteria": [
            "Correct identification of the appropriate asynchronous query.",
            "Understanding of the behavior of different query types."
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\nimport { render, screen } from '@testing-library/react';\n\nfunction DataLoader() {\n  const [data, setData] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      await new Promise(resolve => setTimeout(resolve, 100)); // Simulate API call\n      setData('Data loaded successfully!');\n    };\n    fetchData();\n  }, []);\n\n  return (\n    <div>\n      {data ? <p>{data}</p> : <p>Loading...</p>}\n    </div>\n  );\n}\n\ntest('DataLoader displays loaded data after async operation', async () => {\n  render(<DataLoader />);\n  expect(screen.getByText('Loading...')).toBeInTheDocument();\n  \n  // Use findByText to wait for the asynchronous data to appear\n  const loadedDataElement = await screen.findByText('Data loaded successfully!');\n  expect(loadedDataElement).toBeInTheDocument();\n});\n```",
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Asynchronous",
            "Queries",
            "MCQ"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "JavaScript_Promises"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_8",
          "topic": "jest.fn() in RTL",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is `jest.fn()` commonly used when testing React components with RTL?",
          "answer": "`jest.fn()` is used to create mock functions. In RTL, it's particularly useful for mocking callback props passed to components (e.g., `onSubmit`, `onClick`). This allows tests to: \n1.  Verify if the callback was called.\n2.  Verify how many times it was called.\n3.  Verify the arguments it was called with.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "jest.fn",
            "Mock Functions",
            "RTL",
            "Assertions"
          ],
          "evaluationCriteria": [
            "Understanding the purpose of mocking in testing"
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Jest",
            "Mocking"
          ],
          "prerequisites": [
            "Jest_Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_enzyme_1",
          "topic": "Enzyme Introduction",
          "level": "easy",
          "type": "flashcard",
          "question": "What is Enzyme primarily used for in React development?",
          "answer": "Enzyme is a JavaScript testing utility for React that provides an API for testing React Components' output, making it easier to assert, manipulate, and traverse React trees.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Enzyme",
            "React Testing",
            "Utility"
          ],
          "evaluationCriteria": [
            "Basic understanding of Enzyme's purpose"
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "Enzyme"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_enzyme_2",
          "topic": "Shallow vs Mount vs Render",
          "level": "medium",
          "type": "mcq",
          "question": "Which Enzyme rendering method is best suited for unit testing a component in isolation, without rendering its child components?",
          "answer": "`shallow`",
          "options": [
            "`shallow`",
            "`mount`",
            "`render`",
            "`debug` (not a rendering method)"
          ],
          "analysisPoints": [
            "Understanding the core distinction between Enzyme's rendering methods.",
            "`shallow` isolates the component, `mount` renders full DOM, `render` to static HTML."
          ],
          "keyConcepts": [
            "Enzyme",
            "Shallow Rendering",
            "Unit Testing",
            "Isolation"
          ],
          "evaluationCriteria": [
            "Correct identification of `shallow`'s purpose.",
            "Understanding of testing isolation."
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "Shallow",
            "MCQ"
          ],
          "prerequisites": [
            "theory_enzyme_testing"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_3",
          "topic": "Enzyme `mount` usage",
          "level": "medium",
          "type": "flashcard",
          "question": "When would you typically use Enzyme's `mount` rendering method over `shallow`?",
          "answer": "You would use `mount` when you need to test components that interact with the full DOM API, components that rely on their children's lifecycle methods, or when testing interactions between parent and deeply nested child components. It's suitable for integration testing.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Enzyme",
            "Mount Rendering",
            "Integration Testing",
            "DOM Interaction",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Understanding `mount`'s use cases"
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "Mount"
          ],
          "prerequisites": [
            "theory_enzyme_testing"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_4",
          "topic": "Enzyme `simulate`",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you trigger an event on an element within an Enzyme wrapper?",
          "answer": "You use the `simulate(event, mockEvent)` method on the wrapper. For example, `wrapper.find('button').simulate('click');`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Enzyme",
            "Simulate",
            "Events"
          ],
          "evaluationCriteria": [
            "Basic understanding of event simulation in Enzyme"
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "Events"
          ],
          "prerequisites": [
            "theory_enzyme_testing"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_enzyme_5",
          "topic": "Testing state updates with Enzyme",
          "level": "medium",
          "type": "code",
          "question": "You have a simple `ToggleButton` component that maintains an internal `isOn` state and displays text based on it. Write an Enzyme test using `shallow` to verify that clicking the button toggles its state and updates the displayed text.",
          "answer": "```typescript\nimport React, { useState } from 'react';\nimport { shallow } from 'enzyme';\n\nfunction ToggleButton() {\n  const [isOn, setIsOn] = useState(false);\n\n  return (\n    <button onClick={() => setIsOn(!isOn)} data-testid=\"toggle-button\">\n      {isOn ? 'ON' : 'OFF'}\n    </button>\n  );\n}\n\ndescribe('ToggleButton', () => {\n  it('should toggle state and display correct text on click', () => {\n    const wrapper = shallow(<ToggleButton />);\n    const button = wrapper.find('[data-testid=\"toggle-button\"]');\n    \n    // Initial state: OFF\n    expect(button.text()).toBe('OFF');\n    expect(wrapper.state('isOn')).toBe(false); // Direct state access (less common with hooks, but possible for class components or with certain Enzyme adapters/debug methods)\n    \n    // Click once: should become ON\n    button.simulate('click');\n    expect(button.text()).toBe('ON');\n    // For functional components with shallow, direct state access like `wrapper.state('isOn')` is typically not available.\n    // We assert on the rendered output instead. To truly test state, you'd re-render or use `mount` with `update()`.\n    // Or rely solely on the visual output.\n\n    // Re-render the shallow wrapper to reflect state changes for functional components\n    // This is often implicitly handled by Jest if the component is mounted in a test environment.\n    // However, for explicit shallow tests of functional component state, you might need `wrapper.update();`\n    // After simulate, the component's state is implicitly updated in the virtual DOM representation that shallow holds.\n    \n    // Click again: should become OFF\n    button.simulate('click');\n    expect(button.text()).toBe('OFF');\n  });\n});\n```\n\n**Note on `wrapper.state()` with Functional Components and Shallow Rendering:**\nWith React Hooks (functional components), `wrapper.state()` is generally not accessible or meaningful in `shallow` rendering because hooks manage state internally without exposing a direct `.state` property on the component instance. The assertion `expect(wrapper.state('isOn')).toBe(false);` would typically fail or return `undefined` for a functional component. The correct way to test state changes in a functional component with shallow rendering is to assert on the **rendered output** (e.g., `button.text()`) that reflects the state change. The example is modified to reflect this, relying on `button.text()` which is the user-observable output.",
          "options": [],
          "analysisPoints": [
            "Correct setup of Enzyme `shallow` wrapper.",
            "Identifying elements with selectors (`data-testid`).",
            "Simulating click events with `simulate`.",
            "Asserting on the visual output (`text()`) to confirm state change.",
            "Understanding limitations of `shallow` with functional component state access (and how to properly assert)."
          ],
          "keyConcepts": [
            "Enzyme",
            "Shallow Rendering",
            "State Testing",
            "Functional Components",
            "Simulate"
          ],
          "evaluationCriteria": [
            "Code correctness and adherence to Enzyme usage.",
            "Effective testing of state transitions through UI output.",
            "Awareness of functional component state testing nuances with `shallow`."
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "Shallow",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_enzyme_testing"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_6",
          "topic": "Enzyme vs RTL Comparison",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast Enzyme and React Testing Library (RTL) in terms of their testing philosophy, strengths, and weaknesses. When would you choose one over the other in a modern React project?",
          "answer": "**Enzyme vs. React Testing Library (RTL)**\n\n**Enzyme:**\n*   **Philosophy:** Focuses on testing component implementation details. It provides a comprehensive API to inspect, manipulate, and traverse React component trees. It's more about testing 'how' components work internally.\n*   **Strengths:**\n    *   **Access to Internal State/Props:** Allows direct access to component instance, state, and props (especially with `mount` for class components or `wrapper.props()`).\n    *   **Shallow Rendering:** Enables isolated unit testing without mounting child components, making tests faster and less coupled to children's implementations.\n    *   **Direct Component Method Testing:** Can call component methods directly.\n    *   **Component Tree Traversal:** Powerful API for finding nodes using various selectors (component names, CSS selectors, props).\n*   **Weaknesses:**\n    *   **Coupled to Implementation Details:** Tests can break easily if internal implementation changes, even if the user experience remains the same.\n    *   **Less User-Centric:** Doesn't inherently encourage accessible or user-focused testing practices.\n    *   **Maintenance:** Development has slowed, and it sometimes requires `enzyme-adapter` packages for specific React versions, which can be a maintenance burden.\n\n**React Testing Library (RTL):**\n*   **Philosophy:** \"The more your tests resemble the way your software is used, the more confidence they can give you.\" Focuses on testing user behavior and accessibility, interacting with the DOM as a user would. It's about testing 'what' the user sees and experiences.\n*   **Strengths:**\n    *   **User-Centric:** Encourages writing tests that are resilient to refactoring and mirror real user interactions, promoting more robust tests.\n    *   **Accessibility Focus:** Prioritizes queries that rely on accessible attributes (roles, labels, text), naturally leading to more accessible applications.\n    *   **Less Brittle:** Tests are less likely to break due to internal component changes, making them more stable over time.\n    *   **Framework-Agnostic Core:** Its core principles apply beyond React.\n    *   **Community Recommendation:** Currently the recommended testing library by the React team for new projects.\n*   **Weaknesses:**\n    *   **No Direct State/Method Access:** Does not provide direct access to component internal state or methods, which can make testing certain low-level logic more challenging (though this is by design).\n    *   **Requires DOM Environment:** Tests always render into a DOM environment, potentially making them slightly slower than Enzyme's `shallow` tests.\n\n**When to Choose One Over the Other in a Modern React Project:**\nFor **modern React projects**, **React Testing Library (RTL) is generally the recommended choice**. You would choose RTL because:\n*   It aligns with the latest best practices for writing maintainable and resilient tests.\n*   It encourages accessible development by design.\n*   It gives higher confidence that your application works for real users.\n\n**You might consider Enzyme for:**\n*   **Legacy Projects:** If you're working on an older project that already heavily uses Enzyme, it might be more practical to continue using it to maintain consistency.\n*   **Specific Niche Use Cases:** In rare scenarios where you *must* test very specific internal component logic, lifecycle methods, or props directly, and you understand the trade-offs in terms of test brittleness.\n\nIn conclusion, while both are capable testing libraries, RTL's user-centric and accessibility-first approach makes it the preferred tool for most new React development and for writing tests that provide the most confidence.",
          "options": [],
          "analysisPoints": [
            "Clear and accurate explanation of each library's philosophy.",
            "Detailed listing of strengths and weaknesses for both.",
            "Well-reasoned recommendation for modern projects.",
            "Identification of specific scenarios where the less-recommended library might still be used.",
            "Demonstration of deep understanding of testing paradigms."
          ],
          "keyConcepts": [
            "Enzyme",
            "React Testing Library",
            "Testing Philosophy",
            "Unit Testing",
            "Integration Testing",
            "Shallow Rendering",
            "Mount Rendering",
            "Accessibility",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison covering all requested aspects.",
            "Logical structure and clarity of argument.",
            "Depth of understanding of testing principles.",
            "Practical and realistic advice for tool selection."
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "RTL",
            "Comparison",
            "Best Practices",
            "Open-Ended"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "theory_enzyme_testing"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_enzyme_7",
          "topic": "Enzyme `find` selector",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React component:\n\n```jsx\nfunction MyComponent() {\n  return (\n    <div>\n      <p className=\"message\">Hello</p>\n      <button id=\"my-button\">Click Me</button>\n      <MyChildComponent />\n    </div>\n  );\n}\n\nfunction MyChildComponent() {\n  return <span>Child</span>;\n}\n```\n\nWhich of the following Enzyme `find` selectors would correctly select the `MyChildComponent` when using `shallow` rendering?",
          "answer": "`wrapper.find('MyChildComponent')`",
          "options": [
            "`wrapper.find('MyChildComponent')`",
            "`wrapper.find('.message')`",
            "`wrapper.find('button#my-button')`",
            "`wrapper.find('span')`"
          ],
          "analysisPoints": [
            "Understanding that `shallow` rendering does not render child components' DOM output, but rather their React component types.",
            "Knowing that Enzyme's `find` can accept component names as selectors in `shallow` mode.",
            "Recognizing that CSS selectors like `'.message'` or `'span'` would work for actual DOM nodes, but `span` wouldn't exist directly for `MyChildComponent` in `shallow` output (only `<MyChildComponent />` would)."
          ],
          "keyConcepts": [
            "Enzyme",
            "Shallow Rendering",
            "Find Selectors",
            "Component Type Selector"
          ],
          "evaluationCriteria": [
            "Correct identification of `shallow`'s behavior with child components.",
            "Accurate application of Enzyme's `find` method."
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "Shallow",
            "MCQ"
          ],
          "prerequisites": [
            "theory_enzyme_testing"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_8",
          "topic": "Enzyme `render` method",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main characteristic and use case of Enzyme's `render` method?",
          "answer": "Enzyme's `render` method renders React components to static HTML strings. Its main characteristic is that it does not provide access to React component instances, state, or lifecycle methods, and cannot simulate events. It's primarily used for testing the rendered HTML output (e.g., for snapshot testing).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Enzyme",
            "Render Method",
            "Static HTML",
            "Snapshot Testing"
          ],
          "evaluationCriteria": [
            "Understanding the specific purpose and limitations of `render`"
          ],
          "example": null,
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "Render"
          ],
          "prerequisites": [
            "theory_enzyme_testing"
          ],
          "complexity": 4,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_react_performance_hooks_1",
          "title": "Optimize a Data Display Component with useMemo and useCallback",
          "description": "\nYou are given a React component that displays a list of products and allows filtering. Currently, the filtering logic is executed on every re-render, and an `onClick` handler is re-created on every re-render, even when unrelated state changes. Your task is to refactor this component to use `useMemo` for the filtering logic and `useCallback` for the `onClick` handler to improve performance.\n\n**Requirements:**\n1.  Use `useMemo` to memoize the `filteredProducts` array. The filtering logic should only re-run when the `products` prop or `searchTerm` state changes.\n2.  Use `useCallback` to memoize the `handleProductClick` function. This function's reference should remain stable across re-renders that are not related to `handleProductClick`'s dependencies (e.g., when the `counter` changes).\n3.  Add `console.log` statements inside the `useMemo` callback and `useCallback` callback to demonstrate when they are re-executed/re-created.\n4.  Verify that incrementing the `counter` (unrelated state) does NOT trigger the re-execution of the filtering logic or the re-creation of the `handleProductClick` function, as evidenced by your console logs.\n\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ninterface ProductListProps {\n  products: Product[];\n}\n\nfunction ProductList({ products }: ProductListProps) {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [counter, setCounter] = useState(0); // Unrelated state\n\n  // TODO: Refactor this to use useMemo\n  const filteredProducts = products.filter(product => \n    product.name.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  // TODO: Refactor this to use useCallback\n  const handleProductClick = (id: number) => {\n    console.log(`Product ${id} clicked!`);\n    // In a real app, this might navigate or dispatch an action\n  };\n\n  return (\n    <div>\n      <h1>Product Catalog</h1>\n      <input\n        type=\"text\"\n        placeholder=\"Search products...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n      />\n\n      <p>Counter: {counter}</p>\n      <button onClick={() => setCounter(prev => prev + 1)}>\n        Increment Unrelated Counter\n      </button>\n\n      <h2>Available Products ({filteredProducts.length})</h2>\n      <ul>\n        {filteredProducts.map(product => (\n          <li key={product.id} onClick={() => handleProductClick(product.id)}>\n            {product.name} - ${product.price}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default ProductList;\n\n// Example usage for testing (not part of the component itself):\n/*\nconst sampleProducts: Product[] = [\n  { id: 1, name: 'Laptop', price: 1200 },\n  { id: 2, name: 'Mouse', price: 25 },\n  { id: 3, name: 'Keyboard', price: 75 },\n  { id: 4, name: 'Monitor', price: 300 },\n  { id: 5, name: 'Webcam', price: 50 },\n];\n\nfunction App() {\n  return <ProductList products={sampleProducts} />;\n}\n*/",
          "solutionCode": "import React, { useState, useMemo, useCallback } from 'react';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ninterface ProductListProps {\n  products: Product[];\n}\n\nfunction ProductList({ products }: ProductListProps) {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [counter, setCounter] = useState(0); // Unrelated state\n\n  // Use useMemo to memoize the filtered products.\n  // This calculation will only re-run if 'products' or 'searchTerm' changes.\n  const filteredProducts = useMemo(() => {\n    console.log('useMemo: Filtering products...'); // Log to observe re-runs\n    if (!searchTerm) {\n      return products;\n    }\n    const lowerCaseSearchTerm = searchTerm.toLowerCase();\n    return products.filter(product => \n      product.name.toLowerCase().includes(lowerCaseSearchTerm)\n    );\n  }, [products, searchTerm]); // Dependencies: products and searchTerm\n\n  // Use useCallback to memoize the handleProductClick function.\n  // Its reference will remain stable unless its dependencies change.\n  // In this case, it doesn't depend on any state/props that change frequently, so an empty array works.\n  const handleProductClick = useCallback((id: number) => {\n    console.log(`useCallback: Product ${id} clicked!`); // Log to observe function re-creation\n  }, []); // Empty dependency array: function created once\n\n  return (\n    <div>\n      <h1>Product Catalog</h1>\n      <input\n        type=\"text\"\n        placeholder=\"Search products...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n      />\n\n      <p>Counter: {counter}</p>\n      <button onClick={() => setCounter(prev => prev + 1)}>\n        Increment Unrelated Counter\n      </button>\n\n      <h2>Available Products ({filteredProducts.length})</h2>\n      <ul>\n        {filteredProducts.map(product => (\n          <li key={product.id} onClick={() => handleProductClick(product.id)}>\n            {product.name} - ${product.price}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default ProductList;\n",
          "testCases": [
            "Initial render: `useMemo: Filtering products...` should log once.",
            "Type in search box: `useMemo: Filtering products...` should log on each significant change, `useCallback: Product X clicked!` should log when a product is clicked.",
            "Click 'Increment Unrelated Counter' multiple times: `useMemo: Filtering products...` should NOT log. `useCallback: Product X clicked!` should log when a product is clicked (indicating the function reference did not change unless clicked)."
          ],
          "hints": [
            "Remember that `useMemo` memoizes a value, and `useCallback` memoizes a function.",
            "Pay close attention to the dependency arrays for both hooks.",
            "An empty dependency array `[]` ensures the memoized value/function is created only once.",
            "Use `console.log` statements within the hook callbacks to verify their execution/re-creation."
          ],
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "useCallback",
            "Performance",
            "Optimization",
            "Frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_Functional_Components",
            "React_State_Hooks",
            "JavaScript_Closures"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Memoization",
            "React.memo",
            "Referential Equality"
          ]
        },
        {
          "id": "task_react_testing_library_1",
          "title": "Test a User Registration Form with React Testing Library",
          "description": "\nCreate a `RegistrationForm` component with fields for 'Username', 'Email', and 'Password', and a 'Register' button. Then, write a comprehensive test suite for this component using React Testing Library to simulate user interactions and verify expected outcomes.\n\n**Component Requirements:**\n1.  Three input fields: 'Username', 'Email', 'Password' (type 'password'). Each should have a clear label.\n2.  A 'Register' button that submits the form.\n3.  The form should accept an `onSubmit` prop, which is called with an object `{ username, email, password }` when the form is submitted.\n\n**Test Requirements (using RTL):**\n1.  **Initial Render Test:** Verify that all input fields and the submit button are present in the document.\n2.  **Input Change Test:** Simulate typing into each input field and assert that their values update correctly.\n3.  **Form Submission Test:**\n    *   Create a `jest.fn()` mock for the `onSubmit` prop.\n    *   Fill out all three input fields.\n    *   Click the 'Register' button.\n    *   Assert that `onSubmit` was called exactly once with the correct user data (username, email, password).\n4.  **Error Handling (Bonus):** If the component had validation (e.g., password too short), you could add a test to ensure an error message appears/disappears.",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface RegistrationFormProps {\n  onSubmit: (data: { username: string; email: string; password: string }) => void;\n}\n\nfunction RegistrationForm({ onSubmit }: RegistrationFormProps) {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSubmit({ username, email, password });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username-input\">Username</label>\n        <input \n          id=\"username-input\"\n          type=\"text\"\n          value={username}\n          onChange={(e) => setUsername(e.target.value)}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"email-input\">Email</label>\n        <input \n          id=\"email-input\"\n          type=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password-input\">Password</label>\n        <input \n          id=\"password-input\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n        />\n      </div>\n      <button type=\"submit\">Register</button>\n    </form>\n  );\n}\n\nexport default RegistrationForm;\n\n// --- Test File Structure (for your solution) ---\n// import { render, screen, fireEvent } from '@testing-library/react';\n// import '@testing-library/jest-dom/extend-expect';\n// import RegistrationForm from './RegistrationForm';\n\n// describe('RegistrationForm', () => {\n//   // Your tests go here\n// });\n",
          "solutionCode": "import React, { useState } from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\n\ninterface RegistrationFormProps {\n  onSubmit: (data: { username: string; email: string; password: string }) => void;\n}\n\nfunction RegistrationForm({ onSubmit }: RegistrationFormProps) {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSubmit({ username, email, password });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username-input\">Username</label>\n        <input \n          id=\"username-input\"\n          type=\"text\"\n          value={username}\n          onChange={(e) => setUsername(e.target.value)}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"email-input\">Email</label>\n        <input \n          id=\"email-input\"\n          type=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password-input\">Password</label>\n        <input \n          id=\"password-input\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n        />\n      </div>\n      <button type=\"submit\">Register</button>\n    </form>\n  );\n}\n\nexport default RegistrationForm;\n\n// --- Test File (e.g., RegistrationForm.test.tsx) ---\n\ndescribe('RegistrationForm', () => {\n  test('renders all input fields and a submit button', () => {\n    render(<RegistrationForm onSubmit={jest.fn()} />);\n    \n    expect(screen.getByLabelText(/username/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /register/i })).toBeInTheDocument();\n  });\n\n  test('updates input values when user types', () => {\n    render(<RegistrationForm onSubmit={jest.fn()} />);\n    \n    const usernameInput = screen.getByLabelText(/username/i);\n    const emailInput = screen.getByLabelText(/email/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n\n    fireEvent.change(usernameInput, { target: { value: 'testuser' } });\n    expect(usernameInput).toHaveValue('testuser');\n\n    fireEvent.change(emailInput, { target: { value: 'test@example.com' } });\n    expect(emailInput).toHaveValue('test@example.com');\n\n    fireEvent.change(passwordInput, { target: { value: 'securepass123' } });\n    expect(passwordInput).toHaveValue('securepass123');\n  });\n\n  test('calls onSubmit with correct data when form is submitted', () => {\n    const mockOnSubmit = jest.fn();\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    \n    const usernameInput = screen.getByLabelText(/username/i);\n    const emailInput = screen.getByLabelText(/email/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n    const registerButton = screen.getByRole('button', { name: /register/i });\n\n    // Fill out the form\n    fireEvent.change(usernameInput, { target: { value: 'newUser' } });\n    fireEvent.change(emailInput, { target: { value: 'new@example.com' } });\n    fireEvent.change(passwordInput, { target: { value: 'passwordXYZ' } });\n\n    // Submit the form\n    fireEvent.click(registerButton);\n\n    // Assert onSubmit was called correctly\n    expect(mockOnSubmit).toHaveBeenCalledTimes(1);\n    expect(mockOnSubmit).toHaveBeenCalledWith({\n      username: 'newUser',\n      email: 'new@example.com',\n      password: 'passwordXYZ',\n    });\n  });\n});\n",
          "testCases": [
            "Test for existence of 'Username' label/input.",
            "Test for existence of 'Email' label/input.",
            "Test for existence of 'Password' label/input.",
            "Test for existence of 'Register' button.",
            "Type 'myusername' into Username input: input value should be 'myusername'.",
            "Type 'myemail@example.com' into Email input: input value should be 'myemail@example.com'.",
            "Type 'mypassword123' into Password input: input value should be 'mypassword123'.",
            "Fill all fields and click 'Register': `onSubmit` should be called once with `{ username: 'test', email: 'test@test.com', password: 'pass' }`."
          ],
          "hints": [
            "Remember to use `screen.getByLabelText` or `screen.getByRole` for finding input fields and buttons, as these are user-centric queries.",
            "`fireEvent.change` for inputs needs an object with `target: { value: '...' }`.",
            "To assert on the input's value, use `toHaveValue()` from `@testing-library/jest-dom`.",
            "For asserting mock function calls, `jest.fn()`, `toHaveBeenCalledTimes()`, and `toHaveBeenCalledWith()` are essential."
          ],
          "tags": [
            "React",
            "Testing",
            "RTL",
            "Forms",
            "Unit Testing",
            "Integration Testing"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_react_testing_library",
            "Jest_Basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "jest.fn",
            "fireEvent",
            "screen",
            "Queries",
            "Assertions"
          ]
        },
        {
          "id": "task_enzyme_testing_1",
          "title": "Test a Simple Toggle Component with Enzyme (Shallow & Mount)",
          "description": "\nCreate a `ToggleSwitch` component that has an internal `isOn` state and a `label` prop. The component should display the label and visually indicate its `isOn` status (e.g., 'ON' or 'OFF' text). Your task is to write tests for this component using both Enzyme's `shallow` and `mount` rendering methods, highlighting their differences.\n\n**Component Requirements:**\n1.  A functional React component named `ToggleSwitch`.\n2.  Manages an internal boolean `isOn` state, defaulting to `false`.\n3.  Accepts a `label` prop (string).\n4.  Displays the `label` and the current status ('ON' if `true`, 'OFF' if `false`).\n5.  Clicking the switch should toggle the `isOn` state.\n6.  (Optional for `mount`): If you add a `ChildComponent` inside `ToggleSwitch`, ensure `mount` renders it fully.\n\n**Test Requirements (using Enzyme):**\n1.  **Shallow Render Test:**\n    *   Test initial render: verify the label and default 'OFF' status are displayed.\n    *   Simulate a click: verify the status toggles to 'ON'.\n    *   Simulate another click: verify the status toggles back to 'OFF'.\n    *   *Do NOT* try to access internal state directly with `wrapper.state()` for functional components; rely on rendered text.\n2.  **Mount Render Test (if applicable, demonstrate children):**\n    *   If `ToggleSwitch` contains a nested component (`ChildComponent`), demonstrate that `mount` renders `ChildComponent` fully, while `shallow` does not.\n    *   Re-run the click tests from shallow, ensuring they work similarly with `mount`. (Focus on DOM presence/text, not internal state).\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface ToggleSwitchProps {\n  label: string;\n}\n\n// Optional: a simple child component to demonstrate mount vs shallow\n// function NestedIndicator() {\n//   return <span className=\"nested-indicator\">[Nested Indicator]</span>;\n// }\n\nfunction ToggleSwitch({ label }: ToggleSwitchProps) {\n  const [isOn, setIsOn] = useState(false);\n\n  return (\n    <button onClick={() => setIsOn(!isOn)} data-testid=\"toggle-button\">\n      {label}: {isOn ? 'ON' : 'OFF'}\n      {/* Optional: <NestedIndicator /> */}\n    </button>\n  );\n}\n\nexport default ToggleSwitch;\n\n// --- Test File Structure (for your solution) ---\n// import React from 'react';\n// import { shallow, mount } from 'enzyme';\n// import ToggleSwitch from './ToggleSwitch';\n\n// describe('ToggleSwitch - Shallow Rendering', () => {\n//   // Your shallow tests here\n// });\n\n// describe('ToggleSwitch - Mount Rendering', () => {\n//   // Your mount tests here\n// });\n",
          "solutionCode": "import React, { useState } from 'react';\nimport { shallow, mount } from 'enzyme';\n\ninterface ToggleSwitchProps {\n  label: string;\n}\n\n// A simple child component to demonstrate mount vs shallow\nfunction NestedIndicator() {\n  return <span className=\"nested-indicator\">[Nested Indicator]</span>;\n}\n\nfunction ToggleSwitch({ label }: ToggleSwitchProps) {\n  const [isOn, setIsOn] = useState(false);\n\n  return (\n    <button onClick={() => setIsOn(!isOn)} data-testid=\"toggle-button\">\n      {label}: {isOn ? 'ON' : 'OFF'}\n      <NestedIndicator /> {/* Include the child component */}\n    </button>\n  );\n}\n\nexport default ToggleSwitch;\n\n// --- Test File (e.g., ToggleSwitch.test.tsx) ---\n\ndescribe('ToggleSwitch - Shallow Rendering', () => {\n  it('renders correctly with initial OFF state and label', () => {\n    const wrapper = shallow(<ToggleSwitch label=\"Enable Feature\" />);\n    expect(wrapper.text()).toContain('Enable Feature: OFF');\n    // Verify NestedIndicator is present as a component type, not rendered DOM\n    expect(wrapper.find('NestedIndicator').exists()).toBe(true);\n    expect(wrapper.find('.nested-indicator').exists()).toBe(false); // No actual DOM from child\n  });\n\n  it('toggles state to ON on first click', () => {\n    const wrapper = shallow(<ToggleSwitch label=\"Enable Feature\" />);\n    const button = wrapper.find('[data-testid=\"toggle-button\"]');\n    \n    button.simulate('click');\n    expect(button.text()).toContain('Enable Feature: ON');\n  });\n\n  it('toggles state back to OFF on second click', () => {\n    const wrapper = shallow(<ToggleSwitch label=\"Enable Feature\" />);\n    const button = wrapper.find('[data-testid=\"toggle-button\"]');\n    \n    button.simulate('click'); // ON\n    button.simulate('click'); // OFF\n    expect(button.text()).toContain('Enable Feature: OFF');\n  });\n});\n\ndescribe('ToggleSwitch - Mount Rendering', () => {\n  it('renders correctly with initial OFF state and label', () => {\n    const wrapper = mount(<ToggleSwitch label=\"Enable Feature\" />);\n    expect(wrapper.text()).toContain('Enable Feature: OFF');\n    // Verify NestedIndicator's actual DOM is present\n    expect(wrapper.find('NestedIndicator').exists()).toBe(true);\n    expect(wrapper.find('.nested-indicator').exists()).toBe(true); // Actual DOM from child\n  });\n\n  it('toggles state to ON on first click', () => {\n    const wrapper = mount(<ToggleSwitch label=\"Enable Feature\" />);\n    const button = wrapper.find('[data-testid=\"toggle-button\"]');\n    \n    button.simulate('click');\n    // Need to `update()` for `mount` to re-render and reflect state changes immediately in the wrapper's DOM\n    wrapper.update(); \n    expect(button.text()).toContain('Enable Feature: ON');\n  });\n\n  it('toggles state back to OFF on second click', () => {\n    const wrapper = mount(<ToggleSwitch label=\"Enable Feature\" />);\n    const button = wrapper.find('[data-testid=\"toggle-button\"]');\n    \n    button.simulate('click'); // ON\n    wrapper.update(); \n    button.simulate('click'); // OFF\n    wrapper.update();\n    expect(button.text()).toContain('Enable Feature: OFF');\n  });\n});\n",
          "testCases": [
            "Shallow: Initial text contains 'OFF' and correct label.",
            "Shallow: After 1 click, text contains 'ON'.",
            "Shallow: After 2 clicks, text contains 'OFF'.",
            "Shallow: `find('NestedIndicator').exists()` should be `true` (component type).",
            "Shallow: `find('.nested-indicator').exists()` should be `false` (no child DOM).",
            "Mount: Initial text contains 'OFF' and correct label.",
            "Mount: After 1 click, text contains 'ON'.",
            "Mount: After 2 clicks, text contains 'OFF'.",
            "Mount: `find('NestedIndicator').exists()` should be `true`.",
            "Mount: `find('.nested-indicator').exists()` should be `true` (child DOM is rendered)."
          ],
          "hints": [
            "For `shallow` tests, remember that child components are not rendered into full DOM. You can find them by their component name (`wrapper.find('MyChildComponent')`).",
            "For `mount` tests, after simulating an event that causes state changes, you might need to call `wrapper.update()` to re-render the component tree and reflect the changes in the wrapper before making assertions.",
            "Use `data-testid` or CSS class/id selectors for `find()` when targeting specific DOM elements within the component.",
            "`wrapper.text()` is useful for asserting displayed content."
          ],
          "tags": [
            "React",
            "Testing",
            "Enzyme",
            "Shallow",
            "Mount",
            "Unit Testing",
            "Integration Testing"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_enzyme_testing",
            "React_State_Hooks"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Isolation",
            "DOM Manipulation",
            "Virtual DOM",
            "State Management"
          ]
        }
      ]
    }
  },
  {
    "id": "f5b48cca-63de-4855-b694-e79e62ebf099",
    "startLine": 5300,
    "endLine": 5399,
    "processedDate": "2025-06-17T09:30:24.703Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_jest_react_basics",
          "title": "Jest and React Testing Library Fundamentals",
          "content": "Jest is a powerful JavaScript testing framework that is widely used for React applications. It is known for its simplicity and 'batteries-included' approach, providing a complete testing solution out of the box, including assertion libraries, mocking capabilities, and test runners.\n\nReact Testing Library (RTL) is a set of utilities that help test React components by interacting with them in a way that resembles how real users would. Its guiding principle is to make tests reflect actual user behavior as closely as possible, discouraging reliance on component internals (like state or props).\n\n### Key Concepts:\n*   **`render` function (from `@testing-library/react`):** Renders a React component into a Document Object Model (DOM) container and returns a set of utilities to query that DOM. This function is the primary way to mount components for testing.\n*   **Queries (e.g., `getByRole`, `getByText`, `queryByTestId`):** RTL provides various query functions to find elements in the rendered DOM. `getByRole` is highly recommended as it encourages semantic HTML and helps ensure accessibility, simulating how assistive technologies would interact with the page.\n    *   `getByRole(role, options)`: Finds an element by its ARIA role (e.g., 'button', 'heading', 'navigation').\n    *   `getByText(text, options)`: Finds an element that contains the given text content.\n    *   `queryBy...`: Similar to `getBy...` but returns `null` if no element is found, instead of throwing an error. Useful for asserting an element is *not* present.\n    *   `findBy...`: Asynchronous versions of `getBy...`, useful for waiting for elements to appear in the DOM (e.g., after an API call).\n*   **`expect` and Matchers:** Jest provides `expect` to make assertions about values. Matchers are functions chained to `expect` that perform the actual comparison or check.\n    *   `toBeInTheDocument()`: Checks if an element exists within the document (provided by `@testing-library/jest-dom`).\n    *   `toHaveTextContent(text)`: Checks if an element contains the specified text content.\n*   **`describe` block:** A way to group related tests together. It often represents a component or a specific feature being tested.\n*   **`it` (or `test`) block:** Defines an individual test case. It should describe a single, specific behavior or outcome.",
          "examples": [
            {
              "id": "example_jest_react_basics_1",
              "title": "Basic Component Rendering and Assertion",
              "code": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ndescribe('MyComponent', () => {\n  it('should render the title and content correctly', () => {\n    render(<MyComponent title=\"Welcome\" content=\"Hello World\" />);\n    // Using getByRole for semantic elements\n    expect(screen.getByRole('heading', { level: 1 })).toHaveTextContent('Welcome');\n    // Using getByText for general text content\n    expect(screen.getByText('Hello World')).toBeInTheDocument();\n  });\n\n  it('should display a default message when no content is provided', () => {\n    render(<MyComponent title=\"Empty\" />);\n    expect(screen.getByText(/no content available/i)).toBeInTheDocument();\n  });\n});\n\n// MyComponent.jsx (for context)\n// import React from 'react';\n// const MyComponent = ({ title, content }) => (\n//   <div>\n//     <h1>{title}</h1>\n//     {content ? <p>{content}</p> : <p>No content available.</p>}\n//   </div>\n// );\n// export default MyComponent;\n",
              "explanation": "This example demonstrates how to render a simple React component (`MyComponent`) using `render` from React Testing Library. It then uses `screen.getByRole` to find a heading and `toHaveTextContent` to assert its text, and `screen.getByText` with `toBeInTheDocument` to check for paragraph text. The second test case shows how to test a default behavior when a prop is missing, using a regex for text matching.",
              "language": "typescript"
            },
            {
              "id": "example_jest_react_basics_2",
              "title": "Querying for specific HTML elements",
              "code": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport Header from './Header';\n\ndescribe('Header component', () => {\n  it('renders correctly with a given title', () => {\n    // Render the Header component with a specific title prop\n    const { getByRole } = render(<Header title=\"Test Title\" />);\n    // Assert that a heading element (h1, h2, etc.) contains the title text\n    expect(getByRole('heading')).toHaveTextContent('Test Title');\n  });\n\n  it('contains a navigation menu', () => {\n    // Render the Header component (without title, if optional)\n    const { getByRole } = render(<Header />);\n    // Assert that an element with the 'navigation' ARIA role is present in the document\n    expect(getByRole('navigation')).toBeInTheDocument();\n  });\n});\n\n// Header.jsx (for context)\n// import React from 'react';\n// const Header = ({ title }) => (\n//   <header>\n//     <h1>{title || 'Default Header'}</h1>\n//     <nav aria-label=\"Main navigation\">\n//       <ul>\n//         <li>Home</li>\n//         <li>About</li>\n//       </ul>\n//     </nav>\n//   </header>\n// );\n// export default Header;\n",
              "explanation": "This example, directly from the provided markdown, illustrates basic component testing. It uses `getByRole` to locate elements based on their semantic roles (`heading` and `navigation`) which is a best practice for accessibility and robust tests. `toHaveTextContent` verifies the text within the heading, and `toBeInTheDocument` confirms the presence of the navigation element.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_jest_react_basics_1",
            "question_jest_react_basics_2",
            "question_jest_react_basics_3",
            "question_jest_react_basics_4"
          ],
          "relatedTasks": [
            "task_jest_react_basics_1",
            "task_jest_react_basics_2"
          ],
          "tags": [
            "Jest",
            "React Testing Library",
            "Unit Testing",
            "Frontend Testing",
            "TDD",
            "Accessibility"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "JavaScript ES6+",
            "HTML DOM"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Component Testing",
            "Integration Testing"
          ]
        },
        {
          "id": "theory_mock_functions",
          "title": "Mock Functions in React Tests",
          "content": "Mock functions in Jest allow you to test the links between code by erasing the actual implementation of a function, capturing calls to it, and allowing you to specify return values. This is crucial for isolating the unit under test and ensuring your tests are focused and fast.\n\n### Key Concepts:\n*   **`jest.fn()`:** Creates a mock function. By default, it's an empty function, but you can configure its behavior (e.g., return values, implementations).\n*   **`fireEvent` (from `@testing-library/react`):** A utility to simulate DOM events (e.g., `click`, `change`, `submit`). It dispatches native browser events, making tests more realistic.\n*   **Mock Matchers:** Jest provides specific matchers for mock functions:\n    *   `toHaveBeenCalled()`: Asserts that the mock function was called at least once.\n    *   `toHaveBeenCalledTimes(number)`: Asserts that the mock function was called exactly `number` times.\n    *   `toHaveBeenCalledWith(...args)`: Asserts that the mock function was called with specific arguments.\n    *   `toHaveBeenLastCalledWith(...args)`: Asserts that the mock function was last called with specific arguments.\n*   **`jest.spyOn()`:** This is used to spy on an existing function (e.g., a method on an object) without changing its original implementation. It allows you to track calls to the real function. You can optionally mock the implementation with `mockImplementation()` after spying.",
          "examples": [
            {
              "id": "example_mock_functions_1",
              "title": "Testing a Button Click with a Mock Handler",
              "code": "import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport Button from './Button';\n\ntest('calls onClick handler when clicked', () => {\n  // Create a mock function using jest.fn()\n  const handleClick = jest.fn();\n  \n  // Render the Button component, passing the mock function as the onClick prop\n  render(<Button onClick={handleClick}>Click Me</Button>);\n  \n  // Find the button element by its role and accessible name\n  const button = screen.getByRole('button', { name: /click me/i });\n  \n  // Simulate a click event on the button\n  fireEvent.click(button);\n  \n  // Assert that the mock function was called exactly once\n  expect(handleClick).toHaveBeenCalledTimes(1);\n\n  // You could also check if it was called with specific arguments if applicable\n  // expect(handleClick).toHaveBeenCalledWith('someValue');\n});\n\n// Button.jsx (for context)\n// import React from 'react';\n// const Button = ({ onClick, children }) => (\n//   <button onClick={onClick}>\n//     {children}\n//   </button>\n// );\n// export default Button;\n",
              "explanation": "This example demonstrates mocking a callback function (`onClick`) passed as a prop to a `Button` component. `jest.fn()` creates the mock. `render` mounts the component. `screen.getByRole` finds the button. `fireEvent.click` simulates a user clicking the button. Finally, `expect(handleClick).toHaveBeenCalledTimes(1)` asserts that the mock function was indeed called once, verifying the button's intended behavior without actually executing the real `onClick` logic.",
              "language": "typescript"
            },
            {
              "id": "example_mock_functions_2",
              "title": "Mocking API Calls in Component Tests",
              "code": "import React from 'react';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport UserProfile from './UserProfile';\n\n// Mock the entire 'axios' module\njest.mock('axios', () => ({\n  get: jest.fn(() => Promise.resolve({ data: { name: 'Alice', email: 'alice@example.com' } }))\n}));\n\nimport axios from 'axios'; // Import after jest.mock to get the mocked version\n\ndescribe('UserProfile', () => {\n  it('should display user data fetched from API', async () => {\n    render(<UserProfile userId={123} />);\n    \n    // Verify that axios.get was called with the correct URL\n    expect(axios.get).toHaveBeenCalledWith('/api/users/123');\n    \n    // Wait for the asynchronous data to appear in the DOM\n    await waitFor(() => {\n      expect(screen.getByText('Alice')).toBeInTheDocument();\n      expect(screen.getByText('alice@example.com')).toBeInTheDocument();\n    });\n  });\n});\n\n// UserProfile.jsx (for context)\n// import React, { useEffect, useState } from 'react';\n// import axios from 'axios';\n// const UserProfile = ({ userId }) => {\n//   const [user, setUser] = useState(null);\n//   useEffect(() => {\n//     axios.get(`/api/users/${userId}`).then(response => setUser(response.data));\n//   }, [userId]);\n//   if (!user) return <div>Loading...</div>;\n//   return (\n//     <div>\n//       <h2>{user.name}</h2>\n//       <p>{user.email}</p>\n//     </div>\n//   );\n// };\n// export default UserProfile;\n",
              "explanation": "This advanced example shows how to mock an external dependency (`axios`) for testing components that perform API calls. `jest.mock('axios', ...)` replaces the entire module with a mock. The mock's `get` method is configured to return a resolved promise with mock data. This allows the `UserProfile` component to render as if data was fetched, enabling isolated testing of the component's rendering logic without making actual network requests. `waitFor` is used to handle the asynchronous update of the DOM.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_mock_functions_1",
            "question_mock_functions_2",
            "question_mock_functions_3",
            "question_mock_functions_4"
          ],
          "relatedTasks": [
            "task_mock_functions_1"
          ],
          "tags": [
            "Jest",
            "Mocking",
            "Unit Testing",
            "API Testing",
            "Frontend Testing",
            "React Testing Library"
          ],
          "technology": "React",
          "prerequisites": [
            "Jest Basics",
            "React State & Props",
            "Asynchronous JavaScript"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Integration Testing",
            "Redux Testing"
          ]
        },
        {
          "id": "theory_snapshot_testing",
          "title": "Snapshot Testing in React",
          "content": "Snapshot testing is a powerful feature of Jest that allows you to capture the rendered output of a component at a specific point in time and compare it against a previously saved snapshot. This is particularly useful for UI components to ensure that unintended changes don't occur.\n\n### Key Concepts:\n*   **`react-test-renderer`:** A package that provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment. This is what Jest uses under the hood for snapshot testing.\n*   **`renderer.create(<Component />).toJSON()`:** This method from `react-test-renderer` creates a JSON representation of the rendered component tree, which is then used to form the snapshot.\n*   **`toMatchSnapshot()`:** A Jest matcher that saves the JSON representation as a `.snap` file on the first run. On subsequent runs, it compares the current rendered output to the saved snapshot. If they don't match, the test fails, indicating a change in the component's output.\n*   **Updating Snapshots:** When a component's output changes intentionally (e.g., due to a feature update or bug fix), the saved snapshot needs to be updated. This is typically done by running Jest with the `-u` or `--updateSnapshot` flag (`jest -u`).\n\n### When to use Snapshot Testing:\n*   To ensure the UI doesn't change unexpectedly (e.g., regressions).\n*   For components with complex, static structures.\n*   To quickly catch accidental styling or structural changes.\n\n### When NOT to use Snapshot Testing:\n*   For frequently changing components or dynamic data, as it leads to frequent snapshot updates, making tests brittle.\n*   As a replacement for behavioral testing (e.g., checking user interactions). Snapshot tests confirm *what* is rendered, not *how* it behaves.\n*   For large, entire pages, as snapshots can become very large and hard to review.",
          "examples": [
            {
              "id": "example_snapshot_testing_1",
              "title": "Basic Snapshot Test for a Card Component",
              "code": "import React from 'react';\nimport renderer from 'react-test-renderer';\nimport Card from './Card';\n\ntest('Card component matches snapshot', () => {\n  // Create a React test renderer instance for the Card component\n  const component = renderer.create(\n    <Card title=\"Example Card\" content=\"This is an example card.\" />\n  );\n  \n  // Convert the rendered component to a JSON tree\n  const tree = component.toJSON();\n  \n  // Compare the JSON tree against the last saved snapshot\n  // On the first run, this creates the .snap file.\n  // On subsequent runs, it compares against the existing .snap file.\n  expect(tree).toMatchSnapshot();\n});\n\n// Card.jsx (for context)\n// import React from 'react';\n// const Card = ({ title, content }) => (\n//   <div className=\"card\">\n//     <h2 className=\"card-title\">{title}</h2>\n//     <p className=\"card-content\">{content}</p>\n//   </div>\n// );\n// export default Card;\n",
              "explanation": "This example demonstrates a basic snapshot test. A `Card` component is rendered using `react-test-renderer`. The rendered output is converted to a JSON object (`tree`) and then compared against a stored snapshot using `toMatchSnapshot()`. This ensures that any unintended changes to the `Card` component's structure or content will cause the test to fail, prompting a review of the changes.",
              "language": "typescript"
            },
            {
              "id": "example_snapshot_testing_2",
              "title": "Snapshot with Props Variations",
              "code": "import React from 'react';\nimport renderer from 'react-test-renderer';\nimport Profile from './Profile';\n\ndescribe('Profile component snapshots', () => {\n  it('renders a default profile correctly', () => {\n    const tree = renderer.create(<Profile />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders a profile with custom user data', () => {\n    const user = {\n      name: 'Jane Doe',\n      age: 30,\n      email: 'jane@example.com'\n    };\n    const tree = renderer.create(<Profile user={user} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders a profile with a loading state', () => {\n    const tree = renderer.create(<Profile isLoading={true} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n\n// Profile.jsx (for context)\n// import React from 'react';\n// const Profile = ({ user, isLoading }) => {\n//   if (isLoading) return <div>Loading profile...</div>;\n//   if (!user) return <div>No profile data.</div>;\n//   return (\n//     <div className=\"profile-card\">\n//       <h3>{user.name}</h3>\n//       <p>Age: {user.age}</p>\n//       <p>Email: {user.email}</p>\n//     </div>\n//   );\n// };\n// export default Profile;\n",
              "explanation": "This example shows how to use multiple `it` blocks within a `describe` block to create different snapshots for a single component based on varying props or states. This helps ensure that the component renders correctly under different conditions, providing comprehensive UI regression protection.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_snapshot_testing_1",
            "question_snapshot_testing_2",
            "question_snapshot_testing_3",
            "question_snapshot_testing_4"
          ],
          "relatedTasks": [
            "task_snapshot_testing_1"
          ],
          "tags": [
            "Jest",
            "Snapshot Testing",
            "UI Testing",
            "Regression Testing",
            "Frontend Testing"
          ],
          "technology": "React",
          "prerequisites": [
            "Jest Basics",
            "React Component Structure"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Component Testing"
          ]
        },
        {
          "id": "theory_context_redux_testing",
          "title": "Testing React Components with Context and Redux",
          "content": "When testing React components that rely on Context or Redux, you need to ensure that the component has access to the necessary context or store. This typically involves wrapping the component under test with the appropriate provider components and providing a controlled state for your tests.\n\n### Key Concepts:\n*   **Providing Context/Redux Store:** Components consuming Context or Redux state must be rendered within their respective `Provider` components. In tests, you'll render the component under test wrapped by these providers.\n*   **`Provider` (from `react-redux` or custom context):** Makes the Redux store or context value available to all nested components.\n*   **`redux-mock-store`:** A library specifically designed to create mock Redux stores for testing. It allows you to define an initial state and then inspect actions dispatched to the store. This is preferred over a real Redux store in unit tests for performance and isolation.\n*   **`configureStore` (from `redux-mock-store`):** A function used to create the mock store factory.\n*   **Initial State:** When creating a mock store, you provide the `initialState` that the component under test expects to receive.\n\n### General Approach:\n1.  **Import necessary utilities:** `render` from `@testing-library/react`, `Provider` from `react-redux` (or your context), and `configureStore` from `redux-mock-store`.\n2.  **Create `mockStore` factory:** `const mockStore = configureStore([]);` (The empty array is for middleware, often not needed for simple unit tests).\n3.  **Define `initialState`:** Set up the slice of the Redux state that your component needs for the specific test case.\n4.  **Create a store instance:** `const store = mockStore(initialState);`\n5.  **Render the component:** Wrap the component under test with the `Provider`, passing your `store` instance.\n6.  **Assert:** Use React Testing Library queries to check the rendered output based on the provided state.\n\nFor React Context, the approach is similar: wrap the component with `MyContext.Provider` and pass a mock value to the `value` prop.",
          "examples": [
            {
              "id": "example_context_redux_testing_1",
              "title": "Testing a Redux-Connected Component",
              "code": "import { render, screen } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\nimport ConnectedComponent from './ConnectedComponent';\n\n// Create a mock store factory\nconst mockStore = configureStore([]);\n\ntest('connected component renders with redux store', () => {\n  // Define the initial state that the component expects\n  const initialState = { user: { name: 'John Doe', status: 'active' } };\n  // Create a mock store instance with the defined initial state\n  const store = mockStore(initialState);\n  \n  // Render the ConnectedComponent wrapped in the Redux Provider\n  render(\n    <Provider store={store}>\n      <ConnectedComponent />\n    </Provider>\n  );\n  \n  // Assert that elements deriving their content from the store are present\n  expect(screen.getByText(/John Doe/i)).toBeInTheDocument();\n  expect(screen.getByText(/Status: active/i)).toBeInTheDocument();\n\n  // You can also assert on actions dispatched, if your component dispatches actions\n  // fireEvent.click(screen.getByRole('button', { name: /logout/i }));\n  // const actions = store.getActions();\n  // expect(actions).toEqual([{ type: 'LOGOUT_USER' }]);\n});\n\n// ConnectedComponent.jsx (for context - example using useSelector)\n// import React from 'react';\n// import { useSelector } from 'react-redux';\n// const ConnectedComponent = () => {\n//   const user = useSelector(state => state.user);\n//   return (\n//     <div>\n//       <p>User Name: {user.name}</p>\n//       <p>Status: {user.status}</p>\n//     </div>\n//   );\n// };\n// export default ConnectedComponent;\n",
              "explanation": "This example, taken from the markdown, shows how to test a React component that is connected to a Redux store. `redux-mock-store` is used to create a lightweight, predictable store for testing purposes. The `ConnectedComponent` is wrapped in the `Provider` with the mock store, allowing it to access the `initialState` just as it would a real Redux store. Assertions then verify that the component correctly renders data from the provided state.",
              "language": "typescript"
            },
            {
              "id": "example_context_redux_testing_2",
              "title": "Testing Component with React Context",
              "code": "import React, { createContext, useContext } from 'react';\nimport { render, screen } from '@testing-library/react';\n\n// Define a mock context for testing\nconst ThemeContext = createContext('light');\n\nconst ThemedComponent = () => {\n  const theme = useContext(ThemeContext);\n  return <div data-testid=\"themed-div\">Current theme: {theme}</div>;\n};\n\ndescribe('ThemedComponent', () => {\n  it('renders with default context value', () => {\n    render(<ThemedComponent />);\n    expect(screen.getByText('Current theme: light')).toBeInTheDocument();\n  });\n\n  it('renders with provided context value', () => {\n    render(\n      <ThemeContext.Provider value=\"dark\">\n        <ThemedComponent />\n      </ThemeContext.Provider>\n    );\n    expect(screen.getByText('Current theme: dark')).toBeInTheDocument();\n  });\n});\n",
              "explanation": "This example illustrates how to test a component that consumes React Context. In the first test, the component renders with its default context value. In the second test, `ThemedComponent` is explicitly wrapped with `ThemeContext.Provider`, and a `value` prop is supplied, overriding the default. This allows testing how the component behaves when different context values are provided, ensuring proper data flow through context.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_context_redux_testing_1",
            "question_context_redux_testing_2",
            "question_context_redux_testing_3",
            "question_context_redux_testing_4"
          ],
          "relatedTasks": [
            "task_context_redux_testing_1"
          ],
          "tags": [
            "Jest",
            "Redux Testing",
            "Context API",
            "React Redux",
            "Integration Testing",
            "Frontend Testing"
          ],
          "technology": "React",
          "prerequisites": [
            "React Context API",
            "Redux Fundamentals",
            "Jest Basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Complex Application Testing"
          ]
        },
        {
          "id": "theory_custom_hooks_testing",
          "title": "Testing React Custom Hooks",
          "content": "Testing custom hooks can be tricky because hooks are JavaScript functions that rely on React's internal mechanisms (like state, effects, context). You can't just call them like regular functions outside of a React component. The `@testing-library/react-hooks` library provides a solution by creating a temporary, isolated React component to run your hook within.\n\n### Key Concepts:\n*   **`@testing-library/react-hooks`:** A library specifically designed for testing React hooks in isolation. It manages the lifecycle of a test component where your hook can run.\n*   **`renderHook(callback, options)`:** The primary function from `@testing-library/react-hooks`. It takes a callback function that executes your hook and returns an object containing the `result` of the hook and `rerender` utility.\n    *   `callback`: A function that calls your custom hook. For example, `() => useCounter()`. Any props passed to the hook can be provided via `options.initialProps`.\n    *   `options.initialProps`: An object of props to pass to your hook during its initial render.\n*   **`result.current`:** The `result` object returned by `renderHook` has a `current` property that holds the latest value returned by your hook. This is how you access the hook's state, return values, or functions.\n*   **`act(() => ...)`:** A utility from `react-test-renderer/test-utils` (re-exported by `@testing-library/react` and `@testing-library/react-hooks`). It ensures that all updates related to your hook's state (e.g., state changes, effects) are processed before assertions are made. Any code that causes state updates or renders in your hook *must* be wrapped in `act()` to ensure predictable test behavior and avoid warnings.\n*   **`rerender(newProps)`:** A function returned by `renderHook` that allows you to simulate a re-render of the hook, optionally with new props, without re-mounting the underlying test component. Useful for testing effects that depend on prop changes.\n*   **`unmount()`:** A function returned by `renderHook` to simulate unmounting the component that uses the hook. Useful for testing cleanup logic in `useEffect`.\n\n### General Approach:\n1.  **Import `renderHook` and `act`:** From `@testing-library/react-hooks`.\n2.  **Call `renderHook`:** Pass a callback that invokes your custom hook. Destructure `result` (and `rerender`/`unmount` if needed).\n3.  **Interact with the hook (if applicable):** If your hook returns functions that modify its state, call them via `result.current`. **Wrap these calls in `act()`**.\n4.  **Assert:** Use `expect(result.current.value).toBe(...)` to check the hook's returned state or values.",
          "examples": [
            {
              "id": "example_custom_hooks_testing_1",
              "title": "Testing a simple useCounter Hook",
              "code": "import { renderHook, act } from '@testing-library/react-hooks';\nimport useCounter from './useCounter';\n\ntest('should increment counter', () => {\n  // Render the useCounter hook inside a test component\n  const { result } = renderHook(() => useCounter());\n  \n  // Interact with the hook's returned function, wrapped in `act`\n  // `act` ensures all state updates caused by increment() are processed\n  act(() => {\n    result.current.increment();\n  });\n  \n  // Assert the updated value of the counter\n  expect(result.current.count).toBe(1);\n});\n\ntest('should decrement counter', () => {\n  const { result } = renderHook(() => useCounter(5)); // Start with initial value\n  \n  act(() => {\n    result.current.decrement();\n  });\n  \n  expect(result.current.count).toBe(4);\n});\n\n// useCounter.js (for context)\n// import { useState, useCallback } from 'react';\n// const useCounter = (initialValue = 0) => {\n//   const [count, setCount] = useState(initialValue);\n//   const increment = useCallback(() => setCount(prevCount => prevCount + 1), []);\n//   const decrement = useCallback(() => setCount(prevCount => prevCount - 1), []);\n//   return { count, increment, decrement };\n// };\n// export default useCounter;\n",
              "explanation": "This example directly from the markdown illustrates testing a custom `useCounter` hook. `renderHook` is used to create a test environment for the hook. `result.current` provides access to the `count`, `increment`, and `decrement` values/functions returned by the hook. Crucially, the calls to `result.current.increment()` (or `decrement()`) are wrapped in `act()` to ensure that React processes all state updates before assertions are made, preventing potential race conditions or incorrect test results.",
              "language": "typescript"
            },
            {
              "id": "example_custom_hooks_testing_2",
              "title": "Testing a Hook with Effects and Async Operations",
              "code": "import { renderHook, act, waitFor } from '@testing-library/react-hooks';\nimport { useEffect, useState } from 'react';\n\nconst useFetch = (url) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n};\n\ndescribe('useFetch hook', () => {\n  beforeAll(() => {\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve({ message: 'Success!' })\n      })\n    );\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should fetch data successfully', async () => {\n    const { result, waitForNextUpdate } = renderHook(() => useFetch('/api/data'));\n\n    expect(result.current.loading).toBe(true);\n    expect(result.current.data).toBe(null);\n\n    await waitForNextUpdate(); // Wait for the effect to complete\n\n    expect(result.current.loading).toBe(false);\n    expect(result.current.data).toEqual({ message: 'Success!' });\n    expect(result.current.error).toBe(null);\n    expect(global.fetch).toHaveBeenCalledWith('/api/data');\n  });\n\n  it('should handle fetch errors', async () => {\n    global.fetch.mockImplementationOnce(() =>\n      Promise.resolve({ ok: false, status: 500 })\n    );\n\n    const { result, waitForNextUpdate } = renderHook(() => useFetch('/api/error'));\n\n    await waitForNextUpdate();\n\n    expect(result.current.loading).toBe(false);\n    expect(result.current.data).toBe(null);\n    expect(result.current.error).toBeInstanceOf(Error);\n  });\n});\n",
              "explanation": "This advanced example demonstrates testing a custom hook (`useFetch`) that performs asynchronous operations (fetching data). `global.fetch` is mocked to control the network response. `waitForNextUpdate()` (or `waitFor` if you're asserting DOM changes) is crucial here to await the completion of the `useEffect` and subsequent state updates. This ensures the test checks the final state of the hook after the async operation has resolved, including loading, data, and error states.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_custom_hooks_testing_1",
            "question_custom_hooks_testing_2",
            "question_custom_hooks_testing_3",
            "question_custom_hooks_testing_4"
          ],
          "relatedTasks": [
            "task_custom_hooks_testing_1"
          ],
          "tags": [
            "Jest",
            "Custom Hooks",
            "React Hooks",
            "Unit Testing",
            "Frontend Testing",
            "Asynchronous Testing"
          ],
          "technology": "React",
          "prerequisites": [
            "React Hooks",
            "Jest Basics",
            "Asynchronous JavaScript"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Complex Hook Development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_jest_react_basics_1",
          "topic": "Jest and React Testing Library Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "Which `React Testing Library` function is best suited for rendering a React component into a test environment?",
          "answer": "`render`",
          "options": [
            "`mount`",
            "`render`",
            "`shallow`",
            "`createRoot`"
          ],
          "analysisPoints": [
            "Tests knowledge of basic RTL setup.",
            "Distinguishes between RTL and other testing paradigms (e.g., Enzyme's `mount`/`shallow`)."
          ],
          "keyConcepts": [
            "`render`",
            "React Testing Library",
            "Component Mounting"
          ],
          "evaluationCriteria": [
            "Correct identification of RTL's primary rendering function.",
            "Understanding of the purpose of component rendering in tests."
          ],
          "example": "The `render` function from `@testing-library/react` is the primary utility for rendering your React components into a DOM element that is attached to `document.body`. This allows you to interact with your component as a user would. Options like `mount` and `shallow` are associated with Enzyme, an older testing utility, while `createRoot` is for React 18+ client-side rendering setup, not typically for isolated component testing.",
          "tags": [
            "Jest",
            "React Testing Library",
            "Unit Testing"
          ],
          "prerequisites": [
            "React Testing Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_jest_react_basics_2",
          "topic": "Jest and React Testing Library Fundamentals",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary philosophy behind React Testing Library (RTL) and how it differs from testing component internals. Provide an example of how this philosophy is applied when querying elements.",
          "answer": "React Testing Library's primary philosophy is to test components in a way that resembles how users interact with them. It encourages testing the *behavior* of the component from the user's perspective, rather than its internal implementation details (like state, props, or component methods). This leads to more robust and maintainable tests because they are less likely to break when the internal implementation of a component changes, as long as its public behavior remains consistent.\n\nThe philosophy can be summarized as: \"The more your tests resemble the way your software is used, the more confidence they can give you.\"\n\nThis differs from testing component internals because it avoids directly accessing a component's internal state (`component.state.value`) or props (`component.props.data`) or calling its methods directly. Instead, you interact with the rendered DOM nodes.\n\n**Example of application when querying elements:**\nInstead of querying by `data-testid` or component instance properties, RTL encourages using queries that reflect how a user or assistive technology would find an element. For instance, to find a button, you wouldn't query `getByTestId('my-button')` unless absolutely necessary. You would prefer:\n\n*   `getByRole('button', { name: /submit/i })`: This is the most preferred method as it mimics how a screen reader user would perceive the button.\n*   `getByText('Submit')`: If the button has visible text.\n\nThis approach ensures that if a developer changes the `data-testid` or adds/removes an internal prop, the test won't break, as long as the user can still interact with the button and its functionality remains the same. If the button no longer has a 'submit' role or text, then it's a user-facing change that *should* break the test, signaling a change in behavior.",
          "analysisPoints": [
            "Tests understanding of RTL's core principles.",
            "Evaluates ability to articulate the benefits of behavioral testing.",
            "Checks knowledge of preferred querying methods in RTL."
          ],
          "keyConcepts": [
            "React Testing Library Philosophy",
            "Behavioral Testing",
            "Accessibility (ARIA roles)",
            "Queries (getByRole, getByText)"
          ],
          "evaluationCriteria": [
            "Clear explanation of RTL philosophy.",
            "Correct comparison with internal testing.",
            "Appropriate and specific example of querying.",
            "Emphasis on user perspective and accessibility."
          ],
          "example": null,
          "tags": [
            "React Testing Library",
            "Testing Philosophy",
            "Best Practices",
            "Accessibility",
            "Queries"
          ],
          "prerequisites": [
            "React Testing Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jest_react_basics_3",
          "topic": "Jest and React Testing Library Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `expect(element).toBeInTheDocument()` in a React Testing Library test?",
          "answer": "It asserts that the given DOM element is present within the document (i.e., rendered and accessible in the DOM tree).",
          "analysisPoints": [
            "Verifies knowledge of common Jest-DOM matchers.",
            "Tests understanding of asserting element presence."
          ],
          "keyConcepts": [
            "`toBeInTheDocument`",
            "Jest-DOM",
            "Assertions"
          ],
          "evaluationCriteria": [
            "Accurate description of the matcher's function.",
            "Understanding its role in verifying rendering."
          ],
          "example": null,
          "tags": [
            "Jest",
            "React Testing Library",
            "Matchers"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_jest_react_basics_4",
          "topic": "Jest and React Testing Library Fundamentals",
          "level": "medium",
          "type": "code",
          "question": "Given the following React component, write a Jest and React Testing Library test that verifies:\n1. The `title` prop is rendered as an `<h2>` element.\n2. The `description` prop is rendered as a `<p>` element.\n3. If `isFeatured` is true, a `<span>` with the text 'Featured!' is rendered.",
          "answer": "```typescript\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\n\n// MyCard.jsx (for context, imagine this is in a separate file)\nconst MyCard = ({ title, description, isFeatured }) => (\n  <div>\n    <h2>{title}</h2>\n    <p>{description}</p>\n    {isFeatured && <span data-testid=\"featured-badge\">Featured!</span>}\n  </div>\n);\n\ndescribe('MyCard component', () => {\n  it('renders title and description correctly', () => {\n    render(<MyCard title=\"Test Title\" description=\"Test Description\" />);\n    expect(screen.getByRole('heading', { level: 2, name: 'Test Title' })).toBeInTheDocument();\n    expect(screen.getByText('Test Description')).toBeInTheDocument();\n  });\n\n  it('renders featured badge when isFeatured is true', () => {\n    render(<MyCard title=\"Featured Card\" description=\"\" isFeatured={true} />);\n    expect(screen.getByText('Featured!')).toBeInTheDocument();\n    // Alternatively, using data-testid for non-semantic elements\n    expect(screen.getByTestId('featured-badge')).toBeInTheDocument();\n  });\n\n  it('does not render featured badge when isFeatured is false', () => {\n    render(<MyCard title=\"Regular Card\" description=\"\" isFeatured={false} />);\n    expect(screen.queryByText('Featured!')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('featured-badge')).not.toBeInTheDocument();\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to use `render` and `screen`.",
            "Checks understanding of `getByRole`, `getByText`, and `queryByText`.",
            "Verifies conditional rendering assertion.",
            "Demonstrates proper `describe` and `it` block usage."
          ],
          "keyConcepts": [
            "React Testing Library",
            "Jest",
            "Queries",
            "Conditional Rendering",
            "Assertions"
          ],
          "evaluationCriteria": [
            "Correctly sets up the test file.",
            "Uses appropriate query methods (`getByRole`, `getByText`, `queryByText`).",
            "Accurately asserts text content and element presence/absence.",
            "Handles conditional rendering effectively."
          ],
          "example": null,
          "tags": [
            "Jest",
            "React Testing Library",
            "Code Challenge",
            "Unit Testing"
          ],
          "prerequisites": [
            "React Basics",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_mock_functions_1",
          "topic": "Mock Functions in React Tests",
          "level": "medium",
          "type": "mcq",
          "question": "You have a `LoginForm` component with an `onSubmit` prop. You want to verify that `onSubmit` is called exactly once when the form is submitted. Which of the following code snippets correctly sets up the mock function and asserts its call count?",
          "answer": "```typescript\nconst handleSubmit = jest.fn();\nrender(<LoginForm onSubmit={handleSubmit} />);\nfireEvent.submit(screen.getByRole('form'));\nexpect(handleSubmit).toHaveBeenCalledTimes(1);\n```",
          "options": [
            "```typescript\nconst handleSubmit = () => {};\nrender(<LoginForm onSubmit={handleSubmit} />);\nfireEvent.submit(screen.getByRole('form'));\nexpect(handleSubmit).toHaveBeenCalled();\n```",
            "```typescript\nconst handleSubmit = jest.fn();\nrender(<LoginForm onSubmit={handleSubmit} />);\nfireEvent.submit(screen.getByRole('form'));\nexpect(handleSubmit).toHaveBeenCalledTimes(1);\n```",
            "```typescript\nconst handleSubmit = jest.mock();\nrender(<LoginForm onSubmit={handleSubmit} />);\nfireEvent.submit(screen.getByRole('form'));\nexpect(handleSubmit).toHaveBeenCalledTimes(1);\n```",
            "```typescript\nconst handleSubmit = jest.fn();\nrender(<LoginForm onSubmit={handleSubmit} />);\nhandleSubmit(); // Manually calling it\nexpect(handleSubmit).toHaveBeenCalledTimes(1);\n```"
          ],
          "analysisPoints": [
            "Tests correct usage of `jest.fn()` to create a mock.",
            "Verifies understanding of `fireEvent` to simulate user interaction.",
            "Checks knowledge of `toHaveBeenCalledTimes()` matcher.",
            "Distinguishes between a real function and a mock function for assertion."
          ],
          "keyConcepts": [
            "Mock Functions",
            "`jest.fn()`",
            "`fireEvent`",
            "Assertions (`toHaveBeenCalledTimes`)"
          ],
          "evaluationCriteria": [
            "Correct initialization of a mock function.",
            "Accurate simulation of a DOM event.",
            "Appropriate assertion for call count.",
            "Avoids common pitfalls like manually calling the mock or using non-mock functions."
          ],
          "example": "The correct option correctly uses `jest.fn()` to create a mock function that Jest can track. `fireEvent.submit` simulates the form submission, which in turn should trigger the `onSubmit` prop. Finally, `toHaveBeenCalledTimes(1)` precisely verifies that the mock function was invoked exactly once as a result of the form submission. The other options either don't create a mock (`() => {}`), use an incorrect mocking method (`jest.mock()`), or manually call the mock function, which doesn't test the component's behavior.",
          "tags": [
            "Jest",
            "Mocking",
            "React Testing Library",
            "MCQ"
          ],
          "prerequisites": [
            "Jest Basics",
            "React Forms"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_mock_functions_2",
          "topic": "Mock Functions in React Tests",
          "level": "hard",
          "type": "open",
          "question": "When testing a React component that makes an asynchronous API call (e.g., using `fetch` or `axios`), how would you use Jest's mocking capabilities to ensure your test is fast, isolated, and predictable? Describe the steps involved and differentiate between mocking a function prop and mocking an external module.",
          "answer": "To test a React component that makes an asynchronous API call, Jest's mocking capabilities are essential for ensuring the test is fast, isolated, and predictable. This involves preventing actual network requests and providing controlled responses.\n\n**Steps Involved:**\n1.  **Identify the dependency:** Determine which function or module is responsible for the API call (e.g., `window.fetch`, `axios`, or a custom API client). For third-party libraries like `axios`, module mocking is common.\n2.  **Create the mock:**\n    *   **For `window.fetch`:** Use `jest.spyOn(global, 'fetch')` to spy on the global `fetch` function, and then chain `.mockImplementation()` to control its return value (e.g., a resolved Promise with mock data or a rejected Promise for error scenarios).\n    *   **For an external module (e.g., `axios`):** Use `jest.mock('module-name')` at the top of your test file to mock the entire module. Inside the mock factory function, define the mocked methods (e.g., `get`, `post`) to return mock Promises. For example, `jest.mock('axios', () => ({ get: jest.fn(() => Promise.resolve({ data: { id: 1 } })) }));`.\n3.  **Render the component:** Use `render` from `@testing-library/react` to mount your component that performs the API call.\n4.  **Wait for asynchronous operations:** Since API calls are asynchronous, the component's state and DOM updates will happen after the promise resolves. Use `await screen.findBy...` queries, `waitFor` from RTL, or `waitForNextUpdate` (for hooks) to wait for the UI to reflect the data.\n5.  **Assert:** Verify that the mock function/method was called with the correct arguments (e.g., `expect(axios.get).toHaveBeenCalledWith('/api/users')`) and that the component renders the mock data correctly (`expect(screen.getByText('John Doe')).toBeInTheDocument()`).\n\n**Differentiation: Mocking a Function Prop vs. Mocking an External Module**\n\n*   **Mocking a Function Prop (`jest.fn()`):**\n    *   **Purpose:** Used when a component receives a function as a prop (e.g., `onSubmit`, `onSave`) and you want to ensure that the component calls this prop correctly when an event occurs.\n    *   **Mechanism:** You create a standalone mock function using `const myMock = jest.fn();` and pass it directly to the component as a prop: `<MyComponent onAction={myMock} />`.\n    *   **Isolation:** Tests the interaction *between* the parent and child component (the child calls the prop, the parent provides it). The focus is on verifying the callback was invoked.\n    *   **Example:** Testing a button's `onClick` prop, or a form's `onSubmit` prop.\n\n*   **Mocking an External Module (`jest.mock('module-name')` or `jest.spyOn()`):**\n    *   **Purpose:** Used when a component directly imports and uses functions/objects from external libraries (e.g., `axios`, `lodash`, `utility-functions.js`) or global APIs (`fetch`, `localStorage`). This allows you to control the behavior of these external dependencies during the test.\n    *   **Mechanism:** `jest.mock()` is typically placed at the top of the test file and replaces the entire module. `jest.spyOn()` allows you to monitor and/or replace a specific method on an existing object or module. The mocked behavior is defined within the mock factory function or using `mockImplementation()`.\n    *   **Isolation:** Achieves true unit testing by isolating the component from its external dependencies. The component behaves as if it's interacting with the real dependency, but under controlled conditions.\n    *   **Example:** Mocking `axios.get()` to control API responses, or mocking a custom logging utility to check if it was called.\n\nIn essence, `jest.fn()` is for testing interactions with *callback props*, while `jest.mock()` or `jest.spyOn()` are for isolating a component from its *external library/API dependencies*.",
          "analysisPoints": [
            "Comprehensive explanation of API mocking strategy.",
            "Clear distinction between `jest.fn()` and `jest.mock()`/`jest.spyOn()`.",
            "Demonstrates understanding of asynchronous testing with RTL utilities.",
            "Discusses benefits like speed, isolation, predictability."
          ],
          "keyConcepts": [
            "Mocking API Calls",
            "Jest.fn()",
            "Jest.mock()",
            "Jest.spyOn()",
            "Asynchronous Testing",
            "`waitFor`",
            "`findBy`"
          ],
          "evaluationCriteria": [
            "Detailed, step-by-step process for API mocking.",
            "Accurate and clear comparison of different mocking techniques.",
            "Correct mention of RTL's asynchronous utilities.",
            "Understanding of the core benefits of mocking in tests."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Mocking",
            "API Testing",
            "Asynchronous",
            "Unit Testing",
            "Interview Question"
          ],
          "prerequisites": [
            "Jest Basics",
            "Asynchronous JavaScript"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_mock_functions_3",
          "topic": "Mock Functions in React Tests",
          "level": "easy",
          "type": "flashcard",
          "question": "What Jest mock matcher would you use to verify that a mock function was called with specific arguments, for example, `myMock('hello', 123)`?",
          "answer": "`expect(myMock).toHaveBeenCalledWith('hello', 123);`",
          "analysisPoints": [
            "Tests knowledge of specific mock matchers.",
            "Verifies correct syntax for `toHaveBeenCalledWith`."
          ],
          "keyConcepts": [
            "Mock Matchers",
            "`toHaveBeenCalledWith`",
            "Jest"
          ],
          "evaluationCriteria": [
            "Correct identification of the matcher.",
            "Accurate recall of its usage."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Mocking",
            "Matchers",
            "Flashcard"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_mock_functions_4",
          "topic": "Mock Functions in React Tests",
          "level": "medium",
          "type": "code",
          "question": "Create a React component `InputWithButton` that contains an input field and a button. When the button is clicked, it should call an `onSubmit` prop with the current value of the input field. Write a Jest and React Testing Library test to verify that the `onSubmit` prop is called with the correct input value.",
          "answer": "```typescript\nimport React, { useState } from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\n\n// InputWithButton.jsx (for context)\nconst InputWithButton = ({ onSubmit }) => {\n  const [value, setValue] = useState('');\n\n  const handleChange = (e) => {\n    setValue(e.target.value);\n  };\n\n  const handleClick = () => {\n    onSubmit(value);\n    setValue(''); // Clear input after submission\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        placeholder=\"Enter text\"\n      />\n      <button onClick={handleClick}>Submit</button>\n    </div>\n  );\n};\n\ndescribe('InputWithButton', () => {\n  it('calls onSubmit with the input value when button is clicked', () => {\n    const mockOnSubmit = jest.fn();\n    render(<InputWithButton onSubmit={mockOnSubmit} />);\n\n    const inputElement = screen.getByPlaceholderText('Enter text');\n    const submitButton = screen.getByRole('button', { name: /submit/i });\n\n    // Simulate user typing into the input\n    fireEvent.change(inputElement, { target: { value: 'Hello Test!' } });\n\n    // Simulate user clicking the button\n    fireEvent.click(submitButton);\n\n    // Assert that the mock function was called once with the correct value\n    expect(mockOnSubmit).toHaveBeenCalledTimes(1);\n    expect(mockOnSubmit).toHaveBeenCalledWith('Hello Test!');\n\n    // Optionally, check if the input cleared\n    expect(inputElement).toHaveValue('');\n  });\n\n  it('does not call onSubmit if input is empty and button is clicked', () => {\n    const mockOnSubmit = jest.fn();\n    render(<InputWithButton onSubmit={mockOnSubmit} />);\n\n    const submitButton = screen.getByRole('button', { name: /submit/i });\n\n    fireEvent.click(submitButton);\n\n    // Assert that the mock function was NOT called\n    expect(mockOnSubmit).not.toHaveBeenCalled();\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to mock a function prop.",
            "Checks understanding of `fireEvent.change` for input fields.",
            "Verifies assertion using `toHaveBeenCalledWith`.",
            "Demonstrates testing component state changes (input clearing)."
          ],
          "keyConcepts": [
            "Mock Functions",
            "Jest.fn()",
            "FireEvent",
            "toHaveBeenCalledWith",
            "Component Interaction"
          ],
          "evaluationCriteria": [
            "Correct setup of mock function.",
            "Accurate simulation of user input and clicks.",
            "Precise assertions for function calls and arguments.",
            "Handles edge cases like empty input (optional, but good)."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Mocking",
            "React Testing Library",
            "Code Challenge",
            "Forms"
          ],
          "prerequisites": [
            "React State",
            "Jest Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_snapshot_testing_1",
          "topic": "Snapshot Testing",
          "level": "easy",
          "type": "mcq",
          "question": "Which Jest matcher is used to perform a snapshot test?",
          "answer": "`toMatchSnapshot()`",
          "options": [
            "`toEqual()`",
            "`toMatchObject()`",
            "`toMatchSnapshot()`",
            "`toBe()`"
          ],
          "analysisPoints": [
            "Tests direct knowledge of Jest snapshot matchers.",
            "Distinguishes `toMatchSnapshot` from other common Jest matchers."
          ],
          "keyConcepts": [
            "Snapshot Testing",
            "Jest Matchers"
          ],
          "evaluationCriteria": [
            "Correct identification of the snapshot matcher.",
            "Basic understanding of Jest matchers."
          ],
          "example": "The `toMatchSnapshot()` matcher is specifically designed for snapshot testing in Jest. When called, it serializes the value it receives and compares it to a previously saved snapshot file. If no snapshot exists, it creates one. The other options are general Jest matchers used for different types of comparisons.",
          "tags": [
            "Jest",
            "Snapshot Testing",
            "MCQ"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_snapshot_testing_2",
          "topic": "Snapshot Testing",
          "level": "medium",
          "type": "open",
          "question": "Discuss the primary advantages and disadvantages of using snapshot testing in a React application. When would it be most appropriate to use it, and when might it be problematic?",
          "answer": "**Advantages of Snapshot Testing:**\n1.  **Ease of Use & Quick Setup:** Snapshot tests are very easy to write and require minimal setup. A single `expect(component).toMatchSnapshot()` line can cover a large part of a component's rendering.\n2.  **Regression Detection:** They are excellent for catching unintended UI changes (regressions). If a change breaks the visual output, the snapshot test will fail, alerting the developer.\n3.  **Documentation:** Snapshots act as a form of documentation, showing exactly what a component renders at a given point in time.\n4.  **Coverage for Complex UIs:** For components with complex, static, or deeply nested structures, snapshot tests can provide extensive coverage with less effort than explicit DOM assertions.\n\n**Disadvantages of Snapshot Testing:**\n1.  **Brittleness:** They can be brittle. Minor, intentional changes (e.g., refactoring HTML structure, adding a new class for styling) will cause snapshot failures, requiring frequent updates (`jest -u`). This can lead to \"false positives\" where a test fails for a non-bug reason.\n2.  **Review Burden:** Large snapshots can be difficult and time-consuming to review during code reviews, making it hard to spot legitimate bugs amidst expected changes.\n3.  **Lack of Semantic Meaning:** Snapshots only capture the rendered output; they don't explicitly assert *what* that output means semantically or functionally. A button might be present in the snapshot, but the test doesn't confirm it's clickable or performs the correct action.\n4.  **Not a Replacement for Behavioral Tests:** They don't test user interactions or business logic. They are about *what* is rendered, not *how* it behaves.\n\n**When Most Appropriate:**\n*   **Static/Presentational Components:** Ideal for components that primarily render UI based on props and have a stable structure (e.g., `Header`, `Footer`, `Card`, `Icon`).\n*   **Regression Testing for Visual Changes:** To ensure that refactors or new features don't inadvertently alter existing UI elements.\n*   **Large, Complex HTML Structures:** When a component generates a lot of HTML, and explicitly asserting every element would be too verbose.\n\n**When Problematic:**\n*   **Highly Dynamic Components:** Components whose output changes frequently based on data or user interaction (e.g., a real-time chat window, a form that shows/hides many fields).\n*   **Components with Randomness/Timestamps:** Any component that includes dynamic data like current dates, unique IDs, or random values, as these will always cause snapshot mismatches.\n*   **As a Sole Testing Strategy:** Relying *only* on snapshot tests is insufficient. They should complement, not replace, unit and integration tests that verify behavior and functionality.",
          "analysisPoints": [
            "Covers both pros and cons comprehensively.",
            "Provides clear scenarios for appropriate and problematic use cases.",
            "Highlights the distinction between 'what' (snapshot) and 'how' (behavioral) testing."
          ],
          "keyConcepts": [
            "Snapshot Testing",
            "Advantages",
            "Disadvantages",
            "UI Regression",
            "Test Brittleness"
          ],
          "evaluationCriteria": [
            "Balanced perspective on snapshot testing.",
            "Specific examples for appropriate and problematic use.",
            "Demonstrates understanding of testing trade-offs.",
            "Clarity and organization of points."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Snapshot Testing",
            "Testing Philosophy",
            "Best Practices",
            "Interview Question"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_snapshot_testing_3",
          "topic": "Snapshot Testing",
          "level": "easy",
          "type": "flashcard",
          "question": "What command line flag do you use with Jest to update existing snapshots?",
          "answer": "`-u` or `--updateSnapshot` (e.g., `jest -u`)",
          "analysisPoints": [
            "Tests practical command-line usage.",
            "Verifies knowledge of common Jest flags."
          ],
          "keyConcepts": [
            "Snapshot Testing",
            "Jest CLI",
            "Updating Snapshots"
          ],
          "evaluationCriteria": [
            "Correct recall of the command line flag.",
            "Understanding its purpose."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Snapshot Testing",
            "CLI",
            "Flashcard"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_snapshot_testing_4",
          "topic": "Snapshot Testing",
          "level": "medium",
          "type": "code",
          "question": "Consider a `ProductDisplay` component that receives `product` data as a prop. The `product` object can have `name`, `price`, and an optional `discount` property. If `discount` is present, it should render the original price struck through and the discounted price. Otherwise, just the regular price. Write snapshot tests to cover both scenarios (with and without discount).",
          "answer": "```typescript\nimport React from 'react';\nimport renderer from 'react-test-renderer';\n\n// ProductDisplay.jsx (for context)\nconst ProductDisplay = ({ product }) => {\n  const { name, price, discount } = product;\n\n  return (\n    <div className=\"product-card\">\n      <h3>{name}</h3>\n      {discount ? (\n        <p>\n          <span style={{ textDecoration: 'line-through' }}>${price.toFixed(2)}</span>\n          {' '}\n          <span style={{ color: 'red', fontWeight: 'bold' }}>${(price * (1 - discount)).toFixed(2)}</span>\n        </p>\n      ) : (\n        <p>${price.toFixed(2)}</p>\n      )}\n    </div>\n  );\n};\n\ndescribe('ProductDisplay snapshot tests', () => {\n  it('renders correctly for a product without discount', () => {\n    const product = {\n      name: 'Standard Widget',\n      price: 99.99,\n    };\n    const tree = renderer.create(<ProductDisplay product={product} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders correctly for a product with a discount', () => {\n    const product = {\n      name: 'Premium Gizmo',\n      price: 150.00,\n      discount: 0.20, // 20% off\n    };\n    const tree = renderer.create(<ProductDisplay product={product} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to set up `react-test-renderer`.",
            "Verifies creation of JSON tree.",
            "Checks application of `toMatchSnapshot`.",
            "Demonstrates snapshot testing with different prop variations to cover conditional rendering."
          ],
          "keyConcepts": [
            "Snapshot Testing",
            "Conditional Rendering",
            "React Test Renderer",
            "Jest"
          ],
          "evaluationCriteria": [
            "Correct setup for snapshot tests.",
            "Covers both conditional rendering paths with separate snapshots.",
            "Uses appropriate data for each scenario.",
            "Clear and concise test structure."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Snapshot Testing",
            "Code Challenge",
            "Conditional Rendering"
          ],
          "prerequisites": [
            "React Basics",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_redux_testing_1",
          "topic": "Testing with Context and Redux",
          "level": "medium",
          "type": "mcq",
          "question": "When testing a React component that consumes Redux state, which of the following is the most appropriate approach using Jest and React Testing Library?",
          "answer": "Wrap the component under test with `Provider` from `react-redux` and pass a mock store created by `redux-mock-store`.",
          "options": [
            "Directly import the Redux store into the test file and pass it to the component as a prop.",
            "Mock the `useSelector` hook directly using `jest.mock('react-redux')` to control the returned state.",
            "Wrap the component under test with `Provider` from `react-redux` and pass a mock store created by `redux-mock-store`.",
            "Avoid testing Redux-connected components directly; instead, test the pure component and the Redux reducer separately."
          ],
          "analysisPoints": [
            "Tests understanding of Redux testing best practices.",
            "Evaluates knowledge of `Provider` and `redux-mock-store`.",
            "Differentiates between unit testing and integration testing contexts for Redux components."
          ],
          "keyConcepts": [
            "Redux Testing",
            "React Redux Provider",
            "Redux Mock Store",
            "Integration Testing"
          ],
          "evaluationCriteria": [
            "Correctly identifies the recommended approach for Redux integration testing.",
            "Understanding of why `redux-mock-store` is used.",
            "Recognition of the role of `Provider`."
          ],
          "example": "To effectively test a Redux-connected component, you need to provide it with a Redux store. Using `redux-mock-store` is the most common and recommended approach. It allows you to create a controlled, predictable store instance with a specific initial state for your test, and also enables you to inspect dispatched actions. The component is then rendered wrapped in the `Provider` from `react-redux`, connecting it to this mock store. Directly importing the real store or mocking `useSelector` directly can lead to less realistic or more brittle tests, respectively. While testing pure components and reducers separately is good, it doesn't cover the integration aspect of the connected component.",
          "tags": [
            "Redux",
            "Testing",
            "React Redux",
            "Mocking",
            "MCQ"
          ],
          "prerequisites": [
            "Redux Fundamentals",
            "React Testing Library"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_redux_testing_2",
          "topic": "Testing with Context and Redux",
          "level": "hard",
          "type": "open",
          "question": "Imagine you have a `UserDashboard` component that displays user information, which it retrieves using `useContext` from an `AuthContext` and potentially dispatches actions to a Redux store for logout functionality. Describe how you would set up your test environment to test this component's rendering and interaction behavior effectively. Include considerations for both context and Redux.",
          "answer": "To effectively test a `UserDashboard` component that consumes `AuthContext` and interacts with a Redux store, the test environment needs to provide controlled mock values for both dependencies. The goal is to isolate the `UserDashboard` component, ensuring its rendering and behavior are tested independently of the actual Redux store or Auth context's full implementation.\n\n**Setup for AuthContext:**\n1.  **Define a Mock Context Provider:** Create a simple wrapper component that provides a controlled `AuthContext.Provider` for your tests. This allows you to easily pass different mock `value` objects to the context for various test scenarios.\n    ```typescript\n    // test-utils.js (or similar)\n    import React from 'react';\n    import { render as rtlRender } from '@testing-library/react';\n    import { AuthContext } from './AuthContext'; // Assume AuthContext is exported\n\n    function renderWithAuthContext(ui, { providerProps, ...renderOptions } = {}) {\n      return rtlRender(\n        <AuthContext.Provider value={providerProps.value}>\n          {ui}\n        </AuthContext.Provider>,\n        renderOptions\n      );\n    }\n    export * from '@testing-library/react';\n    export { renderWithAuthContext as render };\n    ```\n2.  **Provide Mock Values:** In your tests, call this custom `render` function, passing the desired `value` for the context.\n\n**Setup for Redux Store:**\n1.  **`redux-mock-store`:** Use `redux-mock-store` to create a test-specific Redux store. This allows you to define the initial state the component expects and to inspect any actions dispatched by the component.\n    ```typescript\n    import configureStore from 'redux-mock-store';\n    const mockStore = configureStore([]); // No middleware for simple tests\n    ```\n2.  **Create Store Instance with Initial State:** For each test case, define the `initialState` relevant to that test and create a new mock store instance.\n    ```typescript\n    const initialState = { auth: { user: { name: 'Test User' } }, other: {} };\n    const store = mockStore(initialState);\n    ```\n\n**Combining Both for `UserDashboard` Testing:**\n\n```typescript\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\n// Assume UserDashboard uses useContext(AuthContext) and useDispatch()\nimport { AuthContext } from './AuthContext';\nimport UserDashboard from './UserDashboard'; \n\nconst mockReduxStore = configureStore([]);\n\ndescribe('UserDashboard', () => {\n  it('renders user name from AuthContext and Redux state', () => {\n    const mockAuthContextValue = { user: { id: '123', role: 'admin' }, isAuthenticated: true };\n    const mockReduxInitialState = { preferences: { theme: 'dark' } }; // Example Redux state\n    const store = mockReduxStore(mockReduxInitialState);\n\n    render(\n      <AuthContext.Provider value={mockAuthContextValue}>\n        <Provider store={store}>\n          <UserDashboard />\n        </Provider>\n      </AuthContext.Provider>\n    );\n\n    // Assertions based on AuthContext\n    expect(screen.getByText(/Welcome, admin user!/i)).toBeInTheDocument(); // Assuming component logic\n    // Assertions based on Redux state\n    expect(screen.getByText(/Current theme: dark/i)).toBeInTheDocument(); // Assuming component logic\n  });\n\n  it('dispatches logout action when logout button is clicked', () => {\n    const mockAuthContextValue = { user: { id: '123' }, isAuthenticated: true };\n    const mockReduxInitialState = { preferences: { theme: 'light' } };\n    const store = mockReduxStore(mockReduxInitialState);\n\n    render(\n      <AuthContext.Provider value={mockAuthContextValue}>\n        <Provider store={store}>\n          <UserDashboard />\n        </Provider>\n      </AuthContext.Provider>\n    );\n\n    fireEvent.click(screen.getByRole('button', { name: /logout/i }));\n\n    // Assert that the correct action was dispatched\n    const actions = store.getActions();\n    expect(actions).toEqual([{ type: 'AUTH_LOGOUT' }]);\n  });\n\n  it('shows login prompt if not authenticated via AuthContext', () => {\n    const mockAuthContextValue = { user: null, isAuthenticated: false };\n    const store = mockReduxStore({}); // Empty Redux state if not relevant\n\n    render(\n      <AuthContext.Provider value={mockAuthContextValue}>\n        <Provider store={store}>\n          <UserDashboard />\n        </Provider>\n      </AuthContext.Provider>\n    );\n    expect(screen.getByText(/Please log in/i)).toBeInTheDocument();\n  });\n});\n```\n\n**Considerations:**\n*   **Isolation:** Each test should ideally create its own mock context and store instances to ensure test isolation and prevent state leakage between tests.\n*   **Realism:** While mocking is used, the setup still mimics the real application structure (wrapping with Providers) as much as possible, aligning with RTL's philosophy.\n*   **Action Inspection:** `redux-mock-store`'s `getActions()` method is crucial for verifying that the component dispatches the correct Redux actions in response to user interactions.\n*   **Testing Different States:** Design tests to cover various states of both context and Redux (e.g., authenticated/unauthenticated, different user roles, various Redux data states).",
          "analysisPoints": [
            "Comprehensive plan for testing a multi-dependency component.",
            "Demonstrates combining mock context and mock Redux store setups.",
            "Illustrates how to provide different states/values for testing scenarios.",
            "Explains how to verify dispatched Redux actions.",
            "Highlights key considerations for robust testing."
          ],
          "keyConcepts": [
            "Context Testing",
            "Redux Testing",
            "Mocking Dependencies",
            "Integration Testing",
            "`redux-mock-store`",
            "`AuthContext.Provider`",
            "Action Inspection"
          ],
          "evaluationCriteria": [
            "Detailed and actionable test setup steps.",
            "Correct use of `Provider` and `redux-mock-store`.",
            "Shows how to test rendering based on provided state and dispatched actions.",
            "Addresses both context and Redux in a combined scenario.",
            "Demonstrates understanding of testing complex components."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Context API",
            "Testing Strategy",
            "Integration Testing",
            "Advanced Testing",
            "Interview Question"
          ],
          "prerequisites": [
            "React Context API",
            "Redux Fundamentals",
            "Jest Mocking"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "expert"
        },
        {
          "id": "question_context_redux_testing_3",
          "topic": "Testing with Context and Redux",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using `redux-mock-store` instead of a real Redux store in unit tests for connected components?",
          "answer": "It provides a lightweight, predictable store for testing, allowing you to define a specific initial state and easily inspect dispatched actions without the overhead of a full Redux setup.",
          "analysisPoints": [
            "Tests understanding of mock store benefits.",
            "Highlights aspects of isolation and control in testing."
          ],
          "keyConcepts": [
            "`redux-mock-store`",
            "Unit Testing",
            "Isolation",
            "Predictability"
          ],
          "evaluationCriteria": [
            "Accurate description of benefits.",
            "Focus on key testing principles."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Testing",
            "Mocking",
            "Flashcard"
          ],
          "prerequisites": [
            "Redux Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_redux_testing_4",
          "topic": "Testing with Context and Redux",
          "level": "medium",
          "type": "code",
          "question": "Create a `UserProfileDisplay` component that consumes a `UserContext` and displays the user's name and email. The `UserContext` provides an object `{ name: string, email: string }`. Write a test using React Testing Library to verify that the component correctly displays the user information provided by the context.",
          "answer": "```typescript\nimport React, { createContext, useContext } from 'react';\nimport { render, screen } from '@testing-library/react';\n\n// UserContext.js (for context)\nconst UserContext = createContext(null);\n\n// UserProfileDisplay.jsx (for context)\nconst UserProfileDisplay = () => {\n  const user = useContext(UserContext);\n  \n  if (!user) {\n    return <div>No user data available.</div>;\n  }\n\n  return (\n    <div>\n      <h2>Welcome, {user.name}!</h2>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n};\n\ndescribe('UserProfileDisplay', () => {\n  it('renders user details from UserContext', () => {\n    const mockUser = { name: 'Jane Doe', email: 'jane.doe@example.com' };\n\n    render(\n      <UserContext.Provider value={mockUser}>\n        <UserProfileDisplay />\n      </UserContext.Provider>\n    );\n\n    expect(screen.getByRole('heading', { name: 'Welcome, Jane Doe!' })).toBeInTheDocument();\n    expect(screen.getByText('Email: jane.doe@example.com')).toBeInTheDocument();\n  });\n\n  it('renders a fallback message when no user is provided', () => {\n    render(\n      <UserContext.Provider value={null}>\n        <UserProfileDisplay />\n      </UserContext.Provider>\n    );\n\n    expect(screen.getByText('No user data available.')).toBeInTheDocument();\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to mock React Context.",
            "Checks understanding of providing context values in tests.",
            "Verifies assertions for content derived from context.",
            "Demonstrates testing conditional rendering based on context availability."
          ],
          "keyConcepts": [
            "React Context API",
            "Context Testing",
            "Provider",
            "React Testing Library",
            "Code Challenge"
          ],
          "evaluationCriteria": [
            "Correctly sets up `UserContext.Provider` with a mock value.",
            "Accurately asserts the rendered content based on context.",
            "Handles the null/no user context scenario.",
            "Clean and readable test code."
          ],
          "example": null,
          "tags": [
            "React Context",
            "Testing",
            "Code Challenge",
            "Unit Testing"
          ],
          "prerequisites": [
            "React Context API Basics",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_testing_1",
          "topic": "Testing Custom Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "When testing a custom React hook that updates its internal state (e.g., a counter hook), why is it important to wrap the hook's state-updating calls in `act()` from `@testing-library/react-hooks`?",
          "answer": "`act()` ensures that all updates related to the hook's state (including effects) are flushed and applied to the DOM before any assertions are made, making tests more predictable and avoiding warnings.",
          "options": [
            "`act()` is required to correctly mock asynchronous operations within the hook.",
            "`act()` helps to optimize the test performance by batching state updates.",
            "`act()` ensures that all updates related to the hook's state (including effects) are flushed and applied to the DOM before any assertions are made, making tests more predictable and avoiding warnings.",
            "`act()` is only necessary when testing hooks that interact with the actual DOM."
          ],
          "analysisPoints": [
            "Tests understanding of the purpose of `act()` in hook testing.",
            "Differentiates `act()`'s role from other testing concerns.",
            "Highlights predictability and warning prevention as key benefits."
          ],
          "keyConcepts": [
            "Custom Hooks Testing",
            "`act()`",
            "State Updates",
            "Asynchronous Testing"
          ],
          "evaluationCriteria": [
            "Accurate explanation of `act()`'s role.",
            "Understanding of its impact on test reliability.",
            "Avoids common misconceptions about its purpose."
          ],
          "example": "The `act()` function plays a crucial role in ensuring that your tests behave closer to how React works in a browser. React's updates (state changes, effects) are often batched and don't happen immediately. `act()` flushes these pending updates, making sure that the state of your hook (and the underlying test component's DOM) is stable and fully updated before you make any assertions. Without `act()`, your assertions might run against an outdated state, leading to flaky tests or 'act' warnings in the console.",
          "tags": [
            "React Hooks",
            "Testing",
            "Act",
            "MCQ"
          ],
          "prerequisites": [
            "React Hooks Basics",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_testing_2",
          "topic": "Testing Custom Hooks",
          "level": "hard",
          "type": "open",
          "question": "You are tasked with testing a custom hook, `useDebounce(value, delay)`, which delays updating a value until a certain `delay` has passed since the last change. Describe how you would approach testing this hook using `@testing-library/react-hooks`, specifically focusing on how to manage time (debouncing) in your tests. Include considerations for both initial value, updates, and cleanup.",
          "answer": "Testing a `useDebounce` hook, which inherently deals with time, requires careful management of Jest's timer mocks to ensure predictable and fast tests.\n\n**Hook Definition (for context):**\n```typescript\nimport { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n```\n\n**Testing Approach with Jest Timer Mocks:**\n\n1.  **Enable Jest Fake Timers:** At the beginning of your test file or `describe` block, enable Jest's fake timers. This replaces `setTimeout`, `setInterval`, etc., with Jest's controlled versions.\n    ```typescript\n    jest.useFakeTimers();\n    ```\n2.  **Render the Hook:** Use `renderHook` from `@testing-library/react-hooks` to run your `useDebounce` hook. You'll primarily interact with `result.current` and `rerender`.\n    ```typescript\n    const { result, rerender, unmount } = renderHook(\n      ({ value, delay }) => useDebounce(value, delay),\n      { initialProps: { value: 'initial', delay: 500 } }\n    );\n    ```\n3.  **Advance Timers:** Instead of waiting for real time, use `jest.advanceTimersByTime(ms)` to simulate the passage of time.\n\n**Specific Test Scenarios:**\n\n*   **Initial Value:**\n    Verify that the `debouncedValue` initially reflects the `value` passed on the first render, before any delay has passed.\n    ```typescript\n    it('should return the initial value immediately', () => {\n      const { result } = renderHook(() => useDebounce('initial', 500));\n      expect(result.current).toBe('initial');\n    });\n    ```\n\n*   **Debounce Behavior (Update after delay):**\n    Simulate a value change and then advance timers past the `delay` to ensure the debounced value updates correctly.\n    ```typescript\n    it('should debounce value changes', () => {\n      const { result, rerender } = renderHook(\n        ({ value, delay }) => useDebounce(value, delay),\n        { initialProps: { value: 'initial', delay: 500 } }\n      );\n\n      // Change value without advancing timers yet\n      rerender({ value: 'new value', delay: 500 });\n      expect(result.current).toBe('initial'); // Still old value\n\n      // Advance timers just enough for the debounce to trigger\n      act(() => {\n        jest.advanceTimersByTime(500);\n      });\n      expect(result.current).toBe('new value'); // New value should now be reflected\n    });\n    ```\n\n*   **Multiple Rapid Updates (Debouncing in action):**\n    Simulate multiple value changes within the `delay` period and ensure only the *last* value is debounced and applied.\n    ```typescript\n    it('should only update after the last change within delay', () => {\n      const { result, rerender } = renderHook(\n        ({ value, delay }) => useDebounce(value, delay),\n        { initialProps: { value: 'first', delay: 1000 } }\n      );\n\n      rerender({ value: 'second', delay: 1000 });\n      act(() => { jest.advanceTimersByTime(500); }); // Advance half the delay\n      expect(result.current).toBe('first');\n\n      rerender({ value: 'third', delay: 1000 });\n      act(() => { jest.advanceTimersByTime(500); }); // Advance another half (total 1000, but from last rerender, timeout reset)\n      expect(result.current).toBe('first'); // Still 'first' because new timeout started\n\n      act(() => { jest.advanceTimersByTime(500); }); // Advance again, passing 1000 from 'third'\n      expect(result.current).toBe('third'); // Finally, 'third' is debounced\n    });\n    ```\n\n*   **Cleanup:**\n    Ensure that the `clearTimeout` function is called when the component (or hook) unmounts. This prevents memory leaks.\n    ```typescript\n    it('should clear the timeout on unmount', () => {\n      const clearTimeoutSpy = jest.spyOn(global, 'clearTimeout');\n      const { unmount } = renderHook(() => useDebounce('test', 500));\n      \n      unmount();\n      expect(clearTimeoutSpy).toHaveBeenCalledTimes(1); // Or whatever count expected due to initial render\n      clearTimeoutSpy.mockRestore(); // Clean up the spy\n    });\n    ```\n\n**Cleanup:**\n*   After each test, it's good practice to clear all timers and restore them (`jest.clearAllTimers()` and `jest.runOnlyPendingTimers()` or `jest.runAllTimers()`) and then disable fake timers (`jest.useRealTimers()`) if other tests in the suite need real timers.\n\nThis comprehensive approach ensures that the `useDebounce` hook's behavior is thoroughly tested across different scenarios, including its time-dependent logic and proper cleanup, all without introducing actual delays into the test suite.",
          "analysisPoints": [
            "Demonstrates advanced hook testing with time manipulation.",
            "Correctly uses `jest.useFakeTimers()`, `jest.advanceTimersByTime()`, and `act()`.",
            "Covers initial state, update logic, and cleanup (useEffect return).",
            "Provides practical code examples for each scenario.",
            "Highlights the importance of `rerender` for prop changes."
          ],
          "keyConcepts": [
            "Custom Hooks Testing",
            "`useDebounce`",
            "Jest Fake Timers",
            "`jest.advanceTimersByTime`",
            "`act()`",
            "`rerender`",
            "useEffect Cleanup"
          ],
          "evaluationCriteria": [
            "Thorough understanding of testing time-sensitive hooks.",
            "Correct application of Jest's timer mocks.",
            "Ability to test various states and interactions of the hook.",
            "Consideration for cleanup and test isolation.",
            "Well-structured and explained code examples."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "Testing",
            "Asynchronous",
            "Jest",
            "Code Challenge",
            "Advanced"
          ],
          "prerequisites": [
            "React Hooks",
            "Jest Basics",
            "Mock Functions"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_custom_hooks_testing_3",
          "topic": "Testing Custom Hooks",
          "level": "easy",
          "type": "flashcard",
          "question": "What property of the `result` object returned by `renderHook` allows you to access the current value(s) returned by your custom hook?",
          "answer": "`result.current`",
          "analysisPoints": [
            "Tests knowledge of `renderHook`'s return value structure.",
            "Verifies basic interaction with tested hooks."
          ],
          "keyConcepts": [
            "`renderHook`",
            "Custom Hooks Testing",
            "`result.current`"
          ],
          "evaluationCriteria": [
            "Correct identification of the property.",
            "Understanding of how to access hook values in tests."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "Testing",
            "Flashcard"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_custom_hooks_testing_4",
          "topic": "Testing Custom Hooks",
          "level": "medium",
          "type": "code",
          "question": "Implement and test a custom hook `useToggle(initialValue)` that manages a boolean state. It should return the current boolean value and a `toggle` function to flip the value, and optionally an `on` and `off` function to explicitly set the value to `true` or `false` respectively.",
          "answer": "```typescript\nimport { useState, useCallback } from 'react';\nimport { renderHook, act } from '@testing-library/react-hooks';\n\n// useToggle.js (for context)\nconst useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() => {\n    setValue((prev) => !prev);\n  }, []);\n\n  const on = useCallback(() => {\n    setValue(true);\n  }, []);\n\n  const off = useCallback(() => {\n    setValue(false);\n  }, []);\n\n  return { value, toggle, on, off };\n};\n\ndescribe('useToggle', () => {\n  it('should toggle the value', () => {\n    const { result } = renderHook(() => useToggle(false));\n    expect(result.current.value).toBe(false);\n\n    act(() => {\n      result.current.toggle();\n    });\n    expect(result.current.value).toBe(true);\n\n    act(() => {\n      result.current.toggle();\n    });\n    expect(result.current.value).toBe(false);\n  });\n\n  it('should set the value to true using `on`', () => {\n    const { result } = renderHook(() => useToggle(false));\n    expect(result.current.value).toBe(false);\n\n    act(() => {\n      result.current.on();\n    });\n    expect(result.current.value).toBe(true);\n\n    // Calling 'on' when already true should keep it true\n    act(() => {\n      result.current.on();\n    });\n    expect(result.current.value).toBe(true);\n  });\n\n  it('should set the value to false using `off`', () => {\n    const { result } = renderHook(() => useToggle(true));\n    expect(result.current.value).toBe(true);\n\n    act(() => {\n      result.current.off();\n    });\n    expect(result.current.value).toBe(false);\n\n    // Calling 'off' when already false should keep it false\n    act(() => {\n      result.current.off();\n    });\n    expect(result.current.value).toBe(false);\n  });\n\n  it('should handle different initial values', () => {\n    const { result: trueResult } = renderHook(() => useToggle(true));\n    expect(trueResult.current.value).toBe(true);\n\n    const { result: falseResult } = renderHook(() => useToggle(false));\n    expect(falseResult.current.value).toBe(false);\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to implement a custom hook with multiple functions.",
            "Checks proper usage of `renderHook` and `act`.",
            "Verifies `useState` and `useCallback` usage within the hook.",
            "Demonstrates testing different methods returned by a hook.",
            "Covers various initial states and explicit state setting."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Testing Hooks",
            "`renderHook`",
            "`act()`",
            "`useState`",
            "`useCallback`",
            "Code Challenge"
          ],
          "evaluationCriteria": [
            "Correct implementation of `useToggle` with all specified functions.",
            "Thorough test coverage for `toggle`, `on`, `off`, and initial values.",
            "Appropriate use of `act()` for state updates.",
            "Clear and effective assertions.",
            "Follows best practices for hook testing."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "Testing",
            "Code Challenge",
            "Unit Testing"
          ],
          "prerequisites": [
            "React Hooks",
            "Jest Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_jest_react_basics_1",
          "title": "Implement a Simple Greeting Component and Test its Display",
          "description": "\nCreate a React component named `Greeting` that accepts a `name` prop (string, default to 'Guest') and displays a personalized greeting. Then, write unit tests for this component using Jest and React Testing Library to ensure:\n\n1.  It renders 'Hello, Guest!' when no `name` prop is provided.\n2.  It renders 'Hello, [name]!' when a `name` prop is provided.\n3.  The greeting text is contained within an `<h1>` heading.\n\nYour solution should use `render`, `screen.getByRole`, and `toHaveTextContent`.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\n// TODO: Implement the Greeting component here\nconst Greeting = ({ name = 'Guest' }) => {\n  return (\n    <h1>Hello, {name}!</h1>\n  );\n};\n\n// TODO: Write your tests below this line\ndescribe('Greeting component', () => {\n  // Test case 1\n  // Test case 2\n  // Test case 3\n});\n",
          "solutionCode": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\n\nconst Greeting = ({ name = 'Guest' }) => {\n  return (\n    <h1>Hello, {name}!</h1>\n  );\n};\n\ndescribe('Greeting component', () => {\n  it('renders \"Hello, Guest!\" when no name prop is provided', () => {\n    render(<Greeting />);\n    expect(screen.getByRole('heading')).toHaveTextContent('Hello, Guest!');\n  });\n\n  it('renders \"Hello, John!\" when name prop is \"John\"', () => {\n    render(<Greeting name=\"John\" />);\n    expect(screen.getByRole('heading')).toHaveTextContent('Hello, John!');\n  });\n\n  it('renders the greeting text within an h1 element', () => {\n    render(<Greeting name=\"Tester\" />);\n    const headingElement = screen.getByText('Hello, Tester!');\n    expect(headingElement.tagName).toBe('H1'); // Verify it's an H1 tag\n    expect(headingElement.localName).toBe('h1'); // Alternative for lowercase check\n    expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument(); // Best practice to check role and level\n  });\n});\n",
          "testCases": [
            "Greeting component renders 'Hello, Guest!' by default.",
            "Greeting component renders 'Hello, Alice!' when name prop is 'Alice'.",
            "The rendered greeting is inside an `<h1>` tag."
          ],
          "hints": [
            "Remember to import `render` and `screen` from `@testing-library/react`.",
            "`screen.getByRole('heading', { level: 1 })` is a robust way to find an `<h1>`.",
            "Use `toHaveTextContent` to assert the text displayed."
          ],
          "tags": [
            "React",
            "Jest",
            "React Testing Library",
            "Unit Testing",
            "Basic Component"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Basics",
            "Jest Fundamentals"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Component Props",
            "Conditional Rendering"
          ]
        },
        {
          "id": "task_jest_react_basics_2",
          "title": "Test a Navigation Bar with Conditional Links",
          "description": "\nImplement a `NavBar` React component that displays a list of navigation links. It should have:\n\n1.  A default set of links always visible (`Home`, `About`).\n2.  An optional `adminLinks` prop (an array of link objects `{ text: string, path: string }`) that, if provided, renders additional links under an 'Admin' heading.\n\nWrite Jest and React Testing Library tests to verify:\n\n*   The default 'Home' and 'About' links are always present.\n*   If `adminLinks` are provided, the 'Admin' heading and the specific admin links appear.\n*   If `adminLinks` are NOT provided, the 'Admin' heading and admin links are NOT present.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { render, screen, queryByText } from '@testing-library/react';\n\n// TODO: Implement the NavBar component here\nconst NavBar = ({ adminLinks }) => {\n  const defaultLinks = [\n    { text: 'Home', path: '/' },\n    { text: 'About', path: '/about' },\n  ];\n\n  return (\n    <nav>\n      <ul>\n        {defaultLinks.map(link => (\n          <li key={link.path}><a href={link.path}>{link.text}</a></li>\n        ))}\n      </ul>\n      {/* TODO: Implement conditional rendering for admin links */}\n    </nav>\n  );\n};\n\ndescribe('NavBar component', () => {\n  // TODO: Write your tests here\n});\n",
          "solutionCode": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\n\nconst NavBar = ({ adminLinks }) => {\n  const defaultLinks = [\n    { text: 'Home', path: '/' },\n    { text: 'About', path: '/about' },\n  ];\n\n  return (\n    <nav aria-label=\"Main Navigation\">\n      <ul>\n        {defaultLinks.map(link => (\n          <li key={link.path}><a href={link.path}>{link.text}</a></li>\n        ))}\n      </ul>\n      {adminLinks && adminLinks.length > 0 && (\n        <div>\n          <h3>Admin</h3>\n          <ul>\n            {adminLinks.map(link => (\n              <li key={link.path}><a href={link.path}>{link.text}</a></li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </nav>\n  );\n};\n\ndescribe('NavBar component', () => {\n  it('renders default links correctly', () => {\n    render(<NavBar />);\n    expect(screen.getByRole('link', { name: 'Home' })).toBeInTheDocument();\n    expect(screen.getByRole('link', { name: 'About' })).toBeInTheDocument();\n  });\n\n  it('renders admin links and heading when provided', () => {\n    const adminLinks = [\n      { text: 'Dashboard', path: '/admin/dashboard' },\n      { text: 'Users', path: '/admin/users' },\n    ];\n    render(<NavBar adminLinks={adminLinks} />);\n    \n    expect(screen.getByRole('heading', { name: 'Admin' })).toBeInTheDocument();\n    expect(screen.getByRole('link', { name: 'Dashboard' })).toBeInTheDocument();\n    expect(screen.getByRole('link', { name: 'Users' })).toBeInTheDocument();\n  });\n\n  it('does not render admin links or heading when not provided', () => {\n    render(<NavBar />);\n    expect(screen.queryByRole('heading', { name: 'Admin' })).not.toBeInTheDocument();\n    // Using queryByRole/queryByText is important for asserting absence\n    expect(screen.queryByRole('link', { name: 'Dashboard' })).not.toBeInTheDocument();\n  });\n\n  it('does not render admin links or heading when provided with empty array', () => {\n    render(<NavBar adminLinks={[]} />);\n    expect(screen.queryByRole('heading', { name: 'Admin' })).not.toBeInTheDocument();\n  });\n});\n",
          "testCases": [
            "NavBar renders default 'Home' and 'About' links.",
            "NavBar renders 'Admin' heading and specific admin links when `adminLinks` prop is present.",
            "NavBar does NOT render 'Admin' heading or admin links when `adminLinks` prop is null or undefined.",
            "NavBar does NOT render 'Admin' heading or admin links when `adminLinks` prop is an empty array."
          ],
          "hints": [
            "Use `screen.queryByRole` or `screen.queryByText` when asserting that an element is *not* present in the DOM. These queries return `null` instead of throwing an error if the element is not found.",
            "Remember that `getByRole` with `name` option is great for finding links.",
            "Consider edge cases like an empty `adminLinks` array."
          ],
          "tags": [
            "React",
            "Jest",
            "React Testing Library",
            "Conditional Rendering",
            "Props",
            "Integration Testing"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Props",
            "Conditional Rendering",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Structure",
            "Accessibility"
          ]
        },
        {
          "id": "task_mock_functions_1",
          "title": "Test an API-Dependent User Form with Mocked API Calls",
          "description": "\nCreate a React component `UserRegistrationForm` that takes `onSuccess` and `onError` callbacks as props. The form should have input fields for `username` and `email`, and a submit button. When submitted, it should make an asynchronous `POST` request to `/api/register` with the form data. Upon successful registration, it should call `onSuccess` with the response data; on failure, it should call `onError` with the error.\n\nYour task is to:\n1.  Implement the `UserRegistrationForm` component.\n2.  Write Jest and React Testing Library tests that:\n    *   Mock the `fetch` API (or `axios` if you prefer).\n    *   Verify `onSuccess` is called with the correct data on successful registration.\n    *   Verify `onError` is called with an error on failed registration (e.g., a 400 or 500 status).\n    *   Ensure the form input fields are cleared after a successful submission.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\n\n// Mock the fetch API globally before component import\n// For axios, you would typically use jest.mock('axios');\n// jest.mock('axios', () => ({\n//   post: jest.fn(),\n// }));\n\n// TODO: Implement the UserRegistrationForm component\nconst UserRegistrationForm = ({ onSuccess, onError }) => {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      // Replace with actual fetch or axios call\n      const response = await fetch('/api/register', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ username, email }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      onSuccess(data);\n      setUsername('');\n      setEmail('');\n    } catch (error) {\n      onError(error);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input id=\"username\" type=\"text\" value={username} onChange={(e) => setUsername(e.target.value)} />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input id=\"email\" type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} />\n      </div>\n      <button type=\"submit\">Register</button>\n    </form>\n  );\n};\n\ndescribe('UserRegistrationForm', () => {\n  let mockOnSuccess;\n  let mockOnError;\n\n  beforeEach(() => {\n    mockOnSuccess = jest.fn();\n    mockOnError = jest.fn();\n    // Reset mocks for fetch/axios for each test\n    // For fetch:\n    global.fetch = jest.fn();\n    // For axios:\n    // axios.post.mockClear();\n  });\n\n  // TODO: Write your tests for successful and failed registration\n});\n",
          "solutionCode": "import React, { useState } from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\n\n// NOTE: For 'fetch' API, mock it globally. For 'axios', use jest.mock('axios').\n// The solution uses 'fetch' as per the starting code's suggestion.\n\nconst UserRegistrationForm = ({ onSuccess, onError }) => {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const response = await fetch('/api/register', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ username, email }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      onSuccess(data);\n      setUsername('');\n      setEmail('');\n    } catch (error) {\n      onError(error);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input id=\"username\" type=\"text\" value={username} onChange={(e) => setUsername(e.target.value)} />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input id=\"email\" type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} />\n      </div>\n      <button type=\"submit\">Register</button>\n    </form>\n  );\n};\n\ndescribe('UserRegistrationForm', () => {\n  let mockOnSuccess;\n  let mockOnError;\n\n  beforeEach(() => {\n    mockOnSuccess = jest.fn();\n    mockOnError = jest.fn();\n    // Clear all mocks before each test to ensure isolation\n    global.fetch = jest.fn();\n  });\n\n  it('calls onSuccess with data and clears form on successful registration', async () => {\n    // Mock a successful fetch response\n    global.fetch.mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve({ id: 1, username: 'testuser', email: 'test@example.com' }),\n    });\n\n    render(\n      <UserRegistrationForm onSuccess={mockOnSuccess} onError={mockOnError} />\n    );\n\n    // Get input elements by label text\n    const usernameInput = screen.getByLabelText(/username:/i);\n    const emailInput = screen.getByLabelText(/email:/i);\n    const submitButton = screen.getByRole('button', { name: /register/i });\n\n    // Simulate user input\n    fireEvent.change(usernameInput, { target: { value: 'testuser' } });\n    fireEvent.change(emailInput, { target: { value: 'test@example.com' } });\n\n    // Simulate form submission\n    fireEvent.click(submitButton);\n\n    // Wait for the asynchronous operations to complete and state to update\n    await waitFor(() => {\n      expect(mockOnSuccess).toHaveBeenCalledTimes(1);\n      expect(mockOnSuccess).toHaveBeenCalledWith({ id: 1, username: 'testuser', email: 'test@example.com' });\n      expect(mockOnError).not.toHaveBeenCalled();\n    });\n    \n    // Verify form fields are cleared after success\n    expect(usernameInput).toHaveValue('');\n    expect(emailInput).toHaveValue('');\n\n    // Verify fetch was called with correct arguments\n    expect(global.fetch).toHaveBeenCalledTimes(1);\n    expect(global.fetch).toHaveBeenCalledWith(\n      '/api/register',\n      expect.objectContaining({\n        method: 'POST',\n        body: JSON.stringify({ username: 'testuser', email: 'test@example.com' }),\n      })\n    );\n  });\n\n  it('calls onError and does not clear form on failed registration', async () => {\n    // Mock a failed fetch response (e.g., 400 Bad Request)\n    global.fetch.mockResolvedValueOnce({\n      ok: false,\n      status: 400,\n      json: () => Promise.resolve({ message: 'Validation failed' }),\n    });\n\n    render(\n      <UserRegistrationForm onSuccess={mockOnSuccess} onError={mockOnError} />\n    );\n\n    const usernameInput = screen.getByLabelText(/username:/i);\n    const emailInput = screen.getByLabelText(/email:/i);\n    const submitButton = screen.getByRole('button', { name: /register/i });\n\n    fireEvent.change(usernameInput, { target: { value: 'invaliduser' } });\n    fireEvent.change(emailInput, { target: { value: 'invalid@example.com' } });\n\n    fireEvent.click(submitButton);\n\n    await waitFor(() => {\n      expect(mockOnError).toHaveBeenCalledTimes(1);\n      expect(mockOnError).toHaveBeenCalledWith(expect.any(Error)); // Checks it's an Error object\n      expect(mockOnSuccess).not.toHaveBeenCalled();\n    });\n    \n    // Verify form fields are NOT cleared after failure\n    expect(usernameInput).toHaveValue('invaliduser');\n    expect(emailInput).toHaveValue('invalid@example.com');\n\n    expect(global.fetch).toHaveBeenCalledTimes(1);\n  });\n});\n",
          "testCases": [
            "Successful registration: `onSuccess` is called with returned data, input fields are cleared.",
            "Failed registration: `onError` is called with an error, input fields are NOT cleared.",
            "Verify `fetch` (or `axios.post`) was called with correct URL and payload.",
            "Ensure no `onSuccess` call on error, and no `onError` call on success."
          ],
          "hints": [
            "Use `global.fetch = jest.fn()` to mock `fetch`. You can chain `.mockResolvedValueOnce()` to control its response.",
            "`fireEvent.change` for input fields and `fireEvent.submit` for forms.",
            "Remember to use `await waitFor(() => { /* assertions */ })` for asynchronous updates, especially after API calls.",
            "Use `jest.fn()` for `onSuccess` and `onError` props and `toHaveBeenCalledWith` to check arguments."
          ],
          "tags": [
            "React",
            "Jest",
            "Mocking",
            "API",
            "Forms",
            "Asynchronous",
            "Integration Testing",
            "Code Challenge"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React State & Forms",
            "Asynchronous JavaScript (Promises, async/await)",
            "Jest Mocking"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Error Handling",
            "User Interaction",
            "Form Validation"
          ]
        },
        {
          "id": "task_snapshot_testing_1",
          "title": "Create and Test a Multi-Variant Alert Component with Snapshots",
          "description": "\nImplement a React component named `Alert` that displays a message. The component should accept `message` (string) and `type` (string: 'info', 'success', 'warning', 'error') props. The `type` prop should affect the CSS class applied to the alert (e.g., `alert-info`, `alert-success`).\n\nYour task is to:\n1.  Create the `Alert` component with basic styling based on `type`.\n2.  Write Jest snapshot tests to ensure that the `Alert` component renders correctly for each of the `type` variants ('info', 'success', 'warning', 'error') and for a default (no type) case.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport renderer from 'react-test-renderer';\n\n// TODO: Implement the Alert component here\nconst Alert = ({ message, type = 'info' }) => {\n  // Consider a className based on type: `alert-${type}`\n  return (\n    <div className={`alert alert-${type}`}>\n      {message}\n    </div>\n  );\n};\n\ndescribe('Alert component snapshot tests', () => {\n  // TODO: Write snapshot tests for different alert types\n});\n",
          "solutionCode": "import React from 'react';\nimport renderer from 'react-test-renderer';\n\nconst Alert = ({ message, type = 'info' }) => {\n  return (\n    <div className={`alert alert-${type}`}>\n      {message}\n    </div>\n  );\n};\n\ndescribe('Alert component snapshot tests', () => {\n  it('renders correctly for info type', () => {\n    const component = renderer.create(\n      <Alert message=\"This is an informational message.\" type=\"info\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n\n  it('renders correctly for success type', () => {\n    const component = renderer.create(\n      <Alert message=\"Operation completed successfully!\" type=\"success\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n\n  it('renders correctly for warning type', () => {\n    const component = renderer.create(\n      <Alert message=\"Warning: Something might be wrong.\" type=\"warning\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n\n  it('renders correctly for error type', () => {\n    const component = renderer.create(\n      <Alert message=\"Error: An unexpected error occurred.\" type=\"error\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n\n  it('renders correctly with default type when no type is provided', () => {\n    const component = renderer.create(\n      <Alert message=\"Default alert message.\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n});\n",
          "testCases": [
            "Snapshot for 'info' type.",
            "Snapshot for 'success' type.",
            "Snapshot for 'warning' type.",
            "Snapshot for 'error' type.",
            "Snapshot for default type (no `type` prop provided)."
          ],
          "hints": [
            "Import `renderer` from `react-test-renderer`.",
            "Use `component.toJSON()` to get the render tree.",
            "Remember that each `it` block should ideally test one specific scenario or prop combination.",
            "Run `jest -u` on the first run to generate the snapshot files."
          ],
          "tags": [
            "React",
            "Jest",
            "Snapshot Testing",
            "Component Props",
            "UI Testing"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Basics",
            "Jest Fundamentals",
            "CSS Classes"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Conditional Styling"
          ]
        },
        {
          "id": "task_context_redux_testing_1",
          "title": "Test a User Profile Component Connected to a Redux Store",
          "description": "\nCreate a `UserProfile` React component that displays a user's `firstName` and `lastName` retrieved from a Redux store. It should also have a button labeled 'Reset Name' that, when clicked, dispatches a `RESET_NAME` action.\n\nYour task is to:\n1.  Implement the `UserProfile` component (you can use `useSelector` and `useDispatch` from `react-redux`).\n2.  Write Jest and React Testing Library tests that:\n    *   Provide a mock Redux store with an initial user state using `redux-mock-store`.\n    *   Verify that the component correctly displays the user's `firstName` and `lastName` from the store.\n    *   Simulate a click on the 'Reset Name' button.\n    *   Assert that the `RESET_NAME` action was dispatched exactly once.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\n\n// Action type for reset\nconst RESET_NAME = 'RESET_NAME';\n\n// TODO: Implement the UserProfile component\nconst UserProfile = () => {\n  const user = useSelector(state => state.user);\n  const dispatch = useDispatch();\n\n  const handleResetName = () => {\n    dispatch({ type: RESET_NAME });\n  };\n\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>First Name: {user.firstName}</p>\n      <p>Last Name: {user.lastName}</p>\n      <button onClick={handleResetName}>Reset Name</button>\n    </div>\n  );\n};\n\nconst mockStore = configureStore([]);\n\ndescribe('UserProfile component', () => {\n  // TODO: Write your tests here\n});\n",
          "solutionCode": "import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\n\nconst RESET_NAME = 'RESET_NAME';\n\nconst UserProfile = () => {\n  const user = useSelector(state => state.user);\n  const dispatch = useDispatch();\n\n  const handleResetName = () => {\n    dispatch({ type: RESET_NAME });\n  };\n\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>First Name: {user.firstName}</p>\n      <p>Last Name: {user.lastName}</p>\n      <button onClick={handleResetName}>Reset Name</button>\n    </div>\n  );\n};\n\nconst mockStore = configureStore([]);\n\ndescribe('UserProfile component', () => {\n  it('renders user information from the Redux store', () => {\n    const initialState = {\n      user: { firstName: 'John', lastName: 'Doe' }\n    };\n    const store = mockStore(initialState);\n\n    render(\n      <Provider store={store}>\n        <UserProfile />\n      </Provider>\n    );\n\n    expect(screen.getByText(/First Name: John/i)).toBeInTheDocument();\n    expect(screen.getByText(/Last Name: Doe/i)).toBeInTheDocument();\n  });\n\n  it('dispatches RESET_NAME action when Reset Name button is clicked', () => {\n    const initialState = {\n      user: { firstName: 'Jane', lastName: 'Smith' }\n    };\n    const store = mockStore(initialState);\n\n    render(\n      <Provider store={store}>\n        <UserProfile />\n      </Provider>\n    );\n\n    const resetButton = screen.getByRole('button', { name: /Reset Name/i });\n    fireEvent.click(resetButton);\n\n    // Get all actions that were dispatched to the mock store\n    const actions = store.getActions();\n\n    // Assert that the RESET_NAME action was dispatched\n    expect(actions).toEqual([{ type: RESET_NAME }]);\n    expect(actions).toHaveLength(1); // Ensure only one action was dispatched\n  });\n\n  it('renders correctly when user data is missing (edge case)', () => {\n    const initialState = { user: {} }; // Missing firstName, lastName\n    const store = mockStore(initialState);\n\n    render(\n      <Provider store={store}>\n        <UserProfile />\n      </Provider>\n    );\n\n    // Assuming component handles missing data gracefully, perhaps showing empty strings or a placeholder\n    expect(screen.getByText(/First Name:/i)).toBeInTheDocument();\n    expect(screen.getByText(/Last Name:/i)).toBeInTheDocument();\n  });\n});\n",
          "testCases": [
            "Component displays correct `firstName` and `lastName` from initial store state.",
            "Clicking 'Reset Name' button dispatches `RESET_NAME` action.",
            "Ensure no other actions are dispatched.",
            "Component handles missing user data in store gracefully."
          ],
          "hints": [
            "Remember to wrap `UserProfile` with `<Provider store={store}>`.",
            "Use `mockStore(initialState)` to define the starting Redux state for your test.",
            "`store.getActions()` will return an array of all actions dispatched to the mock store. You can then assert against this array.",
            "Use `fireEvent.click` to simulate button clicks."
          ],
          "tags": [
            "React",
            "Redux",
            "Jest",
            "React Testing Library",
            "Integration Testing",
            "Redux Testing"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Redux Fundamentals",
            "React Redux (useSelector, useDispatch)",
            "Jest Mocking"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "State Management",
            "Actions",
            "Dispatchers"
          ]
        },
        {
          "id": "task_custom_hooks_testing_1",
          "title": "Implement and Test a `useLocalStorage` Custom Hook",
          "description": "\nImplement a custom React hook `useLocalStorage(key, initialValue)` that allows you to store and retrieve a value from `localStorage`. The hook should:\n\n1.  Initialize its state with `initialValue` if nothing is found in `localStorage` for the given `key`.\n2.  Initialize its state with the value from `localStorage` if present.\n3.  Update the value in `localStorage` whenever the hook's state changes.\n4.  Return the current value and a setter function (similar to `useState`).\n\nWrite Jest tests using `@testing-library/react-hooks` to verify:\n\n*   The hook correctly initializes from `localStorage`.\n*   The hook correctly initializes with `initialValue` if `localStorage` is empty.\n*   Updating the hook's value also updates `localStorage`.\n*   The hook's value is reactive (changes when `localStorage` changes, though this requires more advanced mocking for `storage` events, focus on the setter for this task).\n\n**Note:** You will need to mock `localStorage` for your tests.\n",
          "difficulty": "hard",
          "startingCode": "import { useState, useEffect, useCallback } from 'react';\nimport { renderHook, act } from '@testing-library/react-hooks';\n\n// Mock localStorage for testing\nconst localStorageMock = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn(),\n};\nObject.defineProperty(window, 'localStorage', {\n  value: localStorageMock,\n});\n\n// TODO: Implement the useLocalStorage hook\nconst useLocalStorage = (key, initialValue) => {\n  const [value, setValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.warn(`Error reading localStorage key “${key}”:`, error);\n      return initialValue;\n    }\n  });\n\n  const setStoredValue = useCallback(newValue => {\n    try {\n      setValue(newValue);\n      window.localStorage.setItem(key, JSON.stringify(newValue));\n    } catch (error) {\n      console.warn(`Error setting localStorage key “${key}”:`, error);\n    }\n  }, [key]);\n\n  return [value, setStoredValue];\n};\n\ndescribe('useLocalStorage', () => {\n  beforeEach(() => {\n    // Clear and reset all mocks before each test\n    localStorageMock.getItem.mockClear();\n    localStorageMock.setItem.mockClear();\n    localStorageMock.removeItem.mockClear();\n    localStorageMock.clear.mockClear();\n  });\n\n  // TODO: Write your tests here\n});\n",
          "solutionCode": "import { useState, useEffect, useCallback } from 'react';\nimport { renderHook, act } from '@testing-library/react-hooks';\n\n// Mock localStorage for testing\nconst localStorageMock = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn(),\n};\nObject.defineProperty(window, 'localStorage', {\n  value: localStorageMock,\n});\n\nconst useLocalStorage = (key, initialValue) => {\n  const [value, setValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.warn(`Error reading localStorage key “${key}”:`, error);\n      return initialValue;\n    }\n  });\n\n  const setStoredValue = useCallback(newValue => {\n    try {\n      // Allow newValue to be a function, just like useState's setter\n      const valueToStore = newValue instanceof Function ? newValue(value) : newValue;\n      setValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.warn(`Error setting localStorage key “${key}”:`, error);\n    }\n  }, [key, value]); // Add `value` to dependency array for function updates\n\n  // Optionally, you might add a useEffect to listen for storage events\n  // For this task, we focus on the setter for updates\n\n  return [value, setStoredValue];\n};\n\ndescribe('useLocalStorage', () => {\n  beforeEach(() => {\n    localStorageMock.getItem.mockClear();\n    localStorageMock.setItem.mockClear();\n    localStorageMock.removeItem.mockClear();\n    localStorageMock.clear.mockClear();\n  });\n\n  it('should initialize with initialValue if localStorage is empty', () => {\n    localStorageMock.getItem.mockReturnValue(null);\n    const { result } = renderHook(() => useLocalStorage('myKey', 'default'));\n    expect(result.current[0]).toBe('default');\n    expect(localStorageMock.getItem).toHaveBeenCalledWith('myKey');\n  });\n\n  it('should initialize with value from localStorage if present', () => {\n    localStorageMock.getItem.mockReturnValue(JSON.stringify('storedValue'));\n    const { result } = renderHook(() => useLocalStorage('myKey', 'default'));\n    expect(result.current[0]).toBe('storedValue');\n    expect(localStorageMock.getItem).toHaveBeenCalledWith('myKey');\n  });\n\n  it('should update localStorage when the value changes', () => {\n    localStorageMock.getItem.mockReturnValue(null); // Ensure initial state doesn't come from storage\n    const { result } = renderHook(() => useLocalStorage('myKey', 'default'));\n    \n    act(() => {\n      result.current[1]('newValue'); // Call the setter function\n    });\n    expect(result.current[0]).toBe('newValue');\n    expect(localStorageMock.setItem).toHaveBeenCalledWith('myKey', JSON.stringify('newValue'));\n    expect(localStorageMock.setItem).toHaveBeenCalledTimes(1); // Only one setItem call from this action\n  });\n\n  it('should handle function updates to the value', () => {\n    localStorageMock.getItem.mockReturnValue(null);\n    const { result } = renderHook(() => useLocalStorage('count', 0));\n    \n    act(() => {\n      result.current[1](prev => prev + 1);\n    });\n    expect(result.current[0]).toBe(1);\n    expect(localStorageMock.setItem).toHaveBeenCalledWith('count', JSON.stringify(1));\n  });\n\n  it('should handle complex objects correctly', () => {\n    const initialUser = { name: 'Bob', age: 30 };\n    localStorageMock.getItem.mockReturnValue(JSON.stringify(initialUser));\n    const { result } = renderHook(() => useLocalStorage('user', null));\n\n    expect(result.current[0]).toEqual(initialUser);\n\n    const updatedUser = { ...initialUser, age: 31 };\n    act(() => {\n      result.current[1](updatedUser);\n    });\n    expect(result.current[0]).toEqual(updatedUser);\n    expect(localStorageMock.setItem).toHaveBeenCalledWith('user', JSON.stringify(updatedUser));\n  });\n});\n",
          "testCases": [
            "Hook initializes with `initialValue` if `localStorage` is empty.",
            "Hook initializes with parsed value from `localStorage` if present.",
            "Calling the setter function updates the hook's value and saves it to `localStorage`.",
            "Calling the setter function with a functional updater (e.g., `prev => prev + 1`) works correctly.",
            "Hook correctly handles storing and retrieving complex JSON objects.",
            "Ensure `localStorage.getItem` and `setItem` are called with the correct key and value."
          ],
          "hints": [
            "Make sure your `useLocalStorage` hook uses `JSON.parse` when reading from `localStorage` and `JSON.stringify` when writing to it.",
            "Use `localStorageMock.getItem.mockReturnValueOnce()` to control what `getItem` returns for specific test scenarios.",
            "Remember to wrap state updates (`result.current[1](...)`) in `act()`.",
            "Use `toHaveBeenCalledWith` to verify the arguments passed to `localStorage.setItem`."
          ],
          "tags": [
            "React",
            "Custom Hooks",
            "LocalStorage",
            "Testing",
            "Jest",
            "Mocking",
            "Advanced"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React Hooks (useState, useEffect, useCallback)",
            "Jest Mocking",
            "Web Storage API"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "State Persistence",
            "Side Effects",
            "Test Doubles"
          ]
        }
      ]
    }
  },
  {
    "id": "b60bd1fa-5e7f-4763-a19e-7da6e5ce6011",
    "startLine": 5400,
    "endLine": 5499,
    "processedDate": "2025-06-17T09:38:12.195Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_hooks_testing",
          "title": "Testing React Custom Hooks with react-hooks-testing-library",
          "content": "Testing custom React Hooks requires a specific approach different from testing regular React components. `react-hooks-testing-library` is a dedicated library that provides utilities to test hooks in isolation, mimicking their lifecycle within a React component environment without needing to render a full component.\n\n## Key Concepts\n\n### `renderHook`\nThis utility is the primary way to test a hook. It renders a test component internally that calls your hook, allowing you to access its return value and interact with it. It simulates the component lifecycle necessary for hooks to function correctly.\n\n### `result.current`\nThe `renderHook` function returns an object that includes a `result` property. `result.current` holds the latest value returned by your hook. This is the primary way to assert the state or functions exposed by your hook after an action or a re-render.\n\n### `act`\n`act` is a utility from `react-test-renderer` (or `react-dom/test-utils`). When testing React components or hooks, any updates that trigger re-renders or state changes (like calling a state setter, or a function returned by a hook that updates its internal state) should be wrapped in `act()`. This ensures that all React updates are flushed and applied to the DOM (or virtual DOM in tests) before you make assertions. Using `act` prevents warnings about unhandled updates and makes your tests behave closer to how React works in a browser, leading to more reliable test results.\n\n## Lifecycle for Testing Hooks\n1.  **Render the hook:** Use `renderHook(() => yourHook(initialProps))`. This effectively mounts an internal test component and calls your hook.\n2.  **Interact:** Use `act(() => result.current.someFunction())` to simulate user interactions or trigger state updates within the hook. For asynchronous updates, `await act(async () => { ... })` might be necessary, often combined with `waitForNextUpdate`.\n3.  **Assert:** Use `expect(result.current.value).toBe(expectedValue)` to check the hook's state or return values after interactions.\n\n### Example Hook: `useCounter`\nA `useCounter` hook typically manages a numerical state, providing functions to increment and decrement it.",
          "examples": [
            {
              "id": "example_use_counter_hook",
              "title": "Basic `useCounter` Hook Implementation",
              "code": "import { useState, useCallback } from 'react';\n\n/**\n * A custom hook to manage a numerical counter state.\n * @param {number} initialValue The initial value of the counter.\n * @returns {{count: number, increment: () => void, decrement: () => void, reset: () => void}}\n */\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n\n  const increment = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []);\n\n  const decrement = useCallback(() => {\n    setCount(prevCount => prevCount - 1);\n  }, []);\n\n  const reset = useCallback(() => {\n    setCount(initialValue);\n  }, [initialValue]);\n\n  return { count, increment, decrement, reset };\n}",
              "explanation": "This code defines a simple `useCounter` custom hook. It uses React's `useState` to manage the `count` state and `useCallback` to memoize the `increment`, `decrement`, and `reset` functions. Memoizing these functions is a good practice for performance when they are passed down to child components, as it prevents their re-creation on every re-render of the component consuming the hook, thus avoiding unnecessary re-renders of the children.",
              "language": "typescript"
            },
            {
              "id": "example_use_counter_testing",
              "title": "Testing `useCounter` with `react-hooks-testing-library`",
              "code": "import { renderHook, act } from '@testing-library/react-hooks';\nimport { useCounter } from './useCounter'; // Assuming useCounter is in useCounter.js\n\ntest('should increment counter', () => {\n  const { result } = renderHook(() => useCounter(0));\n\n  act(() => {\n    result.current.increment();\n  });\n\n  expect(result.current.count).toBe(1);\n});\n\ntest('should decrement counter', () => {\n  const { result } = renderHook(() => useCounter(10));\n\n  act(() => {\n    result.current.decrement();\n  });\n\n  expect(result.current.count).toBe(9);\n});\n\ntest('should reset counter to initial value', () => {\n  const { result } = renderHook(() => useCounter(5));\n  act(() => {\n    result.current.increment();\n    result.current.increment();\n  });\n  expect(result.current.count).toBe(7);\n\n  act(() => {\n    result.current.reset();\n  });\n  expect(result.current.count).toBe(5);\n});",
              "explanation": "These tests demonstrate how to use `renderHook` to mount the `useCounter` hook in a test environment. The `act` wrapper is crucial for any operations that update the hook's state (like `increment` or `decrement`) to ensure React updates are processed and the component's state is stable before assertions are made. `result.current` is then used to access the current value of `count` for direct assertions.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_counter_mcq_act_purpose",
            "question_use_counter_open_renderhook",
            "question_use_counter_flashcard_result_current",
            "question_use_counter_code_usetoggle_test",
            "question_use_counter_difficulty_test"
          ],
          "relatedTasks": [
            "task_implement_use_toggle_hook"
          ],
          "tags": [
            "React Hooks",
            "Testing",
            "react-hooks-testing-library",
            "Unit Testing",
            "JavaScript"
          ],
          "technology": "React, Jest, Testing Library",
          "prerequisites": [
            "react_functional_components",
            "react_hooks_useState_useCallback",
            "jest_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "custom_hook_development",
            "advanced_react_testing"
          ]
        },
        {
          "id": "theory_react_pure_component",
          "title": "React.PureComponent for Performance Optimization",
          "content": "`React.PureComponent` is a base class that extends `React.Component` but includes a shallow prop and state comparison in its `shouldComponentUpdate` lifecycle method. This automatic optimization helps prevent unnecessary re-renders of components, leading to potential performance improvements in React applications.\n\n## How it Works\n\nNormally, when a parent component re-renders, all its child components also re-render by default, regardless of whether their props or state have actually changed. This can be inefficient if a child component is complex or renders frequently but its output doesn't depend on every parent re-render.\n\n`React.PureComponent` addresses this by implementing a default `shouldComponentUpdate` method that performs a shallow comparison of the component's `props` and `state` with their `nextProps` and `nextState`.\n\n```typescript\nshouldComponentUpdate(nextProps, nextState) {\n  return !shallowEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);\n}\n```\n\n`shallowEqual` checks if the properties of two objects (props or state) are strictly equal (`===`) at the first level of depth. If the shallow comparison finds no changes in either props or state, `shouldComponentUpdate` returns `false`, effectively skipping the `render` method and its subsequent reconciliation, thus saving CPU cycles.\n\n## `shallowEqual` Explained\n\n`shallowEqual` is a utility function used internally by `PureComponent` (and also by `React.memo`'s default behavior) that compares two objects at the first level of depth. It returns `true` if:\n*   Both objects are `null` or `undefined`.\n*   Both objects are the same reference.\n*   They have the same number of keys.\n*   Each key in the first object has a corresponding key in the second object.\n*   The values associated with each key are strictly (`===`) equal.\n\n**Limitations of `shallowEqual`:**\n*   **Deeply Nested Objects/Arrays:** `shallowEqual` only checks the references of nested objects or arrays, not their contents. If a prop is an object or an array and its contents change but its reference remains the same, `PureComponent` will *not* re-render, leading to stale UI. For example, if you pass `props.data = { value: 1 }` and later update `props.data.value = 2` without changing the `data` object's reference (i.e., `props.data` still points to the same object in memory), `PureComponent` will not detect the change.\n*   **Functions:** Functions defined inline in the `render` method of a parent component will create a new function instance on every parent re-render. Passing such a function as a prop to a `PureComponent` will cause the `PureComponent` to re-render unnecessarily because `shallowEqual` will detect a new function reference. This can be mitigated by binding methods in the constructor or using arrow functions as class properties for class components, or `useCallback` for functional components.\n\n## When to Use `PureComponent`\n\nUse `PureComponent` when:\n1.  Your component's render output is determined *solely* by its `props` and `state`.\n2.  The `props` and `state` are simple JavaScript primitives (strings, numbers, booleans) or simple objects/arrays that are guaranteed to have new references when their content changes (i.e., you are using immutable data structures or methods that return new objects/arrays).\n3.  You don't need to implement a custom `shouldComponentUpdate()` method with more complex comparison logic.\n\n## When to Avoid `PureComponent`\n\nAvoid `PureComponent` if:\n1.  Your component relies on context, or `children` that are not pure (e.g., if `children` are frequently re-rendered or contain dynamic content not controlled by props/state).\n2.  Your `props` or `state` contain deeply nested data structures that are mutated without creating new references. In such cases, `PureComponent` might miss updates, leading to incorrect UI.\n3.  You need custom comparison logic that goes beyond shallow comparison. In such cases, use `React.Component` and implement `shouldComponentUpdate` manually, or use `React.memo` with a custom comparison function for functional components.\n\nFor functional components, the equivalent of `PureComponent` is `React.memo`. `React.memo` is a higher-order component that works similarly by memoizing component rendering based on prop comparison, and it can also accept a custom comparison function as its second argument for more control.",
          "examples": [
            {
              "id": "example_pure_vs_regular_counter",
              "title": "PureComponent vs. Regular Component Re-renders",
              "code": "import React from 'react';\n\nclass PureCounter extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  \n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  }\n  \n  render() {\n    console.log('PureCounter render called'); // This won't log on parent re-renders unless props/state change\n    return (\n      <div>\n        <h2>Count: {this.state.count}</h2>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// Regular component will re-render on every parent update\nclass RegularCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  \n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  }\n  \n  render() {\n    console.log('RegularCounter render called'); // This will log on every parent re-render\n    return (\n      <div>\n        <h2>Count: {this.state.count}</h2>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\nclass ParentComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { parentValue: 0 };\n  }\n\n  componentDidMount() {\n    this.interval = setInterval(() => {\n      this.setState(prevState => ({ parentValue: prevState.parentValue + 1 }));\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    console.log('ParentComponent render called');\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc' }}>\n        <h1>Parent Value: {this.state.parentValue}</h1>\n        <p>PureCounter below will only re-render if its own state changes.</p>\n        <PureCounter />\n        <hr/>\n        <p>RegularCounter below will re-render every second with the parent.</p>\n        <RegularCounter />\n      </div>\n    );\n  }\n}",
              "explanation": "This example vividly shows the difference in rendering behavior. The `ParentComponent` updates its `parentValue` every second, causing itself to re-render. The `RegularCounter` child, being a `React.Component`, also re-renders every time its parent does, even though its own `props` (it receives none in this simplified example, but imagine it receiving static props) and its `state` (initially) haven't changed. The `PureCounter` child, being a `React.PureComponent`, only re-renders when its *own* state changes (e.g., when you click its Increment button), ignoring parent re-renders when its props and state are shallowly equal.",
              "language": "typescript"
            },
            {
              "id": "example_pure_component_immutable_data",
              "title": "PureComponent with Immutable Data Patterns",
              "code": "import React from 'react';\n\nclass DataDisplay extends React.PureComponent {\n  render() {\n    console.log('DataDisplay PureComponent render called');\n    const { data } = this.props;\n    return (\n      <div>\n        <p>Data ID: {data.id}</p>\n        <p>Data Value: {data.value}</p>\n      </div>\n    );\n  }\n}\n\nclass ParentWithImmutableData extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      tick: 0,\n      item: { id: 1, value: 'initial' }\n    };\n  }\n\n  componentDidMount() {\n    this.interval = setInterval(() => {\n      this.setState(prevState => ({\n        tick: prevState.tick + 1,\n        // Correct way to update nested data for PureComponent:\n        // Always create a new object reference if content changes.\n        item: prevState.tick % 2 === 0 \n              ? { ...prevState.item, value: `updated-${prevState.tick}` } // New object reference\n              : prevState.item // Same object reference if value not changing\n      }));\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    console.log('ParentWithImmutableData render called');\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', marginTop: '20px' }}>\n        <h3>Parent Tick: {this.state.tick}</h3>\n        <DataDisplay data={this.state.item} />\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates how to use `PureComponent` effectively with objects as props by adhering to immutability principles. The `ParentWithImmutableData` component updates its `tick` state every second. It also conditionally updates the `item` object. Crucially, when `item.value` is modified, a *new* `item` object is created using the spread syntax (`{ ...prevState.item, value: ... }`). This ensures that `shallowEqual` in `DataDisplay` (a `PureComponent`) detects a change in the `data` prop's reference only when its content actually changes, thus preventing unnecessary renders of `DataDisplay` when `item` reference is unchanged.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_pure_component_mcq_shallow_comparison",
            "question_pure_component_open_when_not_to_use",
            "question_pure_component_flashcard_benefit",
            "question_pure_component_code_refactor_example",
            "question_pure_component_mcq_deep_comparison"
          ],
          "relatedTasks": [
            "task_pure_component_performance_demo"
          ],
          "tags": [
            "React",
            "Performance Optimization",
            "PureComponent",
            "shouldComponentUpdate",
            "Shallow Comparison",
            "Class Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_lifecycle_methods",
            "javascript_object_comparison"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_performance_tuning",
            "understanding_re_render_mechanism"
          ]
        },
        {
          "id": "theory_styled_components",
          "title": "Styled Components: CSS-in-JS for React",
          "content": "Styled Components is a popular library that allows developers to write actual CSS code within JavaScript, tying styles directly to React components. This approach is known as 'CSS-in-JS' and offers several benefits for managing styles in modern web applications.\n\n## Key Concepts\n\n### Component-Scoped Styling\nStyled Components leverage tagged template literals to create React components that have styles attached to them. Each styled component generates a unique class name (e.g., `sc-bZQynM gTjMgi`), ensuring that styles are automatically scoped to that component and do not conflict with other styles on the page. This eliminates the need for methodologies like BEM or CSS Modules for scope management.\n\n### Dynamic Styling with Props\nOne of the powerful features of Styled Components is the ability to pass props to your styled components. You can then use these props within your CSS to dynamically change styles based on component state or properties. This is achieved by using a function inside the template literal that receives the component's props as an argument.\n\n### Advantages\n*   **Automatic Critical CSS:** Only the styles needed for the currently rendered components are injected into the page, improving load times and reducing the initial CSS payload.\n*   **No Class Name Collisions:** Unique, hashed class names are generated automatically, so you never have to worry about style conflicts, even with third-party libraries.\n*   **Easier Deletion of CSS:** Styles are tightly coupled with their components. When you delete a component, its styles are also deleted, preventing 'dead CSS' build-up over time.\n*   **Dynamic Styling:** Seamlessly adjust styles based on props, component state, or theme variables directly within the CSS. This makes components highly adaptable and reusable.\n*   **Better Developer Experience:** Keep logic and styling related to a component in one place, enhancing readability and maintainability.\n*   **Theming:** Built-in support for theming through a `<ThemeProvider>` component, allowing you to define global styles, colors, and variables that can be accessed by all styled components.\n\n## Basic Usage\nTo create a styled component, import `styled` from `styled-components` and then use `styled.<HTML_tag_name>` (e.g., `styled.h1`, `styled.button`) followed by a tagged template literal containing your CSS. You can also style existing React components using `styled(Component)`.",
          "examples": [
            {
              "id": "example_styled_components_basic",
              "title": "Basic Styled Components Usage",
              "code": "import styled from 'styled-components';\nimport React from 'react';\n\n// Create a Title component that renders an <h1> with some styles\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n`;\n\n// Create a Wrapper component that renders a <section> with styling\nconst Wrapper = styled.section`\n  padding: 4em;\n  background: papayawhip;\n`;\n\n// How to use them in a React component\nfunction App() {\n  return (\n    <Wrapper>\n      <Title>Hello, Styled Components!</Title>\n      <p>This paragraph is outside the styled components but within the app.</p>\n    </Wrapper>\n  );\n}",
              "explanation": "This example shows the fundamental way to define and use styled components. `Title` and `Wrapper` are regular React components that, when rendered, produce HTML elements (`<h1>` and `<section>` respectively) with the specified CSS rules applied. The CSS is written directly within backticks (template literals), allowing for familiar CSS syntax.",
              "language": "typescript"
            },
            {
              "id": "example_styled_components_props",
              "title": "Dynamic Styling with Props",
              "code": "import styled from 'styled-components';\nimport React from 'react';\n\nconst Button = styled.button`\n  background: ${props => props.primary ? 'palevioletred' : 'white'};\n  color: ${props => props.primary ? 'white' : 'palevioletred'};\n\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n  cursor: pointer;\n\n  &:hover {\n    box-shadow: 0 0 5px palevioletred;\n    opacity: 0.9;\n  }\n`;\n\nfunction MyButtons() {\n  return (\n    <div style={{ display: 'flex', justifyContent: 'center' }}>\n      <Button>Normal Button</Button>\n      <Button primary>Primary Button</Button>\n    </div>\n  );\n}",
              "explanation": "Here, the `Button` component's `background` and `color` properties are determined by a `primary` prop. Inside the template literal, you can use a JavaScript function (an arrow function in this case) that receives the component's props as an argument. This allows for powerful dynamic styling based on component logic or external data, making the component reusable with different visual appearances.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_styled_components_mcq_css_syntax",
            "question_styled_components_open_advantages",
            "question_styled_components_flashcard_props",
            "question_styled_components_code_dynamic_button",
            "question_styled_components_mcq_scoping"
          ],
          "relatedTasks": [
            "task_styled_components_ui_elements"
          ],
          "tags": [
            "React",
            "Styling",
            "CSS-in-JS",
            "Styled Components",
            "Frontend Development"
          ],
          "technology": "React, Styled Components",
          "prerequisites": [
            "html_css_basics",
            "react_components_basics",
            "javascript_template_literals"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_react_styling",
            "component_design_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_use_counter_mcq_act_purpose",
          "topic": "React Hooks Testing",
          "level": "medium",
          "type": "mcq",
          "question": "In `react-hooks-testing-library` tests, why is it important to wrap state updates or function calls that modify hook state within an `act(() => { ... })` block?",
          "answer": "To ensure that React updates are flushed and applied before assertions are made, mimicking browser behavior.",
          "options": [
            "To make the test run faster by batching updates.",
            "To explicitly tell Jest to wait for asynchronous operations.",
            "To ensure that React updates are flushed and applied before assertions are made, mimicking browser behavior.",
            "To prevent infinite re-renders during testing."
          ],
          "analysisPoints": [
            "`act` is crucial for testing React's asynchronous rendering behavior, ensuring that all side effects from state updates are processed.",
            "It flushes all updates inside the callback, ensuring the DOM (or virtual DOM) is in a consistent state before subsequent assertions.",
            "Failing to use `act` can lead to misleading test results, flaky tests, or warnings about unhandled updates because React's updates might not have completed when assertions run."
          ],
          "keyConcepts": [
            "React `act`",
            "React Hook Testing Library",
            "Asynchronous Testing",
            "React Rendering Lifecycle",
            "Test Reliability"
          ],
          "evaluationCriteria": [
            "Understanding of React's update cycle and scheduling.",
            "Knowledge of `act`'s role in testing and its necessity for reliable tests.",
            "Ability to debug common testing pitfalls related to asynchronous updates."
          ],
          "example": "```typescript\nimport { renderHook, act } from '@testing-library/react-hooks';\nimport { useCounter } from './useCounter';\n\ntest('should increment counter correctly', () => {\n  const { result } = renderHook(() => useCounter(0));\n  \n  // This ensures all state updates from increment() are processed by React\n  // before the expect statement checks result.current.count.\n  act(() => {\n    result.current.increment();\n  });\n  \n  expect(result.current.count).toBe(1);\n});\n```",
          "tags": [
            "React Hooks",
            "Testing",
            "act",
            "react-hooks-testing-library",
            "Unit Testing"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "jest_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_counter_open_renderhook",
          "topic": "React Hooks Testing",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary purpose and usage of the `renderHook` utility from `react-hooks-testing-library`. How does it differ from the `render` utility from `@testing-library/react`?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "`renderHook` is specifically designed for testing custom hooks in isolation. Its primary purpose is to provide a minimalist React environment where a hook can be called and its return values can be observed and manipulated, without rendering an actual DOM element.",
            "It returns an object containing `result`, `rerender`, and `unmount` utilities, allowing tests to interact with the hook's lifecycle.",
            "The `result.current` property provides direct access to the values returned by the hook, enabling assertions on state or functions.",
            "In contrast, `render` from `@testing-library/react` is for testing React components by rendering them into a simulated DOM environment. It focuses on user interactions (e.g., clicking buttons, typing into inputs) and asserting on the visible output and accessibility, rather than direct access to component internals."
          ],
          "keyConcepts": [
            "renderHook",
            "render (Testing Library)",
            "React Hook Testing Library",
            "Testing React Components vs. Hooks",
            "Isolation in Testing",
            "Simulated DOM"
          ],
          "evaluationCriteria": [
            "Ability to articulate the specialized role of `renderHook` for custom hooks.",
            "Understanding the fundamental distinction between testing hooks in isolation and testing components through their rendered UI.",
            "Knowledge of different testing library utilities and their appropriate use cases."
          ],
          "example": "```typescript\nimport { renderHook } from '@testing-library/react-hooks';\nimport { useSomeHook } from './useSomeHook';\n\n// Usage of renderHook: Focus on the hook's return values\nconst { result, rerender, unmount } = renderHook(() => useSomeHook());\n\n// Comparison with render from @testing-library/react:\n// import { render, screen } from '@testing-library/react';\n// import { MyComponent } from './MyComponent';\n// render(<MyComponent />); // Renders to virtual DOM\n// screen.getByText('Some Text'); // Interacts with the rendered output\n```",
          "tags": [
            "React Hooks",
            "Testing",
            "react-hooks-testing-library",
            "Unit Testing",
            "Testing Library"
          ],
          "prerequisites": [
            "react_hooks",
            "testing_library_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_counter_flashcard_result_current",
          "topic": "React Hooks Testing",
          "level": "easy",
          "type": "flashcard",
          "question": "In `react-hooks-testing-library`, what does `result.current` provide access to after calling `renderHook` and subsequent `act` updates?",
          "answer": "The latest value returned by the custom hook.",
          "options": [],
          "analysisPoints": [
            "`result.current` is the primary interface for inspecting the state and functions exposed by your hook during testing.",
            "It always reflects the most up-to-date return value after any React updates have been processed (especially after `act` calls)."
          ],
          "keyConcepts": [
            "result.current",
            "React Hook Testing Library",
            "Hook State"
          ],
          "evaluationCriteria": [
            "Basic recall of `react-hooks-testing-library` API for accessing hook output."
          ],
          "example": "",
          "tags": [
            "React Hooks",
            "Testing",
            "react-hooks-testing-library",
            "Flashcard"
          ],
          "prerequisites": [
            "react_hooks"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_counter_code_usetoggle_test",
          "topic": "React Hooks Testing",
          "level": "medium",
          "type": "code",
          "question": "Implement a `useToggle` custom hook that takes an optional initial value (default `false`) and returns a boolean state and a `toggle` function. Then, write a unit test for this hook using `react-hooks-testing-library` to ensure it toggles the value correctly and respects the initial state.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly implementing `useState` and `useCallback` within the hook demonstrates fundamental hook knowledge and best practices for stability.",
            "Properly using `renderHook` to mount the hook in isolation is key for accurate testing.",
            "Using `act` to trigger the `toggle` function ensures that React's internal updates are flushed, making tests reliable and preventing warnings.",
            "Asserting against `result.current` for both initial and toggled states validates the hook's functionality."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "useState",
            "useCallback",
            "react-hooks-testing-library",
            "Unit Testing",
            "act",
            "Test-Driven Development"
          ],
          "evaluationCriteria": [
            "Ability to create and test custom hooks adhering to React's best practices.",
            "Understanding of testing asynchronous React updates with `act`.",
            "Code quality, readability, and correct API usage."
          ],
          "example": "```typescript\n// useToggle.js\nimport { useState, useCallback } from 'react';\n\nexport function useToggle(initialValue = false) {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() => {\n    setValue(prevValue => !prevValue);\n  }, []);\n\n  return [value, toggle];\n}\n\n// useToggle.test.js\nimport { renderHook, act } from '@testing-library/react-hooks';\nimport { useToggle } from './useToggle';\n\ntest('should toggle value from false to true and back', () => {\n  const { result } = renderHook(() => useToggle());\n  expect(result.current[0]).toBe(false);\n\n  act(() => {\n    result.current[1](); // Call the toggle function\n  });\n  expect(result.current[0]).toBe(true);\n\n  act(() => {\n    result.current[1]();\n  });\n  expect(result.current[0]).toBe(false);\n});\n\ntest('should respect initial value', () => {\n  const { result } = renderHook(() => useToggle(true));\n  expect(result.current[0]).toBe(true);\n\n  act(() => {\n    result.current[1]();\n  });\n  expect(result.current[0]).toBe(false);\n});\n```",
          "tags": [
            "React Hooks",
            "Testing",
            "Code Challenge",
            "useState",
            "useCallback",
            "Jest"
          ],
          "prerequisites": [
            "react_hooks",
            "jest",
            "testing_library"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_counter_difficulty_test",
          "topic": "React Hooks Testing",
          "level": "hard",
          "type": "open",
          "question": "You are testing a custom hook `useFetchData` that fetches data asynchronously. Explain how you would simulate different API responses (success, error, loading) and how `react-hooks-testing-library` and Jest mocks would be used together to achieve this. Consider potential race conditions if multiple fetches are triggered rapidly.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "**Mocking API Calls:** Explain how to use Jest's mocking capabilities (`jest.spyOn(global, 'fetch')` or `jest.mock('axios')`) to control network responses. Detail `mockResolvedValueOnce` for successful data and `mockRejectedValueOnce` for errors.",
            "**Handling Asynchronicity:** Describe the use of `await act(async () => { ... })` and `waitForNextUpdate()` (or `waitFor`) from `react-hooks-testing-library` to wait for asynchronous state changes and re-renders that result from API calls.",
            "**Simulating Loading States:** Explain how to assert the `loading` state immediately after the hook is rendered and before the API call resolves/rejects, and then again after the asynchronous operation completes.",
            "**Simulating Race Conditions:** Discuss how `jest.useFakeTimers()` and `jest.advanceTimersByTime()` can simulate network delays, allowing you to test scenarios where multiple fetch requests might be initiated before previous ones complete. This highlights the need for cleanup functions in `useEffect` or debouncing/throttling mechanisms within the hook itself."
          ],
          "keyConcepts": [
            "Asynchronous Testing",
            "Jest Mocks",
            "react-hooks-testing-library",
            "Race Conditions",
            "Network Requests",
            "jest.useFakeTimers",
            "useEffect Cleanup"
          ],
          "evaluationCriteria": [
            "Advanced understanding of asynchronous testing patterns in React.",
            "Proficiency in Jest mocking capabilities for network requests.",
            "Ability to design robust tests for complex, side-effect-laden hooks.",
            "Awareness of common pitfalls like race conditions and strategies to mitigate them in both hook implementation and testing."
          ],
          "example": "```typescript\n// Example pseudo-code for testing useFetchData hook:\nimport { renderHook, act, waitFor } from '@testing-library/react-hooks';\n\n// Assume useFetchData is implemented like:\n// function useFetchData(url) {\n//   const [data, setData] = useState(null);\n//   const [loading, setLoading] = useState(false);\n//   const [error, setError] = useState(null);\n//   useEffect(() => {\n//     let isMounted = true;\n//     const fetchData = async () => {\n//       setLoading(true);\n//       try {\n//         const response = await fetch(url);\n//         const json = await response.json();\n//         if (isMounted) setData(json);\n//       } catch (e) {\n//         if (isMounted) setError(e);\n//       } finally {\n//         if (isMounted) setLoading(false);\n//       }\n//     };\n//     fetchData();\n//     return () => { isMounted = false; }; // Cleanup for race conditions\n//   }, [url]);\n//   return { data, loading, error };\n// }\n\n// Mock the global fetch function\nglobal.fetch = jest.fn();\n\ntest('should fetch data successfully and update states', async () => {\n  // Arrange: Mock a successful API response\n  fetch.mockResolvedValueOnce({\n    ok: true,\n    json: () => Promise.resolve({ id: 1, name: 'Test Data' }),\n  });\n\n  // Act: Render the hook\n  const { result, waitForNextUpdate } = renderHook(() => useFetchData('/api/data'));\n\n  // Assert: Initial loading state\n  expect(result.current.loading).toBe(true);\n  expect(result.current.data).toBeNull();\n  expect(result.current.error).toBeNull();\n\n  // Act: Wait for the asynchronous update to complete\n  await act(async () => {\n    await waitForNextUpdate(); // Wait until the next render cycle occurs due to state change\n  });\n\n  // Assert: Final state after successful fetch\n  expect(result.current.loading).toBe(false);\n  expect(result.current.data).toEqual({ id: 1, name: 'Test Data' });\n  expect(result.current.error).toBeNull();\n});\n\ntest('should handle fetch errors and update states', async () => {\n  // Arrange: Mock an API error response\n  const errorMessage = 'Network error occurred!';\n  fetch.mockRejectedValueOnce(new Error(errorMessage));\n\n  // Act: Render the hook\n  const { result, waitForNextUpdate } = renderHook(() => useFetchData('/api/data'));\n\n  // Assert: Initial loading state (same as success case)\n  expect(result.current.loading).toBe(true);\n\n  // Act: Wait for the asynchronous update to complete\n  await act(async () => {\n    await waitForNextUpdate();\n  });\n\n  // Assert: Final state after error\n  expect(result.current.loading).toBe(false);\n  expect(result.current.data).toBeNull();\n  expect(result.current.error).toBeInstanceOf(Error);\n  expect(result.current.error.message).toBe(errorMessage);\n});\n```",
          "tags": [
            "React Hooks",
            "Testing",
            "Asynchronous",
            "Jest",
            "Mocks",
            "Hard",
            "API Integration"
          ],
          "prerequisites": [
            "async_await",
            "jest_mocking",
            "react_hooks_advanced",
            "useEffect"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_pure_component_mcq_shallow_comparison",
          "topic": "React.PureComponent",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following best describes how `React.PureComponent` optimizes re-renders?",
          "answer": "It automatically implements `shouldComponentUpdate` with a shallow comparison of props and state.",
          "options": [
            "It performs a deep comparison of props and state to decide on re-renders.",
            "It memoizes the entire component tree to avoid re-renders.",
            "It automatically implements `shouldComponentUpdate` with a shallow comparison of props and state.",
            "It prevents all re-renders unless `forceUpdate` is explicitly called."
          ],
          "analysisPoints": [
            "The core mechanism of `PureComponent` is its default implementation of `shouldComponentUpdate`.",
            "The comparison is *shallow*, meaning it only checks for reference equality of properties, not deep content changes.",
            "This optimization avoids unnecessary work (re-rendering) when props and state haven't changed at the top level.",
            "It does not prevent *all* re-renders; it's a conditional re-render based on its internal comparison logic."
          ],
          "keyConcepts": [
            "React.PureComponent",
            "shouldComponentUpdate",
            "Shallow Comparison",
            "Performance Optimization",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Understanding of `PureComponent`'s internal mechanism for optimization.",
            "Ability to distinguish between shallow and deep comparison.",
            "Knowledge of how `PureComponent` contributes to React performance."
          ],
          "example": "```typescript\n// PureComponent's internal shouldComponentUpdate logic:\nclass MyPureComponent extends React.PureComponent {\n  shouldComponentUpdate(nextProps, nextState) {\n    // This is the logic PureComponent implements automatically\n    return !shallowEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);\n  }\n  render() { /* ... */ }\n}\n```",
          "tags": [
            "React",
            "PureComponent",
            "Performance",
            "Shallow Comparison",
            "Optimization"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pure_component_open_when_not_to_use",
          "topic": "React.PureComponent",
          "level": "medium",
          "type": "open",
          "question": "Describe scenarios where using `React.PureComponent` might lead to unexpected behavior or issues, rather than performance improvements. What alternative strategies or patterns would you consider in such cases?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "**Deeply Nested Objects/Arrays:** If props or state contain objects or arrays that are mutated internally (i.e., their contents change, but their reference remains the same), `PureComponent`'s shallow comparison will not detect the change. This leads to the component *not* re-rendering, resulting in stale or incorrect UI. This is the most common pitfall.",
            "**Functions as Props:** When a parent component defines a function inline within its `render` method and passes it as a prop to a `PureComponent` child, a new function instance is created on every parent re-render. `PureComponent` will detect this new function reference (even if its logic is identical) and unnecessarily re-render its child.",
            "**Context API:** Components that consume React Context (especially legacy context or if `shouldComponentUpdate` is not designed to account for it) might re-render even if their own props and state are shallowly equal, as `PureComponent`'s default logic does not inherently check for context changes.",
            "**Alternatives/Mitigations:**\n    *   **Immutability:** Always update nested data by creating new objects/arrays (e.g., using spread syntax `{ ...old, key: newValue }` or immutable-helper libraries like Immer). This ensures new references are generated when content changes, allowing `PureComponent` to detect updates.\n    *   **Memoizing Functions:** For functions passed as props, ensure their reference is stable. For class components, bind methods in the constructor (`this.method = this.method.bind(this)`). For functional components, use `useCallback` (`const memoizedFn = useCallback(() => { ... }, [dependencies])`).\n    *   **Custom `shouldComponentUpdate`:** For complex cases requiring deep comparisons or specific logic, use `React.Component` and implement `shouldComponentUpdate` manually with custom comparison logic.\n    *   **`React.memo` with Custom Comparison:** For functional components, `React.memo` (the functional equivalent of `PureComponent`) can accept a second argument, `arePropsEqual`, which is a custom comparison function for more granular control over re-renders."
          ],
          "keyConcepts": [
            "PureComponent Limitations",
            "Shallow Comparison",
            "Immutability",
            "Functions as Props",
            "Context API",
            "shouldComponentUpdate",
            "React.memo",
            "useCallback"
          ],
          "evaluationCriteria": [
            "Identification and clear explanation of `PureComponent`'s pitfalls due to shallow comparison.",
            "Understanding of how these issues manifest (e.g., stale UI, unnecessary re-renders).",
            "Knowledge of best practices for state management and functional components to avoid these issues.",
            "Ability to suggest appropriate alternative solutions or patterns."
          ],
          "example": "```typescript\n// Problematic scenario for PureComponent due to mutable nested object:\nclass Parent extends React.Component {\n  state = { data: { count: 0 } };\n  componentDidMount() {\n    setInterval(() => {\n      // Problem: Mutates the existing object and then sets state with the SAME REFERENCE\n      this.state.data.count++; \n      this.setState({ data: this.state.data }); // PureChild WILL NOT re-render reliably\n    }, 1000);\n  }\n  render() {\n    return <PureChild data={this.state.data} />;\n  }\n}\nclass PureChild extends React.PureComponent {\n  render() {\n    console.log('PureChild re-rendered'); // Might not log when expected\n    return <p>Count: {this.props.data.count}</p>;\n  }\n}\n\n// Mitigation for the above issue (using immutability):\nclass ParentFixed extends React.Component {\n  state = { data: { count: 0 } };\n  componentDidMount() {\n    setInterval(() => {\n      // Solution: Create a NEW object reference when data changes\n      this.setState(prevState => ({\n        data: { ...prevState.data, count: prevState.data.count + 1 }\n      }));\n    }, 1000);\n  }\n  render() {\n    return <PureChild data={this.state.data} />;\n  }\n}\n```",
          "tags": [
            "React",
            "PureComponent",
            "Performance",
            "Pitfalls",
            "Immutability",
            "Optimization"
          ],
          "prerequisites": [
            "react_lifecycle_methods",
            "javascript_objects_references",
            "react_state_management"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_pure_component_flashcard_benefit",
          "topic": "React.PureComponent",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using `React.PureComponent` in a class component?",
          "answer": "It provides a performance boost by preventing unnecessary re-renders of the component when its props and state have not shallowly changed.",
          "options": [],
          "analysisPoints": [
            "The main advantage is reducing the number of `render` calls, thus saving CPU cycles and improving application responsiveness.",
            "It's a form of memoization for class components."
          ],
          "keyConcepts": [
            "PureComponent",
            "Performance Optimization",
            "Re-renders",
            "shouldComponentUpdate"
          ],
          "evaluationCriteria": [
            "Basic understanding of `PureComponent`'s purpose and its direct impact on performance."
          ],
          "example": "",
          "tags": [
            "React",
            "PureComponent",
            "Performance",
            "Flashcard",
            "Optimization"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_pure_component_code_refactor_example",
          "topic": "React.PureComponent",
          "level": "medium",
          "type": "code",
          "question": "Consider a `UserProfile` component that receives `user` (an object) and `onEdit` (a function) as props. The `user` object might have nested properties (e.g., `user.address.city`). The `onEdit` function is passed down from a parent. Refactor the `UserProfile` from `React.Component` to `React.PureComponent` and identify any potential issues that might arise if `user` is mutated or `onEdit` is an inline function in the parent. Suggest and implement how to mitigate these issues.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Demonstrates the syntactic change from `React.Component` to `React.PureComponent`.",
            "Highlights the `console.log` in `render` to observe re-renders, which helps in debugging performance.",
            "Explains that if `user.address.city` is changed without creating a new `user` object reference, `PureComponent` will *not* re-render (stale UI).",
            "Explains that if `onEdit` is defined inline in the parent's `render` method, it will create a new function reference every time, causing `PureComponent` to unnecessarily re-render.",
            "Proposes and implements solutions:\n    *   For `user` object: enforce immutability by always creating a new object reference when updating (`this.setState(prev => ({ user: { ...prev.user, name: 'new' } }))` or deep cloning if necessary). For nested objects, all ancestors in the path to the mutated property must also be new objects.\n    *   For `onEdit` function: memoize the function. For class components, this means binding `this` in the constructor (`this.method = this.method.bind(this)`). For functional parents, it implies using `useCallback`."
          ],
          "keyConcepts": [
            "PureComponent",
            "Immutability",
            "Function References",
            "Performance Optimization",
            "shouldComponentUpdate",
            "useCallback",
            "Class Component Optimization"
          ],
          "evaluationCriteria": [
            "Ability to apply `PureComponent` correctly.",
            "Identifying and explaining common `PureComponent` pitfalls (mutable nested data, unstable function references).",
            "Proposing and implementing effective, idiomatic React solutions for these pitfalls (immutability, memoization).",
            "Understanding the underlying reasons for `PureComponent`'s behavior."
          ],
          "example": "```typescript\nimport React from 'react';\n\n// --- Initial UserProfile component (React.Component) ---\nclass UserProfileRegular extends React.Component {\n  render() {\n    console.log('UserProfileRegular (React.Component) re-rendered');\n    const { user, onEdit } = this.props;\n    return (\n      <div style={{ border: '1px solid #aaa', padding: '10px', margin: '10px' }}>\n        <h3>Regular User Profile</h3>\n        <p>Name: {user.name}</p>\n        <p>City: {user.address.city}</p>\n        <button onClick={onEdit}>Edit Profile</button>\n      </div>\n    );\n  }\n}\n\n// --- Refactored UserProfile component (React.PureComponent) ---\nclass UserProfilePure extends React.PureComponent {\n  render() {\n    console.log('UserProfilePure (React.PureComponent) re-rendered');\n    const { user, onEdit } = this.props;\n    return (\n      <div style={{ border: '1px solid #228B22', padding: '10px', margin: '10px' }}>\n        <h3>Pure User Profile</h3>\n        <p>Name: {user.name}</p>\n        <p>City: {user.address.city}</p>\n        <button onClick={onEdit}>Edit Profile</button>\n      </div>\n    );\n  }\n}\n\n// --- Parent Component demonstrating issues and solutions ---\nclass AppParent extends React.Component {\n  state = {\n    count: 0,\n    user: { \n      id: 1, \n      name: 'John Doe', \n      address: { street: '123 Main St', city: 'Anytown' }\n    }\n  };\n\n  // Mitigation for functions as props: Bind in constructor for class components\n  constructor(props) {\n    super(props);\n    this.handleEdit = this.handleEdit.bind(this);\n    // If a functional parent, use useCallback: \n    // const handleEdit = useCallback(() => { console.log('Editing...'); }, []);\n  }\n\n  handleEdit() {\n    console.log('Editing user profile...');\n  }\n\n  componentDidMount() {\n    this.interval = setInterval(() => {\n      this.setState(prevState => {\n        const newCount = prevState.count + 1;\n        let newUser = prevState.user;\n\n        // Simulate changing user data every 3 seconds\n        if (newCount % 3 === 0) {\n          // Problematic: Mutating nested property without creating new reference\n          // prevState.user.address.city = 'Othertown ' + newCount; \n          // newUser = prevState.user; \n\n          // Mitigation: Ensure immutability for user object and nested address\n          newUser = {\n            ...prevState.user,\n            address: { ...prevState.user.address, city: `City ${newCount}` }\n          };\n        }\n        \n        return { count: newCount, user: newUser };\n      });\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    console.log('AppParent re-rendered. Count:', this.state.count);\n    return (\n      <div style={{ padding: '20px', border: '2px dashed blue' }}>\n        <h1>Parent Component (updates every second)</h1>\n        <p>Parent Current Count: {this.state.count}</p>\n        <hr/>\n        <UserProfileRegular user={this.state.user} onEdit={this.handleEdit} />\n        <hr/>\n        <UserProfilePure user={this.state.user} onEdit={this.handleEdit} />\n        <p>Check console logs for 're-rendered' messages.</p>\n      </div>\n    );\n  }\n}\n\nexport default AppParent;\n```",
          "tags": [
            "React",
            "PureComponent",
            "Code Challenge",
            "Performance",
            "Immutability",
            "Functions as Props",
            "Optimization"
          ],
          "prerequisites": [
            "react_class_components",
            "javascript_closures_scope",
            "react_state_management"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_pure_component_mcq_deep_comparison",
          "topic": "React.PureComponent",
          "level": "hard",
          "type": "mcq",
          "question": "You have a `React.PureComponent` that receives a `data` prop, which is an array of objects: `[{ id: 1, value: 'A' }, { id: 2, value: 'B' }]`. If you modify the `value` of an object within this array (e.g., `data[0].value = 'C'`) directly (mutating the original object) without creating a new array or a new object reference for `data[0]`, will the `PureComponent` re-render?",
          "answer": "No, because `PureComponent` performs a shallow comparison and the array reference itself has not changed.",
          "options": [
            "Yes, because `PureComponent` detects changes in nested array elements.",
            "No, because `PureComponent` performs a shallow comparison and the array reference itself has not changed.",
            "Only if `React.memo` is used in conjunction with `PureComponent`.",
            "It depends on whether `shouldComponentUpdate` is explicitly overridden."
          ],
          "analysisPoints": [
            "This question tests a critical understanding of the 'shallow' aspect of `PureComponent`'s comparison.",
            "Mutating a nested property of an object or array without creating a new reference for the parent object/array is a common trap for `PureComponent`.",
            "Because the `data` array's reference remains the same (`this.props.data === nextProps.data`), `shallowEqual` will return `true` for the props, causing `PureComponent` to skip the re-render.",
            "For the component to re-render, a new array and new object references for the changed items within it must be created (e.g., `newData = oldData.map(item => item.id === 1 ? { ...item, value: 'C' } : item)`).",
            "Explicitly overriding `shouldComponentUpdate` or using `React.memo` with a custom comparison function (`arePropsEqual`) would be necessary if you *must* work with mutable deep data and require updates."
          ],
          "keyConcepts": [
            "PureComponent",
            "Shallow Comparison",
            "Immutability",
            "Nested Data",
            "Object References",
            "shouldComponentUpdate"
          ],
          "evaluationCriteria": [
            "Deep understanding of `shallowEqual`'s limitations and its implications for `PureComponent`.",
            "Ability to anticipate `PureComponent` behavior with mutable nested data structures.",
            "Knowledge of how to correctly update complex data structures for optimized React components."
          ],
          "example": "```typescript\n// Parent component demonstrating mutable data sent to PureComponent\nclass ParentDataMutator extends React.Component {\n  state = { data: [{ id: 1, value: 'A' }, { id: 2, value: 'B' }] };\n\n  componentDidMount() {\n    this.interval = setInterval(() => {\n      // THIS IS PROBLEMATIC FOR PURECOMPONENT:\n      // Mutating the existing object inside the array, array reference remains the same\n      this.state.data[0].value = `Updated: ${Math.random().toFixed(2)}`;\n      this.setState({ data: this.state.data }); // array reference unchanged\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    console.log('ParentDataMutator render');\n    return <PureChildDisplay data={this.state.data} />;\n  }\n}\n\nclass PureChildDisplay extends React.PureComponent {\n  render() {\n    console.log('PureChildDisplay render called'); // This might NOT be called even if data[0].value changes\n    return (\n      <div style={{ border: '1px solid purple', padding: '10px', margin: '10px' }}>\n        <h3>Pure Child Display (Check Console)</h3>\n        {this.props.data.map(item => (\n          <p key={item.id}>{item.id}: {item.value}</p>\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default ParentDataMutator;\n```",
          "tags": [
            "React",
            "PureComponent",
            "Performance",
            "Shallow Comparison",
            "Immutability",
            "Hard",
            "Data Structures"
          ],
          "prerequisites": [
            "javascript_object_references",
            "react_state_management"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_styled_components_mcq_css_syntax",
          "topic": "Styled Components",
          "level": "easy",
          "type": "mcq",
          "question": "What primary JavaScript syntax construct is used to write CSS rules directly within a Styled Components definition?",
          "answer": "Tagged template literals (backticks ```` ` ````)",
          "options": [
            "JSX curly braces `{ }` with CSS-in-JS objects.",
            "Regular CSS files imported as modules.",
            "Tagged template literals (backticks ```` ` ````)",
            "JSON objects passed as props to the `style` attribute."
          ],
          "analysisPoints": [
            "Styled Components leverage a specific ES6 JavaScript feature: tagged template literals.",
            "This allows for actual CSS syntax within JavaScript string literals, making the styling feel native CSS-like.",
            "Other options describe different styling approaches (e.g., inline styles, CSS modules, plain JS objects), but not the core syntax of Styled Components."
          ],
          "keyConcepts": [
            "Styled Components",
            "CSS-in-JS",
            "Template Literals",
            "JavaScript Syntax"
          ],
          "evaluationCriteria": [
            "Basic knowledge of Styled Components' core syntax and how CSS is embedded.",
            "Understanding of fundamental JavaScript features used by the library."
          ],
          "example": "```typescript\nimport styled from 'styled-components';\n\nconst MyComponent = styled.div`\n  color: blue; /* CSS rules go inside these backticks */\n  font-size: 16px;\n  padding: 10px;\n`;\n\nfunction App() {\n  return <MyComponent>Hello, Styled!</MyComponent>;\n}\n```",
          "tags": [
            "Styled Components",
            "CSS-in-JS",
            "Syntax",
            "Beginner"
          ],
          "prerequisites": [
            "javascript_template_literals"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_styled_components_open_advantages",
          "topic": "Styled Components",
          "level": "medium",
          "type": "open",
          "question": "Discuss at least three significant advantages of using Styled Components (or a similar CSS-in-JS library like Emotion) over traditional CSS methodologies (e.g., global CSS files, BEM, or CSS Modules) in a large-scale React application. Provide a brief explanation for each advantage.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "**Automatic Critical CSS & Performance:** Styled Components automatically extracts only the CSS required for the components rendered on the initial screen and injects it. This reduces the initial CSS bundle size, leading to faster page load times and better perceived performance compared to loading monolithic CSS files where much of the CSS might be unused on a given page.",
            "**No Class Name Collisions & Scoped Styles:** Styled Components generate unique, hashed class names for each styled component. This completely eliminates the problem of class name collisions, which can plague large codebases using global CSS. Developers no longer need to rely on strict naming conventions like BEM or manual scoping mechanisms, simplifying development and preventing unexpected style overrides.",
            "**Easier Deletion of CSS & Maintainability:** Styles are co-located directly with the React components they style. This means that when a component is deleted, its associated styles are automatically removed from the codebase. This prevents 'dead CSS' (CSS that is no longer used but remains in the codebase) from accumulating, which improves long-term maintainability and reduces technical debt. It also makes refactoring easier as style dependencies are clear.",
            "**Dynamic Styling with JavaScript:** Styled Components allow direct access to component props and the theme object within the CSS definitions. This enables powerful dynamic styling based on component state, user interactions, or global theme variables, making components highly adaptable and reusable without resorting to complex JavaScript logic to toggle many class names.",
            "**Theming Capabilities:** Libraries like Styled Components often come with built-in `ThemeProvider` support, making it straightforward to implement global themes (e.g., light/dark mode, brand colors) that can be easily accessed and applied across all styled components.",
            "**Improved Developer Experience:** By keeping styling and component logic in the same JavaScript file, developers can reason about components more easily, leading to better organization and reduced context switching."
          ],
          "keyConcepts": [
            "CSS-in-JS",
            "Styled Components Advantages",
            "Scoped Styles",
            "Automatic Critical CSS",
            "Maintainability",
            "Performance Optimization",
            "Dynamic Styling",
            "Theming"
          ],
          "evaluationCriteria": [
            "Ability to articulate multiple distinct advantages of CSS-in-JS.",
            "Clear and concise explanations for each advantage.",
            "Demonstration of understanding how these benefits address challenges in large-scale applications.",
            "Comparison with traditional styling methods (implies understanding of their limitations)."
          ],
          "example": "",
          "tags": [
            "Styled Components",
            "CSS-in-JS",
            "Advantages",
            "Architecture",
            "Scaling",
            "Frontend Development"
          ],
          "prerequisites": [
            "css_basics",
            "react_styling_methods"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_styled_components_flashcard_props",
          "topic": "Styled Components",
          "level": "easy",
          "type": "flashcard",
          "question": "How can you pass and use dynamic props within a Styled Components style definition to conditionally change styles?",
          "answer": "By using a JavaScript function (e.g., an arrow function) inside the template literal that receives the component's props as an argument.",
          "options": [],
          "analysisPoints": [
            "This mechanism is fundamental to Styled Components' power for creating highly dynamic and reusable UI components.",
            "The function receives the entire `props` object, allowing access to any prop passed to the component."
          ],
          "keyConcepts": [
            "Styled Components",
            "Dynamic Styling",
            "Props",
            "Tagged Template Literals",
            "Conditional Styling"
          ],
          "evaluationCriteria": [
            "Recall of the primary method for making styles dynamic in Styled Components."
          ],
          "example": "```typescript\nimport styled from 'styled-components';\n\nconst DynamicDiv = styled.div`\n  background-color: ${props => props.isActive ? 'blue' : 'gray'};\n  color: white;\n  padding: 10px;\n`;\n\n// Usage:\n// <DynamicDiv isActive={true}>Active</DynamicDiv>\n// <DynamicDiv isActive={false}>Inactive</DynamicDiv>\n```",
          "tags": [
            "Styled Components",
            "Props",
            "Flashcard",
            "Dynamic Styling"
          ],
          "prerequisites": [
            "react_props",
            "javascript_arrow_functions"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_styled_components_code_dynamic_button",
          "topic": "Styled Components",
          "level": "medium",
          "type": "code",
          "question": "Create a `Button` styled component that changes its `background-color` to `darkblue` and `color` to `white` when a `variant` prop is set to `'primary'`, otherwise it should have a `lightgray` background and `black` text. Additionally, apply a default `padding` of `10px 20px`, `border-radius` of `5px`, and `border: none`. Ensure it has a subtle `box-shadow` on hover. Finally, demonstrate its usage by rendering both a 'default' and a 'primary' button.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly define a styled component using `styled.button`.",
            "Effectively utilize prop-based styling within the template literal to implement conditional `background-color` and `color`.",
            "Apply basic CSS properties like `padding`, `border-radius`, and `border`.",
            "Demonstrate the use of CSS pseudo-classes (`&:hover`) for interactive styling.",
            "Properly render both primary and default buttons in a React component to show functionality."
          ],
          "keyConcepts": [
            "Styled Components",
            "Dynamic Styling",
            "Props",
            "CSS Properties",
            "Pseudo-classes",
            "Component Reusability"
          ],
          "evaluationCriteria": [
            "Ability to create and apply styled components with dynamic properties.",
            "Proficiency in embedding conditional logic within CSS using props.",
            "Correct application of common CSS rules and pseudo-classes.",
            "Clean and functional demonstration of the styled component."
          ],
          "example": "```typescript\nimport styled from 'styled-components';\nimport React from 'react';\n\nconst Button = styled.button`\n  padding: 10px 20px;\n  border-radius: 5px;\n  border: none;\n  cursor: pointer;\n  font-weight: bold;\n  transition: all 0.2s ease-in-out; /* Smooth transition for hover */\n  \n  background-color: ${props => props.variant === 'primary' ? 'darkblue' : 'lightgray'};\n  color: ${props => props.variant === 'primary' ? 'white' : 'black'};\n\n  &:hover {\n    opacity: 0.9;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n  }\n`;\n\nfunction App() {\n  return (\n    <div style={{ padding: '20px', display: 'flex', gap: '10px' }}>\n      <Button>Default Button</Button>\n      <Button variant=\"primary\">Primary Button</Button>\n    </div>\n  );\n}\n\nexport default App;\n```",
          "tags": [
            "Styled Components",
            "Code Challenge",
            "Dynamic Styling",
            "CSS",
            "Frontend"
          ],
          "prerequisites": [
            "react_basics",
            "css_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_styled_components_mcq_scoping",
          "topic": "Styled Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements most accurately describes how Styled Components ensure style isolation and prevent class name conflicts in a large application?",
          "answer": "It generates unique, hashed class names for each styled component at runtime, automatically scoping the applied CSS rules.",
          "options": [
            "It uses the browser's Shadow DOM to encapsulate styles entirely.",
            "It relies on global CSS cascades and enforces a strict BEM naming convention on developers.",
            "It wraps components in an `iframe` to isolate their styles from the main document.",
            "It generates unique, hashed class names for each styled component at runtime, automatically scoping the applied CSS rules."
          ],
          "analysisPoints": [
            "The core mechanism of Styled Components for isolation is the automatic generation of unique, dynamic class names (e.g., `sc-1f7c1d7-0 jwWzQo`). These class names are injected into the HTML and CSS, effectively scoping the styles to their respective components.",
            "This approach removes the burden of manual naming conventions (like BEM) or relying on developer discipline to avoid conflicts.",
            "It does *not* use Shadow DOM (which is a different web component standard for true encapsulation) or iframes (which are heavy and create separate browsing contexts).",
            "It directly solves the problem of global CSS conflicts by making styles locally relevant to the component that defines them."
          ],
          "keyConcepts": [
            "Styled Components",
            "Style Isolation",
            "CSS Scoping",
            "Class Name Collisions",
            "CSS-in-JS Architecture",
            "Runtime Generation"
          ],
          "evaluationCriteria": [
            "Understanding of Styled Components' core architectural feature for style management and conflict prevention.",
            "Ability to differentiate its approach from other styling methodologies.",
            "Knowledge of how it enhances maintainability and scalability in large projects."
          ],
          "example": "```css\n/* Example of CSS generated by Styled Components for a Title component */\n.sc-bZQynM.gTjMgi {\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n}\n\n/* The generated HTML would look something like */\n<h1 class=\"sc-bZQynM gTjMgi\">Hello, Styled Components!</h1>\n```\nHere, `sc-bZQynM` and `gTjMgi` are unique, auto-generated class names ensuring the `h1` component's styles don't bleed out or conflict with any other `h1` or similar styles on the page.",
          "tags": [
            "Styled Components",
            "CSS-in-JS",
            "Scoping",
            "Architecture",
            "Intermediate"
          ],
          "prerequisites": [
            "css_specificity",
            "react_styling_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_use_toggle_hook",
          "title": "Implement and Test a `useToggle` Hook",
          "description": "\nCreate a custom React Hook called `useToggle`. This hook should manage a boolean state, similar to `useState`, but specifically designed for toggling.\n\n**Requirements:**\n1.  The hook should accept an optional `initialValue` (default to `false`).\n2.  It should return an array containing the current boolean `value` and a `toggle` function.\n3.  The `toggle` function, when called, should invert the current boolean `value`.\n4.  Ensure the `toggle` function is stable across re-renders (i.e., use `useCallback`).\n\n**Testing Requirements:**\n1.  Write unit tests for `useToggle` using `react-hooks-testing-library`.\n2.  Test that the hook correctly initializes with the default `false` value.\n3.  Test that the hook correctly initializes with a provided `initialValue` (e.g., `true`).\n4.  Test that the `toggle` function correctly switches the boolean state from `false` to `true` and back multiple times.\n5.  Ensure all state-modifying actions in tests are wrapped with `act` to reflect React's update cycle.\n",
          "difficulty": "medium",
          "startingCode": "import { useState, useCallback } from 'react';\nimport { renderHook, act } from '@testing-library/react-hooks';\n\n// --- Implement useToggle hook here ---\n/**\n * A custom hook to manage a boolean toggle state.\n * @param {boolean} initialValue The initial boolean value (defaults to false).\n * @returns {[boolean, () => void]}\n */\nfunction useToggle(initialValue) {\n  // TODO: Implement the hook logic using useState and useCallback\n  return [false, () => {}]; // Placeholder\n}\n\n// --- Write tests for useToggle hook here ---\n// Example Test Structure:\n/*\ntest('should initialize with default false', () => {\n  const { result } = renderHook(() => useToggle());\n  expect(result.current[0]).toBe(false);\n});\n\ntest('should initialize with provided initial value', () => {\n  // ...\n});\n\ntest('should toggle value correctly multiple times', () => {\n  // ...\n});\n*/\n",
          "solutionCode": "import { useState, useCallback } from 'react';\nimport { renderHook, act } from '@testing-library/react-hooks';\n\n/**\n * A custom hook to manage a boolean toggle state.\n * @param {boolean} initialValue The initial boolean value (defaults to false).\n * @returns {[boolean, () => void]}\n */\nfunction useToggle(initialValue = false) {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() => {\n    setValue(prevValue => !prevValue);\n  }, []);\n\n  return [value, toggle];\n}\n\ntest('should initialize with default false', () => {\n  const { result } = renderHook(() => useToggle());\n  expect(result.current[0]).toBe(false);\n});\n\ntest('should initialize with provided initial value', () => {\n  const { result } = renderHook(() => useToggle(true));\n  expect(result.current[0]).toBe(true);\n});\n\ntest('should toggle value correctly from false to true and back', () => {\n  const { result } = renderHook(() => useToggle());\n  expect(result.current[0]).toBe(false);\n\n  act(() => {\n    result.current[1](); // Call toggle function\n  });\n  expect(result.current[0]).toBe(true);\n\n  act(() => {\n    result.current[1](); // Call toggle again\n  });\n  expect(result.current[0]).toBe(false);\n});\n\ntest('should toggle value correctly from true to false and back', () => {\n  const { result } = renderHook(() => useToggle(true));\n  expect(result.current[0]).toBe(true);\n\n  act(() => {\n    result.current[1](); // Call toggle function\n  });\n  expect(result.current[0]).toBe(false);\n\n  act(() => {\n    result.current[1](); // Call toggle again\n  });\n  expect(result.current[0]).toBe(true);\n});\n\ntest('should handle multiple rapid toggles correctly', () => {\n  const { result } = renderHook(() => useToggle(false));\n  expect(result.current[0]).toBe(false);\n\n  act(() => {\n    result.current[1](); // false -> true\n    result.current[1](); // true -> false\n    result.current[1](); // false -> true\n  });\n  expect(result.current[0]).toBe(true);\n});\n",
          "testCases": [
            "Test `useToggle()` initializes to `false`.",
            "Test `useToggle(true)` initializes to `true`.",
            "Test `toggle()` switches `false` to `true`.",
            "Test `toggle()` switches `true` to `false`.",
            "Test multiple sequential `toggle()` calls result in correct final state (e.g., `false -> true -> false -> true`)."
          ],
          "hints": [
            "Remember to use `useState` for managing the boolean state.",
            "Wrap the `toggle` function with `useCallback` to prevent it from being recreated on every re-render of the component that consumes the hook. This is a good practice for performance and stability.",
            "The `act()` wrapper is crucial around any code that causes state updates within your hook to ensure React's updates are processed before you assert on `result.current`."
          ],
          "tags": [
            "React Hooks",
            "Testing",
            "Custom Hook",
            "Unit Testing",
            "Jest",
            "useCallback",
            "useState"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_useState",
            "react_useCallback",
            "react_hooks_testing_library_basics",
            "jest_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useState",
            "useCallback",
            "act",
            "renderHook",
            "test_driven_development"
          ]
        },
        {
          "id": "task_pure_component_performance_demo",
          "title": "Demonstrate PureComponent Performance Benefits",
          "description": "\nCreate a React application that clearly demonstrates the performance difference in re-rendering behavior between `React.Component` and `React.PureComponent`. The goal is to show how `PureComponent` prevents unnecessary re-renders when its props and state have not shallowly changed, even if its parent re-renders frequently.\n\n**Requirements:**\n1.  **`ParentComponent`:**\n    *   Create a class component named `ParentComponent`.\n    *   It should maintain an internal state (e.g., a simple counter `timer`).\n    *   Update this `timer` state every second using `setInterval` in `componentDidMount` and clear it in `componentWillUnmount`. This will cause the `ParentComponent` to re-render frequently.\n    *   Include a `console.log('ParentComponent Rendered')` in its `render` method.\n2.  **`RegularChild`:**\n    *   Create a class component named `RegularChild` that extends `React.Component`.\n    *   It should render a simple message (e.g., 'Regular Child Rendered').\n    *   Include a `console.log('RegularChild Rendered')` in its `render` method.\n    *   Crucially, `RegularChild` should receive *no props* (or only static, unchanging props) from `ParentComponent`.\n3.  **`PureChild`:**\n    *   Create a class component named `PureChild` that extends `React.PureComponent`.\n    *   It should render a simple message (e.g., 'Pure Child Rendered').\n    *   Include a `console.log('PureChild Rendered')` in its `render` method.\n    *   Like `RegularChild`, `PureChild` should receive *no props* (or only static, unchanging props) from `ParentComponent`.\n4.  **Integration:** Render both `RegularChild` and `PureChild` components within the `ParentComponent`'s render method.\n5.  **Observation:** Run the application and observe the console output. Explain the difference in `render` call frequency for `RegularChild` vs. `PureChild`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ParentComponent extends React.Component {\n  state = { timer: 0 };\n  intervalId = null;\n\n  componentDidMount() {\n    // TODO: Implement setInterval to update timer state every second\n  }\n\n  componentWillUnmount() {\n    // TODO: Clear interval to prevent memory leaks\n  }\n\n  render() {\n    console.log('ParentComponent Rendered');\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc' }}>\n        <h1>Parent Timer: {this.state.timer}</h1>\n        <p>Observe the console logs to see which components re-render.</p>\n        <hr/>\n        {/* TODO: Render RegularChild and PureChild here, ensuring they receive no dynamic props */}\n        {/* <RegularChild /> */}\n        {/* <PureChild /> */}\n      </div>\n    );\n  }\n}\n\nclass RegularChild extends React.Component {\n  render() {\n    console.log('RegularChild Rendered');\n    return <p style={{ color: 'red' }}>I am a regular child.</p>;\n  }\n}\n\nclass PureChild extends React.PureComponent {\n  render() {\n    console.log('PureChild Rendered');\n    return <p style={{ color: 'green' }}>I am a pure child.</p>;\n  }\n}\n\nexport default ParentComponent;\n",
          "solutionCode": "import React from 'react';\n\nclass ParentComponent extends React.Component {\n  state = { timer: 0 };\n  intervalId = null;\n\n  componentDidMount() {\n    this.intervalId = setInterval(() => {\n      this.setState(prevState => ({ timer: prevState.timer + 1 }));\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  render() {\n    console.log('ParentComponent Rendered. Timer:', this.state.timer);\n    return (\n      <div style={{ padding: '20px', border: '2px solid blue', margin: '20px' }}>\n        <h1>Parent Component (Updates Every Second)</h1>\n        <p>Parent Timer Value: {this.state.timer}</p>\n        <p>Observe the console logs for 'Rendered' messages from children.</p>\n        <hr/>\n        <RegularChild />\n        <hr/>\n        <PureChild />\n      </div>\n    );\n  }\n}\n\nclass RegularChild extends React.Component {\n  render() {\n    console.log('RegularChild Rendered');\n    return <p style={{ color: 'red', border: '1px dashed red', padding: '5px' }}>\n      I am a RegularChild. I re-render every time my parent does.\n    </p>;\n  }\n}\n\nclass PureChild extends React.PureComponent {\n  render() {\n    console.log('PureChild Rendered');\n    return <p style={{ color: 'green', border: '1px dashed green', padding: '5px' }}>\n      I am a PureChild. I only re-render if my own state or props shallowly change.\n    </p>;\n  }\n}\n\nexport default ParentComponent;\n",
          "testCases": [
            "Verify `ParentComponent`'s `render` method logs to the console every second, confirming its re-rendering.",
            "Verify `RegularChild`'s `render` method logs to the console every time `ParentComponent` re-renders, demonstrating its default behavior.",
            "Verify `PureChild`'s `render` method logs only on its initial mount, but *not* on subsequent `ParentComponent` re-renders (unless its own state changes or new props are passed), illustrating the `PureComponent` optimization.",
            "Confirm that the text content of both child components remains consistent, as their own states are not being updated and they receive no new props."
          ],
          "hints": [
            "Place `console.log` statements at the beginning of each component's `render` method. This is the most direct way to observe when a component re-renders.",
            "Ensure no props are passed to `RegularChild` and `PureChild` that change their reference, as this would cause `PureChild` to re-render.",
            "Remember to use `setInterval` in `componentDidMount` for the `ParentComponent` to trigger periodic updates, and `clearInterval` in `componentWillUnmount` for cleanup."
          ],
          "tags": [
            "React",
            "Performance",
            "PureComponent",
            "Class Components",
            "Lifecycle Methods",
            "Optimization"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "react_lifecycle_methods",
            "javascript_timers"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "shouldComponentUpdate",
            "memoization",
            "re-rendering",
            "reconciliation"
          ]
        },
        {
          "id": "task_styled_components_ui_elements",
          "title": "Build a Themed Button and Input using Styled Components",
          "description": "\nCreate a small React application that utilizes Styled Components to implement a custom `Button` and an `Input` field. These components should demonstrate both basic static styling and dynamic styling based on props and user interaction.\n\n**Requirements:**\n1.  **`Button` Component (Styled Component):**\n    *   **Default Styles:** `background-color: #007bff` (a shade of blue), `color: white`, `padding: 10px 15px`, `border-radius: 5px`, `border: none`, `cursor: pointer`.\n    *   **Variant Prop:** Accept a `variant` prop. If `variant` is `'secondary'`, the background should be `gray` and text `white`. Otherwise (default/primary), use the default blue.\n    *   **Hover Effect:** Add a subtle `box-shadow` (e.g., `0px 2px 5px rgba(0, 0, 0, 0.2)`) and slight `opacity` change on hover.\n2.  **`Input` Component (Styled Component):**\n    *   **Default Styles:** `border: 1px solid #ccc`, `padding: 8px`, `border-radius: 4px`.\n    *   **Focus Effect:** When the input is focused, the `border-color` should change to `darkblue` and remove the default outline.\n    *   **`fullWidth` Prop:** Accept a `fullWidth` prop (boolean). If `true`, the `width` should be `100%`. Ensure padding and border are included in the width calculation (`box-sizing: border-box`).\n3.  **`App` Component (Functional React Component):**\n    *   Import and render instances of both your `Button` and `Input` components.\n    *   Showcase the different variants/props for each:\n        *   A default `Button`.\n        *   A `Button` with `variant=\"primary\"`.\n        *   A `Button` with `variant=\"secondary\"`.\n        *   A regular `Input`.\n        *   A `Input` with `fullWidth` prop set to `true`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport styled from 'styled-components';\n\n// TODO: Define Button styled component here\nconst Button = styled.button`\n  /* Add default styles */\n  /* Implement variant prop logic */\n  /* Add hover effect */\n`;\n\n// TODO: Define Input styled component here\nconst Input = styled.input`\n  /* Add default styles */\n  /* Implement focus effect */\n  /* Implement fullWidth prop logic */\n`;\n\nfunction App() {\n  return (\n    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto', fontFamily: 'Arial, sans-serif' }}>\n      <h1>Styled UI Components</h1>\n\n      <h2>Buttons</h2>\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>\n        {/* TODO: Render different button variants */}\n        {/* <Button>Default Button</Button> */}\n        {/* <Button variant=\"primary\">Primary Button</Button> */}\n        {/* <Button variant=\"secondary\">Secondary Button</Button> */}\n      </div>\n\n      <h2>Inputs</h2>\n      <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n        {/* TODO: Render different input types */}\n        {/* <Input type=\"text\" placeholder=\"Enter text...\" /> */}\n        {/* <Input type=\"text\" placeholder=\"Full width input...\" fullWidth /> */}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  background-color: ${props => {\n    switch (props.variant) {\n      case 'primary': return '#007bff';\n      case 'secondary': return 'gray';\n      default: return '#007bff'; // Default to primary if no variant or unknown variant\n    }\n  }};\n  color: white;\n  padding: 10px 15px;\n  border-radius: 5px;\n  border: none;\n  cursor: pointer;\n  font-size: 1em;\n  transition: all 0.2s ease-in-out; /* Smooth transition for hover */\n\n  &:hover {\n    opacity: 0.9;\n    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);\n  }\n`;\n\nconst Input = styled.input`\n  border: 1px solid #ccc;\n  padding: 8px;\n  border-radius: 4px;\n  font-size: 1em;\n  transition: border-color 0.2s ease-in-out;\n\n  ${props => props.fullWidth && `\n    width: 100%;\n    box-sizing: border-box; /* Include padding and border in the element's total width */\n  `}\n\n  &:focus {\n    border-color: darkblue;\n    outline: none; /* Remove default browser outline */\n    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25); /* Subtle focus ring */\n  }\n`;\n\nfunction App() {\n  return (\n    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto', fontFamily: 'Arial, sans-serif' }}>\n      <h1>Styled UI Components</h1>\n\n      <h2>Buttons</h2>\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px', flexWrap: 'wrap' }}>\n        <Button>Default Button</Button>\n        <Button variant=\"primary\">Primary Button</Button>\n        <Button variant=\"secondary\">Secondary Button</Button>\n        <Button onClick={() => alert('Button Clicked!')}>Click Me!</Button>\n      </div>\n\n      <h2>Inputs</h2>\n      <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n        <Input type=\"text\" placeholder=\"Enter regular text...\" />\n        <Input type=\"email\" placeholder=\"Enter email address...\" />\n        <Input type=\"text\" placeholder=\"Enter full width text...\" fullWidth />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Verify `Button` component renders with default blue background and white text.",
            "Verify `Button` with `variant=\"secondary\"` renders with a gray background.",
            "Verify `Button` displays a `box-shadow` and slight `opacity` change when hovered over.",
            "Verify `Input` component renders with a `1px solid #ccc` border.",
            "Verify `Input`'s border color changes to `darkblue` when it receives focus.",
            "Verify `Input` with `fullWidth` prop has `width: 100%` and `box-sizing: border-box` applied (inspect element in browser dev tools)."
          ],
          "hints": [
            "For `Button` variants, use a conditional (ternary operator or `switch` statement) inside the template literal, checking `props.variant`.",
            "For hover/focus effects, use CSS pseudo-classes like `&:hover` and `&:focus` within your styled component's template literal.",
            "For the `Input`'s `fullWidth` prop, you can use a template literal interpolation (`${props => props.fullWidth && 'width: 100%;'}`) or a block of CSS string interpolation (`` ${props => props.fullWidth && `width: 100%; box-sizing: border-box;`} ``) for multi-line conditional styles."
          ],
          "tags": [
            "Styled Components",
            "UI Development",
            "Dynamic Styling",
            "CSS-in-JS",
            "Frontend",
            "Component Design"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_basics",
            "css_basics",
            "javascript_template_literals",
            "javascript_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "styled_components_props",
            "css_pseudo_classes",
            "component_composition",
            "theming_basics"
          ]
        }
      ]
    }
  },
  {
    "id": "51703075-3e77-4075-b54c-616e396df6bb",
    "startLine": 5500,
    "endLine": 5599,
    "processedDate": "2025-06-17T09:41:10.279Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_styled_components",
          "title": "Styled Components: CSS-in-JS for React",
          "content": "Styled Components is a popular CSS-in-JS library that allows you to write actual CSS code to style your React components. It leverages tagged template literals to embed CSS directly into your JavaScript, providing a more component-oriented approach to styling.\n\n## Key Concepts\n- **CSS-in-JS**: Write CSS directly within your JavaScript files, collocated with your component logic.\n- **Tagged Template Literals**: Styled Components use JavaScript's tagged template literals (`styled.div` `` `background: blue;` ``) to define styles. This allows for powerful features like prop-based styling and easy interpolation.\n- **Component-Based Styling**: Each styled component is a true React component with styles attached. This promotes modularity and reusability.\n- **Automatic Vendor Prefixing**: Styled Components automatically handles vendor prefixes for CSS properties.\n- **Unique Class Names**: It automatically generates unique class names for your styles, eliminating class name collisions and making debugging easier.\n\n## Core Usage\nTo create a styled component, you import `styled` from `'styled-components'` and then call it with an HTML tag or another React component as a method, followed by a template literal containing your CSS rules.\n\n```jsx\nimport styled from 'styled-components';\n\n// Create a styled div\nconst Wrapper = styled.div`\n  padding: 4em;\n  background: papayawhip;\n`;\n\n// Create a styled h1\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n`;\n\n// Use it like any other React component\nfunction App() {\n  return (\n    <Wrapper>\n      <Title>{'Lets start first styled component!'}</Title>\n    </Wrapper>\n  );\n}\n```\n\n## Advantages of Styled Components\n- **Component Libraries**: Facilitates building reusable component libraries with consistent styling.\n- **Dynamic Styles**: Easily implement styles that change based on component props or state.\n- **Avoid CSS Class Name Collisions**: Unique class names are generated automatically, preventing global styling conflicts.\n- **Removes Component-Style Mapping**: Styles are directly tied to components, simplifying maintenance and understanding.",
          "examples": [
            {
              "id": "example_styled_components_basic_1",
              "title": "Basic Styled Component Structure",
              "code": "import styled from 'styled-components';\n\nconst Wrapper = styled.div`\n  padding: 4em;\n  background: papayawhip;\n`;\n\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n`;\n\nfunction App() {\n  return (\n    <Wrapper>\n      <Title>{'Lets start first styled component!'}</Title>\n    </Wrapper>\n  );\n}",
              "explanation": "This example demonstrates the fundamental way to define and use styled components. `Wrapper` and `Title` are created using `styled.<element>`` `CSS rules` syntax and then used as regular React components in the `App` function.",
              "language": "typescript"
            },
            {
              "id": "example_styled_components_props_2",
              "title": "Dynamic Styles with Props",
              "code": "import styled from 'styled-components';\n\nconst Button = styled.button`\n  background: ${props => props.primary ? 'palevioletred' : 'white'};\n  color: ${props => props.primary ? 'white' : 'palevioletred'};\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n`;\n\nfunction MyComponent() {\n  return (\n    <>\n      <Button>Normal Button</Button>\n      <Button primary>Primary Button</Button>\n    </>\n  );\n}",
              "explanation": "This example shows how to make styles dynamic using props. The `background` and `color` of the `Button` component change based on whether the `primary` prop is `true`. Inside the template literal, you can access props as a function argument.",
              "language": "typescript"
            },
            {
              "id": "example_styled_components_extend_3",
              "title": "Extending Styles of Another Component",
              "code": "import styled from 'styled-components';\n\nconst Button = styled.button`\n  background: white;\n  color: palevioletred;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n`;\n\nconst TomatoButton = styled(Button)`\n  color: tomato;\n  border-color: tomato;\n  /* Additional styles specific to TomatoButton */\n  box-shadow: 0 0 5px rgba(255, 99, 71, 0.5);\n`;\n\nfunction MyOtherComponent() {\n  return (\n    <>\n      <Button>Original Button</Button>\n      <TomatoButton>Tomato Button</TomatoButton>\n    </>\n  );\n}",
              "explanation": "This demonstrates style inheritance. `TomatoButton` reuses all styles from the `Button` component and then overrides or adds new styles. This is achieved by passing the `Button` component itself to `styled()`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_styled_components_mcq_1",
            "question_styled_components_mcq_2",
            "question_styled_components_open_1",
            "question_styled_components_code_1",
            "question_styled_components_flashcard_1",
            "question_styled_components_mcq_3",
            "question_styled_components_open_2",
            "question_styled_components_flashcard_2"
          ],
          "relatedTasks": [
            "task_styled_components_dynamic_button",
            "task_styled_components_responsive_card"
          ],
          "tags": [
            "React",
            "CSS-in-JS",
            "Styling",
            "Frontend",
            "Styled Components"
          ],
          "technology": "React, TypeScript",
          "prerequisites": [
            "React Basics",
            "JavaScript ES6 Template Literals",
            "CSS Fundamentals"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Component Library Development",
            "Theming in React"
          ]
        },
        {
          "id": "theory_custom_hooks",
          "title": "React Custom Hooks: Reusable Logic",
          "content": "Custom Hooks are a powerful feature in React that allow you to extract reusable stateful logic from your components. They are JavaScript functions whose names start with the word `use` and can call other built-in React Hooks (like `useState`, `useEffect`, `useContext`, etc.). Custom Hooks enable you to share logic without sharing UI, adhering to the principle of separation of concerns.\n\n## Purpose of Custom Hooks\n- **Logic Reusability**: Extract complex logic (e.g., form handling, data fetching, state management for specific features) into a single function that can be used across multiple components.\n- **Improved Readability**: Components become cleaner and more focused on rendering, as logic is encapsulated elsewhere.\n- **Testability**: Logic encapsulated in a custom hook is often easier to test independently.\n- **Separation of Concerns**: Helps to separate UI logic from business logic.\n\n## Building Custom Hooks\nA custom hook is essentially a function that leverages one or more standard React Hooks to provide some piece of reusable functionality. It must always start with the `use` prefix, which is a convention that allows React to enforce rules of Hooks (e.g., calling Hooks only at the top level of a component or custom hook).\n\n```typescript\nimport { useState, useEffect } from 'react';\n\n// Custom hook for managing form input\nfunction useInput(initialValue: string) {\n  const [value, setValue] = useState(initialValue);\n  \n  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    setValue(e.target.value);\n  };\n  \n  const reset = () => {\n    setValue(initialValue);\n  };\n  \n  return [value, handleChange, reset] as const; // 'as const' provides tuple inference\n}\n\n// Usage in a component\nfunction LoginForm() {\n  const [username, handleUsernameChange, resetUsername] = useInput('');\n  const [password, handlePasswordChange, resetPassword] = useInput('');\n  \n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    console.log('Submitted:', username, password);\n    resetUsername();\n    resetPassword();\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Username:</label>\n        <input type=\"text\" value={username} onChange={handleUsernameChange} />\n      </div>\n      <div>\n        <label>Password:</label>\n        <input type=\"password\" value={password} onChange={handlePasswordChange} />\n      </div>\n      <button type=\"submit\">Login</button>\n      <button type=\"button\" onClick={() => { resetUsername(); resetPassword(); }}>Reset</button>\n    </form>\n  );\n}\n```\n\nIn the `useInput` example, it encapsulates the state (`value`), a change handler (`handleChange`), and a reset function (`reset`) for an input field. This allows any component to use `useInput` to easily manage its input fields without duplicating the `useState` and `handleChange` logic.",
          "examples": [
            {
              "id": "example_custom_hooks_use_input_1",
              "title": "Basic useInput Custom Hook",
              "code": "import { useState } from 'react';\n\nfunction useInput(initialValue: string) {\n  const [value, setValue] = useState(initialValue);\n  \n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setValue(e.target.value);\n  };\n  \n  const reset = () => {\n    setValue(initialValue);\n  };\n  \n  return [value, handleChange, reset] as const;\n}",
              "explanation": "This is the definition of the `useInput` custom hook. It takes an `initialValue`, uses `useState` internally to manage the input's state, and returns the current `value`, a `handleChange` function for input events, and a `reset` function to restore the initial state. The `as const` ensures TypeScript infers a tuple type.",
              "language": "typescript"
            },
            {
              "id": "example_custom_hooks_login_form_2",
              "title": "LoginForm Component Using useInput",
              "code": "import React, { useState } from 'react';\n\n// Assume useInput is defined as above\nfunction useInput(initialValue: string) {\n    const [value, setValue] = useState(initialValue);\n    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => setValue(e.target.value);\n    const reset = () => setValue(initialValue);\n    return [value, handleChange, reset] as const;\n}\n\nfunction LoginForm() {\n  const [username, handleUsernameChange, resetUsername] = useInput('');\n  const [password, handlePasswordChange, resetPassword] = useInput('');\n  \n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    console.log('Submitted:', { username, password });\n    resetUsername();\n    resetPassword();\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Username:</label>\n        <input type=\"text\" value={username} onChange={handleUsernameChange} />\n      </div>\n      <div>\n        <label>Password:</label>\n        <input type=\"password\" value={password} onChange={handlePasswordChange} />\n      </div>\n      <button type=\"submit\">Login</button>\n      <button type=\"button\" onClick={() => { resetUsername(); resetPassword(); }}>Reset</button>\n    </form>\n  );\n}",
              "explanation": "This component demonstrates how `useInput` simplifies form handling. Instead of multiple `useState` calls and `onChange` handlers, each input uses `useInput` for its state management. The `handleSubmit` function logs the values and then resets the inputs using the returned `reset` functions.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_custom_hooks_mcq_1",
            "question_custom_hooks_open_1",
            "question_custom_hooks_code_1",
            "question_custom_hooks_flashcard_1",
            "question_custom_hooks_mcq_2",
            "question_custom_hooks_mcq_3"
          ],
          "relatedTasks": [
            "task_custom_hooks_use_local_storage",
            "task_custom_hooks_use_debounce"
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "State Management",
            "Logic Reusability",
            "Frontend"
          ],
          "technology": "React, TypeScript",
          "prerequisites": [
            "React Hooks (useState, useEffect)",
            "JavaScript Functions"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced React Development",
            "Building Reusable Utilities"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_styled_components_mcq_1",
          "topic": "Styled Components Basics",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following best describes Styled Components?",
          "answer": "A CSS-in-JS library for styling React components.",
          "options": [
            "A JavaScript framework for building user interfaces.",
            "A CSS preprocessor like Sass or Less.",
            "A CSS-in-JS library for styling React components.",
            "A state management library for React applications."
          ],
          "analysisPoints": [
            "Identifies Styled Components as a styling solution.",
            "Distinguishes it from frameworks, preprocessors, or state management libraries.",
            "Highlights its primary use case in React."
          ],
          "keyConcepts": [
            "Styled Components",
            "CSS-in-JS",
            "React Component Styling"
          ],
          "evaluationCriteria": [
            "Basic understanding of Styled Components' purpose."
          ],
          "example": "Styled Components allows embedding actual CSS within JavaScript using tagged template literals, like `const MyDiv = styled.div`` `color: blue;` ``.",
          "tags": [
            "Styled Components",
            "CSS-in-JS",
            "Basics"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_styled_components_mcq_2",
          "topic": "Dynamic Styling with Props",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Styled Components code:\n\n```jsx\nimport styled from 'styled-components';\n\nconst StyledDiv = styled.div`\n  background-color: ${props => props.isActive ? 'blue' : 'gray'};\n  padding: 10px;\n`;\n\nfunction App() {\n  return (\n    <>\n      <StyledDiv isActive={true}>Active State</StyledDiv>\n      <StyledDiv isActive={false}>Inactive State</StyledDiv>\n    </>\n  );\n}\n```\n\nWhat will be the background color of the `StyledDiv` with the text \"Inactive State\"?",
          "answer": "gray",
          "options": [
            "blue",
            "gray",
            "transparent",
            "An error will occur"
          ],
          "analysisPoints": [
            "Tests understanding of prop access within styled component CSS.",
            "Evaluates the conditional rendering of styles based on prop values.",
            "Confirms knowledge of template literal interpolation in Styled Components."
          ],
          "keyConcepts": [
            "Styled Components Props",
            "Dynamic Styling",
            "Tagged Template Literals"
          ],
          "evaluationCriteria": [
            "Ability to interpret Styled Components syntax.",
            "Understanding of conditional styling."
          ],
          "example": "The `isActive` prop is passed to the `StyledDiv` component. Inside the styled component's template literal, `props.isActive` is accessed. For the \"Inactive State\" div, `isActive` is `false`, so the expression `props.isActive ? 'blue' : 'gray'` evaluates to `'gray'`.",
          "tags": [
            "Styled Components",
            "Props",
            "Dynamic Styling",
            "Conditional Styling"
          ],
          "prerequisites": [
            "Styled Components Basics",
            "JavaScript Ternary Operator"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_styled_components_open_1",
          "topic": "Benefits of Styled Components",
          "level": "medium",
          "type": "open",
          "question": "Discuss at least three significant benefits of using Styled Components in a React application compared to traditional CSS approaches (e.g., BEM, global stylesheets).",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Ability to articulate the advantages of CSS-in-JS.",
            "Understanding of how Styled Components addresses common CSS challenges.",
            "Mention of specific benefits like avoiding class name collisions, dynamic styling, and component-style co-location.",
            "Comparison with traditional CSS methodologies."
          ],
          "keyConcepts": [
            "Styled Components Benefits",
            "CSS-in-JS vs Traditional CSS",
            "Class Name Collisions",
            "Dynamic Styling",
            "Component-Level Styling"
          ],
          "evaluationCriteria": [
            "Depth of understanding of Styled Components' value proposition.",
            "Clarity and comprehensiveness of the explanation.",
            "Ability to compare and contrast different styling methodologies."
          ],
          "example": "Possible benefits include: \n1.  **Elimination of Class Name Collisions**: Styled Components automatically generates unique class names, solving the problem of global CSS conflicts and the need for complex naming conventions like BEM.\n2.  **Dynamic Styling Based on Props**: Styles can be dynamically changed based on component props or state, making it very powerful for building interactive UIs without complex JavaScript manipulations of CSS classes.\n3.  **Co-location of Styles and Logic**: Styles are defined directly within the component file, making it easier to understand, maintain, and refactor components as all related code (markup, logic, styles) is in one place.\n4.  **Easier Theming**: Context API can be easily integrated to manage application-wide themes.",
          "tags": [
            "Styled Components",
            "Benefits",
            "CSS Architecture",
            "Interview Question"
          ],
          "prerequisites": [
            "Styled Components",
            "CSS Fundamentals"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_styled_components_code_1",
          "topic": "Extending Styled Components",
          "level": "medium",
          "type": "code",
          "question": "Using Styled Components, create a base `Button` component and then extend it to create a `WarningButton` that changes the background to `orange` and text color to `white`, while retaining all other styles from the base `Button`.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly uses `styled(Component)` syntax for extending styles.",
            "Applies new styles that override/add to the base styles.",
            "Demonstrates understanding of reusability in Styled Components.",
            "Valid React component usage."
          ],
          "keyConcepts": [
            "Styled Components Extension",
            "Style Inheritance",
            "Component Reusability"
          ],
          "evaluationCriteria": [
            "Correct implementation of style extension.",
            "Syntactical correctness.",
            "Clarity and conciseness of code."
          ],
          "example": "```jsx\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  background: palevioletred;\n  color: white;\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n  cursor: pointer;\n`;\n\nconst WarningButton = styled(Button)`\n  background: orange;\n  color: white;\n  border-color: orange;\n`;\n\nfunction App() {\n  return (\n    <>\n      <Button>Regular Action</Button>\n      <WarningButton>Warning Action</WarningButton>\n    </>\n  );\n}\n```",
          "tags": [
            "Styled Components",
            "Code Challenge",
            "Extension",
            "Reusability"
          ],
          "prerequisites": [
            "Styled Components Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_styled_components_flashcard_1",
          "topic": "Styled Components Tagged Template Literals",
          "level": "easy",
          "type": "flashcard",
          "question": "What JavaScript feature does Styled Components heavily rely on for defining styles?",
          "answer": "Tagged Template Literals",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Tagged Template Literals",
            "Styled Components Syntax"
          ],
          "evaluationCriteria": [],
          "example": "Example: `styled.div`` `color: blue;` ``. The backticks (` `` `) define a template literal, and `styled.div` acts as the 'tag' function.",
          "tags": [
            "Styled Components",
            "Flashcard",
            "JavaScript",
            "Syntax"
          ],
          "prerequisites": [
            "JavaScript ES6"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_styled_components_mcq_3",
          "topic": "Styled Components and Performance",
          "level": "medium",
          "type": "mcq",
          "question": "Which statement about Styled Components and performance is generally TRUE?",
          "answer": "Styled Components generate unique class names at runtime, which helps prevent style collisions.",
          "options": [
            "Styled Components always result in larger bundle sizes than traditional CSS.",
            "Styled Components offer server-side rendering (SSR) support out of the box for better initial load performance.",
            "Styled Components require manual management of CSS class names to avoid collisions.",
            "Styled Components generate unique class names at runtime, which helps prevent style collisions."
          ],
          "analysisPoints": [
            "Tests knowledge of how Styled Components handle class names.",
            "Addresses common misconceptions about bundle size and performance.",
            "Checks understanding of SSR capabilities."
          ],
          "keyConcepts": [
            "Styled Components Performance",
            "Class Name Generation",
            "SSR",
            "Bundle Size"
          ],
          "evaluationCriteria": [
            "Accurate understanding of Styled Components' underlying mechanisms.",
            "Ability to discern true from false statements regarding its performance characteristics."
          ],
          "example": "Styled Components automatically generate unique class names for each styled component instance (e.g., `sc-bdfBwQ gBszFh`). This avoids the issues of global CSS and manual class name management, ensuring styles are isolated and conflict-free. While bundle size can be a consideration, it's often outweighed by developer experience and maintainability benefits, and SSR support is indeed available.",
          "tags": [
            "Styled Components",
            "Performance",
            "Interview Question"
          ],
          "prerequisites": [
            "Styled Components Basics",
            "Web Performance Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_styled_components_open_2",
          "topic": "Styled Components Theming",
          "level": "hard",
          "type": "open",
          "question": "How can you implement a global theme (e.g., dark/light mode, brand colors) across multiple Styled Components using the `ThemeProvider`? Provide a conceptual example.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Mentions `ThemeProvider` and its role.",
            "Explains how to define and pass a theme object.",
            "Describes how styled components access theme properties via props.",
            "Demonstrates understanding of context in React for global state."
          ],
          "keyConcepts": [
            "Styled Components Theming",
            "ThemeProvider",
            "React Context",
            "Global Styles"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of the theming mechanism.",
            "Clear conceptual example.",
            "Understanding of the `ThemeProvider` and prop access."
          ],
          "example": "```jsx\nimport styled, { ThemeProvider } from 'styled-components';\n\n// 1. Define your themes\nconst lightTheme = {\n  primary: 'palevioletred',\n  secondary: 'white',\n  text: 'black',\n};\n\nconst darkTheme = {\n  primary: 'darkblue',\n  secondary: 'darkgray',\n  text: 'white',\n};\n\n// 2. Create styled components that use theme props\nconst Container = styled.div`\n  background: ${props => props.theme.secondary};\n  color: ${props => props.theme.text};\n  padding: 20px;\n  text-align: center;\n`;\n\nconst Button = styled.button`\n  background: ${props => props.theme.primary};\n  color: white;\n  padding: 10px 20px;\n  border: none;\n  border-radius: 5px;\n  cursor: pointer;\n`;\n\n// 3. Wrap your application or components with ThemeProvider\nfunction App() {\n  const [currentTheme, setCurrentTheme] = useState(lightTheme);\n\n  const toggleTheme = () => {\n    setCurrentTheme(prev => prev === lightTheme ? darkTheme : lightTheme);\n  };\n\n  return (\n    <ThemeProvider theme={currentTheme}>\n      <Container>\n        <h1>Current Theme: {currentTheme === lightTheme ? 'Light' : 'Dark'}</h1>\n        <Button onClick={toggleTheme}>Toggle Theme</Button>\n      </Container>\n    </ThemeProvider>\n  );\n}\n```\n\n`ThemeProvider` provides the `theme` object to all styled components within its tree via React Context. Styled components can then access these theme properties through their `props.theme` object, allowing for centralized theme management and dynamic theme switching.",
          "tags": [
            "Styled Components",
            "Theming",
            "ThemeProvider",
            "React Context"
          ],
          "prerequisites": [
            "Styled Components Basics",
            "React Context API"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_styled_components_flashcard_2",
          "topic": "Styled Components `styled()` function",
          "level": "medium",
          "type": "flashcard",
          "question": "How do you extend the styles of an existing Styled Component to create a new one, as shown in the provided example?",
          "answer": "By passing the existing Styled Component as an argument to the `styled()` function, e.g., `const NewComponent = styled(ExistingComponent)`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Styled Components Extension",
            "Style Inheritance"
          ],
          "evaluationCriteria": [],
          "example": "```jsx\nconst Button = styled.button` /* ... */ `;\nconst TomatoButton = styled(Button)`\n  color: tomato;\n  border-color: tomato;\n`;\n```",
          "tags": [
            "Styled Components",
            "Flashcard",
            "Extension",
            "Inheritance"
          ],
          "prerequisites": [
            "Styled Components Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_mcq_1",
          "topic": "Custom Hooks Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of a React Custom Hook?",
          "answer": "To extract and reuse stateful logic across multiple components.",
          "options": [
            "To manage global application state like Redux.",
            "To perform side effects outside of component rendering.",
            "To replace traditional component lifecycle methods.",
            "To extract and reuse stateful logic across multiple components."
          ],
          "analysisPoints": [
            "Correctly identifies the core functionality of custom hooks.",
            "Distinguishes custom hooks from state management, direct side effects (though they enable them), or full lifecycle replacement."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Logic Reusability",
            "Stateful Logic"
          ],
          "evaluationCriteria": [
            "Basic understanding of custom hooks' role."
          ],
          "example": "A `useInput` hook encapsulates `useState` and `handleChange` logic, allowing multiple input fields to reuse this behavior without duplicating code.",
          "tags": [
            "React Hooks",
            "Custom Hooks",
            "Basics"
          ],
          "prerequisites": [
            "React Hooks (useState)"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_custom_hooks_open_1",
          "topic": "Custom Hooks Benefits and Convention",
          "level": "medium",
          "type": "open",
          "question": "Explain the advantages of using custom hooks in React development. What is the crucial naming convention for custom hooks and why is it important?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Articulates benefits like reusability, separation of concerns, and readability.",
            "States the `use` prefix naming convention.",
            "Explains that the `use` prefix enables React to apply 'Rules of Hooks' and recognize them as hooks."
          ],
          "keyConcepts": [
            "Custom Hooks Benefits",
            "Naming Conventions",
            "Rules of Hooks",
            "Logic Reusability"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of custom hooks' advantages.",
            "Knowledge of the naming convention and its underlying reason.",
            "Clarity and precision in explanation."
          ],
          "example": "Advantages include:\n1.  **Reusability**: Encapsulate complex logic (e.g., form validation, data fetching) into a single function that can be easily shared and reused across different components without prop drilling or render props.\n2.  **Separation of Concerns**: Helps to separate UI logic from business logic, making components cleaner and more focused on rendering.\n3.  **Readability and Maintainability**: Components become less cluttered, and the logic is easier to understand and test in isolation.\n\nThe crucial naming convention is that a custom hook **must start with the prefix `use`** (e.g., `useInput`, `useFetchData`). This convention is vital because it allows React's linter plugin to identify them as hooks and enforce the 'Rules of Hooks', such as calling hooks only at the top level of a function component or another custom hook, and not from regular JavaScript functions, loops, or conditional statements. This ensures the predictable behavior of hooks.",
          "tags": [
            "React Hooks",
            "Custom Hooks",
            "Benefits",
            "Rules of Hooks",
            "Interview Question"
          ],
          "prerequisites": [
            "React Hooks (useState, useEffect)"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_code_1",
          "topic": "Implementing a Custom Hook",
          "level": "medium",
          "type": "code",
          "question": "Implement a custom hook named `useToggle` that manages a boolean state. It should return the current boolean value and a function to toggle it. Demonstrate its usage in a simple functional component.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly uses `useState` inside the custom hook.",
            "Returns the state and a setter/toggle function.",
            "Adheres to the `use` naming convention.",
            "Demonstrates proper usage within a component.",
            "Code is clean and functional."
          ],
          "keyConcepts": [
            "Custom Hooks Implementation",
            "useState",
            "Boolean State Management",
            "Hook Design"
          ],
          "evaluationCriteria": [
            "Correct and efficient implementation.",
            "Adherence to React Hook best practices.",
            "Clear demonstration of usage."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\n// Custom hook: useToggle\nfunction useToggle(initialValue: boolean = false) {\n  const [value, setValue] = useState(initialValue);\n  \n  const toggle = () => {\n    setValue(currentValue => !currentValue);\n  };\n  \n  return [value, toggle] as const;\n}\n\n// Component using useToggle\nfunction LightSwitch() {\n  const [isOn, toggle] = useToggle(false);\n  \n  return (\n    <div>\n      <p>The light is: {isOn ? 'ON' : 'OFF'}</p>\n      <button onClick={toggle}>Toggle Light</button>\n    </div>\n  );\n}\n\n// Example App usage\nfunction App() {\n    return <LightSwitch />;\n}\n```",
          "tags": [
            "React Hooks",
            "Custom Hooks",
            "Code Challenge",
            "useState"
          ],
          "prerequisites": [
            "React Hooks (useState)"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_flashcard_1",
          "topic": "Custom Hooks Naming Convention",
          "level": "easy",
          "type": "flashcard",
          "question": "What prefix must all custom React Hooks start with?",
          "answer": "`use`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Custom Hooks",
            "Naming Convention",
            "Rules of Hooks"
          ],
          "evaluationCriteria": [],
          "example": "Examples: `useInput`, `useFetch`, `useLocalStorage`.",
          "tags": [
            "React Hooks",
            "Flashcard",
            "Naming Convention"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_custom_hooks_mcq_2",
          "topic": "Custom Hooks vs. Higher-Order Components (HOCs)",
          "level": "hard",
          "type": "mcq",
          "question": "Which of the following is a key advantage of Custom Hooks over Higher-Order Components (HOCs) for code reuse in React?",
          "answer": "Custom Hooks avoid wrapper hell and provide better composition for non-visual logic.",
          "options": [
            "HOCs are simpler to implement for sharing stateful logic.",
            "Custom Hooks always lead to smaller bundle sizes.",
            "Custom Hooks avoid wrapper hell and provide better composition for non-visual logic.",
            "HOCs allow direct manipulation of the rendered JSX tree, which hooks do not."
          ],
          "analysisPoints": [
            "Highlights a primary benefit of hooks over HOCs (wrapper hell).",
            "Focuses on logic reuse rather than visual rendering.",
            "Correctly identifies that HOCs often introduce extra nested components."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Higher-Order Components (HOCs)",
            "Code Reusability",
            "Composition",
            "Wrapper Hell"
          ],
          "evaluationCriteria": [
            "Deep understanding of different React code reuse patterns.",
            "Ability to compare and contrast HOCs and Hooks effectively.",
            "Recognition of common HOC drawbacks."
          ],
          "example": "HOCs wrap components, leading to deeply nested component trees in React DevTools ('wrapper hell'). Custom Hooks, on the other hand, abstract away logic *inside* functional components, resulting in a flatter component tree and more straightforward composition of different functionalities without introducing additional layers of components.",
          "tags": [
            "React Hooks",
            "HOCs",
            "Comparison",
            "Advanced"
          ],
          "prerequisites": [
            "React Hooks",
            "Higher-Order Components"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_custom_hooks_mcq_3",
          "topic": "Rules of Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about React's 'Rules of Hooks' is TRUE?",
          "answer": "Hooks must be called at the top level of a React function component or another custom Hook.",
          "options": [
            "Hooks can be called inside loops, conditions, or nested functions.",
            "Hooks can only be used with class components.",
            "Hooks must be called at the top level of a React function component or another custom Hook.",
            "Hooks do not require any specific naming convention."
          ],
          "analysisPoints": [
            "Tests knowledge of where hooks can be called.",
            "Reinforces that hooks are for functional components.",
            "Checks understanding of the naming convention requirement."
          ],
          "keyConcepts": [
            "Rules of Hooks",
            "Conditional Hooks",
            "Functional Components",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Accurate understanding of fundamental Hook rules.",
            "Ability to identify incorrect usage patterns."
          ],
          "example": "The 'Rules of Hooks' state that Hooks must only be called at the top level of your React function components or custom Hooks. You cannot call Hooks inside loops, conditions, or nested functions. This ensures that Hooks are called in the same order each time a component renders, which is crucial for React to correctly associate state with calls to `useState` and effects with `useEffect`.",
          "tags": [
            "React Hooks",
            "Rules of Hooks",
            "Fundamentals"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_styled_components_dynamic_button",
          "title": "Create a Themed & Dynamic Button Component with Styled Components",
          "description": "\nImplement a `Button` component using Styled Components that supports two main features:\n\n1.  **Theming**: It should accept a `variant` prop (`'primary'`, `'secondary'`, `'danger'`) and apply different background and text colors based on the variant.\n2.  **Size**: It should accept a `size` prop (`'small'`, `'medium'`, `'large'`) and adjust padding and font size accordingly.\n\n### Requirements:\n-   Use `styled-components` for all styling.\n-   Define default styles for the button.\n-   Implement conditional styling based on the `variant` prop (`primary`: blue, white text; `secondary`: gray, black text; `danger`: red, white text).\n-   Implement size adjustments based on the `size` prop (`small`: 0.5em padding, 0.8em font; `medium`: 1em padding, 1em font; `large`: 1.5em padding, 1.2em font).\n-   Provide a default variant (e.g., 'primary') and size (e.g., 'medium') if not specified.\n-   The button should have a `border-radius`, `cursor: pointer`, and `margin`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  /* Add default styles here */\n  border: none;\n  border-radius: 5px;\n  cursor: pointer;\n  margin: 0.5em;\n\n  /* Implement variant-based styling here */\n  /* Example: background-color: ${props => props.variant === 'primary' ? 'blue' : 'grey'}; */\n\n  /* Implement size-based styling here */\n  /* Example: padding: ${props => props.size === 'small' ? '0.5em 1em' : '1em 2em'}; */\n`;\n\nfunction App() {\n  return (\n    <div>\n      <Button variant=\"primary\" size=\"medium\">Primary Button</Button>\n      <Button variant=\"secondary\" size=\"small\">Secondary Small</Button>\n      <Button variant=\"danger\" size=\"large\">Danger Large</Button>\n      <Button>Default Button</Button> {/* Should use default variant/size */}\n    </div>\n  );\n}\n\n// export default App; // For testing if needed\n",
          "solutionCode": "import React from 'react';\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  background-color: #f0f0f0; /* Default background */\n  color: #333; /* Default text color */\n  border: none;\n  border-radius: 5px;\n  cursor: pointer;\n  margin: 0.5em;\n  transition: all 0.3s ease;\n\n  /* Default size */\n  padding: 1em 2em;\n  font-size: 1em;\n\n  ${props => {\n    switch (props.variant) {\n      case 'primary':\n        return `\n          background-color: #007bff;\n          color: white;\n          &:hover { background-color: #0056b3; }\n        `;\n      case 'secondary':\n        return `\n          background-color: #6c757d;\n          color: white;\n          &:hover { background-color: #5a6268; }\n        `;\n      case 'danger':\n        return `\n          background-color: #dc3545;\n          color: white;\n          &:hover { background-color: #c82333; }\n        `;\n      default:\n        return `\n          background-color: #f0f0f0;\n          color: #333;\n          &:hover { background-color: #e2e6ea; }\n        `;\n    }\n  }}\n\n  ${props => {\n    switch (props.size) {\n      case 'small':\n        return `\n          padding: 0.5em 1em;\n          font-size: 0.8em;\n        `;\n      case 'medium':\n        return `\n          padding: 1em 2em;\n          font-size: 1em;\n        `;\n      case 'large':\n        return `\n          padding: 1.5em 3em;\n          font-size: 1.2em;\n        `;\n      default:\n        return `\n          padding: 1em 2em;\n          font-size: 1em;\n        `;\n    }\n  }}\n`;\n\nfunction App() {\n  return (\n    <div>\n      <Button variant=\"primary\" size=\"medium\">Primary Button</Button>\n      <Button variant=\"secondary\" size=\"small\">Secondary Small</Button>\n      <Button variant=\"danger\" size=\"large\">Danger Large</Button>\n      <Button>Default Button</Button> {/* Uses default variant/size */}\n      <Button variant=\"primary\">Primary Default Size</Button>\n      <Button size=\"large\">Default Variant Large</Button>\n    </div>\n  );\n}\n\n// export default App;\n",
          "testCases": [
            "Button with `variant=\"primary\"` should have blue background.",
            "Button with `variant=\"danger\"` should have red background.",
            "Button with `size=\"small\"` should have smaller padding/font size.",
            "Button with `size=\"large\"` should have larger padding/font size.",
            "Button without `variant` or `size` props should apply default styles.",
            "Button should combine variant and size styles correctly (e.g., `primary` `small`)."
          ],
          "hints": [
            "You can use template literal functions to access props within your CSS. `background-color: ${props => props.myProp ? 'value1' : 'value2'};`",
            "Consider using a `switch` statement or a lookup object within the template literal function for managing multiple variant/size options.",
            "Remember to set default values for props if they are not provided, either through JavaScript defaults or within your styled component logic."
          ],
          "tags": [
            "Styled Components",
            "Dynamic Styling",
            "Props",
            "Theming",
            "Frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Styled Components Basics",
            "JavaScript ES6 Template Literals"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_styled_components"
          ]
        },
        {
          "id": "task_styled_components_responsive_card",
          "title": "Implement a Responsive Card Component with Styled Components",
          "description": "\nCreate a responsive `Card` component using Styled Components. The card should display a title and some content.\n\n### Requirements:\n-   **Base Styles**: A basic card with `background-color`, `padding`, `border-radius`, and `box-shadow`.\n-   **Responsiveness**: The card's width should be `90%` of its parent on small screens (max-width: 768px) and `300px` fixed width on larger screens.\n-   **Centering**: The card should be horizontally centered on the page.\n-   **Internal Layout**: Use flexbox or grid for arranging title and content within the card.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport styled from 'styled-components';\n\nconst Card = styled.div`\n  /* Add base styles here */\n  background-color: #fff;\n  padding: 20px;\n  border-radius: 8px;\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n\n  /* Implement responsiveness here */\n  /* @media (max-width: 768px) { ... } */\n`;\n\nconst CardTitle = styled.h2`\n  /* Add title styles */\n`;\n\nconst CardContent = styled.p`\n  /* Add content styles */\n`;\n\nfunction App() {\n  return (\n    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '100vh', backgroundColor: '#f0f2f5' }}>\n      <Card>\n        <CardTitle>Welcome to My Card</CardTitle>\n        <CardContent>This is some content inside a responsive card. It should adapt its width based on screen size.</CardContent>\n      </Card>\n    </div>\n  );\n}\n\n// export default App; // For testing if needed\n",
          "solutionCode": "import React from 'react';\nimport styled from 'styled-components';\n\nconst Card = styled.div`\n  background-color: #fff;\n  padding: 20px;\n  border-radius: 8px;\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n  margin: 20px auto; /* Centering with margin auto for block elements */\n  \n  /* Default for larger screens */\n  width: 300px;\n\n  /* Responsive styles for smaller screens */\n  @media (max-width: 768px) {\n    width: 90%;\n  }\n`;\n\nconst CardTitle = styled.h2`\n  color: #333;\n  margin-top: 0;\n  margin-bottom: 10px;\n  font-size: 1.5em;\n`;\n\nconst CardContent = styled.p`\n  color: #666;\n  line-height: 1.6;\n`;\n\nfunction App() {\n  return (\n    <div style={{ minHeight: '100vh', backgroundColor: '#f0f2f5', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>\n      <Card>\n        <CardTitle>Welcome to My Responsive Card</CardTitle>\n        <CardContent>This is some content inside a responsive card. It should adapt its width based on screen size. On smaller screens, it will take 90% width, and on larger screens, it will be fixed at 300px. This demonstrates media queries with Styled Components.</CardContent>\n      </Card>\n    </div>\n  );\n}\n\n// export default App;\n",
          "testCases": [
            "Card should have specified `background-color`, `padding`, `border-radius`, and `box-shadow`.",
            "On screens larger than 768px, the card's width should be exactly `300px`.",
            "On screens 768px or smaller, the card's width should be `90%`.",
            "The card should be horizontally centered on the page.",
            "Title and content should render correctly within the card."
          ],
          "hints": [
            "Use CSS `media` queries directly inside your styled component's template literal for responsiveness.",
            "For horizontal centering of a block element, `margin: 0 auto;` is a common technique.",
            "Styled Components supports all standard CSS properties and features, including flexbox, grid, and media queries."
          ],
          "tags": [
            "Styled Components",
            "Responsiveness",
            "Media Queries",
            "Layout",
            "Frontend"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Styled Components Basics",
            "CSS Media Queries",
            "CSS Box Model"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_styled_components"
          ]
        },
        {
          "id": "task_custom_hooks_use_local_storage",
          "title": "Implement a `useLocalStorage` Custom Hook",
          "description": "\nCreate a custom React Hook named `useLocalStorage` that allows components to persist state in the browser's `localStorage`. This hook should behave similarly to `useState` but with automatic storage and retrieval.\n\n### Requirements:\n1.  **Signature**: The hook should accept a `key` (string) and an `initialValue` (any type) as arguments.\n2.  **State Management**: It should return the current `value` and a `setValue` function, just like `useState`.\n3.  **Persistence**: The `value` should be loaded from `localStorage` on initial render. If no value is found, the `initialValue` should be used.\n4.  **Update `localStorage`**: Whenever the `value` changes (via `setValue`), it should automatically update the corresponding entry in `localStorage`.\n5.  **Error Handling**: Gracefully handle cases where `localStorage` might not be available (e.g., in some browser environments or if it's restricted).\n6.  **Serialization**: Ensure values are correctly serialized to JSON before saving and parsed from JSON when loading.\n\n**Note**: Due to `localStorage` being a browser API, this hook is typically meant for client-side environments.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction useLocalStorage(key, initialValue) {\n  // TODO: Implement the logic for useLocalStorage\n  // 1. Get stored value from localStorage on initial render\n  // 2. If no value, use initialValue\n  // 3. Update localStorage whenever value changes\n  // 4. Handle JSON serialization/deserialization\n  // 5. Handle potential localStorage errors\n\n  return [initialValue, () => {}]; // Placeholder\n}\n\n// --- Example Usage (for testing) ---\nfunction Counter() {\n  const [count, setCount] = useLocalStorage('my-counter', 0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>\n      <button onClick={() => setCount(0)}>Reset</button>\n    </div>\n  );\n}\n\nfunction UserSettings() {\n  const [name, setName] = useLocalStorage('user-name', 'Guest');\n  const [email, setEmail] = useLocalStorage('user-email', '');\n\n  return (\n    <div>\n      <label>\n        Name:\n        <input type=\"text\" value={name} onChange={(e) => setName(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Email:\n        <input type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} />\n      </label>\n      <p>Hello, {name}!</p>\n    </div>\n  );\n}\n\n// function App() {\n//   return (\n//     <div>\n//       <Counter />\n//       <hr />\n//       <UserSettings />\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction useLocalStorage<T>(key: string, initialValue: T): [T, React.Dispatch<React.SetStateAction<T>>] {\n  // Function to get the stored value from localStorage\n  const getStoredValue = (): T => {\n    if (typeof window === 'undefined') { // Check for server-side rendering environment\n      return initialValue;\n    }\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading from localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  };\n\n  const [value, setValue] = useState<T>(getStoredValue);\n\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      try {\n        window.localStorage.setItem(key, JSON.stringify(value));\n      } catch (error) {\n        console.error(`Error writing to localStorage key \"${key}\":`, error);\n      }\n    }\n  }, [key, value]);\n\n  return [value, setValue];\n}\n\n// --- Example Usage (for testing) ---\nfunction Counter() {\n  const [count, setCount] = useLocalStorage('my-counter', 0);\n\n  return (\n    <div>\n      <h3>Counter with LocalStorage</h3>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>\n      <button onClick={() => setCount(0)}>Reset</button>\n    </div>\n  );\n}\n\nfunction UserSettings() {\n  const [name, setName] = useLocalStorage('user-name', 'Guest');\n  const [email, setEmail] = useLocalStorage('user-email', '');\n  const [isDarkMode, setIsDarkMode] = useLocalStorage('dark-mode', false);\n\n  return (\n    <div>\n      <h3>User Settings with LocalStorage</h3>\n      <label>\n        Name:\n        <input type=\"text\" value={name} onChange={(e) => setName(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Email:\n        <input type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} />\n      </label>\n      <br/>\n      <label>\n        Dark Mode:\n        <input type=\"checkbox\" checked={isDarkMode} onChange={(e) => setIsDarkMode(e.target.checked)} />\n      </label>\n      <p>Hello, {name}! Your email is {email}. Dark mode is {isDarkMode ? 'enabled' : 'disabled'}.</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>\n      <Counter />\n      <hr style={{ margin: '30px 0' }}/>\n      <UserSettings />\n    </div>\n  );\n}\n\n// export default App;\n",
          "testCases": [
            "Initial load: If 'my-counter' is not in localStorage, `count` should be 0. If it is, `count` should load that value.",
            "Incrementing `count`: Clicking Increment should update `count` and persist the new value in localStorage.",
            "Resetting `count`: Clicking Reset should set `count` to 0 and persist it.",
            "String/Text fields: `user-name` and `user-email` should load/save correctly when input changes.",
            "Boolean fields: `dark-mode` should load/save correctly when checkbox is toggled.",
            "Multiple instances: Ensure multiple `useLocalStorage` calls with different keys work independently.",
            "JSON serialization: Test with objects/arrays as initial values (e.g., `useLocalStorage('my-array', [1, 2, 3])`).",
            "Error handling: Simulate `localStorage` unavailability (e.g., in a non-browser environment) to ensure it defaults to `initialValue` without crashing (though hard to test in browser).",
            "Type safety: Ensure TypeScript types (`<T>`) are handled correctly."
          ],
          "hints": [
            "You'll need `useState` to hold the current value and `useEffect` to handle the side effect of reading from/writing to `localStorage`.",
            "The `initialValue` for `useState` can be a function that computes the initial state, which is useful for lazy initialization that involves `localStorage` access.",
            "Remember that `localStorage` only stores strings. You'll need `JSON.stringify()` before saving and `JSON.parse()` after retrieving.",
            "Wrap `localStorage` operations in `try...catch` blocks as access can sometimes be denied or cause errors (e.g., storage full). Also, check `typeof window !== 'undefined'` for SSR compatibility."
          ],
          "tags": [
            "React Hooks",
            "Custom Hooks",
            "LocalStorage",
            "State Persistence",
            "Side Effects",
            "Data Management",
            "Interview Challenge"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React Hooks (useState, useEffect)",
            "JavaScript localStorage API",
            "JSON Serialization"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_custom_hooks"
          ]
        },
        {
          "id": "task_custom_hooks_use_debounce",
          "title": "Implement a `useDebounce` Custom Hook",
          "description": "\nCreate a custom React Hook named `useDebounce` that debounces a value. This is useful for delaying expensive operations (like API calls or heavy computations) until a user has stopped typing or interacting for a certain period.\n\n### Requirements:\n1.  **Signature**: The hook should accept a `value` (any type) and a `delay` (number in milliseconds) as arguments.\n2.  **Debounced Value**: It should return the `debouncedValue`.\n3.  **Delay Logic**: The `debouncedValue` should only update after the `value` has not changed for the specified `delay` period.\n4.  **Cleanup**: Ensure that any pending timeouts are cleared when the component unmounts or when the `value` or `delay` dependencies change, to prevent memory leaks or incorrect behavior.\n\n### Scenario:\nImagine you have a search input. You don't want to make an API call on every keystroke, but only after the user pauses typing for a short duration.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  // TODO: Implement debounce logic here\n  // You'll need useState for the debounced value\n  // and useEffect for setting/clearing timeouts\n\n  return value; // Placeholder\n}\n\n// --- Example Usage (for testing) ---\nfunction SearchInput() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTerm, 500); // Debounce by 500ms\n\n  useEffect(() => {\n    // This effect should only run AFTER the debounce delay\n    if (debouncedSearchTerm) {\n      console.log('Performing search for:', debouncedSearchTerm);\n      // In a real app, this would be an API call\n    }\n  }, [debouncedSearchTerm]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n      />\n      <p>Current input: {searchTerm}</p>\n      <p>Debounced search: {debouncedSearchTerm}</p>\n    </div>\n  );\n}\n\n// function App() {\n//   return <SearchInput />;\n// }\n\n// export default App;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    // Set a timeout to update the debounced value after the specified delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    // Clean up the timeout if value or delay changes, or if the component unmounts\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]); // Only re-run if value or delay changes\n\n  return debouncedValue;\n}\n\n// --- Example Usage (for testing) ---\nfunction SearchInput() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTerm, 500); // Debounce by 500ms\n  const [apiCallCount, setApiCallCount] = useState(0);\n\n  useEffect(() => {\n    // This effect should only run AFTER the debounce delay\n    if (debouncedSearchTerm) {\n      console.log('Performing API search for:', debouncedSearchTerm);\n      setApiCallCount(prev => prev + 1);\n      // Simulate an API call\n      // fetch(`/api/search?q=${debouncedSearchTerm}`).then(res => res.json());\n    } else if (searchTerm === '') {\n      console.log('Search term cleared.');\n      setApiCallCount(0);\n    }\n  }, [debouncedSearchTerm]);\n\n  return (\n    <div style={{ fontFamily: 'Arial, sans-serif', padding: '20px' }}>\n      <h2>Search with Debounce Hook</h2>\n      <input\n        type=\"text\"\n        placeholder=\"Type to search...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ padding: '10px', fontSize: '1em', width: '300px', marginBottom: '10px' }}\n      />\n      <p>Current input: <strong>{searchTerm}</strong></p>\n      <p>Debounced search term (updates after 500ms pause): <strong>{debouncedSearchTerm}</strong></p>\n      <p>Simulated API calls made: <strong>{apiCallCount}</strong></p>\n      <p style={{ color: '#888', fontSize: '0.9em' }}>Type quickly, then pause to see the debounced term update.</p>\n    </div>\n  );\n}\n\n// function App() {\n//   return <SearchInput />;\n// }\n\n// export default App;\n",
          "testCases": [
            "Initial render: `debouncedValue` should be equal to `value`.",
            "Typing quickly: If `value` changes rapidly (e.g., 'a', 'ab', 'abc'), `debouncedValue` should not update immediately.",
            "Pause after typing: If user types 'abc' and then stops for `delay` ms, `debouncedValue` should update to 'abc'.",
            "Clearing input: If `searchTerm` is cleared, `debouncedSearchTerm` should eventually clear after the delay.",
            "Unmount: Ensure `clearTimeout` is called on unmount (check console for `SetState` warnings if not handled).",
            "Delay change: If `delay` itself changes, the debouncing logic should re-initialize correctly."
          ],
          "hints": [
            "Use `useState` for `debouncedValue` and `useEffect` for the debouncing logic.",
            "Inside `useEffect`, set a timeout to update `debouncedValue`.",
            "The `useEffect` cleanup function (`return () => {}`) is crucial here to clear the previous timeout whenever `value` or `delay` changes, or the component unmounts."
          ],
          "tags": [
            "React Hooks",
            "Custom Hooks",
            "Debounce",
            "Performance Optimization",
            "useEffect",
            "Interview Challenge"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "React Hooks (useState, useEffect)",
            "JavaScript `setTimeout` and `clearTimeout`"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_custom_hooks"
          ]
        }
      ]
    }
  },
  {
    "id": "a92d8f16-1886-485d-acf5-abdb71e84f43",
    "startLine": 5600,
    "endLine": 5699,
    "processedDate": "2025-06-17T09:42:32.826Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_state_forms",
          "title": "React State Management with useState and Form Handling",
          "content": "This section covers the fundamental `useState` hook in React for managing component-level state and its application in handling user input within forms.\n\n## useState Hook\n`useState` is a React Hook that lets you add state to functional components. It returns a stateful value and a function to update it. When the setter function is called, React re-renders the component.\n\n**Syntax:** `const [state, setState] = useState(initialState);`\n*   `state`: The current state value.\n*   `setState`: A function to update the state. It can be called with a new value or a function that receives the previous state and returns the new state (useful for complex updates or when new state depends on previous state).\n*   `initialState`: The initial value of the state. This can be a primitive (number, string, boolean) or an object/array. If `initialState` is a function, it will be executed only once during the initial render to compute the initial state, which is useful for expensive initializations.\n\n## Controlled Components in Forms\nIn React, form elements like `<input>`, `<textarea>`, and `<select>` maintain their own internal state. When you want React to be the 'single source of truth' for the form data, you create 'controlled components'.\n\nFor a controlled component:\n1.  The `value` attribute of the form element is tied to a state variable.\n2.  The `onChange` event handler updates this state variable whenever the input value changes.\n\nThis pattern ensures that the component's state and the displayed input value are always synchronized, allowing React to control the form data. This approach simplifies validation, conditional rendering, and dynamic changes to the form.\n\n## Event Handling in Forms\n\n*   `onChange`: This event fires whenever the value of a form input element is changed. It's crucial for controlled components to update the state.\n*   `onSubmit`: This event fires when a form is submitted. It's typically attached to the `<form>` element. The event object provides `event.preventDefault()` which is used to stop the browser's default behavior of reloading the page upon form submission, allowing React to handle the submission logic.\n",
          "examples": [
            {
              "id": "example_react_state_forms_1",
              "title": "Basic LoginForm Example",
              "code": "import React, { useState } from 'react';\n\nfunction LoginForm() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleUsernameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUsername(event.target.value);\n  };\n\n  const handlePasswordChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setPassword(event.target.value);\n  };\n\n  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    // In a real application, you would send these credentials to a server\n    console.log('Username:', username);\n    console.log('Password:', password);\n    alert(`Submitting: Username - ${username}, Password - ${password}`);\n    // Reset form or redirect\n    setUsername('');\n    setPassword('');\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input \n          id=\"username\"\n          type=\"text\" \n          value={username} \n          onChange={handleUsernameChange} \n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input \n          id=\"password\"\n          type=\"password\" \n          value={password} \n          onChange={handlePasswordChange} \n        />\n      </div>\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nexport default LoginForm;\n",
              "explanation": "This example demonstrates a typical controlled `LoginForm` component. `useState` is used to manage the `username` and `password` inputs. Each input's `value` is bound to its respective state variable, and `onChange` handlers update the state whenever the input changes. The `handleSubmit` function prevents the default form submission behavior and logs the collected credentials, then clears the form.",
              "language": "typescript"
            },
            {
              "id": "example_react_state_forms_2",
              "title": "useState with Functional Update",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    // Using functional update is safer when new state depends on previous state\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const incrementTwice = () => {\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={incrementTwice}>Increment Twice (Safe)</button>\n    </div>\n  );\n}\n\nexport default Counter;\n",
              "explanation": "This example illustrates the use of a functional update for `setCount`. When `setCount` is called with a function, React ensures the `prevCount` argument is the most up-to-date state, preventing stale closure issues, especially when state updates are batched or queued, as seen in `incrementTwice`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_useState_1",
            "question_form_handling_1",
            "question_controlled_components_1",
            "question_useState_functional_update_1"
          ],
          "relatedTasks": [
            "task_user_registration_form",
            "task_dynamic_form_validation"
          ],
          "tags": [
            "React",
            "Hooks",
            "State Management",
            "Forms",
            "useState",
            "Controlled Components",
            "Event Handling"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Basics",
            "HTML Forms"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Custom Hooks",
            "Context API",
            "Redux"
          ]
        },
        {
          "id": "theory_custom_hook_use_local_storage",
          "title": "Building Custom React Hooks: useLocalStorage",
          "content": "Custom Hooks are JavaScript functions whose names start with `use` and that can call other Hooks. They allow you to reuse stateful logic across different components without sharing actual state.\n\n## useLocalStorage Hook\nThe `useLocalStorage` hook provides a way to persist React component state to the browser's `localStorage`.\n\n### Key Concepts:\n*   **State Initialization:** The `useState` hook is initialized with a function `() => { ... }`. This functional initializer is executed only once during the initial render. It attempts to retrieve the stored value from `localStorage` using `window.localStorage.getItem(key)`. If a value is found, it's parsed from JSON; otherwise, the `initialValue` provided to the hook is used. This prevents re-reading `localStorage` on every re-render and ensures efficient initial state setup.\n*   **Persistence with `useEffect`:** The `useEffect` hook is used to synchronize the component's state with `localStorage`. Whenever the `storedValue` (the state managed by `useState`) or the `key` changes, the `useEffect` callback runs. Inside the callback, `window.localStorage.setItem(key, JSON.stringify(storedValue))` is called to save the current state to `localStorage`.\n*   **Dependency Array:** The `useEffect` hook includes `[key, storedValue]` in its dependency array. This ensures that the effect re-runs only when the `key` or the `storedValue` actually changes, preventing unnecessary `localStorage` writes and optimizing performance.\n*   **Error Handling:** Both the initial read from `localStorage` and the subsequent writes are wrapped in `try...catch` blocks. This is crucial because `localStorage` operations can fail (e.g., due to security restrictions, storage quota exceeded, or malformed JSON data), preventing the application from crashing.\n\n### Benefits of Custom Hooks:\n*   **Reusability:** Share logic across multiple components without prop drilling or render props.\n*   **Readability:** Encapsulate complex logic into a single, descriptive function.\n*   **Separation of Concerns:** Keep presentation logic separate from stateful logic.\n*   **Testability:** Custom hooks are easier to test in isolation.\n",
          "examples": [
            {
              "id": "example_use_local_storage_1",
              "title": "useLocalStorage Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\n// Custom hook for persisting state to localStorage\nfunction useLocalStorage<T>(key: string, initialValue: T): [T, (value: T | ((prev: T) => T)) => void] {\n  // Get initial value from localStorage or use initialValue\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      if (typeof window === 'undefined') { // Server-side rendering check\n        return initialValue;\n      }\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(\"Error reading from localStorage:\", error);\n      return initialValue;\n    }\n  });\n  \n  // Update localStorage when state changes\n  useEffect(() => {\n    try {\n      if (typeof window !== 'undefined') { // Client-side check\n        window.localStorage.setItem(key, JSON.stringify(storedValue));\n      }\n    } catch (error) {\n      console.error(\"Error writing to localStorage:\", error);\n    }\n  }, [key, storedValue]); // Dependencies: re-run when key or storedValue changes\n  \n  return [storedValue, setStoredValue];\n}\n\n// Usage example:\n// function PersistentCounter() {\n//   const [count, setCount] = useLocalStorage('count', 0);\n  \n//   return (\n//     <div>\n//       <p>Count: {count}</p>\n//       <button onClick={() => setCount(count + 1)}>Increment</button>\n//       <button onClick={() => setCount(0)}>Reset</button>\n//     </div>\n//   );\n// }\n\nexport default useLocalStorage;\n",
              "explanation": "This is the core implementation of `useLocalStorage`. It correctly uses `useState` with a functional initializer for lazy initial state computation and `useEffect` with a dependency array to persist state changes. Crucially, it includes `typeof window === 'undefined'` checks for server-side rendering compatibility and comprehensive `try...catch` blocks for robust error handling during `localStorage` operations. Type parameters `<T>` are added for better TypeScript support.",
              "language": "typescript"
            },
            {
              "id": "example_use_local_storage_2",
              "title": "Persistent Counter Component using useLocalStorage",
              "code": "import React from 'react';\nimport useLocalStorage from './useLocalStorage'; // Assuming useLocalStorage is in a separate file\n\nfunction PersistentCounter() {\n  const [count, setCount] = useLocalStorage('app-counter', 0);\n  const [theme, setTheme] = useLocalStorage('app-theme', 'light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n  \n  return (\n    <div style={{ background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#333', padding: '20px', borderRadius: '8px' }}>\n      <h2>Persistent Counter & Theme</h2>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(prevCount => prevCount - 1)}>Decrement</button>\n      <button onClick={() => setCount(0)}>Reset Count</button>\n      \n      <p>Current Theme: {theme}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\nexport default PersistentCounter;\n",
              "explanation": "This component demonstrates the practical usage of the `useLocalStorage` hook. It maintains a `count` and a `theme` state, both of which are automatically persisted and loaded from `localStorage`. Changes to these states are immediately reflected in the UI and saved for future sessions, showcasing the reusability and power of custom hooks for managing persistent application settings.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_custom_hooks_1",
            "question_local_storage_limitations_1",
            "question_use_state_functional_initializer_1",
            "question_use_effect_dependencies_1",
            "question_custom_hook_error_handling_1"
          ],
          "relatedTasks": [
            "task_user_settings_panel",
            "task_persistent_todo_list"
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "useState",
            "useEffect",
            "LocalStorage",
            "State Persistence",
            "Web Storage"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "useState",
            "useEffect",
            "JavaScript ES6+",
            "Web Storage API"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced React Patterns",
            "State Management Libraries"
          ]
        },
        {
          "id": "theory_custom_hook_use_fetch",
          "title": "Building Custom React Hooks: useFetch and Data Fetching Patterns",
          "content": "This section delves into creating a custom hook for asynchronous data fetching, a common requirement in most modern web applications. It highlights key considerations like managing loading and error states, and handling component unmounting.\n\n## useFetch Hook\nThe `useFetch` hook encapsulates the logic for fetching data from a given URL, managing the `data`, `loading`, and `error` states.\n\n### Key Concepts:\n*   **State Management for Async Operations:** The hook uses three `useState` variables: `data` (for the fetched content), `loading` (to indicate if the fetch is in progress), and `error` (to store any error messages).\n*   **Side Effects with `useEffect`:** Data fetching is a side effect and is therefore performed inside a `useEffect` hook. This ensures that the fetch operation runs after the component renders and can be re-triggered based on dependencies.\n*   **Asynchronous Operations (`async/await` and `fetch` API):** The `fetchData` function is `async`, allowing the use of `await` for cleaner asynchronous code. The `fetch` API is used to make the network request. It returns a `Promise` that resolves to a `Response` object. The `response.json()` method is then used to parse the response body as JSON.\n*   **Error Handling:**\n    *   **HTTP Errors:** `response.ok` is checked to determine if the HTTP response status code indicates success (2xx range). If not, an `Error` is thrown with the status.\n    *   **Network/Parse Errors:** A `try...catch` block surrounds the `fetch` and JSON parsing operations to catch network errors, JSON parsing errors, or any other exceptions during the fetch process. The `error` state is updated accordingly.\n*   **Dependency Array:** The `useEffect` hook includes `[url, options]` in its dependency array. This means the `fetchData` function will be re-executed whenever the `url` or `options` (e.g., headers, method) passed to the hook change, allowing the hook to respond to dynamic data requirements.\n*   **Cleanup and `isMounted` Flag:**\n    *   **Problem:** A common issue in React when dealing with asynchronous operations is attempting to update the state of an unmounted component. This can lead to memory leaks and React warnings (`Can't perform a React state update on an unmounted component`).\n    *   **Solution (`isMounted` Flag):** A boolean variable `isMounted` is used within the `useEffect` scope. It is initialized to `true` and set to `false` in the `return` cleanup function of `useEffect`. Before calling `setData`, `setLoading`, or `setError`, the `isMounted` flag is checked. If the component has unmounted (`isMounted` is `false`), no state updates are performed.\n    *   This pattern ensures that state updates only occur if the component is still mounted, preventing potential issues.\n",
          "examples": [
            {
              "id": "example_use_fetch_1",
              "title": "useFetch Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\ninterface FetchOptions extends RequestInit {}\n\ninterface FetchResult<T> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n}\n\n// Custom hook for fetching data\nfunction useFetch<T>(url: string, options?: FetchOptions): FetchResult<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  useEffect(() => {\n    let isMounted = true; // Flag to track if the component is mounted\n    setLoading(true); // Set loading to true at the start of fetch\n    setError(null); // Clear previous errors\n    \n    const fetchData = async () => {\n      try {\n        const response = await fetch(url, options); // Perform fetch request\n        if (!response.ok) { // Check for HTTP errors (e.g., 404, 500)\n          throw new Error(`HTTP error! Status: ${response.status} - ${response.statusText}`);\n        }\n        \n        const json: T = await response.json(); // Parse response as JSON\n        if (isMounted) { // Only update state if component is still mounted\n          setData(json);\n          setError(null);\n        }\n      } catch (e) {\n        const errorMessage = (e instanceof Error) ? e.message : String(e);\n        if (isMounted) { // Only update state if component is still mounted\n          setError(errorMessage);\n          setData(null);\n        }\n      } finally {\n        if (isMounted) { // Only update state if component is still mounted\n          setLoading(false);\n        }\n      }\n    };\n    \n    fetchData(); // Execute the fetch operation\n\n    // Cleanup function: runs when component unmounts or before effect re-runs\n    return () => {\n      isMounted = false;\n    };\n  }, [url, options]); // Dependencies: re-run when url or options change\n  \n  return { data, loading, error };\n}\n\n// Usage example:\n// interface Post {\n//   userId: number;\n//   id: number;\n//   title: string;\n//   body: string;\n// }\n\n// function PostViewer() {\n//   const { data: post, loading, error } = useFetch<Post>('https://jsonplaceholder.typicode.com/posts/1');\n\n//   if (loading) return <p>Loading post...</p>;\n//   if (error) return <p>Error: {error}</p>;\n//   if (!post) return <p>No post found.</p>;\n\n//   return (\n//     <div>\n//       <h2>{post.title}</h2>\n//       <p>{post.body}</p>\n//     </div>\n//   );\n// }\n\nexport default useFetch;\n",
              "explanation": "This comprehensive `useFetch` hook demonstrates how to manage different states (`data`, `loading`, `error`) during an asynchronous operation. It correctly uses `useEffect` for side effects, handles HTTP and network errors, and implements the `isMounted` flag as part of the effect's cleanup function to prevent updating state on unmounted components. TypeScript interfaces are added for better type safety.",
              "language": "typescript"
            },
            {
              "id": "example_use_fetch_2",
              "title": "Displaying Data with useFetch Component",
              "code": "import React from 'react';\nimport useFetch from './useFetch'; // Assuming useFetch is in a separate file\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction UserList() {\n  const { data: users, loading, error } = useFetch<User[]>('https://jsonplaceholder.typicode.com/users');\n\n  if (loading) {\n    return <p>Loading users...</p>;\n  }\n\n  if (error) {\n    return <p style={{ color: 'red' }}>Error fetching users: {error}</p>;\n  }\n\n  if (!users || users.length === 0) {\n    return <p>No users found.</p>;\n  }\n\n  return (\n    <div>\n      <h1>Users</h1>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <strong>{user.name}</strong> ({user.email})\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default UserList;\n",
              "explanation": "This component showcases how to consume the `useFetch` hook to display a list of users. It gracefully handles the `loading` and `error` states by displaying appropriate messages to the user. Once data is successfully fetched, it maps over the `users` array and renders them in a list, illustrating a common pattern for displaying API data in React applications.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_fetch_states_1",
            "question_is_mounted_pattern_1",
            "question_fetch_api_error_handling_1",
            "question_use_effect_cleanup_1",
            "question_custom_hooks_data_fetching_1"
          ],
          "relatedTasks": [
            "task_fetch_display_posts",
            "task_searchable_api_data",
            "task_pagination_with_use_fetch"
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "useEffect",
            "useState",
            "Data Fetching",
            "Fetch API",
            "Async/Await",
            "Error Handling",
            "Cleanup",
            "Memory Leaks"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "useState",
            "useEffect",
            "JavaScript Async/Await",
            "Fetch API"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Building Complex UIs",
            "Performance Optimization",
            "State Management in Large Apps"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_useState_1",
          "topic": "React useState Hook",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the `useState` hook in React functional components?",
          "answer": "To add state to functional components.",
          "options": [
            "To perform side effects like data fetching.",
            "To manage component lifecycle methods.",
            "To add state to functional components.",
            "To provide a context for deeply nested components."
          ],
          "analysisPoints": [
            "`useState` is specifically designed for managing mutable state within functional components.",
            "Side effects are managed by `useEffect`.",
            "Lifecycle methods are a concept from class components, replaced by hooks in functional components.",
            "Context is managed by `useContext`."
          ],
          "keyConcepts": [
            "useState",
            "Functional Components",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental React hooks",
            "Ability to distinguish hook purposes"
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction ExampleComponent() {\n  const [count, setCount] = useState(0); // Here, useState adds state.\n  return <p>Count: {count}</p>;\n}\n```",
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Fundamentals"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_form_handling_1",
          "topic": "React Form Handling (Controlled Components)",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of 'controlled components' in React forms and why `event.preventDefault()` is typically used with form submissions.",
          "answer": "A 'controlled component' in React forms is an input element (like `<input>`, `<textarea>`, `<select>`) whose value is controlled by React state. The input's `value` attribute is bound to a state variable, and its `onChange` event handler updates that state. This makes React the single source of truth for the input's data, allowing for easy validation, manipulation, and conditional rendering of form data.\n\n`event.preventDefault()` is used with form submissions to stop the browser's default behavior, which is to reload the page when a form is submitted. In a Single Page Application (SPA) built with React, we want to handle the form data with JavaScript without a full page refresh. `event.preventDefault()` allows React to take full control of the submission process, enabling AJAX requests, local state updates, or client-side routing without disrupting the user's experience.",
          "analysisPoints": [
            "Definition of controlled component (state controls value, `onChange` updates state).",
            "Benefits of controlled components (validation, single source of truth).",
            "Purpose of `event.preventDefault()` (stop default browser refresh).",
            "Context of `event.preventDefault()` in SPAs."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Forms",
            "Event Handling",
            "event.preventDefault()",
            "React State"
          ],
          "evaluationCriteria": [
            "Understanding of React form patterns",
            "Knowledge of browser default behaviors",
            "Ability to explain common React practices"
          ],
          "example": "See `LoginForm` example in theory `theory_react_state_forms` for practical implementation.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Event Handling"
          ],
          "prerequisites": [
            "React Basics",
            "JavaScript Event Loop"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_useState_functional_update_1",
          "topic": "useState Functional Update",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```typescript\nimport React, { useState } from 'react';\n\nfunction MultiClickCounter() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Click Me</button>\n    </div>\n  );\n}\n```\nIf the user clicks the 'Click Me' button once, what will be the final value of `count` displayed?",
          "answer": "1",
          "options": [
            "0",
            "1",
            "2",
            "It depends on React's batching behavior."
          ],
          "analysisPoints": [
            "React batches state updates within the same event loop for performance.",
            "When `setCount(count + 1)` is called twice with a direct value, both calls use the `count` value from the *beginning* of the render/event cycle.",
            "If `count` was 0, both `setCount(0 + 1)` calls effectively try to set `count` to 1.",
            "The second call overwrites the first within the same batch, resulting in a final `count` of 1.",
            "To get 2, one would need to use the functional update form: `setCount(prevCount => prevCount + 1);`"
          ],
          "keyConcepts": [
            "useState",
            "Functional Update",
            "State Batching",
            "Stale Closures"
          ],
          "evaluationCriteria": [
            "Understanding of `useState` behavior",
            "Knowledge of React's state update mechanisms",
            "Ability to identify potential pitfalls"
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction MultiClickCounterFixed() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    // Using functional updates ensures the latest state is used\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Click Me (Fixed)</button>\n    </div>\n  );\n}\n// In this fixed version, clicking once would result in count: 2.\n```",
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Advanced",
            "Performance"
          ],
          "prerequisites": [
            "React Basics",
            "useState"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_1",
          "topic": "Custom Hooks",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using custom hooks in React?",
          "answer": "Reusing stateful logic across multiple components.",
          "analysisPoints": [
            "Custom hooks allow developers to extract and share stateful logic, like managing component state or side effects, without resorting to prop drilling or render props patterns.",
            "They promote code organization, readability, and testability."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Code Reusability",
            "Stateful Logic"
          ],
          "evaluationCriteria": [
            "Basic understanding of custom hook purpose"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Fundamentals"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_local_storage_limitations_1",
          "topic": "localStorage Limitations",
          "level": "medium",
          "type": "open",
          "question": "What are some limitations or potential issues when using `localStorage` for persisting application state in a React application?",
          "answer": "While `localStorage` is useful for simple state persistence, it has several limitations:\n\n1.  **Synchronous Nature:** `localStorage` operations are synchronous, meaning they block the main thread. Frequent or large reads/writes can lead to performance issues and a janky UI, especially on low-power devices.\n2.  **String-only Storage:** `localStorage` can only store strings. Objects and arrays must be serialized to JSON (`JSON.stringify()`) before saving and deserialized (`JSON.parse()`) when retrieved, adding overhead and potential for parsing errors.\n3.  **Limited Storage Capacity:** Typically, `localStorage` has a limit of around 5-10 MB per origin, which is sufficient for small data but insufficient for large datasets or media.\n4.  **Security Concerns:** Data stored in `localStorage` is accessible via JavaScript (XSS attacks) and is not encrypted. Sensitive information like user credentials should never be stored here. It's also domain-specific, meaning `http://example.com` cannot access data stored by `https://example.com`.\n5.  **No Type Support:** Values retrieved from `localStorage` are always strings, requiring manual type conversion back to numbers, booleans, etc.\n6.  **No Expiration:** Data stored in `localStorage` persists indefinitely until explicitly cleared by the user or script, or by the browser. There's no built-in mechanism for setting an expiration time.\n7.  **Client-Side Only:** `localStorage` is a browser API, meaning it's not available during server-side rendering (SSR), which requires careful handling (e.g., `typeof window !== 'undefined'` checks in hooks like `useLocalStorage`).",
          "analysisPoints": [
            "Synchronous I/O.",
            "String-only storage, requiring serialization/deserialization.",
            "Storage capacity limits.",
            "Security risks (XSS, no encryption).",
            "Lack of built-in expiration.",
            "Client-side only nature (SSR incompatibility)."
          ],
          "keyConcepts": [
            "localStorage",
            "Web Storage API",
            "Limitations",
            "Security",
            "Performance",
            "SSR"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of `localStorage` caveats",
            "Awareness of practical implications for React apps"
          ],
          "example": "```typescript\n// Example of the synchronous nature and string-only storage\ntry {\n  localStorage.setItem('myLargeKey', JSON.stringify({ data: Array(100000).fill('some_data') })); // Can block UI\n  const item = localStorage.getItem('myLargeKey');\n  const parsed = JSON.parse(item); // Needs parsing\n} catch (error) {\n  console.error('LocalStorage error:', error); // Catches quota exceeded or parse errors\n}\n```",
          "tags": [
            "Web Storage",
            "localStorage",
            "Performance",
            "Security",
            "Frontend Architecture"
          ],
          "prerequisites": [
            "JavaScript Basics",
            "Web APIs"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_state_functional_initializer_1",
          "topic": "useState Initializer Function",
          "level": "medium",
          "type": "mcq",
          "question": "Why is it recommended to pass a function to `useState` for its `initialState` argument when the initial state calculation is expensive?",
          "answer": "To ensure the initialization logic runs only once during the initial render.",
          "options": [
            "To enable asynchronous state updates.",
            "To ensure the initialization logic runs only once during the initial render.",
            "To make the state immutable.",
            "To automatically recompute the initial state on every re-render."
          ],
          "analysisPoints": [
            "When `useState` receives a function as `initialState`, React calls that function *only once* during the very first render of the component.",
            "If `initialState` is a direct value (e.g., `useState(someExpensiveCalculation())`), `someExpensiveCalculation()` would run on *every* re-render, even though its result is only used for the initial render, leading to unnecessary computations.",
            "This optimization is crucial for performance when the initial state derivation involves heavy computation, like parsing a large JSON string from `localStorage` or fetching data."
          ],
          "keyConcepts": [
            "useState",
            "Initial State",
            "Functional Initializer",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding of `useState` initialization patterns",
            "Knowledge of performance best practices"
          ],
          "example": "```typescript\nimport { useState } from 'react';\n\nfunction MyComponent() {\n  // Expensive calculation that should only run once\n  const getInitialValue = () => {\n    console.log('Calculating initial value...');\n    return JSON.parse(localStorage.getItem('mySetting') || '\"default\"');\n  };\n\n  // Correct usage: function is passed, executed once\n  const [setting, setSetting] = useState(getInitialValue);\n\n  // Incorrect usage: function is called directly, executes on every re-render\n  // const [setting, setSetting] = useState(getInitialValue());\n\n  return <div>Setting: {setting}</div>;\n}\n```",
          "tags": [
            "React",
            "useState",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "React Basics",
            "useState"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_effect_dependencies_1",
          "topic": "useEffect Dependency Array",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `useEffect` hook:\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setSeconds(seconds + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []); // Dependency array\n\n  return <p>Seconds: {seconds}</p>;\n}\n```\n\nWhat is the expected behavior of this `Timer` component when rendered?",
          "answer": "The timer will increment to 1 and then stop, as `seconds` is captured at its initial value.",
          "options": [
            "The timer will increment correctly every second (0, 1, 2, 3...).",
            "The timer will increment to 1 and then stop, as `seconds` is captured at its initial value.",
            "The component will re-render infinitely due to `useEffect` loop.",
            "An error will occur because `seconds` is not in the dependency array."
          ],
          "analysisPoints": [
            "The `useEffect` hook has an empty dependency array `[]`, meaning the effect runs only once after the initial render.",
            "When `setInterval` is set up, `seconds` is captured in the closure with its initial value (0).",
            "Therefore, `setSeconds(seconds + 1)` effectively becomes `setSeconds(0 + 1)`, repeatedly setting `seconds` to 1.",
            "This is a common 'stale closure' problem when `useEffect` dependencies are incorrect.",
            "To fix this, `setSeconds(prevSeconds => prevSeconds + 1)` should be used, or `seconds` should be included in the dependency array (though the functional update is generally preferred for timers)."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Stale Closures",
            "Closures",
            "setInterval"
          ],
          "evaluationCriteria": [
            "Deep understanding of `useEffect` dependencies and closures",
            "Ability to diagnose common React hook issues"
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction TimerFixed() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // Using functional update to avoid stale closure\n      setSeconds(prevSeconds => prevSeconds + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []); // Still empty dependency array, as functional update doesn't depend on 'seconds'\n\n  return <p>Seconds: {seconds}</p>;\n}\n```",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Bugs",
            "Performance",
            "Intermediate"
          ],
          "prerequisites": [
            "React Hooks",
            "JavaScript Closures"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hook_error_handling_1",
          "topic": "Custom Hook Error Handling",
          "level": "medium",
          "type": "open",
          "question": "Why is it important to include `try...catch` blocks within a custom hook like `useLocalStorage` or `useFetch`, and what kinds of errors are you typically trying to catch?",
          "answer": "It is crucial to include `try...catch` blocks within custom hooks like `useLocalStorage` or `useFetch` to handle potential runtime errors gracefully, preventing the application from crashing and providing a better user experience.\n\nFor `useLocalStorage`, `try...catch` is important for:\n*   **`localStorage` access errors:** Browsers might block `localStorage` access in certain sandboxed environments (e.g., cross-origin iframes, private browsing mode with strict settings) or if the storage quota is exceeded. Attempting to `getItem` or `setItem` in such scenarios can throw a `SecurityError` or `QuotaExceededError`.\n*   **`JSON.parse()` errors:** If data stored in `localStorage` is corrupted or not valid JSON (e.g., manually edited, or an error during `JSON.stringify` on save), `JSON.parse()` will throw a `SyntaxError`.\n\nFor `useFetch`, `try...catch` is important for:\n*   **Network errors:** `fetch` promises will reject with a `TypeError` for network-related issues (e.g., no internet connection, DNS lookup failure, CORS issues, request timeout). These are errors that prevent the request from completing.\n*   **HTTP errors (non-2xx responses):** While `fetch` itself doesn't reject for HTTP status codes like 404 or 500, the `response.ok` property will be `false`. It's good practice to `throw new Error()` explicitly in this case within the `try` block, so the `catch` block can handle it consistently.\n*   **JSON parsing errors:** If the server response is not valid JSON, `response.json()` will throw an error.\n\nBy catching these errors, the hook can set an `error` state, display a fallback UI, or log the issue, instead of causing the entire application to fail.",
          "analysisPoints": [
            "Importance of `try...catch` for robustness.",
            "Specific error types for `useLocalStorage` (security, quota, JSON parsing).",
            "Specific error types for `useFetch` (network, HTTP non-2xx, JSON parsing).",
            "Benefits of error handling (graceful degradation, UX, debugging)."
          ],
          "keyConcepts": [
            "Error Handling",
            "Custom Hooks",
            "useLocalStorage",
            "useFetch",
            "try...catch",
            "Network Errors",
            "HTTP Status Codes",
            "JSON Parsing"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of error types in web development",
            "Ability to apply robust coding practices"
          ],
          "example": "See `useLocalStorage` and `useFetch` theory blocks for `try...catch` implementations.",
          "tags": [
            "Error Handling",
            "React",
            "Hooks",
            "Best Practices",
            "Robustness"
          ],
          "prerequisites": [
            "JavaScript Error Handling",
            "Web APIs"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_states_1",
          "topic": "useFetch Hook State Management",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the three main state variables typically managed by a `useFetch` custom hook?",
          "answer": "`data`, `loading`, and `error`.",
          "analysisPoints": [
            "These three states cover the complete lifecycle of an asynchronous data fetching operation: the result, the status of the operation, and any issues encountered."
          ],
          "keyConcepts": [
            "useFetch",
            "State Management",
            "Data Fetching",
            "Loading State",
            "Error State"
          ],
          "evaluationCriteria": [
            "Basic recall of `useFetch` pattern"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Data Fetching"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_is_mounted_pattern_1",
          "topic": "useEffect Cleanup and isMounted Flag",
          "level": "hard",
          "type": "mcq",
          "question": "In a `useFetch` hook, why is the `isMounted` flag used, and what problem does it solve?\n\n```typescript\n// Inside useFetch useEffect\nuseEffect(() => {\n  let isMounted = true;\n  // ... async fetchData ...\n  if (isMounted) {\n    setData(json);\n    setLoading(false);\n  }\n  return () => {\n    isMounted = false;\n  };\n}, [url]);\n```",
          "answer": "It prevents state updates on an unmounted component, which can lead to memory leaks and React warnings.",
          "options": [
            "It optimizes network requests by canceling them if the component unmounts.",
            "It ensures data is always fetched from the server and not from cache.",
            "It prevents state updates on an unmounted component, which can lead to memory leaks and React warnings.",
            "It controls how many times the `fetchData` function is executed."
          ],
          "analysisPoints": [
            "The `isMounted` flag addresses a common issue where an asynchronous operation (like `fetch`) completes *after* the component that initiated it has unmounted.",
            "Attempting to call `setState` on an unmounted component is a memory leak (the state update is queued but never applied) and causes React to issue a warning.",
            "By setting `isMounted = false` in the `useEffect` cleanup function (which runs when the component unmounts or before the effect re-runs), subsequent state updates are conditionally skipped if the component is no longer in the DOM.",
            "It does *not* cancel the network request itself, only prevents state updates. Cancelling requests would require `AbortController`."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Memory Leaks",
            "Component Lifecycle",
            "isMounted Pattern",
            "Asynchronous Operations"
          ],
          "evaluationCriteria": [
            "Deep understanding of React `useEffect` lifecycle",
            "Ability to identify and solve memory leak issues",
            "Knowledge of best practices for async operations in React"
          ],
          "example": "See `useFetch` theory block for full implementation.",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Memory Leaks",
            "Performance",
            "Advanced"
          ],
          "prerequisites": [
            "React Hooks",
            "JavaScript Closures",
            "Asynchronous JavaScript"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_fetch_api_error_handling_1",
          "topic": "Fetch API Error Handling",
          "level": "medium",
          "type": "open",
          "question": "When using the Fetch API, why is it necessary to explicitly check `response.ok` even if the `fetch` call itself doesn't throw an error, and how would you typically handle different types of errors (network vs. HTTP) in a `useFetch` hook?",
          "answer": "The Fetch API's `fetch()` method only throws an error (rejects its promise) for network errors (e.g., no internet connection, DNS error, CORS issues, or a malformed request that prevents it from even being sent). It *does not* reject for HTTP error status codes (like 404 Not Found, 500 Internal Server Error, 401 Unauthorized), which are still successful network responses from the server, just with an error status. For these HTTP errors, `response.ok` will be `false`.\n\nTherefore, it's necessary to explicitly check `response.ok` (which is `true` for 2xx status codes) to handle server-side errors that result in a non-2xx status code. If `response.ok` is `false`, you should manually `throw new Error()` to propagate the error into your `catch` block.\n\n**Handling different error types in `useFetch`:**\n\n1.  **Network Errors:** These are caught by the `try...catch` block surrounding the `fetch` call. The `catch` block receives the `TypeError` directly. The hook would then update its `error` state with a message like 'Network error' or the `error.message`.\n\n    ```typescript\n    try {\n      const response = await fetch(url, options);\n      // ... check response.ok and parse json\n    } catch (e) {\n      // This 'catch' handles network errors or errors from response.json()\n      setError(e.message || 'Network error occurred');\n      setData(null);\n    }\n    ```\n\n2.  **HTTP Errors (non-2xx):** After the `fetch` call, check `response.ok`. If `false`, throw a custom error to be caught by the same `try...catch` block. This allows centralized error handling.\n\n    ```typescript\n    const response = await fetch(url, options);\n    if (!response.ok) {\n      // Manually throw for HTTP error statuses\n      throw new Error(`HTTP error! Status: ${response.status} - ${response.statusText}`);\n    }\n    const json = await response.json();\n    ```\n\nThis pattern allows a single `catch` block to handle both network-level failures and application-level (HTTP status) failures originating from the server, providing a consistent error handling mechanism within the hook.",
          "analysisPoints": [
            "Difference in `fetch` promise rejection behavior for network vs. HTTP errors.",
            "Importance of `response.ok` check.",
            "How to unify error handling with `try...catch` and manual `throw`.",
            "Specific examples of error messages for each type."
          ],
          "keyConcepts": [
            "Fetch API",
            "Error Handling",
            "HTTP Status Codes",
            "Network Errors",
            "try...catch",
            "useFetch"
          ],
          "evaluationCriteria": [
            "Detailed understanding of Fetch API nuances",
            "Ability to implement robust error handling strategies"
          ],
          "example": "See `useFetch` theory block for full implementation.",
          "tags": [
            "Fetch API",
            "JavaScript",
            "Asynchronous",
            "Error Handling",
            "HTTP"
          ],
          "prerequisites": [
            "JavaScript Async/Await",
            "Fetch API"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_custom_hooks_data_fetching_1",
          "topic": "Custom Hooks for Data Fetching",
          "level": "hard",
          "type": "code",
          "question": "Implement a simplified version of `useFetch` that supports fetching data and exposing `data`, `loading`, and `error` states. It should take a URL and an optional `options` object. Ensure proper cleanup to prevent setting state on an unmounted component. You do not need to implement full TypeScript interfaces, simple `any` or no types are fine for this task.",
          "answer": "```javascript\nimport { useState, useEffect } from 'react';\n\nfunction useFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    setLoading(true); // Always set loading to true when starting a fetch\n    setError(null);   // Clear any previous errors\n    setData(null);    // Clear previous data\n\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        \n        const json = await response.json();\n        if (isMounted) {\n          setData(json);\n        }\n      } catch (err) {\n        if (isMounted) {\n          setError(err.message);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    \n    fetchData();\n\n    // Cleanup function: set isMounted to false when component unmounts\n    return () => {\n      isMounted = false;\n    };\n  }, [url, options]); // Re-run effect if url or options change\n  \n  return { data, loading, error };\n}\n\n// Example Usage:\n/*\nfunction MyComponent() {\n  const { data, loading, error } = useFetch('https://jsonplaceholder.typicode.com/todos/1');\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error}</p>;\n\n  return (\n    <div>\n      <h1>Todo: {data?.title}</h1>\n      <p>Completed: {data?.completed ? 'Yes' : 'No'}</p>\n    </div>\n  );\n}\n*/\n```",
          "analysisPoints": [
            "Correct use of `useState` for `data`, `loading`, `error`.",
            "Correct use of `useEffect` to initiate fetching.",
            "Proper use of `async/await` with `fetch`.",
            "Handling `response.ok` for HTTP errors.",
            "Implementing `try...catch` for network and parsing errors.",
            "Correct implementation of the `isMounted` flag for cleanup to prevent memory leaks/warnings.",
            "Correct dependency array for `useEffect`."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "useEffect",
            "useState",
            "Data Fetching",
            "Fetch API",
            "Async/Await",
            "Error Handling",
            "Cleanup"
          ],
          "evaluationCriteria": [
            "Ability to create a custom hook",
            "Understanding of asynchronous patterns in React",
            "Correct use of `useEffect` cleanup"
          ],
          "example": "The provided code serves as the solution example.",
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Data Fetching",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React Hooks",
            "JavaScript Async/Await",
            "Fetch API"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_custom_hook_vs_hoc_rp_1",
          "topic": "Custom Hooks vs. HOCs/Render Props",
          "level": "hard",
          "type": "open",
          "question": "How do custom React hooks (`use...`) compare to Higher-Order Components (HOCs) and Render Props in terms of reusing stateful logic? Discuss their advantages and disadvantages.",
          "answer": "All three patterns (Custom Hooks, HOCs, Render Props) aim to reuse stateful logic in React. However, custom hooks generally offer a simpler and more intuitive approach.\n\n**1. Custom Hooks (`use...` functions):**\n*   **Concept:** Plain JavaScript functions that allow you to encapsulate and reuse stateful logic (e.g., `useState`, `useEffect`) directly within functional components.\n*   **Advantages:**\n    *   **Simplicity & Readability:** No wrapper components or deeply nested JSX. The logic is directly integrated into the component where it's needed.\n    *   **No Component Tree Changes:** They don't introduce extra layers into the component tree, avoiding issues like wrapper hell or prop collision.\n    *   **Flexible:** Can return any type of data (values, functions, objects) and can be combined easily.\n    *   **Easier Debugging:** Clearer flow of data compared to HOCs.\n*   **Disadvantages:**\n    *   **Rules of Hooks:** Must follow specific rules (call only at top level, only from React functions).\n    *   **Limited for UI Rendering:** Primarily for logic, not for injecting JSX or layout directly (though the logic they provide can drive UI).\n\n**2. Higher-Order Components (HOCs):**\n*   **Concept:** A function that takes a component as an argument and returns a new component with enhanced props or behavior.\n    ```javascript\n    const withAuth = (WrappedComponent) => {\n      return (props) => { /* logic */ return <WrappedComponent {...props} /> };\n    };\n    ```\n*   **Advantages:**\n    *   **Legacy Support:** Well-established pattern before hooks.\n    *   **Inject Props:** Can easily inject additional props into the wrapped component.\n*   **Disadvantages:**\n    *   **Wrapper Hell:** Can lead to a deeply nested component tree, making debugging harder.\n    *   **Name Collisions:** Can cause prop name clashes if the injected props have the same name as existing props.\n    *   **Implicit Props:** Props added by the HOC are not immediately visible in the component's signature, making it harder to understand what props a component expects.\n    *   **Non-standard Composition:** Not a standard React pattern, can feel less intuitive.\n\n**3. Render Props:**\n*   **Concept:** A pattern where a component takes a function as a prop, and that function (the 'render prop') is responsible for rendering the component's children, often with shared state or logic.\n    ```javascript\n    <DataSource render={({ data }) => <MyComponent data={data} />} />\n    ```\n*   **Advantages:**\n    *   **Explicit Data Flow:** Very clear about what data is being shared.\n    *   **Avoids Name Collisions:** No risk of prop name clashes.\n*   **Disadvantages:**\n    *   **Nested JSX:** Can lead to deeply nested JSX, making the render method harder to read (similar to callback hell).\n    *   **Performance:** Can sometimes lead to unnecessary re-renders if the render prop function is defined inline in the `render` method.\n\n**Conclusion:**\nCustom Hooks are generally preferred for reusing stateful logic due to their simplicity, flexibility, and the way they align with functional component paradigms. They solve many of the problems associated with HOCs (wrapper hell, prop collisions) and Render Props (nested JSX) while providing a cleaner API for logic reuse. HOCs and Render Props still have their use cases but are less common for general-purpose logic sharing since the introduction of Hooks.",
          "analysisPoints": [
            "Define each pattern (Custom Hooks, HOCs, Render Props).",
            "List specific advantages of Custom Hooks (simplicity, no wrapper hell, flexible).",
            "List specific disadvantages of Custom Hooks (Rules of Hooks).",
            "List specific advantages of HOCs (legacy).",
            "List specific disadvantages of HOCs (wrapper hell, prop collisions, implicit props).",
            "List specific advantages of Render Props (explicit data flow).",
            "List specific disadvantages of Render Props (nested JSX, performance).",
            "Provide a clear concluding statement on preference and why."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "HOCs",
            "Render Props",
            "Code Reusability",
            "Stateful Logic",
            "React Patterns",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Comprehensive knowledge of React's advanced patterns",
            "Ability to compare and contrast architectural choices",
            "Understanding of their respective trade-offs"
          ],
          "example": "See text for code examples of each pattern.",
          "tags": [
            "React",
            "Architecture",
            "Design Patterns",
            "Hooks",
            "HOC",
            "Render Props"
          ],
          "prerequisites": [
            "Advanced React",
            "Component Lifecycle"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_user_registration_form",
          "title": "Build a Controlled User Registration Form with Validation",
          "description": "\nCreate a React component `RegistrationForm` that allows a user to register with a username, email, and password. This form should:\n\n1.  Be a **controlled component**, managing input values using `useState` hooks.\n2.  Implement **client-side validation** for the following rules:\n    *   **Username:** Must be at least 3 characters long.\n    *   **Email:** Must be a valid email format (e.g., contains '@' and '.').\n    *   **Password:** Must be at least 6 characters long and contain at least one uppercase letter, one lowercase letter, and one number.\n    *   All fields are **required**.\n3.  Display **real-time error messages** below each input field if validation fails.\n4.  The submit button should be **disabled** if any field is invalid or empty.\n5.  On successful submission, log the form data to the console and display a success message. Prevent default form submission behavior.\n\nYour solution should demonstrate understanding of basic state management, controlled components, and event handling in React.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction RegistrationForm() {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  // State for errors\n  const [usernameError, setUsernameError] = useState('');\n  const [emailError, setEmailError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n\n  // Handlers for input changes\n  const handleUsernameChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setUsername(e.target.value);\n    // TODO: Add validation logic here or in a separate validate function\n  };\n\n  const handleEmailChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setEmail(e.target.value);\n    // TODO: Add validation logic\n  };\n\n  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setPassword(e.target.value);\n    // TODO: Add validation logic\n  };\n\n  // TODO: Add a general validation function that checks all fields\n  const validateForm = () => {\n    let isValid = true;\n    // Example: username validation\n    if (username.length < 3) {\n      setUsernameError('Username must be at least 3 characters.');\n      isValid = false;\n    } else {\n      setUsernameError('');\n    }\n\n    // TODO: Implement email and password validation\n    \n    return isValid;\n  };\n\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if (validateForm()) {\n      console.log('Form Submitted:', { username, email, password });\n      alert('Registration successful!');\n      // Reset form\n      setUsername('');\n      setEmail('');\n      setPassword('');\n    } else {\n      console.log('Form has errors.');\n    }\n  };\n\n  // Determine if submit button should be disabled\n  const isFormValid = username && email && password && !usernameError && !emailError && !passwordError;\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '15px', maxWidth: '400px', margin: 'auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Register</h2>\n      <div>\n        <label htmlFor=\"reg-username\">Username:</label>\n        <input \n          type=\"text\" \n          id=\"reg-username\"\n          value={username} \n          onChange={handleUsernameChange} \n        />\n        {usernameError && <p style={{ color: 'red', fontSize: '0.8em' }}>{usernameError}</p>}\n      </div>\n      <div>\n        <label htmlFor=\"reg-email\">Email:</label>\n        <input \n          type=\"email\" \n          id=\"reg-email\"\n          value={email} \n          onChange={handleEmailChange} \n        />\n        {emailError && <p style={{ color: 'red', fontSize: '0.8em' }}>{emailError}</p>}\n      </div>\n      <div>\n        <label htmlFor=\"reg-password\">Password:</label>\n        <input \n          type=\"password\" \n          id=\"reg-password\"\n          value={password} \n          onChange={handlePasswordChange} \n        />\n        {passwordError && <p style={{ color: 'red', fontSize: '0.8em' }}>{passwordError}</p>}\n      </div>\n      <button type=\"submit\" disabled={!isFormValid}>Register</button>\n    </form>\n  );\n}\n\nexport default RegistrationForm;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction RegistrationForm() {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const [usernameError, setUsernameError] = useState('');\n  const [emailError, setEmailError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n\n  // Effect to validate username whenever it changes\n  useEffect(() => {\n    if (username.length > 0 && username.length < 3) {\n      setUsernameError('Username must be at least 3 characters.');\n    } else {\n      setUsernameError('');\n    }\n  }, [username]);\n\n  // Effect to validate email whenever it changes\n  useEffect(() => {\n    const emailRegex = /^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\n    if (email.length > 0 && !emailRegex.test(email)) {\n      setEmailError('Please enter a valid email address.');\n    } else {\n      setEmailError('');\n    }\n  }, [email]);\n\n  // Effect to validate password whenever it changes\n  useEffect(() => {\n    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{6,}$/;\n    if (password.length > 0 && !passwordRegex.test(password)) {\n      setPasswordError('Password must be at least 6 characters, contain one uppercase, one lowercase, and one number.');\n    } else {\n      setPasswordError('');\n    }\n  }, [password]);\n\n  const validateAllFields = () => {\n    let isValid = true;\n\n    if (username.length < 3) { setUsernameError('Username must be at least 3 characters.'); isValid = false; }\n    else { setUsernameError(''); }\n\n    const emailRegex = /^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\n    if (!emailRegex.test(email)) { setEmailError('Please enter a valid email address.'); isValid = false; }\n    else { setEmailError(''); }\n\n    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{6,}$/;\n    if (!passwordRegex.test(password)) { setPasswordError('Password must be at least 6 characters, contain one uppercase, one lowercase, and one number.'); isValid = false; }\n    else { setPasswordError(''); }\n\n    return isValid;\n  };\n\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    // Validate all fields on submit, in case user didn't trigger all 'onChange' validations\n    if (validateAllFields()) {\n      console.log('Form Submitted:', { username, email, password });\n      alert('Registration successful!');\n      // Reset form\n      setUsername('');\n      setEmail('');\n      setPassword('');\n    } else {\n      console.log('Form has errors. Please fix them.');\n    }\n  };\n\n  // Check if all fields have non-empty values AND no current errors\n  const isFormValid = username.length > 0 && email.length > 0 && password.length > 0 &&\n                      !usernameError && !emailError && !passwordError;\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '15px', maxWidth: '400px', margin: 'auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Register</h2>\n      <div>\n        <label htmlFor=\"reg-username\">Username:</label>\n        <input \n          type=\"text\" \n          id=\"reg-username\"\n          value={username} \n          onChange={(e) => setUsername(e.target.value)} \n          onBlur={validateAllFields} // Validate on blur for immediate feedback\n        />\n        {usernameError && <p style={{ color: 'red', fontSize: '0.8em' }}>{usernameError}</p>}\n      </div>\n      <div>\n        <label htmlFor=\"reg-email\">Email:</label>\n        <input \n          type=\"email\" \n          id=\"reg-email\"\n          value={email} \n          onChange={(e) => setEmail(e.target.value)} \n          onBlur={validateAllFields}\n        />\n        {emailError && <p style={{ color: 'red', fontSize: '0.8em' }}>{emailError}</p>}\n      </div>\n      <div>\n        <label htmlFor=\"reg-password\">Password:</label>\n        <input \n          type=\"password\" \n          id=\"reg-password\"\n          value={password} \n          onChange={(e) => setPassword(e.target.value)} \n          onBlur={validateAllFields}\n        />\n        {passwordError && <p style={{ color: 'red', fontSize: '0.8em' }}>{passwordError}</p>}\n      </div>\n      <button type=\"submit\" disabled={!isFormValid}>Register</button>\n    </form>\n  );\n}\n\nexport default RegistrationForm;\n",
          "testCases": [
            "Empty form submission: Button should be disabled initially. Submitting empty form should display all required field errors.",
            "Valid inputs: Username 'testuser', Email 'test@example.com', Password 'Password123' should enable submit button and show success on submit.",
            "Invalid username: 'ab' should show 'Username must be at least 3 characters.' error.",
            "Invalid email: 'invalid-email' should show 'Please enter a valid email address.' error.",
            "Invalid password: 'abc' should show password complexity error. 'Abcdef' should show numeric complexity error. '123456' should show uppercase/lowercase complexity error.",
            "Mixing valid and invalid: Ensure only relevant error messages are displayed.",
            "Form reset: After successful submission, fields should clear.",
            "Dynamic button state: Button's disabled state should accurately reflect form validity in real-time."
          ],
          "hints": [
            "Use regular expressions for email and password validation.",
            "Consider using `useEffect` hooks to run validation logic whenever a specific input's state changes, providing real-time feedback.",
            "Ensure the `disabled` state of the submit button is a computed value based on all current input values and their respective validation states.",
            "A single `validateForm` function can be called on `onSubmit` to perform final validation before submission."
          ],
          "tags": [
            "React",
            "Forms",
            "useState",
            "Validation",
            "Controlled Components",
            "UX"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React State Management",
            "JavaScript Regular Expressions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_state_forms"
          ]
        },
        {
          "id": "task_user_settings_panel",
          "title": "Create a User Settings Panel with Persistent Preferences",
          "description": "\nBuild a React component `UserSettings` that allows a user to configure a few preferences. These preferences should persist across browser sessions using the `useLocalStorage` custom hook provided in the theory.\n\n1.  **Integrate `useLocalStorage`:** Use the `useLocalStorage` hook to manage the state of at least three different user settings (e.g., `theme` (light/dark), `notificationsEnabled` (boolean), `itemsPerPage` (number)).\n2.  **UI Elements:** Provide appropriate UI elements for each setting (e.g., radio buttons or a toggle for theme, a checkbox for notifications, a select dropdown or number input for items per page).\n3.  **Display Current Settings:** Clearly display the currently selected settings.\n4.  **Real-time Updates:** Ensure that changing a setting immediately updates the UI and persists the new value to `localStorage`.\n5.  **Initial Load:** When the component mounts, it should load the last saved settings from `localStorage`.\n6.  **Reset Button:** Include a 'Reset to Defaults' button that clears `localStorage` for these specific settings and reverts them to their initial default values.\n\nYour solution should demonstrate proper usage of a custom hook for state persistence and basic UI interaction.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport useLocalStorage from './useLocalStorage'; // Assume useLocalStorage is imported\n\nfunction UserSettings() {\n  // TODO: Use useLocalStorage for theme, notificationsEnabled, itemsPerPage\n  const [theme, setTheme] = useLocalStorage('user-theme', 'light'); // Example\n  const [notificationsEnabled, setNotificationsEnabled] = useLocalStorage('user-notifications', true);\n  const [itemsPerPage, setItemsPerPage] = useLocalStorage('user-items-per-page', 10);\n\n  const handleThemeChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setTheme(e.target.value);\n  };\n\n  const handleNotificationsToggle = () => {\n    setNotificationsEnabled(prev => !prev);\n  };\n\n  const handleItemsPerPageChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setItemsPerPage(Number(e.target.value));\n  };\n\n  const handleResetDefaults = () => {\n    // TODO: Reset all settings to their initial values\n    setTheme('light');\n    setNotificationsEnabled(true);\n    setItemsPerPage(10);\n    // Note: useLocalStorage itself handles saving the new defaults\n    // If you wanted to *remove* from localStorage, you'd call localStorage.removeItem(key)\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px', maxWidth: '500px', margin: '20px auto' }}>\n      <h2>User Settings</h2>\n      \n      <div>\n        <h3>Theme: {theme}</h3>\n        <label>\n          <input \n            type=\"radio\" \n            value=\"light\" \n            checked={theme === 'light'} \n            onChange={handleThemeChange} \n          /> Light\n        </label>\n        <label style={{ marginLeft: '10px' }}>\n          <input \n            type=\"radio\" \n            value=\"dark\" \n            checked={theme === 'dark'} \n            onChange={handleThemeChange} \n          /> Dark\n        </label>\n      </div>\n\n      <div style={{ marginTop: '15px' }}>\n        <h3>Notifications: {notificationsEnabled ? 'Enabled' : 'Disabled'}</h3>\n        <label>\n          <input \n            type=\"checkbox\" \n            checked={notificationsEnabled} \n            onChange={handleNotificationsToggle} \n          /> Enable Notifications\n        </label>\n      </div>\n\n      <div style={{ marginTop: '15px' }}>\n        <h3>Items Per Page: {itemsPerPage}</h3>\n        <select value={itemsPerPage} onChange={handleItemsPerPageChange}>\n          <option value={5}>5</option>\n          <option value={10}>10</option>\n          <option value={20}>20</option>\n        </select>\n      </div>\n\n      <button onClick={handleResetDefaults} style={{ marginTop: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n        Reset to Defaults\n      </button>\n      \n      <p style={{ marginTop: '20px', fontSize: '0.9em', color: '#666' }}>\n        Try changing settings, then close and reopen your browser tab to see persistence!\n      </p>\n    </div>\n  );\n}\n\nexport default UserSettings;\n\n// Make sure you have useLocalStorage.ts (or .js) available in the same directory\n// from the theory section:\n// import { useState, useEffect } from 'react';\n// function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T | ((prev: T) => T)) => void] {\n//   const [storedValue, setStoredValue] = useState<T>(() => {\n//     try { if (typeof window === 'undefined') { return initialValue; } const item = window.localStorage.getItem(key); return item ? JSON.parse(item) : initialValue; } catch (error) { console.error(\"Error reading from localStorage:\", error); return initialValue; }\n//   });\n//   useEffect(() => { try { if (typeof window !== 'undefined') { window.localStorage.setItem(key, JSON.stringify(storedValue)); } } catch (error) { console.error(\"Error writing to localStorage:\", error); } }, [key, storedValue]);\n//   return [storedValue, setStoredValue];\n// }\n",
          "solutionCode": "import React from 'react';\nimport useLocalStorage from './useLocalStorage'; // Assuming useLocalStorage.ts is in the same directory\n\n// Placeholder for useLocalStorage if not available directly\n// import { useState, useEffect } from 'react';\n// function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T | ((prev: T) => T)) => void] {\n//   const [storedValue, setStoredValue] = useState<T>(() => {\n//     try { \n//       if (typeof window === 'undefined') { return initialValue; }\n//       const item = window.localStorage.getItem(key);\n//       return item ? JSON.parse(item) : initialValue;\n//     } catch (error) {\n//       console.error(\"Error reading from localStorage:\", error);\n//       return initialValue;\n//     }\n//   });\n//   useEffect(() => {\n//     try {\n//       if (typeof window !== 'undefined') {\n//         window.localStorage.setItem(key, JSON.stringify(storedValue));\n//       }\n//     } catch (error) {\n//       console.error(\"Error writing to localStorage:\", error);\n//     }\n//   }, [key, storedValue]);\n//   return [storedValue, setStoredValue];\n// }\n\nfunction UserSettings() {\n  // Define default values explicitly\n  const DEFAULT_THEME = 'light';\n  const DEFAULT_NOTIFICATIONS_ENABLED = true;\n  const DEFAULT_ITEMS_PER_PAGE = 10;\n\n  // Use useLocalStorage for each setting\n  const [theme, setTheme] = useLocalStorage('user-theme', DEFAULT_THEME);\n  const [notificationsEnabled, setNotificationsEnabled] = useLocalStorage('user-notifications', DEFAULT_NOTIFICATIONS_ENABLED);\n  const [itemsPerPage, setItemsPerPage] = useLocalStorage('user-items-per-page', DEFAULT_ITEMS_PER_PAGE);\n\n  const handleThemeChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setTheme(e.target.value);\n    // The useLocalStorage hook handles the persistence automatically\n  };\n\n  const handleNotificationsToggle = () => {\n    setNotificationsEnabled(prev => !prev);\n  };\n\n  const handleItemsPerPageChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    // Ensure the value is parsed as a number\n    setItemsPerPage(Number(e.target.value));\n  };\n\n  const handleResetDefaults = () => {\n    // Simply set the state back to default values\n    // The useLocalStorage hook will automatically persist these new defaults\n    setTheme(DEFAULT_THEME);\n    setNotificationsEnabled(DEFAULT_NOTIFICATIONS_ENABLED);\n    setItemsPerPage(DEFAULT_ITEMS_PER_PAGE);\n\n    // Optional: If you wanted to explicitly clear from localStorage first for a true 'reset'\n    // window.localStorage.removeItem('user-theme');\n    // window.localStorage.removeItem('user-notifications');\n    // window.localStorage.removeItem('user-items-per-page');\n    // Then the next render cycle would pick up initial values, or you set them manually as above.\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px', maxWidth: '500px', margin: '20px auto', background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#333' }}>\n      <h2>User Settings</h2>\n      \n      <div>\n        <h3>Theme: {theme}</h3>\n        <label>\n          <input \n            type=\"radio\" \n            value=\"light\" \n            checked={theme === 'light'} \n            onChange={handleThemeChange} \n          /> Light\n        </label>\n        <label style={{ marginLeft: '10px' }}>\n          <input \n            type=\"radio\" \n            value=\"dark\" \n            checked={theme === 'dark'} \n            onChange={handleThemeChange} \n          /> Dark\n        </label>\n      </div>\n\n      <div style={{ marginTop: '15px' }}>\n        <h3>Notifications: {notificationsEnabled ? 'Enabled' : 'Disabled'}</h3>\n        <label>\n          <input \n            type=\"checkbox\" \n            checked={notificationsEnabled} \n            onChange={handleNotificationsToggle} \n          /> Enable Notifications\n        </label>\n      </div>\n\n      <div style={{ marginTop: '15px' }}>\n        <h3>Items Per Page: {itemsPerPage}</h3>\n        <select value={itemsPerPage} onChange={handleItemsPerPageChange}>\n          <option value={5}>5</option>\n          <option value={10}>10</option>\n          <option value={20}>20</option>\n          <option value={50}>50</option>\n        </select>\n      </div>\n\n      <button onClick={handleResetDefaults} style={{ marginTop: '20px', padding: '10px 15px', cursor: 'pointer', backgroundColor: theme === 'dark' ? '#555' : '#eee', color: theme === 'dark' ? '#fff' : '#333', border: '1px solid #777', borderRadius: '4px' }}>\n        Reset to Defaults\n      </button>\n      \n      <p style={{ marginTop: '20px', fontSize: '0.9em', color: theme === 'dark' ? '#bbb' : '#666' }}>\n        Try changing settings, then close and reopen your browser tab to see persistence!\n      </p>\n    </div>\n  );\n}\n\nexport default UserSettings;\n",
          "testCases": [
            "Initial load: Verify that refreshing the page or closing/reopening the tab correctly loads the last saved settings from `localStorage`.",
            "Theme change: Change theme to 'dark', refresh, verify it's still 'dark'.",
            "Notifications toggle: Toggle notifications off, refresh, verify they are off.",
            "Items per page change: Set to 20, refresh, verify it's 20.",
            "Mixed changes: Change all settings, refresh, verify all persist correctly.",
            "Reset defaults: Click 'Reset to Defaults', verify settings revert to initial values ('light', true, 10) and persist after refresh.",
            "Error handling (manual test): If possible, simulate `localStorage` quota exceeded (e.g., by filling it manually with large data in browser dev tools) and observe error logging in console without app crash."
          ],
          "hints": [
            "Remember that `useLocalStorage` itself handles the saving and loading. Your component just needs to use the returned `state` and `setState`.",
            "For the 'Reset to Defaults' button, simply call the `setState` functions returned by `useLocalStorage` with their respective default values.",
            "Ensure number inputs or select dropdowns correctly parse their `event.target.value` to a `number` if your initial state is a number, as `input.value` is always a string."
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "LocalStorage",
            "State Persistence",
            "UI/UX"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_custom_hook_use_local_storage",
            "React State Management"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useLocalStorage",
            "useState",
            "useEffect",
            "LocalStorage API"
          ]
        },
        {
          "id": "task_fetch_display_posts",
          "title": "Display Blog Posts from an API using useFetch",
          "description": "\nCreate a React component `BlogPostViewer` that fetches and displays a list of blog posts from a public API. Utilize the `useFetch` custom hook provided in the theory to handle data fetching logic.\n\n1.  **Integrate `useFetch`:** Use the `useFetch` hook to fetch data from `https://jsonplaceholder.typicode.com/posts`.\n2.  **Handle Loading State:** Display a 'Loading...' message while the data is being fetched.\n3.  **Handle Error State:** Display an appropriate error message if the fetch request fails.\n4.  **Display Data:** Once data is successfully fetched, render a list of blog post titles and bodies.\n5.  **No Data State:** Display a 'No posts found.' message if the API returns an empty array or `null`.\n6.  **Refresh Button:** Add a button that re-fetches the data when clicked (hint: consider how to make `useFetch` re-run).\n\nYour solution should demonstrate proper consumption of a custom data fetching hook and robust UI handling for asynchronous operations.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\nimport useFetch from './useFetch'; // Assume useFetch is imported\n\n// Define a type for a single Post if using TypeScript\ninterface Post {\n  userId: number;\n  id: number;\n  title: string;\n  body: string;\n}\n\nfunction BlogPostViewer() {\n  const [refreshKey, setRefreshKey] = useState(0);\n  const apiUrl = 'https://jsonplaceholder.typicode.com/posts';\n  \n  // TODO: Use useFetch hook here, ensuring it re-runs when refreshKey changes\n  // const { data: posts, loading, error } = useFetch<Post[]>(apiUrl);\n  const { data: posts, loading, error } = useFetch<Post[]>(apiUrl + `?refresh=${refreshKey}`); // Example of making URL dynamic\n\n  const handleRefresh = () => {\n    // TODO: Implement logic to trigger a re-fetch.\n    setRefreshKey(prev => prev + 1);\n  };\n\n  if (loading) {\n    return <p>Loading posts...</p>;\n  }\n\n  if (error) {\n    return <p style={{ color: 'red' }}>Error: {error}</p>;\n  }\n\n  if (!posts || posts.length === 0) {\n    return <p>No posts found.</p>;\n  }\n\n  return (\n    <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n      <h1>Blog Posts</h1>\n      <button onClick={handleRefresh} style={{ marginBottom: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n        Refresh Posts\n      </button>\n      {\n        // TODO: Map over posts and display them\n      }\n      <ul>\n        {posts.map(post => (\n          <li key={post.id} style={{ marginBottom: '20px', borderBottom: '1px solid #eee', paddingBottom: '15px' }}>\n            <h3>{post.title}</h3>\n            <p>{post.body}</p>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default BlogPostViewer;\n\n// Make sure you have useFetch.ts (or .js) available in the same directory\n// from the theory section:\n// import { useState, useEffect } from 'react';\n// function useFetch<T>(url: string, options?: RequestInit): { data: T | null; loading: boolean; error: string | null; } {\n//   const [data, setData] = useState<T | null>(null);\n//   const [loading, setLoading] = useState<boolean>(true);\n//   const [error, setError] = useState<string | null>(null);\n//   useEffect(() => { let isMounted = true; setLoading(true); setError(null); const fetchData = async () => { try { const response = await fetch(url, options); if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); } const json: T = await response.json(); if (isMounted) { setData(json); setError(null); } } catch (e) { const errorMessage = (e instanceof Error) ? e.message : String(e); if (isMounted) { setError(errorMessage); setData(null); } } finally { if (isMounted) { setLoading(false); } } }; fetchData(); return () => { isMounted = false; }; }, [url, options]); return { data, loading, error };\n// }\n",
          "solutionCode": "import React, { useState } from 'react';\nimport useFetch from './useFetch'; // Assuming useFetch.ts is in the same directory\n\n// Placeholder for useFetch if not available directly\n// import { useState, useEffect } from 'react';\n// interface FetchOptions extends RequestInit {}\n// interface FetchResult<T> {\n//   data: T | null;\n//   loading: boolean;\n//   error: string | null;\n// }\n// function useFetch<T>(url: string, options?: FetchOptions): FetchResult<T> {\n//   const [data, setData] = useState<T | null>(null);\n//   const [loading, setLoading] = useState<boolean>(true);\n//   const [error, setError] = useState<string | null>(null);\n  \n//   useEffect(() => {\n//     let isMounted = true;\n//     setLoading(true);\n//     setError(null);\n//     setData(null); // Clear previous data on re-fetch\n    \n//     const fetchData = async () => {\n//       try {\n//         const response = await fetch(url, options);\n//         if (!response.ok) {\n//           throw new Error(`HTTP error! Status: ${response.status} - ${response.statusText}`);\n//         }\n        \n//         const json: T = await response.json();\n//         if (isMounted) {\n//           setData(json);\n//           setError(null);\n//         }\n//       } catch (e) {\n//         const errorMessage = (e instanceof Error) ? e.message : String(e);\n//         if (isMounted) {\n//           setError(errorMessage);\n//           setData(null);\n//         }\n//       } finally {\n//         if (isMounted) {\n//           setLoading(false);\n//         }\n//       }\n//     };\n    \n//     fetchData();\n//     return () => {\n//       isMounted = false;\n//     };\n//   }, [url, options]);\n  \n//   return { data, loading, error };\n// }\n\ninterface Post {\n  userId: number;\n  id: number;\n  title: string;\n  body: string;\n}\n\nfunction BlogPostViewer() {\n  const [refreshKey, setRefreshKey] = useState(0); // State to trigger re-fetch\n  \n  // Append refreshKey to URL to make it a dependency of useFetch,\n  // causing it to re-run when refreshKey changes.\n  const apiUrl = `https://jsonplaceholder.typicode.com/posts?_t=${refreshKey}`;\n  \n  const { data: posts, loading, error } = useFetch<Post[]>(apiUrl);\n\n  const handleRefresh = () => {\n    setRefreshKey(prevKey => prevKey + 1);\n  };\n\n  if (loading) {\n    return (\n      <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n        <h1>Blog Posts</h1>\n        <p>Loading posts...</p>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n        <h1>Blog Posts</h1>\n        <p style={{ color: 'red' }}>Error fetching posts: {error}</p>\n        <button onClick={handleRefresh} style={{ marginTop: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n          Try Again\n        </button>\n      </div>\n    );\n  }\n\n  if (!posts || posts.length === 0) {\n    return (\n      <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n        <h1>Blog Posts</h1>\n        <p>No posts found.</p>\n        <button onClick={handleRefresh} style={{ marginTop: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n          Fetch Posts\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n      <h1>Blog Posts</h1>\n      <button onClick={handleRefresh} style={{ marginBottom: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n        Refresh Posts\n      </button>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id} style={{ marginBottom: '20px', borderBottom: '1px solid #eee', paddingBottom: '15px' }}>\n            <h3>{post.title}</h3>\n            <p>{post.body}</p>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default BlogPostViewer;\n",
          "testCases": [
            "Initial load: Verify 'Loading...' message appears, then posts are displayed.",
            "Successful fetch: Ensure all post titles and bodies are rendered correctly (check browser console for network requests).",
            "Refresh functionality: Click 'Refresh Posts', verify the UI shows 'Loading...' briefly and then re-displays posts. Check network tab for new request.",
            "Simulate network error: (e.g., go offline in browser dev tools, or provide an invalid URL like `https://jsonplaceholder.typicode.com/invalid-url`) Verify 'Error: ...' message is displayed.",
            "Simulate empty data: (e.g., modify the API response in dev tools to an empty array `[]`) Verify 'No posts found.' message.",
            "Component unmount/mount: (e.g., render/unrender `BlogPostViewer` quickly using a parent component's state) Verify no console warnings about setting state on unmounted components."
          ],
          "hints": [
            "To force `useFetch` to re-run, its `url` dependency (or `options`) needs to change. You can achieve this by adding a dummy query parameter to the URL that changes when the refresh button is clicked (e.g., `?_t=${timestamp}` or `?refresh=${refreshCounter}`).",
            "Ensure your `useFetch` hook clears previous `data` and `error` states and sets `loading` to `true` at the beginning of each fetch cycle to properly reflect UI status."
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Data Fetching",
            "Fetch API",
            "UI States"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_custom_hook_use_fetch",
            "React State Management"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useFetch",
            "useState",
            "useEffect",
            "Error Handling",
            "Async/Await"
          ]
        }
      ]
    }
  },
  {
    "id": "2f957036-eb34-437c-bcd0-a40628a380f4",
    "startLine": 5700,
    "endLine": 5799,
    "processedDate": "2025-06-17T09:44:34.311Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_use_fetch_hook",
          "title": "Understanding the useFetch Hook for Asynchronous Data",
          "content": "The `useFetch` custom hook is designed to simplify data fetching logic within React components, abstracting away the complexities of `useState` and `useEffect` for managing loading, error, and data states. This hook encapsulates the common pattern of making API requests, providing a reusable and clean interface.\n\n## Key Concepts\n*   **State Management:** It internally uses `useState` to manage three crucial pieces of state: `data` (for the fetched payload), `loading` (a boolean indicating if a request is in progress), and `error` (for any errors encountered during the fetch).\n*   **Side Effects with `useEffect`:** The actual data fetching logic is housed within a `useEffect` hook. This ensures the fetch operation runs when the component mounts and re-runs if any of its dependencies (`url`, `options`) change.\n*   **Dependency Array:** The `useEffect`'s dependency array `[url, options]` ensures that the fetch operation is re-triggered only when the URL or fetch options change. It's crucial to correctly manage dependencies to prevent unnecessary re-fetches or stale data.\n*   **Asynchronous Operations:** The `fetchData` function is asynchronous (`async/await`) to handle the promise-based nature of the `fetch` API. It wraps the `fetch` call in a `try-catch` block to gracefully handle network errors or invalid responses.\n*   **Preventing Memory Leaks (`isMounted`):** A critical aspect of this `useFetch` implementation is the `isMounted` flag. This boolean variable, initialized to `true` and set to `false` in the `useEffect`'s cleanup function, prevents state updates on an unmounted component. This avoids the common React warning: \"Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.\" This is particularly important for slow network requests where the component might unmount before the fetch promise resolves.\n*   **Abstraction and Reusability:** By encapsulating the fetching logic into a custom hook, components using `useFetch` become cleaner and more focused on rendering data rather than managing fetch lifecycle.\n\n## Implementation Details\nThe hook returns an object `{ data, loading, error }`, making it easy for consuming components to access the current state of the data fetching operation. The `options` parameter allows for flexibility in configuring the `fetch` request, such as setting HTTP methods, headers, or body for POST/PUT requests.\n\nWhen `options` is an object, it's important to memoize it (e.g., using `useMemo` in the calling component) if it's not a primitive, to prevent the `useEffect` from re-running on every render due to reference equality changes, even if the content of the options object is conceptually the same.\n\n",
          "examples": [
            {
              "id": "example_use_fetch_basic",
              "title": "Basic useFetch Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\nfunction useFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        if (isMounted) {\n          setData(result);\n        }\n      } catch (e) {\n        if (isMounted) {\n          setError(e.message);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted = false; // Set to false on unmount\n    };\n  }, [url, options]); // Re-run effect when url or options change\n\n  return { data, loading, error };\n}",
              "explanation": "This code defines the `useFetch` hook. It initializes `data`, `loading`, and `error` states. The `useEffect` hook performs the asynchronous data fetch. The `isMounted` flag is a crucial pattern to prevent memory leaks and 'Can't perform a React state update on an unmounted component' warnings, ensuring state is only updated if the component is still mounted. The `finally` block ensures `setLoading(false)` is called whether the fetch succeeds or fails. The hook returns an object with the current data, loading status, and any error.",
              "language": "typescript"
            },
            {
              "id": "example_use_fetch_usage",
              "title": "Usage of useFetch Hook",
              "code": "import React from 'react';\n// Assume useFetch is imported from the file above\n\nfunction UserProfile({ userId }) {\n  const { data, loading, error } = useFetch(\n    `https://api.example.com/users/${userId}`\n  );\n\n  if (loading) return <div>Loading user profile...</div>;\n  if (error) return <div>Error loading user: {error}</div>;\n  if (!data) return <div>No user data found.</div>; // Handle case where data is null initially or after error\n\n  return (\n    <div>\n      <h2>{data.name}</h2>\n      <p>Email: {data.email}</p>\n      <p>ID: {userId}</p>\n    </div>\n  );\n}",
              "explanation": "This `UserProfile` component demonstrates how to consume the `useFetch` hook. It destructurizes `data`, `loading`, and `error` from the hook's return value. Based on the `loading` and `error` states, it renders different UI feedback. Once data is successfully fetched and available, it renders the user's name and email.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_fetch_1",
            "question_use_fetch_2",
            "question_use_fetch_3",
            "question_use_fetch_4",
            "question_use_fetch_5",
            "question_use_fetch_6",
            "question_use_fetch_7",
            "question_use_fetch_8",
            "question_use_fetch_9",
            "question_use_fetch_10"
          ],
          "relatedTasks": [
            "task_use_fetch_1",
            "task_use_fetch_2"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "Data Fetching",
            "Asynchronous",
            "API Integration",
            "Custom Hooks",
            "Error Handling",
            "Loading States",
            "Memory Leaks"
          ],
          "technology": "React",
          "prerequisites": [
            "useState",
            "useEffect",
            "Asynchronous JavaScript (Promises, async/await)",
            "Fetch API"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Building custom data hooks",
            "Complex form submissions",
            "Real-time data updates"
          ]
        },
        {
          "id": "theory_use_media_query_hook",
          "title": "Implementing the useMediaQuery Hook for Responsive Design",
          "content": "The `useMediaQuery` custom hook provides a declarative way to incorporate responsive design logic directly into React components. Instead of relying solely on CSS media queries, this hook allows components to dynamically adjust their rendering based on viewport characteristics, enabling more complex layout adaptations or feature toggles.\n\n## Key Concepts\n*   **CSS Media Queries in JavaScript:** It leverages the `window.matchMedia()` Web API. This API allows JavaScript to programmatically test and monitor CSS media queries. `window.matchMedia(query)` returns a `MediaQueryList` object.\n*   **`MediaQueryList` Object:** The `MediaQueryList` object has a `matches` property (a boolean indicating if the document currently matches the media query) and methods (`addEventListener`, `removeEventListener`) to listen for changes in the media query status.\n*   **State Management:** The hook uses `useState` to store the `matches` boolean, which reflects whether the provided media query currently applies.\n*   **Event Listeners and Cleanup:** A `useEffect` hook is used to set up and tear down an event listener. When the component mounts, it attaches a `change` event listener to the `MediaQueryList` object. This listener updates the `matches` state whenever the media query status changes (e.g., when the viewport crosses a breakpoint). The cleanup function returned by `useEffect` is crucial for performance and preventing memory leaks; it removes the event listener when the component unmounts or before the effect re-runs if the `query` dependency changes.\n*   **Dynamic UI:** By returning the `matches` boolean, the consuming component can use conditional rendering to display different layouts or components based on the current screen size or other media features.\n\n## Implementation Details\nThe `useEffect` hook runs once when the component mounts (due to initial empty dependency array or when `query` changes). It initializes the `matches` state with the current status of the media query. The `listener` function is simple: it directly updates the state based on the `e.matches` property from the event object. This hook is highly efficient as it only re-renders the component when the `matches` status actually changes.\n",
          "examples": [
            {
              "id": "example_use_media_query_basic",
              "title": "Basic useMediaQuery Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\nfunction useMediaQuery(query) {\n  const [matches, setMatches] = useState(false);\n  \n  useEffect(() => {\n    // Check if window is defined (for SSR compatibility)\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const mediaQuery = window.matchMedia(query);\n    setMatches(mediaQuery.matches); // Initialize state with current match status\n    \n    // Define the listener function\n    const listener = (e) => setMatches(e.matches);\n    \n    // Add event listener for changes\n    mediaQuery.addEventListener('change', listener);\n    \n    // Cleanup function: remove event listener on unmount or query change\n    return () => mediaQuery.removeEventListener('change', listener);\n  }, [query]); // Re-run effect if the media query string changes\n  \n  return matches;\n}",
              "explanation": "This code defines the `useMediaQuery` hook. It initializes `matches` state to `false`. Inside `useEffect`, it uses `window.matchMedia` to create a `MediaQueryList` object. It sets the initial `matches` state and then adds a `change` event listener to `mediaQuery`. The listener updates the `matches` state whenever the media query condition changes. The cleanup function ensures the event listener is removed when the component unmounts or the `query` changes, preventing memory leaks.",
              "language": "typescript"
            },
            {
              "id": "example_use_media_query_usage",
              "title": "Usage of useMediaQuery Hook for Responsive Layouts",
              "code": "import React from 'react';\n// Assume useMediaQuery is imported from the file above\nimport MobileLayout from './MobileLayout';\nimport DesktopLayout from './DesktopLayout';\n\nfunction ResponsiveComponent() {\n  // Check for mobile screens (e.g., width up to 768px)\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  \n  // Check for print media\n  const isPrint = useMediaQuery('print');\n\n  return (\n    <div>\n      <h1>Responsive Content</h1>\n      {isMobile ? (\n        <MobileLayout />\n      ) : (\n        <DesktopLayout />\n      )}\n      {isPrint && <p>This content is optimized for printing.</p>}\n    </div>\n  );\n}",
              "explanation": "This `ResponsiveComponent` uses the `useMediaQuery` hook to dynamically render either a `MobileLayout` or `DesktopLayout` based on the screen width. It also demonstrates checking for `print` media, showing how flexible the hook is for various media query types. This allows for fine-grained control over UI rendering based on specific environmental factors.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_media_query_1",
            "question_use_media_query_2",
            "question_use_media_query_3",
            "question_media_query_performance",
            "question_media_query_server_side",
            "question_use_media_query_4",
            "question_use_media_query_5"
          ],
          "relatedTasks": [
            "task_use_media_query_1",
            "task_use_media_query_2"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "Responsive Design",
            "Media Queries",
            "Web API",
            "Custom Hooks",
            "UI/UX",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "useState",
            "useEffect",
            "CSS Media Queries",
            "JavaScript Event Listeners"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Building adaptive UIs",
            "Component-level responsive logic",
            "Accessibility enhancements"
          ]
        },
        {
          "id": "theory_use_debounce_hook",
          "title": "Mastering the useDebounce Hook for Performance Optimization",
          "content": "The `useDebounce` custom hook is an essential tool for optimizing performance in React applications, particularly when dealing with frequently firing events like typing in a search input, resizing a window, or scrolling. Debouncing ensures that a function is not called until a certain amount of time has passed since the last time it was invoked.\n\n## Key Concepts\n*   **Debouncing Principle:** The core idea of debouncing is to delay an action until a specified `delay` has passed without any further triggers. If the action is triggered again before the delay expires, the timer is reset.\n*   **`setTimeout` and `clearTimeout`:** The hook relies heavily on JavaScript's `setTimeout` for scheduling the delayed update and `clearTimeout` for canceling any pending timers. This cancellation is crucial for the debouncing effect.\n*   **State Management:** It uses `useState` to hold the `debouncedValue`, which is the value that will eventually be returned after the debounce `delay` has passed.\n*   **`useEffect` for Lifecycle Management:** The `useEffect` hook is responsible for managing the `setTimeout` timer. It runs whenever the `value` or `delay` dependencies change.\n*   **Cleanup Function:** The cleanup function returned by `useEffect` is vital: `return () => { clearTimeout(handler); }`. It ensures that if the `value` changes again *before* the `delay` expires, the previous timeout is cleared, preventing the old, outdated `debouncedValue` from being set. It also clears the timeout when the component unmounts, preventing potential errors or unnecessary operations.\n*   **Common Use Cases:**\n    *   **Search Bars:** Prevents sending an API request on every keystroke, instead waiting for the user to pause typing.\n    *   **Window Resizing:** Avoids frequent re-renders or recalculations during continuous window resizing.\n    *   **Input Validation:** Delays validation checks until the user stops typing, improving responsiveness.\n\n## Implementation Details\nThe `useDebounce` hook takes two arguments: the `value` to be debounced and the `delay` in milliseconds. The `useEffect` sets a timeout to update the `debouncedValue` after `delay`. If `value` changes before `delay` runs out, the previous timeout is cleared, and a new one is set. This effectively delays the `debouncedValue` update until the `value` has been stable for the specified `delay`.\n",
          "examples": [
            {
              "id": "example_use_debounce_basic",
              "title": "Basic useDebounce Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    // Set up a timeout to update the debounced value after the delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    // Cleanup function: cancel the timeout if value or delay changes, or on unmount\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]); // Re-run effect if value or delay changes\n  \n  return debouncedValue;\n}",
              "explanation": "This code defines the `useDebounce` hook. It maintains `debouncedValue` state. Inside `useEffect`, it sets a `setTimeout` to update `debouncedValue` after `delay` milliseconds. Crucially, the cleanup function `clearTimeout(handler)` ensures that if the `value` changes before the `delay` is over, the previous timeout is cancelled, and a new one is started. This prevents intermediate values from triggering effects.",
              "language": "typescript"
            },
            {
              "id": "example_use_debounce_usage",
              "title": "Usage of useDebounce Hook for a Search Input",
              "code": "import React, { useState, useEffect } from 'react';\n// Assume useDebounce is imported from the file above\n\nfunction SearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  // Debounce the search term by 500ms\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n\n  // Effect to perform actual search when debouncedSearchTerm changes\n  useEffect(() => {\n    if (debouncedSearchTerm) {\n      console.log(`Performing search for: \"${debouncedSearchTerm}\"...`);\n      // Here you would typically make an API call using debouncedSearchTerm\n      // For example: fetch(`/api/search?q=${debouncedSearchTerm}`);\n    } else {\n      console.log('Search term cleared.');\n    }\n  }, [debouncedSearchTerm]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Type to search...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ padding: '10px', width: '300px', fontSize: '16px' }}\n      />\n      <p>Current input: {searchTerm}</p>\n      <p>Debounced search: {debouncedSearchTerm}</p>\n    </div>\n  );\n}",
              "explanation": "This `SearchComponent` demonstrates a common use case for `useDebounce`. The `searchTerm` state updates immediately as the user types. However, the `useEffect` that simulates an API call only triggers when `debouncedSearchTerm` changes, which happens only after the user has paused typing for 500 milliseconds. This significantly reduces the number of API calls, improving performance and reducing server load.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_debounce_1",
            "question_use_debounce_2",
            "question_use_debounce_3",
            "question_use_debounce_4",
            "question_debounce_throttle_diff",
            "question_debounce_real_world"
          ],
          "relatedTasks": [
            "task_use_debounce_1",
            "task_use_debounce_2"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "Debounce",
            "Performance Optimization",
            "Custom Hooks",
            "Timers",
            "Search Input",
            "Event Handling"
          ],
          "technology": "React",
          "prerequisites": [
            "useState",
            "useEffect",
            "setTimeout",
            "clearTimeout",
            "Event Handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Building high-performance UIs",
            "Optimizing API calls",
            "Responsive event handling"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_use_fetch_1",
          "topic": "useFetch Hook - Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What primary React hooks are typically used internally when creating a `useFetch` custom hook?",
          "answer": "`useState` to manage data, loading, and error states; and `useEffect` to perform the side effect of fetching data.",
          "options": [],
          "analysisPoints": [
            "Identifies core React hooks for state and side effects.",
            "Understands the role of each hook in data fetching."
          ],
          "keyConcepts": [
            "useState",
            "useEffect",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Recall of fundamental React hook usage.",
            "Understanding of state management and side effects."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Fundamentals",
            "useFetch"
          ],
          "prerequisites": [
            "useState",
            "useEffect"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_fetch_2",
          "topic": "useFetch Hook - Cleanup and Memory Leaks",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `useFetch` hook's `useEffect` cleanup function. What is the main purpose of `isMounted = false;` in the return function?\n\n```javascript\n  useEffect(() => {\n    let isMounted = true;\n    const fetchData = async () => {\n      // ... fetch logic ...\n      if (isMounted) {\n        setData(result);\n      }\n      // ...\n    };\n    fetchData();\n    return () => {\n      isMounted = false;\n    };\n  }, [url, options]);\n```",
          "answer": "To prevent state updates on an unmounted component, which would otherwise lead to memory leak warnings.",
          "options": [
            "To reset the `isMounted` flag for the next fetch request.",
            "To signal that the data fetching process has completed successfully.",
            "To prevent state updates on an unmounted component, which would otherwise lead to memory leak warnings.",
            "To cancel the ongoing fetch request if the component unmounts."
          ],
          "analysisPoints": [
            "Tests understanding of `useEffect` cleanup.",
            "Highlights the common 'memory leak' warning in React.",
            "Distinguishes between preventing state updates and cancelling network requests (which requires `AbortController`)."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Memory Leaks",
            "Component Lifecycle",
            "useFetch"
          ],
          "evaluationCriteria": [
            "Knowledge of `useEffect` cleanup mechanisms.",
            "Ability to identify and address common React warnings/issues.",
            "Differentiation between `isMounted` flag and `AbortController`."
          ],
          "example": "The `isMounted` flag is a standard pattern in older React codebases (before React 18's automatic batching and `useSyncExternalStore` for external state) to prevent attempts to update state on a component that has already been removed from the DOM. If a fetch request finishes after the component unmounts, calling `setData` or `setError` on an unmounted component will cause React to issue a warning about potential memory leaks.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Memory Leaks",
            "Best Practices",
            "MCQ"
          ],
          "prerequisites": [
            "useEffect",
            "Component Lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_fetch_3",
          "topic": "useFetch Hook - Dependency Array",
          "level": "medium",
          "type": "open",
          "question": "Explain the significance of the `[url, options]` dependency array in the `useFetch` hook's `useEffect`. What happens if `options` is an object literal created inline within the component that calls `useFetch`?",
          "answer": "The `[url, options]` dependency array tells `useEffect` to re-run the `fetchData` function whenever the `url` string or the `options` object reference changes. This ensures that new data is fetched when the source or the request configuration changes.\n\nIf `options` is an object literal created inline (e.g., `const { data } = useFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' } });`), a *new* object reference is created on every re-render of the calling component. Since JavaScript compares objects by reference, this new object, even if its contents are identical to the previous one, will be considered a 'change' by `useEffect`. Consequently, the `useFetch` hook's effect will re-run on every render, leading to an infinite loop of data fetches or excessive, unnecessary API calls. To prevent this, the `options` object should be memoized using `useMemo` in the consuming component, or defined outside the component if it's static.",
          "analysisPoints": [
            "Understanding of `useEffect` dependency array mechanics.",
            "Knowledge of JavaScript object reference equality.",
            "Ability to identify and troubleshoot infinite re-renders/unnecessary API calls.",
            "Proposing solutions like `useMemo` for memoization."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Object Equality",
            "Memoization",
            "useMemo",
            "Performance"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `useEffect` dependencies.",
            "Demonstrates understanding of JS object comparison.",
            "Identifies and solves a common React performance pitfall."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Performance",
            "Interview Question"
          ],
          "prerequisites": [
            "useEffect",
            "JavaScript Object References"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_4",
          "topic": "useFetch Hook - Error Handling",
          "level": "easy",
          "type": "flashcard",
          "question": "How does the `useFetch` hook handle HTTP errors (e.g., 404 Not Found or 500 Internal Server Error)?",
          "answer": "It checks `response.ok`. If `false`, it throws an `Error` which is then caught by the `try-catch` block, setting the `error` state.",
          "options": [],
          "analysisPoints": [
            "Recognizes the `response.ok` property of the `Fetch` API.",
            "Understands `try-catch` block for error propagation and state update."
          ],
          "keyConcepts": [
            "Fetch API",
            "Error Handling",
            "Async/Await",
            "useFetch"
          ],
          "evaluationCriteria": [
            "Knowledge of `fetch` response properties.",
            "Basic understanding of `try-catch`."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Error Handling",
            "Flashcard"
          ],
          "prerequisites": [
            "Fetch API",
            "Async/Await"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_fetch_5",
          "topic": "useFetch Hook - Advanced Features",
          "level": "hard",
          "type": "code",
          "question": "Modify the `useFetch` hook to include a `refetch` function that can be called externally to re-run the fetch operation. Additionally, implement an `AbortController` to cancel the ongoing fetch request if the component unmounts or a new fetch request is initiated.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Ability to extend existing custom hooks.",
            "Correctly implementing `useCallback` for stable function references.",
            "Proper usage of `AbortController` for request cancellation.",
            "Managing `useEffect` dependencies with the new `refetch` mechanism."
          ],
          "keyConcepts": [
            "useCallback",
            "AbortController",
            "Data Fetching",
            "Custom Hooks",
            "Performance"
          ],
          "evaluationCriteria": [
            "Practical application of `useCallback` and `AbortController`.",
            "Demonstrates advanced React hook patterns.",
            "Handles complex side effect scenarios (cancellation, manual re-trigger)."
          ],
          "example": "```typescript\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\nfunction useFetchWithRefetchAndAbort(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const controllerRef = useRef(null); // To store AbortController\n\n  const fetchData = useCallback(async () => {\n    // Abort any previous request if active\n    if (controllerRef.current) {\n      controllerRef.current.abort();\n    }\n    const controller = new AbortController();\n    controllerRef.current = controller;\n    const signal = controller.signal;\n\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await fetch(url, { ...options, signal });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      setData(result);\n    } catch (e) {\n      if (e.name === 'AbortError') {\n        console.log('Fetch aborted');\n        return; // Don't set error for aborted requests\n      }\n      setError(e.message);\n    } finally {\n      setLoading(false);\n      controllerRef.current = null; // Clear controller once request is done/aborted\n    }\n  }, [url, options]); // fetchData itself is memoized\n\n  useEffect(() => {\n    fetchData(); // Initial fetch and re-fetch on url/options change\n\n    return () => {\n      // Abort request on component unmount or when effect re-runs\n      if (controllerRef.current) {\n        controllerRef.current.abort();\n      }\n    };\n  }, [fetchData]); // Dependency on memoized fetchData\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// Usage Example:\n// function UserProfile({ userId }) {\n//   const { data, loading, error, refetch } = useFetchWithRefetchAndAbort(\n//     `https://api.example.com/users/${userId}`\n//   );\n\n//   if (loading) return <div>Loading user profile...</div>;\n//   if (error) return <div>Error loading user: {error}</div>;\n//   if (!data) return <div>No user data found.</div>;\n\n//   return (\n//     <div>\n//       <h2>{data.name}</h2>\n//       <p>Email: {data.email}</p>\n//       <button onClick={refetch}>Refresh User Data</button>\n//     </div>\n//   );\n// }\n```",
          "tags": [
            "React",
            "Hooks",
            "useFetch",
            "AbortController",
            "useCallback",
            "Advanced",
            "Code Challenge"
          ],
          "prerequisites": [
            "useCallback",
            "Fetch API",
            "Promises",
            "Error Handling"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_6",
          "topic": "useFetch Hook - Comparison",
          "level": "medium",
          "type": "open",
          "question": "What are the advantages of using a custom `useFetch` hook over performing data fetching directly inside a `useEffect` hook in each component?",
          "answer": "Using a custom `useFetch` hook offers several advantages:\n1.  **Reusability:** The fetching logic is centralized and can be reused across multiple components, reducing code duplication.\n2.  **Abstraction:** It abstracts away the complexity of managing loading, error, and data states, as well as the `useEffect` cleanup for `isMounted` or `AbortController`.\n3.  **Readability:** Components that consume the hook become cleaner and easier to understand, focusing on rendering logic rather than data fetching boilerplate.\n4.  **Maintainability:** Changes or improvements to the data fetching mechanism (e.g., adding caching, retry logic, or different error handling) can be made in one place within the custom hook, affecting all consumers.\n5.  **Testability:** The custom hook can be tested independently of any specific component.",
          "analysisPoints": [
            "Compares custom hooks to inline `useEffect`.",
            "Highlights benefits like reusability, abstraction, maintainability, testability.",
            "Demonstrates understanding of 'Don't Repeat Yourself' (DRY) principle in React."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Reusability",
            "Abstraction",
            "Maintainability",
            "DRY Principle"
          ],
          "evaluationCriteria": [
            "Ability to articulate the benefits of custom hooks.",
            "Understanding of software design principles applied to React."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Best Practices",
            "Software Design"
          ],
          "prerequisites": [
            "Custom Hooks",
            "useEffect"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_fetch_7",
          "topic": "useFetch Hook - Initial State",
          "level": "easy",
          "type": "mcq",
          "question": "What is the initial `loading` state typically set to in a `useFetch` hook, and why?",
          "answer": "True, because data fetching starts immediately when the component mounts.",
          "options": [
            "False, it becomes true only after the fetch request is initiated.",
            "True, because data fetching starts immediately when the component mounts.",
            "Null, indicating no loading status until the first render.",
            "Undefined, as its value is determined by the `fetchData` function."
          ],
          "analysisPoints": [
            "Tests understanding of initial state management in hooks.",
            "Connects initial state to component lifecycle."
          ],
          "keyConcepts": [
            "useState",
            "Initial State",
            "Loading States",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Correctly identifies initial state for a loading indicator.",
            "Understands the timing of initial data fetch."
          ],
          "example": "```typescript\nfunction useFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true); // Initial state is true\n  const [error, setError] = useState(null);\n  // ... rest of the hook\n}\n```\nThe `loading` state is set to `true` initially because as soon as the component renders and the `useEffect` runs, the `fetchData` function will be called, meaning a fetch operation is immediately in progress.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "MCQ"
          ],
          "prerequisites": [
            "useState"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_fetch_8",
          "topic": "useFetch Hook - Flashcard: `isMounted` vs `AbortController`",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the conceptual difference between using an `isMounted` flag and `AbortController` for handling side effects in `useEffect` when a component unmounts?",
          "answer": "`isMounted` prevents *state updates* on an unmounted component (avoiding warnings), while `AbortController` *cancels the ongoing network request* itself, saving bandwidth and resources.",
          "options": [],
          "analysisPoints": [
            "Distinguishes between preventing state updates and cancelling network requests.",
            "Highlights the resource management aspect of `AbortController`.",
            "Understands the limitations of `isMounted` (doesn't stop the actual request)."
          ],
          "keyConcepts": [
            "isMounted",
            "AbortController",
            "useEffect Cleanup",
            "Resource Management",
            "Memory Leaks"
          ],
          "evaluationCriteria": [
            "Clear understanding of two common cleanup strategies.",
            "Ability to explain their distinct purposes and benefits."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Performance",
            "Best Practices",
            "Flashcard"
          ],
          "prerequisites": [
            "useEffect",
            "Fetch API",
            "Component Lifecycle"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_9",
          "topic": "useFetch Hook - Edge Cases",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where using the `useFetch` hook without proper memoization of its `options` argument could lead to performance issues or unexpected behavior. How would you mitigate this?",
          "answer": "Scenario: A component uses `useFetch` to post data, and its `options` object includes a `body` property that is an object. If this `options` object (or the `body` object within it) is created as a new literal on every render of the consuming component, the `useEffect` in `useFetch` will detect a new reference for `options` in its dependency array on every render. This will cause the `fetchData` function to run repeatedly, leading to an infinite loop of POST requests or excessive network activity.\n\nMitigation: The `options` object should be memoized using `useMemo`. For example:\n\n```typescript\nimport React, { useMemo } from 'react';\n// ... assume useFetch is imported\n\nfunction MyPostComponent({ dataToPost }) {\n  const memoizedOptions = useMemo(() => ({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(dataToPost),\n  }), [dataToPost]); // Re-create only if dataToPost changes\n\n  const { data, loading, error } = useFetch('/api/submit', memoizedOptions);\n\n  // ... rest of component\n}\n```\n\nThis ensures that `memoizedOptions` only changes when `dataToPost` changes, preventing unnecessary re-fetches.",
          "analysisPoints": [
            "Identifies the problem of object reference equality in dependency arrays.",
            "Explains the cascading effect of unnecessary re-renders leading to API calls.",
            "Provides a concrete solution using `useMemo`.",
            "Demonstrates understanding of performance optimization in React hooks."
          ],
          "keyConcepts": [
            "useMemo",
            "Dependency Array",
            "Object Reference Equality",
            "Performance Optimization",
            "Infinite Loop",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Diagnoses a common React performance bug.",
            "Applies `useMemo` correctly for object memoization.",
            "Explains the 'why' behind the solution."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "useMemo",
            "Interview Question"
          ],
          "prerequisites": [
            "useEffect",
            "useMemo",
            "JavaScript Object References"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_10",
          "topic": "useFetch Hook - Conditional Fetching",
          "level": "medium",
          "type": "code",
          "question": "Modify the `useFetch` hook or its usage to allow conditional fetching. The fetch request should only be made if the `url` provided is not null or an empty string. If the `url` is invalid, the hook should return `data: null`, `loading: false`, and `error: null`.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Ability to implement conditional logic within a hook's effect.",
            "Correctly managing initial state for un-fetched scenarios.",
            "Ensuring the hook still behaves correctly when `url` becomes valid later."
          ],
          "keyConcepts": [
            "Conditional Logic",
            "useEffect",
            "Custom Hooks",
            "State Management"
          ],
          "evaluationCriteria": [
            "Adds robust input validation to the hook's behavior.",
            "Maintains correct state transitions for loading/error.",
            "Handles the 'no fetch' scenario gracefully."
          ],
          "example": "```typescript\nimport { useState, useEffect } from 'react';\n\nfunction useConditionalFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false); // Changed to false initially\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Condition to prevent fetching if url is invalid\n    if (!url) {\n      setData(null);\n      setLoading(false);\n      setError(null); // Ensure error is cleared if url becomes invalid\n      return; // Do not proceed with fetch\n    }\n\n    let isMounted = true;\n\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        if (isMounted) {\n          setData(result);\n        }\n      } catch (e) {\n        if (isMounted) {\n          setError(e.message);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [url, options]);\n\n  return { data, loading, error };\n}\n\n// Usage Example:\n// function PostDetail({ postId }) {\n//   const url = postId ? `https://api.example.com/posts/${postId}` : null;\n//   const { data, loading, error } = useConditionalFetch(url);\n\n//   if (!postId) return <div>Select a post to view details.</div>; // Early exit for no postId\n//   if (loading) return <div>Loading post...</div>;\n//   if (error) return <div>Error: {error}</div>;\n//   if (!data) return <div>No post found.</div>;\n\n//   return (\n//     <div>\n//       <h3>{data.title}</h3>\n//       <p>{data.body}</p>\n//     </div>\n//   );\n// }\n```",
          "tags": [
            "React",
            "Hooks",
            "Conditional Logic",
            "Code Challenge"
          ],
          "prerequisites": [
            "useEffect",
            "Conditional Rendering"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_media_query_1",
          "topic": "useMediaQuery Hook - Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What Web API is at the core of the `useMediaQuery` hook?",
          "answer": "`window.matchMedia()`",
          "options": [],
          "analysisPoints": [
            "Identifies the key Web API used for media query detection in JavaScript."
          ],
          "keyConcepts": [
            "Web API",
            "window.matchMedia",
            "useMediaQuery"
          ],
          "evaluationCriteria": [
            "Recall of essential Web APIs.",
            "Basic understanding of media query interaction with JavaScript."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Web API",
            "Flashcard"
          ],
          "prerequisites": [
            "JavaScript DOM"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_media_query_2",
          "topic": "useMediaQuery Hook - Event Handling",
          "level": "medium",
          "type": "mcq",
          "question": "The `useMediaQuery` hook uses `mediaQuery.addEventListener('change', listener)`. What is the significance of the `'change'` event here?\n\n```javascript\nfunction useMediaQuery(query) {\n  const [matches, setMatches] = useState(false);\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(query);\n    setMatches(mediaQuery.matches);\n    const listener = (e) => setMatches(e.matches);\n    mediaQuery.addEventListener('change', listener);\n    return () => mediaQuery.removeEventListener('change', listener);\n  }, [query]);\n  return matches;\n}\n```",
          "answer": "It allows the hook to react dynamically when the media query condition (e.g., screen width) changes, updating the `matches` state.",
          "options": [
            "It triggers once when the component mounts to set the initial `matches` state.",
            "It is deprecated and should be replaced by a polling mechanism.",
            "It allows the hook to react dynamically when the media query condition (e.g., screen width) changes, updating the `matches` state.",
            "It fires whenever any CSS property related to the media query is modified."
          ],
          "analysisPoints": [
            "Tests understanding of event listeners and their purpose.",
            "Highlights the dynamic nature of responsive hooks.",
            "Distinguishes `change` event from initial evaluation."
          ],
          "keyConcepts": [
            "Event Listeners",
            "window.matchMedia",
            "Responsive Design",
            "useEffect"
          ],
          "evaluationCriteria": [
            "Correctly identifies the purpose of the `change` event for media queries.",
            "Understands how `useEffect` and event listeners enable dynamic behavior."
          ],
          "example": "The `'change'` event on a `MediaQueryList` object is specifically designed to fire when the evaluation result of the media query changes from `true` to `false` or vice-versa. This is essential for responsive designs where components need to react in real-time as the user resizes their browser window or rotates their device.",
          "tags": [
            "React",
            "Hooks",
            "Event Handling",
            "Responsive Design",
            "MCQ"
          ],
          "prerequisites": [
            "JavaScript Event Listeners",
            "CSS Media Queries"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_media_query_3",
          "topic": "useMediaQuery Hook - Cleanup",
          "level": "medium",
          "type": "open",
          "question": "Why is it important to include `mediaQuery.removeEventListener('change', listener);` in the cleanup function of the `useMediaQuery` hook's `useEffect`?",
          "answer": "Including `mediaQuery.removeEventListener` in the cleanup function is crucial for:\n1.  **Preventing Memory Leaks:** If the event listener is not removed when the component unmounts, the listener function (`listener`) will continue to exist in memory, potentially holding references to the component's scope. This can prevent garbage collection of the unmounted component, leading to a memory leak.\n2.  **Avoiding Unnecessary Updates:** If the component has unmounted, there's no UI to update. Continuing to listen for changes and attempting `setMatches` would be a no-op at best and could lead to warnings.\n3.  **Correct Behavior on `query` Change:** If the `query` string changes (and thus the `useEffect` re-runs), the old listener for the previous query must be removed before a new one is attached for the updated query. This ensures only one active listener per `useMediaQuery` instance.",
          "analysisPoints": [
            "Explains memory leak prevention.",
            "Highlights preventing unnecessary work on unmounted components.",
            "Addresses correct behavior when `useEffect` dependencies change."
          ],
          "keyConcepts": [
            "useEffect Cleanup",
            "Memory Leaks",
            "Event Listeners",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Thorough explanation of cleanup importance.",
            "Demonstrates understanding of `useEffect` lifecycle."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Memory Leaks",
            "Best Practices"
          ],
          "prerequisites": [
            "useEffect",
            "JavaScript Event Listeners"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_media_query_performance",
          "topic": "useMediaQuery Hook - Performance",
          "level": "medium",
          "type": "flashcard",
          "question": "Does `useMediaQuery` cause frequent re-renders? Why or why not?",
          "answer": "No, it typically does not cause *frequent* re-renders. It only triggers a re-render when the `matches` state actually changes (i.e., the media query condition transitions from true to false or vice versa), not on every pixel change during a resize.",
          "options": [],
          "analysisPoints": [
            "Understands how `useState` updates trigger re-renders.",
            "Connects this to the specific behavior of `MediaQueryList` `change` events."
          ],
          "keyConcepts": [
            "Performance",
            "Re-renders",
            "useState",
            "MediaQueryList"
          ],
          "evaluationCriteria": [
            "Evaluates performance implications of the hook.",
            "Accurate understanding of state updates and re-renders."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Flashcard"
          ],
          "prerequisites": [
            "React Re-renders"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_media_query_server_side",
          "topic": "useMediaQuery Hook - SSR",
          "level": "hard",
          "type": "open",
          "question": "How would you ensure that the `useMediaQuery` hook works correctly in an application that uses Server-Side Rendering (SSR)? What potential issues might arise without special handling?",
          "answer": "On the server, `window` and `window.matchMedia` are not defined, so directly accessing them would cause runtime errors during SSR. To ensure `useMediaQuery` works correctly:\n\n**Potential Issues:**\n*   `ReferenceError: window is not defined` when the server attempts to execute the hook during the build or server render.\n*   Hydration mismatches if the initial render on the server assumes a certain media query state (e.g., desktop layout) while the client quickly evaluates to a different state (e.g., mobile layout) before hydration completes.\n\n**Mitigation:**\n1.  **Client-Side Only Execution:** The simplest approach is to check for the `window` object's existence before accessing `window.matchMedia`. If `window` is `undefined` (indicating server environment), return a default value (e.g., `false` or `true` based on a common breakpoint) or `null` and handle it in the component.\n\n    ```typescript\n    function useMediaQuery(query) {\n      const [matches, setMatches] = useState(false);\n\n      useEffect(() => {\n        if (typeof window === 'undefined') {\n          return; // Skip execution on server\n        }\n        const mediaQuery = window.matchMedia(query);\n        setMatches(mediaQuery.matches);\n        const listener = (e) => setMatches(e.matches);\n        mediaQuery.addEventListener('change', listener);\n        return () => mediaQuery.removeEventListener('change', listener);\n      }, [query]);\n\n      // For SSR, you might need a safe initial state, or null\n      // It's often paired with a separate 'isClient' state or hydration check.\n      return matches; // This initial 'false' might cause a flash of incorrect content\n    }\n    ```\n\n2.  **`useState` with a lazy initializer and `useEffect` for client-only logic:** A more robust approach sets an initial state that is SSR-safe, then updates it on the client side.\n\n    ```typescript\n    import { useState, useEffect } from 'react';\n\n    function useMediaQuerySSR(query) {\n      const [matches, setMatches] = useState(() => {\n        // Lazy initializer for initial state, runs once on server and client\n        if (typeof window === 'undefined') {\n          return false; // Default for server, e.g., assume mobile or desktop based on query\n        }\n        return window.matchMedia(query).matches;\n      });\n\n      useEffect(() => {\n        if (typeof window === 'undefined') {\n          return; // Effect only runs on client\n        }\n\n        const mediaQuery = window.matchMedia(query);\n        // We already set initial state via lazy initializer, now add listener\n        const listener = (e) => setMatches(e.matches);\n        mediaQuery.addEventListener('change', listener);\n        return () => mediaQuery.removeEventListener('change', listener);\n      }, [query]);\n\n      return matches;\n    }\n    ```\n\nThis approach avoids errors on the server and ensures that the client-side evaluation takes over after hydration. For more complex scenarios, you might use a pattern with `useEffect` that explicitly checks if the component has 'hydrated' on the client.",
          "analysisPoints": [
            "Identifies the core SSR challenge: `window` object absence.",
            "Explains `ReferenceError` and hydration mismatches.",
            "Proposes solutions using `typeof window` check.",
            "Suggests `useState` lazy initializer for initial SSR-safe state."
          ],
          "keyConcepts": [
            "SSR",
            "Hydration",
            "window object",
            "useEffect",
            "useState Lazy Initializer",
            "Cross-Platform Compatibility"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of SSR challenges with browser APIs.",
            "Ability to implement robust, cross-environment solutions.",
            "Knowledge of `useState` lazy initialization for initial render optimization."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "SSR",
            "Client-Side Rendering",
            "Performance",
            "Code Architecture"
          ],
          "prerequisites": [
            "SSR Concepts",
            "React Hydration",
            "useEffect",
            "useState"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_use_media_query_4",
          "topic": "useMediaQuery Hook - General",
          "level": "medium",
          "type": "open",
          "question": "Beyond simple `(max-width: Xpx)` queries, what other types of media queries can be effectively used with the `useMediaQuery` hook, and for what purposes?",
          "answer": "The `useMediaQuery` hook can utilize any valid CSS media query string, opening up possibilities beyond just screen width. Examples include:\n\n*   **`'(prefers-color-scheme: dark)'`**: To detect if the user has a dark mode preference set in their OS. Useful for automatically switching themes.\n*   **`'print'`**: To apply styles or render specific content only when the page is being printed.\n*   **`'(orientation: landscape)'` or `'(orientation: portrait)'`**: To detect device orientation. Useful for adjusting layouts on tablets or phones.\n*   **`'(min-resolution: 2dppx)'` or `'(min-resolution: 192dpi)'`**: To detect high-resolution (Retina) screens. Useful for serving higher-quality images.\n*   **`'(prefers-reduced-motion)'`**: To detect if the user has requested reduced motion in their OS settings. Important for accessibility to disable animations.\n*   **`'(hover: hover)'` and `'(pointer: fine)'`**: To detect if the primary input mechanism can hover and is precise. Useful for optimizing touch vs. mouse interactions.",
          "analysisPoints": [
            "Demonstrates broad knowledge of CSS media queries.",
            "Connects media query types to practical use cases.",
            "Emphasizes accessibility and user experience."
          ],
          "keyConcepts": [
            "CSS Media Queries",
            "Responsive Design",
            "Accessibility",
            "User Experience",
            "Browser Features"
          ],
          "evaluationCriteria": [
            "Expansive knowledge of media query capabilities.",
            "Ability to relate technical features to practical applications.",
            "Awareness of modern web development best practices (e.g., accessibility)."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Responsive Design",
            "Accessibility",
            "UI/UX"
          ],
          "prerequisites": [
            "CSS Media Queries"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_media_query_5",
          "topic": "useMediaQuery Hook - Hook Return Value",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the return type of the `useMediaQuery` hook, and what does it represent?",
          "answer": "It returns a boolean (`matches`), which indicates whether the provided media query currently evaluates to true.",
          "options": [],
          "analysisPoints": [
            "Identifies the simple and intuitive return value.",
            "Understands what the boolean represents."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Return Value",
            "Boolean Logic",
            "MediaQueryList"
          ],
          "evaluationCriteria": [
            "Recall of hook's output.",
            "Understanding of the core logic."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Flashcard"
          ],
          "prerequisites": [
            "Basic JavaScript"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_debounce_1",
          "topic": "useDebounce Hook - Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useDebounce` hook in a React application?",
          "answer": "To delay the execution of a function or the update of a value until a certain amount of time has passed without any further triggering events.",
          "options": [],
          "analysisPoints": [
            "Defines debouncing correctly.",
            "Understands its role in event handling."
          ],
          "keyConcepts": [
            "Debounce",
            "Performance Optimization",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Recall of debouncing definition.",
            "Understanding of its application."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Debounce",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_debounce_2",
          "topic": "useDebounce Hook - Core Logic",
          "level": "medium",
          "type": "mcq",
          "question": "In the `useDebounce` hook, why is `clearTimeout(handler);` called in the `useEffect`'s cleanup function?\n\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
          "answer": "To cancel the previous timeout if the `value` changes before the `delay` expires, ensuring only the latest `value` is debounced.",
          "options": [
            "To prevent memory leaks from the `setTimeout` function.",
            "To reset the `debouncedValue` to its initial state.",
            "To ensure the timeout handler is correctly garbage collected.",
            "To cancel the previous timeout if the `value` changes before the `delay` expires, ensuring only the latest `value` is debounced."
          ],
          "analysisPoints": [
            "Tests understanding of `setTimeout`/`clearTimeout` interaction.",
            "Explains the core debouncing mechanism.",
            "Distinguishes `clearTimeout` from general memory leak prevention."
          ],
          "keyConcepts": [
            "Debounce",
            "setTimeout",
            "clearTimeout",
            "useEffect Cleanup",
            "Performance"
          ],
          "evaluationCriteria": [
            "Accurately describes the role of `clearTimeout` in debouncing logic.",
            "Understands the interplay between `useEffect` and timers."
          ],
          "example": "If a user types 'a', a timeout starts. If they then type 'b' before the 'a' timeout finishes, without `clearTimeout`, both 'a' and 'b' would eventually trigger an update. By calling `clearTimeout(handler)`, the 'a' timeout is cancelled, and a *new* timeout for 'ab' starts. This ensures that the action only fires after the user has truly finished typing for the specified delay.",
          "tags": [
            "React",
            "Hooks",
            "Debounce",
            "Performance",
            "MCQ"
          ],
          "prerequisites": [
            "useEffect",
            "setTimeout"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_debounce_3",
          "topic": "useDebounce Hook - Usage Example",
          "level": "medium",
          "type": "open",
          "question": "Describe a practical scenario where `useDebounce` is highly beneficial. Provide a brief conceptual outline of how you would integrate it into that scenario.",
          "answer": "A highly beneficial scenario for `useDebounce` is an **auto-suggest search bar** that fetches suggestions from an API.\n\n**Problem:** Without debouncing, every keystroke in the search input would trigger an immediate API call. This leads to an excessive number of requests, unnecessary network traffic, potential rate limiting, and a poor user experience (flickering suggestions).\n\n**Integration Outline:**\n1.  **Input State:** Use `useState` to manage the immediate `searchTerm` from the input field (e.g., `const [searchTerm, setSearchTerm] = useState('');`).\n2.  **Debounced Value:** Use `const debouncedSearchTerm = useDebounce(searchTerm, 300);` (300ms is a common delay) to get the debounced version of the search term.\n3.  **API Call Effect:** Use a `useEffect` hook that has `debouncedSearchTerm` in its dependency array. This `useEffect` will contain the logic to make the API call to fetch suggestions.\n    ```typescript\n    useEffect(() => {\n      if (debouncedSearchTerm) {\n        // Make API call using debouncedSearchTerm\n        console.log(`Fetching suggestions for: ${debouncedSearchTerm}`);\n      } else {\n        // Clear suggestions if input is empty\n        console.log('Clearing suggestions');\n      }\n    }, [debouncedSearchTerm]);\n    ```\n\n**Benefit:** The API call will only be triggered after the user pauses typing for 300ms. If they type quickly, intermediate keystrokes will not trigger new requests, saving resources and providing a smoother experience.",
          "analysisPoints": [
            "Identifies a clear and common use case (search bar).",
            "Explains the problem solved by debouncing.",
            "Outlines the integration steps with specific React hooks.",
            "Articulates the practical benefits for performance and UX."
          ],
          "keyConcepts": [
            "Debounce",
            "Search Bar",
            "API Integration",
            "Performance Optimization",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Provides a relevant and detailed example.",
            "Demonstrates practical application of the hook.",
            "Clearly explains the 'before' and 'after' scenario."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Real-world",
            "Interview Question"
          ],
          "prerequisites": [
            "useState",
            "useEffect",
            "API Concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_debounce_4",
          "topic": "useDebounce Hook - Dependencies",
          "level": "easy",
          "type": "flashcard",
          "question": "Why are `value` and `delay` included in the dependency array of the `useDebounce` hook's `useEffect`?",
          "answer": "`value` is included so that the debounced value is updated whenever the input value changes. `delay` is included so that the debounce timer is reset if the delay duration itself changes.",
          "options": [],
          "analysisPoints": [
            "Understands how `useEffect` dependencies control re-execution.",
            "Recognizes the importance of both arguments to the debouncing logic."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Debounce"
          ],
          "evaluationCriteria": [
            "Correctly identifies the purpose of each dependency.",
            "Shows understanding of `useEffect` re-run conditions."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Flashcard"
          ],
          "prerequisites": [
            "useEffect"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_debounce_throttle_diff",
          "topic": "Debounce vs. Throttling",
          "level": "hard",
          "type": "open",
          "question": "Explain the difference between debouncing and throttling, and provide a scenario where each would be more appropriate.",
          "answer": "**Debouncing** delays the execution of a function until a certain amount of time has passed without any further calls. It ensures that a function is only called *after* a period of inactivity. If the function is called again within the delay, the timer is reset.\n*   **Scenario for Debouncing:** A search input field. You want to send an API request to fetch suggestions only after the user has stopped typing for, say, 300ms. This prevents an API call on every keystroke, reducing server load and unnecessary rendering.\n\n**Throttling** limits the execution of a function to at most once in a given time period. It ensures that a function is called regularly, but not more often than a specified frequency.\n*   **Scenario for Throttling:** A window resize event handler. You want to recalculate layout or perform heavy DOM manipulations during a window resize, but only every 100ms. This prevents the function from firing hundreds of times per second during a continuous resize, improving performance without missing too many intermediate states.\n\n**Key Difference:**\n*   **Debounce:** \"Wait until I'm done typing, then do something.\" (Executes *after* inactivity)\n*   **Throttle:** \"Do something, but no more than once every X milliseconds.\" (Executes *at most* every X milliseconds)",
          "analysisPoints": [
            "Clearly defines both debouncing and throttling.",
            "Provides distinct and appropriate real-world scenarios for each.",
            "Highlights the fundamental difference in their execution patterns.",
            "Demonstrates understanding of performance optimization strategies."
          ],
          "keyConcepts": [
            "Debounce",
            "Throttling",
            "Performance Optimization",
            "Event Handling",
            "Timers"
          ],
          "evaluationCriteria": [
            "Accurate and concise definitions.",
            "Relevant and illustrative examples.",
            "Clear articulation of the core distinction."
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Performance",
            "Algorithms",
            "Interview Question"
          ],
          "prerequisites": [
            "setTimeout",
            "Event Handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_debounce_real_world",
          "topic": "useDebounce Hook - Real-world Applications",
          "level": "medium",
          "type": "open",
          "question": "Beyond a search bar, name two other real-world scenarios where `useDebounce` or debouncing logic would be beneficial and explain why.",
          "answer": "1.  **Saving Form Data/Auto-saving Drafts:**\n    *   **Scenario:** A text editor or a complex form where data needs to be saved to a backend API frequently, but you don't want to save on every keystroke or every minor change.\n    *   **Why Debounce:** Debouncing the save function (e.g., by 1-2 seconds) ensures that the save operation only triggers after the user has paused typing or modifying content for that duration. This prevents a flood of save requests, reduces server load, and improves responsiveness by not constantly interrupting the user's input with save operations.\n\n2.  **Validating Input Fields (Client-side):**\n    *   **Scenario:** An email input field that needs to validate the email format or check for availability against a database.\n    *   **Why Debounce:** Instead of validating on every keystroke, debouncing the validation logic (e.g., by 500ms) allows the user to finish typing their email address before the validation function is called. This avoids showing premature error messages (e.g., 'Invalid email format' after just typing 'a') and reduces the number of database/API calls for availability checks, making the UI feel smoother and less intrusive.",
          "analysisPoints": [
            "Provides diverse real-world examples.",
            "Explains the specific problem solved by debouncing in each scenario.",
            "Connects to UX improvements and resource optimization."
          ],
          "keyConcepts": [
            "Debounce",
            "Form Validation",
            "Auto-save",
            "Performance",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Creative and relevant application of debouncing.",
            "Clear justification for its use in each scenario."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Real-world",
            "UX"
          ],
          "prerequisites": [],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_use_fetch_1",
          "title": "Build a useFetch Hook with Caching and Retry Logic",
          "description": "\nImplement an enhanced `useFetch` hook that includes:\n\n1.  **Basic Fetching:** Retain the core functionality to fetch `data`, `loading`, and `error` states.\n2.  **In-Memory Caching:** Implement a simple in-memory cache for GET requests. If a request for the same URL has been made recently (e.g., within the last 5 minutes), return the cached data instantly. The cache should be cleared after a configurable time.\n3.  **Retry Mechanism:** If a fetch request fails due to a network error (e.g., `TypeError: Failed to fetch` or a 5xx status code), implement a retry mechanism that attempts the request up to 3 times with a delay (e.g., 500ms, 1000ms, 2000ms) between retries.\n4.  **AbortController Integration:** Ensure ongoing requests can be safely aborted if the component unmounts or a new request is initiated (e.g., URL changes). You can combine this with the `isMounted` flag for state updates.\n\nYour solution should be robust and handle various network conditions gracefully.\n",
          "difficulty": "hard",
          "startingCode": "import { useState, useEffect, useRef, useCallback } from 'react';\n\n// A simple in-memory cache map\nconst cache = new Map();\n\nfunction useFetchEnhanced(url, options = {}, cacheDuration = 300000) { // cacheDuration in ms (5 minutes default)\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef(null);\n\n  const fetchData = useCallback(async (retries = 0) => {\n    if (!url) {\n      setData(null);\n      setLoading(false);\n      setError(null);\n      return;\n    }\n\n    // 1. Abort any ongoing request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    const controller = new AbortController();\n    abortControllerRef.current = controller;\n    const signal = controller.signal;\n\n    // 2. Check cache for GET requests\n    if (options.method === 'GET' || !options.method) {\n      const cached = cache.get(url);\n      if (cached && (Date.now() - cached.timestamp < cacheDuration)) {\n        setData(cached.data);\n        setLoading(false);\n        setError(null);\n        console.log(`Cache hit for ${url}`);\n        return; // Return cached data instantly\n      }\n    }\n\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch(url, { ...options, signal });\n\n      if (!response.ok) {\n        // Handle HTTP errors for retry\n        if (response.status >= 500 && retries < 3) {\n          const retryDelay = [500, 1000, 2000][retries];\n          console.warn(`Fetch failed for ${url}, retrying in ${retryDelay}ms... (Attempt ${retries + 1})`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n          return fetchData(retries + 1); // Retry recursively\n        }\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      setData(result);\n      \n      // Cache successful GET requests\n      if (options.method === 'GET' || !options.method) {\n        cache.set(url, { data: result, timestamp: Date.now() });\n        setTimeout(() => cache.delete(url), cacheDuration); // Clear cache after duration\n      }\n\n    } catch (e) {\n      if (e.name === 'AbortError') {\n        console.log('Fetch aborted');\n        return; // Do not set error for aborted requests\n      }\n      // Handle network errors for retry\n      if (e instanceof TypeError && e.message === 'Failed to fetch' && retries < 3) {\n        const retryDelay = [500, 1000, 2000][retries];\n        console.warn(`Network error for ${url}, retrying in ${retryDelay}ms... (Attempt ${retries + 1})`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        return fetchData(retries + 1); // Retry recursively\n      }\n      setError(e.message);\n    } finally {\n      setLoading(false);\n      abortControllerRef.current = null; // Clear controller once request is done/aborted\n    }\n  }, [url, options, cacheDuration]); // Dependencies for fetchData\n\n  useEffect(() => {\n    let isMounted = true;\n    // Helper function to call fetchData and ensure state updates only on mounted component\n    const safeFetch = async () => {\n      await fetchData();\n      // No explicit isMounted checks needed for setData/setError/setLoading\n      // because fetchData itself directly sets state only if not aborted.\n      // However, for the initial state transition (loading=true), we do it outside.\n    }\n\n    safeFetch();\n\n    return () => {\n      isMounted = false;\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort(); // Abort on unmount\n      }\n    };\n  }, [fetchData]); // Dependency on memoized fetchData\n\n  return { data, loading, error };\n}\n\n// Example Usage (for testing):\n// function TestComponent() {\n//   const [userId, setUserId] = useState(1);\n//   const { data, loading, error } = useFetchEnhanced(`https://jsonplaceholder.typicode.com/users/${userId}`);\n\n//   return (\n//     <div>\n//       <button onClick={() => setUserId(prev => prev + 1)}>Next User</button>\n//       {loading && <p>Loading user {userId}...</p>}\n//       {error && <p style={{ color: 'red' }}>Error: {error}</p>}\n//       {data && (\n//         <div>\n//           <h3>User: {data.name}</h3>\n//           <p>Email: {data.email}</p>\n//         </div>\n//       )}\n//     </div>\n//   );\n// }\n",
          "solutionCode": "import { useState, useEffect, useRef, useCallback } from 'react';\n\n// A simple in-memory cache map\nconst cache = new Map();\n\nfunction useFetchEnhanced(url, options = {}, cacheDuration = 300000) { // cacheDuration in ms (5 minutes default)\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef(null); // Ref to store AbortController instance\n\n  // Using useCallback to memoize fetchData to prevent infinite loops in useEffect dependencies\n  const fetchData = useCallback(async (retries = 0) => {\n    // If URL is invalid, reset state and exit\n    if (!url) {\n      setData(null);\n      setLoading(false);\n      setError(null);\n      return;\n    }\n\n    // Abort any ongoing request before starting a new one\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    const controller = new AbortController();\n    abortControllerRef.current = controller;\n    const signal = controller.signal;\n\n    // Implement in-memory caching for GET requests\n    if (options.method === 'GET' || !options.method) {\n      const cached = cache.get(url);\n      if (cached && (Date.now() - cached.timestamp < cacheDuration)) {\n        setData(cached.data);\n        setLoading(false);\n        setError(null);\n        console.log(`useFetchEnhanced: Cache hit for ${url}`);\n        return; // Return cached data instantly\n      }\n    }\n\n    setLoading(true); // Start loading\n    setError(null); // Clear previous errors\n    \n    try {\n      const response = await fetch(url, { ...options, signal });\n\n      // Check for HTTP errors (e.g., 5xx for retries, others for immediate error)\n      if (!response.ok) {\n        // Retry mechanism for server errors (5xx) and network errors\n        if (response.status >= 500 && retries < 3) {\n          const retryDelay = [500, 1000, 2000][retries];\n          console.warn(`useFetchEnhanced: HTTP Error ${response.status} for ${url}, retrying in ${retryDelay}ms... (Attempt ${retries + 1})`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n          return fetchData(retries + 1); // Recursive retry\n        }\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      setData(result);\n      \n      // Cache successful GET requests with a timestamp and auto-clear\n      if (options.method === 'GET' || !options.method) {\n        cache.set(url, { data: result, timestamp: Date.now() });\n        // Set a timeout to clear this specific cache entry after cacheDuration\n        setTimeout(() => {\n          if (cache.get(url) && cache.get(url).timestamp === cache.get(url).timestamp) { // Only clear if it's the same entry\n            cache.delete(url);\n            console.log(`useFetchEnhanced: Cache cleared for ${url}`);\n          }\n        }, cacheDuration);\n      }\n\n    } catch (e) {\n      if (e.name === 'AbortError') {\n        console.log('useFetchEnhanced: Fetch aborted');\n        return; // Do not set error or loading state for aborted requests\n      }\n      \n      // Retry mechanism for network errors (e.g., 'Failed to fetch')\n      if (e instanceof TypeError && (e.message === 'Failed to fetch' || e.message.includes('network')) && retries < 3) {\n        const retryDelay = [500, 1000, 2000][retries];\n        console.warn(`useFetchEnhanced: Network error for ${url}, retrying in ${retryDelay}ms... (Attempt ${retries + 1})`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        return fetchData(retries + 1); // Recursive retry\n      }\n      setError(e.message);\n    } finally {\n      setLoading(false); // Stop loading regardless of success or failure\n      abortControllerRef.current = null; // Clear controller ref as request is complete or aborted\n    }\n  }, [url, options, cacheDuration]); // Dependencies for useCallback\n\n  // useEffect to trigger fetch on mount and when dependencies (url, options) change\n  useEffect(() => {\n    // No `isMounted` flag needed with AbortController if state updates are always guarded by `if (!signal.aborted) { ... }`\n    // However, the `isMounted` pattern is safer if you're not fully certain all async paths respect `signal.aborted`.\n    // In this specific implementation, all state updates are within the `fetchData` function,\n    // which is guarded by `if (e.name === 'AbortError') return;`, so it's implicitly handled.\n    \n    fetchData(); // Execute fetch logic\n\n    // Cleanup function: Abort ongoing request if component unmounts or dependencies change\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [fetchData]); // Dependency on the memoized fetchData function\n\n  return { data, loading, error };\n}\n\n// Example Usage:\n// function UserProfileWithCacheAndRetry({ userId }) {\n//   const url = userId ? `https://jsonplaceholder.typicode.com/users/${userId}` : null;\n//   const { data, loading, error } = useFetchEnhanced(url);\n\n//   if (!userId) return <div>Enter a user ID.</div>;\n//   if (loading) return <div>Loading user {userId}...</div>;\n//   if (error) return <div style={{ color: 'red' }}>Error: {error}</div>;\n//   if (!data) return <div>No user data found.</div>;\n\n//   return (\n//     <div>\n//       <h2>{data.name}</h2>\n//       <p>Email: {data.email}</p>\n//       <p>Phone: {data.phone}</p>\n//     </div>\n//   );\n// }\n\n// function App() {\n//   const [currentUserId, setCurrentUserId] = useState(1);\n\n//   return (\n//     <div>\n//       <h1>Enhanced Fetch Example</h1>\n//       <button onClick={() => setCurrentUserId(prev => (prev % 10) + 1)}>Next User</button>\n//       <button onClick={() => setCurrentUserId(999)}>Fetch Non-existent User (for error/retry test)</button>\n//       <UserProfileWithCacheAndRetry userId={currentUserId} />\n//     </div>\n//   );\n// }\n",
          "testCases": [
            "Test with valid URL: Should fetch data and set `loading` to `false`, `error` to `null`.",
            "Test with invalid URL (e.g., 404): Should set `error` and `loading` to `false`.",
            "Test cache hit: Fetch the same URL twice within `cacheDuration`. The second call should return data instantly without `loading` state transition.",
            "Test cache miss: Fetch the same URL after `cacheDuration`. Should re-fetch data.",
            "Test retry mechanism (simulate 500 error): Mock `fetch` to return 500 for first 2 calls, then 200. Should show loading, retry messages, then success.",
            "Test retry mechanism (simulate network error): Mock `fetch` to throw `TypeError` for first 2 calls, then success. Should show loading, retry messages, then success.",
            "Test component unmount during fetch: Ensure no state updates are attempted on unmounted component (no React warnings).",
            "Test URL change during fetch: Ensure previous request is aborted and new one initiated correctly.",
            "Test with null URL: Should return `data: null`, `loading: false`, `error: null`.",
            "Test with POST request (should not cache): Ensure POST requests are never cached."
          ],
          "hints": [
            "Use a `Map` object for the in-memory cache. Store `data` and `timestamp`.",
            "The `AbortController` should be created and referenced for each `fetch` call.",
            "For retry logic, you can make `fetchData` a `useCallback` that accepts a `retries` parameter and calls itself recursively.",
            "Remember to clear the `setTimeout` for cache expiration if the data is re-fetched or component unmounts before the timer runs out.",
            "Carefully manage `loading` and `error` states in all fetch outcomes (success, error, abort, cache hit)."
          ],
          "tags": [
            "React",
            "Hooks",
            "Data Fetching",
            "Caching",
            "Retry Logic",
            "AbortController",
            "Performance",
            "Advanced"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "useFetch Hook (basic)",
            "Promises",
            "Async/Await",
            "Fetch API",
            "AbortController",
            "useCallback",
            "Error Handling"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "expert",
          "relatedConcepts": [
            "useFetch Hook",
            "Fetch API",
            "AbortController",
            "Cache Management",
            "Error Handling Patterns",
            "Retry Patterns"
          ]
        },
        {
          "id": "task_use_media_query_1",
          "title": "Build a useBreakpoints Hook for Themed Responsive Design",
          "description": "\nCreate a custom hook `useBreakpoints` that simplifies responsive design by allowing components to query against a predefined set of named breakpoints (similar to design systems like Material-UI or Bootstrap).\n\n**Requirements:**\n1.  The hook should accept an object of named breakpoints (e.g., `{ xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920 }`).\n2.  It should return an object with boolean flags for each breakpoint, indicating whether the current viewport width is at or above that breakpoint. For example, ` { sm: true, md: false, lg: false }` if the screen is between `sm` and `md`.\n3.  It should also return the `currentBreakpoint` as a string (e.g., 'sm', 'md'), representing the *largest* breakpoint that is currently matched.\n4.  The hook must react dynamically to window resizing.\n5.  Handle Server-Side Rendering (SSR) safely by providing a default initial state or handling `window` object absence.\n",
          "difficulty": "medium",
          "startingCode": "import { useState, useEffect } from 'react';\n\nconst defaultBreakpoints = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n};\n\nfunction useBreakpoints(breakpoints = defaultBreakpoints) {\n  const sortedBreakpoints = Object.entries(breakpoints)\n    .sort(([, valA], [, valB]) => valA - valB);\n\n  const getMatches = () => {\n    if (typeof window === 'undefined') {\n      // Provide a default for SSR, e.g., assume 'xs' or 'md'\n      return {\n        matches: Object.fromEntries(sortedBreakpoints.map(([key]) => [key, false])),\n        current: 'xs' // Default to smallest for SSR or specific initial assumption\n      };\n    }\n\n    const currentWidth = window.innerWidth;\n    let currentBreakpoint = 'xs'; // Default to smallest\n    const matches = {};\n\n    for (let i = 0; i < sortedBreakpoints.length; i++) {\n      const [name, value] = sortedBreakpoints[i];\n      if (currentWidth >= value) {\n        matches[name] = true;\n        currentBreakpoint = name;\n      } else {\n        matches[name] = false;\n      }\n    }\n    return { matches, current: currentBreakpoint };\n  };\n\n  const [state, setState] = useState(getMatches);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const handleResize = () => {\n      setState(getMatches());\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [breakpoints]); // Re-run effect if breakpoints object changes\n\n  return { ...state.matches, current: state.current };\n}\n\n// Usage Example:\n// function ResponsiveDisplay() {\n//   const { xs, sm, md, lg, xl, current } = useBreakpoints();\n\n//   return (\n//     <div>\n//       <p>Current Breakpoint: {current}</p>\n//       {xs && <p>I am on an extra small screen or larger.</p>}\n//       {sm && <p>I am on a small screen or larger.</p>}\n//       {md && <p>I am on a medium screen or larger.</p>}\n//       {lg && <p>I am on a large screen or larger.</p>}\n//       {xl && <p>I am on an extra large screen or larger.</p>}\n//       {current === 'sm' && <p style={{ fontWeight: 'bold' }}>Specifically small screen!</p>}\n//     </div>\n//   );\n// }\n",
          "solutionCode": "import { useState, useEffect, useMemo } from 'react';\n\nconst defaultBreakpoints = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n};\n\nfunction useBreakpoints(breakpoints = defaultBreakpoints) {\n  // Memoize sorted breakpoints to avoid re-sorting on every render\n  const sortedBreakpoints = useMemo(() => \n    Object.entries(breakpoints)\n      .sort(([, valA], [, valB]) => valA - valB)\n  , [breakpoints]);\n\n  const getBreakpointState = useCallback(() => {\n    if (typeof window === 'undefined') {\n      // Default state for SSR: assume 'xs' matched, all others false.\n      // This provides a consistent initial render that can then hydrate.\n      const initialMatches = {};\n      sortedBreakpoints.forEach(([key]) => {\n        initialMatches[key] = (key === 'xs'); // Assuming 'xs' is 0 or smallest\n      });\n      return {\n        matches: initialMatches,\n        current: 'xs' \n      };\n    }\n\n    const currentWidth = window.innerWidth;\n    let currentBreakpoint = 'xs'; // Initialize with the smallest breakpoint name\n    const matches = {};\n\n    // Iterate through sorted breakpoints to determine matches and the largest matched breakpoint\n    for (let i = 0; i < sortedBreakpoints.length; i++) {\n      const [name, value] = sortedBreakpoints[i];\n      if (currentWidth >= value) {\n        matches[name] = true;\n        currentBreakpoint = name; // Update currentBreakpoint if this one matches\n      } else {\n        matches[name] = false;\n      }\n    }\n    return { matches, current: currentBreakpoint };\n  }, [sortedBreakpoints]); // getBreakpointState depends on sortedBreakpoints\n\n  // Use lazy initializer for initial state, and then update via effect\n  const [state, setState] = useState(getBreakpointState);\n\n  useEffect(() => {\n    // Only run event listener logic on the client-side\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const handleResize = () => {\n      setState(getBreakpointState());\n    };\n\n    // Add event listener for window resize\n    window.addEventListener('resize', handleResize);\n    \n    // Initial state update on client-side might be needed if SSR default was wrong\n    // or for clients where JS is enabled before hydration.\n    // setState(getBreakpointState()); // Can cause hydration mismatch if not carefully handled with specific SSR patterns\n                                    // Better to rely on initial lazy state and event listener for subsequent changes.\n\n    // Cleanup function: remove event listener\n    return () => window.removeEventListener('resize', handleResize);\n  }, [getBreakpointState]); // Effect depends on memoized getBreakpointState\n\n  // Return individual breakpoint flags and the current breakpoint name\n  return { ...state.matches, current: state.current };\n}\n\n// Usage Example:\n// function ResponsiveHeader() {\n//   const { sm, md, lg, current } = useBreakpoints({\n//     phone: 0,\n//     tablet: 768,\n//     desktop: 1024,\n//   });\n\n//   const HeaderContent = () => {\n//     if (lg) return <h1>Desktop Header</h1>;\n//     if (md) return <h2>Tablet Header</h2>;\n//     if (sm) return <h3>Phone Header (Landscape)</h3>;\n//     return <h4>Phone Header (Portrait)</h4>;\n//   };\n\n//   return (\n//     <header style={{ padding: '20px', background: '#eee' }}>\n//       {HeaderContent()}\n//       <p>Current active breakpoint: {current}</p>\n//     </header>\n//   );\n// }\n",
          "testCases": [
            "Test with various window widths: Verify correct boolean flags for `sm`, `md`, `lg`, etc. (e.g., if width is 700px, `sm` should be true, `md` false).",
            "Test `currentBreakpoint`: Verify `current` correctly returns the largest matched breakpoint name.",
            "Test resizing window: Ensure the hook dynamically updates `matches` and `current` properties.",
            "Test with custom breakpoints: Provide a different breakpoint object and ensure it works correctly.",
            "Test SSR safety: Run in a Node.js environment (e.g., Jest with `window` undefined) and confirm no errors occur, and initial values are as expected for `xs`.",
            "Test `useMemo` and `useCallback` efficiency: Ensure `getBreakpointState` and `sortedBreakpoints` are not re-created unnecessarily.",
            "Test with window width exactly at a breakpoint (e.g., 600px): Ensure it matches that breakpoint and above.",
            "Test with very small width (e.g., 300px): Should match only 'xs'."
          ],
          "hints": [
            "Sort the breakpoints from smallest to largest to correctly determine the `currentBreakpoint`.",
            "Use `window.innerWidth` to get the current viewport width.",
            "Remember to use `useCallback` for `getBreakpointState` and `useMemo` for `sortedBreakpoints` to optimize performance and prevent unnecessary re-runs of `useEffect`.",
            "For SSR, check `typeof window === 'undefined'` at the beginning of your effect and state initializer to avoid errors.",
            "The `currentBreakpoint` should be the largest breakpoint whose value is less than or equal to `window.innerWidth`."
          ],
          "tags": [
            "React",
            "Hooks",
            "Responsive Design",
            "Media Queries",
            "SSR",
            "Performance",
            "Theming"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "useMediaQuery Hook (basic)",
            "useEffect",
            "useState",
            "useMemo",
            "useCallback",
            "SSR Concepts",
            "JavaScript Object Manipulation"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "CSS Media Queries",
            "Responsive Web Design",
            "SSR Hydration",
            "React Performance Optimization"
          ]
        },
        {
          "id": "task_use_debounce_1",
          "title": "Implement a Debounced Search Input with API Integration",
          "description": "\nCreate a React component that features a search input. When the user types, it should use the `useDebounce` hook to delay fetching search results from a mock API until the user has paused typing for a specified duration.\n\n**Requirements:**\n1.  **Search Input:** A basic text input where users can type their search query.\n2.  **Debounced Search Term:** Use the provided `useDebounce` hook (or re-implement it) with a configurable delay (e.g., 500ms).\n3.  **Mock API Call:** Simulate an API call using `setTimeout` (e.g., 300ms) that returns mock search results based on the debounced search term. The mock API should simulate fetching data and can return an empty array if no matches.\n4.  **Loading State:** Display a 'Loading...' indicator while the mock API call is in progress.\n5.  **Display Results:** Render the search results below the input. If no results, display 'No results found.'\n6.  **Clear Search:** Implement a way to clear the search input and results.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// --- useDebounce Hook (Provided for convenience or re-implement) ---\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n}\n// ------------------------------------------------------------------\n\n// Mock API data\nconst MOCK_DATA = [\n  'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry',\n  'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon',\n  'Mango', 'Nectarine', 'Orange', 'Papaya', 'Quince'\n];\n\n// Mock API function\nconst searchApi = (query) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const results = MOCK_DATA.filter(item =>\n        item.toLowerCase().includes(query.toLowerCase())\n      );\n      resolve(results);\n    }, 300); // Simulate network delay\n  });\n};\n\nfunction DebouncedSearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n  const [searchResults, setSearchResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  // TODO: Implement useEffect to call searchApi when debouncedSearchTerm changes\n  // Handle loading state and set searchResults\n\n  const handleClear = () => {\n    setSearchTerm('');\n    setSearchResults([]);\n    setLoading(false);\n  };\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '500px', margin: '0 auto' }}>\n      <h2>Fruit Search</h2>\n      <input\n        type=\"text\"\n        placeholder=\"Search fruits...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ width: '100%', padding: '10px', fontSize: '16px' }}\n      />\n      <button onClick={handleClear} style={{ marginTop: '10px' }}>\n        Clear Search\n      </button>\n\n      {loading && <p>Loading results...</p>}\n\n      {!loading && searchResults.length > 0 && (\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          {searchResults.map((result, index) => (\n            <li key={index} style={{ padding: '8px 0', borderBottom: '1px solid #eee' }}>\n              {result}\n            </li>\n          ))}\n        </ul>\n      )}\n\n      {!loading && searchTerm && searchResults.length === 0 && (\n        <p>No results found for \"{searchTerm}\".</p>\n      )}\n      \n      {!searchTerm && !loading && searchResults.length === 0 && (\n        <p>Start typing to search.</p>\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// --- useDebounce Hook ---\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n// ------------------------\n\n// Mock API data\nconst MOCK_DATA = [\n  'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry',\n  'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon',\n  'Mango', 'Nectarine', 'Orange', 'Papaya', 'Quince'\n];\n\n// Mock API function\nconst searchApi = (query) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (!query) {\n        resolve([]); // If query is empty, return no results\n        return;\n      }\n      const results = MOCK_DATA.filter(item =>\n        item.toLowerCase().includes(query.toLowerCase())\n      );\n      resolve(results);\n    }, 300); // Simulate network delay\n  });\n};\n\nfunction DebouncedSearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTerm, 500); // 500ms debounce delay\n  const [searchResults, setSearchResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null); // Added error state for robustness\n\n  useEffect(() => {\n    // Only perform search if debouncedSearchTerm is not empty\n    if (debouncedSearchTerm) {\n      setLoading(true);\n      setError(null);\n      searchApi(debouncedSearchTerm)\n        .then(results => {\n          setSearchResults(results);\n        })\n        .catch(err => {\n          console.error(\"Search API error:\", err);\n          setError(\"Failed to fetch search results.\");\n          setSearchResults([]);\n        })\n        .finally(() => {\n          setLoading(false);\n        });\n    } else {\n      setSearchResults([]); // Clear results if search term is empty\n      setLoading(false); // Ensure loading is false\n      setError(null); // Clear errors\n    }\n  }, [debouncedSearchTerm]); // Effect runs only when debouncedSearchTerm changes\n\n  const handleClear = () => {\n    setSearchTerm('');\n    setSearchResults([]);\n    setLoading(false);\n    setError(null);\n  };\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '500px', margin: '0 auto', fontFamily: 'Arial, sans-serif' }}>\n      <h2>Fruit Search</h2>\n      <input\n        type=\"text\"\n        placeholder=\"Search fruits...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ width: '100%', padding: '10px', fontSize: '16px', border: '1px solid #ccc', borderRadius: '4px' }}\n      />\n      <button \n        onClick={handleClear} \n        style={{ marginTop: '10px', padding: '8px 15px', fontSize: '14px', cursor: 'pointer', background: '#f0f0f0', border: '1px solid #ddd', borderRadius: '4px' }}\n      >\n        Clear Search\n      </button>\n\n      {loading && searchTerm && <p style={{ color: '#007bff' }}>Loading results for \"{debouncedSearchTerm}\"...</p>}\n      {error && <p style={{ color: 'red' }}>Error: {error}</p>}\n\n      {!loading && !error && searchResults.length > 0 && (\n        <ul style={{ listStyleType: 'none', padding: 0, borderTop: '1px solid #eee', marginTop: '15px' }}>\n          {searchResults.map((result, index) => (\n            <li key={index} style={{ padding: '10px 0', borderBottom: '1px solid #eee' }}>\n              {result}\n            </li>\n          ))}\n        </ul>\n      )}\n\n      {!loading && !error && debouncedSearchTerm && searchResults.length === 0 && (\n        <p style={{ color: '#555' }}>No results found for \"{debouncedSearchTerm}\".</p>\n      )}\n      \n      {!searchTerm && !loading && !error && searchResults.length === 0 && (\n        <p style={{ color: '#777' }}>Start typing to search.</p>\n      )}\n    </div>\n  );\n}\n\nexport default DebouncedSearchComponent;\n",
          "testCases": [
            "Test typing quickly: Observe that the mock API call (console log) is delayed until typing pauses, and only the final term triggers the fetch.",
            "Test typing slowly: Observe that each pause triggers a fetch for the current term.",
            "Test empty input: Clear the input and ensure results are cleared and no API call is made.",
            "Test specific search terms: 'Apple', 'Orange', 'berry' (should return 'Elderberry' and 'Cherry').",
            "Test for non-existent terms: 'xyz' (should return 'No results found').",
            "Test loading indicator: Ensure 'Loading...' appears only when an API call is active.",
            "Test clearing search: Click 'Clear Search' button and ensure input and results reset.",
            "Test `useDebounce` delay: Change delay to 1000ms and observe longer pauses required."
          ],
          "hints": [
            "The `useEffect` that calls `searchApi` should have `debouncedSearchTerm` in its dependency array.",
            "Make sure to set `loading` to `true` before the API call and `false` in the `finally` block of the promise.",
            "Handle the case where `debouncedSearchTerm` is empty (e.g., when the input is cleared) by not making an API call and clearing previous results."
          ],
          "tags": [
            "React",
            "Hooks",
            "Debounce",
            "Performance",
            "API Integration",
            "UI/UX",
            "Search"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "useDebounce Hook",
            "useState",
            "useEffect",
            "Promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Debouncing",
            "Throttling",
            "Asynchronous Operations",
            "Search Filtering"
          ]
        },
        {
          "id": "task_use_debounce_2",
          "title": "Build a Debounced Window Resize Listener",
          "description": "\nCreate a React component that displays the current window width and height, but updates these values only after the user stops resizing the window for a short period.\n\n**Requirements:**\n1.  **Display Dimensions:** Show `window.innerWidth` and `window.innerHeight` in a component.\n2.  **Debounced Update:** Use the `useDebounce` hook (or re-implement it) to debounce the window's `resize` event. The dimensions should update only after a configurable `delay` (e.g., 200ms) of no further resizing activity.\n3.  **Initial Display:** The component should show the current window dimensions immediately on mount, before any resize events.\n4.  **Cleanup:** Ensure the event listener is properly removed when the component unmounts.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// --- useDebounce Hook (Provided for convenience or re-implement) ---\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n}\n// ------------------------------------------------------------------\n\nfunction DebouncedResizeDisplay() {\n  const [windowDimensions, setWindowDimensions] = useState(() => ({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  }));\n\n  // TODO: Implement useEffect to listen to window 'resize' events\n  // Update a 'raw' dimension state immediately on resize\n  // Use useDebounce on this raw state to get debounced dimensions\n  // Display the debounced dimensions\n\n  return (\n    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>\n      <h2>Debounced Window Resizer</h2>\n      <p>Raw Window Width: {windowDimensions.width}px</p>\n      <p>Raw Window Height: {windowDimensions.height}px</p>\n      <hr />\n      {/* Display debounced dimensions here */}\n      <p>Debounced Window Width: {windowDimensions.width}px</p>\n      <p>Debounced Window Height: {windowDimensions.height}px</p>\n      <p style={{ color: '#888' }}>Resize your browser window to see the effect.</p>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// --- useDebounce Hook ---\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n// ------------------------\n\nfunction DebouncedResizeDisplay() {\n  // State to hold the *raw*, immediate window dimensions\n  const [rawWindowDimensions, setRawWindowDimensions] = useState(() => ({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  }));\n\n  // Debounce the raw dimensions\n  const debouncedWindowDimensions = useDebounce(rawWindowDimensions, 200); // 200ms debounce delay\n\n  useEffect(() => {\n    // Ensure this runs only in browser environment\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const handleResize = () => {\n      setRawWindowDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n\n    // Add event listener for window resize\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup function: remove event listener on component unmount\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount\n\n  return (\n    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif', border: '1px solid #ddd', borderRadius: '8px', maxWidth: '400px', margin: '20px auto', boxShadow: '0 4px 8px rgba(0,0,0,0.1)' }}>\n      <h2 style={{ color: '#333' }}>Debounced Window Resizer</h2>\n      <p><strong>Raw Window Dimensions (updates instantly):</strong></p>\n      <p>Width: <span style={{ color: '#007bff', fontWeight: 'bold' }}>{rawWindowDimensions.width}px</span></p>\n      <p>Height: <span style={{ color: '#007bff', fontWeight: 'bold' }}>{rawWindowDimensions.height}px</span></p>\n      <hr style={{ margin: '15px 0', borderColor: '#eee' }} />\n      <p><strong>Debounced Window Dimensions (updates after 200ms pause):</strong></p>\n      <p>Width: <span style={{ color: '#28a745', fontWeight: 'bold' }}>{debouncedWindowDimensions.width}px</span></p>\n      <p>Height: <span style={{ color: '#28a745', fontWeight: 'bold' }}>{debouncedWindowDimensions.height}px</span></p>\n      <p style={{ color: '#888', fontSize: '0.9em', marginTop: '15px' }}>Resize your browser window to see the debouncing effect.</p>\n    </div>\n  );\n}\n\nexport default DebouncedResizeDisplay;\n",
          "testCases": [
            "Test initial render: Dimensions should be displayed immediately on load.",
            "Test quick resize: Drag window rapidly. 'Raw' dimensions should change instantly, while 'Debounced' dimensions should lag and update only after you stop resizing.",
            "Test slow resize: Drag window slowly with pauses. 'Debounced' dimensions should update after each pause.",
            "Test unmount: Simulate component unmount (e.g., toggle visibility) and ensure no errors related to event listeners occur.",
            "Test with different debounce delays: Change the `delay` in `useDebounce` (e.g., 500ms, 1000ms) and observe the difference in update responsiveness."
          ],
          "hints": [
            "You'll need two sets of states: one for the `raw` window dimensions (updated on every resize event) and one for the `debounced` dimensions.",
            "The `useEffect` for the resize listener should only have an empty dependency array (`[]`) to run once on mount and clean up on unmount.",
            "Remember to use the `useState` functional update form or a lazy initializer if you need to calculate initial state based on `window` object to avoid SSR issues.",
            "Pass the `rawWindowDimensions` to `useDebounce`."
          ],
          "tags": [
            "React",
            "Hooks",
            "Debounce",
            "Performance",
            "Event Handling",
            "Window Events"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "useDebounce Hook",
            "useState",
            "useEffect",
            "JavaScript Event Listeners"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Throttling",
            "Responsive Layouts",
            "Event Optimization"
          ]
        }
      ]
    }
  },
  {
    "id": "c7a239e2-4465-46c6-bde9-1837b3d335a7",
    "startLine": 5800,
    "endLine": 5899,
    "processedDate": "2025-06-17T09:46:54.622Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_debouncing_and_useeffect",
          "title": "React `useEffect` for Side Effects and Debouncing",
          "content": "## Understanding `useEffect` Hook\n\nThe `useEffect` hook in React allows you to perform side effects in functional components. Side effects are operations that interact with the outside world or affect things outside the React component tree, such as data fetching, subscriptions, or manually changing the DOM. `useEffect` runs after every render, but you can control when it runs using its dependency array.\n\n### `useEffect` Signature\n\n```typescript\nuseEffect(() => {\n  // Side effect logic\n  return () => {\n    // Cleanup function (optional)\n  };\n}, [dependencies]); // Dependency array (optional)\n```\n\n-   **Callback Function**: Contains the side effect logic. This function runs after every render where the dependencies have changed.\n-   **Cleanup Function (Return Value)**: An optional function returned by the callback. This function runs before the component unmounts and before the effect runs again (if dependencies change). It's crucial for cleaning up resources to prevent memory leaks (e.g., clearing timers, unsubscribing).\n-   **Dependency Array**: An optional array of values. The effect will only re-run if one of the values in this array changes between renders. If omitted, the effect runs after every render. An empty array `[]` means the effect runs only once after the initial render (and cleanup runs on unmount).\n\n### Debouncing with `useEffect`\n\nDebouncing is a technique used to limit the rate at which a function is called. When applied to an input field, it ensures that a function (e.g., an API call for search results) is not executed until a certain amount of time has passed since the user stopped typing. This is crucial for performance and reducing unnecessary network requests.\n\n`useEffect` is ideal for implementing debouncing because it allows you to:\n1.  **Trigger on Change**: Re-run the effect whenever the input value changes.\n2.  **Delay Execution**: Use `setTimeout` to delay the execution of the actual search logic.\n3.  **Cancel Previous Execution**: Use `clearTimeout` in the cleanup function to cancel any pending delayed executions from previous input changes. This ensures that the search function only runs *after* the user has stopped typing for the specified delay.\n\n**Typical Debouncing Flow:**\n1.  User types a character in the input.\n2.  `searchTerm` state updates.\n3.  `useEffect` detects `searchTerm` change.\n4.  The cleanup function from the *previous* `useEffect` run (if any) clears the old timer.\n5.  A new `setTimeout` is set for the `debouncedSearchTerm` update.\n6.  If the user types again before the timeout, steps 3-5 repeat, resetting the timer.\n7.  If the user stops typing, the timeout eventually completes, updating `debouncedSearchTerm`.\n8.  The `useEffect` watching `debouncedSearchTerm` then triggers the actual search API call.",
          "examples": [
            {
              "id": "example_useeffect_basic",
              "title": "Basic `useEffect` for Logging",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Component rendered or count changed:', count);\n    // This runs after every render where 'count' has changed.\n\n    return () => {\n      console.log('Cleanup for count:', count);\n      // This runs before the next effect or on unmount.\n    };\n  }, [count]); // Dependency array\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates a basic `useEffect` hook. It logs a message whenever the component renders or the `count` state changes. The cleanup function logs before the effect re-runs or when the component unmounts, showing how resources can be managed.",
              "language": "typescript"
            },
            {
              "id": "example_useeffect_debouncing",
              "title": "Debouncing Search Input with `useEffect`",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Simulate an API call\nconst fetchSearchResults = async (query: string) => {\n  console.log(`Fetching results for: \"${query}\"...`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve([{ id: 1, name: `Result for ${query}` }]);\n    }, 500);\n  });\n};\n\nfunction SearchBar() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');\n  const [results, setResults] = useState<{ id: number; name: string }[]>([]);\n\n  // Effect to debounce searchTerm\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedSearchTerm(searchTerm);\n    }, 500); // 500ms debounce delay\n\n    // Cleanup function: clear timeout if searchTerm changes before delay\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [searchTerm]); // Re-run effect whenever searchTerm changes\n\n  // Effect to fetch results when debouncedSearchTerm changes\n  useEffect(() => {\n    if (debouncedSearchTerm) {\n      fetchSearchResults(debouncedSearchTerm).then(results => {\n        setResults(results);\n      });\n    } else {\n      setResults([]);\n    }\n  }, [debouncedSearchTerm]); // Re-run effect whenever debouncedSearchTerm changes\n\n  return (\n    <div>\n      <input\n        value={searchTerm}\n        onChange={e => setSearchTerm(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <ul>\n        {results.map(result => (\n          <li key={result.id}>{result.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example showcases a common pattern for debouncing user input using two `useEffect` hooks. The first `useEffect` manages the `searchTerm` and updates `debouncedSearchTerm` after a delay, ensuring that rapid typing doesn't trigger intermediate updates. Its cleanup function `clearTimeout(handler)` is critical to cancel pending debounces. The second `useEffect` then watches the `debouncedSearchTerm` and triggers the actual (simulated) API call only when the debounced value changes, significantly reducing unnecessary network requests.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_debouncing_1",
            "question_debouncing_2",
            "question_useeffect_1",
            "question_useeffect_2",
            "question_useeffect_3",
            "question_useeffect_4",
            "question_useeffect_5"
          ],
          "relatedTasks": [
            "task_debounced_search_input"
          ],
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Debouncing",
            "Performance",
            "Side Effects",
            "Frontend Optimization",
            "Cleanup Function"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_state_management"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_form_handling",
            "realtime_search",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_usereducer_usecontext",
          "title": "Centralized State Management with `useReducer` and `useContext`",
          "content": "## `useReducer` Hook for Complex State Logic\n\n`useReducer` is a React Hook that is an alternative to `useState` for managing state. It's often preferred for more complex state logic, especially when the next state depends on the previous one, or when state updates involve multiple sub-values. It's inspired by the Redux pattern.\n\n### `useReducer` Signature\n\n```typescript\nconst [state, dispatch] = useReducer(reducer, initialState, init?);\n```\n\n-   **`reducer`**: A pure function that takes the current `state` and an `action` as arguments, and returns the *new* state. It's typically a `switch` statement based on `action.type`.\n-   **`initialState`**: The initial value of the state.\n-   **`init` (optional)**: An optional function to lazily initialize the state. If provided, `initialState` is passed to `init`, and `init`'s return value becomes the initial state.\n-   **`state`**: The current state managed by the reducer.\n-   **`dispatch`**: A function that you call to dispatch an `action`. An `action` is typically an object with a `type` property describing what happened, and often a `payload` with any necessary data.\n\n### `useContext` Hook for Global State Sharing\n\n`useContext` is a React Hook that lets you read and subscribe to a context. Context provides a way to pass data through the component tree without having to pass props down manually at every level (prop drilling).\n\n### `useContext` Flow:\n1.  **Create Context**: `const MyContext = createContext(defaultValue);` creates a Context object.\n2.  **Provide Context**: `<MyContext.Provider value={/* some value */}>` wraps the part of the component tree that needs access to the context. The `value` prop is the data that will be available to consuming components.\n3.  **Consume Context**: `const value = useContext(MyContext);` is used inside a functional component to subscribe to context changes and read its current value.\n\n### Combining `useReducer` and `useContext`\n\nThis combination is a powerful pattern for managing global or complex application state without external libraries like Redux, especially when the state needs to be updated by multiple, deeply nested components.\n\n-   `useReducer` is used in a parent component (often a `Provider` component) to manage the actual state logic.\n-   `useContext` is used to make the `state` and the `dispatch` function available to any descendant component without prop drilling.\n\n### Custom Hooks for Encapsulation\n\nA custom hook (like `useTodo` in the example) is a JavaScript function whose name starts with 'use' and that can call other Hooks. They are a powerful way to reuse stateful logic between components. When combining `useReducer` and `useContext`, a custom hook can abstract away the `useContext` call and provide a more focused API, making components cleaner and more readable.\n\n**Benefits of this pattern:**\n-   **Centralized State Logic**: All state transitions are handled in a single `reducer` function, making it easier to understand and debug.\n-   **Avoids Prop Drilling**: Data and dispatch functions can be accessed by any component within the `Provider`'s scope without explicit prop passing.\n-   **Performance**: `useContext` consumers only re-render when the context `value` changes.\n-   **Scalability**: Well-suited for medium to large applications where state management becomes complex.\n-   **Testability**: Reducer functions are pure and easy to test in isolation.",
          "examples": [
            {
              "id": "example_reducer_context_todo",
              "title": "Todo App with `useReducer` and `useContext`",
              "code": "import React, { createContext, useReducer, useContext } from 'react';\n\n// 1. Create Context\nconst TodoContext = createContext<{\n  todos: { id: number; text: string; completed: boolean }[];\n  dispatch: React.Dispatch<any>;\n} | undefined>(undefined);\n\n// 2. Action Types (constants to avoid typos)\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst DELETE_TODO = 'DELETE_TODO';\n\n// 3. Reducer Function\ninterface TodoState { id: number; text: string; completed: boolean }[];\ninterface TodoAction { type: string; payload?: any; }\n\nfunction todoReducer(state: TodoState, action: TodoAction): TodoState {\n  switch (action.type) {\n    case ADD_TODO:\n      return [...state, { id: Date.now(), text: action.payload, completed: false }];\n    case TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case DELETE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n}\n\n// 4. Provider Component\nfunction TodoProvider({ children }: { children: React.ReactNode }) {\n  const [todos, dispatch] = useReducer(todoReducer, []); // Initialize with an empty array\n  \n  return (\n    <TodoContext.Provider value={{ todos, dispatch }}>\n      {children}\n    </TodoContext.Provider>\n  );\n}\n\n// 5. Custom Hook to Consume Context\nfunction useTodo() {\n  const context = useContext(TodoContext);\n  if (context === undefined) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  }\n  return context;\n}\n\n// 6. Components that use the context\nfunction TodoList() {\n  const { todos, dispatch } = useTodo();\n  \n  return (\n    <ul>\n      {todos.map(todo => (\n        <li\n          key={todo.id}\n          style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\n        >\n          <span onClick={() => dispatch({ type: TOGGLE_TODO, payload: todo.id })}>\n            {todo.text}\n          </span>\n          <button\n            onClick={() => dispatch({ type: DELETE_TODO, payload: todo.id })}>\n            Delete\n          </button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nfunction AddTodo() {\n  const { dispatch } = useTodo();\n  const [text, setText] = React.useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: ADD_TODO, payload: text });\n      setText('');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder=\"Add new todo\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\n// App component to render everything\nfunction App() {\n  return (\n    <TodoProvider>\n      <h1>My Todo List</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}",
              "explanation": "This comprehensive example demonstrates how `useReducer` and `useContext` are used together to manage a global state for a Todo application. It shows the full lifecycle:\n1.  **`createContext`**: Initializes the context.\n2.  **Action Types**: Defines constant strings for action types.\n3.  **`todoReducer`**: A pure function that dictates how the state changes based on dispatched actions.\n4.  **`TodoProvider`**: A component that uses `useReducer` to manage the `todos` state and then provides both `todos` (state) and `dispatch` (updater) via `TodoContext.Provider` to its children.\n5.  **`useTodo` (Custom Hook)**: A custom hook that simplifies consuming the context, abstracting `useContext(TodoContext)` and providing a helpful error message if used outside the provider.\n6.  **Components (`TodoList`, `AddTodo`)**: These components use `useTodo` to access the global state and dispatch actions without needing to pass props down. The `TodoList` maps over `todos` and dispatches `TOGGLE_TODO` and `DELETE_TODO` actions, while `AddTodo` dispatches `ADD_TODO`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_usereducer_1",
            "question_usereducer_2",
            "question_usereducer_3",
            "question_usecontext_1",
            "question_usecontext_2",
            "question_usecontext_3",
            "question_custom_hook_1",
            "question_reducer_context_1",
            "question_reducer_context_2",
            "question_reducer_context_3",
            "question_reducer_context_4",
            "question_reducer_context_5"
          ],
          "relatedTasks": [
            "task_shopping_cart_reducer_context"
          ],
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "useContext",
            "State Management",
            "Global State",
            "Context API",
            "Custom Hooks",
            "Reducer Pattern",
            "Prop Drilling",
            "Architecture"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_state_management",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_state_management",
            "large_scale_react_apps",
            "application_architecture"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_useeffect_1",
          "topic": "React `useEffect` Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useEffect` hook in React?",
          "answer": "`useEffect` allows you to perform side effects in functional components, such as data fetching, subscriptions, or manually changing the DOM.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useEffect",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles"
          ],
          "example": "",
          "tags": [
            "React",
            "useEffect",
            "Hooks"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_useeffect_2",
          "topic": "React `useEffect` Cleanup",
          "level": "medium",
          "type": "mcq",
          "question": "What is the purpose of the return function within a `useEffect` hook, and when is it executed?\n\n```javascript\nuseEffect(() => {\n  // Effect logic\n  return () => {\n    // Cleanup logic\n  };\n}, [dependencies]);\n```",
          "answer": "The return function is a cleanup function that runs before the component unmounts and before the effect runs again due to dependency changes.",
          "options": [
            "It's a function that returns the state to be updated, executed after the effect completes.",
            "It's a cleanup function that runs only when the component unmounts.",
            "The return function is a cleanup function that runs before the component unmounts and before the effect runs again due to dependency changes.",
            "It's an optional function for error handling, executed if the effect encounters an error."
          ],
          "analysisPoints": [
            "Tests understanding of `useEffect`'s lifecycle.",
            "Distinguishes between unmount and re-run cleanup.",
            "Highlights the importance of resource management."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Side Effects",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect` lifecycle",
            "Ability to distinguish between similar concepts"
          ],
          "example": "The cleanup function is vital for preventing memory leaks. For instance, if `useEffect` sets up a timer (`setTimeout`) or an event listener, the cleanup function `clearTimeout` or `removeEventListener` ensures that these resources are released when the component is no longer needed or the effect is re-executed with new dependencies. Without proper cleanup, previous timers or listeners might continue to run, consuming resources or causing unexpected behavior.",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Cleanup"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_useeffect_3",
          "topic": "React `useEffect` Dependency Array",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `useEffect` usage:\n\n```javascript\nfunction MyComponent({ propValue }) {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect ran with count:', count, 'and propValue:', propValue);\n  }, [propValue]);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <p>Count: {count}</p>\n      <p>Prop: {propValue}</p>\n    </div>\n  );\n}\n```\n\nWhen will the `console.log` inside `useEffect` be executed?",
          "answer": "Only when `propValue` changes, or on the initial mount.",
          "options": [
            "After every render of `MyComponent`.",
            "Only when `count` changes.",
            "Only when `propValue` changes, or on the initial mount.",
            "Only once, after the initial mount."
          ],
          "analysisPoints": [
            "Tests understanding of the `useEffect` dependency array.",
            "Highlights that `useEffect` only re-runs if dependencies change.",
            "Emphasizes that variables *not* in the dependency array but used in the effect might be stale if `eslint-plugin-react-hooks` is not used."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect`'s re-render logic",
            "Ability to interpret code snippets"
          ],
          "example": "The `useEffect` hook with a dependency array `[propValue]` means the effect callback will only re-execute if `propValue` has a different value between renders, in addition to running after the initial mount. Changes to `count` will *not* trigger this specific effect, although `count`'s value *inside* the effect will reflect its initial value from the render when the effect was last run, not its current value if `count` changes without `propValue` changing. This is a common source of bugs if `count` were intended to be part of the dependencies but omitted.",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Dependencies"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_debouncing_1",
          "topic": "Debouncing",
          "level": "easy",
          "type": "flashcard",
          "question": "What is debouncing in the context of user input?",
          "answer": "Debouncing is a technique to limit how often a function is called. For user input, it delays the execution of a function until a certain amount of time has passed since the user last performed an action (e.g., typed a character).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Debouncing",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding of core concept"
          ],
          "example": "",
          "tags": [
            "Debouncing",
            "Performance"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_debouncing_2",
          "topic": "Debouncing Implementation",
          "level": "medium",
          "type": "open",
          "question": "Explain how `setTimeout` and `clearTimeout` are used together within `useEffect` to implement a debouncing mechanism for a search input.",
          "answer": "To implement debouncing with `useEffect`, you typically use two state variables: one for the immediate input value (`searchTerm`) and one for the debounced value (`debouncedSearchTerm`).\n\n1.  **`setTimeout`**: Inside a `useEffect` that depends on `searchTerm`, you set a `setTimeout` to update `debouncedSearchTerm` after a specified delay (e.g., 500ms). This delays the actual search logic.\n2.  **`clearTimeout`**: The crucial part is the cleanup function returned by `useEffect`. This cleanup function calls `clearTimeout` on the timer ID obtained from `setTimeout`. If the `searchTerm` changes again before the delay completes, the previous `setTimeout` is cleared, effectively resetting the debounce timer. The `debouncedSearchTerm` is only updated when the user *stops* typing for the duration of the delay, and thus the `useEffect` watching `debouncedSearchTerm` triggers the search API call.",
          "options": [],
          "analysisPoints": [
            "Ability to articulate the debouncing logic.",
            "Understanding of the role of `setTimeout` for delay.",
            "Understanding of the role of `clearTimeout` for cancellation and resetting the timer.",
            "Connecting `useEffect`'s dependency array and cleanup to the debouncing pattern."
          ],
          "keyConcepts": [
            "Debouncing",
            "useEffect",
            "setTimeout",
            "clearTimeout",
            "Cleanup Function"
          ],
          "evaluationCriteria": [
            "Detailed explanation",
            "Correct usage of relevant APIs",
            "Understanding of the interplay between `setTimeout`, `clearTimeout`, and `useEffect` lifecycle"
          ],
          "example": "See `example_useeffect_debouncing` in theory for code. The key is that `return () => clearTimeout(handler)` ensures that if `searchTerm` changes rapidly, the `setDebouncedSearchTerm` for the previous `searchTerm` is cancelled before it can execute. Only the `setDebouncedSearchTerm` associated with the *last* `searchTerm` after the user stops typing will successfully run.",
          "tags": [
            "Debouncing",
            "useEffect",
            "Performance",
            "Interview Question"
          ],
          "prerequisites": [
            "javascript_timers",
            "react_useeffect"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_useeffect_4",
          "topic": "Debouncing Code Challenge",
          "level": "medium",
          "type": "code",
          "question": "Implement a custom React hook `useDebounce` that takes a value and a delay, and returns a debounced version of that value. This hook should be reusable for any value, not just search terms.",
          "answer": "See `tasks_debounced_search_input` solution, specifically the `useDebounce` hook.",
          "options": [],
          "analysisPoints": [
            "Correctly using `useState` and `useEffect`.",
            "Properly setting and clearing timers (`setTimeout`, `clearTimeout`).",
            "Understanding how to encapsulate logic in a custom hook.",
            "Handling edge cases like initial render or delay changes."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Debouncing",
            "useEffect",
            "setTimeout",
            "clearTimeout"
          ],
          "evaluationCriteria": [
            "Functional correctness",
            "Code readability",
            "Reusability",
            "Proper hook usage"
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// Example usage:\nfunction DebouncedInput() {\n  const [inputValue, setInputValue] = useState('');\n  const debouncedInputValue = useDebounce(inputValue, 500);\n\n  useEffect(() => {\n    // This effect runs only when debouncedInputValue changes\n    console.log('Debounced value:', debouncedInputValue);\n    // e.g., fetch data based on debouncedInputValue\n  }, [debouncedInputValue]);\n\n  return (\n    <input\n      type=\"text\"\n      value={inputValue}\n      onChange={(e) => setInputValue(e.target.value)}\n      placeholder=\"Type to debounce...\"\n    />\n  );\n}\n```",
          "tags": [
            "React",
            "Custom Hooks",
            "Debouncing",
            "Coding Challenge"
          ],
          "prerequisites": [
            "react_useeffect",
            "react_usestate",
            "javascript_closures"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_useeffect_5",
          "topic": "UseEffect Lifecycle",
          "level": "hard",
          "type": "open",
          "question": "Describe the lifecycle of `useEffect` with dependencies and a cleanup function. Provide a scenario where incorrectly omitting a dependency from the dependency array could lead to a bug.",
          "answer": "The lifecycle of `useEffect` with dependencies and a cleanup function is as follows:\n1.  **Initial Render**: After the component mounts for the first time, `useEffect`'s callback function is executed.\n2.  **Dependency Change**: On subsequent renders, React compares the current values in the dependency array with their values from the previous render. If any dependency has changed:\n    a.  The *cleanup function* from the *previous* effect run (if one was returned) is executed.\n    b.  The new `useEffect` callback function is then executed.\n3.  **Component Unmount**: When the component unmounts, the *cleanup function* from the *last* effect run is executed.\n\n**Scenario for omitted dependency bug (Stale Closures):**\nConsider a chat application where `useEffect` subscribes to a chat room. You want to display a message count from a `count` state variable.\n\n```javascript\nfunction ChatRoom({ roomId }) {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const handleMessage = (message) => {\n      // This 'count' will be stale if not in dependencies\n      setCount(prevCount => prevCount + 1);\n      console.log(`New message in ${roomId}. Total messages: ${count}`); \n    };\n\n    const subscription = subscribeToChat(roomId, handleMessage);\n    \n    return () => {\n      unsubscribeFromChat(subscription);\n    };\n  }, [roomId]); // 'count' is omitted from dependencies\n\n  return (\n    <div>\n      <p>Messages in {roomId}: {count}</p>\n      {/* ... */}\n    </div>\n  );\n}\n```\n\n**Bug**: If `count` is omitted from the dependency array `[roomId]`, the `handleMessage` function (which forms a closure over `count`) will always capture the `count` value from the render when `useEffect` *last* ran. So, if `roomId` never changes, `useEffect` only runs once on mount. When `handleMessage` is called multiple times, `console.log(count)` will always print `0` (or whatever `count` was initially) because the closure around `handleMessage` captured that initial `count` value. While `setCount(prevCount => prevCount + 1)` correctly updates the state using the functional update, the `console.log` would reflect the stale `count` from the closure.\n\n**Solution**: Include `count` in the dependency array if you intend to use its current value, or more commonly, use a functional update for `setCount` (`setCount(prevCount => prevCount + 1)`) to avoid needing `count` in dependencies for state updates, but be mindful of any other variables used within the effect's closure that need to be up-to-date. In this `console.log` scenario, the `count` in the log would still be stale without including it or making it a ref, or simply removing it if its up-to-date value isn't critical for the side effect itself. The ESLint rule `exhaustive-deps` helps catch such issues.",
          "options": [],
          "analysisPoints": [
            "Comprehensive understanding of `useEffect` lifecycle including initial run, dependency change, and unmount.",
            "Ability to explain the concept of stale closures in `useEffect`.",
            "Provide a concrete, realistic example of a bug caused by missing dependencies.",
            "Demonstrate knowledge of how to mitigate such bugs (e.g., functional updates, `useRef`, `exhaustive-deps` ESLint rule)."
          ],
          "keyConcepts": [
            "useEffect Lifecycle",
            "Dependencies",
            "Cleanup Function",
            "Stale Closures",
            "Bugs in React",
            "ESLint"
          ],
          "evaluationCriteria": [
            "Depth of explanation",
            "Accuracy of lifecycle steps",
            "Clarity of bug example",
            "Proposed solutions"
          ],
          "example": "",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Advanced",
            "Interview Question",
            "Bugs",
            "Performance"
          ],
          "prerequisites": [
            "react_useeffect",
            "javascript_closures"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_usereducer_1",
          "topic": "React `useReducer` Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "When is `useReducer` generally preferred over `useState` for managing component state?",
          "answer": "`useReducer` is preferred for more complex state logic, when the next state depends on the previous one, or when state updates involve multiple sub-values (e.g., multiple related fields in a form, or complex transitions).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useReducer",
            "useState",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of hook choice criteria"
          ],
          "example": "",
          "tags": [
            "React",
            "useReducer",
            "Hooks"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_usereducer_2",
          "topic": "React `useReducer` Action Types",
          "level": "medium",
          "type": "mcq",
          "question": "In the `todoReducer` function provided previously:\n\n```javascript\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [...state, { id: Date.now(), text: action.payload, completed: false }];\n    case TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case DELETE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n}\n```\n\nWhat is the role of `action.payload` and what would happen if `action.payload` was missing when dispatching a `TOGGLE_TODO` action?",
          "answer": "The `action.payload` carries the data necessary for the reducer to perform the state update. If it's missing for `TOGGLE_TODO`, the reducer wouldn't know which todo item to toggle, leading to an incorrect state or an error.",
          "options": [
            "It specifies the reducer function to be called; the reducer would still work if it's missing.",
            "It's an optional message for debugging; the action would still process normally.",
            "The `action.payload` carries the data necessary for the reducer to perform the state update. If it's missing for `TOGGLE_TODO`, the reducer wouldn't know which todo item to toggle, leading to an incorrect state or an error.",
            "It indicates the urgency of the action; the action would default to low urgency."
          ],
          "analysisPoints": [
            "Tests understanding of action structure in `useReducer`.",
            "Highlights the importance of `payload` for data transfer.",
            "Predicting consequences of missing data."
          ],
          "keyConcepts": [
            "useReducer",
            "Actions",
            "Payload",
            "Reducer Pattern"
          ],
          "evaluationCriteria": [
            "Understanding of action structure",
            "Ability to reason about code behavior"
          ],
          "example": "In Redux or `useReducer` patterns, actions are objects that describe 'what happened'. The `type` property describes the event, and `payload` typically holds any relevant data needed to update the state. For `TOGGLE_TODO`, the `payload` is crucial because it provides the `id` of the specific todo item that needs to be toggled. Without it, the `state.map` operation's condition (`todo.id === action.payload`) would fail to find a match, leading to no item being toggled.",
          "tags": [
            "React",
            "useReducer",
            "Actions",
            "State Management"
          ],
          "prerequisites": [
            "react_use_reducer"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usereducer_3",
          "topic": "React `useReducer` vs `useState`",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast `useState` and `useReducer` in React. Provide scenarios where each would be the more appropriate choice.",
          "answer": "**`useState`**\n*   **Purpose**: Simpler state management for individual primitive values or simple objects/arrays.\n*   **API**: Returns the current state and a setter function (`[state, setState] = useState(initialState)`).\n*   **Updates**: Direct updates, e.g., `setCount(count + 1)` or `setObject({ ...object, key: value })`.\n*   **Scenarios**: Toggling boolean flags, managing input field values, simple counters, or any state that doesn't have complex transitions or depend heavily on previous states.\n\n**`useReducer`**\n*   **Purpose**: More powerful state management for complex state logic, especially when state transitions are explicit and involve multiple sub-values, or when the next state depends on the previous one in a non-trivial way.\n*   **API**: Returns the current state and a `dispatch` function (`[state, dispatch] = useReducer(reducer, initialState)`).\n*   **Updates**: Updates are performed by dispatching 'actions' (objects describing 'what happened') to a separate `reducer` function, which then computes the new state.\n*   **Scenarios**: Shopping carts, complex forms with interdependencies, managing multiple related pieces of state (e.g., loading, error, data states for an API call), or when you prefer a Redux-like state management pattern.\n\n**Comparison:**\n*   **Simplicity**: `useState` is simpler for basic cases. `useReducer` has a steeper learning curve due to the reducer pattern.\n*   **Logic Separation**: `useReducer` cleanly separates state logic (in the reducer function) from component rendering logic. `useState` often leads to state logic being intertwined with component logic.\n*   **Predictability**: `useReducer` can lead to more predictable state updates, especially with complex transitions, as all state changes go through the reducer.\n*   **Performance**: For deeply nested updates, `useReducer` can sometimes be more performant as React can optimize re-renders if the `dispatch` function (which is stable) is passed down instead of multiple `setState` functions.\n*   **Bundle Size**: `useReducer` has a slightly larger footprint than `useState` due to the additional logic involved.\n\n**When to choose:**\n*   **`useState`**: For simple, independent state variables (e.g., `const [isOpen, setIsOpen] = useState(false);`).\n*   **`useReducer`**: For complex state that has multiple, interconnected updates, or when you want to centralize state transition logic (e.g., a multi-step form, a game state, a shopping cart). It's also great when state updates are dispatched from deeply nested components, as `dispatch` is stable and doesn't need to be in dependency arrays.\n\nIn summary, `useState` is great for simple, localized state, while `useReducer` excels at managing more elaborate, predictable state transitions, especially when combined with `useContext` for global state.",
          "options": [],
          "analysisPoints": [
            "Clear distinction between `useState` and `useReducer` APIs.",
            "Accurate identification of use cases for each hook.",
            "Discussion of pros and cons (simplicity, logic separation, predictability, performance).",
            "Structured comparison with concrete examples."
          ],
          "keyConcepts": [
            "useState",
            "useReducer",
            "State Management",
            "React Hooks",
            "Reducer Pattern"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison",
            "Contextual understanding",
            "Clarity and organization"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "State Management",
            "Interview Question"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usecontext_1",
          "topic": "React `useContext` Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What problem does `useContext` primarily solve in React applications?",
          "answer": "`useContext` primarily solves 'prop drilling', allowing data to be passed deeply through the component tree without manually passing props at every level.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useContext",
            "Prop Drilling",
            "Context API"
          ],
          "evaluationCriteria": [
            "Understanding of core problem solved"
          ],
          "example": "",
          "tags": [
            "React",
            "useContext",
            "Hooks"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_usecontext_2",
          "topic": "React `useContext` Usage",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React Context setup:\n\n```javascript\nimport React, { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext('light');\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = React.useState('light');\n  return (\n    <ThemeContext.Provider value={theme}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nfunction ThemedComponent() {\n  // Line A: How to access the theme value here?\n  return <p>Current Theme: {themeValue}</p>;\n}\n\nfunction App() {\n  return (\n    <ThemeProvider>\n      <ThemedComponent />\n    </ThemeProvider>\n  );\n}\n```\n\nWhich line correctly accesses the `theme` value within `ThemedComponent`?",
          "answer": "```javascript\nconst themeValue = useContext(ThemeContext);\n```",
          "options": [
            "```javascript\nconst themeValue = ThemeContext.value;\n```",
            "```javascript\nconst themeValue = this.context.theme;\n```",
            "```javascript\nconst themeValue = useContext(ThemeContext);\n```",
            "```javascript\nconst themeValue = ThemeProvider.theme;\n```"
          ],
          "analysisPoints": [
            "Tests the correct usage of the `useContext` hook.",
            "Distinguishes `useContext` from other incorrect ways of accessing context.",
            "Reinforces that `useContext` is a hook used within functional components."
          ],
          "keyConcepts": [
            "useContext",
            "Context API",
            "Provider",
            "Consumer"
          ],
          "evaluationCriteria": [
            "Correct application of `useContext`",
            "Understanding of React Hooks syntax"
          ],
          "example": "The `useContext` hook is the standard way to consume context in functional components. It takes the `Context` object (e.g., `ThemeContext`) as an argument and returns the current context `value` as provided by the nearest `Provider` up the component tree. Other options represent incorrect or outdated ways (e.g., `this.context` is for class components).",
          "tags": [
            "React",
            "useContext",
            "Hooks",
            "MCQ"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usecontext_3",
          "topic": "Context API Limitations",
          "level": "hard",
          "type": "open",
          "question": "While `useContext` is powerful for global state, what are some of its limitations or potential downsides, especially when used for highly-frequently updated state?",
          "answer": "While `useContext` is excellent for avoiding prop drilling and sharing static or infrequently updated data, it has some limitations when used for highly-frequently updated state:\n\n1.  **Re-renders All Consumers**: When the `value` prop passed to a `Context.Provider` changes, *all* components that consume that context (using `useContext`) will re-render, regardless of whether the specific part of the context they use has changed. This can lead to unnecessary re-renders and performance issues if the context value is an object or array that's frequently recreated.\n2.  **No Selectors/Memoization Built-in**: Unlike state management libraries (e.g., Redux with `mapStateToProps` or Zustand with selectors), `useContext` doesn't provide a built-in mechanism to 'select' only specific parts of the context value and prevent re-renders if other parts change. Developers often have to implement their own memoization (e.g., `useMemo` for the `value` object, or custom hooks with internal state/`useRef` and `useCallback`) to mitigate this.\n3.  **Single Value Limitation**: A single context can only hold one `value`. If you want to provide multiple, unrelated pieces of global state, you often end up creating many separate contexts and nesting multiple `Provider` components, which can make the component tree verbose.\n4.  **Performance with Object/Array Values**: If the `value` prop is an object or array, and it's created inline in the provider component, it will be a new object/array on every render, even if its contents are shallowly the same. This causes `useContext` consumers to re-render unnecessarily because `value` changes by reference. You need to `useMemo` the `value` object to prevent this.\n\n**Example of Re-render issue:**\nIf you have a `UserContext.Provider` providing `{ user: { name, email }, isAuthenticated: true }` and `isAuthenticated` changes frequently, even components only interested in `user.name` will re-render because the entire `value` object reference changes.",
          "options": [],
          "analysisPoints": [
            "Identification of re-rendering all consumers.",
            "Lack of built-in selector mechanism.",
            "Limitation to a single value.",
            "Performance issues with frequently changing object/array values.",
            "Explanation of why performance issues occur (reference equality)."
          ],
          "keyConcepts": [
            "useContext",
            "Context API",
            "Performance",
            "Re-renders",
            "Prop Drilling",
            "State Management",
            "Memoization"
          ],
          "evaluationCriteria": [
            "Depth of understanding of limitations",
            "Ability to explain technical reasons (e.g., reference equality)",
            "Suggesting mitigation strategies"
          ],
          "example": "",
          "tags": [
            "React",
            "useContext",
            "Performance",
            "Advanced",
            "Interview Question"
          ],
          "prerequisites": [
            "react_usecontext",
            "javascript_objects_references"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_custom_hook_1",
          "topic": "Custom Hooks",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary benefit of creating a custom hook like `useTodo` for `useReducer` and `useContext`?",
          "answer": "The primary benefit is to encapsulate and reuse stateful logic (like accessing context and its dispatch function), making components cleaner, more readable, and promoting separation of concerns.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Custom Hooks",
            "Reusability",
            "Separation of Concerns"
          ],
          "evaluationCriteria": [
            "Understanding of custom hook benefits"
          ],
          "example": "",
          "tags": [
            "React",
            "Custom Hooks",
            "Hooks"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reducer_context_1",
          "topic": "Combining `useReducer` and `useContext`",
          "level": "medium",
          "type": "open",
          "question": "Describe the architectural pattern of combining `useReducer` and `useContext` for state management in a React application. What are its advantages over simply passing state and setState down via props?",
          "answer": "The pattern involves using `useReducer` within a parent component (typically a 'Provider' component) to manage complex state logic, and then using `useContext` to make both the current state and the `dispatch` function available to any descendant component without passing them as props.\n\n**Architectural Pattern:**\n1.  **Reducer**: A pure function (`reducer(state, action)`) defines all possible state transitions.\n2.  **Context**: A React Context object is created (`createContext`).\n3.  **Provider Component**: A dedicated component (e.g., `TodoProvider`) uses `useReducer` to manage the actual state. It then renders `Context.Provider` and passes the `state` and `dispatch` function as the `value` prop to its children.\n4.  **Custom Hook (Optional but Recommended)**: A custom hook (e.g., `useTodo`) is created to abstract the `useContext` call, providing a cleaner, type-safe, and often more robust way to consume the context.\n5.  **Consumers**: Any component within the `Provider`'s subtree can use the custom hook (or `useContext` directly) to access the global state and dispatch actions.\n\n**Advantages over passing state/setState via props (Prop Drilling):**\n1.  **Avoids Prop Drilling**: This is the primary advantage. You don't need to manually pass state and updater functions through many intermediate components that don't actually use that data. This significantly simplifies component signatures and the overall component tree structure.\n2.  **Cleaner Components**: Consumer components only need to `useContext` (or the custom hook) to get what they need, without worrying about how the state flows from the top. Their props remain focused on their immediate data needs.\n3.  **Centralized Logic**: All complex state mutation logic is isolated within the `reducer` function, making it easier to understand, test, and debug. Components only dispatch 'actions' without knowing the implementation details of state updates.\n4.  **Performance (Dispatch Function Stability)**: The `dispatch` function returned by `useReducer` is guaranteed to be stable across re-renders. This means you can pass `dispatch` down without causing unnecessary re-renders in child components that receive it as a prop or include it in their `useEffect`/`useCallback` dependency arrays.",
          "options": [],
          "analysisPoints": [
            "Clear explanation of the roles of `useReducer`, `useContext`, and the Provider/Consumer pattern.",
            "Detailed comparison with prop drilling.",
            "Highlighting benefits like centralized logic and `dispatch` stability.",
            "Discussion of custom hooks as an enhancement."
          ],
          "keyConcepts": [
            "useReducer",
            "useContext",
            "State Management",
            "Context API",
            "Prop Drilling",
            "Reducer Pattern",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of pattern",
            "Accurate comparison of benefits",
            "Clarity and structure"
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "Hooks",
            "Architecture",
            "Interview Question"
          ],
          "prerequisites": [
            "react_use_reducer",
            "react_use_context"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_reducer_context_2",
          "topic": "Combining `useReducer` and `useContext`",
          "level": "hard",
          "type": "code",
          "question": "Refactor a simple counter application to use `useReducer` and `useContext`. The application should have an `App` component that renders a `CounterProvider`, and within it, a `CounterDisplay` component showing the current count, and `IncrementButton` and `DecrementButton` components that update the count.",
          "answer": "```typescript\nimport React, { createContext, useReducer, useContext } from 'react';\n\n// 1. Define Action Types\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\nconst RESET = 'RESET';\n\ninterface CounterState {\n  count: number;\n}\n\ninterface CounterAction {\n  type: string;\n  payload?: number;\n}\n\n// 2. Reducer Function\nfunction counterReducer(state: CounterState, action: CounterAction): CounterState {\n  switch (action.type) {\n    case INCREMENT:\n      return { ...state, count: state.count + (action.payload || 1) };\n    case DECREMENT:\n      return { ...state, count: state.count - (action.payload || 1) };\n    case RESET:\n      return { ...state, count: 0 };\n    default:\n      return state;\n  }\n}\n\n// 3. Create Context\nconst CounterContext = createContext<{\n  state: CounterState;\n  dispatch: React.Dispatch<CounterAction>;\n} | undefined>(undefined);\n\n// 4. Provider Component\nfunction CounterProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n\n  return (\n    <CounterContext.Provider value={{ state, dispatch }}>\n      {children}\n    </CounterContext.Provider>\n  );\n}\n\n// 5. Custom Hook to Consume Context\nfunction useCounter() {\n  const context = useContext(CounterContext);\n  if (context === undefined) {\n    throw new Error('useCounter must be used within a CounterProvider');\n  }\n  return context;\n}\n\n// 6. Components that use the context\nfunction CounterDisplay() {\n  const { state } = useCounter();\n  return <p>Current Count: {state.count}</p>;\n}\n\nfunction IncrementButton() {\n  const { dispatch } = useCounter();\n  return <button onClick={() => dispatch({ type: INCREMENT })}>Increment</button>;\n}\n\nfunction DecrementButton() {\n  const { dispatch } = useCounter();\n  return <button onClick={() => dispatch({ type: DECREMENT })}>Decrement</button>;\n}\n\nfunction ResetButton() {\n  const { dispatch } = useCounter();\n  return <button onClick={() => dispatch({ type: RESET })}>Reset</button>;\n}\n\n// App component\nfunction App() {\n  return (\n    <CounterProvider>\n      <h1>Global Counter</h1>\n      <CounterDisplay />\n      <IncrementButton />\n      <DecrementButton />\n      <ResetButton />\n    </CounterProvider>\n  );\n}\n\nexport default App;\n```",
          "options": [],
          "analysisPoints": [
            "Correct implementation of `useReducer` and `useContext`.",
            "Proper separation of concerns into reducer, provider, and consumer components.",
            "Definition of action types and reducer logic.",
            "Effective use of a custom hook for context consumption.",
            "Demonstrates understanding of TypeScript types for state and actions."
          ],
          "keyConcepts": [
            "useReducer",
            "useContext",
            "Context API",
            "State Management",
            "Custom Hooks",
            "Reducer Pattern",
            "TypeScript"
          ],
          "evaluationCriteria": [
            "Functional correctness",
            "Adherence to architectural pattern",
            "Code clarity and structure",
            "Appropriate use of hooks"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Coding Challenge",
            "State Management"
          ],
          "prerequisites": [
            "react_use_reducer",
            "react_use_context"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_reducer_context_3",
          "topic": "State Immutability with `useReducer`",
          "level": "medium",
          "type": "flashcard",
          "question": "Why is it crucial for a `useReducer` function to return a new state object/array rather than mutating the existing state directly?",
          "answer": "Returning a new state object/array is crucial for immutability. React relies on reference equality checks to detect state changes and trigger re-renders. If you mutate the original state directly, React won't detect a change (because the reference remains the same) and your components won't re-render, leading to UI inconsistencies.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useReducer",
            "Immutability",
            "State Management",
            "React Re-renders"
          ],
          "evaluationCriteria": [
            "Understanding of immutability importance"
          ],
          "example": "",
          "tags": [
            "React",
            "useReducer",
            "Immutability"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reducer_context_4",
          "topic": "Error Handling with `useContext`",
          "level": "medium",
          "type": "open",
          "question": "The `useTodo` custom hook includes an error check: `if (!context) { throw new Error('useTodo must be used within a TodoProvider'); }`. Why is this check important, and what problem does it prevent?",
          "answer": "This check is crucial because `useContext` will return `undefined` (or the `defaultValue` provided to `createContext`, which is `undefined` in this case) if it's called outside of its corresponding `Provider`. \n\n**Why it's important:**\n1.  **Prevents Runtime Errors**: Without this check, if a component using `useTodo` is rendered outside the `TodoProvider`'s scope, `context` would be `undefined`. Any attempt to access properties like `context.todos` or `context.dispatch` would result in a `TypeError: Cannot read properties of undefined (reading 'todos')` or similar, causing a crash that can be hard to trace.\n2.  **Provides Clearer Debugging**: The `throw new Error` provides an explicit, descriptive error message that immediately tells the developer exactly what went wrong and how to fix it (by wrapping the component in `TodoProvider`). This is much more helpful than a generic `TypeError`.\n3.  **Enforces Correct Usage**: It ensures that consumers of the context are always within the intended context provider's hierarchy, upholding the architectural pattern.",
          "options": [],
          "analysisPoints": [
            "Explains what `useContext` returns when used outside a Provider.",
            "Identifies the specific runtime error it prevents.",
            "Highlights the benefit of clear error messages for debugging.",
            "Emphasizes enforcing correct usage of the context API pattern."
          ],
          "keyConcepts": [
            "useContext",
            "Custom Hooks",
            "Error Handling",
            "Context API",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Clear explanation of problem prevented",
            "Understanding of error message benefits",
            "Demonstrates practical coding wisdom"
          ],
          "example": "",
          "tags": [
            "React",
            "useContext",
            "Custom Hooks",
            "Error Handling",
            "Interview Question"
          ],
          "prerequisites": [
            "react_use_context",
            "javascript_error_handling"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reducer_context_5",
          "topic": "React Hooks Performance",
          "level": "hard",
          "type": "mcq",
          "question": "When using `useReducer` and `useContext` together, what is a key performance consideration related to the `value` prop of `Context.Provider`?\n\n```typescript\nfunction MyProvider({ children }) {\n  const [state, dispatch] = useReducer(myReducer, initialState);\n  \n  // Line A: Potentially problematic value\n  const contextValue = { state, dispatch }; \n  \n  return (\n    <MyContext.Provider value={contextValue}>\n      {children}\n    </MyContext.Provider>\n  );\n}\n```",
          "answer": "If `contextValue` is an object created inline on every render (as in Line A), all consumers of `MyContext` will re-render even if `state` or `dispatch` haven't functionally changed, because the object reference changes.",
          "options": [
            "The `dispatch` function changes on every render, causing re-renders in consumers unless memoized.",
            "If `contextValue` is an object created inline on every render (as in Line A), all consumers of `MyContext` will re-render even if `state` or `dispatch` haven't functionally changed, because the object reference changes.",
            "Only components directly consuming `dispatch` will re-render when `state` changes.",
            "React automatically memoizes the `value` prop, so no manual optimization is needed."
          ],
          "analysisPoints": [
            "Tests understanding of reference equality in JavaScript and React's re-render mechanism.",
            "Highlights the specific performance pitfall of inline object creation for `Context.Provider`'s `value`.",
            "Correctly identifies that `dispatch` is stable, debunking a common misconception."
          ],
          "keyConcepts": [
            "Context API",
            "useReducer",
            "Performance",
            "Re-renders",
            "Reference Equality",
            "useMemo"
          ],
          "evaluationCriteria": [
            "Accuracy of performance analysis",
            "Understanding of object references",
            "Identification of correct solution (though not explicitly asked, it implies `useMemo`)"
          ],
          "example": "In the provided code, `contextValue = { state, dispatch }` creates a *new object* on every render of `MyProvider`. Even if `state` remains the same (by content), the `contextValue` object itself has a new memory address. Since React's context API triggers re-renders for consumers when the `value` prop's *reference* changes, all components using `useContext(MyContext)` will re-render unnecessarily. To fix this, `contextValue` should be memoized using `useMemo`:\n\n```typescript\nconst contextValue = React.useMemo(() => ({ state, dispatch }), [state, dispatch]);\n```\n\nThis ensures `contextValue` only changes its reference when `state` or `dispatch` (which is stable) actually change, preventing unnecessary re-renders. (Note: `dispatch` itself is stable and doesn't need to be in the `useMemo` dependency array, but including it causes no harm).",
          "tags": [
            "React",
            "Context API",
            "Performance",
            "Hooks",
            "MCQ"
          ],
          "prerequisites": [
            "react_functional_components",
            "javascript_objects_references",
            "react_usememo"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_debounced_search_input",
          "title": "Implement a Debounced Search Input Component",
          "description": "\nCreate a React component `DebouncedSearch` that includes an input field. As the user types, the component should not immediately perform a 'search' (e.g., console log the search term). Instead, it should wait for a specified delay after the user stops typing before displaying the final search term. This demonstrates the debouncing pattern.\n\n**Requirements:**\n1.  Render an input field and a display area for the debounced search term.\n2.  Implement a debouncing mechanism with a configurable delay (e.g., 500ms).\n3.  The debounced term should only update after the user pauses typing for the specified delay.\n4.  The component should be robust against rapid successive key presses (i.e., previous timeouts should be cleared).\n5.  (Optional but Recommended): Extract the debouncing logic into a reusable custom hook named `useDebounce`.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Optional: Create a reusable useDebounce hook here\n// function useDebounce<T>(value: T, delay: number): T {\n//   // Implement debounce logic\n//   return debouncedValue;\n// }\n\nfunction DebouncedSearch() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');\n\n  // TODO: Implement the debouncing logic using useEffect\n  // - Set a timeout to update debouncedSearchTerm based on searchTerm\n  // - Return a cleanup function to clear the timeout\n\n  return (\n    <div>\n      <h2>Debounced Search</h2>\n      <input\n        type=\"text\"\n        value={searchTerm}\n        onChange={e => setSearchTerm(e.target.value)}\n        placeholder=\"Type to search...\"\n        style={{ padding: '8px', width: '300px' }}\n      />\n      <p>Current Input: <strong>{searchTerm}</strong></p>\n      <p>Debounced Search Term (after 500ms pause): <strong>{debouncedSearchTerm}</strong></p>\n    </div>\n  );\n}\n\nexport default DebouncedSearch;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// Reusable custom hook for debouncing any value\nfunction useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    // Set a timeout to update the debounced value\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    // Cleanup function: clear timeout if value or delay changes before timeout fires\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]); // Re-run effect only if value or delay changes\n\n  return debouncedValue;\n}\n\nfunction DebouncedSearch() {\n  const [searchTerm, setSearchTerm] = useState('');\n  \n  // Use the custom useDebounce hook\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n\n  // Optional: Effect to simulate fetching results when debounced term changes\n  useEffect(() => {\n    if (debouncedSearchTerm) {\n      console.log(`Performing search for: \"${debouncedSearchTerm}\"`);\n      // In a real app: fetchSearchResults(debouncedSearchTerm).then(results => ...);\n    } else {\n      console.log('Debounced search term is empty, clearing results.');\n    }\n  }, [debouncedSearchTerm]); // This effect runs only when debouncedSearchTerm changes\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px' }}>\n      <h2>Debounced Search Input</h2>\n      <input\n        type=\"text\"\n        value={searchTerm}\n        onChange={e => setSearchTerm(e.target.value)}\n        placeholder=\"Type to search...\"\n        style={{ padding: '10px', fontSize: '16px', width: '100%', boxSizing: 'border-box' }}\n      />\n      <p style={{ marginTop: '15px' }}>\n        <strong>Current Input:</strong> <span style={{ color: '#007bff' }}>{searchTerm}</span>\n      </p>\n      <p>\n        <strong>Debounced Value (after 500ms pause):</strong> <span style={{ color: '#28a745' }}>{debouncedSearchTerm}</span>\n      </p>\n      <p style={{ fontSize: '0.9em', color: '#666' }}>\n        Check console for simulated API calls.\n      </p>\n    </div>\n  );\n}\n\nexport default DebouncedSearch;\n",
          "testCases": [
            "Type 'a', wait 500ms: Debounced term should become 'a'.",
            "Type 'ap', then 'app' quickly: Debounced term should become 'app' only after 500ms pause from the last 'p'. Intermediate 'ap' should not appear as debounced.",
            "Type 'test', then clear input immediately: Debounced term should become empty (or previous value) after 500ms pause.",
            "Rapidly type 'hello world': The debounced term should only update once with 'hello world' after a 500ms pause from the last character.",
            "Start typing, then navigate away (component unmounts): Ensure no errors occur and timers are properly cleared."
          ],
          "hints": [
            "You'll need `useState` for both the immediate input value and the debounced value.",
            "The `useEffect` hook will be essential for setting and clearing timers.",
            "Remember that `useEffect` can return a cleanup function, which is perfect for `clearTimeout`.",
            "The dependency array for `useEffect` should include the `searchTerm` to trigger a new debounce when the input changes.",
            "Consider extracting the `useEffect` logic into a custom `useDebounce` hook for reusability across your application."
          ],
          "tags": [
            "React",
            "Hooks",
            "Debouncing",
            "Performance",
            "useEffect",
            "Custom Hooks"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_useeffect",
            "react_usestate",
            "javascript_timers"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Side Effects",
            "Cleanup Function",
            "Performance Optimization"
          ]
        },
        {
          "id": "task_shopping_cart_reducer_context",
          "title": "Build a Simple Shopping Cart with `useReducer` and `useContext`",
          "description": "\nImplement a basic shopping cart functionality in a React application using the `useReducer` and `useContext` hooks. The application should allow users to add items, remove items, and view the current items in the cart.\n\n**Requirements:**\n1.  **Context Setup**: Create a `CartContext` using `createContext`.\n2.  **Reducer**: Implement a `cartReducer` function that handles actions for `ADD_ITEM`, `REMOVE_ITEM`, and potentially `CLEAR_CART`.\n3.  **Provider**: Create a `CartProvider` component that wraps the main application, initializes the `cartReducer`, and provides the `cartState` and `dispatch` function via `CartContext.Provider`.\n4.  **Custom Hook**: Implement a `useCart` custom hook to simplify accessing the cart context (state and dispatch).\n5.  **Components**: \n    *   `ProductList`: Displays a list of products, each with an 'Add to Cart' button.\n    *   `ShoppingCart`: Displays the items currently in the cart, with 'Remove' buttons for each item.\n    *   Ensure all components correctly interact with the global cart state using the `useCart` hook.\n",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useReducer, useContext } from 'react';\n\n// Define types for item, state, and actions\ninterface CartItem {\n  id: number;\n  name: string;\n  price: number;\n  quantity: number;\n}\n\ninterface CartState {\n  items: CartItem[];\n}\n\ninterface CartAction {\n  type: string;\n  payload: any;\n}\n\n// 1. Create Context (with a default value that matches the structure)\nconst CartContext = createContext<{\n  state: CartState;\n  dispatch: React.Dispatch<CartAction>;\n} | undefined>(undefined);\n\n// 2. Action Types (Constants)\nconst ADD_ITEM = 'ADD_ITEM';\nconst REMOVE_ITEM = 'REMOVE_ITEM';\nconst CLEAR_CART = 'CLEAR_CART';\n\n// 3. Reducer Function\nfunction cartReducer(state: CartState, action: CartAction): CartState {\n  switch (action.type) {\n    case ADD_ITEM:\n      // TODO: Implement logic to add item. If item exists, increment quantity.\n      return state;\n    case REMOVE_ITEM:\n      // TODO: Implement logic to remove item. If quantity > 1, decrement. Else, remove fully.\n      return state;\n    case CLEAR_CART:\n      // TODO: Implement logic to clear all items.\n      return state;\n    default:\n      return state;\n  }\n}\n\n// 4. Provider Component\nfunction CartProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = useReducer(cartReducer, { items: [] });\n\n  return (\n    <CartContext.Provider value={{ state, dispatch }}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\n// 5. Custom Hook to consume context\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (context === undefined) {\n    throw new Error('useCart must be used within a CartProvider');\n  }\n  return context;\n}\n\n// Example Product Data\nconst products = [\n  { id: 1, name: 'Laptop', price: 1200 },\n  { id: 2, name: 'Mouse', price: 25 },\n  { id: 3, name: 'Keyboard', price: 75 },\n];\n\n// 6. ProductList Component\nfunction ProductList() {\n  const { dispatch } = useCart();\n\n  return (\n    <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '5px' }}>\n      <h3>Available Products</h3>\n      {products.map(product => (\n        <div key={product.id} style={{ marginBottom: '10px' }}>\n          {product.name} - ${product.price} \n          <button onClick={() => dispatch({ type: ADD_ITEM, payload: product })} style={{ marginLeft: '10px' }}>\n            Add to Cart\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// 7. ShoppingCart Component\nfunction ShoppingCart() {\n  const { state, dispatch } = useCart();\n\n  const total = state.items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n\n  return (\n    <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '5px', marginTop: '20px' }}>\n      <h3>Shopping Cart</h3>\n      {state.items.length === 0 ? (\n        <p>Cart is empty.</p>\n      ) : (\n        <ul>\n          {state.items.map(item => (\n            <li key={item.id}>\n              {item.name} (x{item.quantity}) - ${item.price * item.quantity}\n              <button onClick={() => dispatch({ type: REMOVE_ITEM, payload: item.id })} style={{ marginLeft: '10px' }}>\n                Remove\n              </button>\n            </li>\n          ))}\n        </ul>\n      )}\n      <p><strong>Total: ${total.toFixed(2)}</strong></p>\n      {state.items.length > 0 && (\n        <button onClick={() => dispatch({ type: CLEAR_CART })}>Clear Cart</button>\n      )}\n    </div>\n  );\n}\n\n// App component to render everything\nfunction App() {\n  return (\n    <CartProvider>\n      <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #ddd', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\n        <h1>My Online Store</h1>\n        <ProductList />\n        <ShoppingCart />\n      </div>\n    </CartProvider>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { createContext, useReducer, useContext, useMemo } from 'react';\n\n// Define types for item, state, and actions\ninterface CartItem {\n  id: number;\n  name: string;\n  price: number;\n  quantity: number;\n}\n\ninterface CartState {\n  items: CartItem[];\n}\n\ninterface AddItemPayload {\n  id: number;\n  name: string;\n  price: number;\n}\n\ninterface RemoveItemPayload {\n  id: number;\n}\n\ntype CartAction = \n  | { type: 'ADD_ITEM', payload: AddItemPayload }\n  | { type: 'REMOVE_ITEM', payload: RemoveItemPayload }\n  | { type: 'CLEAR_CART' };\n\n// 1. Create Context (with a default value that matches the structure)\nconst CartContext = createContext<{\n  state: CartState;\n  dispatch: React.Dispatch<CartAction>;\n} | undefined>(undefined);\n\n// 2. Action Types (Constants)\nconst ADD_ITEM = 'ADD_ITEM';\nconst REMOVE_ITEM = 'REMOVE_ITEM';\nconst CLEAR_CART = 'CLEAR_CART';\n\n// 3. Reducer Function\nfunction cartReducer(state: CartState, action: CartAction): CartState {\n  switch (action.type) {\n    case ADD_ITEM:\n      const existingItem = state.items.find(item => item.id === action.payload.id);\n      if (existingItem) {\n        return {\n          ...state,\n          items: state.items.map(item =>\n            item.id === action.payload.id\n              ? { ...item, quantity: item.quantity + 1 }\n              : item\n          ),\n        };\n      } else {\n        return {\n          ...state,\n          items: [...state.items, { ...action.payload, quantity: 1 }],\n        };\n      }\n    case REMOVE_ITEM:\n      const itemToRemove = state.items.find(item => item.id === action.payload.id);\n      if (itemToRemove && itemToRemove.quantity > 1) {\n        return {\n          ...state,\n          items: state.items.map(item =>\n            item.id === action.payload.id\n              ? { ...item, quantity: item.quantity - 1 }\n              : item\n          ),\n        };\n      } else {\n        return {\n          ...state,\n          items: state.items.filter(item => item.id !== action.payload.id),\n        };\n      }\n    case CLEAR_CART:\n      return { ...state, items: [] };\n    default:\n      return state;\n  }\n}\n\n// 4. Provider Component\nfunction CartProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = useReducer(cartReducer, { items: [] });\n\n  // Memoize the value to prevent unnecessary re-renders of consumers\n  const contextValue = useMemo(() => ({ state, dispatch }), [state]);\n\n  return (\n    <CartContext.Provider value={contextValue}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\n// 5. Custom Hook to consume context\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (context === undefined) {\n    throw new Error('useCart must be used within a CartProvider');\n  }\n  return context;\n}\n\n// Example Product Data\nconst products = [\n  { id: 1, name: 'Laptop', price: 1200 },\n  { id: 2, name: 'Mouse', price: 25 },\n  { id: 3, name: 'Keyboard', price: 75 },\n];\n\n// 6. ProductList Component\nfunction ProductList() {\n  const { dispatch } = useCart();\n\n  return (\n    <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '5px' }}>\n      <h3>Available Products</h3>\n      {products.map(product => (\n        <div key={product.id} style={{ marginBottom: '10px' }}>\n          {product.name} - ${product.price} \n          <button onClick={() => dispatch({ type: ADD_ITEM, payload: product })} style={{ marginLeft: '10px' }}>\n            Add to Cart\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// 7. ShoppingCart Component\nfunction ShoppingCart() {\n  const { state, dispatch } = useCart();\n\n  const total = state.items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n\n  return (\n    <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '5px', marginTop: '20px' }}>\n      <h3>Shopping Cart</h3>\n      {state.items.length === 0 ? (\n        <p>Cart is empty.</p>\n      ) : (\n        <ul>\n          {state.items.map(item => (\n            <li key={item.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n              <span>{item.name} (x{item.quantity}) - ${item.price * item.quantity}</span>\n              <button onClick={() => dispatch({ type: REMOVE_ITEM, payload: { id: item.id } })} style={{ marginLeft: '10px' }}>\n                Remove\n              </button>\n            </li>\n          ))}\n        </ul>\n      )}\n      <p><strong>Total: ${total.toFixed(2)}</strong></p>\n      {state.items.length > 0 && (\n        <button onClick={() => dispatch({ type: CLEAR_CART })}>Clear Cart</button>\n      )}\n    </div>\n  );\n}\n\n// App component to render everything\nfunction App() {\n  return (\n    <CartProvider>\n      <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #ddd', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\n        <h1>My Online Store</h1>\n        <ProductList />\n        <ShoppingCart />\n      </div>\n    </CartProvider>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Add 'Laptop' once: Cart should show 'Laptop (x1)'.",
            "Add 'Laptop' again: Cart should show 'Laptop (x2)'.",
            "Add 'Mouse' then 'Keyboard': Cart should show 'Laptop (x2)', 'Mouse (x1)', 'Keyboard (x1)'.",
            "Remove 'Laptop' when quantity is 2: Cart should show 'Laptop (x1)'.",
            "Remove 'Laptop' when quantity is 1: 'Laptop' should be completely removed from cart.",
            "Remove 'Mouse' when quantity is 1: 'Mouse' should be completely removed from cart.",
            "Clear Cart: Cart should become empty.",
            "Check total calculation: Ensure total price accurately reflects item quantities and prices.",
            "Add multiple distinct items, then remove one. Check if others remain correct.",
            "Verify type safety: Ensure TypeScript definitions for state and actions are correct and prevent common errors."
          ],
          "hints": [
            "For `ADD_ITEM` in the reducer, check if the item already exists in `state.items`. If it does, increment its `quantity`; otherwise, add the new item with `quantity: 1`. Remember to create new arrays/objects for immutability.",
            "For `REMOVE_ITEM`, if the item's `quantity` is greater than 1, decrement it. If it's 1, filter it out of the array entirely.",
            "Ensure your reducer always returns a *new* state object/array, do not mutate the `state` directly.",
            "Use `useMemo` for the `value` prop in `CartContext.Provider` to prevent unnecessary re-renders of consuming components when only the `dispatch` function (which is stable) is present, or `state` remains reference-equal.",
            "Think about the `payload` for each action type: what data does the reducer need to perform that specific action?"
          ],
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "useContext",
            "State Management",
            "Global State",
            "E-commerce",
            "TypeScript",
            "Coding Challenge"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "react_use_reducer",
            "react_use_context",
            "javascript_array_methods",
            "javascript_immutability"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Reducer Pattern",
            "Context API",
            "Prop Drilling",
            "Data Flow",
            "Immutability"
          ]
        }
      ]
    }
  },
  {
    "id": "4902befb-a321-47ad-97f8-8baff6e7b398",
    "startLine": 5900,
    "endLine": 5999,
    "processedDate": "2025-06-17T09:49:00.532Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_context_reducer_hooks",
          "title": "State Management with React Context, useReducer, and Custom Hooks",
          "content": "This section explores a common and powerful pattern for managing state in React applications using a combination of the Context API, the `useReducer` hook, and custom hooks. This pattern is particularly useful for global or shared state that needs to be accessed by multiple components without prop drilling.\n\n## React Context API\nReact's Context API provides a way to pass data through the component tree without having to pass props down manually at every level. It's designed to share data that can be considered 'global' for a tree of React components, such as the current authenticated user, theme, or preferred language.\n\n-   **`React.createContext(defaultValue)`**: Creates a Context object. When React renders a component that subscribes to this Context object, it will read the current context value from the closest matching Provider above it in the tree.\n-   **`Context.Provider`**: A React component that allows consuming components to subscribe to context changes. It accepts a `value` prop to be passed to consuming components that are descendants of this Provider.\n-   **`useContext(ContextObject)`**: A React Hook that accepts a context object (the value returned from `React.createContext`) and returns the current context value for that context. It subscribes the component to context changes.\n\n## `useReducer` Hook\nThe `useReducer` hook is an alternative to `useState` for more complex state logic, especially when the state logic involves multiple sub-values or when the next state depends on the previous one. It's conceptually similar to Redux.\n\n-   **`const [state, dispatch] = useReducer(reducer, initialArg, init?)`**: Returns the current state and a `dispatch` function. `useReducer` is often preferred over `useState` when you have complex state transitions, or when the next state depends on the previous one.\n-   **`reducer(state, action)`**: A pure function that takes the current `state` and an `action` object, and returns the `newState`.\n-   **`action`**: An object, conventionally with a `type` property (a string) indicating the type of action performed, and an optional `payload` property containing any data needed for the state update.\n-   **`dispatch`**: A function returned by `useReducer` that you call to dispatch actions. Dispatching an action causes the reducer function to be executed with the current state and the given action, and the component re-renders with the new state.\n\n## Custom Hooks\nCustom hooks are JavaScript functions whose names start with 'use' and that can call other hooks. They allow you to extract reusable stateful logic from components. This promotes code reusability, testability, and better organization.\n\nWhen `Context`, `useReducer`, and custom hooks are combined, you can create a robust and scalable state management solution:\n1.  **Define Reducer**: Create a `reducer` function that defines how the state changes based on different actions.\n2.  **Create Context**: Create a `Context` object using `React.createContext`.\n3.  **Implement Provider**: Create a `Provider` component that wraps its children with `Context.Provider` and manages the state using `useReducer`. It passes the `state` and `dispatch` function down through the context `value`.\n4.  **Create Custom Hook**: Create a custom hook (e.g., `useTodo`) that uses `useContext` to consume the `state` and `dispatch` from the `Provider`, making it easy for any component to access the shared state and dispatch actions.\n\nThis pattern centralizes state logic, avoids prop drilling, and provides a clean API for components to interact with the global state.",
          "examples": [
            {
              "id": "example_todo_reducer",
              "title": "Todo Reducer Function",
              "code": "const ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst REMOVE_TODO = 'REMOVE_TODO';\n\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          id: Date.now(), // Simple unique ID\n          text: action.payload,\n          completed: false,\n        },\n      ];\n    case TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case REMOVE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n}",
              "explanation": "This `todoReducer` function defines the state transitions for our todo application. It takes the current `state` (an array of todo objects) and an `action` object. Based on the `action.type`, it returns a new state array. For `ADD_TODO`, it adds a new todo item. For `TOGGLE_TODO`, it flips the `completed` status of a specific todo. For `REMOVE_TODO`, it filters out a todo by its ID. It's crucial that the reducer always returns a new state object/array, not mutates the existing one.",
              "language": "javascript"
            },
            {
              "id": "example_todo_context_provider_hook",
              "title": "Todo Context, Provider, and Custom Hook",
              "code": "import React, { createContext, useReducer, useContext } from 'react';\n\n// 1. Define Context\nconst TodoContext = createContext(null);\n\n// 2. Define Reducer (as shown in previous example)\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst REMOVE_TODO = 'REMOVE_TODO';\n\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          id: Date.now(),\n          text: action.payload,\n          completed: false,\n        },\n      ];\n    case TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case REMOVE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n}\n\n// 3. Implement Provider Component\nexport function TodoProvider({ children }) {\n  const [todos, dispatch] = useReducer(todoReducer, []); // Initial state is an empty array\n\n  return (\n    <TodoContext.Provider value={{ todos, dispatch }}>\n      {children}\n    </TodoContext.Provider>\n  );\n}\n\n// 4. Create Custom Hook to consume context\nexport function useTodo() {\n  const context = useContext(TodoContext);\n  if (context === null) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  }\n  return context;\n}\n",
              "explanation": "This example showcases the full setup: `TodoContext` is created. `TodoProvider` uses `useReducer` to manage the `todos` state and `dispatch` function, then passes them down via `TodoContext.Provider`. The `useTodo` custom hook simplifies consuming this context from any child component, abstracting away the `useContext` call and adding a useful error check for incorrect usage.",
              "language": "javascript"
            },
            {
              "id": "example_todo_components",
              "title": "Components Using the Todo State",
              "code": "import React from 'react';\nimport { useTodo, ADD_TODO, TOGGLE_TODO, REMOVE_TODO } from './TodoContext'; // Assuming previous file is TodoContext.js\n\n// TodoItem component\nfunction TodoItem({ todo }) {\n  const { dispatch } = useTodo();\n  \n  return (\n    <li>\n      <span\n        style={{ textDecoration: todo.completed ? 'line-through' : 'none', cursor: 'pointer' }}\n        onClick={() => dispatch({ type: TOGGLE_TODO, payload: todo.id })}\n      >\n        {todo.text}\n      </span>\n      <button onClick={() => dispatch({ type: REMOVE_TODO, payload: todo.id })}>Remove</button>\n    </li>\n  );\n}\n\n// TodoList component\nfunction TodoList() {\n  const { todos } = useTodo();\n\n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem key={todo.id} todo={todo} />\n      ))}\n    </ul>\n  );\n}\n\n// AddTodo component\nfunction AddTodo() {\n  const { dispatch } = useTodo();\n  const [text, setText] = React.useState('');\n  \n  const handleSubmit = e => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: ADD_TODO, payload: text });\n      setText('');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n        placeholder=\"Add todo...\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\n// App component using the custom hook pattern\nfunction TodoApp() {\n  return (\n    <TodoProvider>\n      <h1>Todo App</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}\n",
              "explanation": "These components demonstrate how to consume the shared state and dispatch actions using the `useTodo` custom hook. `TodoList` simply displays todos, `AddTodo` dispatches `ADD_TODO` actions, and `TodoItem` dispatches `TOGGLE_TODO` and `REMOVE_TODO` actions. `TodoApp` wraps the entire application with `TodoProvider`, making the todo state available to all its descendants.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Hooks",
            "Context API",
            "useReducer",
            "State Management",
            "Custom Hooks",
            "Redux Pattern"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_hooks_useState_useEffect"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "large_scale_react_apps",
            "state_management_patterns"
          ]
        },
        {
          "id": "theory_react_portals",
          "title": "React Portals",
          "content": "React Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. This means you can render a component's content into an entirely different part of the HTML `document.body` or any other DOM element, while still maintaining its logical position and event bubbling behavior within the React component tree.\n\n## Syntax\n```javascript\nReactDOM.createPortal(child, container)\n```\n-   `child`: Any renderable React child (e.g., an element, string, fragment, or array of elements).\n-   `container`: A DOM element. This is the actual DOM node where the portal's children will be mounted.\n\n## When to Use Portals\nPortals are exceptionally useful in scenarios where the visual rendering of a component needs to 'break out' of its parent's DOM constraints, while still being managed by React's declarative rendering:\n\n-   **CSS Clipping Issues**: A parent component has `overflow: hidden`, `z-index`, or `position` styles that would visually 'clip' or obscure the child component if it were rendered directly within the parent's DOM subtree.\n-   **Breaking Stacking Context**: When a child needs to visually appear above all other content on the page, regardless of its parent's stacking context. This is common for overlays.\n-   **Maintaining React Component Tree Logic**: The child component maintains its position in the React component tree, meaning it receives context from its logical parents, and events (like clicks) will bubble up through the React tree to its logical ancestors, even though its DOM representation is elsewhere.\n\n## Common Use Cases\n-   **Modals and Dialogs**: To ensure they appear above all page content and are not constrained by parent `overflow` styles.\n-   **Tooltips and Popovers**: Which often need to position themselves relative to an element but escape its clipping boundaries.\n-   **Floating Menus**: Similar to popovers, where the menu should appear on top of other content.\n-   **Global Notification Systems**: Like toast messages, which need to be rendered at the top level of the DOM to be always visible.\n-   **Widgets that appear above other content**: Any component that requires a 'top-layer' rendering.\n\n## How it Works\nWhen you use `ReactDOM.createPortal`, React effectively moves the DOM nodes of the `child` to the specified `container` DOM node. However, React's internal component tree (the 'virtual DOM') still considers the `child` to be a descendant of its logical React parent. This is why event bubbling works as expected: an event triggered on a portal's child will bubble up through the DOM to the `container` element, then up through the React component tree (virtual DOM) to its logical React parent, and so on.",
          "examples": [
            {
              "id": "example_modal_with_portal_structure",
              "title": "HTML Structure for Portal Root",
              "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>React Portal Example</title>\n  <style>\n    /* Basic styling for modal overlay */\n    #modal-root {\n      position: fixed;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      background-color: rgba(0, 0, 0, 0.5);\n      z-index: 1000;\n    }\n    .modal-content {\n      background: white;\n      padding: 20px;\n      border-radius: 8px;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      z-index: 1001;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"root\"></div> <!-- Your main React app mounts here -->\n  <div id=\"modal-root\"></div> <!-- Portal target -->\n  <script src=\"index.js\"></script> <!-- Your compiled React app -->\n</body>\n</html>",
              "explanation": "To use a portal, you typically need a specific DOM element outside of your main React app's `root` element to serve as the portal's target. In this HTML structure, `modal-root` is designated for this purpose. It's often placed directly inside the `<body>` tag to ensure it's at the highest level of the DOM, making it suitable for modals, tooltips, etc., that need to appear above all other content. The CSS provides basic styling for a modal overlay.",
              "language": "html"
            },
            {
              "id": "example_modal_component_with_portal",
              "title": "Modal Component Using ReactDOM.createPortal",
              "code": "// Modal.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction Modal({ children }) {\n  const modalRoot = document.getElementById('modal-root');\n  if (!modalRoot) return null; // Or throw an error if modal-root is not found\n\n  // Create a portal that renders children into 'modal-root'\n  return ReactDOM.createPortal(\n    <div className=\"modal\">\n      <div className=\"modal-content\">\n        {children}\n      </div>\n    </div>,\n    modalRoot // The target DOM node\n  );\n}",
              "explanation": "This `Modal` component demonstrates the core usage of `ReactDOM.createPortal`. Inside the component, `document.getElementById('modal-root')` retrieves the target DOM node. The children passed to the `Modal` component (which typically include the modal's content) are then rendered into this `modal-root` element, rather than being rendered as direct children of `Modal`'s parent in the React tree. This ensures the modal visually breaks out of any CSS constraints of its parent.",
              "language": "javascript"
            },
            {
              "id": "example_app_using_modal_portal",
              "title": "App Component Using the Modal Portal",
              "code": "import React from 'react';\nimport Modal from './Modal'; // Assuming Modal.js is in the same directory\n\nfunction App() {\n  const [showModal, setShowModal] = React.useState(false);\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid grey', height: '200px', overflow: 'auto' }}>\n      <h1>My App Content</h1>\n      <p>This is some content within the main app container. \n         It has overflow: auto, which would clip a normal modal.</p>\n      <button onClick={() => setShowModal(true)}>Open Modal</button>\n\n      {showModal && (\n        <Modal>\n          <h2>Hello from Modal!</h2>\n          <p>I am rendered using a Portal, so I can escape parent CSS.</p>\n          <button onClick={() => setShowModal(false)}>Close Modal</button>\n        </Modal>\n      )}\n    </div>\n  );\n}",
              "explanation": "The `App` component demonstrates how to use the `Modal` component. Even though `Modal` is logically rendered inside `App` (and therefore `App`'s `div` with `overflow: auto`), the `Modal` content visually appears at the `modal-root` element in the HTML. This effectively 'breaks out' of the `App`'s CSS context, proving the utility of portals for overlays like modals. The `showModal` state controls the visibility of the modal.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "DOM",
            "Portals",
            "Modals",
            "Tooltips",
            "UI",
            "Advanced React"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "react_dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_ui_components",
            "global_ui_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_context_reducer_1",
          "topic": "React Context and useReducer",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of React Context API?",
          "answer": "To provide a way to pass data through the component tree without manually passing props at every level (prop drilling).",
          "analysisPoints": [
            "Focus on 'prop drilling' as the problem Context solves.",
            "Emphasize 'global' or 'shared' data."
          ],
          "keyConcepts": [
            "React Context",
            "Prop Drilling"
          ],
          "evaluationCriteria": [
            "Understanding of core Context purpose"
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_props"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_context_reducer_2",
          "topic": "React `useReducer` Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes when to use `useReducer` instead of `useState`?",
          "answer": "When state logic is complex, involves multiple sub-values, or the next state depends on the previous one.",
          "options": [
            "When managing a single boolean value.",
            "When state updates are always synchronous.",
            "When state logic is complex, involves multiple sub-values, or the next state depends on the previous one.",
            "Only when integrating with external libraries like Redux."
          ],
          "analysisPoints": [
            "Recognize `useReducer`'s suitability for complex state transitions.",
            "Understand that `useState` is simpler for basic state.",
            "Clarify that `useReducer` is a built-in Hook, not just for Redux integration."
          ],
          "keyConcepts": [
            "useReducer",
            "useState",
            "State Management"
          ],
          "evaluationCriteria": [
            "Differentiating state management hooks",
            "Understanding useReducer's benefits"
          ],
          "example": "```javascript\n// Simple state with useState\nconst [count, setCount] = useState(0);\n\n// Complex state with useReducer\nconst initialState = { count: 0, showText: true };\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment': return { ...state, count: state.count + 1 };\n    case 'toggleText': return { ...state, showText: !state.showText };\n    default: throw new Error();\n  }\n}\nconst [state, dispatch] = useReducer(reducer, initialState);\n```",
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "useState"
          ],
          "prerequisites": [
            "react_hooks_useState_useEffect"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_reducer_3",
          "topic": "Custom Hooks",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a custom hook in React, and what is its primary benefit?",
          "answer": "A custom hook is a JavaScript function whose name starts with 'use' and that can call other hooks. Its primary benefit is to extract reusable stateful logic from components, promoting code reusability, testability, and better organization.",
          "analysisPoints": [
            "The naming convention `useSomething`.",
            "Ability to call other hooks within them.",
            "Focus on 'reusable stateful logic'."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Reusability",
            "Stateful Logic"
          ],
          "evaluationCriteria": [
            "Definition of custom hook",
            "Understanding of its purpose"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Reusability"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_context_reducer_4",
          "topic": "Combining Context, useReducer, and Custom Hooks",
          "level": "medium",
          "type": "open",
          "question": "Explain the advantages of combining React Context API, `useReducer`, and custom hooks for state management in a large-scale application, as demonstrated by the TodoApp example.",
          "answer": "N/A",
          "analysisPoints": [
            "**Centralized State Logic**: `useReducer` centralizes state update logic within a single `reducer` function, making it predictable and easier to debug than scattered `useState` calls.",
            "**Avoids Prop Drilling**: Context API allows direct access to state and dispatch function to any deeply nested component, eliminating the need to pass props down through many levels of the component tree.",
            "**Reusability & Abstraction**: Custom hooks (e.g., `useTodo`) abstract away the `useContext` call and the specific context object, providing a clean, reusable API for components to interact with the global state without knowing the underlying Context implementation details.",
            "**Scalability**: This pattern scales well for complex global states, as new actions and state slices can be easily added to the reducer.",
            "**Performance (Selective Re-renders)**: While Context API can cause re-renders for all consuming components when the context value changes, strategic splitting of contexts or using `React.memo` can mitigate this. `useReducer` combined with Context allows `dispatch` to be stable, which helps prevent unnecessary re-renders of components that only receive `dispatch`.",
            "**Testability**: The `reducer` function is a pure function, making it easy to test independently. Custom hooks can also be tested in isolation."
          ],
          "keyConcepts": [
            "Context API",
            "useReducer",
            "Custom Hooks",
            "Prop Drilling",
            "Scalability",
            "Reusability",
            "State Management Patterns"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of each technology's role.",
            "Ability to articulate synergy and benefits of the combination.",
            "Awareness of potential performance considerations (though minor in this context)."
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "Architecture",
            "Design Patterns",
            "Hooks"
          ],
          "prerequisites": [
            "theory_react_context_reducer_hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_reducer_5",
          "topic": "Dispatching Actions",
          "level": "medium",
          "type": "code",
          "question": "Consider the `todoReducer` and the `AddTodo` component from the example. Write the `handleSubmit` function within `AddTodo` to correctly dispatch an `ADD_TODO` action with the input text.",
          "answer": "```javascript\n// Inside AddTodo component\nconst handleSubmit = e => {\n  e.preventDefault();\n  if (text.trim()) {\n    dispatch({ type: ADD_TODO, payload: text });\n    setText('');\n  }\n};\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `e.preventDefault()` for form submission.",
            "Understanding of `dispatch` function call.",
            "Correct `action` object structure (`type` and `payload`).",
            "Handling empty input (`text.trim()`).",
            "Clearing input field after submission (`setText('')`)."
          ],
          "keyConcepts": [
            "useReducer",
            "dispatch",
            "Action Object",
            "Event Handling",
            "Form Submission"
          ],
          "evaluationCriteria": [
            "Correct implementation of event handler.",
            "Accurate action dispatching.",
            "Handling basic input validation and cleanup."
          ],
          "example": "```javascript\n// Provided AddTodo component structure\nfunction AddTodo() {\n  const { dispatch } = useTodo();\n  const [text, setText] = React.useState('');\n  \n  const handleSubmit = e => {\n    // Your code here\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n        placeholder=\"Add todo...\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "Forms",
            "State Management",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_react_context_reducer_hooks",
            "react_forms"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_reducer_6",
          "topic": "State Immutability in Reducers",
          "level": "hard",
          "type": "mcq",
          "question": "Given the following reducer, what will be the state after dispatching `{ type: 'INCREMENT' }` if the current state is `[1, 2, 3]`?\n```javascript\nfunction faultyReducer(state, action) {\n  if (action.type === 'INCREMENT') {\n    state.push(state.length + 1);\n  }\n  return state;\n}\n```",
          "answer": "Mutation of the original state array.",
          "options": [
            "The new state will be `[1, 2, 3, 4]` and React will correctly re-render.",
            "The new state will be `[1, 2, 3, 4]` but React might not re-render or might behave unpredictably due to state mutation.",
            "The reducer will throw an error because `push` is not allowed.",
            "Mutation of the original state array."
          ],
          "analysisPoints": [
            "Identify that `push` mutates the original array.",
            "Explain that React relies on reference equality to detect state changes.",
            "Consequence of mutation: no re-render, unpredictable behavior, difficult debugging.",
            "Emphasize that reducers MUST return a new state object/array, not modify the existing one."
          ],
          "keyConcepts": [
            "Reducer",
            "State Immutability",
            "React Re-rendering",
            "Pure Functions"
          ],
          "evaluationCriteria": [
            "Understanding of immutability principle in React/Redux.",
            "Ability to spot state mutation.",
            "Knowledge of re-render mechanisms."
          ],
          "example": "```javascript\n// Correct way to add an item immutably\nfunction correctReducer(state, action) {\n  if (action.type === 'INCREMENT') {\n    return [...state, state.length + 1]; // Returns a new array\n  }\n  return state;\n}\n```",
          "tags": [
            "React",
            "useReducer",
            "Immutability",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "theory_react_context_reducer_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_portals_1",
          "topic": "React Portals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary function of `ReactDOM.createPortal`?",
          "answer": "To render children into a DOM node that exists outside the DOM hierarchy of the parent component.",
          "analysisPoints": [
            "Focus on 'outside the DOM hierarchy' but 'within the React component tree'."
          ],
          "keyConcepts": [
            "React Portals",
            "DOM Hierarchy",
            "React Component Tree"
          ],
          "evaluationCriteria": [
            "Basic definition of Portals"
          ],
          "example": "",
          "tags": [
            "React",
            "Portals",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_portals_2",
          "topic": "React Portals Use Cases",
          "level": "medium",
          "type": "open",
          "question": "List and briefly explain three common use cases where React Portals are particularly useful.",
          "answer": "N/A",
          "analysisPoints": [
            "**Modals/Dialogs**: They need to appear on top of all page content and break free from any `overflow: hidden` or `z-index` properties of parent components. Portals ensure they render directly under `body` or a dedicated `modal-root`.",
            "**Tooltips/Popovers**: While they are logically tied to an element, their visual placement often requires them to escape the parent's layout constraints to avoid clipping or being hidden by sibling elements' `z-index`.",
            "**Global Notification Systems (Toasts)**: Notifications need to appear consistently at a fixed position on the screen, unaffected by the scroll or layout of the main application content. Portals allow them to mount directly to the document body.",
            "**Floating Menus**: Similar to popovers, they might need to appear above other content and be free of parent styling."
          ],
          "keyConcepts": [
            "React Portals",
            "Modals",
            "Tooltips",
            "Z-index",
            "Overflow"
          ],
          "evaluationCriteria": [
            "Knowledge of practical applications of Portals.",
            "Ability to explain *why* portals are needed in these scenarios (e.g., CSS clipping, stacking context)."
          ],
          "example": "",
          "tags": [
            "React",
            "Portals",
            "UI/UX",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_react_portals"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_portals_3",
          "topic": "Event Bubbling with Portals",
          "level": "medium",
          "type": "mcq",
          "question": "If an event (e.g., a click) occurs on a child element rendered within a React Portal, how does event bubbling behave?",
          "answer": "The event bubbles up through the actual DOM tree to the portal's container, then continues bubbling up through the logical React component tree to the portal's logical parent.",
          "options": [
            "The event only bubbles up through the actual DOM tree until it reaches the portal's container, and stops there.",
            "The event only bubbles up through the logical React component tree, completely ignoring the physical DOM structure.",
            "The event bubbles up through the actual DOM tree to the portal's container, then continues bubbling up through the logical React component tree to the portal's logical parent.",
            "Portals prevent event bubbling entirely for their children."
          ],
          "analysisPoints": [
            "Crucial understanding that React maintains its own 'virtual' event system on top of the browser's native one.",
            "Portals only change the *physical* DOM location, not the *logical* React component parent-child relationship for event propagation.",
            "Events first bubble up the physical DOM to the portal's target, then bridge back into the React component tree for further bubbling."
          ],
          "keyConcepts": [
            "React Portals",
            "Event Bubbling",
            "DOM Events",
            "Virtual DOM"
          ],
          "evaluationCriteria": [
            "Understanding of advanced React concepts like event delegation and virtual DOM interaction with Portals."
          ],
          "example": "```javascript\nfunction ParentComponent() {\n  const handleClick = () => console.log('Parent clicked!');\n  return (\n    <div onClick={handleClick}>\n      <MyModalButton /> {/* MyModalButton renders button in a portal */}\n    </div>\n  );\n}\n\nfunction MyModalButton() {\n  return ReactDOM.createPortal(\n    <button onClick={() => console.log('Button clicked!')}>Click Me</button>,\n    document.getElementById('modal-root')\n  );\n}\n// When 'Click Me' is clicked, both 'Button clicked!' and 'Parent clicked!' will log.\n```",
          "tags": [
            "React",
            "Portals",
            "Events",
            "Advanced"
          ],
          "prerequisites": [
            "theory_react_portals",
            "react_event_handling"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_portals_4",
          "topic": "Portal Implementation",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple `Tooltip` component that uses `ReactDOM.createPortal`. The tooltip should display `children` when hovered over its `targetElement` prop. The `targetElement` should be a ref to the DOM element to which the tooltip is conceptually attached. Ensure the tooltip is hidden when not hovered.\n\nAssume there's a `<div id=\"tooltip-root\"></div>` in the `<body>`.",
          "answer": "```javascript\nimport React, { useState, useRef, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst Tooltip = ({ children, targetElement }) => {\n  const [isVisible, setIsVisible] = useState(false);\n  const tooltipRoot = useRef(null);\n\n  useEffect(() => {\n    tooltipRoot.current = document.getElementById('tooltip-root');\n  }, []);\n\n  useEffect(() => {\n    const target = targetElement?.current;\n    if (!target) return;\n\n    const showTooltip = () => setIsVisible(true);\n    const hideTooltip = () => setIsVisible(false);\n\n    target.addEventListener('mouseenter', showTooltip);\n    target.addEventListener('mouseleave', hideTooltip);\n\n    return () => {\n      target.removeEventListener('mouseenter', showTooltip);\n      target.removeEventListener('mouseleave', hideTooltip);\n    };\n  }, [targetElement]);\n\n  if (!tooltipRoot.current || !isVisible) {\n    return null;\n  }\n\n  // Basic positioning - in a real app, this would be more complex\n  const targetRect = targetElement.current.getBoundingClientRect();\n  const style = {\n    position: 'absolute',\n    top: `${targetRect.bottom + window.scrollY + 5}px`,\n    left: `${targetRect.left + window.scrollX}px`,\n    backgroundColor: 'black',\n    color: 'white',\n    padding: '5px 10px',\n    borderRadius: '4px',\n    zIndex: 9999,\n  };\n\n  return ReactDOM.createPortal(\n    <div style={style}>{children}</div>,\n    tooltipRoot.current\n  );\n};\n\n// Usage Example:\n// function App() {\n//   const buttonRef = useRef(null);\n//   return (\n//     <div>\n//       <button ref={buttonRef}>Hover Me</button>\n//       <Tooltip targetElement={buttonRef}>This is a helpful tooltip!</Tooltip>\n//     </div>\n//   );\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `ReactDOM.createPortal`.",
            "Manages visibility state (`isVisible`).",
            "Uses `useEffect` to attach/detach event listeners to the `targetElement` (passed as a ref).",
            "Handles the `tooltip-root` DOM node lookup (e.g., in `useEffect` or `useRef`).",
            "Basic positioning logic (acknowledging that robust positioning is complex).",
            "Cleans up event listeners on unmount."
          ],
          "keyConcepts": [
            "React Portals",
            "Refs",
            "useEffect",
            "Event Listeners",
            "DOM Manipulation",
            "Tooltip"
          ],
          "evaluationCriteria": [
            "Ability to implement a practical use case for Portals.",
            "Correct use of hooks for DOM interaction and state management.",
            "Understanding of event handling and cleanup."
          ],
          "example": "```javascript\n// Starting template\nimport React, { useState, useRef, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst Tooltip = ({ children, targetElement }) => {\n  const [isVisible, setIsVisible] = useState(false);\n  // You might need a ref for the portal target node as well\n  const portalNode = useRef(null);\n\n  useEffect(() => {\n    // Initialize portalNode.current to document.getElementById('tooltip-root')\n    // and add/remove event listeners on targetElement\n  }, [targetElement]);\n\n  if (!portalNode.current || !isVisible) {\n    return null;\n  }\n\n  // Implement basic positioning logic\n  const style = {}; // Calculate position based on targetElement's bounding rect\n\n  return ReactDOM.createPortal(\n    <div style={style}>{children}</div>,\n    portalNode.current\n  );\n};\n\n// How to use it in App.js:\n// function App() {\n//   const myButtonRef = useRef(null);\n//   return (\n//     <div>\n//       <button ref={myButtonRef}>Hover Me</button>\n//       <Tooltip targetElement={myButtonRef}>I'm a portal tooltip!</Tooltip>\n//     </div>\n//   );\n// }\n```",
          "tags": [
            "React",
            "Portals",
            "Hooks",
            "Coding Challenge",
            "UI Components",
            "Hard"
          ],
          "prerequisites": [
            "theory_react_portals",
            "react_refs",
            "react_hooks_useEffect"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_todo_app_extend",
          "title": "Extend Todo App with Delete and Edit Functionality",
          "description": "\nExtend the existing Todo application to include delete and edit functionalities for individual todo items. This task will reinforce your understanding of `useReducer`, Context API, and how to dispatch actions for complex state updates.\n\n**Requirements:**\n1.  **Delete Todo**: Add a 'Delete' button next to each todo item. Clicking it should remove the todo from the list.\n2.  **Edit Todo**: Allow users to edit the text of an existing todo. This could involve:\n    *   Displaying an 'Edit' button or making the todo text clickable.\n    *   When editing, the text should turn into an input field pre-filled with the current todo text.\n    *   The user should be able to save changes (e.g., by pressing Enter or clicking a 'Save' button).\n    *   The edit action should update the `text` property of the corresponding todo item in the state.\n3.  **Update Reducer**: Modify the `todoReducer` to handle new actions for deleting and editing todos.\n4.  **Update Components**: Modify `TodoItem` to include the delete button and handle the edit state (displaying text vs. input field).\n5.  **Maintain Immutability**: Ensure all state updates in the reducer are immutable.\n",
          "difficulty": "medium",
          "startingCode": "import React, { createContext, useReducer, useContext, useState } from 'react';\n\n// Action Types\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\n// Add new action types here for DELETE and EDIT\nconst REMOVE_TODO = 'REMOVE_TODO'; // Already present, rename to DELETE_TODO for clarity?\n\n// Reducer\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          id: Date.now(),\n          text: action.payload,\n          completed: false,\n        },\n      ];\n    case TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case REMOVE_TODO: // Use this for delete, or create DELETE_TODO\n      return state.filter(todo => todo.id !== action.payload);\n    // Add cases for DELETE and EDIT actions here\n    default:\n      return state;\n  }\n}\n\n// Context & Provider\nconst TodoContext = createContext(null);\n\nexport function TodoProvider({ children }) {\n  const [todos, dispatch] = useReducer(todoReducer, []);\n  return (\n    <TodoContext.Provider value={{ todos, dispatch }}>\n      {children}\n    </TodoContext.Provider>\n  );\n}\n\n// Custom Hook\nexport function useTodo() {\n  const context = useContext(TodoContext);\n  if (context === null) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  }\n  return context;\n}\n\n// TodoItem Component (needs modification)\nfunction TodoItem({ todo }) {\n  const { dispatch } = useTodo();\n  // Add state for editing mode and current edit text\n\n  return (\n    <li>\n      <span\n        style={{ textDecoration: todo.completed ? 'line-through' : 'none', cursor: 'pointer' }}\n        onClick={() => dispatch({ type: TOGGLE_TODO, payload: todo.id })}\n      >\n        {todo.text}\n      </span>\n      {/* Add Delete and Edit buttons/logic here */}\n    </li>\n  );\n}\n\n// TodoList Component (should be fine as is)\nfunction TodoList() {\n  const { todos } = useTodo();\n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem key={todo.id} todo={todo} />\n      ))}\n    </ul>\n  );\n}\n\n// AddTodo Component (should be fine as is)\nfunction AddTodo() {\n  const { dispatch } = useTodo();\n  const [text, setText] = useState('');\n  \n  const handleSubmit = e => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: ADD_TODO, payload: text });\n      setText('');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n        placeholder=\"Add todo...\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\n// App Component\nexport default function TodoApp() {\n  return (\n    <TodoProvider>\n      <h1>Todo App</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}",
          "solutionCode": "import React, { createContext, useReducer, useContext, useState, useRef, useEffect } from 'react';\n\n// Action Types\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst DELETE_TODO = 'DELETE_TODO'; // Renamed from REMOVE_TODO for clarity\nconst EDIT_TODO = 'EDIT_TODO';\n\n// Reducer\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          id: Date.now(),\n          text: action.payload,\n          completed: false,\n        },\n      ];\n    case TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case DELETE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    case EDIT_TODO:\n      return state.map(todo =>\n        todo.id === action.payload.id ? { ...todo, text: action.payload.newText } : todo\n      );\n    default:\n      return state;\n  }\n}\n\n// Context & Provider\nconst TodoContext = createContext(null);\n\nexport function TodoProvider({ children }) {\n  const [todos, dispatch] = useReducer(todoReducer, []);\n  return (\n    <TodoContext.Provider value={{ todos, dispatch }}>\n      {children}\n    </TodoContext.Provider>\n  );\n}\n\n// Custom Hook\nexport function useTodo() {\n  const context = useContext(TodoContext);\n  if (context === null) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  }\n  return context;\n}\n\n// TodoItem Component (modified)\nfunction TodoItem({ todo }) {\n  const { dispatch } = useTodo();\n  const [isEditing, setIsEditing] = useState(false);\n  const [editText, setEditText] = useState(todo.text);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    if (isEditing) {\n      inputRef.current?.focus();\n    }\n  }, [isEditing]);\n\n  const handleSaveEdit = () => {\n    if (editText.trim() && editText !== todo.text) {\n      dispatch({ type: EDIT_TODO, payload: { id: todo.id, newText: editText.trim() } });\n    }\n    setIsEditing(false);\n  };\n\n  const handleEditKeyDown = (e) => {\n    if (e.key === 'Enter') {\n      handleSaveEdit();\n    } else if (e.key === 'Escape') {\n      setEditText(todo.text); // Revert changes\n      setIsEditing(false);\n    }\n  };\n\n  return (\n    <li>\n      {isEditing ? (\n        <input\n          ref={inputRef}\n          type=\"text\"\n          value={editText}\n          onChange={e => setEditText(e.target.value)}\n          onBlur={handleSaveEdit} // Save on blur\n          onKeyDown={handleEditKeyDown}\n        />\n      ) : (\n        <span\n          style={{ textDecoration: todo.completed ? 'line-through' : 'none', cursor: 'pointer' }}\n          onClick={() => dispatch({ type: TOGGLE_TODO, payload: todo.id })}\n        >\n          {todo.text}\n        </span>\n      )}\n      \n      {!isEditing && <button onClick={() => setIsEditing(true)}>Edit</button>}\n      <button onClick={() => dispatch({ type: DELETE_TODO, payload: todo.id })}>Delete</button>\n    </li>\n  );\n}\n\n// TodoList Component (fine as is)\nfunction TodoList() {\n  const { todos } = useTodo();\n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem key={todo.id} todo={todo} />\n      ))}\n    </ul>\n  );\n}\n\n// AddTodo Component (fine as is)\nfunction AddTodo() {\n  const { dispatch } = useTodo();\n  const [text, setText] = useState('');\n  \n  const handleSubmit = e => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: ADD_TODO, payload: text });\n      setText('');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n        placeholder=\"Add todo...\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\n// App Component\nexport default function TodoApp() {\n  return (\n    <TodoProvider>\n      <h1>Todo App</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}",
          "testCases": [
            "**Delete Functionality**: Add 3 todos, click delete on the middle one. Verify only 2 remain and correct ones.",
            "**Edit Functionality**: Add a todo 'Buy groceries'. Click edit, change to 'Buy milk & eggs', save. Verify text updates.",
            "**Edit Cancel**: Add a todo. Click edit, type something, then press 'Escape'. Verify text reverts to original and edit mode exits.",
            "**Empty Edit Save**: Add a todo 'Test'. Click edit, clear the input, then save. Verify the todo is not updated or potentially deleted (depending on how you handle it, usually not updated).",
            "**Toggle & Delete**: Toggle a todo as complete, then delete it. Verify no errors occur.",
            "**Multiple Todos**: Add 10+ todos and perform various operations (add, toggle, edit, delete) to ensure stability."
          ],
          "hints": [
            "Define new action types (e.g., `DELETE_TODO`, `EDIT_TODO`) and add corresponding cases to your `todoReducer`.",
            "For editing, the `TodoItem` component will need its own local state (e.g., `isEditing`, `editText`) to control the input field visibility and value.",
            "Remember to use immutable updates in your reducer when handling `EDIT_TODO`.",
            "Consider using an `onBlur` event on the edit input field to save changes when the input loses focus, in addition to an 'Enter' key press.",
            "You might need a `useRef` to focus the input field when entering edit mode."
          ],
          "tags": [
            "React",
            "State Management",
            "useReducer",
            "Context API",
            "Custom Hooks",
            "CRUD",
            "Forms"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_react_context_reducer_hooks"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "controlled_components",
            "event_handling",
            "immutable_updates",
            "local_component_state"
          ]
        },
        {
          "id": "task_reusable_portal_modal",
          "title": "Build a Reusable Modal Component with React Portals",
          "description": "\nCreate a robust and reusable `Modal` component using React Portals. This modal should be flexible enough to display any content and include common modal features like an overlay, a close button, and optional closing on outside clicks.\n\n**Requirements:**\n1.  **Portal Integration**: The modal content must be rendered using `ReactDOM.createPortal` into a dedicated DOM node (e.g., `<div id=\"modal-root\"></div>` which you assume exists in `index.html`).\n2.  **Open/Close Control**: The modal should accept a `isOpen` prop (boolean) to control its visibility and an `onClose` prop (function) to notify the parent when it should close.\n3.  **Overlay**: Implement a semi-transparent overlay that covers the rest of the page when the modal is open.\n4.  **Close Button**: Include a visible close button (e.g., an 'X' icon or a 'Close' button) inside the modal content.\n5.  **Click Outside Close**: The modal should close if the user clicks on the overlay (outside the modal content itself).\n6.  **Escape Key Close**: The modal should close when the 'Escape' key is pressed.\n7.  **Focus Management (Optional, but good for accessibility)**: When the modal opens, focus should be trapped within the modal, and restored to the element that triggered the modal when it closes. (This is a hard bonus point).\n",
          "difficulty": "hard",
          "startingCode": "import React, { useEffect, useRef } from 'react';\nimport ReactDOM from 'react-dom';\n\n// Assume 'modal-root' exists in your index.html:\n// <div id=\"root\"></div>\n// <div id=\"modal-root\"></div>\n\nfunction Modal({ isOpen, onClose, children }) {\n  const modalRef = useRef(null); // Ref for the modal content div\n\n  useEffect(() => {\n    if (isOpen) {\n      // Add event listeners for escape key and outside clicks\n      // Focus management (optional)\n    } else {\n      // Clean up event listeners\n    }\n    return () => {\n      // Cleanup on unmount\n    };\n  }, [isOpen, onClose]);\n\n  if (!isOpen) {\n    return null;\n  }\n\n  const portalRoot = document.getElementById('modal-root');\n  if (!portalRoot) return null; // Handle case where root doesn't exist\n\n  // Basic structure for modal and overlay\n  const modalContent = (\n    <div className=\"modal-overlay\" onClick={/* handle click outside */}>\n      <div className=\"modal-content\" ref={modalRef} onClick={e => e.stopPropagation()}> {/* Prevent click inside from closing */}\n        {children}\n        <button className=\"modal-close-button\" onClick={onClose}>&times;</button>\n      </div>\n    </div>\n  );\n\n  return ReactDOM.createPortal(modalContent, portalRoot);\n}\n\n// Basic CSS (add this to your index.css or a style tag)\n/*\n.modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.6);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n}\n\n.modal-content {\n  background: white;\n  padding: 20px;\n  border-radius: 8px;\n  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n  position: relative; // For close button positioning\n  min-width: 300px;\n  max-width: 80%;\n  max-height: 80%;\n  overflow-y: auto;\n}\n\n.modal-close-button {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  background: none;\n  border: none;\n  font-size: 1.5em;\n  cursor: pointer;\n}\n*/\n\n// Example Usage in App.js:\n// import React, { useState } from 'react';\n// import Modal from './Modal';\n\n// function App() {\n//   const [isModalOpen, setIsModalOpen] = useState(false);\n\n//   return (\n//     <div>\n//       <h1>My App</h1>\n//       <button onClick={() => setIsModalOpen(true)}>Open Modal</button>\n//       <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>\n//         <h2>This is a Portal Modal</h2>\n//         <p>You can put any content here.</p>\n//       </Modal>\n//     </div>\n//   );\n// }\n",
          "solutionCode": "import React, { useEffect, useRef, useCallback } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction Modal({ isOpen, onClose, children }) {\n  const modalRef = useRef(null); // Ref for the modal content div itself\n  const previouslyActiveElement = useRef(null); // For focus management\n\n  // Store the portal root element in a ref to avoid re-querying DOM\n  const portalRoot = useRef(null);\n  useEffect(() => {\n    portalRoot.current = document.getElementById('modal-root');\n  }, []);\n\n  // Function to handle escape key press\n  const handleEscapeKey = useCallback((event) => {\n    if (event.key === 'Escape' && isOpen) {\n      onClose();\n    }\n  }, [isOpen, onClose]);\n\n  // Function to handle click outside modal content\n  const handleOverlayClick = useCallback((event) => {\n    if (modalRef.current && !modalRef.current.contains(event.target)) {\n      onClose();\n    }\n  }, [onClose]);\n\n  useEffect(() => {\n    if (isOpen) {\n      // Save reference to the element that was focused before modal opened\n      previouslyActiveElement.current = document.activeElement;\n      document.addEventListener('keydown', handleEscapeKey);\n      // Focus the modal content for accessibility\n      modalRef.current?.focus(); \n    } else {\n      document.removeEventListener('keydown', handleEscapeKey);\n      // Restore focus to the previously active element when modal closes\n      if (previouslyActiveElement.current) {\n        previouslyActiveElement.current.focus();\n      }\n    }\n    // Cleanup event listeners on component unmount or when isOpen changes\n    return () => {\n      document.removeEventListener('keydown', handleEscapeKey);\n    };\n  }, [isOpen, handleEscapeKey]);\n\n  if (!isOpen || !portalRoot.current) {\n    return null;\n  }\n\n  return ReactDOM.createPortal(\n    <div className=\"modal-overlay\" onClick={handleOverlayClick} tabIndex=\"-1\">\n      <div\n        className=\"modal-content\"\n        ref={modalRef}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabIndex=\"0\" // Make content focusable for initial focus\n        onClick={e => e.stopPropagation()} // Prevent clicks inside content from closing modal\n      >\n        {children}\n        <button className=\"modal-close-button\" onClick={onClose} aria-label=\"Close modal\">&times;</button>\n      </div>\n    </div>,\n    portalRoot.current\n  );\n}\n\n// Basic CSS (add this to your index.css or a style tag)\n/*\n.modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.6);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n}\n\n.modal-content {\n  background: white;\n  padding: 20px;\n  border-radius: 8px;\n  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n  position: relative; /* For close button positioning */\n  min-width: 300px;\n  max-width: 80%;\n  max-height: 80%;\n  overflow-y: auto;\n  outline: none; /* Remove focus outline */\n}\n\n.modal-close-button {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  background: none;\n  border: none;\n  font-size: 1.5em;\n  cursor: pointer;\n  padding: 5px;\n}\n*/\n\n// Example Usage in App.js:\n// import React, { useState } from 'react';\n// import Modal from './Modal';\n\n// function App() {\n//   const [isModalOpen, setIsModalOpen] = useState(false);\n\n//   return (\n//     <div>\n//       <h1>My App</h1>\n//       <button onClick={() => setIsModalOpen(true)}>Open Modal</button>\n//       <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>\n//         <h2>This is a Portal Modal</h2>\n//         <p>You can put any content here.</p>\n//       </Modal>\n//     </div>\n//   );\n// }\n",
          "testCases": [
            "**Basic Open/Close**: Click a button to open the modal, then click its internal close button. Verify it opens and closes correctly.",
            "**Click Outside**: Open the modal, click on the semi-transparent overlay. Verify the modal closes.",
            "**Escape Key**: Open the modal, press the 'Escape' key. Verify the modal closes.",
            "**No Modal Open**: Verify that no modal elements are present in the DOM when `isOpen` is false.",
            "**Content Rendering**: Pass various types of children (text, other components) to the Modal and ensure they render correctly within the modal content area.",
            "**Focus Management (if implemented)**: After opening and closing the modal, verify that focus returns to the button that triggered it. Test tabbing through elements inside the modal."
          ],
          "hints": [
            "Use `useEffect` to manage event listeners for the 'Escape' key and clicks outside the modal. Remember to clean up these listeners when the component unmounts or `isOpen` changes.",
            "For clicking outside the modal, attach the `onClick` listener to the overlay, and then use `event.stopPropagation()` on the modal's inner content div to prevent clicks within the modal from bubbling up and closing it.",
            "Store the `modal-root` DOM node in a `useRef` to avoid repeatedly querying the DOM.",
            "For focus management, you'll need to capture `document.activeElement` when the modal opens and restore focus to it when the modal closes. You might also need to make the modal content focusable (e.g., `tabIndex=\"0\"`).",
            "Utilize `useCallback` for event handlers that are passed to `useEffect` dependencies to prevent unnecessary re-creations and re-attachments of listeners."
          ],
          "tags": [
            "React",
            "Portals",
            "UI Components",
            "Modals",
            "Accessibility",
            "Hooks",
            "Event Handling"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_react_portals",
            "react_hooks_useEffect",
            "react_refs",
            "event_handling"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "controlled_components",
            "event_delegation",
            "css_positioning",
            "a11y"
          ]
        }
      ]
    }
  },
  {
    "id": "ccff1b1a-8105-4c5d-814d-851301c7bcee",
    "startLine": 6000,
    "endLine": 6099,
    "processedDate": "2025-06-17T09:50:22.862Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_portals",
          "title": "React Portals",
          "content": "React Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. This allows components to break out of their parent's DOM tree, which is particularly useful for dealing with modals, tooltips, dialogs, and other overlays that need to be positioned outside the normal document flow (e.g., to avoid `overflow: hidden` issues or to manage `z-index`).\n\n### How to use React Portals\nTo create a portal, you use `ReactDOM.createPortal(child, container)`. \n- `child`: This is any renderable React child, such as an element, string, or fragment.\n- `container`: This is a DOM element. The `child` will be mounted into this DOM element.\n\nTypically, the `container` DOM element for portals is a dedicated `div` element at the root level of your `public/index.html` (e.g., `<div id=\"modal-root\"></div>`), separate from your main React application's root element.\n\n### Important Portal Characteristics\n1.  **Event Bubbling:** Events fired inside a portal will still propagate up the React component tree, even if the portal's DOM elements are not direct ancestors in the DOM tree. This means that an event handler attached to a parent component (e.g., `App`) will still catch events from a child rendered via a portal, maintaining React's synthetic event system behavior.\n2.  **DOM Structure vs. React Component Hierarchy:** Portals only alter the physical DOM structure. They do not change the logical React component hierarchy. Components rendered within a portal still behave like normal React children within the context of the React tree (e.g., context consumption, state management).\n3.  **Context Providers:** Context providers defined in ancestor components *above* the portal will still be accessible to components rendered inside the portal. This is because, as mentioned, portals maintain the React component hierarchy for context flow, despite DOM placement.",
          "examples": [
            {
              "id": "example_react_portals_1",
              "title": "Basic Modal Implementation with Portal",
              "code": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// 1. Create a dedicated DOM node in public/index.html:\n// <div id=\"modal-root\"></div>\n\n// 2. Define a reusable Modal component using createPortal\nfunction Modal({ children, onClose }) {\n  const modalRoot = document.getElementById('modal-root');\n  if (!modalRoot) {\n    // In a real application, you might throw an error or handle this more gracefully\n    console.error(\"The DOM element with ID 'modal-root' was not found.\");\n    return null;\n  }\n  return ReactDOM.createPortal(\n    <div className=\"modal-backdrop\" onClick={onClose}>\n      <div className=\"modal-content\" onClick={e => e.stopPropagation()}>\n        {children}\n        <button onClick={onClose}>Close Modal</button>\n      </div>\n    </div>,\n    modalRoot\n  );\n}\n\n// 3. Use the Modal component in your App\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <div className=\"app-container\" style={{ border: '2px solid blue', padding: '20px' }}>\n      <h1>My Application Content</h1>\n      <p>This content is part of the regular DOM hierarchy.</p>\n      <button onClick={() => setShowModal(true)}>Show Modal</button>\n      \n      {showModal && (\n        <Modal onClose={() => setShowModal(false)}>\n          <h2>Modal Title</h2>\n          <p>This modal content is rendered into '#modal-root', outside the 'app-container' DOM node.</p>\n        </Modal>\n      )}\n      <p>More app content below the button.</p>\n    </div>\n  );\n}\n\n// Typical root rendering\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This example demonstrates how to create and use a React Portal for a modal. The `Modal` component uses `ReactDOM.createPortal` to render its children (the modal content) into a specific DOM node (`modal-root`) that is outside the main application's root. This helps in managing z-index and overflow issues, ensuring the modal always appears on top. Despite being rendered elsewhere in the DOM, the `onClick` event on the 'Close Modal' button still correctly triggers the `setShowModal(false)` function in the `App` component due to event bubbling through the React component hierarchy.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_portal_1",
            "question_react_portal_2",
            "question_react_portal_3",
            "question_react_portal_4"
          ],
          "relatedTasks": [
            "task_implement_modal_with_portal"
          ],
          "tags": [
            "React",
            "Portals",
            "DOM",
            "Event Bubbling",
            "Context",
            "UI/UX",
            "Advanced React"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_state",
            "react_props",
            "dom_manipulation_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_ui_patterns",
            "component_library_development"
          ]
        },
        {
          "id": "theory_error_boundaries",
          "title": "React Error Boundaries",
          "content": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application. They are designed to encapsulate errors, preventing a single component's crash from bringing down the whole UI. This is crucial for building robust and user-friendly applications.\n\n### How to Implement an Error Boundary\nA class component becomes an error boundary if it defines either (or both) of the following lifecycle methods:\n\n1.  `static getDerivedStateFromError(error)`:\n    *   This static method is invoked after an error has been thrown by a descendant component.\n    *   It receives the `error` as an argument.\n    *   Its purpose is to update state so that the next render shows a fallback UI. It should return an object to update state, or `null` to not update state.\n\n2.  `componentDidCatch(error, info)`:\n    *   This method is invoked after an error has been thrown by a descendant component.\n    *   It receives two arguments: `error` (the error that was thrown) and `info` (an object with a `componentStack` key containing component stack trace information).\n    *   Its purpose is to perform side effects, such as logging the error to an error reporting service.\n\n### What Error Boundaries Catch\nError boundaries catch errors that occur during:\n*   Rendering\n*   In lifecycle methods\n*   In constructors of the whole tree below them.\n\n### What Error Boundaries Do NOT Catch\nError boundaries do *not* catch errors for:\n*   **Event handlers:** React does not catch errors inside event handlers because event handlers don't happen during rendering. If you need to catch errors in event handlers, use a regular JavaScript `try/catch` block inside the event handler itself.\n*   **Asynchronous code:** Errors inside `setTimeout`, `requestAnimationFrame`, or other asynchronous callbacks (like `fetch` requests) are not caught by error boundaries.\n*   **Server-side rendering:** Errors during server-side rendering are handled differently.\n*   **Errors thrown in the error boundary itself:** An error boundary can only catch errors in its children. If the error boundary's `render` method or `componentDidCatch` method throws an error, it will not catch it.\n\n### Usage\nOnce defined, an error boundary is used by wrapping it around the components you want to protect. A single error boundary can protect multiple components or even the entire application.",
          "examples": [
            {
              "id": "example_error_boundaries_1",
              "title": "Basic Error Boundary Component",
              "code": "import React from 'react';\n\n// A service to log errors (e.g., Sentry, Bugsnag)\nfunction logErrorToMyService(error, info) {\n  console.error(\"Error caught by ErrorBoundary:\", error, info);\n  // In a real app, you would send this to an external logging service\n}\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render shows the fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // You can also log the error to an error reporting service\n    this.setState({\n      error: error,\n      errorInfo: info\n    });\n    logErrorToMyService(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return (\n        <div style={{ border: '1px solid red', padding: '10px', margin: '10px' }}>\n          <h2>Something went wrong.</h2>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo && this.state.errorInfo.componentStack}\n          </details>\n          <p>Please refresh the page or try again later.</p>\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\n// Example Component that might throw an error\nfunction BuggyCounter() {\n  const [counter, setCounter] = React.useState(0);\n\n  const handleClick = () => {\n    if (counter === 5) {\n      // This error will be caught by the ErrorBoundary during render\n      throw new Error('I crashed at 5!');\n    }\n    setCounter(c => c + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {counter}</p>\n      <button onClick={handleClick}>Increment</button>\n    </div>\n  );\n}\n\n// Usage in the App component\nfunction App() {\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <p>Click the counter until it crashes. The error boundary should catch it.</p>\n      \n      {/* Wrapping the BuggyCounter with the ErrorBoundary */}\n      <ErrorBoundary>\n        <BuggyCounter />\n      </ErrorBoundary>\n      \n      <p>This part of the app remains unaffected.</p>\n      <BuggyCounter /> {/* This one is not wrapped, will crash the whole app */}\n    </div>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This example shows a full implementation of an Error Boundary. The `ErrorBoundary` class component uses `static getDerivedStateFromError` to update its internal state (`hasError`), which triggers a re-render to display the fallback UI. `componentDidCatch` is used to log the error information to a hypothetical service. The `BuggyCounter` component is designed to throw an error when its internal `counter` reaches 5 during its render cycle. When `BuggyCounter` is wrapped by `ErrorBoundary`, the error is caught, and only the `BuggyCounter` part of the UI is replaced with the fallback, while the rest of the application remains functional. The second `BuggyCounter` is left unwrapped to illustrate that an unhandled error will crash the entire React component tree.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_error_boundary_1",
            "question_error_boundary_2",
            "question_error_boundary_3",
            "question_error_boundary_4",
            "question_error_boundary_5",
            "question_error_boundary_6"
          ],
          "relatedTasks": [
            "task_implement_error_boundary"
          ],
          "tags": [
            "React",
            "Error Handling",
            "Error Boundaries",
            "Lifecycle Methods",
            "Reliability",
            "Debugging"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_state",
            "react_lifecycle"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust_application_development",
            "production_ready_react_apps"
          ]
        },
        {
          "id": "theory_react_strictmode",
          "title": "React.StrictMode",
          "content": "React.StrictMode is a developer tool designed to highlight potential problems in a React application. It activates additional checks and warnings for its descendants during development, but it does not render any visible UI itself and has no effect on the production build. Its primary goal is to help developers identify and fix common issues, deprecated features, and potential side effects before they become problems in production.\n\n### Key Benefits and Checks Activated by StrictMode:\n1.  **Identifying components with unsafe lifecycle methods**: It warns about components using legacy or unsafe lifecycle methods (e.g., `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`) that are considered problematic for async rendering and are slated for removal or deprecation in future React versions.\n2.  **Warning about legacy string ref API usage**: It helps update code to use the newer and recommended callback refs or `React.createRef()` APIs instead of string refs (e.g., `<input ref=\"myInput\" />`).\n3.  **Detecting unexpected side effects**: It intentionally double-invokes functions like component constructors, `render` methods, and `setState` updaters in development mode. This helps to highlight potential side effects that might occur during unexpected multiple renders or when React's upcoming concurrent mode features are enabled. Pure functions should not produce side effects.\n4.  **Detecting legacy context API**: It warns about deprecated `contextTypes` and `getChildContext` usage, encouraging migration to the newer `React.createContext` API.\n5.  **Ensuring reusable state**: It helps identify state that isn't properly reset between renders, particularly when React is simulating unmounting and remounting components (e.g., when preserving state across different UI trees).\n6.  **Warning about deprecated findDOMNode usage**: It warns if `findDOMNode` is used, which is being phased out as it prevents certain performance optimizations in concurrent mode.\n\n### When to Use StrictMode:\n*   **New applications**: It is highly recommended to wrap the entire application in `StrictMode` when starting a new React project to catch issues early.\n*   **Legacy code maintenance**: When updating or maintaining older codebases, apply `StrictMode` to portions of the application or specific components as you refactor them to ensure they adhere to modern React practices.\n*   **Component library development**: If you are developing a reusable component library, using `StrictMode` helps ensure your components have clean implementations, are free of deprecated patterns, and are ready for future React features.\n\n### Important Notes:\n*   `StrictMode` only runs in **development mode** and has no performance impact or effect on the production build of your application.\n*   It doesn't render any visible UI. Its purpose is purely for warning and debugging.",
          "examples": [
            {
              "id": "example_react_strictmode_1",
              "title": "Applying React.StrictMode to an Application",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\n\n// Example of a component that might trigger StrictMode warnings\nclass UnsafeComponent extends React.Component {\n  // This lifecycle method is considered unsafe and will cause a warning in StrictMode\n  UNSAFE_componentWillMount() {\n    console.log('UNSAFE_componentWillMount called');\n  }\n\n  constructor(props) {\n    super(props);\n    console.log('UnsafeComponent constructor called'); // Will be double-invoked\n    this.state = { count: 0 };\n  }\n\n  render() {\n    console.log('UnsafeComponent render called'); // Will be double-invoked\n    return (\n      <div>\n        <p>Unsafe Component Count: {this.state.count}</p>\n        <button onClick={() => this.setState(prev => ({ count: prev.count + 1 }))}>Increment (watch console)</button>\n      </div>\n    );\n  }\n}\n\n// Example of a functional component with potential side effect in render\nfunction FunctionalSideEffectComponent() {\n  // This side effect will be more noticeable with StrictMode's double invocation\n  console.log('FunctionalSideEffectComponent rendered'); \n  \n  // This would be bad practice if it modified global state or DOM directly\n  // document.title = 'Side Effect!'; \n  \n  return <p>Functional Component with potential side effects.</p>;\n}\n\nfunction App() {\n  return (\n    // Wrap your application or parts of it with StrictMode\n    <React.StrictMode>\n      <div>\n        <h1>App with Strict Mode</h1>\n        <p>Check your browser's console for warnings and double invocations.</p>\n        <UnsafeComponent />\n        <FunctionalSideEffectComponent />\n      </div>\n    </React.StrictMode>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This example demonstrates how to apply `React.StrictMode` to a React application. By wrapping the `App` component's children with `<React.StrictMode>`, React activates additional checks. In this specific example, the `UnsafeComponent` uses `UNSAFE_componentWillMount`, which will trigger a warning in the console. Furthermore, both the constructor and `render` method of `UnsafeComponent`, as well as the functional component's render log, will be called twice in development mode, highlighting that these should ideally be pure functions without side effects. This double invocation helps developers identify potential issues that might arise in future concurrent React modes.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_strictmode_1",
            "question_react_strictmode_2",
            "question_react_strictmode_3",
            "question_react_strictmode_4",
            "question_react_strictmode_5",
            "question_react_strictmode_6"
          ],
          "relatedTasks": [
            "task_demonstrate_strictmode_effects"
          ],
          "tags": [
            "React",
            "StrictMode",
            "Development Tools",
            "Debugging",
            "Lifecycle Methods",
            "Best Practices",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "react_lifecycle",
            "react_functional_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust_application_development",
            "modern_react_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_portal_1",
          "topic": "React Portals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of React Portals?",
          "answer": "To render children into a DOM node that exists outside the DOM hierarchy of the parent component.",
          "options": [],
          "analysisPoints": [
            "Focuses on the core definition of Portals.",
            "Highlights the key benefit of rendering outside the parent's DOM hierarchy."
          ],
          "keyConcepts": [
            "React Portals",
            "DOM Hierarchy",
            "Rendering"
          ],
          "evaluationCriteria": [
            "Ability to define React Portals"
          ],
          "example": "Portals are particularly useful for modals, tooltips, and popovers to manage z-index and overflow issues.",
          "tags": [
            "React",
            "Portals",
            "Basics"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_portal_2",
          "topic": "React Portals",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about event bubbling with React Portals is true?",
          "answer": "Events fired inside a portal will propagate to ancestors in the React component tree, even if those elements are not ancestors in the DOM tree.",
          "options": [
            "Events fired inside a portal only propagate within the portal's DOM hierarchy.",
            "Events fired inside a portal will propagate to ancestors in the React component tree, even if those elements are not ancestors in the DOM tree.",
            "Event bubbling is completely disabled for elements rendered via portals.",
            "Events from portals are caught by the nearest DOM ancestor only, not React ancestors."
          ],
          "analysisPoints": [
            "Tests understanding of a key characteristic of Portals.",
            "Distinguishes between DOM hierarchy and React component hierarchy.",
            "Highlights how React's synthetic event system behaves with Portals."
          ],
          "keyConcepts": [
            "React Portals",
            "Event Bubbling",
            "DOM Tree",
            "React Component Tree"
          ],
          "evaluationCriteria": [
            "Understanding of Portal mechanics.",
            "Ability to differentiate between DOM and React hierarchy effects."
          ],
          "example": "```jsx\n// App component\nfunction App() {\n  const handleClick = () => console.log('App click handled');\n  return (\n    <div onClick={handleClick}>\n      <Modal>\n        <button>Click Me</button> {/* This button's click will bubble up to App */}\n      </Modal>\n    </div>\n  );\n}\n\n// Modal component uses createPortal\n```\nExplanation: Even though the button is rendered in a separate DOM node via `ReactDOM.createPortal`, its click event will still be caught by the `onClick` handler on the `div` in the `App` component, demonstrating that event bubbling respects the React component tree, not just the DOM tree.",
          "tags": [
            "React",
            "Portals",
            "Event Handling"
          ],
          "prerequisites": [
            "react_events",
            "react_dom_integration"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_portal_3",
          "topic": "React Portals",
          "level": "medium",
          "type": "open",
          "question": "Explain how React Portals impact the DOM structure versus the React component hierarchy. Provide an example where this distinction is crucial.",
          "answer": "React Portals allow child components to be rendered into a DOM node that exists outside the parent component's DOM hierarchy. This means that while the rendered HTML element might appear in a completely different part of the document tree (e.g., a modal div at the body root), its logical position within the React component tree remains the same. The component rendered via a portal is still a child of its React parent component.\n\nThis distinction is crucial for:\n\n1.  **Event Bubbling:** As discussed, events (like clicks) still bubble up through the *React component hierarchy*. An event handler on a parent component will catch events from a child rendered in a portal, even if the DOM elements are not nested.\n2.  **Context API:** Components rendered inside a portal can still access Context Providers defined by their ancestors in the *React component hierarchy*. For example, if a ThemeContext is provided by the `App` component, a component inside a portal can consume that context, demonstrating that the context flow follows the React tree, not the DOM tree.\n\n**Example Scenario:** Building a global notification system. You want notification messages to appear always on top of everything, regardless of where they are triggered. You can use a portal to render these notifications directly into a `div` at the very end of `body`. Even though they are visually detached, if a notification component needs to dispatch an action to a Redux store or access user data from a React Context provided by the main `App` component, it can still do so because its connection to the React component tree is preserved.",
          "options": [],
          "analysisPoints": [
            "Evaluates the understanding of the core concept: separation of DOM and React trees.",
            "Requires explanation of how event bubbling and context API are affected (or not affected).",
            "Demands a practical example to illustrate the importance of this concept."
          ],
          "keyConcepts": [
            "React Portals",
            "DOM Hierarchy",
            "React Component Hierarchy",
            "Event Bubbling",
            "Context API"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Correctness of technical details.",
            "Relevance and aptness of the example."
          ],
          "example": "See the detailed answer above.",
          "tags": [
            "React",
            "Portals",
            "Advanced",
            "Context",
            "Event Handling"
          ],
          "prerequisites": [
            "react_context_api",
            "react_events"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_portal_4",
          "topic": "React Portals",
          "level": "easy",
          "type": "flashcard",
          "question": "What function is used to create a React Portal?",
          "answer": "`ReactDOM.createPortal(child, container)`",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of the specific API for creating portals."
          ],
          "keyConcepts": [
            "React Portals",
            "ReactDOM.createPortal"
          ],
          "evaluationCriteria": [
            "Recall of API signature"
          ],
          "example": "```javascript\nimport ReactDOM from 'react-dom';\n// ...\nReactDOM.createPortal(\n  <p>Hello from portal!</p>,\n  document.getElementById('some-dom-node')\n);\n```",
          "tags": [
            "React",
            "Portals",
            "API"
          ],
          "prerequisites": [
            "react_dom_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundary_1",
          "topic": "Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary function of a React Error Boundary?",
          "answer": "To catch JavaScript errors anywhere in its child component tree, log them, and display a fallback UI.",
          "options": [],
          "analysisPoints": [
            "Focuses on the core definition and purpose.",
            "Emphasizes error containment and user experience."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Error Handling",
            "Fallback UI"
          ],
          "evaluationCriteria": [
            "Ability to define Error Boundaries"
          ],
          "example": "Error Boundaries prevent a single component crash from breaking the entire application.",
          "tags": [
            "React",
            "Error Handling",
            "Basics"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundary_2",
          "topic": "Error Boundaries",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following methods are used to implement a React Error Boundary?",
          "answer": "Both `static getDerivedStateFromError(error)` and `componentDidCatch(error, info)`",
          "options": [
            "`componentDidMount()` and `componentWillUnmount()`",
            "`render()` and `setState()`",
            "`static getDerivedStateFromError(error)` only",
            "Both `static getDerivedStateFromError(error)` and `componentDidCatch(error, info)`"
          ],
          "analysisPoints": [
            "Tests knowledge of the specific lifecycle methods for error boundaries.",
            "Distinguishes between methods for fallback UI vs. side effects/logging."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Lifecycle Methods",
            "getDerivedStateFromError",
            "componentDidCatch"
          ],
          "evaluationCriteria": [
            "Identification of correct API for error boundaries"
          ],
          "example": "```javascript\nclass MyErrorBoundary extends React.Component {\n  static getDerivedStateFromError(error) {\n    return { hasError: true }; // To render fallback UI\n  }\n  componentDidCatch(error, info) {\n    logErrorToMyService(error, info); // To log errors\n  }\n  // ... render method ...\n}\n```",
          "tags": [
            "React",
            "Error Handling",
            "API",
            "Lifecycle"
          ],
          "prerequisites": [
            "react_class_components",
            "react_lifecycle"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_3",
          "topic": "Error Boundaries",
          "level": "hard",
          "type": "open",
          "question": "List and explain at least three types of errors that React Error Boundaries do NOT catch. How would you handle these types of errors in a React application?",
          "answer": "React Error Boundaries are designed to catch JavaScript errors that occur during rendering, in lifecycle methods, and in constructors of their child component tree. However, they do not catch all types of errors. Here are three common types they do NOT catch and how to handle them:\n\n1.  **Errors inside event handlers:** Event handlers (e.g., `onClick`, `onChange`) do not occur during the rendering phase of React. Therefore, errors thrown within them are outside the scope of Error Boundaries. \n    *   **Handling:** Use standard JavaScript `try...catch` blocks directly within the event handler function where the error might occur.\n    \n    ```javascript\n    function MyComponent() {\n      const handleClick = () => {\n        try {\n          // Potentially erroneous code\n          throw new Error('Error in click handler');\n        } catch (error) {\n          console.error('Caught error in event handler:', error);\n          // Optionally, update component state to show a local error message\n        }\n      };\n      return <button onClick={handleClick}>Click Me</button>;\n    }\n    ```\n\n2.  **Asynchronous code (e.g., `setTimeout`, `fetch`, `Promise` callbacks):** Errors in asynchronous operations are typically detached from the rendering cycle. \n    *   **Handling:** Use `.catch()` blocks on Promises, `try...catch` with `async/await`, or `try...catch` inside the async callback functions. Global error handling (e.g., `window.addEventListener('unhandledrejection')`) can also be used for unhandled promise rejections.\n    \n    ```javascript\n    async function fetchData() {\n      try {\n        const response = await fetch('/api/data');\n        if (!response.ok) {\n          throw new Error('Network response not ok');\n        }\n        const data = await response.json();\n        // Process data\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      }\n    }\n    ```\n\n3.  **Errors thrown in the Error Boundary itself:** An Error Boundary can only catch errors in its children. If the `render` method of the Error Boundary itself, or its `componentDidCatch` method, throws an error, that error will not be caught by the same boundary. This is to prevent an infinite loop of errors.\n    *   **Handling:** Ensure the code within your Error Boundary's `render` and `componentDidCatch` methods is robust and free of potential errors. Keep the logic simple and isolated. For critical applications, you might consider having a nested or higher-level 'meta' error boundary, but this is usually overkill.\n\n4.  **(Bonus) Server-side rendering (SSR) errors:** Errors that occur during server-side rendering are typically handled by the server framework (e.g., Next.js, Express) and require specific server-side error handling mechanisms rather than React Error Boundaries.",
          "options": [],
          "analysisPoints": [
            "Tests a deep understanding of Error Boundary limitations.",
            "Requires knowledge of alternative error handling strategies.",
            "Assesses ability to provide practical code examples for different error types."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Event Handlers",
            "Asynchronous Code",
            "Try/Catch",
            "Promise Catch"
          ],
          "evaluationCriteria": [
            "Completeness and accuracy of error types.",
            "Correctness and clarity of handling strategies.",
            "Quality of code examples."
          ],
          "example": "See the detailed answer above.",
          "tags": [
            "React",
            "Error Handling",
            "Advanced",
            "JavaScript",
            "Asynchronous"
          ],
          "prerequisites": [
            "react_error_boundaries",
            "javascript_error_handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_error_boundary_4",
          "topic": "Error Boundaries",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary responsibility of `static getDerivedStateFromError(error)` in an Error Boundary?",
          "answer": "To update the state to render a fallback UI.",
          "options": [
            "To log the error to an external service.",
            "To update the state to render a fallback UI.",
            "To perform side effects after an error occurs.",
            "To re-render the child components with corrected props."
          ],
          "analysisPoints": [
            "Distinguishes `getDerivedStateFromError` from `componentDidCatch`.",
            "Focuses on its role in UI rendering after an error."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "getDerivedStateFromError",
            "Fallback UI",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of lifecycle method responsibilities"
          ],
          "example": "```javascript\nclass ErrorBoundary extends React.Component {\n  static getDerivedStateFromError(error) {\n    // This is where you would return { hasError: true }\n    // to trigger a re-render with the fallback UI.\n    return { hasError: true };\n  }\n  // ... other methods ...\n}\n```",
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle",
            "API"
          ],
          "prerequisites": [
            "react_lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_5",
          "topic": "Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "Can functional components be React Error Boundaries?",
          "answer": "No, currently Error Boundaries must be class components that define `static getDerivedStateFromError` or `componentDidCatch`.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of the current limitation of Error Boundaries.",
            "Reinforces that specific lifecycle methods are required."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Functional Components",
            "Class Components",
            "Limitations"
          ],
          "evaluationCriteria": [
            "Recall of API restrictions"
          ],
          "example": "There are no hooks equivalent to `componentDidCatch` or `getDerivedStateFromError` for functional components.",
          "tags": [
            "React",
            "Error Handling",
            "Components"
          ],
          "prerequisites": [
            "react_components_types"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundary_6",
          "topic": "Error Boundaries",
          "level": "medium",
          "type": "code",
          "question": "Implement a simple React Error Boundary component that displays a generic error message 'Something went wrong.' when an error occurs in its children. The error boundary should also log the error to the console.",
          "answer": "```typescript\nimport React from 'react';\n\nclass SimpleErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render shows the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service here.\n    console.error(\"Caught by SimpleErrorBoundary:\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Render any custom fallback UI.\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\n// Example usage:\n// function BuggyComponent() {\n//   throw new Error('I am a buggy component!');\n// }\n\n// function App() {\n//   return (\n//     <SimpleErrorBoundary>\n//       <BuggyComponent />\n//     </SimpleErrorBoundary>\n//   );\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Correct implementation of `static getDerivedStateFromError` to manage `hasError` state.",
            "Correct implementation of `componentDidCatch` for logging.",
            "Proper conditional rendering of fallback UI.",
            "Understanding of `this.props.children` usage."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Class Components",
            "Lifecycle Methods",
            "State Management",
            "Fallback UI"
          ],
          "evaluationCriteria": [
            "Functional correctness.",
            "Adherence to React Error Boundary API.",
            "Code readability."
          ],
          "example": "See the `answer` field for the code example.",
          "tags": [
            "React",
            "Error Handling",
            "Coding Challenge"
          ],
          "prerequisites": [
            "react_class_components",
            "react_lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_strictmode_1",
          "topic": "React.StrictMode",
          "level": "easy",
          "type": "flashcard",
          "question": "Does React.StrictMode affect the production build of an application?",
          "answer": "No, React.StrictMode only runs in development mode and has no effect on production builds.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of StrictMode's runtime environment.",
            "Highlights its debugging/development-only nature."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Development Mode",
            "Production Build"
          ],
          "evaluationCriteria": [
            "Recall of StrictMode's scope"
          ],
          "example": "Strict Mode is purely a development tool, it doesn't add any overhead to your production code.",
          "tags": [
            "React",
            "StrictMode",
            "Development Tools"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_strictmode_2",
          "topic": "React.StrictMode",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a benefit or check performed by React.StrictMode?",
          "answer": "Minimizing bundle size by removing unused code.",
          "options": [
            "Identifying components with unsafe lifecycle methods.",
            "Warning about legacy string ref API usage.",
            "Minimizing bundle size by removing unused code.",
            "Detecting unexpected side effects by double-invoking functions."
          ],
          "analysisPoints": [
            "Tests comprehensive knowledge of StrictMode's capabilities.",
            "Distinguishes its role from build optimization tools."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Development Tools",
            "Lifecycle Methods",
            "Side Effects",
            "Refs",
            "Bundle Size"
          ],
          "evaluationCriteria": [
            "Ability to identify core functions of StrictMode.",
            "Distinguishing between development tools and build optimizations."
          ],
          "example": "Strict Mode focuses on runtime checks and warnings during development, not build-time optimizations like tree-shaking or minification.",
          "tags": [
            "React",
            "StrictMode",
            "Benefits"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_strictmode_3",
          "topic": "React.StrictMode",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose and mechanism behind React.StrictMode's 'detecting unexpected side effects' check. Provide an example of how this might help a developer.",
          "answer": "React.StrictMode helps in 'detecting unexpected side effects' by intentionally double-invoking certain functions during development mode. These functions include:\n*   Class component `constructor` methods\n*   `render` methods (for both class and functional components)\n*   `setState` updater functions\n*   `useReducer` reducer functions\n\nThe **purpose** of this double invocation is to ensure that these functions are pure functions and do not produce any unintended side effects. In future versions of React with concurrent rendering, React might pause and resume rendering, or even start rendering multiple times. If these functions have side effects (e.g., modifying global variables, making network requests, directly manipulating the DOM), those side effects could be executed multiple times, leading to inconsistent UI or bugs.\n\n**Mechanism:** When StrictMode is active, React calls these functions twice. If there are side effects, running them twice will often expose an issue (e.g., an element being appended twice, a state update occurring unexpectedly, a subscription being created twice). React then discards the result of the first invocation and uses the second, or simply discards the side effect for functions that should be pure.\n\n**Example:** Consider a component that fetches data inside its `render` method (a common anti-pattern):\n\n```jsx\nfunction MyDataComponent() {\n  // Bad practice: Side effect (fetch) in render\n  fetch('/api/data').then(res => res.json()).then(data => console.log(data));\n  return <div>Data Loading...</div>;\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <MyDataComponent />\n    </React.StrictMode>\n  );\n}\n```\n\nWithout StrictMode, `fetch` would be called once per render. With StrictMode, `fetch` would be called twice during the initial mount. This double network request would immediately alert the developer to an unexpected side effect, prompting them to move the `fetch` call to a `useEffect` hook (for functional components) or `componentDidMount` (for class components) with proper cleanup, ensuring it runs only once and at the appropriate time.",
          "options": [],
          "analysisPoints": [
            "Explains the 'why' (purity, future concurrent mode).",
            "Details the 'how' (double invocation of specific functions).",
            "Provides a clear and relevant example demonstrating the benefit."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Side Effects",
            "Pure Functions",
            "Concurrent Mode",
            "Double Invocation",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation.",
            "Completeness of functions affected.",
            "Effectiveness of the example."
          ],
          "example": "See the detailed answer above.",
          "tags": [
            "React",
            "StrictMode",
            "Advanced",
            "Debugging",
            "Best Practices"
          ],
          "prerequisites": [
            "react_lifecycle",
            "react_functional_components",
            "javascript_side_effects"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_strictmode_4",
          "topic": "React.StrictMode",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you enable React.StrictMode in your application?",
          "answer": "By wrapping the components you want to check with `<React.StrictMode></React.StrictMode>`.",
          "options": [],
          "analysisPoints": [
            "Tests basic syntax for StrictMode integration."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Usage",
            "Wrapper Component"
          ],
          "evaluationCriteria": [
            "Recall of usage syntax"
          ],
          "example": "```jsx\nfunction App() {\n  return (\n    <React.StrictMode>\n      <MyComponent />\n    </React.StrictMode>\n  );\n}\n```",
          "tags": [
            "React",
            "StrictMode",
            "Usage"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_strictmode_5",
          "topic": "React.StrictMode",
          "level": "medium",
          "type": "open",
          "question": "When should you consider using React.StrictMode? Provide at least two scenarios where it is particularly beneficial.",
          "answer": "React.StrictMode is a valuable tool for maintaining code quality and preparing for future React features. Here are two scenarios where it's particularly beneficial:\n\n1.  **Starting a New React Application:** When beginning a new React project, it's highly recommended to wrap the entire application's root component (e.g., `App` component) with `<React.StrictMode>`. This ensures that all components, from the very beginning, are developed following modern best practices. It helps catch unsafe lifecycle methods, deprecated APIs, and accidental side effects early in the development cycle, preventing them from becoming deeply ingrained issues that are harder to refactor later. This promotes cleaner, more predictable code.\n\n2.  **Maintaining or Updating Legacy Codebases:** For existing applications, especially those that might have been started with older versions of React or have not consistently followed the latest recommendations, applying `StrictMode` can be immensely beneficial. Developers can incrementally wrap specific sections or components that are being refactored or actively worked on. This helps identify and migrate away from deprecated features (like string refs or legacy context API) and fix potential side effects that might not be obvious until explicitly highlighted by StrictMode's checks. It's a strategic way to gradually modernize an application without needing a complete rewrite.\n\n**Bonus:** **Developing Component Libraries:** When creating reusable UI component libraries, using `StrictMode` during development is crucial. It ensures that the components are robust, free from deprecated patterns, and compatible with future React behaviors, making them reliable for consumers of the library.",
          "options": [],
          "analysisPoints": [
            "Identifies practical use cases for StrictMode.",
            "Explains the benefits in each scenario (proactive error prevention, refactoring).",
            "Demonstrates an understanding of the development lifecycle."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Best Practices",
            "New Applications",
            "Legacy Code",
            "Refactoring",
            "Component Libraries"
          ],
          "evaluationCriteria": [
            "Relevance of scenarios.",
            "Clarity of explanation for benefits in each case."
          ],
          "example": "See the detailed answer above.",
          "tags": [
            "React",
            "StrictMode",
            "Usage",
            "Best Practices"
          ],
          "prerequisites": [
            "react_project_structure"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_strictmode_6",
          "topic": "React.StrictMode",
          "level": "medium",
          "type": "code",
          "question": "Consider the following component. Explain what `React.StrictMode` would warn about and how you would refactor it to remove the warning.",
          "answer": "```javascript\nimport React from 'react';\n\nclass LegacyComponent extends React.Component {\n  // This method is considered unsafe and will cause a warning in StrictMode.\n  // It's deprecated for async rendering modes.\n  UNSAFE_componentWillMount() {\n    console.log('LegacyComponent: UNSAFE_componentWillMount called');\n    // Any state updates or side effects here could be problematic.\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n    console.log('LegacyComponent: Constructor called'); // Will be double-invoked by StrictMode\n  }\n\n  render() {\n    console.log('LegacyComponent: Render called'); // Will be double-invoked by StrictMode\n    return <div>Legacy Component Content</div>;\n  }\n}\n\n// How StrictMode would warn:\n// 1. Warning about `UNSAFE_componentWillMount` usage. React will suggest migrating to `componentDidMount` or `constructor`.\n// 2. The console logs for 'Constructor called' and 'Render called' will appear twice, indicating double invocation to highlight potential side effects.\n\n// Refactored Component:\nclass ModernComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n    console.log('ModernComponent: Constructor called'); // Still double-invoked, but no unsafe method warning.\n  }\n\n  componentDidMount() {\n    // Preferred place for side effects that need to run once after mount\n    console.log('ModernComponent: componentDidMount called');\n    // Example: fetch data here\n    // fetch('/api/data').then(...)\n  }\n\n  render() {\n    console.log('ModernComponent: Render called'); // Still double-invoked, pure function expected\n    return <div>Modern Component Content</div>;\n  }\n}\n\n// Functional Component Refactor (even better for new code):\nfunction ModernFunctionalComponent() {\n  const [data, setData] = React.useState(null);\n\n  React.useEffect(() => {\n    console.log('ModernFunctionalComponent: useEffect called'); // Runs only once after initial render (if dependencies are empty array)\n    // Fetch data here:\n    // fetch('/api/data').then(res => res.json()).then(setData);\n\n    return () => {\n      console.log('ModernFunctionalComponent: useEffect cleanup'); // Cleanup for subscriptions/timers\n    };\n  }, []); // Empty dependency array means this runs once on mount\n\n  console.log('ModernFunctionalComponent: Render called'); // Still double-invoked in StrictMode\n\n  return <div>Modern Functional Component Content: {data}</div>;\n}\n\n// Usage with StrictMode:\n// function App() {\n//   return (\n//     <React.StrictMode>\n//       <ModernComponent />\n//       <ModernFunctionalComponent />\n//     </React.StrictMode>\n//   );\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Identifies the `UNSAFE_componentWillMount` as the primary warning.",
            "Explains the double-invocation behavior for constructor and render.",
            "Provides a correct refactoring using `componentDidMount`.",
            "Optionally provides a functional component refactor using `useEffect` for better modern React practices."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Unsafe Lifecycle Methods",
            "Double Invocation",
            "Refactoring",
            "componentDidMount",
            "useEffect"
          ],
          "evaluationCriteria": [
            "Correct identification of warnings.",
            "Accurate refactoring to remove warnings.",
            "Understanding of modern React patterns."
          ],
          "example": "See the `answer` field for the code example and explanation.",
          "tags": [
            "React",
            "StrictMode",
            "Code Refactoring",
            "Lifecycle Methods",
            "Functional Components"
          ],
          "prerequisites": [
            "react_lifecycle",
            "react_hooks",
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_modal_with_portal",
          "title": "Implement a Reusable Modal Component with React Portals",
          "description": "\nCreate a reusable `Modal` component in React that utilizes `ReactDOM.createPortal`. The modal should:\n\n1.  Render its children (content) into a specific DOM node outside the main React app's root (e.g., a `div` with `id=\"modal-root\"` in `public/index.html`).\n2.  Include a semi-transparent backdrop that covers the entire screen.\n3.  Allow closing the modal by clicking on the backdrop or by clicking a 'Close' button within the modal content.\n4.  Prevent events from inside the modal content from bubbling to the backdrop when clicking on the content itself.\n5.  Be usable from an `App` component by simply conditionally rendering it.\n\n**Requirements:**\n-   Use `ReactDOM.createPortal`.\n-   The modal should receive `children` for its content and an `onClose` callback.\n-   Ensure proper event handling for closing and content interaction.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// You will need to add <div id=\"modal-root\"></div> to your public/index.html body.\n\n// --- Modal Component (Implement this) ---\nfunction Modal({ children, onClose }) {\n  // TODO: Implement portal logic and modal structure\n  const modalRoot = document.getElementById('modal-root');\n  if (!modalRoot) {\n    console.error(\"Missing #modal-root in index.html\");\n    return null;\n  }\n\n  return ReactDOM.createPortal(\n    <div className=\"modal-backdrop\" style={{ \n      position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,\n      backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex',\n      justifyContent: 'center', alignItems: 'center', zIndex: 1000\n    }} onClick={onClose}>\n      <div className=\"modal-content\" style={{ \n        background: 'white', padding: '20px', borderRadius: '5px',\n        minWidth: '300px', maxWidth: '80%', boxShadow: '0 4px 8px rgba(0,0,0,0.2)'\n      }} onClick={e => e.stopPropagation()}>\n        {children}\n        <button onClick={onClose} style={{ marginTop: '15px', padding: '8px 15px' }}>Close</button>\n      </div>\n    </div>,\n    modalRoot\n  );\n}\n\n// --- App Component (Use the Modal here) ---\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <div style={{ padding: '20px', textAlign: 'center' }}>\n      <h1>React Portal Modal Demo</h1>\n      <p>Click the button below to open the modal.</p>\n      <button onClick={() => setShowModal(true)} style={{ padding: '10px 20px', fontSize: '16px' }}>\n        Show Portal Modal\n      </button>\n      \n      {showModal && (\n        <Modal onClose={() => setShowModal(false)}>\n          <h2>Welcome to the Modal!</h2>\n          <p>This content is rendered outside the main app DOM.</p>\n          <p>Click outside or the close button to dismiss.</p>\n        </Modal>\n      )}\n      \n      <div style={{ height: '1000px', background: '#f0f0f0', marginTop: '20px', overflow: 'auto' }}>\n        <p>Scrollable background content to demonstrate modal positioning.</p>\n        {Array.from({ length: 50 }).map((_, i) => (\n          <p key={i}>Scroll item {i + 1}</p>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction Modal({ children, onClose }) {\n  const modalRoot = document.getElementById('modal-root');\n  if (!modalRoot) {\n    // Fallback or error handling if modal-root doesn't exist\n    console.error(\"The DOM element with ID 'modal-root' was not found. Please add <div id=\\\"modal-root\\\"></div> to your public/index.html\");\n    return null;\n  }\n\n  return ReactDOM.createPortal(\n    <div className=\"modal-backdrop\" \n         onClick={onClose} \n         style={{\n           position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,\n           backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex',\n           justifyContent: 'center', alignItems: 'center', zIndex: 1000\n         }}>\n      <div className=\"modal-content\" \n           onClick={e => e.stopPropagation()} \n           style={{\n             background: 'white', padding: '20px', borderRadius: '5px',\n             minWidth: '300px', maxWidth: '80%', boxShadow: '0 4px 8px rgba(0,0,0,0.2)'\n           }}>\n        {children}\n        <button onClick={onClose} style={{ marginTop: '15px', padding: '8px 15px', cursor: 'pointer' }}>Close</button>\n      </div>\n    </div>,\n    modalRoot\n  );\n}\n\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <div style={{ padding: '20px', textAlign: 'center' }}>\n      <h1>React Portal Modal Demo</h1>\n      <p>Click the button below to open the modal.</p>\n      <button onClick={() => setShowModal(true)} style={{ padding: '10px 20px', fontSize: '16px', cursor: 'pointer' }}>\n        Show Portal Modal\n      </button>\n      \n      {showModal && (\n        <Modal onClose={() => setShowModal(false)}>\n          <h2>Welcome to the Modal!</h2>\n          <p>This content is rendered outside the main app DOM.</p>\n          <p>Click outside or the close button to dismiss.</p>\n        </Modal>\n      )}\n      \n      <div style={{ height: '1000px', background: '#f0f0f0', marginTop: '20px', overflow: 'auto' }}>\n        <p>Scrollable background content to demonstrate modal positioning.</p>\n        {Array.from({ length: 50 }).map((_, i) => (\n          <p key={i}>Scroll item {i + 1}</p>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Modal opens when 'Show Portal Modal' button is clicked.",
            "Modal closes when the 'Close' button inside the modal is clicked.",
            "Modal closes when the semi-transparent backdrop is clicked.",
            "Modal does NOT close when the content inside the modal (e.g., text, inner elements) is clicked.",
            "Modal appears correctly positioned and centered, even when the background content is scrolled.",
            "Application remains responsive and interactive (apart from the modal) while the modal is open.",
            "Verify in browser developer tools that the modal element is appended to `#modal-root` (or the specified container) and not within the main `#root` div."
          ],
          "hints": [
            "Remember to create a dedicated DOM element (e.g., `<div id=\"modal-root\"></div>`) in your `public/index.html` file where the portal will render its content.",
            "Use `e.stopPropagation()` on the modal content's click handler to prevent clicks inside the modal from bubbling up to the backdrop.",
            "Consider using `position: fixed` for the backdrop to cover the entire viewport."
          ],
          "tags": [
            "React",
            "Portals",
            "UI Components",
            "Modals",
            "DOM Manipulation",
            "Event Handling"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_state",
            "react_props",
            "dom_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_state_management",
            "event_bubbling",
            "css_positioning"
          ]
        },
        {
          "id": "task_implement_error_boundary",
          "title": "Implement and Demonstrate a React Error Boundary",
          "description": "\nImplement a React Error Boundary component and demonstrate its functionality by wrapping a child component that deliberately throws an error. The task requires:\n\n1.  **Create an `ErrorBoundary` class component**: This component must catch JavaScript errors in its children.\n    *   It should use `static getDerivedStateFromError(error)` to update state to trigger a fallback UI.\n    *   It should use `componentDidCatch(error, info)` to log the error to the console (simulating an error reporting service).\n    *   Its `render` method should conditionally display either its `children` or a fallback UI (e.g., 'Something went wrong.').\n2.  **Create a `BuggyComponent` functional component**: This component should throw an error under a specific condition (e.g., when a counter reaches a certain number, or a prop is missing).\n3.  **Demonstrate usage in `App`**: Wrap one instance of `BuggyComponent` with your `ErrorBoundary` and place another instance of `BuggyComponent` outside the `ErrorBoundary` to show the difference in behavior (one gracefully handles the error, the other crashes the app).\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// --- ErrorBoundary Component (Implement this) ---\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  // TODO: Implement static getDerivedStateFromError\n\n  // TODO: Implement componentDidCatch\n\n  render() {\n    // TODO: Conditionally render fallback UI or children\n    if (this.state.hasError) {\n      return (\n        <div style={{ border: '1px solid red', padding: '10px', margin: '10px' }}>\n          <h2>Something went wrong.</h2>\n          {/* Optional: display error details in development */}\n          {this.state.error && this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              {this.state.error.toString()}\n              <br />\n              {this.state.errorInfo.componentStack}\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\n// --- Buggy Component (Implement this) ---\nfunction BuggyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    // TODO: Make this component throw an error under a condition\n    setCount(prevCount => prevCount + 1);\n  };\n\n  if (count > 5) {\n    // Example: Throw an error during render if count exceeds 5\n    // throw new Error('I crashed due to count exceeding 5!');\n  }\n\n  return (\n    <div style={{ border: '1px solid gray', padding: '10px', margin: '10px' }}>\n      <p>Buggy Counter: {count}</p>\n      <button onClick={handleClick}>Increment Buggy Counter</button>\n    </div>\n  );\n}\n\n// --- App Component (Use the components here) ---\nfunction App() {\n  return (\n    <div>\n      <h1>Error Boundary Demonstration</h1>\n      <p>The first counter is wrapped in an Error Boundary. The second is not.</p>\n      \n      {/* Wrapped BuggyComponent */}\n      <ErrorBoundary>\n        <BuggyComponent />\n      </ErrorBoundary>\n\n      <hr />\n      \n      {/* Unwrapped BuggyComponent (will crash the app) */}\n      <h2>Unwrapped Component:</h2>\n      <BuggyComponent />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// --- ErrorBoundary Component ---\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render shows the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service here.\n    console.error(\"Caught by ErrorBoundary:\", error, errorInfo);\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Render any custom fallback UI.\n      return (\n        <div style={{ border: '1px solid red', padding: '10px', margin: '10px', backgroundColor: '#ffe6e6' }}>\n          <h2>Something went wrong in this section.</h2>\n          <p>We are sorry for the inconvenience.</p>\n          {/* Display error details in development for debugging */}\n          {this.state.error && this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap', fontSize: '0.8em', color: '#cc0000' }}>\n              {this.state.error.toString()}\n              <br />\n              {this.state.errorInfo.componentStack}\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\n// --- Buggy Component ---\nfunction BuggyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  if (count === 5) {\n    // This error will be caught by the ErrorBoundary if wrapped\n    throw new Error('BuggyComponent crashed at count 5!');\n  }\n\n  return (\n    <div style={{ border: '1px solid gray', padding: '10px', margin: '10px', backgroundColor: '#f9f9f9' }}>\n      <p>Current Count: {count}</p>\n      <button onClick={handleClick}>Increment Counter</button>\n      <p>Keep clicking to see the error!</p>\n    </div>\n  );\n}\n\n// --- App Component ---\nfunction App() {\n  return (\n    <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #eee', boxShadow: '2px 2px 5px rgba(0,0,0,0.1)' }}>\n      <h1 style={{ textAlign: 'center' }}>React Error Boundary Demonstration</h1>\n      <p>This example demonstrates how Error Boundaries help prevent an entire application crash. The first counter is wrapped in an Error Boundary, while the second is not.</p>\n      \n      <h2 style={{ color: '#0056b3' }}>Wrapped Component:</h2>\n      <ErrorBoundary>\n        <BuggyComponent />\n      </ErrorBoundary>\n\n      <hr style={{ margin: '30px 0' }}/>\n      \n      <h2 style={{ color: '#cc0000' }}>Unwrapped Component (will crash the app):</h2>\n      <BuggyComponent />\n      \n      <p style={{ marginTop: '40px', fontSize: '0.9em', color: '#666' }}>Note: The unwrapped component will cause the entire React application to unmount and display a blank page or a development error overlay when it crashes.</p>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "The first `BuggyComponent` (wrapped) displays the 'Something went wrong.' fallback UI when it throws an error (e.g., count reaches 5).",
            "The browser's console shows the error logged by `componentDidCatch` when the wrapped `BuggyComponent` crashes.",
            "The second `BuggyComponent` (unwrapped) causes the entire React application to crash or show the development error overlay when it throws an error.",
            "The 'Something went wrong.' message is displayed only where the error occurred, not affecting other parts of the application if the error is within a boundary.",
            "No errors are thrown in the ErrorBoundary component itself."
          ],
          "hints": [
            "Remember to use `static getDerivedStateFromError` for state updates and `componentDidCatch` for side effects like logging.",
            "Ensure the error in `BuggyComponent` is thrown during rendering or a lifecycle method (not inside an event handler) for the Error Boundary to catch it.",
            "You can throw a simple `new Error('Your custom error message');` from `BuggyComponent`.",
            "The `render` method of the `ErrorBoundary` should check `this.state.hasError` to conditionally render the fallback UI or `this.props.children`."
          ],
          "tags": [
            "React",
            "Error Handling",
            "Class Components",
            "Lifecycle Methods",
            "Debugging"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "react_state",
            "react_lifecycle"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_component_lifecycle",
            "state_management",
            "error_logging"
          ]
        },
        {
          "id": "task_demonstrate_strictmode_effects",
          "title": "Demonstrate React.StrictMode's Effects on Component Lifecycle",
          "description": "\nThis task involves demonstrating the effect of `React.StrictMode` on component lifecycle methods and render functions.\n\n1.  **Create a `StrictModeDemoComponent` (Class Component)**:\n    *   Include a `constructor` that logs a message.\n    *   Include a `render` method that logs a message.\n    *   Optionally, include an `UNSAFE_componentWillMount()` method that logs a message to observe a specific StrictMode warning.\n2.  **Create a `FunctionalStrictModeDemo` (Functional Component)**:\n    *   Include a `console.log` directly in the component body (which runs during render).\n    *   Include a `useEffect` hook that logs a message once on mount.\n3.  **Wrap your components in `App` with `React.StrictMode`**.\n4.  **Run the application and observe the console output.** Document which logs appear twice (due to double invocation) and any specific warnings from StrictMode.\n5.  **Explain the observations:** Why do certain logs appear twice? What does this imply about the purity of `render` methods and constructors?\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// --- StrictModeDemoComponent (Class Component) ---\nclass StrictModeDemoComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    console.log('StrictModeDemoComponent: Constructor called');\n    this.state = { count: 0 };\n  }\n\n  // Optional: Add UNSAFE_componentWillMount() for a specific StrictMode warning\n  // UNSAFE_componentWillMount() {\n  //   console.log('StrictModeDemoComponent: UNSAFE_componentWillMount called');\n  // }\n\n  render() {\n    console.log('StrictModeDemoComponent: Render called');\n    return (\n      <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n        <h3>Class Component Demo</h3>\n        <p>Check console for logs.</p>\n        <button onClick={() => this.setState(prev => ({ count: prev.count + 1 }))}>Increment (Affects Render)</button>\n      </div>\n    );\n  }\n}\n\n// --- FunctionalStrictModeDemo (Functional Component) ---\nfunction FunctionalStrictModeDemo() {\n  console.log('FunctionalStrictModeDemo: Component body (render) called');\n\n  useEffect(() => {\n    console.log('FunctionalStrictModeDemo: useEffect (mount) called');\n    // This should only run once on mount\n    return () => {\n      console.log('FunctionalStrictModeDemo: useEffect (cleanup) called');\n    };\n  }, []); // Empty dependency array means run once on mount and cleanup on unmount\n\n  return (\n    <div style={{ border: '1px dashed green', padding: '10px', margin: '10px' }}>\n      <h3>Functional Component Demo</h3>\n      <p>Check console for logs.</p>\n    </div>\n  );\n}\n\n// --- App Component ---\nfunction App() {\n  return (\n    <React.StrictMode>\n      <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #eee', boxShadow: '2px 2px 5px rgba(0,0,0,0.1)' }}>\n        <h1>React.StrictMode Demonstration</h1>\n        <p>Open your browser's developer console to observe the logs and warnings from StrictMode.</p>\n        <p>Notice how certain messages might appear twice.</p>\n\n        <StrictModeDemoComponent />\n        <FunctionalStrictModeDemo />\n\n      </div>\n    </React.StrictMode>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// --- StrictModeDemoComponent (Class Component) ---\nclass StrictModeDemoComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    console.log('StrictModeDemoComponent: Constructor called (should be double-invoked in StrictMode)');\n    this.state = { count: 0 };\n  }\n\n  // This lifecycle method is considered unsafe and will cause a warning in StrictMode.\n  UNSAFE_componentWillMount() {\n    console.log('StrictModeDemoComponent: UNSAFE_componentWillMount called (Strict Mode Warning!)');\n  }\n\n  componentDidMount() {\n    console.log('StrictModeDemoComponent: componentDidMount called (should be single-invoked)');\n  }\n\n  render() {\n    console.log('StrictModeDemoComponent: Render called (should be double-invoked in StrictMode)');\n    return (\n      <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px', backgroundColor: '#e6f0ff' }}>\n        <h3>Class Component Demo</h3>\n        <p>Check console for logs.</p>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState(prev => ({ count: prev.count + 1 }))}>Increment (Affects Render)</button>\n      </div>\n    );\n  }\n}\n\n// --- FunctionalStrictModeDemo (Functional Component) ---\nfunction FunctionalStrictModeDemo() {\n  console.log('FunctionalStrictModeDemo: Component body (render) called (should be double-invoked in StrictMode)');\n\n  useEffect(() => {\n    console.log('FunctionalStrictModeDemo: useEffect (mount) called (should be single-invoked)');\n    // This should only run once on mount\n    return () => {\n      console.log('FunctionalStrictModeDemo: useEffect (cleanup) called (should run on unmount/re-mount)');\n    };\n  }, []); // Empty dependency array means run once on mount and cleanup on unmount\n\n  return (\n    <div style={{ border: '1px dashed green', padding: '10px', margin: '10px', backgroundColor: '#e6ffe6' }}>\n      <h3>Functional Component Demo</h3>\n      <p>Check console for logs.</p>\n    </div>\n  );\n}\n\n// --- App Component ---\nfunction App() {\n  return (\n    <React.StrictMode>\n      <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #eee', boxShadow: '2px 2px 5px rgba(0,0,0,0.1)' }}>\n        <h1>React.StrictMode Demonstration</h1>\n        <p>Open your browser's developer console to observe the logs and warnings from StrictMode.</p>\n        <p>Notice how certain messages might appear twice, indicating checks for unexpected side effects.</p>\n        <p>Also, look for warnings about deprecated lifecycle methods.</p>\n\n        <StrictModeDemoComponent />\n        <FunctionalStrictModeDemo />\n\n        <div style={{ marginTop: '30px', borderTop: '1px solid #eee', paddingTop: '20px' }}>\n          <h3>Observations Explanation:</h3>\n          <ul>\n            <li>The <b>Constructor</b> and <b>Render</b> methods (both class and functional component bodies) are logged twice. This is StrictMode's way of detecting potential side effects. If these methods were not pure (e.g., directly modifying the DOM or global state), running them twice could lead to bugs.</li>\n            <li><code>UNSAFE_componentWillMount</code> (if uncommented) will trigger a warning. StrictMode helps identify legacy and problematic lifecycle methods.</li>\n            <li><code>componentDidMount</code> and <code>useEffect</code> with an empty dependency array (`[]`) are logged only once. These are the correct places for side effects that should run only once after a component mounts, as React ensures they are not double-invoked.</li>\n          </ul>\n        </div>\n\n      </div>\n    </React.StrictMode>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Browser console shows `StrictModeDemoComponent: Constructor called` twice on initial render.",
            "Browser console shows `StrictModeDemoComponent: Render called` twice on initial render and any state updates.",
            "Browser console shows `FunctionalStrictModeDemo: Component body (render) called` twice on initial render.",
            "Browser console shows `StrictModeDemoComponent: UNSAFE_componentWillMount called` once AND a React warning about its usage.",
            "Browser console shows `StrictModeDemoComponent: componentDidMount called` only once.",
            "Browser console shows `FunctionalStrictModeDemo: useEffect (mount) called` only once.",
            "The application renders without errors, and the console clearly shows the intended StrictMode behaviors (double invocations, warnings)."
          ],
          "hints": [
            "Remember that `React.StrictMode` only affects development mode, so these logs and warnings will not appear in a production build.",
            "The double invocation for `render` and constructors is a key aspect of StrictMode's 'detecting unexpected side effects' check.",
            "Side effects that should only run once (like data fetching or subscriptions) should be placed in `componentDidMount` (for class components) or `useEffect` with an empty dependency array (for functional components), as these are explicitly designed to be safe from double invocation."
          ],
          "tags": [
            "React",
            "StrictMode",
            "Debugging",
            "Lifecycle Methods",
            "Functional Components",
            "Class Components"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "react_lifecycle",
            "react_hooks",
            "react_functional_components",
            "react_class_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "pure_functions",
            "side_effects",
            "concurrent_mode",
            "component_purity"
          ]
        }
      ]
    }
  },
  {
    "id": "f6c5f866-13e0-4184-98a2-063323ed2131",
    "startLine": 6100,
    "endLine": 6199,
    "processedDate": "2025-06-17T09:52:07.119Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_strict_mode",
          "title": "React StrictMode",
          "content": "React's `StrictMode` is a development-only tool that helps developers identify potential problems in an application. It activates additional checks and warnings for its descendants. It does not render any visible UI and does not impact the production build.\n\n## Purpose of StrictMode\n- **Identifying Side Effects**: StrictMode helps detect unintended side effects by deliberately double-invoking certain functions (like `render` method, `useState` updater functions, `useEffect` cleanup and setup functions). If a function is pure, calling it twice should not change the application state or behavior, making side effects obvious.\n- **Preparing for Future React Features**: It helps your code be more resilient to future changes in React, especially related to concurrent rendering. Features like concurrent mode or automatic batching rely on components being pure and side-effect free.\n- **Deprecation Warnings**: It warns about deprecated lifecycle methods or API usages.\n- **Legacy Context API**: Warns about unsafe lifecycles, and usage of the legacy context API.\n- **Finding unexpected side effects**: It checks for unexpected side effects during component rendering, state updates, and lifecycle methods.\n\n## Double-Invocation Mechanism\nStrictMode intentionally double-invokes methods or functions such as:\n- Component `render` method.\n- `useState`, `useReducer` updater functions.\n- `useEffect` cleanup and setup functions.\n- Class component `constructor`, `render`, `shouldComponentUpdate`, `getDerivedStateFromProps`, `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`.\n\nIf your components are pure and free of side effects, this double invocation will not cause any issues. If there are side effects (e.g., mutating external state in a `render` method), the double invocation will make them more apparent during development, aiding in debugging and fixing them.\n\n## Usage\nTo use `StrictMode`, wrap any part of your application with `<React.StrictMode>`.",
          "examples": [
            {
              "id": "example_strict_mode_1",
              "title": "Basic StrictMode Usage",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction MyComponent() {\n  // In StrictMode, if this console.log had side effects, \n  // it would be more apparent due to double invocation.\n  console.log('MyComponent is rendering');\n  return <h1>Hello from MyComponent</h1>;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <MyComponent />\n  </React.StrictMode>\n);",
              "explanation": "This example shows how to wrap a component with `React.StrictMode`. During development, `MyComponent`'s `console.log` might appear twice, indicating the double invocation of the render method and prompting developers to ensure their components' render logic is pure.",
              "language": "typescript"
            },
            {
              "id": "example_strict_mode_2",
              "title": "StrictMode with useState and useEffect",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect setup run, count:', count);\n    return () => {\n      console.log('Effect cleanup run, count:', count);\n    };\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <Counter />\n    </React.StrictMode>\n  );\n}\n\nexport default App;",
              "explanation": "In this example, when `Counter` mounts or `count` changes in StrictMode, you will see the effect setup and cleanup functions log twice. This is React helping ensure that your effects are idempotent and handle cleanup correctly, which is crucial for future concurrent features.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_strict_mode_1",
            "question_strict_mode_2",
            "question_strict_mode_3",
            "question_strict_mode_4",
            "question_strict_mode_5"
          ],
          "relatedTasks": [
            "task_strict_mode_1"
          ],
          "tags": [
            "React",
            "StrictMode",
            "Development",
            "Debugging",
            "Side Effects",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Component_Lifecycle",
            "React_Hooks_Basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Concurrent_React",
            "Advanced_Debugging"
          ]
        },
        {
          "id": "theory_error_handling_boundaries",
          "title": "React Error Boundaries",
          "content": "React 16 introduced the concept of **Error Boundaries** to gracefully handle JavaScript errors in components. An Error Boundary is a React component that **catches JavaScript errors anywhere in its child component tree, logs those errors, and displays a fallback UI** instead of crashing the entire application.\n\n## Why Error Boundaries?\nWithout error boundaries, a JavaScript error in a component's render method would unmount the entire React component tree, leading to a blank screen or a broken UI. Error boundaries provide a way to 'catch' these errors and render a meaningful fallback UI, preventing the entire application from crashing.\n\n## How to Create an Error Boundary\nAn error boundary is a class component that implements at least one of two new lifecycle methods:\n\n1.  `static getDerivedStateFromError(error)`:\n    - This static method is called after an error has been thrown by a descendant component.\n    - It receives the `error` that was thrown.\n    - It should return an object to update state (e.g., `{ hasError: true }`) which will then trigger a re-render of the boundary component with the fallback UI.\n    - Its primary purpose is to render a fallback UI after an error.\n\n2.  `componentDidCatch(error, info)`:\n    - This method is called after an error has been thrown by a descendant component.\n    - It receives two arguments: `error` (the error object) and `info` (an object with a `componentStack` property containing the component stack trace).\n    - It's primarily used for side effects, such as logging the error to an error reporting service (e.g., Sentry, Bugsnag).\n\n## What Errors Do Error Boundaries Catch?\nError boundaries catch errors that occur during:\n-   Rendering (`render` method)\n-   Lifecycle methods (e.g., `componentDidMount`, `componentDidUpdate`)\n-   Constructors of the whole tree below them.\n\n## What Errors Do Error Boundaries NOT Catch?\nError boundaries **do not** catch errors for:\n-   **Event handlers**: Errors inside event handlers (e.g., `onClick`, `onChange`) do not break the entire application and can be caught with regular `try...catch` blocks within the handler itself.\n-   **Asynchronous code**: Errors inside `setTimeout` or `requestAnimationFrame` callbacks, or in `Promise` callbacks (e.g., `fetch` or `axios` requests).\n-   **Server-side rendering**: Errors that occur during server-side rendering.\n-   **Errors thrown in the error boundary itself**: An error boundary cannot catch errors within itself. If the error boundary's `render` method or lifecycle methods throw an error, React will unmount the entire component tree. This is why the fallback UI should be very simple and error-free.\n\n## Placement of Error Boundaries\nYou can place error boundaries anywhere in your component tree. They are most effective when placed around logical blocks of components, allowing you to show specific fallback UIs for different parts of your application.",
          "examples": [
            {
              "id": "example_error_boundary_1",
              "title": "Basic Error Boundary Implementation",
              "code": "import React from 'react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state to display fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // Log the error to an error reporting service\n    console.error(\"Error caught by boundary:\", error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\n// Example usage:\nfunction BuggyCounter() {\n  const [count, setCount] = React.useState(0);\n  const handleClick = () => setCount(count + 1);\n\n  if (count === 5) {\n    // Simulate an error when count reaches 5\n    throw new Error('I crashed!');\n  }\n\n  return <h1 onClick={handleClick}>{count}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <h2>Click the numbers to increment. Click the number that will crash.</h2>\n      <ErrorBoundary>\n        <p>This is a buggy counter:</p>\n        <BuggyCounter />\n      </ErrorBoundary>\n      <p>This is another counter, unaffected by the first:</p>\n      <BuggyCounter />\n    </div>\n  );\n}",
              "explanation": "This example demonstrates a typical Error Boundary component. When `BuggyCounter`'s `count` reaches 5, it throws an error. The `ErrorBoundary` catches this error, updates its state via `getDerivedStateFromError` to `hasError: true`, and then renders its fallback UI ('Something went wrong.'). `componentDidCatch` logs the error for debugging. Notice how the second `BuggyCounter` remains unaffected because it's not wrapped by the crashing boundary, illustrating localized error handling.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_error_boundary_1",
            "question_error_boundary_2",
            "question_error_boundary_3",
            "question_error_boundary_4",
            "question_error_boundary_5",
            "question_error_boundary_6"
          ],
          "relatedTasks": [
            "task_error_boundary_1"
          ],
          "tags": [
            "React",
            "Error Handling",
            "Error Boundaries",
            "Component Lifecycle",
            "Debugging"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Robust_Applications",
            "Production_Ready_Apps"
          ]
        },
        {
          "id": "theory_react_router",
          "title": "React Router: v5 vs v6",
          "content": "React Router is the de-facto standard library for declarative routing in React applications. It enables single-page applications to have multiple views or 'pages' without requiring a full page reload from the server. It keeps the UI in sync with the URL.\n\n## React Router v6 (Latest)\nReact Router v6 was a significant rewrite focusing on smaller bundle sizes, hooks-based API, and improved performance. It introduces a more declarative and nested approach to routing.\n\n### Key Components in v6\n-   `<BrowserRouter>`: Uses the HTML5 history API (`pushState`, `replaceState`, `popstate`) to keep your UI in sync with the URL.\n-   `<Routes>`: Replaces `Switch` from v5. It is a container for all `<Route>` elements. It selects the best match among its children.\n-   `<Route>`: Declares a route. It takes a `path` prop and an `element` prop which renders the component for that route.\n-   `useRoutes`: A hook-based alternative to `<Routes>` that allows you to define routes as JavaScript objects.\n-   `useNavigate`, `useParams`, `useLocation`, `useMatch`: New hooks for programmatically navigating, accessing URL parameters, current location, and route matching information.\n\n```typescript\n// Basic routing setup in React Router v6\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nfunction Home() { return <h2>Home Page</h2>; }\nfunction About() { return <h2>About Us</h2>; }\nfunction Users() { return <h2>Users Section</h2>; }\nfunction UserDetails() { return <h3>User Details Page</h3>; }\nfunction NoMatch() { return <h2>404 - Page Not Found</h2>; }\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"about\" element={<About />} />\n        <Route path=\"users\" element={<Users />}> {/* Parent route */}\n          <Route path=\":userId\" element={<UserDetails />} /> {/* Nested route */}\n        </Route>\n        <Route path=\"*\" element={<NoMatch />} /> {/* 404 route */}\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n## React Router v5\nReact Router v5 was widely used and provided robust routing capabilities. While still functional, it's considered legacy for new projects.\n\n### Key Components in v5\n-   `<BrowserRouter>` (or `<Router>` as alias): Similar to v6.\n-   `<Switch>`: Ensures that only the *first* matching `<Route>` is rendered. If multiple routes match, only the first one defined will be rendered.\n-   `<Route>`: Declares a route. It takes a `path` prop and a `component` prop (or `render` or `children`) which renders the component for that route.\n-   `exact` prop: Used on `<Route>` to ensure the path matches the URL exactly.\n\n```typescript\n// Basic routing setup in React Router v5\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nfunction Home() { return <h2>Home Page</h2>; }\nfunction About() { return <h2>About Us</h2>; }\nfunction UserDetails() { return <h3>User Details Page</h3>; }\nfunction NoMatch() { return <h2>404 - Page Not Found</h2>; }\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\" component={Home}/>\n        <Route path=\"/about\" component={About}/>\n        <Route path=\"/users/:userId\" component={UserDetails}/>\n        <Route path=\"*\" component={NoMatch}/> {/* 404 route */}\n      </Switch>\n    </Router>\n  );\n}\n```\n\n## Key Differences between v5 and v6\n\n1.  **`Switch` renamed to `Routes`**\n    -   **v5**: Uses `<Switch>` to render the *first* child `<Route>` or `<Redirect>` that matches the location.\n    -   **v6**: Uses `<Routes>`. It's an improved version that is more intelligent about matching routes, ranking them by specificity and choosing the best match rather than just the first one. It also enables nested routing more intuitively.\n\n2.  **`component={Component}` changed to `element={<Component />}`**\n    -   **v5**: `component={MyComponent}` was used to render a component. This would implicitly create a new component instance with route props (`history`, `location`, `match`).\n    -   **v6**: `element={<MyComponent />}` is used. This allows you to pass props directly to the component, making it more explicit and flexible. It's a standard React element, which aligns with how React typically renders components and helps with optimizations.\n\n3.  **Nested routes are declared more naturally**\n    -   **v5**: Nested routes often required props drilling or complex rendering logic (`render` prop) within the parent component to render child routes.\n    -   **v6**: Nested routes are declared directly as children of their parent `<Route>` in the `Routes` component. The parent route specifies a partial path, and child routes append to it. A parent route rendering its children uses an `<Outlet>` component (not shown in basic example, but essential for nested layouts).\n\n4.  **`exact` prop is no longer needed**\n    -   **v5**: The `exact` prop was crucial to prevent partial matches, ensuring that `/` didn't also match `/about`.\n    -   **v6**: The `exact` prop is deprecated. Routes are now matched by their specificity (ranking algorithm) by default, meaning `/` will only match exactly `/`, and `/about` will match `/about` but not `/`. This makes routing more intuitive and less error-prone.\n\n5.  **Route path patterns are more robust and flexible**\n    -   **v6**: Supports more advanced pattern matching capabilities, including optional segments (`/users/:userId?`), wildcard segments (`/*`), and more dynamic segment definitions. This allows for more expressive and concise routing logic.\n\n6.  **Relative routes and links**\n    -   **v6**: Introduces relative paths for `Route` and `Link` components. This means you can specify paths relative to the current URL, making it easier to build modular applications, especially with nested routing. For example, a `Link to=\"details\"` within a `/users` route will navigate to `/users/details`.\n\n7.  **Hooks-based API**: v6 heavily relies on hooks (`useNavigate`, `useParams`, `useLocation`, `useMatch`) for programmatic navigation and accessing route information, making it more functional and aligned with modern React practices.",
          "examples": [
            {
              "id": "example_react_router_v6_nested",
              "title": "React Router v6 Nested Routing with Outlet",
              "code": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link, Outlet, useParams, useNavigate } from 'react-router-dom';\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h2>Dashboard</h2>\n      <nav>\n        <Link to=\"./profile\">Profile</Link> |\n        <Link to=\"./settings\">Settings</Link>\n      </nav>\n      <Outlet /> {/* Renders child routes here */}\n    </div>\n  );\n}\n\nfunction Profile() { return <h3>Profile Page</h3>; }\nfunction Settings() { return <h3>Settings Page</h3>; }\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <h1>App Header</h1>\n      <nav>\n        <Link to=\"/\">Home</Link> | <Link to=\"/dashboard\">Dashboard</Link>\n      </nav>\n      <Routes>\n        <Route path=\"/\" element={<h2>Welcome Home!</h2>} />\n        <Route path=\"/dashboard\" element={<Dashboard />}>\n          <Route path=\"profile\" element={<Profile />} />\n          <Route path=\"settings\" element={<Settings />} />\n          <Route index element={<h4>Select an option</h4>} /> {/* Default child route */}\n        </Route>\n        <Route path=\"*\" element={<h2>404 - Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n}",
              "explanation": "This example showcases React Router v6's powerful nested routing. The `Dashboard` component contains an `<Outlet />`, which acts as a placeholder for its child routes (`Profile`, `Settings`, and a default `index` route). Links within `Dashboard` use relative paths (`./profile`), simplifying navigation within a nested context.",
              "language": "typescript"
            },
            {
              "id": "example_react_router_v6_hooks",
              "title": "React Router v6 Hooks Usage",
              "code": "import React from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\n\nfunction UserProfile() {\n  const { userId } = useParams();\n  const navigate = useNavigate();\n\n  const goToHome = () => {\n    navigate('/');\n  };\n\n  return (\n    <div>\n      <h2>User Profile for ID: {userId}</h2>\n      <button onClick={goToHome}>Go to Home</button>\n    </div>\n  );\n}\n\n// (Assume BrowserRouter and Routes are set up higher in the component tree)\n// <Route path=\"/users/:userId\" element={<UserProfile />} />",
              "explanation": "This example demonstrates two key React Router v6 hooks: `useParams` to extract dynamic segments from the URL (like `userId` from `/users/123`), and `useNavigate` for programmatic navigation (e.g., navigating to the home page on button click). These hooks provide a modern, functional way to interact with the router.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_router_1",
            "question_react_router_2",
            "question_react_router_3",
            "question_react_router_4",
            "question_react_router_5",
            "question_react_router_6",
            "question_react_router_7",
            "question_react_router_8"
          ],
          "relatedTasks": [
            "task_react_router_1"
          ],
          "tags": [
            "React",
            "React Router",
            "Routing",
            "Frontend",
            "SPA",
            "Navigation"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components",
            "JavaScript_ES6"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex_SPAs",
            "Fullstack_Applications"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_strict_mode_1",
          "topic": "React StrictMode",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of React's StrictMode?",
          "answer": "To help identify potential problems and side effects in a React application during development.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "StrictMode",
            "Development Mode"
          ],
          "evaluationCriteria": [
            "Basic understanding of StrictMode's goal"
          ],
          "example": "",
          "tags": [
            "React",
            "StrictMode",
            "Development"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_strict_mode_2",
          "topic": "React StrictMode",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about React.StrictMode is TRUE?",
          "answer": "It is only active in development mode and does not affect the production build.",
          "options": [
            "It is only active in development mode and does not affect the production build.",
            "It adds extra runtime overhead to production builds for better debugging.",
            "It prevents all side effects from occurring in your React application.",
            "It enables concurrent rendering features automatically in production."
          ],
          "analysisPoints": [
            "StrictMode is a development-only tool.",
            "It helps *identify* side effects, not *prevent* all of them.",
            "It *prepares* for concurrent rendering but doesn't enable it automatically in production.",
            "No production overhead."
          ],
          "keyConcepts": [
            "StrictMode",
            "Development vs Production",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Understanding of StrictMode's operational scope.",
            "Distinguishing development from production features."
          ],
          "example": "StrictMode is designed to be a developer aid, running checks that might be too expensive for a production environment, ensuring that your final build remains performant.",
          "tags": [
            "React",
            "StrictMode",
            "Development",
            "Production"
          ],
          "prerequisites": [
            "React_Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strict_mode_3",
          "topic": "React StrictMode",
          "level": "medium",
          "type": "open",
          "question": "Explain how StrictMode helps detect unexpected side effects, particularly mentioning the 'double-invocation' mechanism. Provide a small code snippet where this behavior would be noticeable.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Mentioning double-invocation of render, useState/useReducer updaters, useEffect setup/cleanup.",
            "Explaining that pure functions should yield the same result on double invocation, while side effects become apparent.",
            "Providing a relevant code example that shows a console log or state mutation issue."
          ],
          "keyConcepts": [
            "StrictMode",
            "Side Effects",
            "Double Invocation",
            "Pure Functions"
          ],
          "evaluationCriteria": [
            "Clarity of explanation on double-invocation.",
            "Ability to connect double-invocation to side effect detection.",
            "Correctness and relevance of the code snippet."
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction ComponentWithSideEffect() {\n  const [value, setValue] = useState(0);\n\n  // This effect runs twice in StrictMode on mount\n  useEffect(() => {\n    console.log('Effect mounted/updated:', value);\n    // Simulating a side effect that would be noticeable if run twice unintentionally\n    // For instance, if you were appending to a global array here without cleanup.\n    return () => {\n      console.log('Effect cleanup:', value);\n    };\n  }, [value]);\n\n  return (\n    <div>\n      <p>Value: {value}</p>\n      <button onClick={() => setValue(value + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <ComponentWithSideEffect />\n    </React.StrictMode>\n  );\n}\n\nexport default App;\n```\n\n**Explanation:**\nIn StrictMode, `useEffect`'s setup and cleanup functions are run an additional time during development. When `ComponentWithSideEffect` mounts, you'd typically expect 'Effect mounted/updated: 0' once. However, in StrictMode, you'll see 'Effect setup run: 0', then 'Effect cleanup run: 0', and then 'Effect setup run: 0' again. This highlights that your effects should be robust enough to handle being cleaned up and re-set up immediately, encouraging idempotent effects and proper cleanup, which is crucial for features like Fast Refresh and future concurrent rendering.",
          "tags": [
            "React",
            "StrictMode",
            "Side Effects",
            "Debugging",
            "Hooks"
          ],
          "prerequisites": [
            "React_Hooks",
            "Component_Lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strict_mode_4",
          "topic": "React StrictMode",
          "level": "easy",
          "type": "flashcard",
          "question": "Does StrictMode enhance performance in production applications?",
          "answer": "No, StrictMode is a development-only tool and has no impact on production performance or bundle size.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "StrictMode",
            "Production Performance"
          ],
          "evaluationCriteria": [
            "Understanding StrictMode's scope"
          ],
          "example": "",
          "tags": [
            "React",
            "StrictMode",
            "Performance"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_strict_mode_5",
          "topic": "React StrictMode",
          "level": "medium",
          "type": "code",
          "question": "Consider the following component. Explain what logs you would see in the console when this component mounts inside `React.StrictMode` and when the button is clicked once. What if `StrictMode` was not used?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the double invocation of `useEffect` setup and cleanup on mount in StrictMode.",
            "Correctly identifies the single invocation of `useEffect` setup and cleanup on update in StrictMode.",
            "Correctly identifies the single invocation of `useEffect` setup and cleanup on mount and update without StrictMode.",
            "Explains the purpose behind StrictMode's behavior.",
            "Predicts exact console output order."
          ],
          "keyConcepts": [
            "StrictMode",
            "useEffect",
            "Component Lifecycle",
            "Side Effects",
            "Double Invocation"
          ],
          "evaluationCriteria": [
            "Ability to trace execution flow with StrictMode.",
            "Understanding of `useEffect` lifecycle.",
            "Comparison of behavior with and without StrictMode."
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction LoggerComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log(`Effect: Setup for count ${count}`);\n    return () => {\n      console.log(`Effect: Cleanup for count ${count}`);\n    };\n  }, [count]);\n\n  console.log(`Render: count ${count}`);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// Assume App wraps LoggerComponent with React.StrictMode or not\n// For example: \n// ReactDOM.createRoot(...).render(<React.StrictMode><LoggerComponent /></React.StrictMode>);\n```\n\n**Expected Console Output:**\n\n**1. With `React.StrictMode` (on initial mount):**\n```\nRender: count 0\nRender: count 0\nEffect: Setup for count 0\nEffect: Cleanup for count 0\nEffect: Setup for count 0\n```\n**Explanation:**\n- `Render: count 0` appears twice because StrictMode double-invokes the render function to check for side effects.\n- `Effect: Setup for count 0` runs once for the initial mount.\n- `Effect: Cleanup for count 0` runs immediately after the first setup, simulating a remount.\n- `Effect: Setup for count 0` runs again for the 'actual' mount, ensuring the effect is resilient to double-execution and cleanup.\n\n**2. With `React.StrictMode` (after clicking increment button once, `count` becomes 1):**\n```\nRender: count 1\nRender: count 1\nEffect: Cleanup for count 0\nEffect: Setup for count 1\nEffect: Cleanup for count 1\nEffect: Setup for count 1\n```\n**Explanation:**\n- `Render: count 1` appears twice as the component re-renders and StrictMode checks for side effects.\n- `Effect: Cleanup for count 0` runs because the `count` dependency changed from 0 to 1, triggering cleanup for the previous `count` value.\n- `Effect: Setup for count 1` runs for the new `count` value (1).\n- Similar to mount, cleanup and setup run again to simulate re-execution (`Effect: Cleanup for count 1` then `Effect: Setup for count 1`).\n\n**3. Without `React.StrictMode` (on initial mount):**\n```\nRender: count 0\nEffect: Setup for count 0\n```\n**Explanation:**\n- `Render: count 0` appears once.\n- `Effect: Setup for count 0` runs once for the initial mount.\n\n**4. Without `React.StrictMode` (after clicking increment button once, `count` becomes 1):**\n```\nRender: count 1\nEffect: Cleanup for count 0\nEffect: Setup for count 1\n```\n**Explanation:**\n- `Render: count 1` appears once.\n- `Effect: Cleanup for count 0` runs when `count` changes from 0 to 1.\n- `Effect: Setup for count 1` runs for the new `count` value.\n",
          "tags": [
            "React",
            "StrictMode",
            "useEffect",
            "Debugging",
            "Side Effects"
          ],
          "prerequisites": [
            "React_Hooks_useEffect",
            "React_Component_Lifecycle"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_error_boundary_1",
          "topic": "React Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary function of a React Error Boundary?",
          "answer": "To catch JavaScript errors in its child component tree, log them, and display a fallback UI instead of crashing the entire application.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Error Boundary",
            "Error Handling",
            "Fallback UI"
          ],
          "evaluationCriteria": [
            "Basic definition of Error Boundary"
          ],
          "example": "",
          "tags": [
            "React",
            "Error Handling",
            "Error Boundaries"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_2",
          "topic": "React Error Boundaries",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following lifecycle methods are essential for creating a React Error Boundary?",
          "answer": "static getDerivedStateFromError and componentDidCatch",
          "options": [
            "componentDidMount and componentWillUnmount",
            "render and componentDidUpdate",
            "static getDerivedStateFromError and componentDidCatch",
            "constructor and shouldComponentUpdate"
          ],
          "analysisPoints": [
            "`getDerivedStateFromError` is for updating state for fallback UI.",
            "`componentDidCatch` is for logging errors and side effects.",
            "Other options are standard lifecycle methods but not specific to error boundaries."
          ],
          "keyConcepts": [
            "Error Boundary",
            "Lifecycle Methods",
            "getDerivedStateFromError",
            "componentDidCatch"
          ],
          "evaluationCriteria": [
            "Knowledge of Error Boundary specific lifecycle methods.",
            "Distinguishing relevant from irrelevant lifecycle methods for this purpose."
          ],
          "example": "The `static getDerivedStateFromError` method is responsible for returning a new state object that will trigger a re-render of the error boundary with its fallback UI. The `componentDidCatch` method is used for side effects, such as sending error reports to an analytics service.",
          "tags": [
            "React",
            "Error Boundaries",
            "Lifecycle Methods"
          ],
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_3",
          "topic": "React Error Boundaries",
          "level": "medium",
          "type": "open",
          "question": "Describe the distinct roles of `static getDerivedStateFromError(error)` and `componentDidCatch(error, info)` within an error boundary. When would you use each?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explain `getDerivedStateFromError`'s role: to update state to trigger re-render of fallback UI, it's static and returns state object.",
            "Explain `componentDidCatch`'s role: for side effects like logging errors to external services, it receives `error` and `info`.",
            "Provide clear use cases for each method."
          ],
          "keyConcepts": [
            "Error Boundary",
            "getDerivedStateFromError",
            "componentDidCatch",
            "State Update",
            "Side Effects",
            "Error Logging"
          ],
          "evaluationCriteria": [
            "Accurate distinction between the two methods' purposes.",
            "Correct understanding of their parameters and return values (for `getDerivedStateFromError`).",
            "Practical use case examples."
          ],
          "example": "The `static getDerivedStateFromError(error)` method is a static lifecycle method called after an error is thrown. Its sole purpose is to return a state update object (`{ hasError: true }`) that will be used to re-render the Error Boundary's UI, typically displaying a fallback message. It should be a pure function and should not cause side effects.\n\nConversely, `componentDidCatch(error, info)` is a non-static lifecycle method that is called after an error has been thrown and allows for side effects. It's the ideal place to log error information to an external service (e.g., Sentry, Bugsnag) using `console.error` or an API call. It receives the `error` object and an `info` object containing the `componentStack`, which is useful for debugging.\n\nIn summary, `getDerivedStateFromError` is for **rendering fallback UI**, while `componentDidCatch` is for **logging errors and other side effects**.",
          "tags": [
            "React",
            "Error Boundaries",
            "Lifecycle Methods"
          ],
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_4",
          "topic": "React Error Boundaries",
          "level": "hard",
          "type": "mcq",
          "question": "Which of the following scenarios is **NOT** typically caught by a React Error Boundary?",
          "answer": "An error thrown inside an event handler (e.g., `onClick`).",
          "options": [
            "An error thrown during a component's render method.",
            "An error thrown inside `componentDidMount`.",
            "An error thrown inside `static getDerivedStateFromError`.",
            "An error thrown inside an event handler (e.g., `onClick`)."
          ],
          "analysisPoints": [
            "Error Boundaries specifically catch errors in render, lifecycle methods, and constructors of child components.",
            "They do not catch errors in event handlers because event handlers are not part of the rendering pipeline. These errors bubble up through the browser's event system.",
            "Errors in `static getDerivedStateFromError` would mean the boundary itself failed, which it cannot catch."
          ],
          "keyConcepts": [
            "Error Boundary Limitations",
            "Error Handling Scope",
            "Event Handlers"
          ],
          "evaluationCriteria": [
            "In-depth understanding of what error boundaries cover and what they don't.",
            "Ability to differentiate error types and their handling mechanisms."
          ],
          "example": "React Error Boundaries are designed to protect the rendering process. Errors in event handlers do not fall under this category as they are synchronous calls outside of React's rendering phase. Such errors can and should be caught using standard JavaScript `try...catch` blocks within the event handler function itself if specific error handling is needed for that interaction.",
          "tags": [
            "React",
            "Error Boundaries",
            "Limitations",
            "Event Handling"
          ],
          "prerequisites": [
            "React_Error_Handling",
            "JavaScript_Error_Handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_error_boundary_5",
          "topic": "React Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "Can a functional component be an Error Boundary?",
          "answer": "No, Error Boundaries must be class components because they need to implement lifecycle methods like `static getDerivedStateFromError` or `componentDidCatch`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Error Boundary",
            "Class Components",
            "Functional Components",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Basic knowledge of Error Boundary requirements"
          ],
          "example": "",
          "tags": [
            "React",
            "Error Boundaries",
            "Functional Components",
            "Class Components"
          ],
          "prerequisites": [
            "React_Components"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_6",
          "topic": "React Error Boundaries",
          "level": "medium",
          "type": "code",
          "question": "Given the `BuggyComponent` below, write an `App` component that uses an `ErrorBoundary` (provided) to prevent the entire application from crashing when `BuggyComponent` throws an error. Demonstrate what happens when the error is thrown.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly wraps `BuggyComponent` with `ErrorBoundary`.",
            "Demonstrates the effect of the error boundary catching the error.",
            "Shows how other parts of the application remain functional.",
            "The provided `ErrorBoundary` class is correctly utilized."
          ],
          "keyConcepts": [
            "Error Boundary Usage",
            "Fallback UI",
            "Component Isolation"
          ],
          "evaluationCriteria": [
            "Ability to apply Error Boundary correctly.",
            "Understanding of localized error handling.",
            "Functional code example."
          ],
          "example": "```typescript\nimport React from 'react';\n\n// Assume ErrorBoundary is provided like so:\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(\"Error caught by boundary:\", error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Oops! Something went wrong in this section.</h1>;\n    }\n    return this.props.children;\n  }\n}\n\n// Component that might throw an error\nfunction BuggyComponent({ throwError }) {\n  if (throwError) {\n    throw new Error('This component crashed!');\n  }\n  return <p>I am a stable component.</p>;\n}\n\n// Your task is to complete the App component:\nfunction App() {\n  const [shouldCrash, setShouldCrash] = React.useState(false);\n\n  return (\n    <div>\n      <h1>Application Header</h1>\n      <button onClick={() => setShouldCrash(true)}>\n        Trigger Crash in Buggy Section\n      </button>\n      <hr />\n\n      <ErrorBoundary>\n        {/* This is the section where the error will be caught */}\n        <h2>Buggy Section:</h2>\n        <BuggyComponent throwError={shouldCrash} />\n      </ErrorBoundary>\n\n      <hr />\n      <h2>Normal Section:</h2>\n      <p>This part of the application remains functional.</p>\n      <button onClick={() => console.log('Normal section button clicked')}>\n        Click Me\n      </button>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n**Explanation:**\nWhen the 'Trigger Crash in Buggy Section' button is clicked, `shouldCrash` becomes true, causing `BuggyComponent` to throw an error during its render. The `ErrorBoundary` component, which wraps `BuggyComponent`, catches this error. Instead of crashing the entire application, the `ErrorBoundary` displays its fallback UI ('Oops! Something went wrong in this section.'). The 'Normal Section' of the application remains fully interactive and functional, demonstrating the isolation provided by error boundaries.",
          "tags": [
            "React",
            "Error Boundaries",
            "Debugging",
            "Error Handling"
          ],
          "prerequisites": [
            "React_Class_Components",
            "React_State_Hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_1",
          "topic": "React Router v5 vs v6",
          "level": "easy",
          "type": "flashcard",
          "question": "In React Router v6, which component replaces `Switch` from v5?",
          "answer": "`Routes`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router",
            "Routes",
            "Switch"
          ],
          "evaluationCriteria": [
            "Basic knowledge of React Router version differences"
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "v5",
            "Routing"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_router_2",
          "topic": "React Router v5 vs v6",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the correct way to render a component for a route in React Router v6?",
          "answer": "`<Route path=\"/home\" element={<HomePage />} />`",
          "options": [
            "`<Route path=\"/home\" component={HomePage} />`",
            "`<Route path=\"/home\" render={HomePage} />`",
            "`<Route path=\"/home\" element={HomePage} />`",
            "`<Route path=\"/home\" element={<HomePage />} />`"
          ],
          "analysisPoints": [
            "v6 uses `element` prop.",
            "The `element` prop expects a React element (JSX), not just a component reference.",
            "Options A and B are from v5.",
            "Option C passes the component reference, not a React element."
          ],
          "keyConcepts": [
            "React Router v6",
            "Route Props",
            "element prop"
          ],
          "evaluationCriteria": [
            "Understanding of v6 API changes.",
            "Correct syntax for rendering components in routes."
          ],
          "example": "In React Router v6, the `element` prop is used to pass a React element (JSX) to be rendered when the route matches. This allows for passing props directly to the component, unlike the `component` prop in v5 which implicitly received routing props.",
          "tags": [
            "React Router",
            "v6",
            "Routing Syntax"
          ],
          "prerequisites": [
            "React_Basics",
            "React_Router_Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_3",
          "topic": "React Router v5 vs v6",
          "level": "medium",
          "type": "open",
          "question": "Explain why the `exact` prop is no longer needed in React Router v6, and how v6 handles route matching differently from v5's `Switch` component.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explain that v5's `exact` prop was needed to prevent partial matches with `Switch`.",
            "Describe v6's `Routes` component's matching algorithm (specificity, ranking, best match).",
            "Contrast v5's 'first match wins' with v6's 'best match wins'.",
            "Mention how v6 handles `/` path differently (only matches exactly `/`)."
          ],
          "keyConcepts": [
            "React Router v6",
            "exact prop",
            "Routes vs Switch",
            "Route Matching",
            "Specificity"
          ],
          "evaluationCriteria": [
            "Clear explanation of `exact` deprecation.",
            "Accurate description of v6's route matching logic.",
            "Effective comparison between v5 and v6 approaches."
          ],
          "example": "In React Router v5, the `<Switch>` component would render the *first* `<Route>` that partially or exactly matched the current URL. This made the `exact` prop crucial for paths like `/` to prevent them from also matching `/about` or `/users`. Without `exact`, `/` would always match first, blocking other routes.\n\nReact Router v6 replaces `<Switch>` with `<Routes>`. The `Routes` component uses a smarter, more sophisticated ranking algorithm to determine the *best* match among its children, regardless of their order. It prioritizes more specific routes over less specific ones. For example, a route for `/users/:id` is considered more specific than `/users`. As a result, the `exact` prop becomes redundant because v6 inherently handles precise matching based on path specificity, making the routing configuration more intuitive and less prone to unexpected matches.",
          "tags": [
            "React Router",
            "v6",
            "Route Matching",
            "exact prop"
          ],
          "prerequisites": [
            "React_Router_Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_4",
          "topic": "React Router v6",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the purpose of the `<Outlet />` component in React Router v6?",
          "answer": "The `<Outlet />` component is used within a parent route's element to render the matched child route's element, enabling nested layouts and routing.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router v6",
            "Outlet",
            "Nested Routing",
            "Layouts"
          ],
          "evaluationCriteria": [
            "Understanding of nested routing mechanics"
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "Nested Routing"
          ],
          "prerequisites": [
            "React_Router_v6_Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_5",
          "topic": "React Router v6",
          "level": "medium",
          "type": "code",
          "question": "You have a component rendered at `/dashboard`. You want to navigate to `/dashboard/settings` programmatically when a button is clicked. How would you achieve this using a React Router v6 hook? Provide a code snippet.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly identifies and uses the `useNavigate` hook.",
            "Demonstrates programmatic navigation.",
            "Uses a relative path for navigation to `settings` from `dashboard`.",
            "Includes a button click handler for triggering navigation."
          ],
          "keyConcepts": [
            "React Router v6",
            "useNavigate Hook",
            "Programmatic Navigation",
            "Relative Paths"
          ],
          "evaluationCriteria": [
            "Correct application of `useNavigate`.",
            "Understanding of relative path navigation.",
            "Functional code example."
          ],
          "example": "```typescript\nimport React from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nfunction DashboardSettingsButton() {\n  const navigate = useNavigate();\n\n  const goToSettings = () => {\n    // Using a relative path 'settings' from the current route (/dashboard)\n    // This will navigate to /dashboard/settings\n    navigate('settings'); \n  };\n\n  return (\n    <div>\n      <h3>Dashboard Content</h3>\n      <button onClick={goToSettings}>Go to Settings</button>\n    </div>\n  );\n}\n\n// Example of how this might be used in a route setup:\n// <Route path=\"/dashboard\" element={<DashboardLayout />}> \n//   <Route index element={<DashboardHome />} />\n//   <Route path=\"settings\" element={<DashboardSettingsButton />} />\n// </Route>\n```\n**Explanation:**\nThe `useNavigate` hook provides a function (`navigate`) that allows you to change the current URL programmatically. When called with a string, it will push a new entry onto the history stack. In this example, `navigate('settings')` is a relative path. If the current URL is `/dashboard`, it will navigate to `/dashboard/settings`. This is particularly useful for building flexible and maintainable nested navigation within your application.",
          "tags": [
            "React Router",
            "v6",
            "Hooks",
            "Navigation",
            "Programmatic"
          ],
          "prerequisites": [
            "React_Hooks",
            "React_Router_Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_6",
          "topic": "React Router v6",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is **NOT** a new feature or significant change introduced in React Router v6 compared to v5?",
          "answer": "The primary routing mechanism using HTML5 History API (`BrowserRouter`).",
          "options": [
            "The primary routing mechanism using HTML5 History API (`BrowserRouter`).",
            "Introduction of `useRoutes` hook for defining routes as objects.",
            "Relative routes and links are supported by default.",
            "Route path patterns are more robust and flexible, supporting optional segments."
          ],
          "analysisPoints": [
            "`BrowserRouter` (using HTML5 History API) has been a core mechanism in both v5 and v6, so it's not a *new* feature of v6.",
            "`useRoutes`, relative paths, and enhanced path patterns are distinct new features/changes in v6."
          ],
          "keyConcepts": [
            "React Router v6",
            "React Router v5",
            "New Features",
            "BrowserRouter"
          ],
          "evaluationCriteria": [
            "Ability to distinguish core, long-standing features from new version-specific features.",
            "Comprehensive knowledge of v6 advancements."
          ],
          "example": "While `BrowserRouter` is fundamental to React Router, its underlying mechanism using the HTML5 History API has been consistent across major versions. The other options represent significant advancements and new API paradigms that differentiate v6 from v5, making routing more declarative, flexible, and hooks-friendly.",
          "tags": [
            "React Router",
            "v6",
            "Differences",
            "Features"
          ],
          "prerequisites": [
            "React_Router_Version_History"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_7",
          "topic": "React Router v6",
          "level": "hard",
          "type": "code",
          "question": "You are building a user profile section using React Router v6. Implement a setup where `'/users'` displays a list of users, and `'/users/:userId'` displays details for a specific user. The user details component should be nested within the users component using an `<Outlet />`. Also, create a link that navigates to `/users/123` from the user list. Assume `UserList` and `UserDetails` components exist.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly uses `<BrowserRouter>` and `<Routes>`.",
            "Sets up a parent route for `/users`.",
            "Defines a nested route `':userId'` within the parent `/users` route.",
            "Includes `<Outlet />` in the `UserList` component to render nested `UserDetails`.",
            "Uses `<Link>` to navigate to a specific user ID.",
            "Demonstrates understanding of nested routing in v6.",
            "Assumes valid functional components for UserList and UserDetails."
          ],
          "keyConcepts": [
            "React Router v6",
            "Nested Routing",
            "Outlet",
            "Path Params",
            "Link"
          ],
          "evaluationCriteria": [
            "Ability to construct a complex nested routing structure.",
            "Correct usage of `Outlet` and `Link`.",
            "Demonstrates practical application of v6 features."
          ],
          "example": "```typescript\nimport React from 'react';\nimport { BrowserRouter, Routes, Route, Link, Outlet, useParams } from 'react-router-dom';\n\nfunction UserList() {\n  // In a real app, you'd fetch users here\n  const users = [\n    { id: '101', name: 'Alice' },\n    { id: '102', name: 'Bob' },\n    { id: '103', name: 'Charlie' }\n  ];\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <Link to={user.id}>{user.name}</Link>\n          </li>\n        ))}\n      </ul>\n      <Link to=\"123\">Go to User 123 (Example Link)</Link>\n      <hr/>\n      {/* This is where the nested route content will be rendered */}\n      <Outlet /> \n    </div>\n  );\n}\n\nfunction UserDetails() {\n  const { userId } = useParams();\n  return (\n    <div>\n      <h3>Details for User ID: {userId}</h3>\n      <p>This is where details for user {userId} would be displayed.</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <h1>User Management App</h1>\n      <Routes>\n        <Route path=\"/\" element={<h2>Welcome!</h2>} />\n        <Route path=\"/users\" element={<UserList />}> {/* Parent route */}\n          {/* Nested route: matches /users/:userId */}\n          <Route path=\":userId\" element={<UserDetails />} /> \n          {/* Optional: Default content for /users if no child route matches */}\n          <Route index element={<h4>Select a user to view details.</h4>} />\n        </Route>\n        <Route path=\"*\" element={<h2>404 - Page Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n```\n\n**Explanation:**\n- `BrowserRouter` sets up the history API for routing.\n- The first `Route` is for the home page.\n- The `'/users'` `Route` renders `UserList`. Critically, it has a child `Route` with `path=\":userId\"`.\n- `UserList` component contains an `<Outlet />`. When the URL matches `/users/101`, `UserList` renders, and then `UserDetails` (for `userId=101`) is rendered *inside* the `UserList` component at the position of the `<Outlet />`.\n- The `Link to={user.id}` within `UserList` uses a relative path, seamlessly navigating to `/users/101`, `/users/102`, etc., making the nesting intuitive. The example link `to=\"123\"` demonstrates navigating to a hardcoded user ID.\n",
          "tags": [
            "React Router",
            "v6",
            "Nested Routing",
            "Hooks",
            "SPA",
            "Advanced Routing"
          ],
          "prerequisites": [
            "React_Components",
            "React_Hooks_Basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_router_8",
          "topic": "React Router v6",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React Router v6 hook would you use to get URL parameters like `:id` from a route path `/users/:id`?",
          "answer": "`useParams()`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router v6",
            "useParams",
            "URL Parameters"
          ],
          "evaluationCriteria": [
            "Knowledge of common React Router hooks"
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "Hooks"
          ],
          "prerequisites": [
            "React_Hooks_Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_strict_mode_1",
          "title": "Demonstrate StrictMode Side Effect Detection",
          "description": "\nImplement a React functional component `MyCounter` that uses `useState` and `useEffect`.\n\n**Requirements:**\n1.  The component should have a counter state that increments on a button click.\n2.  Inside a `useEffect` that runs on mount and whenever the counter changes, log a message to the console. Make sure this effect has a cleanup function that also logs a message.\n3.  Wrap `MyCounter` in `React.StrictMode` in your `App` component.\n4.  Observe the console logs when the `App` mounts and when the increment button is clicked. Explain the difference in console output with and without `StrictMode`.\n\nYour goal is to clearly show how `StrictMode`'s double-invocation affects the `useEffect` lifecycle.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction MyCounter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // TODO: Add setup log here\n    console.log(`Effect: Setup for count ${count}`);\n\n    return () => {\n      // TODO: Add cleanup log here\n      console.log(`Effect: Cleanup for count ${count}`);\n    };\n  }, [count]);\n\n  // TODO: Add render log here\n  console.log(`Render: count ${count}`);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    // TODO: Wrap MyCounter in StrictMode\n    <React.StrictMode>\n      <MyCounter />\n    </React.StrictMode>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction MyCounter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log(`Effect: Setup for count ${count}`);\n\n    return () => {\n      console.log(`Effect: Cleanup for count ${count}`);\n    };\n  }, [count]);\n\n  console.log(`Render: count ${count}`);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <MyCounter />\n    </React.StrictMode>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n\n/*\nExpected Console Output with StrictMode:\n\nOn initial mount:\nRender: count 0\nRender: count 0\nEffect: Setup for count 0\nEffect: Cleanup for count 0\nEffect: Setup for count 0\n\nAfter clicking Increment button once (count becomes 1):\nRender: count 1\nRender: count 1\nEffect: Cleanup for count 0\nEffect: Setup for count 1\nEffect: Cleanup for count 1\nEffect: Setup for count 1\n\nExpected Console Output without StrictMode (if you comment out <React.StrictMode>):\n\nOn initial mount:\nRender: count 0\nEffect: Setup for count 0\n\nAfter clicking Increment button once (count becomes 1):\nRender: count 1\nEffect: Cleanup for count 0\nEffect: Setup for count 1\n*/\n",
          "testCases": [
            "Verify `Render` message appears twice on initial mount in StrictMode.",
            "Verify `Effect: Setup` and `Effect: Cleanup` logs appear twice (setup, cleanup, setup) on initial mount in StrictMode.",
            "Verify `Render` message appears twice on state update in StrictMode.",
            "Verify `Effect: Cleanup` for old state and `Effect: Setup` for new state appear twice (cleanup_old, setup_new, cleanup_new, setup_new) on state update in StrictMode.",
            "Describe console output differences if `StrictMode` is removed."
          ],
          "hints": [
            "Remember that `StrictMode` specifically double-invokes render methods, `useState` updater functions, and `useEffect` setup/cleanup functions.",
            "Pay close attention to the order of logs, especially the cleanup and setup for `useEffect`.",
            "The logs will help you visualize the 'simulated remounting' behavior."
          ],
          "tags": [
            "React",
            "StrictMode",
            "Hooks",
            "Debugging",
            "Side Effects",
            "Development"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "React_Hooks_useState",
            "React_Hooks_useEffect"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Pure_Components",
            "Idempotent_Operations"
          ]
        },
        {
          "id": "task_error_boundary_1",
          "title": "Implement a Generic Error Boundary and Test It",
          "description": "\nImplement a reusable `ErrorBoundary` class component and demonstrate its usage by wrapping a 'buggy' child component that throws an error.\n\n**Requirements:**\n1.  Create a `ErrorBoundary` class component that implements `static getDerivedStateFromError` to update its state (`hasError`) and `componentDidCatch` to log the error to the console.\n2.  When `hasError` is `true`, the `ErrorBoundary` should render a simple fallback UI (e.g., `<h1>Something went wrong.</h1>`). Otherwise, it should render its children.\n3.  Create a functional component `CrashingComponent` that takes a `shouldCrash` prop. If `shouldCrash` is true, it should throw an error during its render phase.\n4.  In your `App` component, render `CrashingComponent` wrapped by `ErrorBoundary`.\n5.  Add a button in `App` that, when clicked, sets the `shouldCrash` prop to `true`, triggering the error.\n6.  Include another simple component (e.g., `NormalComponent`) *outside* the `ErrorBoundary` to demonstrate that the rest of the application remains functional.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\n\n// TODO: Implement ErrorBoundary class component\nclass ErrorBoundary extends React.Component {\n  // constructor\n  // static getDerivedStateFromError\n  // componentDidCatch\n  // render\n}\n\nfunction CrashingComponent({ shouldCrash }) {\n  if (shouldCrash) {\n    // TODO: Throw an error here\n    throw new Error('CrashingComponent failed!');\n  }\n  return <p>I am a stable component (for now).</p>;\n}\n\nfunction NormalComponent() {\n  return <p>I am a normal component, always working.</p>;\n}\n\nfunction App() {\n  const [triggerCrash, setTriggerCrash] = useState(false);\n\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <button onClick={() => setTriggerCrash(true)}>\n        Trigger Error in Crashing Component\n      </button>\n      <hr />\n\n      {/* TODO: Wrap CrashingComponent with ErrorBoundary */}\n      <div>\n        <h2>Wrapped Component:</h2>\n        <CrashingComponent shouldCrash={triggerCrash} />\n      </div>\n\n      <hr />\n      <h2>Unwrapped Component:</h2>\n      <NormalComponent />\n    </div>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state to display fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // Log the error to an error reporting service\n    console.error(\"Error caught by boundary:\", error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\nfunction CrashingComponent({ shouldCrash }) {\n  if (shouldCrash) {\n    throw new Error('CrashingComponent failed!');\n  }\n  return <p>I am a stable component (for now).</p>;\n}\n\nfunction NormalComponent() {\n  return <p>I am a normal component, always working.</p>;\n}\n\nfunction App() {\n  const [triggerCrash, setTriggerCrash] = useState(false);\n\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <button onClick={() => setTriggerCrash(true)}>\n        Trigger Error in Crashing Component\n      </button>\n      <hr />\n\n      <ErrorBoundary>\n        <h2>Wrapped Component:</h2>\n        <CrashingComponent shouldCrash={triggerCrash} />\n      </ErrorBoundary>\n\n      <hr />\n      <h2>Unwrapped Component:</h2>\n      <NormalComponent />\n    </div>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "testCases": [
            "Initial render: `CrashingComponent` should display its default message, `NormalComponent` should display its message.",
            "Clicking the 'Trigger Error' button: `CrashingComponent` should be replaced by `ErrorBoundary`'s fallback UI ('Something went wrong.').",
            "Clicking the 'Trigger Error' button: An error message should be logged to the console by `componentDidCatch`.",
            "Clicking the 'Trigger Error' button: `NormalComponent` should remain visible and functional, demonstrating isolation.",
            "Attempt to throw an error in `ErrorBoundary`'s render: Verify that the application crashes (as expected, error boundaries cannot catch errors within themselves)."
          ],
          "hints": [
            "Remember that `getDerivedStateFromError` is `static` and only returns state updates, while `componentDidCatch` is for side effects like logging.",
            "Errors thrown in event handlers are *not* caught by error boundaries. Ensure `CrashingComponent` throws the error during render for the boundary to catch it.",
            "Use `console.error` in `componentDidCatch` to see the error details in your browser's console."
          ],
          "tags": [
            "React",
            "Error Handling",
            "Error Boundaries",
            "Class Components",
            "Debugging"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_Class_Components",
            "React_State",
            "React_Lifecycle_Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Fallback_UI",
            "Component_Isolation"
          ]
        },
        {
          "id": "task_react_router_1",
          "title": "Build a Simple Blog with Nested React Router v6",
          "description": "\nCreate a multi-page application for a simple blog using React Router v6. It should include a home page, an 'about' page, a main blog posts list, and nested individual post detail pages.\n\n**Requirements:**\n1.  Set up `BrowserRouter` and `Routes` in your main `App` component.\n2.  Define the following routes:\n    -   `/`: Home Page (`HomePage` component)\n    -   `/about`: About Page (`AboutPage` component)\n    -   `/posts`: Blog Posts List (`PostsLayout` component which contains `<Outlet />`)\n    -   `/posts/:postId`: Individual Post Details (`PostDetails` component, nested under `/posts`)\n3.  Create simple functional components for `HomePage`, `AboutPage`, `PostsLayout`, and `PostDetails`.\n4.  `PostsLayout` should display a list of dummy blog posts (e.g., using `Link` components) and also contain an `<Outlet />` to render the `PostDetails` component.\n5.  `PostDetails` should use `useParams()` to display the `postId` from the URL.\n6.  Include a basic navigation menu at the top of the `App` component with `Link` components to Home, About, and Posts.\n7.  Add a 404 Not Found route (`*`) with a `NotFoundPage` component.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link, Outlet, useParams } from 'react-router-dom';\nimport ReactDOM from 'react-dom/client';\n\n// TODO: Create HomePage, AboutPage, PostsLayout, PostDetails, NotFoundPage components\n// Example structure:\nfunction HomePage() {\n  return <h2>Welcome to the Blog!</h2>;\n}\n\nfunction AboutPage() {\n  return <h2>About Us</h2>;\n}\n\nfunction PostsLayout() {\n  // Dummy posts data\n  const posts = [\n    { id: '1', title: 'First Blog Post' },\n    { id: '2', title: 'Second Blog Post' },\n  ];\n\n  return (\n    <div>\n      <h2>Blog Posts</h2>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>\n            {/* TODO: Add Link to individual post */}\n            <Link to={post.id}>{post.title}</Link>\n          </li>\n        ))}\n      </ul>\n      <hr />\n      {/* TODO: Add Outlet for nested routes */}\n    </div>\n  );\n}\n\nfunction PostDetails() {\n  // TODO: Get postId from URL params and display it\n  const { postId } = useParams();\n  return <h3>Details for Post: {postId}</h3>;\n}\n\nfunction NotFoundPage() {\n  return <h2>404 - Page Not Found</h2>;\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav>\n        {/* TODO: Add navigation links */}\n        <Link to=\"/\">Home</Link> | \n        <Link to=\"/about\">About</Link> | \n        <Link to=\"/posts\">Posts</Link>\n      </nav>\n\n      {/* TODO: Define Routes */}\n      <Routes>\n        {/* Home Route */}\n        {/* About Route */}\n        {/* Posts Parent Route with nested PostDetails */}\n        {/* 404 Route */}\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link, Outlet, useParams } from 'react-router-dom';\nimport ReactDOM from 'react-dom/client';\n\nfunction HomePage() {\n  return <h2>Welcome to the Blog!</h2>;\n}\n\nfunction AboutPage() {\n  return <h2>About Us</h2>;\n}\n\nfunction PostsLayout() {\n  const posts = [\n    { id: '1', title: 'First Blog Post' },\n    { id: '2', title: 'Second Blog Post' },\n    { id: '3', title: 'Third Blog Post' },\n  ];\n\n  return (\n    <div>\n      <h2>Blog Posts</h2>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>\n            <Link to={post.id}>{post.title}</Link>\n          </li>\n        ))}\n      </ul>\n      <hr />\n      {/* This is where the nested route content will be rendered */}\n      <Outlet /> \n    </div>\n  );\n}\n\nfunction PostDetails() {\n  const { postId } = useParams();\n  return (\n    <div>\n      <h3>Details for Post: {postId}</h3>\n      <p>This is the full content for post #{postId}.</p>\n    </div>\n  );\n}\n\nfunction NotFoundPage() {\n  return <h2>404 - Page Not Found</h2>;\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav style={{ padding: '10px 0', borderBottom: '1px solid #ccc' }}>\n        <Link to=\"/\" style={{ margin: '0 10px' }}>Home</Link> \n        <Link to=\"/about\" style={{ margin: '0 10px' }}>About</Link> \n        <Link to=\"/posts\" style={{ margin: '0 10px' }}>Posts</Link>\n      </nav>\n      <div style={{ padding: '20px' }}>\n        <Routes>\n          <Route path=\"/\" element={<HomePage />} />\n          <Route path=\"/about\" element={<AboutPage />} />\n          \n          {/* Parent route for blog posts */}\n          <Route path=\"/posts\" element={<PostsLayout />}>\n            {/* Nested route for individual post details */}\n            <Route path=\":postId\" element={<PostDetails />} />\n            {/* Optional: default content when only /posts is matched */}\n            <Route index element={<h4>Select a post to read details.</h4>} />\n          </Route>\n          \n          {/* 404 Not Found route */}\n          <Route path=\"*\" element={<NotFoundPage />} />\n        </Routes>\n      </div>\n    </BrowserRouter>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "testCases": [
            "Navigate to `/`: Expect `HomePage` to render.",
            "Navigate to `/about`: Expect `AboutPage` to render.",
            "Navigate to `/posts`: Expect `PostsLayout` to render with the list of posts and 'Select a post to read details.' message.",
            "Click on a post link (e.g., 'First Blog Post'): Expect the URL to become `/posts/1` and `PostDetails` to render with 'Details for Post: 1' below the list of posts.",
            "Manually navigate to `/posts/999`: Expect `PostDetails` to render with 'Details for Post: 999'.",
            "Navigate to `/non-existent-path`: Expect `NotFoundPage` to render ('404 - Page Not Found')."
          ],
          "hints": [
            "Remember that `<Routes>` is the container for all `Route` elements in v6.",
            "For nested routes, the parent `Route` uses its `element` prop to define the layout component (e.g., `PostsLayout`), and this layout component must include an `<Outlet />` where its child routes will render.",
            "Dynamic segments in routes are defined with a colon, e.g., `:postId`.",
            "`useParams()` is the hook to extract these dynamic segments.",
            "Relative links work seamlessly in nested contexts; for example, from `/posts`, a `Link to=\"1\"` will lead to `/posts/1`."
          ],
          "tags": [
            "React Router",
            "v6",
            "Routing",
            "Nested Routing",
            "Hooks",
            "SPA",
            "Frontend"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React_Components",
            "React_Hooks_Basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "SPA_Architecture",
            "Declarative_Routing",
            "URL_Parameters"
          ]
        }
      ]
    }
  },
  {
    "id": "950c4a88-f279-4690-8ffd-642c55c97fdb",
    "startLine": 6200,
    "endLine": 6299,
    "processedDate": "2025-06-17T09:53:48.601Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_router_v6_navigation",
          "title": "React Router v6 Navigation Essentials",
          "content": "React Router v6 introduces streamlined APIs for navigation, moving away from some older concepts in v5. The core components for navigation remain `Link` and `NavLink`, while programmatic navigation is handled exclusively via the `useNavigate` hook.\n\n## Key Components and Hooks:\n\n### 1. `Link` Component\n- The `Link` component is the primary way to enable client-side navigation within a React application.\n- It renders an `<a>` tag in the DOM, but it prevents the default browser behavior of a full page reload.\n- Instead of reloading, it uses React Router to update the URL and render the corresponding component without a full page refresh, making the user experience faster and smoother.\n- **Usage:** `<Link to=\"/path\">Link Text</Link>`\n\n### 2. `NavLink` Component\n- `NavLink` is a special version of `Link` that is designed to add styling attributes to the rendered element when it matches the current URL.\n- This is particularly useful for navigation menus where you want to highlight the currently active link.\n- **Active Styling in v6:** Unlike `v5`'s `activeClassName`, `NavLink` in `v6` uses a functional `style` or `className` prop to determine active status. This function receives an object `{ isActive: boolean }` as an argument.\n- **Usage (with functional style):**\n```jsx\n<NavLink to=\"/about\" style={({ isActive }) => isActive ? { fontWeight: 'bold', color: 'blue' } : undefined}>\n  About\n</NavLink>\n```\n- **Usage (with functional className):**\n```jsx\n<NavLink to=\"/dashboard\" className={({ isActive }) => isActive ? 'active-link' : ''}>\n  Dashboard\n</NavLink>\n```\n\n### 3. `useNavigate` Hook\n- The `useNavigate` hook is the recommended way to perform imperative or programmatic navigation in React Router v6.\n- It returns a function that allows you to navigate to different routes, replace entries in the history stack, or navigate relative to the current route.\n- It replaces the `useHistory` hook from v5.\n- **Basic Usage:** `navigate('/some/path')`\n- **Navigating Back/Forward:** `navigate(-1)` (back one step), `navigate(1)` (forward one step).\n- **Replacing History Entry:** `navigate('/some/path', { replace: true })` - This replaces the current entry in the history stack instead of adding a new one, useful for redirects after login.\n- **State Passing:** `navigate('/users/123', { state: { from: 'dashboard' } })` - You can pass state to the new location, which can be accessed via `useLocation().state`.\n\nThese tools provide a robust and flexible way to manage navigation in modern React applications using React Router v6.",
          "examples": [
            {
              "id": "example_v6_nav_1",
              "title": "Basic v6 Navigation Component",
              "code": "import { Link, NavLink, useNavigate } from 'react-router-dom';\n\nfunction NavigationV6() {\n  const navigate = useNavigate();\n\n  return (\n    <nav>\n      <ul>\n        <li><Link to=\"/\">Home</Link></li>\n        <li>\n          <NavLink \n            to=\"/about\" \n            style={({ isActive }) => \n              isActive ? { fontWeight: 'bold', color: 'darkred' } : undefined\n            }\n          >\n            About\n          </NavLink>\n        </li>\n        <li>\n          <button onClick={() => navigate('/contact')}>Contact Us</button>\n        </li>\n        <li>\n          <button onClick={() => navigate(-1)}>Go Back</button>\n        </li>\n      </ul>\n    </nav>\n  );\n}\n\n// To use this, you'd typically wrap your App component in a <BrowserRouter>\n// import { BrowserRouter, Routes, Route } from 'react-router-dom';\n// function App() {\n//   return (\n//     <BrowserRouter>\n//       <NavigationV6 />\n//       <Routes>\n//         <Route path=\"/\" element={<div>Home Page</div>} />\n//         <Route path=\"/about\" element={<div>About Page</div>} />\n//         <Route path=\"/contact\" element={<div>Contact Page</div>} />\n//       </Routes>\n//     </BrowserRouter>\n//   );\n// }\n",
              "explanation": "This example demonstrates a navigation bar using React Router v6 components. `Link` is used for basic navigation. `NavLink` shows how to apply dynamic styling based on the `isActive` state for the current route. A button uses `useNavigate` for programmatic redirection to the '/contact' route and also to go back one step in history.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_nav_v6_link_navlink_diff",
            "question_nav_v6_usenavigate_purpose",
            "question_nav_v6_functional_navlink_style",
            "question_nav_v6_navigate_replace",
            "question_nav_v6_mcq_navlink_styling"
          ],
          "relatedTasks": [
            "task_v6_dynamic_navbar"
          ],
          "tags": [
            "React Router",
            "v6",
            "Navigation",
            "Link",
            "NavLink",
            "useNavigate",
            "Hooks"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "React Hooks",
            "Client-Side Routing Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced Routing",
            "Authentication Flows",
            "Dynamic Navigation"
          ]
        },
        {
          "id": "theory_react_router_v5_navigation",
          "title": "React Router v5 Navigation Essentials (Legacy)",
          "content": "React Router v5 represented a stable version of the library, with similar concepts to v6 but distinct API differences, especially concerning programmatic navigation and active link styling. While v6 is now the standard, understanding v5 can be useful for maintaining older projects or understanding the evolution of the library.\n\n## Key Components and Hooks:\n\n### 1. `Link` Component\n- Identical in purpose to `v6`'s `Link`, it provides client-side navigation without full page reloads.\n- It renders an `<a>` tag.\n- **Usage:** `<Link to=\"/path\">Link Text</Link>`\n\n### 2. `NavLink` Component\n- Similar to `v6`'s `NavLink`, it applies styling to the active link.\n- **Active Styling in v5:** In `v5`, `NavLink` used the `activeClassName` prop to apply a CSS class when the link was active. It also had an `activeStyle` prop for inline styles.\n- **Usage (with `activeClassName`):**\n```jsx\n<NavLink to=\"/about\" activeClassName=\"active-link-style\">\n  About\n</NavLink>\n```\n- **Usage (with `activeStyle`):**\n```jsx\n<NavLink to=\"/dashboard\" activeStyle={{ fontWeight: 'bold' }}>\n  Dashboard\n</NavLink>\n```\n\n### 3. `useHistory` Hook\n- The `useHistory` hook was the primary way to access the history instance and perform imperative navigation in React Router v5.\n- It allowed pushing new entries onto the history stack (`history.push`), replacing entries (`history.replace`), and navigating back/forward (`history.goBack`, `history.goForward`).\n- **Usage:**\n```javascript\nconst history = useHistory();\nhistory.push('/some/path');\nhistory.goBack();\n```\n\n### 4. `withRouter` Higher-Order Component (HOC)\n- Before hooks, `withRouter` was used to inject `history`, `location`, and `match` props into a component that wasn't directly rendered by a `Route`.\n- With the advent of hooks like `useHistory`, `withRouter` became less common but is still found in older class components.\n\n**Note:** While understanding v5 is valuable, new projects should prioritize v6 due to its improved APIs and ongoing support.",
          "examples": [
            {
              "id": "example_v5_nav_1",
              "title": "Basic v5 Navigation Component",
              "code": "import { Link, NavLink, useHistory } from 'react-router-dom';\n\nfunction NavigationV5() {\n  const history = useHistory();\n\n  return (\n    <nav>\n      <ul>\n        <li><Link to=\"/\">Home</Link></li>\n        <li><NavLink to=\"/about\" activeClassName=\"v5-active-link\">About</NavLink></li>\n        <li><button onClick={() => history.push('/contact')}>Contact</button></li>\n      </ul>\n    </nav>\n  );\n}\n\n/*\n// To use this, you'd typically wrap your App component in a <BrowserRouter>\n// and define Routes using <Switch> and <Route> from 'react-router-dom' v5\n// Example structure:\n// import { BrowserRouter, Route, Switch } from 'react-router-dom';\n// function App() {\n//   return (\n//     <BrowserRouter>\n//       <NavigationV5 />\n//       <Switch>\n//         <Route path=\"/\" exact component={HomePage} />\n//         <Route path=\"/about\" component={AboutPage} />\n//         <Route path=\"/contact\" component={ContactPage} />\n//       </Switch>\n//     </BrowserRouter>\n//   );\n// }\n*/",
              "explanation": "This example showcases a navigation bar using React Router v5. `Link` provides basic client-side routing. `NavLink` uses `activeClassName` to apply a CSS class when the link is active. The `useHistory` hook is utilized for programmatic navigation when the 'Contact' button is clicked.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_nav_v5_v6_diff_navlink",
            "question_nav_v5_usehistory_purpose",
            "question_nav_v5_withrouter"
          ],
          "relatedTasks": [],
          "tags": [
            "React Router",
            "v5",
            "Legacy",
            "Navigation",
            "Link",
            "NavLink",
            "useHistory",
            "Hooks",
            "Deprecated"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "React Hooks",
            "Client-Side Routing Concepts"
          ],
          "complexity": 5,
          "interviewRelevance": 6,
          "learningPath": "intermediate",
          "requiredFor": [
            "Maintenance of Legacy Applications",
            "Understanding API Evolution"
          ]
        },
        {
          "id": "theory_programmatic_navigation",
          "title": "Programmatic and Declarative Navigation",
          "content": "Navigation in React Router can be achieved in two main ways: declaratively using components like `Link` or `NavLink`, and programmatically (or imperatively) using hooks or components for redirects.\n\n## Imperative Navigation (Hooks):\n\n### React Router v6: `useNavigate`\n- As discussed, `useNavigate` provides a function to navigate programmatically.\n- **`navigate(to, options)`:**\n    - `to`: The path to navigate to (e.g., `'/dashboard'`, `'/users/123'`). Can also be a number for relative navigation (`-1` for back, `1` for forward).\n    - `options.replace`: `boolean` - If `true`, the current entry in the history stack will be replaced instead of pushing a new one. Useful for redirects (e.g., after login to prevent going back to the login page).\n    - `options.state`: `any` - Data to pass to the new location, accessible via `useLocation().state`.\n\n```javascript\nimport { useNavigate } from 'react-router-dom';\n\nfunction LoginButton() {\n  const navigate = useNavigate();\n\n  const handleLogin = () => {\n    // ... authentication logic ...\n    const isAuthenticated = true; // Assume successful login\n    if (isAuthenticated) {\n      navigate('/dashboard', { replace: true, state: { user: 'admin' } });\n    }\n  };\n\n  return <button onClick={handleLogin}>Login</button>;\n}\n```\n\n### React Router v5: `useHistory`\n- The `useHistory` hook provided similar capabilities in v5.\n- **`history.push(path, state)`:** Adds a new entry to the history stack.\n- **`history.replace(path, state)`:** Replaces the current entry in the history stack.\n- **`history.goBack()` / `history.goForward()` / `history.go(n)`:** Navigate relative to the current position.\n\n```javascript\nimport { useHistory } from 'react-router-dom';\n\nfunction LoginButtonV5() {\n  const history = useHistory();\n\n  const handleLogin = () => {\n    // ... authentication logic ...\n    const isAuthenticated = true; // Assume successful login\n    if (isAuthenticated) {\n      history.push('/dashboard'); // or history.replace('/dashboard');\n    }\n  };\n\n  return <button onClick={handleLogin}>Login</button>;\n}\n```\n\n## Declarative Navigation (Components):\n\n### React Router v6: `<Navigate>` Component\n- React Router v6 introduces the `<Navigate>` component for declarative redirects. It is typically used for conditional redirects, like after a form submission or if a user tries to access a protected route without authentication.\n- It renders a redirect immediately.\n- **Usage:**\n```jsx\nimport { Navigate } from 'react-router-dom';\n\nfunction ProtectedRoute({ isAuthenticated }) {\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" replace />; // Redirects to login and replaces history entry\n  }\n  return <div>Welcome to the protected area!</div>;\n}\n```\n\n### React Router v5: `<Redirect>` Component\n- In v5, the `<Redirect>` component served the same purpose as `<Navigate>` in v6.\n- It's a component that, when rendered, performs a navigation to the specified `to` prop.\n- **`to`:** The path to redirect to.\n- **`push`:** `boolean` - If `true`, a new entry will be pushed onto the history stack; otherwise, it replaces the current entry (default behavior).\n- **Usage:**\n```jsx\nimport { Redirect } from 'react-router-dom';\n\nfunction OldRoute() {\n  // For example, redirecting from an old URL to a new one\n  return <Redirect to=\"/new-path\" />;\n}\n```\n\nProgrammatic navigation is essential for scenarios where navigation is triggered by logic rather than a direct user click on a link, such as form submissions, authentication flows, or error handling.",
          "examples": [
            {
              "id": "example_programmatic_login_v5",
              "title": "Login Component with Redirect (v5)",
              "code": "import React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom';\n\nexport default class LoginComponentV5 extends Component {\n  state = {\n    username: '',\n    password: '',\n    isLoggedIn: false,\n    error: null\n  };\n  \n  handleInputChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  };\n  \n  handleSubmit = (e) => {\n    e.preventDefault();\n    // Authentication logic here\n    if (this.state.username === 'user' && this.state.password === 'pass') {\n      // Simulate successful login\n      this.setState({ isLoggedIn: true });\n    } else {\n      this.setState({ error: 'Invalid username or password' });\n    }\n  };\n  \n  render() {\n    // Redirect if logged in\n    if (this.state.isLoggedIn) {\n      return <Redirect to=\"/dashboard\" />; // Declarative redirect\n    }\n    \n    return (\n      <div>\n        <h2>Login (v5 Example)</h2>\n        {this.state.error && <p className=\"error\" style={{color: 'red'}}>{this.state.error}</p>}\n        <form onSubmit={this.handleSubmit}>\n          <div>\n            <label>Username:</label>\n            <input\n              type=\"text\"\n              name=\"username\"\n              value={this.state.username}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <div>\n            <label>Password:</label>\n            <input\n              type=\"password\"\n              name=\"password\"\n              value={this.state.password}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <button type=\"submit\">Log In</button>\n        </form>\n      </div>\n    );\n  }\n}\n",
              "explanation": "This example demonstrates programmatic navigation using the `Redirect` component in React Router v5. After a simulated successful login (when username 'user' and password 'pass' are entered), the `isLoggedIn` state is set to `true`, which causes the component to render a `<Redirect>` component, effectively navigating the user to the `/dashboard` route.",
              "language": "typescript"
            },
            {
              "id": "example_programmatic_login_v6",
              "title": "Login Component with Programmatic Navigation (v6)",
              "code": "import React, { useState } from 'react';\nimport { useNavigate, Navigate } from 'react-router-dom';\n\nfunction LoginComponentV6() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [error, setError] = useState(null);\n  const navigate = useNavigate();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (username === 'user' && password === 'pass') {\n      setIsLoggedIn(true);\n      // Imperative navigation after successful login, replacing history entry\n      navigate('/dashboard', { replace: true }); \n    } else {\n      setError('Invalid username or password');\n    }\n  };\n  \n  // Declarative navigation alternative (if not using navigate hook)\n  // if (isLoggedIn) {\n  //   return <Navigate to=\"/dashboard\" replace />;\n  // }\n\n  return (\n    <div>\n      <h2>Login (v6 Example)</h2>\n      {error && <p className=\"error\" style={{color: 'red'}}>{error}</p>}\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label>Username:</label>\n          <input\n            type=\"text\"\n            name=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n          />\n        </div>\n        <div>\n          <label>Password:</label>\n          <input\n            type=\"password\"\n            name=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n",
              "explanation": "This v6 equivalent of the login component uses the `useNavigate` hook for programmatic redirection. Upon successful login, `navigate('/dashboard', { replace: true })` is called, which pushes the user to the dashboard and prevents them from navigating back to the login page using the browser's back button. The commented out `<Navigate>` component shows the declarative alternative in v6.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_programmatic_vs_declarative_nav",
            "question_usenavigate_options",
            "question_programmatic_login_scenario",
            "question_redirect_vs_navigate"
          ],
          "relatedTasks": [
            "task_auth_redirect_flow"
          ],
          "tags": [
            "React Router",
            "Programmatic Navigation",
            "Declarative Navigation",
            "useNavigate",
            "useHistory",
            "Redirect",
            "Navigate",
            "Authentication"
          ],
          "technology": "React",
          "prerequisites": [
            "React Hooks",
            "State Management",
            "Event Handling",
            "React Router Basics"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex User Flows",
            "Authentication and Authorization",
            "Form Handling"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_nav_v6_link_navlink_diff",
          "topic": "React Router v6 Link vs NavLink",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between `<Link>` and `<NavLink>` components in React Router v6?",
          "answer": "`<NavLink>` provides additional features over `<Link>` to style or add classes to the link when it matches the current URL (i.e., is active). `<Link>` is for basic navigation only.",
          "analysisPoints": [
            "Identifies the core functionality difference.",
            "Understands the concept of an 'active' link."
          ],
          "keyConcepts": [
            "Link Component",
            "NavLink Component",
            "Active State",
            "Client-side Navigation"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between similar React Router components.",
            "Understanding of their intended use cases."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "Link",
            "NavLink",
            "Basic Navigation"
          ],
          "prerequisites": [
            "React Router Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_nav_v6_mcq_navlink_styling",
          "topic": "React Router v6 NavLink Styling",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the correct way to apply a bold font style to an active `<NavLink>` in React Router v6?",
          "answer": "```jsx\n<NavLink to=\"/products\" style={({ isActive }) => isActive ? { fontWeight: 'bold' } : undefined}>\n  Products\n</NavLink>\n```",
          "options": [
            "```jsx\n<NavLink to=\"/products\" activeClassName=\"bold-link\">\n  Products\n</NavLink>\n```",
            "```jsx\n<Link to=\"/products\" activeStyle={{ fontWeight: 'bold' }}>\n  Products\n</Link>\n```",
            "```jsx\n<NavLink to=\"/products\" style={({ isActive }) => isActive ? { fontWeight: 'bold' } : undefined}>\n  Products\n</NavLink>\n```",
            "```jsx\n<NavLink to=\"/products\" className={isActive => isActive ? 'bold-link' : ''}>\n  Products\n</NavLink>\n```"
          ],
          "analysisPoints": [
            "Tests understanding of NavLink's `style` prop in v6.",
            "Distinguishes v6 API from v5 (`activeClassName`, `activeStyle`).",
            "Recognizes that `Link` does not have active styling properties."
          ],
          "keyConcepts": [
            "NavLink Component",
            "React Router v6",
            "Functional Style Prop",
            "Active State"
          ],
          "evaluationCriteria": [
            "Knowledge of React Router v6 specific APIs.",
            "Ability to correctly implement conditional styling."
          ],
          "example": "In React Router v6, `NavLink`'s `style` and `className` props accept a function that receives an object with an `isActive` boolean. This allows for dynamic styling based on the link's active state. Options A and B use v5 syntax or incorrect components. Option D is valid for `className` but the question asks about `style` specifically.",
          "tags": [
            "React Router",
            "v6",
            "NavLink",
            "Styling",
            "MCQ"
          ],
          "prerequisites": [
            "React Router v6 basics",
            "CSS-in-JS (optional, but understanding style prop)"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nav_v6_usenavigate_purpose",
          "topic": "React Router v6 useNavigate Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useNavigate` hook in React Router v6?",
          "answer": "The `useNavigate` hook is used for programmatic (imperative) navigation, allowing you to change routes based on logic (e.g., after form submission, successful login) rather than a direct user click on a `Link` or `NavLink`.",
          "analysisPoints": [
            "Defines programmatic navigation.",
            "Contrasts with declarative navigation."
          ],
          "keyConcepts": [
            "useNavigate Hook",
            "Programmatic Navigation",
            "Imperative Navigation",
            "React Router v6"
          ],
          "evaluationCriteria": [
            "Understanding of React Router hooks.",
            "Ability to differentiate navigation types."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "useNavigate",
            "Hooks",
            "Navigation"
          ],
          "prerequisites": [
            "React Hooks",
            "React Router Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_nav_v6_navigate_replace",
          "topic": "useNavigate Options (replace)",
          "level": "medium",
          "type": "open",
          "question": "Explain the significance of the `{ replace: true }` option when using `navigate('/path', { replace: true })` in React Router v6. Provide a common use case.",
          "answer": "`{ replace: true }` tells React Router to replace the current entry in the browser's history stack with the new path, instead of pushing a new entry onto the stack. This means that if a user clicks the back button after this navigation, they will go to the page *before* the replaced entry, not the page that was just replaced.\n\nA common use case is after a successful login or a sensitive operation (like submitting an order). For example, after a user successfully logs in and is redirected from `/login` to `/dashboard`, you typically don't want them to be able to hit the browser's back button and return to the `/login` page without logging out. By using `navigate('/dashboard', { replace: true })`, the `/login` page is removed from the history stack, and pressing back will take them to whatever page they were on *before* they landed on `/login` (or simply exit the application if `/login` was the first page they visited).",
          "analysisPoints": [
            "Defines `replace` functionality accurately.",
            "Explains the impact on browser history.",
            "Provides a clear and relevant real-world use case (login/redirect)."
          ],
          "keyConcepts": [
            "useNavigate",
            "Browser History",
            "History Stack",
            "Authentication Flow",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [
            "Detailed explanation of an important React Router API option.",
            "Ability to connect technical details to practical application scenarios.",
            "Understanding of user experience implications of navigation choices."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "useNavigate",
            "History Management",
            "Authentication"
          ],
          "prerequisites": [
            "React Router useNavigate",
            "Browser History API"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nav_v5_v6_diff_navlink",
          "topic": "React Router v5 vs v6 NavLink",
          "level": "medium",
          "type": "open",
          "question": "Describe the main difference in how `NavLink` handles active styling between React Router v5 and v6. Why might the v6 approach be considered more flexible?",
          "answer": "In React Router v5, `NavLink` primarily used the `activeClassName` prop (e.g., `<NavLink to='/about' activeClassName='my-active-class'>`) to apply a CSS class to the active link. It also had an `activeStyle` prop for inline styles.\n\nIn React Router v6, `activeClassName` and `activeStyle` props were removed. Instead, `NavLink`'s `className` and `style` props now accept a function. This function receives an object with an `isActive` boolean property (`({ isActive }) => ...`). This allows developers to dynamically return a CSS class string or a style object based on the `isActive` state.\n\nThe v6 approach is considered more flexible because:\n1.  **Direct Conditional Logic:** It allows for more complex conditional styling directly within the component's JSX, without needing separate CSS classes for every minor variation. You can combine multiple conditions or return different styles/classes based on other props or state.\n2.  **CSS-in-JS Compatibility:** It integrates more smoothly with CSS-in-JS libraries (like Styled Components, Emotion) where you might want to compute styles dynamically based on props, including `isActive`.\n3.  **Encourages Functional Approach:** It aligns with React's functional component and hooks paradigm, encouraging a more direct manipulation of props based on component state/context.",
          "analysisPoints": [
            "Clearly states the syntax difference (`activeClassName` vs functional `className`/`style`).",
            "Explains *why* the v6 approach is more flexible (dynamic logic, CSS-in-JS, functional paradigm).",
            "Demonstrates understanding of API evolution."
          ],
          "keyConcepts": [
            "NavLink",
            "React Router v5",
            "React Router v6",
            "Active Styling",
            "API Evolution"
          ],
          "evaluationCriteria": [
            "Detailed comparison of API versions.",
            "Ability to articulate reasons for design changes.",
            "Comprehension of broader React ecosystem trends (e.g., CSS-in-JS)."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v5",
            "v6",
            "NavLink",
            "Styling",
            "API Changes"
          ],
          "prerequisites": [
            "React Router v5 and v6 basics"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_programmatic_login_scenario",
          "topic": "Programmatic Navigation in Authentication Flow",
          "level": "hard",
          "type": "code",
          "question": "You are building a login form in a React application using React Router v6. After a successful login, you need to redirect the user to a `/dashboard` page. Additionally, users should not be able to navigate back to the `/login` page using the browser's back button after logging in.\n\nImplement the `handleLoginSubmit` function within the `LoginForm` component to achieve this behavior. Assume `performLogin(username, password)` is an async function that returns `true` on success and `false` otherwise.",
          "answer": "```typescript\nimport React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\n// Assume this function exists and simulates an API call\nconst performLogin = async (username: string, password: string): Promise<boolean> => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (username === 'test' && password === 'password') {\n        resolve(true);\n      } else {\n        resolve(false);\n      }\n    }, 500);\n  });\n};\n\nfunction LoginForm() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const navigate = useNavigate();\n\n  const handleLoginSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError('');\n\n    try {\n      const success = await performLogin(username, password);\n      if (success) {\n        // Redirect to dashboard and replace history entry\n        navigate('/dashboard', { replace: true });\n      } else {\n        setError('Invalid credentials');\n      }\n    } catch (err) {\n      setError('Login failed. Please try again.');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <form onSubmit={handleLoginSubmit}>\n        <div>\n          <label>Username:</label>\n          <input\n            type=\"text\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n          />\n        </div>\n        <div>\n          <label>Password:</label>\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\n// To test this component, you'd set up your React Router routes:\n// <BrowserRouter>\n//   <Routes>\n//     <Route path=\"/login\" element={<LoginForm />} />\n//     <Route path=\"/dashboard\" element={<div>Welcome to Dashboard!</div>} />\n//     <Route path=\"/\" element={<div>Home Page</div>} />\n//   </Routes>\n// </BrowserRouter>\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `useNavigate` for programmatic navigation.",
            "Applies the `replace: true` option to prevent returning to the login page.",
            "Handles asynchronous login logic with `async/await`.",
            "Includes basic error handling.",
            "Demonstrates understanding of form submission handling (`e.preventDefault()`)."
          ],
          "keyConcepts": [
            "useNavigate Hook",
            "Programmatic Navigation",
            "Authentication Flow",
            "History Management",
            "Form Handling",
            "Asynchronous JavaScript"
          ],
          "evaluationCriteria": [
            "Correct implementation of React Router v6 navigation.",
            "Proper use of `replace` option.",
            "Ability to integrate routing with business logic (authentication).",
            "Clean and functional code structure.",
            "Error handling considerations."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "Authentication",
            "Programmatic Navigation",
            "Code Challenge",
            "Hooks"
          ],
          "prerequisites": [
            "React Hooks",
            "Asynchronous JavaScript",
            "React Router useNavigate"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_programmatic_vs_declarative_nav",
          "topic": "Programmatic vs. Declarative Navigation",
          "level": "medium",
          "type": "open",
          "question": "Contrast programmatic (imperative) navigation with declarative navigation in React Router. Provide examples for each type in a React Router v6 context, and explain when to prefer one over the other.",
          "answer": "**Declarative Navigation** involves using React components to describe the desired navigation. When these components are rendered, they instruct React Router to navigate. It's often preferred for static links or simple conditional rendering.\n*   **Example (v6):** `<Link to=\"/dashboard\">Go to Dashboard</Link>` or `<NavLink to=\"/profile\">Profile</NavLink>`.\n*   **When to prefer:** For standard clickable links in navigation menus, buttons that directly correspond to a route, or simple conditional redirects using `<Navigate>` where the condition is based purely on rendered state (e.g., if a user is logged in, show dashboard, else redirect to login).\n\n**Programmatic (Imperative) Navigation** involves using JavaScript code (hooks) to trigger navigation based on some logic or event that isn't a direct click on a `Link` component. This is useful when navigation depends on an action's outcome, such as form submission, API call success, or a timeout.\n*   **Example (v6):**\n    ```typescript\n    import { useNavigate } from 'react-router-dom';\n    function MyForm() {\n      const navigate = useNavigate();\n      const handleSubmit = () => {\n        // ... form submission logic ...\n        if (success) {\n          navigate('/success'); // Imperatively navigate\n        }\n      };\n      return <form onSubmit={handleSubmit}>...</form>;\n    }\n    ```\n*   **When to prefer:** After successful form submissions, after an API call completes, based on complex state logic, redirecting to a previous page (`navigate(-1)`), or for non-link elements that trigger navigation (e.g., buttons, dropdown selections).\n\n**In summary:** Use declarative navigation for 'what you want to render' (visual links), and programmatic navigation for 'what you want to do' (logic-driven redirects or history manipulation).",
          "analysisPoints": [
            "Clearly defines both types of navigation.",
            "Provides accurate v6 examples for both.",
            "Articulates appropriate use cases and preferences for each.",
            "Highlights the 'what to render' vs 'what to do' distinction."
          ],
          "keyConcepts": [
            "Declarative Navigation",
            "Programmatic Navigation",
            "Imperative Navigation",
            "Link Component",
            "NavLink Component",
            "useNavigate Hook",
            "Navigate Component",
            "React Router v6"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of React Router navigation paradigms.",
            "Ability to provide relevant code examples.",
            "Practical understanding of when to apply each method.",
            "Clear and concise explanations."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Navigation Patterns",
            "v6",
            "Declarative",
            "Imperative",
            "Concepts"
          ],
          "prerequisites": [
            "React Router Basics",
            "React Hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_vs_navigate",
          "topic": "Redirect vs Navigate Component",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the React Router v6 equivalent of the `<Redirect>` component from v5, and how is it used?",
          "answer": "The React Router v6 equivalent of the `<Redirect>` component is the `<Navigate>` component. It is used for declarative redirects, typically within a `return` statement of a component to conditionally navigate based on state. For example: `if (!user) { return <Navigate to=\"/login\" replace />; }`",
          "analysisPoints": [
            "Identifies the correct v6 component.",
            "Explains its purpose (declarative redirect).",
            "Provides a concise usage example."
          ],
          "keyConcepts": [
            "Redirect Component",
            "Navigate Component",
            "React Router v5",
            "React Router v6",
            "Declarative Navigation"
          ],
          "evaluationCriteria": [
            "Knowledge of API changes between React Router versions.",
            "Understanding of declarative routing components."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v5",
            "v6",
            "Redirect",
            "Navigate",
            "Components"
          ],
          "prerequisites": [
            "React Router Components"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nav_v5_usehistory_purpose",
          "topic": "React Router v5 useHistory Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What was the primary purpose of the `useHistory` hook in React Router v5, and what replaced it in v6?",
          "answer": "The `useHistory` hook in React Router v5 provided access to the `history` object, allowing for programmatic navigation (e.g., `history.push('/path')`, `history.replace('/path')`, `history.goBack()`). It was replaced by the `useNavigate` hook in React Router v6.",
          "analysisPoints": [
            "Correctly identifies `useHistory`'s function.",
            "Names its v6 replacement.",
            "Understands deprecation and evolution."
          ],
          "keyConcepts": [
            "useHistory Hook",
            "useNavigate Hook",
            "React Router v5",
            "React Router v6",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [
            "Knowledge of historical React Router APIs.",
            "Awareness of API evolution."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v5",
            "useHistory",
            "Hooks",
            "Legacy"
          ],
          "prerequisites": [
            "React Router Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nav_v5_withrouter",
          "topic": "React Router v5 withRouter HOC",
          "level": "medium",
          "type": "open",
          "question": "Before React Hooks, how did React Router v5 provide routing-related props (like `history`, `location`, `match`) to components that were not directly rendered by a `<Route>`? What is the modern equivalent in v6?",
          "answer": "In React Router v5 (and earlier versions), the `withRouter` Higher-Order Component (HOC) was used to inject `history`, `location`, and `match` props into any component, regardless of whether it was directly rendered by a `<Route>`.\n\nExample usage:\n```jsx\nimport { withRouter } from 'react-router-dom';\n\nclass MyComponent extends React.Component {\n  // this.props.history, this.props.location, this.props.match are available\n  render() {\n    return <button onClick={() => this.props.history.push('/some-path')}>Navigate</button>;\n  }\n}\n\nexport default withRouter(MyComponent);\n```\n\nThe modern equivalent in React Router v6 (and generally with React Hooks) are individual hooks: `useNavigate` (for `history`), `useLocation` (for `location`), and `useParams` (for `match.params`). These hooks can be used directly in functional components without the need for HOCs, offering a cleaner and more direct API.",
          "analysisPoints": [
            "Identifies `withRouter` as the v5 solution.",
            "Explains its purpose (injecting routing props).",
            "Provides a basic example of `withRouter` usage.",
            "Correctly identifies `useNavigate`, `useLocation`, `useParams` as v6 equivalents.",
            "Highlights the shift from HOCs to Hooks."
          ],
          "keyConcepts": [
            "withRouter HOC",
            "Higher-Order Components",
            "React Router v5",
            "React Router v6",
            "useNavigate",
            "useLocation",
            "useParams",
            "React Hooks"
          ],
          "evaluationCriteria": [
            "Knowledge of both legacy and modern React Router APIs.",
            "Understanding of the role of HOCs vs. Hooks.",
            "Ability to explain API evolution and reasoning.",
            "Clarity of explanation and examples."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v5",
            "v6",
            "HOC",
            "Hooks",
            "API Changes",
            "Legacy"
          ],
          "prerequisites": [
            "React Hooks",
            "React Router Hooks",
            "Higher-Order Components"
          ],
          "complexity": 7,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_v6_dynamic_navbar",
          "title": "Build a Responsive Navigation Bar with React Router v6",
          "description": "\nCreate a `NavBar` React component that utilizes React Router v6 for navigation. The component should meet the following requirements:\n\n1.  **Home Link:** A simple link to the root path (`/`) using `<Link>`.\n2.  **About Link:** A link to `/about` using `<NavLink>`. This link should have its text color changed to `blue` and font weight set to `bold` when it's the active route.\n3.  **Contact Button:** A button that navigates programmatically to `/contact` when clicked. Use the `useNavigate` hook.\n4.  **Go Back Button:** Another button that uses `useNavigate` to go back one step in the browser history.\n5.  **Basic Structure:** Use `<ul>` and `<li>` for the navigation items.\n\nYour solution should be functional within a basic React Router v6 setup (`BrowserRouter`, `Routes`, `Route`).\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { Link, NavLink, useNavigate } from 'react-router-dom';\n\nfunction NavBar() {\n  // TODO: Initialize useNavigate hook\n\n  return (\n    <nav style={{\n      backgroundColor: '#f0f0f0',\n      padding: '10px',\n      borderRadius: '5px',\n      display: 'flex',\n      justifyContent: 'center',\n      gap: '20px'\n    }}>\n      <ul style={{\n        listStyle: 'none',\n        padding: 0,\n        margin: 0,\n        display: 'flex',\n        gap: '20px',\n        alignItems: 'center'\n      }}>\n        <li>\n          {/* TODO: Add Link to Home */}\n        </li>\n        <li>\n          {/* TODO: Add NavLink to About with active styling */}\n        </li>\n        <li>\n          {/* TODO: Add Contact button with programmatic navigation */}\n        </li>\n        <li>\n          {/* TODO: Add Go Back button with programmatic navigation */}\n        </li>\n      </ul>\n    </nav>\n  );\n}\n\nexport default NavBar;\n\n/*\n// Example App.js to test NavBar:\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport NavBar from './NavBar';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <NavBar />\n      <div style={{ marginTop: '20px', textAlign: 'center' }}>\n        <Routes>\n          <Route path=\"/\" element={<h2>Home Page</h2>} />\n          <Route path=\"/about\" element={<h2>About Us Page</h2>} />\n          <Route path=\"/contact\" element={<h2>Contact Us Page</h2>} />\n          <Route path=\"/test-history\" element={<h2>History Test Page</h2>} />\n        </Routes>\n      </div>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n*/\n",
          "solutionCode": "import React from 'react';\nimport { Link, NavLink, useNavigate } from 'react-router-dom';\n\nfunction NavBar() {\n  const navigate = useNavigate();\n\n  return (\n    <nav style={{\n      backgroundColor: '#f0f0f0',\n      padding: '10px',\n      borderRadius: '5px',\n      display: 'flex',\n      justifyContent: 'center',\n      gap: '20px'\n    }}>\n      <ul style={{\n        listStyle: 'none',\n        padding: 0,\n        margin: 0,\n        display: 'flex',\n        gap: '20px',\n        alignItems: 'center'\n      }}>\n        <li>\n          <Link to=\"/\" style={{ textDecoration: 'none', color: 'black' }}>Home</Link>\n        </li>\n        <li>\n          <NavLink \n            to=\"/about\" \n            style={({ isActive }) => \n              isActive ? { fontWeight: 'bold', color: 'blue', textDecoration: 'none' } : { color: 'black', textDecoration: 'none' }\n            }\n          >\n            About\n          </NavLink>\n        </li>\n        <li>\n          <button \n            onClick={() => navigate('/contact')}\n            style={{ padding: '8px 12px', border: 'none', borderRadius: '4px', cursor: 'pointer', backgroundColor: '#add8e6' }}\n          >\n            Contact\n          </button>\n        </li>\n        <li>\n          <button \n            onClick={() => navigate(-1)}\n            style={{ padding: '8px 12px', border: 'none', borderRadius: '4px', cursor: 'pointer', backgroundColor: '#add8e6' }}\n          >\n            Go Back\n          </button>\n        </li>\n      </ul>\n    </nav>\n  );\n}\n\nexport default NavBar;\n",
          "testCases": [
            "Navigate to '/', then '/about', then '/contact'. Verify 'About' link changes style when active.",
            "Click 'Contact' button and verify navigation to '/contact'.",
            "Click 'Go Back' button from '/contact' page. Verify navigation to the previous page (e.g., '/about').",
            "Click 'Go Back' button from the initial page (e.g., '/'). Verify graceful handling (no error, or stays on current page if no history).",
            "Ensure all links and buttons are clickable and functional without full page reloads."
          ],
          "hints": [
            "Remember that `NavLink`'s `style` prop in v6 takes a function that receives `{ isActive }`.",
            "The `useNavigate` hook returns a function that can accept a path string or a number (for relative history navigation).",
            "Make sure to import all necessary components and hooks from `react-router-dom`."
          ],
          "tags": [
            "React Router",
            "v6",
            "Navigation Bar",
            "Link",
            "NavLink",
            "useNavigate",
            "Hooks",
            "Frontend Development"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Basics",
            "React Hooks",
            "React Router Fundamentals"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Client-Side Routing",
            "Dynamic Styling",
            "Imperative Navigation"
          ]
        },
        {
          "id": "task_auth_redirect_flow",
          "title": "Implement a Secure Login Flow with Redirect",
          "description": "\nDevelop a `LoginComponent` that handles user authentication and redirects the user upon successful login using React Router v6. The component should:\n\n1.  **Authentication Simulation:** Simulate a login attempt using a placeholder `fakeLoginApi` function (provided). This function should return a Promise that resolves to `true` for successful login (e.g., `username: 'user', password: 'password'`) and `false` otherwise after a short delay.\n2.  **Form Handling:** Manage username and password input fields using React state.\n3.  **Programmatic Redirect:** Upon successful login, programmatically navigate the user to a `/dashboard` route.\n4.  **History Management:** Ensure that the user *cannot* go back to the `/login` page using the browser's back button after successfully logging in. This requires replacing the history entry.\n5.  **Error Handling:** Display an error message if login fails.\n6.  **Declarative Redirect (Bonus/Alternative):** As an alternative, demonstrate how the `<Navigate>` component could be used for the same redirect behavior if the login state was managed at a higher level.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\nimport { useNavigate, Navigate } from 'react-router-dom';\n\n// Simulate an API call for login\nconst fakeLoginApi = async (username, password) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (username === 'user' && password === 'password') {\n        resolve(true); // Simulate successful login\n      } else {\n        resolve(false); // Simulate failed login\n      }\n    }, 700);\n  });\n};\n\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const [isLoggedIn, setIsLoggedIn] = useState(false); // To track login state\n\n  // TODO: Initialize useNavigate hook\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError(''); // Clear previous errors\n    // TODO: Implement login logic and redirect\n  };\n\n  // TODO (Bonus): Optionally use <Navigate> for declarative redirect based on isLoggedIn state\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '400px', margin: '50px auto', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <form onSubmit={handleSubmit}>\n        <div style={{ marginBottom: '10px' }}>\n          <label htmlFor=\"username\" style={{ display: 'block', marginBottom: '5px' }}>Username:</label>\n          <input\n            type=\"text\"\n            id=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n        </div>\n        <div style={{ marginBottom: '20px' }}>\n          <label htmlFor=\"password\" style={{ display: 'block', marginBottom: '5px' }}>Password:</label>\n          <input\n            type=\"password\"\n            id=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n        </div>\n        <button \n          type=\"submit\" \n          style={{ width: '100%', padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n        >\n          Log In\n        </button>\n      </form>\n    </div>\n  );\n}\n\nexport default LoginComponent;\n\n/*\n// Example App.js to test LoginComponent:\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport LoginComponent from './LoginComponent';\n\nfunction DashboardPage() {\n  return <h2 style={{ textAlign: 'center', marginTop: '50px' }}>Welcome to the Dashboard!</h2>;\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/login\" element={<LoginComponent />} />\n        <Route path=\"/dashboard\" element={<DashboardPage />} />\n        <Route path=\"/\" element={<h2 style={{ textAlign: 'center', marginTop: '50px' }}>Home Page (Access Login at /login)</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n*/",
          "solutionCode": "import React, { useState } from 'react';\nimport { useNavigate, Navigate } from 'react-router-dom';\n\n// Simulate an API call for login\nconst fakeLoginApi = async (username, password) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (username === 'user' && password === 'password') {\n        resolve(true); // Simulate successful login\n      } else {\n        resolve(false); // Simulate failed login\n      }\n    }, 700);\n  });\n};\n\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const navigate = useNavigate(); // Initialize useNavigate hook\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError(''); // Clear previous errors\n\n    const success = await fakeLoginApi(username, password);\n    if (success) {\n      setIsLoggedIn(true); // Update state to reflect login status\n      // Programmatic redirect to dashboard and replace history entry\n      navigate('/dashboard', { replace: true });\n    } else {\n      setError('Invalid username or password. Try 'user' / 'password'.');\n    }\n  };\n\n  // Optional: Declarative redirect using <Navigate> (if login state handled externally/globally)\n  // if (isLoggedIn) {\n  //   return <Navigate to=\"/dashboard\" replace />;\n  // }\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '400px', margin: '50px auto', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <form onSubmit={handleSubmit}>\n        <div style={{ marginBottom: '10px' }}>\n          <label htmlFor=\"username\" style={{ display: 'block', marginBottom: '5px' }}>Username:</label>\n          <input\n            type=\"text\"\n            id=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n        </div>\n        <div style={{ marginBottom: '20px' }}>\n          <label htmlFor=\"password\" style={{ display: 'block', marginBottom: '5px' }}>Password:</label>\n          <input\n            type=\"password\"\n            id=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n        </div>\n        <button \n          type=\"submit\" \n          style={{ width: '100%', padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n        >\n          Log In\n        </button>\n      </form>\n    </div>\n  );\n}\n\nexport default LoginComponent;\n",
          "testCases": [
            "**Successful Login:** Enter 'user' for username and 'password' for password. Verify redirection to '/dashboard' and that using the browser's back button does NOT return to '/login'.",
            "**Failed Login:** Enter incorrect credentials (e.g., 'wrong' / 'pass'). Verify an error message is displayed and no redirection occurs.",
            "**Empty Input:** Submit the form with empty username/password. Verify the login attempt fails (as `fakeLoginApi` would return false) and an appropriate error message is shown.",
            "**Form Resilience:** Ensure `e.preventDefault()` is correctly used to prevent full page reloads on form submission."
          ],
          "hints": [
            "The `useNavigate` hook is crucial for imperative navigation.",
            "To prevent going back to the login page, investigate the `options` object available with `navigate`.",
            "Remember to use `async/await` when dealing with the `fakeLoginApi` Promise.",
            "State management (`useState`) is needed for form inputs and `isLoggedIn` status."
          ],
          "tags": [
            "React Router",
            "v6",
            "Authentication",
            "Programmatic Navigation",
            "History Management",
            "Forms",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Hooks",
            "Form Handling in React",
            "Asynchronous JavaScript",
            "React Router useNavigate"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "User Experience",
            "Security Best Practices (for redirects)",
            "API Integration"
          ]
        }
      ]
    }
  },
  {
    "id": "b9fbc0e9-c05e-4aff-a54a-fc9c2bd8ea8e",
    "startLine": 6300,
    "endLine": 6399,
    "processedDate": "2025-06-17T09:55:04.980Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_form_handling_class_components",
          "title": "Basic Form Handling with Class Components in React",
          "content": "In React, forms are typically handled using controlled components. A controlled component is an input form element whose value is controlled by React state. When the user types into a controlled input, their input is stored in the component's state, and then the input element's `value` prop is updated with this state. This ensures that the React state is the single source of truth for the input's value.\n\n### Key Concepts\n-   **Controlled Components**: Form elements whose values are controlled by React state. This is achieved by binding the `value` prop of the input element to a state variable and updating that state variable via an `onChange` event handler.\n-   **`state`**: An object in a class component that holds data that can change over time and affect the rendering of the component. Changes to `state` trigger a re-render.\n-   **`onChange` Event Handler**: A function attached to input elements (e.g., `<input>`, `<textarea>`, `<select>`) that fires whenever the input's value changes. It typically updates the component's state with the new input value.\n-   **`event.target.name`**: Inside an `onChange` event handler, `event.target` refers to the DOM element that triggered the event. `event.target.name` retrieves the `name` attribute of that input element, which is useful for handling multiple inputs with a single handler.\n-   **`event.target.value`**: Retrieves the current value of the input element that triggered the event.\n-   **`onSubmit` Event Handler**: A function attached to the `<form>` element that fires when the form is submitted. It's crucial to call `event.preventDefault()` inside this handler to stop the default browser behavior of reloading the page on form submission, allowing React to handle the submission logic.\n\n### Implementation\n1.  **Initialize State**: Define initial empty values for each input in the component's `state`.\n2.  **Bind Input Values**: Set the `value` prop of each input field to its corresponding state variable (e.g., `value={this.state.username}`).\n3.  **Handle Changes**: Attach an `onChange` event handler to each input. This handler updates the relevant state property using `this.setState()`. A common pattern is to use `[event.target.name]: event.target.value` to dynamically update the correct state property based on the input's `name` attribute.\n4.  **Handle Submission**: Attach an `onSubmit` event handler to the `<form>`. Inside this handler, prevent the default behavior and then access the form data from the component's state.\n\nThis pattern provides a clear and predictable way to manage form data in React applications, making it easier to implement validation and handle data flow.",
          "examples": [
            {
              "id": "example_form_handling_1",
              "title": "Basic Login Form with Class Component",
              "code": "import React, { Component } from 'react';\n\nclass LoginForm extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      username: '',\n      password: ''\n    };\n    this.handleInputChange = this.handleInputChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleInputChange(event) {\n    const { name, value } = event.target;\n    this.setState({\n      [name]: value\n    });\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n    console.log('Login Submitted:', this.state);\n    // Here you would typically send data to a backend or perform validation\n    alert(`Submitting username: ${this.state.username}, password: ${this.state.password}`);\n    // Optionally clear form or redirect\n    this.setState({\n        username: '',\n        password: ''\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Login Form</h2>\n        <form onSubmit={this.handleSubmit}>\n          <div>\n            <label>Username:</label>\n            <input\n              type=\"text\"\n              name=\"username\"\n              value={this.state.username}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <div>\n            <label>Password:</label>\n            <input\n              type=\"password\"\n              name=\"password\"\n              value={this.state.password}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <button type=\"submit\">Login</button>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default LoginForm;\n",
              "explanation": "This example demonstrates a basic controlled login form implemented using a React class component. The `state` holds the `username` and `password`. The `handleInputChange` method dynamically updates the state based on the input's `name` attribute, making it reusable for multiple inputs. The `handleSubmit` method prevents the default form submission behavior and logs the current state, simulating a login action. After submission, the form fields are cleared by resetting the state.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_form_mcq_1",
            "question_form_open_1",
            "question_form_code_1",
            "question_form_flashcard_1"
          ],
          "relatedTasks": [
            "task_controlled_form_validation"
          ],
          "tags": [
            "React",
            "Forms",
            "Class Components",
            "State Management",
            "Controlled Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "javascript_es6"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "react_hooks_forms"
          ]
        },
        {
          "id": "theory_react_router_core_concepts",
          "title": "React Router: Core Concepts and Components",
          "content": "React Router is a powerful, declarative routing library for React applications. It enables the creation of Single Page Applications (SPAs) where navigation between different views happens without full page reloads, providing a smooth user experience. It achieves this by synchronizing the UI with the URL in the browser.\n\n### Key Concepts\n-   **Client-Side Routing**: Instead of the server handling navigation requests and returning new HTML pages, the browser's JavaScript updates the content dynamically based on the URL.\n-   **Declarative Routing**: React Router components allow you to define routes and navigation links directly within your React component tree, making routing logic easy to understand and maintain.\n-   **`BrowserRouter`**: This is the recommended router for web applications. It uses the HTML5 history API (pushState, replaceState, popState) to keep your UI in sync with the URL. You should typically wrap your entire application or the part of your application that needs routing within a `<BrowserRouter>` component. This provides the context for all other React Router components.\n\n    ![React Router Provider](images/react_router_provider.png)\n\n-   **`Route`**: The `<Route>` component is responsible for rendering UI when its `path` prop matches the current URL. If the `path` matches, the component specified by the `component` prop (or `render`/`children` props) is rendered. It can also accept a `exact` prop to ensure that the path matches exactly, preventing partial matches.\n-   **`Switch`**: The `<Switch>` component renders only the *first* child `<Route>` or `<Redirect>` that matches the current location. This is crucial for ensuring that only one route is rendered at a time, especially when you have multiple routes that might partially match.\n-   **`Link`**: The `<Link>` component provides declarative navigation within your application. When clicked, it changes the URL without causing a full page refresh. It renders an `<a>` tag in the DOM.\n-   **`NavLink`**: A special version of `Link` that can automatically apply an `active` class or style to itself when its `to` prop matches the current URL. This is commonly used for navigation menus to highlight the active page.\n-   **`Redirect`**: The `<Redirect>` component allows you to programmatically navigate to a new location. When rendered, it navigates the user to the URL specified in its `to` prop. This is useful for handling authentication, 404 pages, or directing users after an action.\n-   **Hooks (`useHistory`/`useLocation`/`useParams`)**: React Router provides hooks for functional components to access router state and methods. \n    -   `useHistory`: Gives you access to the `history` instance, which can be used to navigate programmatically (`history.push('/new-path')`, `history.goBack()`).\n    -   `useLocation`: Returns the current `location` object, which contains information about the current URL (pathname, search, hash, state).\n    -   `useParams`: Extracts parameters from the URL defined in the `Route` path (e.g., `/users/:userId`).\n\n    ![React Router Diagram](images/react_router.png)\n\nThese core components and hooks form the foundation for building robust and intuitive navigation in React applications.",
          "examples": [
            {
              "id": "example_react_router_basic",
              "title": "Basic React Router Setup",
              "code": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink } from 'react-router-dom';\n\nconst Home = () => <h2>Home Page</h2>;\nconst About = () => <h2>About Us</h2>;\nconst Contact = () => <h2>Contact Info</h2>;\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <nav>\n        <ul>\n          <li>\n            <Link to=\"/\">Home (Link)</Link>\n          </li>\n          <li>\n            <NavLink to=\"/about\" activeClassName=\"active-link\">\n              About (NavLink)\n            </NavLink>\n          </li>\n          <li>\n            <Link to=\"/contact\">Contact (Link)</Link>\n          </li>\n        </ul>\n      </nav>\n\n      <Switch>\n        <Route path=\"/about\">\n          <About />\n        </Route>\n        <Route path=\"/contact\">\n          <Contact />\n        </Route>\n        <Route path=\"/\">\n          <Home />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
              "explanation": "This example sets up a basic React Router application. `BrowserRouter` wraps the entire application, providing routing context. `Link` and `NavLink` are used for navigation, with `NavLink` demonstrating the `activeClassName` feature. `Switch` ensures that only one `Route` is rendered at a time. The `Route` components define paths and render the corresponding functional components (`Home`, `About`, `Contact`). Note that the home route (`/`) is placed last in `Switch` to prevent it from matching all paths partially.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_router_mcq_1",
            "question_router_open_1",
            "question_router_flashcard_1",
            "question_router_mcq_2",
            "question_router_mcq_3"
          ],
          "relatedTasks": [
            "task_basic_react_router_setup"
          ],
          "tags": [
            "React Router",
            "Routing",
            "SPA",
            "BrowserRouter",
            "Route",
            "Switch",
            "Link",
            "NavLink",
            "Redirect",
            "Hooks"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_lifecycle",
            "javascript_dom_events"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_advanced_routing",
            "single_page_applications"
          ]
        },
        {
          "id": "theory_react_router_parameters_hooks",
          "title": "React Router: Route Parameters and Hooks",
          "content": "React Router allows you to define dynamic segments in your URLs, known as route parameters. These parameters are placeholders in the path that can capture values from the URL, enabling you to render different content based on parts of the URL. This is essential for displaying specific data, like a user profile based on a user ID.\n\n### Key Concepts\n-   **Dynamic Segments**: Defined in the `Route` path using a colon (`:`) followed by the parameter name (e.g., `/users/:userId`). This tells React Router to match any value at that position in the URL and make it available as a parameter.\n-   **Accessing Parameters (Old/Class Components)**: In older React Router versions or class components, parameters were accessed via the `match` prop passed to the routed component. `match.params` is an object containing key-value pairs of the dynamic segments.\n-   **`useParams()` Hook (Modern/Functional Components)**: For functional components (React Router v5+), the `useParams` hook provides a more direct and cleaner way to access route parameters. It returns an object of key/value pairs of URL parameters. It is an ideal way to access parameters in functional components.\n-   **Other Useful Hooks**: While `useParams` is for route parameters, `useHistory` and `useLocation` are other important React Router hooks:\n    -   `useHistory`: Provides access to the `history` object, which allows for programmatic navigation (e.g., `history.push('/dashboard')`, `history.goBack()`).\n    -   `useLocation`: Provides access to the `location` object, which represents the current URL and contains properties like `pathname`, `search` (query parameters), `hash`, and `state` (data passed via `history.push`).\n\nRoute parameters are crucial for creating dynamic and data-driven client-side applications, allowing components to react to different parts of the URL and fetch/display relevant information.",
          "examples": [
            {
              "id": "example_router_params_class",
              "title": "Accessing Route Parameters in Class Components (match prop)",
              "code": "import React, { Component } from 'react';\nimport { Route } from 'react-router-dom';\n\n// Route definition in App component:\n// <Route path=\"/users/:userId\" component={UserProfileClass} />\n\nclass UserProfileClass extends Component {\n  render() {\n    const { userId } = this.props.match.params;\n    return (\n      <div>\n        <h2>User Profile (Class Component)</h2>\n        <p>User ID from match.params: {userId}</p>\n      </div>\n    );\n  }\n}\n\nexport default UserProfileClass;\n",
              "explanation": "This example shows how `userId` is extracted from the `match.params` object, which is passed as a prop to the `UserProfileClass` component by React Router when the route `/users/:userId` is matched. This was the traditional way of accessing parameters in class components.",
              "language": "jsx"
            },
            {
              "id": "example_router_params_hooks",
              "title": "Accessing Route Parameters with `useParams` Hook",
              "code": "import React from 'react';\nimport { useParams, Route } from 'react-router-dom';\n\n// Route definition in App component:\n// <Route path=\"/users/:userId\" component={UserProfileFunctional} />\n\nfunction UserProfileFunctional() {\n  const { userId } = useParams();\n  return (\n    <div>\n      <h2>User Profile (Functional Component)</h2>\n      <p>User ID from useParams hook: {userId}</p>\n    </div>\n  );\n}\n\nexport default UserProfileFunctional;\n",
              "explanation": "This example demonstrates the modern and recommended way to access route parameters in functional components using the `useParams` hook. The hook directly returns an object containing the route parameters, making it more concise and easier to use.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_router_params_mcq_1",
            "question_router_params_open_1",
            "question_router_params_code_1",
            "question_router_params_flashcard_1"
          ],
          "relatedTasks": [
            "task_dynamic_user_profile"
          ],
          "tags": [
            "React Router",
            "Route Parameters",
            "Hooks",
            "useParams",
            "useHistory",
            "useLocation"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_advanced_routing",
            "data_fetching"
          ]
        },
        {
          "id": "theory_react_router_nested_routes",
          "title": "React Router: Nested Routes",
          "content": "Nested routes in React Router allow you to define routes that are relative to a parent route, creating hierarchical URLs and UI structures. This is particularly useful for complex layouts where certain sections of a page (e.g., tabs, sub-sections within a user profile) change based on a deeper URL path, without reloading the entire parent component.\n\n### Key Concepts\n-   **Hierarchical UI**: Nested routes mirror a hierarchical UI structure, where a parent component might render different child components based on sub-paths.\n-   **Relative Paths**: Inside a component rendered by a parent route, you define new `<Route>` components whose `path` props are relative to the parent's matched path.\n-   **`match.path` (Class Components)**: For class components or older functional components that receive `match` prop, `match.path` contains the matched portion of the URL path for the *current* route. It's often used to construct relative nested routes (e.g., `path={`${match.path}/posts`}`).\n-   **`useRouteMatch()` Hook (Functional Components)**: In React Router v5+, the `useRouteMatch()` hook in functional components returns an object similar to the `match` prop, including `path`, `url`, `isExact`, and `params`. `match.path` (or `url`) is crucial for building nested `Route` paths and `Link` `to` props relatively.\n\n### How it Works\nWhen a parent route (e.g., `/users/:userId`) matches, its corresponding component renders. Inside this component, you can place further `<Route>` components. These nested routes will only be considered if the URL matches their combined path with the parent's path. This enables a modular approach to building complex UIs, where each level of routing controls a specific part of the application's layout.",
          "examples": [
            {
              "id": "example_router_nested_routes_class",
              "title": "Implementing Nested Routes with `match.path` (Class Component)",
              "code": "import React from 'react';\nimport { Route, Link } from 'react-router-dom';\n\nconst UserPosts = () => <h3>User Posts View</h3>;\nconst UserPhotos = () => <h3>User Photos View</h3>;\n\n// Assume this component is rendered by a parent route like: <Route path=\"/users/:userId\" component={UserProfileNestedClass} />\nclass UserProfileNestedClass extends React.Component {\n  render() {\n    const { match } = this.props;\n    return (\n      <div>\n        <h2>User Profile (Nested Routes Class)</h2>\n        <p>Current User ID: {match.params.userId}</p>\n        <nav>\n          <ul>\n            <li>\n              <Link to={`${match.url}/posts`}>View Posts</Link>\n            </li>\n            <li>\n              <Link to={`${match.url}/photos`}>View Photos</Link>\n            </li>\n          </ul>\n        </nav>\n        \n        {/* Nested Routes */}\n        <Route path={`${match.path}/posts`} component={UserPosts} />\n        <Route path={`${match.path}/photos`} component={UserPhotos} />\n        \n        {/* A default content or redirect if no nested path matches */}\n        <Route exact path={match.path}>\n            <h3>Select a sub-section above.</h3>\n        </Route>\n      </div>\n    );\n  }\n}\n\nexport default UserProfileNestedClass;\n",
              "explanation": "This example shows a `UserProfileNestedClass` component that defines nested routes for `UserPosts` and `UserPhotos`. It uses `this.props.match.path` (or `match.url` for `Link` `to` props) to construct the paths for the nested `Route` components and `Link` components. When the URL is `/users/123/posts`, `UserPosts` will be rendered, and when it's `/users/123/photos`, `UserPhotos` will be rendered. The `exact` route for `match.path` provides default content when no specific nested route is active.",
              "language": "jsx"
            },
            {
              "id": "example_router_nested_routes_hooks",
              "title": "Implementing Nested Routes with `useRouteMatch` (Functional Component)",
              "code": "import React from 'react';\nimport { Route, Link, useParams, useRouteMatch } from 'react-router-dom';\n\nconst UserPosts = () => <h3>User Posts View</h3>;\nconst UserPhotos = () => <h3>User Photos View</h3>;\n\n// Assume this component is rendered by a parent route like: <Route path=\"/users/:userId\" component={UserProfileNestedFunctional} />\nfunction UserProfileNestedFunctional() {\n  const { userId } = useParams();\n  const { path, url } = useRouteMatch(); // For v5+, useRouteMatch provides path and url\n\n  return (\n    <div>\n      <h2>User Profile (Nested Routes Functional)</h2>\n      <p>Current User ID: {userId}</p>\n      <nav>\n        <ul>\n          <li>\n            <Link to={`${url}/posts`}>View Posts</Link>\n          </li>\n          <li>\n            <Link to={`${url}/photos`}>View Photos</Link>\n          </li>\n        </ul>\n      </nav>\n\n      {/* Nested Routes */}\n      <Route path={`${path}/posts`}>\n        <UserPosts />\n      </Route>\n      <Route path={`${path}/photos`}>\n        <UserPhotos />\n      </Route>\n\n      {/* A default content or redirect if no nested path matches */}\n      <Route exact path={path}>\n          <h3>Select a sub-section above.</h3>\n      </Route>\n    </div>\n  );\n}\n\nexport default UserProfileNestedFunctional;\n",
              "explanation": "This example uses the `useRouteMatch` hook in a functional component to get the `path` and `url` for defining nested routes and links. This approach is cleaner for functional components and provides the same functionality as `match.path` and `match.url` in class components.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_nested_routes_mcq_1",
            "question_nested_routes_open_1",
            "question_nested_routes_code_1",
            "question_nested_routes_flashcard_1"
          ],
          "relatedTasks": [
            "task_nested_user_profile_routes"
          ],
          "tags": [
            "React Router",
            "Nested Routes",
            "useRouteMatch",
            "match.path",
            "Hierarchical UI"
          ],
          "technology": "React",
          "prerequisites": [
            "react_router_parameters_hooks"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_spa_architecture"
          ]
        },
        {
          "id": "theory_react_router_private_routes",
          "title": "React Router: Private Routes and Authentication",
          "content": "Private routes are a common requirement in web applications to restrict access to certain pages based on user authentication or authorization status. React Router does not inherently provide a 'private route' component out-of-the-box, but it offers the flexibility to implement this logic using a combination of its components and React's Context API or conditional rendering.\n\n### Key Concepts\n-   **Authentication Context**: A central place to manage the user's authentication state (e.g., `isLoggedIn`, `user` object) and provide functions for login and logout. React's Context API is well-suited for this, allowing state to be shared across the component tree without prop drilling.\n-   **`AuthContext.Provider`**: Makes the authentication state and functions available to all children components within its scope.\n-   **`useContext` Hook**: Allows functional components to easily consume values from a React Context, such as the `AuthContext` to check the user's login status.\n-   **Custom `PrivateRoute` Component**: This is a wrapper component that renders a standard `<Route>` component internally, but only if a user is authenticated. If the user is not authenticated, it uses the `<Redirect>` component to send them to a login page or another public route.\n-   **Conditional Rendering**: The core of a `PrivateRoute` involves conditionally rendering the protected component or a `Redirect` based on the authentication state.\n\n### Implementation Pattern\n1.  **Create an Authentication Context**: Define a Context object and an `AuthProvider` component that manages the authentication state (e.g., using `useState` for `user`). This provider will wrap your main application or routing logic.\n2.  **Implement a `PrivateRoute` Component**: This component takes the desired `component` to render when authenticated and any other `Route` props. Inside, it uses `useContext` to check the authentication status. If authenticated, it renders the provided `component` via a `Route`. If not, it renders a `Redirect` to a login page.\n3.  **Integrate with React Router**: Wrap your application with the `AuthProvider` and use your `PrivateRoute` component in place of regular `Route` for protected paths.\n\nThis pattern ensures that protected routes are inaccessible to unauthenticated users, enhancing application security and user experience by guiding users to login when necessary.",
          "examples": [
            {
              "id": "example_auth_context",
              "title": "Auth Context for Managing Authentication State",
              "code": "import { createContext, useContext, useState } from 'react';\n\n// Create a Context for authentication\nexport const AuthContext = createContext(null);\n\n// Auth Provider component to wrap the application\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null); // 'user' can be null or a user object\n\n  const login = (userData) => {\n    // In a real app, this would involve API calls, token storage etc.\n    setUser(userData || { name: 'Guest' }); // Mock user data\n    console.log('User logged in:', userData || { name: 'Guest' });\n  };\n\n  const logout = () => {\n    // In a real app, clear tokens, user session etc.\n    setUser(null);\n    console.log('User logged out.');\n  };\n\n  // The value provided to consumers of this context\n  const authContextValue = {\n    user,\n    isAuthenticated: !!user,\n    login,\n    logout\n  };\n\n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Custom hook to easily consume auth context\nexport const useAuth = () => useContext(AuthContext);\n",
              "explanation": "This code sets up an `AuthContext` using React's `createContext` and an `AuthProvider` component. The `AuthProvider` manages the `user` state and provides `login` and `logout` functions. The `user` state determines if a user is authenticated. The `useAuth` custom hook is provided for convenient consumption of the context in functional components. This context will be used by the `PrivateRoute` component to check authentication status.",
              "language": "typescript"
            },
            {
              "id": "example_private_route_component",
              "title": "Implementing a `PrivateRoute` Component",
              "code": "import React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useAuth } from './AuthContext'; // Assuming AuthContext is in AuthContext.js\n\n// A custom PrivateRoute component\nfunction PrivateRoute({ children, ...rest }) {\n  const { isAuthenticated } = useAuth();\n\n  return (\n    <Route\n      {...rest}\n      render={({ location }) =>\n        isAuthenticated ? (\n          children\n        ) : (\n          <Redirect\n            to={{\n              pathname: '/login',\n              state: { from: location } // Pass current location to redirect after login\n            }}\n          />\n        )\n      }\n    />\n  );\n}\n\nexport default PrivateRoute;\n",
              "explanation": "This `PrivateRoute` component is designed to wrap other components that should only be accessible to authenticated users. It uses the `useAuth` hook to check the `isAuthenticated` status. If the user is authenticated, it renders the `children` (the protected component). Otherwise, it uses `Redirect` to send the user to the `/login` page, also passing the original `location` in state, which can be used by the login page to redirect back after successful authentication. This pattern makes it easy to protect multiple routes in your application.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_private_routes_mcq_1",
            "question_private_routes_open_1",
            "question_private_routes_code_1",
            "question_private_routes_flashcard_1"
          ],
          "relatedTasks": [
            "task_implement_private_routes"
          ],
          "tags": [
            "React Router",
            "Authentication",
            "Private Routes",
            "Context API",
            "Conditional Rendering",
            "Authorization"
          ],
          "technology": "React",
          "prerequisites": [
            "react_context_api",
            "react_router_core_concepts"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "secure_spa_development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_form_mcq_1",
          "topic": "Controlled Components in React Forms",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the primary purpose of a controlled component in React forms?",
          "answer": "To allow React state to be the single source of truth for the input's value.",
          "options": [
            "To enable direct DOM manipulation for input values.",
            "To allow React state to be the single source of truth for the input's value.",
            "To automatically synchronize input values with the browser's local storage.",
            "To prevent any user input from being entered into the form field."
          ],
          "analysisPoints": [
            "Tests understanding of controlled component definition.",
            "Distinguishes between direct DOM manipulation and React state control.",
            "Highlights the 'single source of truth' principle in React."
          ],
          "keyConcepts": [
            "Controlled Components",
            "React State",
            "Single Source of Truth",
            "Form Handling"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles of React forms.",
            "Ability to distinguish between correct and incorrect paradigms."
          ],
          "example": "In a controlled component, the `value` prop of an input element is bound to `this.state.someValue`, and the `onChange` handler updates `this.state.someValue`. This ensures that the input's value always reflects what's in the React state.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "State Management"
          ],
          "prerequisites": [
            "react_basics",
            "react_state"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_form_open_1",
          "topic": "Controlled vs. Uncontrolled Components",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between controlled and uncontrolled components in React forms. When would you choose one over the other, and why are controlled components generally preferred?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Definition of controlled components (value tied to state, onChange updates state).",
            "Definition of uncontrolled components (value managed by DOM, useRef/ref to access).",
            "Pros/Cons of each (e.g., validation, instant feedback for controlled; simpler for simple forms for uncontrolled).",
            "Reasons for preference: controlled components provide more control over form data, easier validation, instant feedback, and better integration with React's data flow.",
            "Edge cases where uncontrolled might be acceptable (e.g., file inputs, very simple forms where initial value is not important)."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "React Forms",
            "State Management",
            "Refs",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of both paradigms.",
            "Ability to articulate their trade-offs.",
            "Knowledge of best practices and justifications."
          ],
          "example": "A controlled input will look like `<input value={this.state.inputVal} onChange={this.handleChange} />`. An uncontrolled input might use `<input type='file' ref={fileInputRef} />` and access `fileInputRef.current.files[0]` on submission.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Uncontrolled Components",
            "State Management"
          ],
          "prerequisites": [
            "react_basics",
            "react_state",
            "react_refs"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_code_1",
          "topic": "Implementing a Controlled Input Field",
          "level": "medium",
          "type": "code",
          "question": "Implement a functional React component called `EmailInput` that renders a single email input field. This input should be a controlled component. The component should manage its own state for the email value and display the current email value below the input in a paragraph tag. Ensure that the `onChange` handler correctly updates the state.",
          "answer": "```javascript\nimport React, { useState } from 'react';\n\nfunction EmailInput() {\n  const [email, setEmail] = useState('');\n\n  const handleEmailChange = (event) => {\n    setEmail(event.target.value);\n  };\n\n  return (\n    <div>\n      <label htmlFor=\"email-field\">Email:</label>\n      <input\n        type=\"email\"\n        id=\"email-field\"\n        value={email}\n        onChange={handleEmailChange}\n        placeholder=\"Enter your email\"\n      />\n      <p>Current Email: {email}</p>\n    </div>\n  );\n}\n\nexport default EmailInput;\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `useState` hook for state management.",
            "Binding `value` prop to state.",
            "Implementing `onChange` handler to update state.",
            "Accessibility considerations (e.g., `htmlFor`, `id`)."
          ],
          "keyConcepts": [
            "React Hooks",
            "useState",
            "Controlled Components",
            "Event Handling",
            "Forms"
          ],
          "evaluationCriteria": [
            "Ability to write functional React components.",
            "Correct implementation of controlled input logic.",
            "Understanding of basic state management with hooks."
          ],
          "example": null,
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Hooks",
            "useState"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_flashcard_1",
          "topic": "Controlled Component Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a 'controlled component' in React forms?",
          "answer": "An input form element whose value is controlled by React state.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Controlled Components",
            "React Forms",
            "State Management"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React",
            "Forms",
            "Controlled Components"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_mcq_1",
          "topic": "React Router Core Components",
          "level": "easy",
          "type": "mcq",
          "question": "Which React Router component is used to ensure that only the *first* matching `Route` is rendered at any given time?",
          "answer": "Switch",
          "options": [
            "BrowserRouter",
            "Link",
            "Switch",
            "Route"
          ],
          "analysisPoints": [
            "Tests knowledge of `Switch` component's primary function.",
            "Distinguishes `Switch` from other core routing components."
          ],
          "keyConcepts": [
            "React Router",
            "Switch Component",
            "Route Matching"
          ],
          "evaluationCriteria": [
            "Basic understanding of React Router components."
          ],
          "example": "```jsx\n<Switch>\n  <Route path=\"/about\">About</Route>\n  <Route path=\"/\">Home</Route> {/* Without Switch, this might also match /about */}\n</Switch>\n```",
          "tags": [
            "React Router",
            "Switch",
            "Routing"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_open_1",
          "topic": "Benefits of React Router",
          "level": "medium",
          "type": "open",
          "question": "Discuss the main advantages of using a client-side routing library like React Router in a Single Page Application (SPA) compared to traditional server-side rendering for navigation.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Faster navigation (no full page reload).",
            "Better user experience (smoother transitions, instant feedback).",
            "Ability to build rich, interactive UIs without server requests for every navigation.",
            "Decoupling of frontend and backend logic (API-driven).",
            "Easier state management across route changes.",
            "Supports dynamic client-side content updates.",
            "SEO challenges and solutions (e.g., server-side rendering, pre-rendering)."
          ],
          "keyConcepts": [
            "Client-Side Routing",
            "Single Page Application (SPA)",
            "User Experience (UX)",
            "Performance",
            "React Router"
          ],
          "evaluationCriteria": [
            "Understanding of SPA architecture benefits.",
            "Ability to compare client-side vs. server-side routing.",
            "Recognition of trade-offs and advanced considerations like SEO."
          ],
          "example": "Navigating from `/products` to `/products/123` in an SPA often involves only updating a small part of the DOM, without fetching a new HTML page, unlike traditional multi-page applications.",
          "tags": [
            "React Router",
            "SPA",
            "Performance",
            "UX",
            "Routing Architecture"
          ],
          "prerequisites": [
            "web_basics",
            "spa_concept"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_mcq_2",
          "topic": "Link vs NavLink",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React Router components:\n\n```jsx\nimport { Link, NavLink } from 'react-router-dom';\n\n// Component 1\n<Link to=\"/dashboard\">Dashboard</Link>\n\n// Component 2\n<NavLink to=\"/profile\" activeClassName=\"is-active\">\n  Profile\n</NavLink>\n```\n\nWhat is the primary distinguishing feature of `NavLink` compared to `Link`?",
          "answer": "`NavLink` can automatically apply styling (like an `activeClassName`) when its `to` prop matches the current URL.",
          "options": [
            "`NavLink` can only be used with functional components, while `Link` is for class components.",
            "`Link` causes a full page reload, whereas `NavLink` does not.",
            "`NavLink` automatically applies styling (like an `activeClassName`) when its `to` prop matches the current URL.",
            "`Link` supports nested routes, but `NavLink` does not."
          ],
          "analysisPoints": [
            "Tests understanding of `NavLink`'s specific styling capability.",
            "Clarifies that both are for client-side navigation without full reloads.",
            "Correctly identifies the `activeClassName` (or `activeStyle`) feature."
          ],
          "keyConcepts": [
            "React Router",
            "Link",
            "NavLink",
            "Active Styling",
            "Navigation"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between similar React Router components.",
            "Knowledge of `NavLink`'s specific use case."
          ],
          "example": "If the current URL is `/profile`, the `NavLink` will have the `is-active` class applied, which can be styled via CSS to highlight the active navigation item.",
          "tags": [
            "React Router",
            "NavLink",
            "Link",
            "Navigation",
            "Styling"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_mcq_3",
          "topic": "BrowserRouter Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following best describes the role of `BrowserRouter` in a React application using React Router?",
          "answer": "It uses the HTML5 history API to keep the UI in sync with the URL, enabling client-side routing.",
          "options": [
            "It is used to define dynamic segments in the URL for route parameters.",
            "It renders only the first child Route that matches the current location.",
            "It uses the HTML5 history API to keep the UI in sync with the URL, enabling client-side routing.",
            "It provides declarative navigation around the application via standard `<a>` tags."
          ],
          "analysisPoints": [
            "Tests understanding of `BrowserRouter` as the foundational router.",
            "Distinguishes its role from `Route`, `Switch`, and `Link`.",
            "Emphasizes its reliance on the HTML5 History API."
          ],
          "keyConcepts": [
            "React Router",
            "BrowserRouter",
            "HTML5 History API",
            "Client-Side Routing",
            "SPA"
          ],
          "evaluationCriteria": [
            "Basic understanding of the core routing context provider.",
            "Ability to identify the correct mechanism for URL synchronization."
          ],
          "example": "Typically, your `App` component or the root of your routing structure will be wrapped in `<BrowserRouter>`, like `<BrowserRouter><App /></BrowserRouter>`, to enable all other router functionalities.",
          "tags": [
            "React Router",
            "BrowserRouter",
            "Routing Context"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_flashcard_1",
          "topic": "React Router `Redirect`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary function of the `<Redirect>` component in React Router?",
          "answer": "To programmatically navigate the user to a new location.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router",
            "Redirect",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React Router",
            "Redirect"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_params_mcq_1",
          "topic": "Accessing Route Parameters with Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "Given a React Router `Route` defined as `<Route path=\"/products/:productId\" component={ProductDetail} />`, which hook would you use in the `ProductDetail` functional component to access the `productId`?",
          "answer": "useParams()",
          "options": [
            "useHistory()",
            "useLocation()",
            "useParams()",
            "useRouteMatch()"
          ],
          "analysisPoints": [
            "Tests specific knowledge of React Router hooks for parameters.",
            "Differentiates `useParams` from other context-related hooks.",
            "Understands the direct purpose of `useParams`."
          ],
          "keyConcepts": [
            "React Router Hooks",
            "useParams",
            "Route Parameters",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Correct identification of the relevant hook.",
            "Understanding of hook functionalities."
          ],
          "example": "```jsx\nimport { useParams } from 'react-router-dom';\n\nfunction ProductDetail() {\n  const { productId } = useParams();\n  return <div>Product ID: {productId}</div>;\n}\n```",
          "tags": [
            "React Router",
            "Hooks",
            "useParams",
            "Route Parameters"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_params_open_1",
          "topic": "When to Use Specific React Router Hooks",
          "level": "hard",
          "type": "open",
          "question": "You are building a complex dashboard application. Describe a scenario where you would specifically choose to use `useHistory()`, `useLocation()`, and `useParams()` respectively. Provide a brief code snippet for each scenario.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Clear scenario for `useHistory` (e.g., programmatic navigation after form submission, back/forward buttons).",
            "Clear scenario for `useLocation` (e.g., reading query parameters, accessing state passed during navigation, conditional rendering based on pathname).",
            "Clear scenario for `useParams` (e.g., fetching data for a specific item, displaying dynamic user profiles).",
            "Correct example usage for each hook.",
            "Understanding of the `location` object properties (`pathname`, `search`, `hash`, `state`)."
          ],
          "keyConcepts": [
            "React Router Hooks",
            "useHistory",
            "useLocation",
            "useParams",
            "Programmatic Navigation",
            "Query Parameters",
            "Route Parameters",
            "Location Object"
          ],
          "evaluationCriteria": [
            "In-depth understanding of each hook's purpose.",
            "Ability to apply hooks to realistic scenarios.",
            "Correct code syntax for hook usage."
          ],
          "example": "```jsx\n// useHistory:\nimport { useHistory } from 'react-router-dom';\nfunction LogoutButton() {\n  const history = useHistory();\n  const handleLogout = () => { /* logout logic */ history.push('/login'); };\n  return <button onClick={handleLogout}>Logout</button>;\n}\n\n// useLocation:\nimport { useLocation } from 'react-router-dom';\nfunction SearchResults() {\n  const location = useLocation();\n  const queryParams = new URLSearchParams(location.search);\n  const query = queryParams.get('q');\n  return <div>Search results for: {query}</div>;\n}\n\n// useParams:\nimport { useParams } from 'react-router-dom';\n// Route: /books/:id\nfunction BookDetail() {\n  const { id } = useParams();\n  return <div>Details for Book ID: {id}</div>;\n}\n```",
          "tags": [
            "React Router",
            "Hooks",
            "useHistory",
            "useLocation",
            "useParams",
            "Programmatic Navigation"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_router_params_code_1",
          "topic": "Extracting Parameters from URL",
          "level": "medium",
          "type": "code",
          "question": "Write a functional React component named `CoursePage` that displays the `courseId` from the URL. Assume the `Route` for this component is defined as `/courses/:courseId`. Your component should use the appropriate React Router hook to access this parameter and display it within an `<h2>` tag.",
          "answer": "```javascript\nimport React from 'react';\nimport { useParams } from 'react-router-dom';\n\nfunction CoursePage() {\n  const { courseId } = useParams();\n\n  return (\n    <div>\n      <h2>Course ID: {courseId}</h2>\n      <p>Welcome to the detail page for this course.</p>\n    </div>\n  );\n}\n\nexport default CoursePage;\n```",
          "options": [],
          "analysisPoints": [
            "Correct import of `useParams`.",
            "Destructuring the parameter from the `useParams` hook's return value.",
            "Rendering the parameter in the component's JSX."
          ],
          "keyConcepts": [
            "React Router Hooks",
            "useParams",
            "Route Parameters",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to use `useParams` correctly.",
            "Demonstrates understanding of dynamic routing segments."
          ],
          "example": null,
          "tags": [
            "React Router",
            "Hooks",
            "useParams",
            "Route Parameters"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_params_flashcard_1",
          "topic": "useParams Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What does the `useParams()` hook in React Router return?",
          "answer": "An object of key/value pairs of URL parameters.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router",
            "useParams",
            "Route Parameters",
            "Hooks"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React Router",
            "Hooks",
            "useParams"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_nested_routes_mcq_1",
          "topic": "Purpose of `match.path` / `useRouteMatch().path` in Nested Routes",
          "level": "medium",
          "type": "mcq",
          "question": "When defining nested routes within a component, why is `match.path` (or `useRouteMatch().path` for functional components) typically used to construct the paths for the child `Route` components?",
          "answer": "To ensure that the nested routes are relative to the parent route's matched path, making them work correctly within the hierarchical structure.",
          "options": [
            "To force a full page reload when navigating to a nested route.",
            "To extract query parameters from the URL for the nested component.",
            "To ensure that the nested routes are relative to the parent route's matched path, making them work correctly within the hierarchical structure.",
            "To provide a unique key for each nested route for performance optimization."
          ],
          "analysisPoints": [
            "Tests understanding of relative paths in nested routing.",
            "Explains the role of `match.path` in building hierarchical URLs.",
            "Distinguishes its purpose from other routing functionalities."
          ],
          "keyConcepts": [
            "React Router",
            "Nested Routes",
            "match.path",
            "useRouteMatch",
            "Relative Paths"
          ],
          "evaluationCriteria": [
            "Correctly identifies the function of `match.path` in nested routing.",
            "Understands the concept of relative route definitions."
          ],
          "example": "If the parent route is `/users/:userId` and `match.path` is `/users/:userId`, then a nested route `path={`${match.path}/posts`}` would resolve to `/users/:userId/posts`.",
          "tags": [
            "React Router",
            "Nested Routes",
            "match.path",
            "useRouteMatch"
          ],
          "prerequisites": [
            "react_router_core_concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nested_routes_open_1",
          "topic": "Designing a UI with Nested Routes",
          "level": "hard",
          "type": "open",
          "question": "You are tasked with designing a user profile page that has multiple sub-sections (e.g., 'Overview', 'Settings', 'Activity Log'). How would you leverage React Router's nested routing capabilities to implement this, ensuring a clean URL structure and efficient component rendering? Outline the component structure and the routing logic.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "High-level component structure (e.g., `UserProfile` parent, `UserOverview`, `UserSettings`, `UserActivityLog` children).",
            "Parent `Route` definition (e.g., `/users/:id`).",
            "Use of `useRouteMatch` (or `match.path`) in the `UserProfile` component to define child routes.",
            "Use of `Link` or `NavLink` within `UserProfile` for sub-navigation, also using `match.url` for relative links.",
            "Consideration for a default nested route or redirect when no sub-section is selected.",
            "Benefits: modularity, performance (only re-renders sub-section), clear URLs."
          ],
          "keyConcepts": [
            "React Router",
            "Nested Routes",
            "URL Structure",
            "Component Design",
            "useRouteMatch",
            "Link/NavLink"
          ],
          "evaluationCriteria": [
            "Ability to design a multi-page UI using nested routes.",
            "Correct application of `useRouteMatch` and relative paths.",
            "Understanding of practical benefits of nested routing."
          ],
          "example": "```jsx\n// App.js\n<Route path=\"/users/:userId\">\n  <UserProfile />\n</Route>\n\n// UserProfile.js\nimport { useParams, useRouteMatch, Link, Route, Switch } from 'react-router-dom';\nfunction UserProfile() {\n  const { userId } = useParams();\n  const { path, url } = useRouteMatch();\n  return (\n    <div>\n      <h1>User: {userId}</h1>\n      <nav>\n        <Link to={`${url}`}>Overview</Link>\n        <Link to={`${url}/settings`}>Settings</Link>\n        <Link to={`${url}/activity`}>Activity Log</Link>\n      </nav>\n      <Switch>\n        <Route exact path={path} component={UserOverview} />\n        <Route path={`${path}/settings`} component={UserSettings} />\n        <Route path={`${path}/activity`} component={UserActivityLog} />\n      </Switch>\n    </div>\n  );\n}\n```",
          "tags": [
            "React Router",
            "Nested Routes",
            "Architecture",
            "Design Patterns"
          ],
          "prerequisites": [
            "react_router_parameters_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_nested_routes_code_1",
          "topic": "Implementing Nested Routes",
          "level": "medium",
          "type": "code",
          "question": "Create a functional React component named `Dashboard` that serves as a parent for nested routes. Inside `Dashboard`, define two nested routes: `/dashboard/analytics` and `/dashboard/reports`. Each nested route should render a simple functional component (`AnalyticsPage` and `ReportsPage` respectively). Use `useRouteMatch` to correctly construct the nested paths. Include `Link` components to navigate between these sub-sections.",
          "answer": "```javascript\nimport React from 'react';\nimport { Switch, Route, Link, useRouteMatch } from 'react-router-dom';\n\nconst AnalyticsPage = () => <h3>Dashboard Analytics</h3>;\nconst ReportsPage = () => <h3>Dashboard Reports</h3>;\nconst DefaultDashboard = () => <h3>Welcome to your Dashboard! Select a section.</h3>;\n\nfunction Dashboard() {\n  const { path, url } = useRouteMatch();\n\n  return (\n    <div>\n      <h2>Main Dashboard</h2>\n      <nav>\n        <ul>\n          <li><Link to={`${url}`}>Overview</Link></li>\n          <li><Link to={`${url}/analytics`}>Analytics</Link></li>\n          <li><Link to={`${url}/reports`}>Reports</Link></li>\n        </ul>\n      </nav>\n\n      <Switch>\n        <Route exact path={path} component={DefaultDashboard} />\n        <Route path={`${path}/analytics`} component={AnalyticsPage} />\n        <Route path={`${path}/reports`} component={ReportsPage} />\n      </Switch>\n    </div>\n  );\n}\n\nexport default Dashboard;\n\n// Example usage in your main App.js:\n// <Route path=\"/dashboard\" component={Dashboard} />\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `useRouteMatch` to get `path` and `url`.",
            "Properly constructs nested `Route` paths using `path`.",
            "Correctly constructs `Link` `to` props using `url`.",
            "Uses `Switch` to ensure only one nested route renders.",
            "Includes an `exact` route for the base path to show default content."
          ],
          "keyConcepts": [
            "React Router",
            "Nested Routes",
            "useRouteMatch",
            "Link",
            "Switch",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to implement nested routing.",
            "Correct application of `useRouteMatch`.",
            "Logical flow of navigation within a nested context."
          ],
          "example": null,
          "tags": [
            "React Router",
            "Nested Routes",
            "Hooks",
            "useRouteMatch",
            "Link"
          ],
          "prerequisites": [
            "react_router_parameters_hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_nested_routes_flashcard_1",
          "topic": "Nested Routes `path` vs `url`",
          "level": "medium",
          "type": "flashcard",
          "question": "In React Router's `useRouteMatch()` hook, what is the difference between `path` and `url`?",
          "answer": "`path` is the string pattern used for matching (e.g., `/users/:userId`), while `url` is the actual matched URL string (e.g., `/users/123`). `path` is typically used for defining nested `<Route>` paths, and `url` for constructing `Link` `to` props.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router",
            "useRouteMatch",
            "path",
            "url",
            "Nested Routes"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React Router",
            "Hooks",
            "Nested Routes"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_private_routes_mcq_1",
          "topic": "Redirecting Unauthenticated Users",
          "level": "medium",
          "type": "mcq",
          "question": "When implementing a `PrivateRoute` component in React Router, which component is typically used to send an unauthenticated user to a login page?",
          "answer": "Redirect",
          "options": [
            "Link",
            "NavLink",
            "Route",
            "Redirect"
          ],
          "analysisPoints": [
            "Tests knowledge of the `Redirect` component's programmatic navigation capability.",
            "Differentiates `Redirect` from components used for declarative navigation or route matching."
          ],
          "keyConcepts": [
            "React Router",
            "Private Routes",
            "Redirect",
            "Authentication"
          ],
          "evaluationCriteria": [
            "Correctly identifies the component for programmatic redirection.",
            "Understanding of basic private route implementation strategy."
          ],
          "example": "```jsx\n// Inside PrivateRoute component\nreturn isAuthenticated ? <Route {...rest} /> : <Redirect to=\"/login\" />;\n```",
          "tags": [
            "React Router",
            "Private Routes",
            "Redirect",
            "Authentication"
          ],
          "prerequisites": [
            "react_router_core_concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_private_routes_open_1",
          "topic": "Designing a Private Route System",
          "level": "hard",
          "type": "open",
          "question": "You need to implement a private route system for an e-commerce application where `/admin` and `/checkout` paths should only be accessible to logged-in users. Describe how you would design and implement this using React Router and React's Context API. Include the role of `AuthContext`, `AuthProvider`, and a custom `PrivateRoute` component.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explanation of `AuthContext` and `AuthProvider` for centralized auth state (`user`, `login`, `logout`).",
            "Details on the `PrivateRoute` component: accepting `children` or `component` prop, checking auth status via `useContext(AuthContext)`, and conditionally rendering `children` or `Redirect`.",
            "How `PrivateRoute` integrates with main `App` routing (wrapping specific `Route` definitions).",
            "Handling redirect with `location.state` to return to original path after login.",
            "Consideration of loading states or fallbacks."
          ],
          "keyConcepts": [
            "React Router",
            "Private Routes",
            "Authentication",
            "Context API",
            "AuthProvider",
            "PrivateRoute Component",
            "Redirect"
          ],
          "evaluationCriteria": [
            "Comprehensive design for a private routing system.",
            "Correct application of Context API and React Router components.",
            "Ability to articulate the flow of authentication and redirection.",
            "Understanding of passing location state for post-login redirects."
          ],
          "example": "```jsx\n// index.js (or App.js)\nimport { AuthProvider } from './AuthContext';\nimport AppRouter from './AppRouter';\n<AuthProvider><AppRouter /></AuthProvider>\n\n// AppRouter.js\nimport { Switch, Route } from 'react-router-dom';\nimport PrivateRoute from './PrivateRoute';\n\nconst LoginPage = () => <div>Login</div>;\nconst AdminPage = () => <div>Admin Dashboard</div>;\nconst CheckoutPage = () => <div>Checkout</div>;\n\nfunction AppRouter() {\n  return (\n    <Switch>\n      <Route path=\"/login\" component={LoginPage} />\n      <PrivateRoute path=\"/admin\" component={AdminPage} />\n      <PrivateRoute path=\"/checkout\" component={CheckoutPage} />\n      {/* ...other public routes... */}\n    </Switch>\n  );\n}\n```",
          "tags": [
            "React Router",
            "Private Routes",
            "Authentication",
            "Context API",
            "Architecture"
          ],
          "prerequisites": [
            "react_context_api",
            "react_router_core_concepts"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_private_routes_code_1",
          "topic": "AuthContext Implementation",
          "level": "medium",
          "type": "code",
          "question": "Complete the `AuthContext` and `AuthProvider` implementation. The `AuthProvider` should manage a `user` state (initially `null`). Implement `login` and `logout` functions that update this state. The context value should expose `user`, a boolean `isAuthenticated`, and the `login`/`logout` functions. Also, provide a `useAuth` custom hook.",
          "answer": "```javascript\nimport { createContext, useContext, useState, useEffect } from 'react';\n\nexport const AuthContext = createContext(null);\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true); // Optional: for initial auth check\n\n  // Simulate an initial check for a logged-in user, e.g., from localStorage\n  useEffect(() => {\n    const storedUser = localStorage.getItem('currentUser');\n    if (storedUser) {\n      setUser(JSON.parse(storedUser));\n    }\n    setLoading(false);\n  }, []);\n\n  const login = (userData) => {\n    // In a real app, send credentials to backend, get token, set user\n    const newUser = { id: '1', name: userData.username || 'Test User' };\n    setUser(newUser);\n    localStorage.setItem('currentUser', JSON.stringify(newUser)); // Simulate persisting login\n  };\n\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('currentUser'); // Simulate clearing session\n  };\n\n  const authContextValue = {\n    user,\n    isAuthenticated: !!user,\n    login,\n    logout,\n    loading // Useful for waiting on initial auth check\n  };\n\n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {!loading ? children : <div>Loading authentication...</div>}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `createContext` and `useContext`.",
            "Proper state management for `user` within `AuthProvider`.",
            "Implementation of `login` and `logout` functions.",
            "Exposing correct values via context provider (`user`, `isAuthenticated`, `login`, `logout`).",
            "Creation of a `useAuth` custom hook for convenience.",
            "Consideration of loading state for initial authentication check (optional but good practice)."
          ],
          "keyConcepts": [
            "React Context API",
            "createContext",
            "useContext",
            "useState",
            "Authentication",
            "AuthProvider",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Ability to implement Context API pattern.",
            "Correct state management and function exposure.",
            "Demonstrates understanding of authentication flow at a high level."
          ],
          "example": null,
          "tags": [
            "React",
            "Context API",
            "Authentication",
            "State Management",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_context_api"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_private_routes_flashcard_1",
          "topic": "Purpose of `AuthContext.Provider`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the role of `AuthContext.Provider` in setting up a private routing system?",
          "answer": "It makes the authentication state and functions (like login/logout) available to all children components within its scope.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Context API",
            "AuthContext.Provider",
            "Authentication",
            "State Sharing"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React",
            "Context API",
            "Private Routes"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_controlled_form_validation",
          "title": "Implement a Controlled Registration Form with Basic Validation",
          "description": "\nCreate a functional React component called `RegistrationForm`. This form should include:\n\n1.  **Input Fields**: `username` (text), `email` (email type), and `password` (password type).\n2.  **Controlled Components**: All input fields must be controlled components, managing their values via `useState`.\n3.  **Basic Validation**: Implement client-side validation logic.\n    *   `username`: Must not be empty.\n    *   `email`: Must be a valid email format (simple regex check is sufficient, e.g., `@` and `.` presence).\n    *   `password`: Must be at least 6 characters long.\n4.  **Error Display**: Display appropriate error messages below each input field if validation fails when the user tries to submit the form.\n5.  **Submission Logic**: On form submission, prevent the default behavior. If all fields are valid, log the form data to the console and display a success message (e.g., an alert). If invalid, display the errors.\n6.  **Reset Form**: After successful submission, clear the form fields.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction RegistrationForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: ''\n  });\n\n  const [errors, setErrors] = useState({});\n  const [submissionMessage, setSubmissionMessage] = useState('');\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    // Clear error for the field as user types\n    if (errors[name]) {\n        setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  };\n\n  const validateForm = () => {\n    let newErrors = {};\n    if (!formData.username.trim()) {\n      newErrors.username = 'Username is required';\n    }\n    if (!formData.email.includes('@') || !formData.email.includes('.')) {\n      newErrors.email = 'Please enter a valid email';\n    }\n    if (formData.password.length < 6) {\n      newErrors.password = 'Password must be at least 6 characters long';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    setSubmissionMessage(''); // Clear previous messages\n\n    if (validateForm()) {\n      console.log('Form Submitted Successfully:', formData);\n      setSubmissionMessage('Registration successful!');\n      setFormData({\n        username: '',\n        email: '',\n        password: ''\n      });\n    } else {\n      setSubmissionMessage('Please correct the errors.');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Register</h2>\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input\n            type=\"text\"\n            id=\"username\"\n            name=\"username\"\n            value={formData.username}\n            onChange={handleChange}\n          />\n          {errors.username && <p style={{ color: 'red' }}>{errors.username}</p>}\n        </div>\n        <div>\n          <label htmlFor=\"email\">Email:</label>\n          <input\n            type=\"email\"\n            id=\"email\"\n            name=\"email\"\n            value={formData.email}\n            onChange={handleChange}\n          />\n          {errors.email && <p style={{ color: 'red' }}>{errors.email}</p>}\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input\n            type=\"password\"\n            id=\"password\"\n            name=\"password\"\n            value={formData.password}\n            onChange={handleChange}\n          />\n          {errors.password && <p style={{ color: 'red' }}>{errors.password}</p>}\n        </div>\n        <button type=\"submit\">Register</button>\n      </form>\n      {submissionMessage && <p style={{ color: submissionMessage.includes('successful') ? 'green' : 'orange' }}>{submissionMessage}</p>}\n    </div>\n  );\n}\n\nexport default RegistrationForm;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction RegistrationForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: ''\n  });\n\n  const [errors, setErrors] = useState({});\n  const [submissionMessage, setSubmissionMessage] = useState('');\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    // Clear error for the field as user types\n    if (errors[name]) {\n        setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  };\n\n  const validateForm = () => {\n    let newErrors = {};\n    if (!formData.username.trim()) {\n      newErrors.username = 'Username is required';\n    }\n    // Simple email regex, could be more robust\n    if (!/^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$/g.test(formData.email)) {\n      newErrors.email = 'Please enter a valid email address';\n    }\n    if (formData.password.length < 6) {\n      newErrors.password = 'Password must be at least 6 characters long';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    setSubmissionMessage('');\n\n    if (validateForm()) {\n      console.log('Form Submitted Successfully:', formData);\n      setSubmissionMessage('Registration successful! Check console for data.');\n      setFormData({\n        username: '',\n        email: '',\n        password: ''\n      });\n      setErrors({}); // Clear errors on success\n    } else {\n      setSubmissionMessage('Please correct the errors before submitting.');\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px', maxWidth: '400px', margin: '20px auto' }}>\n      <h2>Register</h2>\n      <form onSubmit={handleSubmit}>\n        <div style={{ marginBottom: '15px' }}>\n          <label htmlFor=\"username\" style={{ display: 'block', marginBottom: '5px' }}>Username:</label>\n          <input\n            type=\"text\"\n            id=\"username\"\n            name=\"username\"\n            value={formData.username}\n            onChange={handleChange}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n          {errors.username && <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>{errors.username}</p>}\n        </div>\n        <div style={{ marginBottom: '15px' }}>\n          <label htmlFor=\"email\" style={{ display: 'block', marginBottom: '5px' }}>Email:</label>\n          <input\n            type=\"email\"\n            id=\"email\"\n            name=\"email\"\n            value={formData.email}\n            onChange={handleChange}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n          {errors.email && <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>{errors.email}</p>}\n        </div>\n        <div style={{ marginBottom: '20px' }}>\n          <label htmlFor=\"password\" style={{ display: 'block', marginBottom: '5px' }}>Password:</label>\n          <input\n            type=\"password\"\n            id=\"password\"\n            name=\"password\"\n            value={formData.password}\n            onChange={handleChange}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n          {errors.password && <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>{errors.password}</p>}\n        </div>\n        <button type=\"submit\" style={{ padding: '10px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>Register</button>\n      </form>\n      {submissionMessage && <p style={{ color: submissionMessage.includes('successful') ? 'green' : 'orange', marginTop: '15px' }}>{submissionMessage}</p>}\n    </div>\n  );\n}\n\nexport default RegistrationForm;\n",
          "testCases": [
            "Test 1: All fields empty - Should show all 'required' or validation error messages.",
            "Test 2: Invalid email format (e.g., 'test@' or 'test.com') - Should show 'valid email' error.",
            "Test 3: Password less than 6 chars (e.g., 'abc') - Should show 'password length' error.",
            "Test 4: All fields valid - Should log data, show success message, and clear form.",
            "Test 5: User types into a field after an error is shown - Error for that specific field should disappear as typing starts."
          ],
          "hints": [
            "Use a single `useState` object for all form data, and another for errors.",
            "The `name` attribute of input fields can be useful for dynamic state updates in a single `handleChange` function.",
            "Remember to call `event.preventDefault()` in `handleSubmit`.",
            "Consider placing validation logic in a separate function to keep `handleSubmit` clean."
          ],
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Validation",
            "useState",
            "Event Handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics",
            "theory_react_form_handling_class_components"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "controlled_components",
            "form_validation",
            "state_management_hooks"
          ]
        },
        {
          "id": "task_basic_react_router_setup",
          "title": "Build a Simple SPA with React Router Navigation",
          "description": "\nCreate a React application with three main pages using React Router:\n\n1.  **Home Page (`/`)**: A simple page with a welcome message.\n2.  **About Page (`/about`)**: A page describing the application or company.\n3.  **Contact Page (`/contact`)**: A page with contact information.\n\n**Requirements:**\n*   Use `BrowserRouter` to wrap your main application components.\n*   Implement navigation using `Link` components for Home and Contact pages.\n*   Implement navigation for the About page using a `NavLink` component. Configure `NavLink` to apply an `active-link` CSS class when the About page is active.\n*   Use `Switch` to ensure only one route is rendered at a time.\n*   Ensure the Home route (`/`) is handled correctly even when other routes match partially.\n*   Create simple functional components for each page.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink } from 'react-router-dom';\n\n// Create your page components here\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome Home!</h2>\n      <p>This is the home page of our simple SPA.</p>\n    </div>\n  );\n};\n\nconst AboutPage = () => {\n  return (\n    <div>\n      <h2>About Us</h2>\n      <p>Learn more about our mission and values.</p>\n    </div>\n  );\n};\n\nconst ContactPage = () => {\n  return (\n    <div>\n      <h2>Contact Us</h2>\n      <p>Reach out to us via email or phone.</p>\n    </div>\n  );\n};\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <nav>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* Implement Link for Home */}\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* Implement NavLink for About with activeClassName */}\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* Implement Link for Contact */}\n          </li>\n        </ul>\n      </nav>\n\n      {/* Implement Switch and Routes here */}\n      <div>\n\n      </div>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n\n// Add some basic CSS for .active-link\n// body {\n//   font-family: sans-serif;\n// }\n// .active-link {\n//   font-weight: bold;\n//   color: blue;\n//   text-decoration: underline;\n// }\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome Home!</h2>\n      <p>This is the home page of our simple SPA.</p>\n    </div>\n  );\n};\n\nconst AboutPage = () => {\n  return (\n    <div>\n      <h2>About Us</h2>\n      <p>Learn more about our mission and values.</p>\n    </div>\n  );\n};\n\nconst ContactPage = () => {\n  return (\n    <div>\n      <h2>Contact Us</h2>\n      <p>Reach out to us via email or phone.</p>\n    </div>\n  );\n};\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <nav>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            <Link to=\"/\">Home</Link>\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            <NavLink to=\"/about\" activeClassName=\"active-link\">\n              About\n            </NavLink>\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            <Link to=\"/contact\">Contact</Link>\n          </li>\n        </ul>\n      </nav>\n\n      <div>\n        <Switch>\n          {/* Specific routes first */}\n          <Route path=\"/about\" component={AboutPage} />\n          <Route path=\"/contact\" component={ContactPage} />\n          {/* Exact home route last to avoid matching other paths partially */}\n          <Route exact path=\"/\" component={HomePage} />\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
          "testCases": [
            "Test 1: Navigate to '/' - Home page should be displayed, Home link should not be active (if Link is used, which it is in solution).",
            "Test 2: Navigate to '/about' - About page should be displayed, 'About' NavLink should have 'active-link' class.",
            "Test 3: Navigate to '/contact' - Contact page should be displayed.",
            "Test 4: Directly access '/invalid-path' - Should not match any of the defined routes and thus show nothing (or a 404 if implemented)."
          ],
          "hints": [
            "Remember to import all necessary components from `react-router-dom`.",
            "The `exact` prop on a `Route` is crucial for the home page to prevent it from matching other paths.",
            "For `NavLink`, the `activeClassName` prop is how you specify the class to apply."
          ],
          "tags": [
            "React Router",
            "SPA",
            "Navigation",
            "BrowserRouter",
            "Route",
            "Switch",
            "Link",
            "NavLink"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_basics",
            "theory_react_router_core_concepts"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "relatedConcepts": [
            "client_side_routing",
            "declarative_navigation"
          ]
        },
        {
          "id": "task_dynamic_user_profile",
          "title": "Create a User Profile Page with Dynamic Parameters",
          "description": "\nExtend the previous React Router application (or start a new one if preferred) to include a dynamic user profile page.\n\n**Requirements:**\n*   Define a route for `/users/:userId`.\n*   Create a functional component `UserProfile` that will be rendered by this route.\n*   Inside `UserProfile`, use the `useParams` hook to extract the `userId` from the URL.\n*   Display the `userId` prominently on the `UserProfile` page (e.g., in an `<h1>` or `<h2>` tag).\n*   Add a `Link` component on your Home or About page that navigates to a specific user profile, e.g., `/users/123` or `/users/john-doe`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, useParams } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome!</h2>\n      <Link to=\"/users/123\">Go to User 123 Profile</Link><br/>\n      <Link to=\"/users/alice\">Go to Alice's Profile</Link>\n    </div>\n  );\n};\n\n// TODO: Create UserProfile component here\nfunction UserProfile() {\n  // Access userId using useParams\n  // Display the userId\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>User ID: </p>\n    </div>\n  );\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\">\n          <HomePage />\n        </Route>\n        {/* TODO: Define the route for /users/:userId */}\n\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, useParams } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome!</h2>\n      <p>Explore dynamic user profiles:</p>\n      <ul>\n        <li><Link to=\"/users/123\">Go to User 123 Profile</Link></li>\n        <li><Link to=\"/users/alice\">Go to Alice's Profile</Link></li>\n        <li><Link to=\"/users/bob-456\">Go to Bob's Profile</Link></li>\n      </ul>\n      <p><Link to=\"/\">Back to Home</Link></p>\n    </div>\n  );\n};\n\nfunction UserProfile() {\n  const { userId } = useParams(); // Access userId using useParams\n  \n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>Currently viewing profile for:</p>\n      <h1>User ID: {userId}</h1>\n      <p><Link to=\"/\">Back to Home</Link></p>\n    </div>\n  );\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\">\n          <HomePage />\n        </Route>\n        {/* Define the route for /users/:userId */}\n        <Route path=\"/users/:userId\">\n          <UserProfile />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
          "testCases": [
            "Test 1: Navigate to `/users/123` - `UserProfile` component should render and display 'User ID: 123'.",
            "Test 2: Navigate to `/users/john-doe` - `UserProfile` component should render and display 'User ID: john-doe'.",
            "Test 3: Click the 'Go to User 123 Profile' link from Home - Should navigate to `/users/123` and display correctly.",
            "Test 4: Directly access `/` - Home page should render."
          ],
          "hints": [
            "Remember to import `useParams` from `react-router-dom`.",
            "Place the `Route` for `/users/:userId` within the `Switch` component.",
            "The `userId` will be available as a property on the object returned by `useParams()`."
          ],
          "tags": [
            "React Router",
            "Route Parameters",
            "Hooks",
            "useParams",
            "Dynamic Routes"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics",
            "theory_react_router_parameters_hooks",
            "task_basic_react_router_setup"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "dynamic_content",
            "url_segmentation"
          ]
        },
        {
          "id": "task_nested_user_profile_routes",
          "title": "Implement Nested Routes for a User Profile Page",
          "description": "\nBuilding on the dynamic user profile task, enhance the `UserProfile` page to include nested routes for different user sub-sections.\n\n**Requirements:**\n*   Within the `UserProfile` component (from the previous task), add internal navigation links:\n    *   'Overview' (default, at `/users/:userId`)\n    *   'Posts' (at `/users/:userId/posts`)\n    *   'Photos' (at `/users/:userId/photos`)\n*   Use `NavLink` for these internal links to highlight the active sub-section (e.g., using `activeClassName=\"sub-active-link\"`).\n*   Define nested `Route` components within `UserProfile` for `PostsPage` and `PhotosPage`.\n*   `PostsPage` and `PhotosPage` should be simple functional components displaying a message like 'User [ID] Posts' or 'User [ID] Photos'. They should also be able to access `userId` via `useParams()` (or passed down if you prefer).\n*   Implement a default route for `/users/:userId` (the base `UserProfile` path) that renders a `UserOverview` component, or a message if no sub-path is matched.\n*   Ensure the `userId` is still accessible and displayed on the main `UserProfile` page and ideally within the nested components.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink, useParams, useRouteMatch } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome!</h2>\n      <Link to=\"/users/123\">Go to User 123 Profile</Link><br/>\n      <Link to=\"/users/alice\">Go to Alice's Profile</Link>\n    </div>\n  );\n};\n\n// TODO: Create UserOverview, PostsPage, PhotosPage components\nconst UserOverview = ({ userId }) => <h3>User {userId} Overview</h3>; // userId should be passed or accessed via useParams\nconst PostsPage = ({ userId }) => <h3>User {userId} Posts</h3>;\nconst PhotosPage = ({ userId }) => <h3>User {userId} Photos</h3>;\n\nfunction UserProfile() {\n  const { userId } = useParams();\n  const { path, url } = useRouteMatch(); // Use useRouteMatch for nested paths/urls\n\n  return (\n    <div>\n      <h2>User Profile for ID: {userId}</h2>\n      <nav>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* TODO: Add NavLink for Overview */}\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* TODO: Add NavLink for Posts */}\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* TODO: Add NavLink for Photos */}\n          </li>\n        </ul>\n      </nav>\n\n      {/* TODO: Add Switch for nested routes */}\n      <div>\n\n      </div>\n      <p><Link to=\"/\">Back to Home</Link></p>\n    </div>\n  );\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\">\n          <HomePage />\n        </Route>\n        <Route path=\"/users/:userId\">\n          <UserProfile />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n\n// Add some basic CSS for .sub-active-link\n// .sub-active-link {\n//   font-weight: bold;\n//   color: green;\n//   text-decoration: underline;\n// }\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink, useParams, useRouteMatch } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome!</h2>\n      <p>Explore dynamic user profiles with nested sections:</p>\n      <ul>\n        <li><Link to=\"/users/123\">Go to User 123 Profile</Link></li>\n        <li><Link to=\"/users/alice\">Go to Alice's Profile</Link></li>\n      </ul>\n    </div>\n  );\n};\n\nconst UserOverview = () => {\n  const { userId } = useParams(); // Can access params directly in nested components\n  return <h3>User {userId} Overview</h3>;\n};\n\nconst PostsPage = () => {\n  const { userId } = useParams();\n  return <h3>User {userId} Posts</h3>;\n};\n\nconst PhotosPage = () => {\n  const { userId } = useParams();\n  return <h3>User {userId} Photos</h3>;\n};\n\nfunction UserProfile() {\n  const { userId } = useParams();\n  const { path, url } = useRouteMatch(); // For v5+, useRouteMatch provides path and url\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ddd', borderRadius: '8px', margin: '20px' }}>\n      <h2>User Profile for ID: {userId}</h2>\n      <nav>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '15px' }}>\n            <NavLink exact to={url} activeClassName=\"sub-active-link\">Overview</NavLink>\n          </li>\n          <li style={{ display: 'inline', marginRight: '15px' }}>\n            <NavLink to={`${url}/posts`} activeClassName=\"sub-active-link\">Posts</NavLink>\n          </li>\n          <li style={{ display: 'inline', marginRight: '15px' }}>\n            <NavLink to={`${url}/photos`} activeClassName=\"sub-active-link\">Photos</NavLink>\n          </li>\n        </ul>\n      </nav>\n\n      <div style={{ marginTop: '20px', borderTop: '1px solid #eee', paddingTop: '15px' }}>\n        <Switch>\n          {/* Default nested route for /users/:userId */}\n          <Route exact path={path}>\n            <UserOverview />\n          </Route>\n          <Route path={`${path}/posts`}>\n            <PostsPage />\n          </Route>\n          <Route path={`${path}/photos`}>\n            <PhotosPage />\n          </Route>\n        </Switch>\n      </div>\n      <p style={{ marginTop: '20px' }}><Link to=\"/\">Back to Home</Link></p>\n    </div>\n  );\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\">\n          <HomePage />\n        </Route>\n        {/* Parent route for user profiles */}\n        <Route path=\"/users/:userId\">\n          <UserProfile />\n        </Route>\n        {/* Add a fallback 404 route (optional) */}\n        <Route path=\"*\">\n          <div>\n            <h2>404 - Page Not Found</h2>\n            <p>The page you are looking for does not exist.</p>\n            <Link to=\"/\">Go to Home</Link>\n          </div>\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
          "testCases": [
            "Test 1: Navigate to `/users/456` - `UserProfile` with 'User ID: 456' and 'Overview' content should appear. 'Overview' NavLink should be active.",
            "Test 2: Navigate to `/users/789/posts` - `UserProfile` with 'User ID: 789' and 'User 789 Posts' content should appear. 'Posts' NavLink should be active.",
            "Test 3: Navigate to `/users/abc/photos` - `UserProfile` with 'User ID: abc' and 'User abc Photos' content should appear. 'Photos' NavLink should be active.",
            "Test 4: From `/users/123`, click 'Posts' NavLink - Should change URL to `/users/123/posts` and render `PostsPage`. 'Posts' NavLink should become active.",
            "Test 5: Directly type `/users/test-user/invalid-sub` - Should render the main `UserProfile` but no nested content (or a nested 404 if implemented)."
          ],
          "hints": [
            "Use `useRouteMatch()` within `UserProfile` to get the `path` and `url` for constructing nested routes and links.",
            "Remember to use `exact` prop for the default nested route (`<Route exact path={path}>`).",
            "Nested components (`PostsPage`, `PhotosPage`) can also use `useParams()` if they need the `userId` directly."
          ],
          "tags": [
            "React Router",
            "Nested Routes",
            "Dynamic Routes",
            "useRouteMatch",
            "useParams",
            "NavLink"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_hooks_basics",
            "theory_react_router_nested_routes",
            "task_dynamic_user_profile"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "hierarchical_routing",
            "component_composition"
          ]
        },
        {
          "id": "task_implement_private_routes",
          "title": "Implement Private Routes with Authentication Context",
          "description": "\nCreate a React application that demonstrates private routes. This application should have:\n\n1.  **Public Pages**: `HomePage` (`/`) and `LoginPage` (`/login`).\n2.  **Private Page**: `DashboardPage` (`/dashboard`).\n3.  **Authentication Context**: An `AuthContext` to manage `isAuthenticated` state and `login`/`logout` functions.\n4.  **`PrivateRoute` Component**: A custom component that wraps a `Route` and redirects unauthenticated users to `/login`.\n\n**Requirements:**\n*   When a user visits `/dashboard` and is not logged in, they should be redirected to `/login`.\n*   After successful login on `/login` (mocked by a button click), they should be redirected to `/dashboard` (or the page they originally tried to access).\n*   Provide a 'Logout' button on the `DashboardPage` that clears authentication state and redirects to `/login` or `/`.\n*   Show a clear message on `LoginPage` indicating whether login was successful or if a redirect is pending.\n*   The `AuthContext` should use `useState` for authentication state and `useEffect` to simulate an initial check (e.g., if a user was previously logged in).\n",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { BrowserRouter as Router, Route, Switch, Redirect, useHistory, useLocation } from 'react-router-dom';\n\n// --- Auth Context Setup (from theory) ---\nexport const AuthContext = createContext(null);\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // Simulate checking for a logged-in user, e.g., from localStorage\n    const storedUser = localStorage.getItem('currentUser');\n    if (storedUser) {\n      setUser(JSON.parse(storedUser));\n    }\n    setLoading(false);\n  }, []);\n\n  const login = (userData) => {\n    const newUser = { id: '1', name: userData.username || 'Test User' };\n    setUser(newUser);\n    localStorage.setItem('currentUser', JSON.stringify(newUser));\n  };\n\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('currentUser');\n  };\n\n  const authContextValue = {\n    user,\n    isAuthenticated: !!user,\n    login,\n    logout,\n    loading\n  };\n\n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {!loading ? children : <div>Loading authentication...</div>}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n\n// --- Custom PrivateRoute Component (from theory) ---\nfunction PrivateRoute({ children, ...rest }) {\n  const { isAuthenticated, loading } = useAuth();\n\n  if (loading) {\n    return <div>Loading...</div>; // Or a spinner\n  }\n\n  return (\n    <Route\n      {...rest}\n      render={({ location }) =>\n        isAuthenticated ? (\n          children\n        ) : (\n          <Redirect\n            to={{\n              pathname: '/login',\n              state: { from: location }\n            }}\n          />\n        )\n      }\n    />\n  );\n}\n\n// --- Page Components ---\nconst HomePage = () => <h2>Welcome to the Public Home Page!</h2>;\n\nconst DashboardPage = () => {\n  const { logout, user } = useAuth();\n  return (\n    <div>\n      <h2>Welcome to your Private Dashboard, {user ? user.name : 'Guest'}!</h2>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n};\n\nconst LoginPage = () => {\n  const history = useHistory();\n  const location = useLocation();\n  const { login, isAuthenticated } = useAuth();\n\n  const { from } = location.state || { from: { pathname: '/dashboard' } };\n\n  const handleLogin = () => {\n    login({ username: 'user123' }); // Mock login\n    // TODO: Redirect after login based on 'from' state\n  };\n\n  if (isAuthenticated) {\n    // If already authenticated, redirect immediately\n    return <Redirect to={from} />;\n  }\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <p>You need to log in to access the dashboard.</p>\n      <button onClick={handleLogin}>Log In (Mock)</button>\n      {location.state && location.state.from &&\n        <p style={{color: 'orange'}}>You were redirected from: {location.state.from.pathname}. Please log in.</p>\n      }\n    </div>\n  );\n};\n\n// --- Main App Router ---\nfunction App() {\n  return (\n    <Router>\n      <nav style={{ marginBottom: '20px' }}>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/\">Home</Link></li>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/dashboard\">Dashboard (Private)</Link></li>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/login\">Login</Link></li>\n        </ul>\n      </nav>\n      <Switch>\n        <Route exact path=\"/\" component={HomePage} />\n        <Route path=\"/login\" component={LoginPage} />\n        {/* Use PrivateRoute for protected paths */}\n        <PrivateRoute path=\"/dashboard\">\n          <DashboardPage />\n        </PrivateRoute>\n        {/* Fallback for 404 */}\n        <Route path=\"*\">\n          <div><h2>404 Not Found</h2><p>Go <Link to=\"/\">Home</Link></p></div>\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { BrowserRouter as Router, Route, Switch, Redirect, useHistory, useLocation } from 'react-router-dom';\n\n// --- Auth Context Setup ---\nexport const AuthContext = createContext(null);\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const storedUser = localStorage.getItem('currentUser');\n    if (storedUser) {\n      setUser(JSON.parse(storedUser));\n    }\n    setLoading(false);\n  }, []);\n\n  const login = (userData) => {\n    const newUser = { id: '1', name: userData.username || 'Test User' };\n    setUser(newUser);\n    localStorage.setItem('currentUser', JSON.stringify(newUser));\n  };\n\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('currentUser');\n  };\n\n  const authContextValue = {\n    user,\n    isAuthenticated: !!user,\n    login,\n    logout,\n    loading\n  };\n\n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {!loading ? children : <div>Loading authentication...</div>}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n\n// --- Custom PrivateRoute Component ---\nfunction PrivateRoute({ children, ...rest }) {\n  const { isAuthenticated, loading } = useAuth();\n\n  if (loading) {\n    return <div>Loading...</div>; // Or a spinner\n  }\n\n  return (\n    <Route\n      {...rest}\n      render={({ location }) =>\n        isAuthenticated ? (\n          children\n        ) : (\n          <Redirect\n            to={{\n              pathname: '/login',\n              state: { from: location }\n            }}\n          />\n        )\n      }\n    />\n  );\n}\n\n// --- Page Components ---\nconst HomePage = () => <h2>Welcome to the Public Home Page!</h2>;\n\nconst DashboardPage = () => {\n  const { logout, user } = useAuth();\n  const history = useHistory();\n\n  const handleLogout = () => {\n    logout();\n    history.push('/login'); // Redirect to login page after logout\n  };\n\n  return (\n    <div>\n      <h2>Welcome to your Private Dashboard, {user ? user.name : 'Guest'}!</h2>\n      <p>You are logged in and can see this private content.</p>\n      <button onClick={handleLogout}>Logout</button>\n      <p><Link to=\"/\">Go to Home Page</Link></p>\n    </div>\n  );\n};\n\nconst LoginPage = () => {\n  const history = useHistory();\n  const location = useLocation();\n  const { login, isAuthenticated } = useAuth();\n\n  const { from } = location.state || { from: { pathname: '/dashboard' } };\n\n  useEffect(() => {\n    // If already authenticated and tried to access login, redirect to 'from' or dashboard\n    if (isAuthenticated) {\n      history.replace(from);\n    }\n  }, [isAuthenticated, from, history]);\n\n  const handleLogin = () => {\n    login({ username: 'user123' }); // Mock login\n    // The useEffect above will handle the redirect after state updates\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <p>Enter credentials to access the dashboard.</p>\n      <button onClick={handleLogin}>Log In (Mock)</button>\n      {location.state && location.state.from &&\n        <p style={{color: 'orange', marginTop: '10px'}}>You were redirected from: {location.state.from.pathname}. Please log in.</p>\n      }\n       <p style={{ marginTop: '10px' }}><Link to=\"/\">Go to Home Page</Link></p>\n    </div>\n  );\n};\n\n// --- Main App Router ---\nfunction App() {\n  return (\n    <Router>\n      <nav style={{ marginBottom: '20px' }}>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/\">Home</Link></li>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/dashboard\">Dashboard (Private)</Link></li>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/login\">Login</Link></li>\n        </ul>\n      </nav>\n      <Switch>\n        <Route exact path=\"/\" component={HomePage} />\n        <Route path=\"/login\" component={LoginPage} />\n        {/* Use PrivateRoute for protected paths */}\n        <PrivateRoute path=\"/dashboard\">\n          <DashboardPage />\n        </PrivateRoute>\n        {/* Fallback for 404 */}\n        <Route path=\"*\">\n          <div><h2>404 Not Found</h2><p>Go <Link to=\"/\">Home</Link></p></div>\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Test 1: Unauthenticated user directly navigates to `/dashboard` - Should be redirected to `/login` with a 'redirected from' message.",
            "Test 2: On `/login`, click 'Log In (Mock)' button - Should log in, and then be redirected to `/dashboard`.",
            "Test 3: Authenticated user navigates to `/dashboard` - Should see Dashboard content.",
            "Test 4: On `/dashboard`, click 'Logout' button - Should log out and be redirected to `/login`.",
            "Test 5: Authenticated user directly navigates to `/login` - Should be redirected to `/dashboard` (or the `from` path if available).",
            "Test 6: User navigates to `/` (home page) whether authenticated or not - Should always see Home page content."
          ],
          "hints": [
            "Ensure `AuthProvider` wraps your entire `Router` to make context available everywhere.",
            "The `PrivateRoute` component should use `useAuth()` to check `isAuthenticated`.",
            "In `LoginPage`, use `useHistory().replace(from)` or `history.push(from)` to redirect after login. `replace` is generally better to avoid adding the login page to history.",
            "Remember to pass `location.state` when redirecting from `PrivateRoute` to `LoginPage` to remember the original desired path."
          ],
          "tags": [
            "React Router",
            "Authentication",
            "Private Routes",
            "Context API",
            "Hooks",
            "Redirection",
            "Single Page Applications"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "react_context_api",
            "react_hooks_basics",
            "theory_react_router_private_routes",
            "task_dynamic_user_profile"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "user_authentication",
            "authorization",
            "protected_routes",
            "global_state_management"
          ]
        }
      ]
    }
  },
  {
    "id": "1666d4a1-21b8-4c60-8aca-764f10e4e81f",
    "startLine": 6400,
    "endLine": 6499,
    "processedDate": "2025-06-17T09:59:47.159Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_router_v6_private_routes",
          "title": "Implementing Private Routes with React Router v6",
          "content": "Private routes are a fundamental concept in web applications, used to restrict access to certain parts of the application based on user authentication or authorization status. In React Router v6, this is typically achieved by wrapping protected components with a custom component that checks the authentication status and redirects the user if they are not authenticated.\n\n## Key Concepts\n-   **Authentication Context (`AuthContext` and `useAuth` hook):** A global state management pattern (often using React's Context API) is used to store and provide the user's authentication status (`user` object or `isAuthenticated` boolean) throughout the application. The `useAuth` custom hook simplifies access to this context.\n-   **`RequireAuth` Component:** This is a higher-order component or a wrapper component that encapsulates the logic for checking authentication. It receives `children` (the protected component) as a prop.\n-   **`useLocation` Hook:** Provided by React Router v6, this hook returns the current `location` object, which contains information about the current URL. This is crucial for storing the user's intended destination before redirecting them to the login page.\n-   **`Navigate` Component:** In React Router v6, `<Navigate>` is the declarative way to perform programmatic navigation or redirects. It's a component that, when rendered, changes the current URL.\n-   **`state` Prop of `Navigate`:** This prop allows you to pass arbitrary state along with the navigation. When redirecting an unauthenticated user to the login page, it's good practice to store the `from` path (the page they tried to access) in the navigation state. After successful login, the user can then be redirected back to this `from` path.\n-   **`replace` Prop of `Navigate`:** Setting `replace` to `true` on `<Navigate>` will replace the current entry in the history stack instead of pushing a new one. This is important for redirects (like after login or for private routes) because it prevents the user from being able to use the browser's back button to return to the page they were redirected *from* (e.g., the protected page they couldn't access). If `replace` were not used, hitting the back button after being redirected to login would take them back to the protected page, then immediately redirect them again, creating a frustrating loop.",
          "examples": [
            {
              "id": "example_react_router_v6_private_route_1",
              "title": "Basic RequireAuth Component",
              "code": "import React, { useContext } from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\n\n// Assume AuthContext and useAuth are defined elsewhere, e.g., in an AuthProvider file\nconst AuthContext = React.createContext(null);\nconst useAuth = () => useContext(AuthContext);\n\n// Private Route component for React Router v6\nfunction RequireAuth({ children }) {\n  const { user } = useAuth(); // Get user from authentication context\n  const location = useLocation(); // Get current location\n\n  if (!user) {\n    // If no user is logged in, redirect to login page\n    // Store the current location in state so we can redirect back after login\n    // `replace` ensures the login page replaces the current entry in history\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  // If user is authenticated, render the children (the protected component)\n  return children;\n}",
              "explanation": "This `RequireAuth` component demonstrates the core logic for protecting routes in React Router v6. It uses the `useAuth` hook to check if a `user` is present (indicating authentication). If not, it leverages the `Navigate` component to redirect to the `/login` path, passing the current `location` in the state. The `replace` prop ensures that the `/login` route replaces the history entry of the attempted protected route, preventing an endless redirect loop when pressing the back button.",
              "language": "typescript"
            },
            {
              "id": "example_react_router_v6_private_route_2",
              "title": "Usage in React Router v6 Application",
              "code": "import React from 'react';\nimport { Routes, Route, BrowserRouter as Router } from 'react-router-dom';\n// Assume AuthProvider, Home, Login, Dashboard components are defined\n\n// Dummy AuthProvider for demonstration\nconst AuthContext = React.createContext(null);\nconst AuthProvider = ({ children }) => {\n  const user = { name: 'TestUser' }; // Simulate logged-in user\n  // const user = null; // Simulate logged-out user\n  return (\n    <AuthContext.Provider value={{ user }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// Re-using the RequireAuth component from the previous example\n// import { RequireAuth } from './RequireAuth'; // In a real app, you'd import it\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/login\" element={<Login />} />\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth>\n                <Dashboard />\n              </RequireAuth>\n            } \n          />\n          {/* Other routes */}\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n\nexport default App;",
              "explanation": "This example shows how the `RequireAuth` component is integrated into a React Router v6 application. The `Dashboard` component, which represents a protected resource, is rendered as `children` inside `RequireAuth`. The entire application is wrapped in `AuthProvider` to make the authentication context available. When a user tries to access `/dashboard`, `RequireAuth` will check their status and either render `Dashboard` or redirect to `/login`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_v6_private_route_1",
            "question_v6_private_route_2",
            "question_v6_private_route_3",
            "question_v6_private_route_4",
            "question_v6_private_route_5"
          ],
          "relatedTasks": [
            "task_v6_private_route_implementation",
            "task_auth_context_refactor"
          ],
          "tags": [
            "React",
            "React Router v6",
            "Authentication",
            "Private Routes",
            "Context API",
            "Hooks"
          ],
          "technology": "React, TypeScript",
          "prerequisites": [
            "react_basics",
            "react_hooks",
            "react_context_api",
            "react_router_v6_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "user_authentication_systems",
            "role_based_access_control"
          ]
        },
        {
          "id": "theory_react_router_v5_private_routes",
          "title": "Implementing Private Routes with React Router v5",
          "content": "Prior to React Router v6, the approach to creating private routes involved different components and patterns. While v6 introduced a more declarative and hook-based API, understanding v5's methodology can be beneficial for working with legacy projects or appreciating the evolution of the library.\n\n## Key Concepts\n-   **`Route` Component with `render` or `component` prop:** In React Router v5, the `<Route>` component was used with either the `component` prop (which would render the specified component when the path matched) or the `render` prop (which accepted an inline function that returns a React element). The `render` prop was preferred for passing additional props.\n-   **`Redirect` Component:** This component was the primary way to perform redirects declaratively in React Router v5. When rendered, it would immediately navigate to the URL specified in its `to` prop.\n-   **`to` Prop of `Redirect`:** Similar to `Navigate`'s `to` prop, this specified the destination path. It could also accept an object with `pathname` and `state` properties, allowing for state to be passed during the redirection.\n-   **`isAuthenticated` Logic:** Authentication status was typically determined by a custom hook or a global variable/function accessible within the `PrivateRoute` component.\n\n## Comparison with React Router v6\n-   **Declarative vs. Component-based:** V6's `Navigate` is a component that renders and causes navigation, fitting naturally within the JSX flow. V5's `Redirect` also renders and causes navigation.\n-   **Props Spreading:** In v5, it was common to spread `...rest` props onto the `<Route>` component to ensure all standard route props (like `exact`, `path`) were correctly applied. The `render` prop would then pass route-specific props (`history`, `location`, `match`) to the wrapped component.\n-   **Hooks vs. HOC/Render Props:** V6 heavily relies on hooks (`useLocation`, `useNavigate`). V5 often used higher-order components (HOCs) or the `render` prop pattern as shown below.\n-   **Simplicity:** V6's approach with `element` prop and `Navigate` within a wrapper component is generally considered more straightforward and composable.",
          "examples": [
            {
              "id": "example_react_router_v5_private_route_1",
              "title": "React Router v5 PrivateRoute Component",
              "code": "import React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\n\n// Dummy authentication check\nconst useAuth = () => { \n  // In a real app, this would check localStorage, context, or an API\n  return true; // Simulate logged-in user\n  // return false; // Simulate logged-out user\n};\n\n// PrivateRoute component for React Router v5\nconst PrivateRoute = ({ component: Component, ...rest }) => {\n  const isAuthenticated = useAuth(); // Your auth hook or logic\n  \n  return (\n    <Route\n      {...rest} // Spread route props like path, exact\n      render={props => // Use render prop to pass location and other props\n        isAuthenticated ? (\n          <Component {...props} /> // Render the component if authenticated\n        ) : (\n          <Redirect // Redirect to login if not authenticated\n            to={{\n              pathname: \"/login\",\n              state: { from: props.location } // Pass current location for redirect back\n            }}\n          />\n        )\n      }\n    />\n  );\n};",
              "explanation": "This `PrivateRoute` component for React Router v5 takes the component to be protected via the `component` prop. It uses the `render` prop of `<Route>` to conditionally render either the `Component` (if `isAuthenticated` is true) or a `Redirect` component that sends the user to `/login`. The `state` object on the `to` prop of `Redirect` is used to pass the original location, allowing for a post-login redirect back to the intended page. The `...rest` ensures any other props passed to `PrivateRoute` (like `path` or `exact`) are correctly applied to the underlying `Route`.",
              "language": "typescript"
            },
            {
              "id": "example_react_router_v5_private_route_2",
              "title": "Usage of PrivateRoute in React Router v5 App",
              "code": "import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\n// Assume Home, Login, Dashboard components are defined\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// Re-using the PrivateRoute component from the previous example\n// import PrivateRoute from './PrivateRoute'; // In a real app, you'd import it\n\nfunction AppV5() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/\" exact component={Home} />\n        <Route path=\"/login\" component={Login} />\n        {/* Protected route using PrivateRoute */}\n        <PrivateRoute path=\"/dashboard\" component={Dashboard} />\n        {/* Other routes */}\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppV5;",
              "explanation": "This example shows the typical usage of the `PrivateRoute` component within a React Router v5 application. Instead of directly using `<Route>` for `/dashboard`, `PrivateRoute` is used. When `/dashboard` is accessed, `PrivateRoute`'s internal logic will determine if the `Dashboard` component should be rendered or if a redirect to `/login` is necessary. Note the use of `Switch` and `exact` common in v5 routing.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_v5_private_route_1",
            "question_v5_private_route_2",
            "question_v5_private_route_3",
            "question_v5_v6_comparison_1"
          ],
          "relatedTasks": [
            "task_v5_to_v6_migration"
          ],
          "tags": [
            "React",
            "React Router v5",
            "Authentication",
            "Private Routes",
            "Legacy"
          ],
          "technology": "React, JavaScript",
          "prerequisites": [
            "react_basics",
            "react_router_v5_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "maintaining_legacy_apps",
            "understanding_router_evolution"
          ]
        },
        {
          "id": "theory_automatic_redirect_after_login",
          "title": "Automatic Redirect After Login in React Router (v5 & v6)",
          "content": "A common user experience pattern in web applications is to redirect a user to a specific page immediately after they successfully log in. This could be their dashboard, the page they were trying to access before authentication, or a default landing page. React Router provides mechanisms to facilitate this in both v5 and v6.\n\n## React Router v5 Approach\nIn React Router v5, the `Redirect` component was primarily used for programmatic redirects. After a successful authentication (e.g., an API call returning a success status), the component's state could be updated to trigger a `Redirect`.\n\n-   **Conditional Rendering of `Redirect`:** A `Redirect` component would be rendered conditionally based on a state variable (e.g., `isLoggedIn`). Once `isLoggedIn` became true, the `Redirect` component would cause the navigation.\n-   **`state.from` Usage:** The `location.state.from` (which was set during the initial redirect to `/login` from a protected route) could be used to determine the target path after login, ensuring the user returns to their intended destination.\n\n## React Router v6 Approach\nReact Router v6 deprecates `Redirect` and introduces the `useNavigate` hook, which provides a function to imperatively change routes.\n\n-   **`useNavigate` Hook:** This hook returns a `navigate` function that can be called with a path string or a number (for going back/forward in history). It offers more flexibility than the declarative `Navigate` component when you need to trigger navigation based on an event (like a button click or an API response).\n-   **`location.state` Access:** The `useLocation` hook is still used to access the `state` passed during the initial redirection to the login page. This allows retrieving the `from` path.\n-   **`replace` Option with `navigate`:** The `navigate` function also accepts an options object, including `replace: true`, which behaves identically to the `replace` prop on the `Navigate` component, preventing new entries in the history stack.",
          "examples": [
            {
              "id": "example_redirect_after_login_v5",
              "title": "React Router v5 Login Component with Redirect",
              "code": "import React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom';\n\nexport default class LoginComponentV5 extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isLoggedIn: false,\n      username: '',\n      password: ''\n    };\n  }\n  \n  handleLogin = () => {\n    // Your authentication logic here\n    // Simulate API call success after a delay\n    setTimeout(() => {\n        console.log('Login successful');\n        this.setState({ isLoggedIn: true });\n    }, 1000);\n  }\n  \n  handleInputChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  }\n  \n  render() {\n    // Get the 'from' path from location state, or default to dashboard\n    const { from } = this.props.location.state || { from: { pathname: '/dashboard' } };\n\n    if (this.state.isLoggedIn) {\n      return <Redirect to={from} />;\n    }\n\n    return (\n      <div>\n        <h2>Login Page (v5)</h2>\n        <input \n          type=\"text\" \n          name=\"username\" \n          placeholder=\"Username\" \n          value={this.state.username} \n          onChange={this.handleInputChange}\n        />\n        <br />\n        <input \n          type=\"password\" \n          name=\"password\" \n          placeholder=\"Password\" \n          value={this.state.password} \n          onChange={this.handleInputChange}\n        />\n        <br />\n        <button onClick={this.handleLogin}>Log In</button>\n      </div>\n    );\n  }\n}",
              "explanation": "This v5 `LoginComponent` demonstrates post-login redirection. Upon successful login (`handleLogin` sets `isLoggedIn` to `true`), the `render` method conditionally returns a `Redirect` component. The `to` prop of `Redirect` is set to `from`, which is retrieved from `this.props.location.state`. This allows the user to be sent back to the page they were originally trying to access. If no `from` state is present (e.g., they directly navigated to login), it defaults to `/dashboard`.",
              "language": "typescript"
            },
            {
              "id": "example_redirect_after_login_v6",
              "title": "React Router v6 Login Component with Redirect",
              "code": "import React, { useState } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\n// Assume useAuth hook is available for login functionality\nconst useAuth = () => ({\n    signIn: (username, password) => {\n        return new Promise(resolve => setTimeout(() => {\n            console.log(`Authenticating ${username}...`);\n            resolve({ user: { id: 1, name: username } }); // Simulate successful login\n        }, 500));\n    }\n});\n\nfunction LoginComponentV6() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n  const auth = useAuth(); // Your authentication hook\n\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const handleLogin = async () => {\n    try {\n      await auth.signIn(username, password); // Simulate login call\n      console.log('Login successful, redirecting...');\n      navigate(from, { replace: true }); // Redirect after successful login\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Handle login error (e.g., show error message)\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login Page (v6)</h2>\n      <input \n        type=\"text\" \n        placeholder=\"Username\" \n        value={username} \n        onChange={(e) => setUsername(e.target.value)}\n      />\n      <br />\n      <input \n        type=\"password\" \n        placeholder=\"Password\" \n        value={password} \n        onChange={(e) => setPassword(e.target.value)}\n      />\n      <br />\n      <button onClick={handleLogin}>Log In</button>\n    </div>\n  );\n}\n\nexport default LoginComponentV6;",
              "explanation": "This v6 `LoginComponent` uses the `useNavigate` hook for post-login redirection. After the simulated `auth.signIn` call succeeds, `navigate(from, { replace: true })` is called. The `from` path is retrieved from `location.state`, which allows redirecting to the user's originally intended page. The `replace: true` option ensures that the login page is replaced in the history stack, preventing the user from navigating back to it immediately after logging in.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redirect_after_login_1",
            "question_redirect_after_login_2",
            "question_redirect_after_login_3",
            "question_redirect_after_login_4",
            "question_redirect_after_login_5"
          ],
          "relatedTasks": [
            "task_implement_post_login_redirect"
          ],
          "tags": [
            "React",
            "React Router",
            "Authentication",
            "Redirection",
            "User Experience",
            "Hooks"
          ],
          "technology": "React, TypeScript",
          "prerequisites": [
            "react_state_management",
            "react_router_v6_basics",
            "asynchronous_javascript"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "user_onboarding_flows",
            "auth_system_integration"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_v6_private_route_1",
          "topic": "React Router v6 Private Routes",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary React Router v6 component used for declarative navigation or redirection within a React component?",
          "answer": "Navigate",
          "options": [],
          "analysisPoints": [
            "Tests basic knowledge of React Router v6 components.",
            "Distinguishes between components and hooks."
          ],
          "keyConcepts": [
            "React Router v6",
            "Navigate component"
          ],
          "evaluationCriteria": [
            "Recall of fundamental React Router v6 components"
          ],
          "example": "",
          "tags": [
            "React Router v6",
            "Navigation",
            "Basic"
          ],
          "prerequisites": [
            "react_router_v6_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_v6_private_route_2",
          "topic": "React Router v6 Private Routes",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `RequireAuth` component for React Router v6:\n\n```jsx\nfunction RequireAuth({ children }) {\n  const { user } = useAuth(); // Assume useAuth returns { user: null } or { user: {} }\n  const location = useLocation();\n\n  if (!user) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n```\n\nWhat is the primary purpose of passing `state={{ from: location }}` to the `Navigate` component?",
          "answer": "To allow redirection back to the originally attempted protected route after successful login.",
          "options": [
            "To pass user credentials to the login page for automatic pre-filling.",
            "To signal to the login page that it should display a 'login required' message.",
            "To allow redirection back to the originally attempted protected route after successful login.",
            "To replace the current history entry with the login page without losing the previous route's state."
          ],
          "analysisPoints": [
            "Tests understanding of `state` prop in `Navigate`.",
            "Clarifies how post-login redirects work in React Router.",
            "Distinguishes between passing state for navigation and authentication data."
          ],
          "keyConcepts": [
            "React Router v6",
            "Navigate component",
            "Location state",
            "Post-login redirect"
          ],
          "evaluationCriteria": [
            "Understanding of data flow during navigation.",
            "Ability to identify correct use cases for React Router features."
          ],
          "example": "The `state` object allows custom data to be attached to the navigation action. In this case, `from: location` captures the full path object of the page the user was *trying* to visit. When the user logs in, the login component can access `location.state.from` via `useLocation` hook and use `useNavigate` to send the user back to that specific path.",
          "tags": [
            "React Router v6",
            "Authentication",
            "Navigation",
            "State Management"
          ],
          "prerequisites": [
            "react_router_v6_basics",
            "react_hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_v6_private_route_3",
          "topic": "React Router v6 Private Routes",
          "level": "medium",
          "type": "mcq",
          "question": "What is the effect of the `replace` prop on the `Navigate` component in the `RequireAuth` example?\n\n```jsx\nfunction RequireAuth({ children }) {\n  const { user } = useAuth();\n  const location = useLocation();\n\n  if (!user) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n```",
          "answer": "It ensures that the login page replaces the current protected route in the browser's history, preventing the user from using the back button to return to the protected route without logging in.",
          "options": [
            "It clears all previous entries from the browser history.",
            "It ensures that the login page replaces the current protected route in the browser's history, preventing the user from using the back button to return to the protected route without logging in.",
            "It automatically refreshes the page after redirection.",
            "It prevents the browser from storing the '/login' path in its history."
          ],
          "analysisPoints": [
            "Tests understanding of browser history manipulation with React Router.",
            "Highlights a common best practice for redirects in authentication flows.",
            "Distinguishes between pushing and replacing history entries."
          ],
          "keyConcepts": [
            "React Router v6",
            "Navigate component",
            "Browser History",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Knowledge of `replace` prop functionality.",
            "Ability to explain the rationale behind using `replace` in auth flows."
          ],
          "example": "If `replace` were not used, the history stack would look like: `[Home, Dashboard (attempted), Login]`. If the user then clicked the back button from the login page, they would go back to the 'Dashboard' entry, which would immediately redirect them to login again, creating a loop. With `replace`, the stack becomes `[Home, Login]`, so hitting back from login correctly takes them to 'Home'.",
          "tags": [
            "React Router v6",
            "History",
            "UX",
            "Authentication"
          ],
          "prerequisites": [
            "react_router_v6_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_v6_private_route_4",
          "topic": "React Router v6 Private Routes",
          "level": "hard",
          "type": "code",
          "question": "Implement a `RequireRole` component similar to `RequireAuth` but which restricts access based on a user's role. Assume `useAuth` provides a `user` object with a `role` property (e.g., `user.role: 'admin' | 'user'`). The component should take an `allowedRoles` array prop. If the user does not have an allowed role, redirect them to a `/unauthorized` page, without storing their previous location in state.",
          "answer": "```typescript\nimport React, { useContext } from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\n\n// Dummy AuthContext and useAuth for demonstration\nconst AuthContext = React.createContext(null);\nconst useAuth = () => useContext(AuthContext);\n\n// For testing roles, you might set a mock user in AuthProvider:\n// const user = { name: 'Admin User', role: 'admin' };\n// const user = { name: 'Regular User', role: 'user' };\n// const user = null; // No user\n\ninterface RequireRoleProps {\n  children: React.ReactNode;\n  allowedRoles: string[];\n}\n\nfunction RequireRole({ children, allowedRoles }: RequireRoleProps) {\n  const { user } = useAuth();\n  const location = useLocation();\n\n  // First, check if user is authenticated at all\n  if (!user) {\n    // If not authenticated, redirect to login (and store location for post-login redirect)\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  // Then, check if the authenticated user has any of the allowed roles\n  const userHasAllowedRole = allowedRoles.includes(user.role);\n\n  if (!userHasAllowedRole) {\n    // If authenticated but unauthorized by role, redirect to unauthorized page\n    // No need to store 'from' location here, as they won't be redirected back after 'auth'\n    return <Navigate to=\"/unauthorized\" replace />;\n  }\n\n  // If authenticated and authorized, render children\n  return children;\n}\n\n// Example Usage in App.tsx\n/*\n<Routes>\n  <Route path=\"/\" element={<Home />} />\n  <Route path=\"/login\" element={<Login />} />\n  <Route path=\"/unauthorized\" element={<h2>Unauthorized Access!</h2>} />\n  <Route \n    path=\"/admin\" \n    element={\n      <RequireRole allowedRoles={['admin']}>\n        <AdminDashboard />\n      </RequireRole>\n    }\n  />\n  <Route \n    path=\"/user-profile\" \n    element={\n      <RequireRole allowedRoles={['admin', 'user']}>\n        <UserProfile />\n      </RequireRole>\n    }\n  />\n</Routes>\n*/\n```",
          "analysisPoints": [
            "Tests ability to extend `RequireAuth` logic for role-based access control.",
            "Requires handling multiple redirection scenarios (unauthenticated vs. unauthorized).",
            "Assesses understanding of `allowedRoles` array and `includes` method.",
            "Checks for correct usage of `Navigate` component with and without `state`."
          ],
          "keyConcepts": [
            "React Router v6",
            "Role-Based Access Control",
            "Conditional Rendering",
            "Authentication",
            "Authorization"
          ],
          "evaluationCriteria": [
            "Correct implementation of role-checking logic.",
            "Appropriate use of `Navigate` component.",
            "Handling of unauthenticated vs. unauthorized states.",
            "Code clarity and reusability."
          ],
          "example": "The `RequireRole` component builds upon `RequireAuth` by adding an extra layer of authorization. It first ensures the user is logged in. If they are, it then checks if their `user.role` is present in the `allowedRoles` array. If not, they are redirected to a dedicated `/unauthorized` page. This demonstrates a robust pattern for managing different access levels.",
          "tags": [
            "React Router v6",
            "Authorization",
            "RBAC",
            "Advanced Routing",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_router_v6_private_routes",
            "array_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_v6_private_route_5",
          "topic": "React Router v6 Private Routes",
          "level": "easy",
          "type": "flashcard",
          "question": "What React Router v6 hook is used to get information about the current URL location?",
          "answer": "useLocation",
          "options": [],
          "analysisPoints": [
            "Tests recall of fundamental React Router hooks."
          ],
          "keyConcepts": [
            "React Router v6",
            "useLocation hook"
          ],
          "evaluationCriteria": [
            "Direct recall of hook name"
          ],
          "example": "The `useLocation` hook returns an object with `pathname`, `search`, `hash`, and `state` properties, representing the current URL.",
          "tags": [
            "React Router v6",
            "Hooks",
            "Basic"
          ],
          "prerequisites": [
            "react_router_v6_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_v5_private_route_1",
          "topic": "React Router v5 Private Routes",
          "level": "medium",
          "type": "mcq",
          "question": "In React Router v5, when creating a `PrivateRoute`, which prop of the `<Route>` component was typically used to conditionally render a component or a `Redirect`?",
          "answer": "render",
          "options": [
            "element",
            "component",
            "children",
            "render"
          ],
          "analysisPoints": [
            "Tests knowledge of React Router v5's `Route` props.",
            "Highlights the distinction between `component` and `render` for conditional logic.",
            "Reinforces that `element` is v6 specific."
          ],
          "keyConcepts": [
            "React Router v5",
            "Route component",
            "render prop"
          ],
          "evaluationCriteria": [
            "Understanding of v5 API differences.",
            "Correct identification of flexible rendering options."
          ],
          "example": "The `component` prop in v5 would instantiate the component directly, making it harder to pass additional props or implement conditional logic. The `render` prop, however, accepts a function that receives route props and can return any JSX, including conditional rendering of a component or a `Redirect`.",
          "tags": [
            "React Router v5",
            "Legacy",
            "Routing"
          ],
          "prerequisites": [
            "react_router_v5_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_v5_private_route_2",
          "topic": "React Router v5 Private Routes",
          "level": "easy",
          "type": "flashcard",
          "question": "What React Router v5 component was used for declarative redirects?",
          "answer": "Redirect",
          "options": [],
          "analysisPoints": [
            "Tests basic recall of v5 redirection component."
          ],
          "keyConcepts": [
            "React Router v5",
            "Redirect component"
          ],
          "evaluationCriteria": [
            "Direct recall of component name"
          ],
          "example": "",
          "tags": [
            "React Router v5",
            "Redirect",
            "Basic"
          ],
          "prerequisites": [
            "react_router_v5_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_v5_private_route_3",
          "topic": "React Router v5 Private Routes",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where you would prefer using the `render` prop over the `component` prop in React Router v5 for a `PrivateRoute`.",
          "answer": "You would prefer using the `render` prop when you need to pass additional props to the component being rendered by the route, or when you need to apply conditional logic before rendering the component or performing a redirect. The `component` prop directly renders the component, making it harder to inject props dynamically or to handle conditional rendering like checking authentication status. The `render` prop provides a function that gives you full control over what is rendered, allowing you to access route props and your custom logic (like `isAuthenticated ? <Component {...props} /> : <Redirect />`).",
          "analysisPoints": [
            "Tests understanding of the practical differences between `component` and `render` props.",
            "Assesses ability to explain trade-offs and best practices in v5.",
            "Requires explaining the `PrivateRoute` context specifically."
          ],
          "keyConcepts": [
            "React Router v5",
            "Route component",
            "render prop",
            "component prop",
            "Conditional Rendering"
          ],
          "evaluationCriteria": [
            "Clear explanation of the problem `render` solves.",
            "Demonstrates knowledge of v5 API nuances.",
            "Ability to articulate practical use cases."
          ],
          "example": null,
          "tags": [
            "React Router v5",
            "Architecture",
            "Best Practices",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_router_v5_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_v5_v6_comparison_1",
          "topic": "React Router v5 vs v6 Private Routes",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the `PrivateRoute` pattern in React Router v5 with the `RequireAuth` pattern in React Router v6. Discuss the advantages and disadvantages of each, and why the v6 approach is generally preferred.",
          "answer": "## React Router v5 `PrivateRoute`\n**Approach:** Typically uses a Higher-Order Component (HOC) or `render` prop on the `<Route>` component. It takes the protected `component` as a prop and conditionally renders it or a `<Redirect>` component based on an authentication check.\n\n**Example:**\n```jsx\nconst PrivateRoute = ({ component: Component, ...rest }) => (\n  <Route\n    {...rest}\n    render={props =>\n      isAuthenticated ? (<Component {...props} />) : (<Redirect to={{ pathname: '/login', state: { from: props.location } }} />)\n    }\n  />\n);\n```\n\n**Advantages:**\n*   **Clear separation of concerns:** The `PrivateRoute` component encapsulates the authentication logic for a specific route.\n\n**Disadvantages:**\n*   **Less intuitive composition:** Wrapping components with a `PrivateRoute` can feel less natural than v6's element prop, especially when nesting.\n*   **`render` vs `component` props:** The nuances between `render` and `component` props (`component` remounts on every render, `render` doesn't) could lead to subtle bugs if not understood properly.\n*   **Imperative `Redirect`:** While declarative, `Redirect` is a component. Programmatic redirects (e.g., after an API call) still required state management to conditionally render it.\n\n## React Router v6 `RequireAuth`\n**Approach:** Leverages React Hooks and the `element` prop on `<Route>`. It's typically implemented as a wrapper component that uses `useContext` for authentication state, `useLocation` for the current path, and the `Navigate` component for redirection.\n\n**Example:**\n```jsx\nfunction RequireAuth({ children }) {\n  const { user } = useAuth();\n  const location = useLocation();\n  if (!user) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  return children;\n}\n\n<Route path=\"/dashboard\" element={<RequireAuth><Dashboard /></RequireAuth>} />\n```\n\n**Advantages:**\n*   **React-ish Composition:** The `element` prop for `<Route>` makes it feel more like standard React component composition, wrapping children directly.\n*   **Hooks API:** Utilizes modern React Hooks (`useLocation`, `useNavigate`), which align with current React development patterns and allow for cleaner, more functional components.\n*   **`Navigate` Component:** `Navigate` is a more declarative and consistent way to handle redirects, both from wrapper components and conditionally.\n*   **`useNavigate` Hook:** Provides an imperative function for redirects (e.g., after login) that doesn't require conditional component rendering.\n*   **Improved Type Safety:** With TypeScript, hooks-based solutions often lead to better type inference and safety.\n\n**Disadvantages:**\n*   Requires functional components (though this is standard practice now).\n*   Can be slightly more verbose if you need deeply nested authentication logic for many routes, but can be abstracted.\n\n**Why v6 is generally preferred:**\nReact Router v6 embraces modern React paradigms (hooks, functional components, JSX composition) more fully. It simplifies the API, makes routing logic more intuitive to read and write, and reduces common pitfalls associated with older patterns (like `component` prop remounts). The clear separation of declarative (`Navigate`) and imperative (`useNavigate`) navigation options also adds flexibility and clarity.",
          "analysisPoints": [
            "Requires detailed knowledge of both v5 and v6 private routing patterns.",
            "Tests ability to identify and articulate key differences in API and conceptual approach.",
            "Evaluates understanding of advantages/disadvantages for each version.",
            "Assesses ability to provide code examples to illustrate points."
          ],
          "keyConcepts": [
            "React Router v5",
            "React Router v6",
            "Private Routes",
            "HOCs",
            "Hooks",
            "Composition",
            "API differences"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison covering API, patterns, advantages, and disadvantages.",
            "Clarity and accuracy of explanations.",
            "Ability to articulate the reasons for v6's preference.",
            "Structured and organized response."
          ],
          "example": null,
          "tags": [
            "React Router",
            "Migration",
            "Architecture",
            "Comparison",
            "Advanced",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_router_v5_private_routes",
            "react_router_v6_private_routes"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_redirect_after_login_1",
          "topic": "Automatic Redirect After Login",
          "level": "medium",
          "type": "code",
          "question": "Given a `LoginComponent` using React Router v6, modify its `handleLogin` function to redirect the user to `/dashboard` after a successful login. Use the `useNavigate` hook.",
          "answer": "```typescript\nimport React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\n// Assume a dummy useAuth hook for demonstration\nconst useAuth = () => ({\n    signIn: (username, password) => {\n        return new Promise(resolve => setTimeout(() => {\n            console.log(`Authenticating ${username}...`);\n            resolve({ user: { id: 1, name: username } }); // Simulate successful login\n        }, 500));\n    }\n});\n\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate(); // Initialize useNavigate hook\n  const auth = useAuth(); // Your authentication hook\n\n  const handleLogin = async () => {\n    try {\n      await auth.signIn(username, password); // Simulate login call\n      console.log('Login successful, redirecting...');\n      navigate('/dashboard', { replace: true }); // Redirect to dashboard, replacing history entry\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Handle login error (e.g., show error message)\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <input \n        type=\"text\" \n        placeholder=\"Username\" \n        value={username} \n        onChange={(e) => setUsername(e.target.value)}\n      />\n      <br />\n      <input \n        type=\"password\" \n        placeholder=\"Password\" \n        value={password} \n        onChange={(e) => setPassword(e.target.value)}\n      />\n      <br />\n      <button onClick={handleLogin}>Log In</button>\n    </div>\n  );\n}\n\nexport default LoginComponent;\n```",
          "analysisPoints": [
            "Tests correct initialization and usage of `useNavigate`.",
            "Ensures understanding of programmatic redirects.",
            "Checks for inclusion of `replace: true` for good UX."
          ],
          "keyConcepts": [
            "React Router v6",
            "useNavigate hook",
            "Programmatic Navigation",
            "Authentication",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Correct use of `useNavigate`.",
            "Proper redirection path.",
            "Consideration for history replacement."
          ],
          "example": "The `useNavigate` hook provides the `navigate` function, which allows you to programmatically change the URL. By calling `navigate('/dashboard', { replace: true })` inside `handleLogin` after a successful authentication, the user is seamlessly moved to the dashboard, and the login page is removed from the browser history, preventing 'back' button issues.",
          "tags": [
            "React Router v6",
            "Hooks",
            "Authentication",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_router_v6_basics",
            "react_hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_after_login_2",
          "topic": "Automatic Redirect After Login",
          "level": "medium",
          "type": "mcq",
          "question": "In React Router v6, if a user attempts to access a protected route (e.g., `/dashboard`), is redirected to `/login` (with `state={{ from: location }}`), and then successfully logs in, which of the following is the most appropriate way to redirect them back to the `/dashboard`?",
          "answer": "Use `useLocation` to retrieve `location.state.from` and then `useNavigate` to navigate to that path, typically with `replace: true`.",
          "options": [
            "Directly use `<Navigate to=\"/dashboard\" />` in the login component's render method.",
            "Use `window.location.href = '/dashboard';` to force a full page reload.",
            "Use `useLocation` to retrieve `location.state.from` and then `useNavigate` to navigate to that path, typically with `replace: true`.",
            "Store the `/dashboard` path in a global variable and access it after login."
          ],
          "analysisPoints": [
            "Tests knowledge of React Router v6 state passing and redirection best practices.",
            "Evaluates understanding of `from` state usage.",
            "Distinguishes between correct React Router patterns and anti-patterns (`window.location.href`)."
          ],
          "keyConcepts": [
            "React Router v6",
            "useLocation",
            "useNavigate",
            "State passing",
            "Post-login redirect"
          ],
          "evaluationCriteria": [
            "Correct application of React Router hooks.",
            "Adherence to recommended patterns for complex navigation flows.",
            "Understanding of the purpose of `from` state."
          ],
          "example": "The flow is: User tries `/dashboard` -> `RequireAuth` sees no user -> `Navigate` to `/login` with `state={{ from: location }}` (where `location` is `/dashboard`). On the login page, `useLocation().state.from` will give you the `/dashboard` location object. Then, `useNavigate()(from.pathname, { replace: true })` will send the user back.",
          "tags": [
            "React Router v6",
            "Authentication",
            "Navigation",
            "Best Practices"
          ],
          "prerequisites": [
            "react_router_v6_private_routes",
            "react_router_v6_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_after_login_3",
          "topic": "Automatic Redirect After Login",
          "level": "easy",
          "type": "flashcard",
          "question": "When redirecting after login, why is it generally recommended to use the `replace: true` option with `navigate` (v6) or the `replace` prop with `Navigate` (v6) / `Redirect` (v5)?",
          "answer": "To prevent the user from being able to navigate back to the login page or the protected page they were redirected from, using the browser's back button, which could lead to an infinite redirect loop.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of UX implications of history management.",
            "Reinforces best practices for authentication flows."
          ],
          "keyConcepts": [
            "React Router",
            "History management",
            "UX",
            "Redirect"
          ],
          "evaluationCriteria": [
            "Correctly identifies the purpose of `replace`"
          ],
          "example": null,
          "tags": [
            "React Router",
            "UX",
            "History",
            "Best Practices"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_after_login_4",
          "topic": "Automatic Redirect After Login",
          "level": "medium",
          "type": "open",
          "question": "What happens if you try to access `location.state.from` in a `LoginComponent` when the user directly navigated to `/login` (not redirected from a protected route)? How should you handle this scenario?",
          "answer": "If a user directly navigates to `/login` (e.g., by typing the URL or clicking a direct login link) instead of being redirected from a protected route, `location.state` will be `undefined` or `null`. Consequently, `location.state.from` would also be `undefined`, leading to an error if accessed without a check.\n\n**Handling this scenario:**\nYou should provide a fallback or default path for redirection. This is typically done using the optional chaining operator (`?.`) in JavaScript or a logical OR (`||`) operator.\n\n**Example (React Router v6):**\n```typescript\nimport { useLocation, useNavigate } from 'react-router-dom';\n\nfunction LoginComponent() {\n  const location = useLocation();\n  const navigate = useNavigate();\n\n  // Safely access `from` or provide a default path\n  const from = location.state?.from?.pathname || '/dashboard'; \n\n  const handleLogin = () => {\n    // ... (authentication logic)\n    navigate(from, { replace: true });\n  };\n\n  // ... (render method)\n}\n```\nIn this example, if `location.state` or `location.state.from` is `undefined`, `from` will default to `'/dashboard'`, ensuring a valid redirection target.",
          "analysisPoints": [
            "Tests understanding of `location.state` and its potential `undefined` value.",
            "Assesses knowledge of defensive programming techniques (optional chaining, logical OR).",
            "Requires suggesting a practical solution for a common edge case."
          ],
          "keyConcepts": [
            "React Router",
            "Location state",
            "Edge Cases",
            "Defensive Programming",
            "Optional Chaining"
          ],
          "evaluationCriteria": [
            "Correctly identifies the problem.",
            "Provides a robust and idiomatic solution.",
            "Explains the reasoning behind the solution."
          ],
          "example": null,
          "tags": [
            "React Router",
            "Edge Cases",
            "Error Handling",
            "Best Practices",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_router_basics",
            "javascript_fundamentals"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_after_login_5",
          "topic": "Automatic Redirect After Login",
          "level": "hard",
          "type": "code",
          "question": "Create a `LoginComponent` that uses the `useAuth` hook (providing `user` and `signIn` function). The component should:\n1.  Handle username and password input.\n2.  Call `auth.signIn(username, password)` on button click.\n3.  After successful login, redirect the user back to the page they were trying to access (if they were redirected from a protected route), otherwise redirect them to `/home`. Ensure the history entry for the login page is replaced.",
          "answer": "```typescript\nimport React, { useState, useContext, createContext } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\n// --- Dummy Auth Context and Hook --- START\n// In a real app, these would be in a separate file (e.g., AuthProvider.tsx)\ninterface User { id: number; name: string; }\ninterface AuthContextType {\n  user: User | null;\n  signIn: (username: string, password?: string) => Promise<User>;\n  signOut: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [user, setUser] = useState<User | null>(null);\n\n  const signIn = (username: string, password?: string) => {\n    return new Promise<User>(resolve => {\n      setTimeout(() => {\n        const newUser = { id: 1, name: username };\n        setUser(newUser);\n        console.log(`User ${username} logged in.`);\n        resolve(newUser);\n      }, 500);\n    });\n  };\n\n  const signOut = () => {\n    return new Promise<void>(resolve => {\n      setTimeout(() => {\n        setUser(null);\n        console.log('User logged out.');\n        resolve();\n      }, 300);\n    });\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n// --- Dummy Auth Context and Hook --- END\n\n\n// --- LoginComponent Implementation --- START\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n  const auth = useAuth(); // Access auth functions\n\n  // Determine the 'from' path or default to '/home'\n  const from = location.state?.from?.pathname || '/home';\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault(); // Prevent default form submission\n    try {\n      await auth.signIn(username, password); // Call the sign-in function from context\n      console.log('Login successful, redirecting to:', from);\n      navigate(from, { replace: true }); // Redirect, replacing history entry\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Optionally, set an error message in state to display to the user\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleLogin}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input \n            id=\"username\" \n            type=\"text\" \n            value={username} \n            onChange={(e) => setUsername(e.target.value)}\n            required\n          />\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input \n            id=\"password\" \n            type=\"password\" \n            value={password} \n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\nexport default LoginComponent;\n\n// Example usage (in App.tsx for testing):\n/*\nfunction App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<h2>Welcome Home</h2>} />\n          <Route path=\"/home\" element={<h2>Home Page</h2>} />\n          <Route path=\"/login\" element={<LoginComponent />} />\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth><Dashboard /></RequireAuth>\n            }\n          />\n          <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n*/\n```",
          "analysisPoints": [
            "Tests complete implementation of a login flow.",
            "Requires integration of `useAuth`, `useNavigate`, `useLocation`.",
            "Checks for correct handling of the `from` state and default fallback.",
            "Evaluates proper usage of `replace: true` for history management.",
            "Assesses basic form handling and asynchronous operation."
          ],
          "keyConcepts": [
            "React Hooks",
            "Context API",
            "React Router v6",
            "Authentication",
            "Navigation",
            "Asynchronous Operations",
            "Form Handling"
          ],
          "evaluationCriteria": [
            "Functional login process.",
            "Correct conditional redirection logic.",
            "Proper use of `replace` option.",
            "Clean code structure and use of hooks.",
            "Error handling (even if basic)."
          ],
          "example": null,
          "tags": [
            "React",
            "React Router v6",
            "Authentication",
            "Forms",
            "State Management",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_router_v6_basics",
            "react_hooks_advanced",
            "asynchronous_javascript",
            "react_context_api"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_v6_private_route_implementation",
          "title": "Implement a Secure Dashboard with React Router v6",
          "description": "\nImplement a React application using React Router v6 that includes:\n\n1.  **Authentication Context (`AuthContext` and `AuthProvider`):** A context to manage user authentication state. It should provide a `user` object (or `null` if logged out) and `signIn`/`signOut` functions (mock them with simple `setTimeout`s).\n2.  **`useAuth` Hook:** A custom hook to consume the `AuthContext`.\n3.  **`RequireAuth` Component:** A component that acts as a private route guard. It should check if `user` is authenticated via `useAuth`. If not, it redirects to `/login`, passing the current location in state (`state={{ from: location }}`). Ensure `replace: true` is used for the `Navigate` component.\n4.  **Login Component:** A basic login form with username/password inputs. On submission, it should call `auth.signIn`. After successful login, it should redirect the user back to the `from` location (retrieved from `useLocation().state`) or to `/dashboard` if `from` is not present. Use `navigate` with `replace: true`.\n5.  **Dashboard Component:** A simple component to be protected.\n6.  **App Routing:** Set up `Routes` for `/`, `/login`, and `/dashboard`. The `/dashboard` route must be protected by `RequireAuth`.\n\nYour solution should demonstrate proper integration of authentication with React Router v6 private routes.\n",
          "difficulty": "medium",
          "startingCode": "import React, { createContext, useContext, useState } from 'react';\nimport { BrowserRouter as Router, Routes, Route, Navigate, useLocation, useNavigate } from 'react-router-dom';\n\n// 1. Define AuthContext and AuthProvider\ninterface User { id: number; name: string; }\ninterface AuthContextType {\n  user: User | null;\n  signIn: (username: string, password?: string) => Promise<User>;\n  signOut: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [user, setUser] = useState<User | null>(null); // Initial state: no user\n\n  const signIn = (username: string, password?: string) => {\n    return new Promise<User>(resolve => {\n      setTimeout(() => {\n        const newUser = { id: 1, name: username };\n        setUser(newUser);\n        console.log(`User ${username} logged in.`);\n        resolve(newUser);\n      }, 500);\n    });\n  };\n\n  const signOut = () => {\n    return new Promise<void>(resolve => {\n      setTimeout(() => {\n        setUser(null);\n        console.log('User logged out.');\n        resolve();\n      }, 300);\n    });\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// 2. Define useAuth hook\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\n// Dummy Components\nconst Home = () => <h2>Home Page</h2>;\nconst Dashboard = () => {\n  const { signOut } = useAuth();\n  return (\n    <div>\n      <h2>Dashboard (Protected)</h2>\n      <button onClick={signOut}>Sign Out</button>\n    </div>\n  );\n};\n\n// 3. TODO: Implement RequireAuth Component\nfunction RequireAuth({ children }: { children: React.ReactNode }) {\n  // Your implementation here\n  return null; // Placeholder\n}\n\n// 4. TODO: Implement LoginComponent\nfunction LoginComponent() {\n  // Your implementation here\n  return (\n    <div>\n      <h2>Login Page</h2>\n      {/* Add form elements */}\n      <button>Log In</button>\n    </div>\n  );\n}\n\n// App Component to set up routes\nexport default function App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <nav>\n          <p><a href=\"/\">Home</a> | <a href=\"/dashboard\">Dashboard</a> | <a href=\"/login\">Login</a></p>\n        </nav>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/login\" element={<LoginComponent />} />\n          {/* 6. TODO: Protect Dashboard Route */}\n          <Route path=\"/dashboard\" element={null /* Your protected element here */} />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n",
          "solutionCode": "import React, { createContext, useContext, useState } from 'react';\nimport { BrowserRouter as Router, Routes, Route, Navigate, useLocation, useNavigate } from 'react-router-dom';\n\n// 1. Define AuthContext and AuthProvider\ninterface User { id: number; name: string; }\ninterface AuthContextType {\n  user: User | null;\n  signIn: (username: string, password?: string) => Promise<User>;\n  signOut: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [user, setUser] = useState<User | null>(null); // Initial state: no user\n\n  const signIn = (username: string, password?: string) => {\n    return new Promise<User>(resolve => {\n      setTimeout(() => {\n        const newUser = { id: 1, name: username };\n        setUser(newUser);\n        console.log(`User ${username} logged in.`);\n        resolve(newUser);\n      }, 500);\n    });\n  };\n\n  const signOut = () => {\n    return new Promise<void>(resolve => {\n      setTimeout(() => {\n        setUser(null);\n        console.log('User logged out.');\n        resolve();\n      }, 300);\n    });\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// 2. Define useAuth hook\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\n// Dummy Components\nconst Home = () => <h2>Home Page</h2>;\nconst Dashboard = () => {\n  const { signOut, user } = useAuth();\n  return (\n    <div>\n      <h2>Dashboard (Protected)</h2>\n      {user && <p>Welcome, {user.name}!</p>}\n      <button onClick={signOut}>Sign Out</button>\n    </div>\n  );\n};\n\n// 3. RequireAuth Component\nfunction RequireAuth({ children }: { children: React.ReactNode }) {\n  const { user } = useAuth();\n  const location = useLocation();\n\n  if (!user) {\n    // Redirect to login page, storing current location\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n\n// 4. LoginComponent\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n  const auth = useAuth();\n\n  // Determine the 'from' path or default to '/dashboard'\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault();\n    try {\n      await auth.signIn(username, password); // Call signIn function\n      console.log('Login successful, redirecting to:', from);\n      navigate(from, { replace: true }); // Redirect, replacing history entry\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Implement error display here\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <form onSubmit={handleLogin}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input \n            id=\"username\" \n            type=\"text\" \n            value={username} \n            onChange={(e) => setUsername(e.target.value)}\n            required\n          />\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input \n            id=\"password\" \n            type=\"password\" \n            value={password} \n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\n// App Component to set up routes\nexport default function App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <nav>\n          <p>\n            <a href=\"/\">Home</a> |\n            <a href=\"/dashboard\">Dashboard (Protected)</a> |\n            <a href=\"/login\">Login</a>\n          </p>\n          <hr/>\n        </nav>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/login\" element={<LoginComponent />} />\n          {/* 6. Protect Dashboard Route */}\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth>\n                <Dashboard />\n              </RequireAuth>\n            } \n          />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Accessing Protected Route when Logged Out**\n\t- **Steps:** Start the application. Navigate to `/dashboard` directly (e.g., type in URL).\n\t- **Expected:** Should be redirected to `/login` page. The URL should show `/login`, and if you inspect `location.state`, it should contain `from: { pathname: '/dashboard', ... }`.\n\t- **Reasoning:** `RequireAuth` should detect no user and trigger the `Navigate` with `state` and `replace`.\n",
            "**Test Case 2: Successful Login and Redirect**\n\t- **Steps:** From the `/login` page (after being redirected from `/dashboard` in Test Case 1), enter any username/password and click 'Log In'.\n\t- **Expected:** After a brief delay (simulating API call), the page should redirect to `/dashboard`. The URL should show `/dashboard`. Pressing the browser's back button should take you to `/` (Home), not back to `/login`.\n\t- **Reasoning:** `LoginComponent` should retrieve `from` state, call `navigate(from, { replace: true })`.\n",
            "**Test Case 3: Direct Login and Default Redirect**\n\t- **Steps:** Start the application. Navigate directly to `/login` (e.g., type in URL). Enter any username/password and click 'Log In'.\n\t- **Expected:** After a brief delay, the page should redirect to `/dashboard`. The URL should show `/dashboard`. Pressing the browser's back button should take you to `/` (Home).\n\t- **Reasoning:** `LoginComponent` should handle `location.state.from` being `undefined` and fall back to the default `/dashboard` path.\n",
            "**Test Case 4: Accessing Protected Route when Logged In**\n\t- **Steps:** Log in first via the `/login` page (or modify `AuthProvider` to start with a user). Then navigate to `/dashboard`.\n\t- **Expected:** You should see the 'Dashboard (Protected)' content. No redirection should occur.\n\t- **Reasoning:** `RequireAuth` should detect an authenticated user and render its `children`.\n",
            "**Test Case 5: Sign Out Functionality**\n\t- **Steps:** Log in and access the Dashboard. Click the 'Sign Out' button on the Dashboard.\n\t- **Expected:** The application should transition back to the logged-out state. Typically, this would mean redirecting to `/login` or `/` (Home). The `user` in `AuthContext` should become `null`.\n\t- **Reasoning:** The `signOut` function from `useAuth` is called, updating the user state, which implicitly re-renders `RequireAuth` and potentially triggers a redirect to login."
          ],
          "hints": [
            "Remember to wrap your entire application in the `AuthProvider` for the context to be accessible.",
            "The `RequireAuth` component should conditionally return either the `children` or a `Navigate` component.",
            "For the `LoginComponent`, use `useLocation()` to get the `state` from the redirect and `useNavigate()` to perform the post-login redirect.",
            "Don't forget the `replace: true` option in your `Navigate` components and `navigate` calls to manage browser history effectively.",
            "Make sure your `LoginComponent` handles the case where `location.state.from` might be undefined (e.g., if the user directly navigates to /login)."
          ],
          "tags": [
            "React Router v6",
            "Authentication",
            "Private Routes",
            "Context API",
            "Hooks",
            "Frontend Architecture"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_basics",
            "react_hooks",
            "react_context_api",
            "react_router_v6_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "user_authentication",
            "authorization",
            "single_page_application_routing",
            "global_state_management"
          ]
        },
        {
          "id": "task_implement_post_login_redirect",
          "title": "Build a Login Form with Dynamic Post-Login Redirection (v6)",
          "description": "\nEnhance a `LoginComponent` to handle dynamic redirection after a successful login based on where the user was trying to go.\n\n1.  **Login Form:** A simple form with username and password inputs and a submit button.\n2.  **Authentication Logic:** Mock an asynchronous `signIn` function (e.g., with `setTimeout`) that resolves after a short delay, simulating a successful API call.\n3.  **Redirection Logic:** After a successful `signIn`, the component should redirect the user.\n    *   If the user was redirected to `/login` from a protected route (e.g., `/dashboard`), retrieve the original path from `location.state.from` and redirect them there.\n    *   If the user directly navigated to `/login`, redirect them to a default path, e.g., `/home`.\n4.  **History Management:** Ensure that the login page is replaced in the browser's history stack after the redirect (using `replace: true`).\n\nProvide the `LoginComponent` and an `App` setup demonstrating this flow.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\nimport { BrowserRouter as Router, Routes, Route, useNavigate, useLocation } from 'react-router-dom';\n\n// Dummy signIn function (simulates API call)\nconst mockSignIn = (username: string, password?: string): Promise<any> => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`Authenticating ${username}...`);\n      resolve({ user: { id: 1, name: username } }); // Simulate successful login\n    }, 700);\n  });\n};\n\n// LoginComponent to implement\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  // TODO: Implement handleLogin to handle authentication and redirection\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault();\n    // Your implementation here\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleLogin}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input \n            id=\"username\" \n            type=\"text\" \n            value={username} \n            onChange={(e) => setUsername(e.target.value)}\n            required\n          />\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input \n            id=\"password\" \n            type=\"password\" \n            value={password} \n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\n// App setup for testing (you might need a dummy RequireAuth for full test)\nconst Home = () => <h2>Home Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// For testing, you can temporarily comment out RequireAuth or use a simple one\n// If you use a full RequireAuth, ensure you have an AuthProvider setup\nconst SimpleRequireAuth = ({ children }: { children: React.ReactNode }) => {\n  const isAuthenticated = true; // For simple testing, assume authenticated\n  // const isAuthenticated = false; // Uncomment to test redirect to login\n  const location = useLocation();\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  return children;\n};\n\nexport default function App() {\n  return (\n    <Router>\n      <nav>\n        <p><a href=\"/\">Home</a> | <a href=\"/dashboard\">Dashboard</a> | <a href=\"/login\">Login</a></p>\n        <hr/>\n      </nav>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/login\" element={<LoginComponent />} />\n        <Route \n          path=\"/dashboard\" \n          element={\n            <SimpleRequireAuth>\n              <Dashboard />\n            </SimpleRequireAuth>\n          } \n        />\n      </Routes>\n    </Router>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\nimport { BrowserRouter as Router, Routes, Route, useNavigate, useLocation, Navigate } from 'react-router-dom';\n\n// Dummy signIn function (simulates API call)\nconst mockSignIn = (username: string, password?: string): Promise<any> => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`Authenticating ${username}...`);\n      resolve({ user: { id: 1, name: username } }); // Simulate successful login\n    }, 700);\n  });\n};\n\n// LoginComponent implementation\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault();\n    try {\n      await mockSignIn(username, password); // Call the mock signIn function\n      \n      // Determine the redirect path\n      const from = location.state?.from?.pathname || '/home'; // Default to /home\n      \n      console.log('Login successful, redirecting to:', from);\n      navigate(from, { replace: true }); // Redirect, replacing history entry\n\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Optionally, set an error message in state to display to the user\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleLogin}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input \n            id=\"username\" \n            type=\"text\" \n            value={username} \n            onChange={(e) => setUsername(e.target.value)}\n            required\n          />\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input \n            id=\"password\" \n            type=\"password\" \n            value={password} \n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\n// App setup for testing\nconst Home = () => <h2>Home Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// A simple RequireAuth for testing the redirection part\nconst SimpleRequireAuth = ({ children }: { children: React.ReactNode }) => {\n  // In a real scenario, this would check a global auth state\n  const isAuthenticated = false; // Set to true to test direct access, false to test redirect to login\n  const location = useLocation();\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  return children;\n};\n\nexport default function App() {\n  return (\n    <Router>\n      <nav>\n        <p>\n          <a href=\"/\">Home</a> |\n          <a href=\"/dashboard\">Dashboard (Protected)</a> |\n          <a href=\"/login\">Login</a>\n        </p>\n        <hr/>\n      </nav>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/login\" element={<LoginComponent />} />\n        <Route \n          path=\"/dashboard\" \n          element={\n            <SimpleRequireAuth>\n              <Dashboard />\n            </SimpleRequireAuth>\n          } \n        />\n        {/* Add a /home route for the default redirect */}\n        <Route path=\"/home\" element={<h2>Welcome Home!</h2>} />\n      </Routes>\n    </Router>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Redirect from Protected Route**\n\t- **Steps:** Navigate directly to `/dashboard`. (The `SimpleRequireAuth` should redirect you to `/login`). Enter credentials and click login.\n\t- **Expected:** After login, you should be redirected to `/dashboard`. The browser's back button should take you to `/` (Home), not `/login`.\n\t- **Reasoning:** `location.state.from` should be `/dashboard`, and `navigate` should use `replace: true`.\n",
            "**Test Case 2: Direct Login to Default Path**\n\t- **Steps:** Navigate directly to `/login`. Enter credentials and click login.\n\t- **Expected:** After login, you should be redirected to `/home`. The browser's back button should take you to `/` (Home), not `/login`.\n\t- **Reasoning:** `location.state.from` should be `undefined`, triggering the fallback to `/home`, and `navigate` should use `replace: true`.\n",
            "**Test Case 3: Invalid Credentials (Optional)**\n\t- **Steps:** Modify `mockSignIn` to reject for specific credentials (e.g., password 'wrong'). Try to log in with these credentials.\n\t- **Expected:** Login should fail (console error) and no redirection should occur. User stays on login page.\n\t- **Reasoning:** `try...catch` block in `handleLogin` should catch errors and prevent redirection on failure."
          ],
          "hints": [
            "Use `useNavigate()` to get the `navigate` function and `useLocation()` to access `location.state`.",
            "The `from` path can be accessed as `location.state?.from?.pathname`. Provide a default path using the `||` operator.",
            "Remember to call `e.preventDefault()` inside `handleLogin` to prevent the browser's default form submission behavior.",
            "Pass `{ replace: true }` as the second argument to the `navigate` function.",
            "Make sure your `mockSignIn` function is `async` and returns a `Promise` so you can `await` it."
          ],
          "tags": [
            "React Router v6",
            "Authentication",
            "Redirection",
            "Forms",
            "Hooks"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks",
            "react_router_v6_basics",
            "asynchronous_javascript",
            "html_forms"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "user_experience",
            "history_api",
            "conditional_rendering"
          ]
        },
        {
          "id": "task_v5_to_v6_migration",
          "title": "Migrate React Router v5 PrivateRoute to v6 RequireAuth",
          "description": "\nYou are given a React application using React Router v5 for private routes and a basic authentication hook. Your task is to migrate the `PrivateRoute` component to the React Router v6 `RequireAuth` pattern, updating the `App` component's routing accordingly.\n\n**Given v5 Code (similar to markdown):**\n```jsx\n// AppV5.jsx\nimport React from 'react';\nimport { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom';\n\nconst useAuthV5 = () => { /* In real app, checks auth */ return false; }; // Simulate logged out\n\nconst PrivateRouteV5 = ({ component: Component, ...rest }) => {\n  const isAuthenticated = useAuthV5();\n  return (\n    <Route\n      {...rest}\n      render={props =>\n        isAuthenticated ? (\n          <Component {...props} />\n        ) : (\n          <Redirect to={{ pathname: '/login', state: { from: props.location } }} />\n        )\n      }\n    />\n  );\n};\n\nconst Home = () => <h2>Home Page (v5)</h2>;\nconst Login = () => <h2>Login Page (v5)</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected, v5)</h2>;\n\nfunction AppV5() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/\" exact component={Home} />\n        <Route path=\"/login\" component={Login} />\n        <PrivateRouteV5 path=\"/dashboard\" component={Dashboard} />\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppV5;\n```\n\n**Your Task:**\n\n1.  **Migrate to React Router v6:** Change all `react-router-dom` imports from v5 to v6 style (`Switch` to `Routes`, `component` to `element`, `Redirect` to `Navigate`).\n2.  **Refactor `PrivateRouteV5` to `RequireAuthV6`:**\n    *   Rename the component to `RequireAuth`.\n    *   Modify its signature to accept `children` instead of `component`.\n    *   Replace `useAuthV5` with a `useAuth` hook that integrates with a simple `AuthContext` (provided in starting code).\n    *   Replace `Redirect` with `Navigate`.\n    *   Ensure `useLocation` is used to pass the `from` state.\n    *   Ensure `replace` prop is used on `Navigate`.\n3.  **Update `App` Component:** Adjust the `<Route>` components to use the `element` prop and wrap protected routes with `<RequireAuth>`. Add a dummy `AuthProvider` if needed.\n\nYour final solution should be a working React Router v6 setup with a functional private route.\n",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useContext, useState } from 'react';\n// TODO: Update imports to React Router v6\nimport { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom';\n\n// Dummy AuthContext and useAuth hook for v6 pattern\ninterface User { id: number; name: string; }\ninterface AuthContextType { user: User | null; }\nconst AuthContext = createContext<AuthContextType | null>(null);\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [user] = useState<User | null>({ id: 1, name: 'MigratedUser' }); // Simulate logged-in\n  // const [user] = useState<User | null>(null); // Uncomment to simulate logged-out\n  return <AuthContext.Provider value={{ user }}>{children}</AuthContext.Provider>;\n};\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) throw new Error('useAuth must be used within an AuthProvider');\n  return context;\n};\n\n// --- V5 components to be migrated ---\n\n// V5 Dummy Auth Logic\nconst useAuthV5 = () => { /* In real app, checks auth */ return false; }; // Simulate logged out for migration test\n\n// TODO: Refactor this PrivateRouteV5 to RequireAuth (v6)\nconst PrivateRouteV5 = ({ component: Component, ...rest }) => {\n  const isAuthenticated = useAuthV5();\n  return (\n    <Route\n      {...rest}\n      render={props =>\n        isAuthenticated ? (\n          <Component {...props} />\n        ) : (\n          <Redirect to={{ pathname: '/login', state: { from: props.location } }} />\n        )\n      }\n    />\n  );\n};\n\n// Dummy Components\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// TODO: Refactor this AppV5 to App (v6)\nfunction AppV5() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/\" exact component={Home} />\n        <Route path=\"/login\" component={Login} />\n        <PrivateRouteV5 path=\"/dashboard\" component={Dashboard} />\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppV5;\n",
          "solutionCode": "import React, { createContext, useContext, useState } from 'react';\n// Updated imports for React Router v6\nimport { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';\n\n// Dummy AuthContext and useAuth hook for v6 pattern\ninterface User { id: number; name: string; }\ninterface AuthContextType { user: User | null; }\nconst AuthContext = createContext<AuthContextType | null>(null);\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  // Simulate logged-in user for demonstration. Change to null for logged-out.\n  const [user] = useState<User | null>({ id: 1, name: 'MigratedUser' }); \n  // const [user] = useState<User | null>(null); // Uncomment to simulate logged-out\n  return <AuthContext.Provider value={{ user }}>{children}</AuthContext.Provider>;\n};\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) throw new Error('useAuth must be used within an AuthProvider');\n  return context;\n};\n\n// --- Migrated RequireAuth (v6) ---\n\n// Refactored PrivateRouteV5 to RequireAuth (v6)\nfunction RequireAuth({ children }: { children: React.ReactNode }) {\n  const { user } = useAuth(); // Use the new v6-compatible useAuth hook\n  const location = useLocation(); // Get current location with v6 hook\n\n  if (!user) {\n    // Redirect to login page using Navigate component (v6)\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n\n// Dummy Components (can remain the same)\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// Refactored AppV5 to App (v6)\nexport default function App() {\n  return (\n    <AuthProvider> {/* Wrap the app with AuthProvider */}\n      <Router>\n        <nav>\n          <p>\n            <a href=\"/\">Home</a> |\n            <a href=\"/dashboard\">Dashboard (Protected)</a> |\n            <a href=\"/login\">Login</a>\n          </p>\n          <hr/>\n        </nav>\n        <Routes> {/* Use Routes instead of Switch */}\n          <Route path=\"/\" element={<Home />} /> {/* Use element prop */}\n          <Route path=\"/login\" element={<Login />} />\n          {/* Protect Dashboard Route with RequireAuth (v6 pattern) */}\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth>\n                <Dashboard />\n              </RequireAuth>\n            } \n          />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Protected Route Access (Logged Out)**\n\t- **Steps:** In `AuthProvider`, set `user` to `null`. Run the app and navigate to `/dashboard`.\n\t- **Expected:** Should be redirected to `/login` with `/dashboard` stored in `location.state.from`. Browser's back button should go to `/`.\n\t- **Reasoning:** `RequireAuth` should detect `null` user and perform a `Navigate` with `replace`.\n",
            "**Test Case 2: Protected Route Access (Logged In)**\n\t- **Steps:** In `AuthProvider`, set `user` to `{ id: 1, name: 'TestUser' }`. Run the app and navigate to `/dashboard`.\n\t- **Expected:** Should see the 'Dashboard (Protected)' content. No redirection.\n\t- **Reasoning:** `RequireAuth` should detect a non-null user and render its `children`.\n",
            "**Test Case 3: Direct Access to Login**\n\t- **Steps:** Navigate directly to `/login`.\n\t- **Expected:** Should see the 'Login Page' content. `location.state.from` should be undefined (as it wasn't redirected from a protected route).\n\t- **Reasoning:** Basic route matching for `/login` should work."
          ],
          "hints": [
            "Start by changing all `react-router-dom` imports to use v6 components/hooks: `BrowserRouter`, `Routes`, `Route`, `Navigate`, `useLocation`.",
            "`Switch` in v5 becomes `Routes` in v6.",
            "The `component` prop on `Route` in v5 is replaced by the `element` prop in v6, which takes a JSX element (e.g., `element={<Home />}`).",
            "The v6 `RequireAuth` component should take `children` as a prop and conditionally render them or a `Navigate` component.",
            "Remember to use `useLocation()` to get the current location object for passing it in the `state` of `Navigate`.",
            "Don't forget the `replace` prop on the `Navigate` component to prevent unwanted history entries."
          ],
          "tags": [
            "React Router",
            "Migration",
            "Private Routes",
            "Authentication",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_router_v5_basics",
            "react_router_v6_basics",
            "react_hooks",
            "react_context_api"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "frontend_migration",
            "api_changes",
            "declarative_ui"
          ]
        }
      ]
    }
  },
  {
    "id": "8535c6f5-6cbf-4926-ae76-4e4900fe37ee",
    "startLine": 6500,
    "endLine": 6599,
    "processedDate": "2025-06-17T10:01:45.038Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_router_v5_vs_v6_navigation",
          "title": "React Router v5 vs. v6: Navigation Differences",
          "content": "This section details the evolution of navigation paradigms in React Router, specifically comparing versions 5 and 6. React Router is a standard library for declarative routing in React applications, allowing navigation between different components without full page reloads, giving the impression of a multi-page application within a single-page application (SPA).\n\n## React Router v5 Navigation (Class Components)\nIn React Router v5, when working with class components, navigation was often handled using the `Redirect` component. The `Redirect` component, when rendered, causes the application to navigate to a new URL. This is a declarative way to handle redirects, often used after an action (like a successful login) completes.\n\nKey characteristics:\n-   Primarily used with class components.\n-   `Redirect` is a component that renders to perform navigation.\n-   Relies on the component lifecycle for triggering redirects.\n\n## React Router v6 Navigation (Functional Components & Hooks)\nReact Router v6 embraces React Hooks, providing the `useNavigate` hook for programmatic navigation. This hook returns a function that can be called to navigate to a different route. This approach is more flexible and integrates seamlessly with functional components and the React Hooks ecosystem.\n\nKey characteristics:\n-   Designed for functional components and React Hooks.\n-   `useNavigate` is a hook that provides a navigation function.\n-   Allows for imperative navigation, often triggered by user interactions or side effects (`useEffect`).\n-   `Navigate` component exists as a direct replacement for `Redirect` in functional components, also for declarative redirects.\n\n## Key Differences Summarized\n-   **Pattern:** v6 uses component composition pattern with `children` prop (e.g., `Routes` and `Route` components), while v5 primarily used render props pattern (e.g., `Switch` and `Route`).\n-   **Navigation Component/Hook:** v5 uses `Redirect` component; v6 uses `useNavigate` hook for programmatic navigation and `Navigate` component for declarative rendering-based redirects.\n-   **Relative Routing:** v6 has built-in, improved support for relative routing, making it easier to define routes relative to the current path.\n-   **API Simplicity:** v6 aims for a simpler and more intuitive API, particularly with the introduction of the `Routes` component instead of `Switch` and more streamlined route definitions.",
          "examples": [
            {
              "id": "example_v5_redirect",
              "title": "React Router v5 with Redirect (Class Component)",
              "code": "import React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom';\n\nclass LoginPageV5 extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      username: '',\n      password: '',\n      isLoggedIn: false\n    };\n  }\n\n  handleInputChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  };\n\n  handleLogin = () => {\n    // Simulate authentication logic\n    if (this.state.username === 'user' && this.state.password === 'pass') {\n      this.setState({ isLoggedIn: true });\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n\n  render() {\n    if (this.state.isLoggedIn) {\n      return <Redirect to=\"/dashboard\" />;\n    } else {\n      return (\n        <div>\n          <h2>Login (v5)</h2>\n          <input \n            type=\"text\" \n            name=\"username\" \n            value={this.state.username} \n            onChange={this.handleInputChange} \n            placeholder=\"Username\"\n          />\n          <input \n            type=\"password\" \n            name=\"password\" \n            value={this.state.password} \n            onChange={this.handleInputChange} \n            placeholder=\"Password\"\n          />\n          <button onClick={this.handleLogin}>Login</button>\n        </div>\n      );\n    }\n  }\n}\n\nexport default LoginPageV5;",
              "explanation": "This example demonstrates a login component in React Router v5. Upon successful login, the `isLoggedIn` state is set to `true`. In the `render` method, if `isLoggedIn` is true, the `Redirect` component is rendered, which causes the browser to navigate to the `/dashboard` path. This is a declarative way of handling redirects.",
              "language": "typescript"
            },
            {
              "id": "example_v6_use_navigate",
              "title": "React Router v6 with useNavigate (Functional Component)",
              "code": "import React, { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst LoginPageV6 = () => {\n  const navigate = useNavigate();\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  \n  useEffect(() => {\n    if (isLoggedIn) {\n      navigate('/dashboard');\n    }\n  }, [isLoggedIn, navigate]); // `navigate` is stable, but included for completeness in dependency array\n  \n  const handleLogin = () => {\n    // Simulate authentication logic\n    if (username === 'user' && password === 'pass') {\n      setIsLoggedIn(true);\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n  \n  return (\n    <div>\n      <h2>Login (v6)</h2>\n      <input\n        type=\"text\"\n        value={username}\n        onChange={(e) => setUsername(e.target.value)}\n        placeholder=\"Username\"\n      />\n      <input\n        type=\"password\"\n        value={password}\n        onChange={(e) => setPassword(e.target.value)}\n        placeholder=\"Password\"\n      />\n      <button onClick={handleLogin}>Login</button>\n    </div>\n  );\n};\n\nexport default LoginPageV6;",
              "explanation": "This example shows the equivalent login component using React Router v6 and functional components. The `useNavigate` hook provides the `navigate` function. After a successful login, `setIsLoggedIn` is set to `true`. A `useEffect` hook then watches for `isLoggedIn` to become `true` and calls `navigate('/dashboard')` to perform the navigation. This is an imperative way of handling navigation.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_v5_v6_diff_mcq_1",
            "question_use_navigate_flashcard_1",
            "question_redirect_vs_navigate_open_1",
            "question_refactor_login_code_1",
            "question_router_composition_mcq_1"
          ],
          "relatedTasks": [
            "task_refactor_login_component",
            "task_implement_auth_navigation"
          ],
          "tags": [
            "React Router",
            "React Hooks",
            "SPA",
            "Navigation",
            "Authentication",
            "Frontend Architecture"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_class_components",
            "react_state",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_react_router",
            "spa_development",
            "authentication_flows"
          ]
        },
        {
          "id": "theory_react_router_vs_conventional_routing",
          "title": "React Router vs. Conventional (Server-Side) Routing",
          "content": "Routing is a fundamental aspect of web applications, determining how different views or content are displayed based on the URL. This section contrasts React Router (client-side routing) with traditional server-side routing.\n\n## Conventional (Server-Side) Routing\nIn conventional routing, each view or page typically corresponds to a distinct HTML file or a server-rendered page. When a user navigates to a new URL, the browser sends a new HTTP request to the server, which then responds with a fresh HTML page. This means the entire page reloads, and the server is responsible for rendering and delivering the content for each 'page'.\n\n**Characteristics:**\n-   **Pages Involved:** Each view corresponds to a new file (e.g., `index.html`, `about.html`, `products.php`).\n-   **URL Changes:** A full HTTP request is sent to the server for each navigation, and a corresponding HTML page is received.\n-   **Feel:** Users experience actual navigation across different pages, often with noticeable page reloads.\n-   **Performance:** Generally slower due to full page reloads for every navigation.\n-   **SEO:** Traditional SEO techniques work well as each 'page' is a distinct HTML document readily crawlable by search engines.\n\n## React Routing (Client-Side Routing)\nReact Router, like other client-side routing libraries, enables Single-Page Applications (SPAs). In an SPA, the browser initially loads a single HTML page (e.g., `index.html`). All subsequent 'page' navigations occur on the client side without requesting new HTML documents from the server. Instead, React Router dynamically updates the UI by rendering different React components based on the URL. It manipulates the browser's History API to change the URL without a full page reload.\n\n**Characteristics:**\n-   **Pages Involved:** Only a single HTML page is involved (the `index.html` that bootstraps the React app).\n-   **URL Changes:** Only the browser's History attribute (URL path) is changed using the History API; no full HTTP request for new HTML is sent.\n-   **Feel:** Users are given the impression they are navigating across different pages, but with seamless transitions and no full page reloads.\n-   **Performance:** Generally faster due to seamless transitions and only fetching data (not full pages) from the server after the initial load.\n-   **SEO:** Requires additional techniques (e.g., server-side rendering (SSR), static site generation (SSG), pre-rendering, or dynamic rendering) for proper indexing by search engines, as initial page content is often empty or generated by JavaScript.",
          "examples": [],
          "relatedQuestions": [
            "question_conventional_vs_react_routing_mcq_1",
            "question_spa_performance_open_1",
            "question_seo_spa_flashcard_1",
            "question_url_changes_flashcard_1",
            "question_spa_pros_cons_open_1"
          ],
          "relatedTasks": [
            "task_build_simple_spa",
            "task_simulate_server_side_rendering"
          ],
          "tags": [
            "React Router",
            "SPA",
            "Routing",
            "Frontend Performance",
            "SEO",
            "Web Architecture"
          ],
          "technology": "React",
          "prerequisites": [
            "web_basics_http",
            "html_css_js_fundamentals",
            "react_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "spa_architecture",
            "performance_optimization",
            "seo_strategies"
          ]
        },
        {
          "id": "theory_advanced_react_router_nested_routes_layouts",
          "title": "Advanced React Router Techniques: Nested Routes and Layouts",
          "content": "React Router's strength lies not only in basic page navigation but also in its ability to handle complex UI structures through nested routes and shared layouts. This allows for hierarchical navigation and reusable UI components across different sections of an application.\n\n## Nested Routes\nNested routes allow you to define routes within other routes. This is particularly useful for building applications with dashboards, user profiles, or any section where a parent component manages a common UI structure, and its children routes render different content within that structure. In React Router v6, nested routes are defined by nesting `<Route>` components inside a parent `<Route>`'s `element` prop, or by defining them directly within a `Routes` component and rendering an `Outlet` in the parent component.\n\n**Key concepts:**\n-   **Hierarchical Structure:** Routes reflect the logical and often visual hierarchy of your application's UI.\n-   **`Outlet` Component:** In v6, the `<Outlet />` component from `react-router-dom` is used within a parent route's element to render the matched child route's component. It acts as a placeholder for nested UI.\n-   **Relative Paths:** Nested routes often utilize relative paths, making route definitions more modular and easier to manage.\n\n## Layouts\nLayouts are components that wrap child routes, providing a consistent UI structure (e.g., header, sidebar, footer) that remains present while the nested content changes. This is achieved by defining a parent route that renders the layout component, and then rendering an `<Outlet />` inside that layout where the child route's content will appear. This pattern promotes code reusability and maintains a uniform user experience.\n\n**Benefits of Layouts:**\n-   **Consistency:** Ensures a consistent look and feel across different parts of the application.\n-   **Reusability:** Avoids duplicating common UI elements in every component.\n-   **Modularity:** Separates layout concerns from content concerns.\n-   **Performance:** Common layout elements are rendered once and only the inner content updates.\n\n## Implementation in React Router v6\nIn React Router v6, nested routes and layouts are typically implemented by defining a parent `Route` with a path and an `element` prop that renders your layout component. Inside this layout component, you render an `<Outlet />`. Child `Route` components are then defined within this parent `Route` or within a `Routes` component where their path is relative to the parent, or their full path is explicitly defined.\n\n```typescript\nimport React from 'react';\nimport { Routes, Route, Outlet, Link } from 'react-router-dom';\n\n// Layout Component\nconst DashboardLayout = () => (\n  <div>\n    <nav>\n      <Link to=\"/dashboard\">Dashboard Home</Link> |\n      <Link to=\"profile\">Profile</Link> |\n      <Link to=\"settings\">Settings</Link>\n    </nav>\n    <hr />\n    {/* This is where the nested routes will render */}\n    <Outlet /> \n  </div>\n);\n\n// Child Components\nconst DashboardHome = () => <h3>Welcome to your Dashboard!</h3>;\nconst Profile = () => <h3>User Profile Page</h3>;\nconst Settings = () => <h3>Application Settings</h3>;\n\nconst AppRouter = () => {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<h1>Home Page</h1>} />\n      {/* Parent route for dashboard layout and nested routes */}\n      <Route path=\"dashboard\" element={<DashboardLayout />}>\n        <Route index element={<DashboardHome />} /> {/* Renders at /dashboard */}\n        <Route path=\"profile\" element={<Profile />} /> {/* Renders at /dashboard/profile */}\n        <Route path=\"settings\" element={<Settings />} /> {/* Renders at /dashboard/settings */}\n      </Route>\n      <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n    </Routes>\n  );\n};\n\nexport default AppRouter;\n```\n\nIn this example, `DashboardLayout` acts as the parent layout. When the URL matches `/dashboard` or any of its children (`/dashboard/profile`, `/dashboard/settings`), `DashboardLayout` is rendered, and the corresponding child component (`DashboardHome`, `Profile`, or `Settings`) is rendered inside the `<Outlet />` placeholder.",
          "examples": [],
          "relatedQuestions": [
            "question_nested_routes_open_1",
            "question_outlet_component_flashcard_1",
            "question_layouts_mcq_1",
            "question_implement_nested_dashboard_code_1"
          ],
          "relatedTasks": [
            "task_implement_dashboard_layout",
            "task_dynamic_nested_routes"
          ],
          "tags": [
            "React Router",
            "Nested Routes",
            "Layouts",
            "UI Architecture",
            "Component Composition"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_router_basics",
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_spa_architecture",
            "enterprise_applications",
            "design_systems"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_v5_v6_diff_mcq_1",
          "topic": "React Router v5 vs. v6 Navigation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes a key difference in programmatic navigation between React Router v5 and v6?",
          "answer": "React Router v5 typically used the `Redirect` component for declarative navigation, while v6 introduced the `useNavigate` hook for imperative navigation.",
          "options": [
            "React Router v5 primarily used the `useHistory` hook, whereas v6 uses the `useLocation` hook for navigation.",
            "React Router v5 typically used the `Redirect` component for declarative navigation, while v6 introduced the `useNavigate` hook for imperative navigation.",
            "React Router v5 enforced client-side rendering for all routes, but v6 allows for server-side rendering by default.",
            "React Router v5 supported nested routes, but v6 completely removed this feature in favor of flat routing."
          ],
          "analysisPoints": [
            "Identifies the core shift from component-based (Redirect) to hook-based (useNavigate) navigation.",
            "Distinguishes between declarative (rendering a component) and imperative (calling a function) navigation.",
            "Highlights the move towards functional components and hooks in v6.",
            "Incorrect options represent common misconceptions or unrelated features."
          ],
          "keyConcepts": [
            "React Router v5 `Redirect`",
            "React Router v6 `useNavigate` hook",
            "Declarative vs. Imperative navigation",
            "Class vs. Functional components"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental changes in React Router API between versions.",
            "Ability to differentiate navigation patterns.",
            "Knowledge of React Hooks adoption in routing."
          ],
          "example": "In React Router v5:\n```jsx\nimport { Redirect } from 'react-router-dom';\n// ... in a class component render method\nif (loggedIn) {\n  return <Redirect to=\"/dashboard\" />;\n}\n```\nIn React Router v6:\n```jsx\nimport { useNavigate } from 'react-router-dom';\n// ... in a functional component\nconst navigate = useNavigate();\n// ... inside an event handler or useEffect\nif (loggedIn) {\n  navigate('/dashboard');\n}\n```\nThis example clarifies how `Redirect` (v5) is a component that you render, while `useNavigate` (v6) provides a function that you call.",
          "tags": [
            "React Router",
            "React Hooks",
            "Navigation",
            "v5 vs v6",
            "MCQ"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_router_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_navigate_flashcard_1",
          "topic": "React Router v6 Navigation",
          "level": "easy",
          "type": "flashcard",
          "question": "What React Router v6 hook is used for programmatic navigation?",
          "answer": "`useNavigate`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router v6",
            "useNavigate",
            "Hooks",
            "Programmatic navigation"
          ],
          "evaluationCriteria": [
            "Recall of React Router v6 API"
          ],
          "example": "",
          "tags": [
            "React Router",
            "Hooks",
            "Navigation",
            "Flashcard"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_redirect_vs_navigate_open_1",
          "topic": "React Router v5 vs. v6 Navigation",
          "level": "medium",
          "type": "open",
          "question": "Explain the conceptual difference between using `Redirect` in React Router v5 and `useNavigate` (or `Navigate` component) in React Router v6 for handling navigation. Discuss why the shift was made and its implications for component design.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Distinguish `Redirect` as a component that triggers navigation when rendered (declarative) vs. `useNavigate` as a hook providing a function for imperative navigation.",
            "Mention `Navigate` component in v6 as the direct declarative equivalent to `Redirect`.",
            "Discuss the tie-in with React's move towards functional components and hooks.",
            "Explain how `useNavigate` allows for more flexible control over navigation within event handlers or `useEffect` hooks, separating concerns from render logic.",
            "Consider implications on lifecycle methods for class components versus `useEffect` for functional components.",
            "Discuss the benefits of `useNavigate` for testability and composability."
          ],
          "keyConcepts": [
            "React Router v5 `Redirect`",
            "React Router v6 `useNavigate`",
            "Declarative vs. Imperative programming",
            "React Hooks paradigm",
            "Component lifecycle",
            "Functional vs. Class components"
          ],
          "evaluationCriteria": [
            "Depth of understanding of React Router's API evolution.",
            "Ability to articulate the advantages of the Hooks paradigm.",
            "Insight into how API design impacts application architecture.",
            "Clear and concise explanation."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Hooks",
            "Navigation",
            "Architectural Patterns",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_router_basics",
            "react_component_lifecycle"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_refactor_login_code_1",
          "topic": "React Router v5 vs. v6 Navigation",
          "level": "medium",
          "type": "code",
          "question": "Given the following React Router v5 login component, refactor it to use React Router v6 hooks (`useNavigate`, `useState`, `useEffect`). Ensure the authentication logic and navigation behavior remain the same.",
          "answer": "```typescript\nimport React, { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst LoginPageV6Refactored = () => {\n  const navigate = useNavigate();\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  \n  useEffect(() => {\n    if (isLoggedIn) {\n      navigate('/dashboard');\n    }\n  }, [isLoggedIn, navigate]);\n  \n  const handleLogin = () => {\n    // Original authentication logic\n    if (username === 'user' && password === 'pass') {\n      setIsLoggedIn(true);\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n  \n  return (\n    <div>\n      <h2>Login Refactored (v6)</h2>\n      <input\n        type=\"text\"\n        value={username}\n        onChange={(e) => setUsername(e.target.value)}\n        placeholder=\"Username\"\n      />\n      <input\n        type=\"password\"\n        value={password}\n        onChange={(e) => setPassword(e.target.value)}\n        placeholder=\"Password\"\n      />\n      <button onClick={handleLogin}>Login</button>\n    </div>\n  );\n};\n\nexport default LoginPageV6Refactored;\n```",
          "options": [],
          "analysisPoints": [
            "Correctly converts class component state (`this.state`) to functional component state (`useState`).",
            "Correctly converts class methods (`handleInputChange`, `handleLogin`) to functional component handlers.",
            "Replaces `Redirect` component with `useNavigate` hook within a `useEffect` to manage side effects (navigation).",
            "Ensures correct dependency array for `useEffect` (`[isLoggedIn, navigate]`)."
          ],
          "keyConcepts": [
            "React Hooks (`useState`, `useEffect`, `useNavigate`)",
            "Class to Functional component refactoring",
            "React Router v5 to v6 migration",
            "Side effects in React"
          ],
          "evaluationCriteria": [
            "Correct use of `useState` and `useEffect` for state and side effects.",
            "Proper implementation of `useNavigate` for routing.",
            "Maintenance of original functionality.",
            "Adherence to React Hooks best practices."
          ],
          "example": "```jsx\n// Original React Router v5 Code:\nimport React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom';\n\nclass LoginPage extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      username: '',\n      password: '',\n      isLoggedIn: false\n    };\n  }\n  handleInputChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  };\n  handleLogin = () => {\n    this.setState({ isLoggedIn: true }); // Simplified for example\n  };\n  render() {\n    if (this.state.isLoggedIn) {\n      return <Redirect to=\"/dashboard\" />;\n    } else {\n      return (\n        <div>\n          <input type=\"text\" name=\"username\" value={this.state.username} onChange={this.handleInputChange} placeholder=\"Username\"/>\n          <input type=\"password\" name=\"password\" value={this.state.password} onChange={this.handleInputChange} placeholder=\"Password\"/>\n          <button onClick={this.handleLogin}>Login</button>\n        </div>\n      );\n    }\n  }\n}\n```",
          "tags": [
            "React",
            "React Router",
            "Hooks",
            "Refactoring",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_router_basics",
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_composition_mcq_1",
          "topic": "React Router v5 vs. v6",
          "level": "medium",
          "type": "mcq",
          "question": "React Router v6 primarily advocates for which pattern for defining routes and their child content, as opposed to the pattern often seen in v5?",
          "answer": "Component composition with the `children` prop and `element` prop.",
          "options": [
            "Render props pattern with the `component` prop.",
            "Higher-Order Components (HOCs) for route wrapping.",
            "Context API for global route state management.",
            "Component composition with the `children` prop and `element` prop."
          ],
          "analysisPoints": [
            "Highlights the shift from render props (common in v5 with `Route`'s `component` or `render` props) to a more direct component composition approach (`element` prop) in v6.",
            "Emphasizes the use of `children` for nested routes within `Routes` or `Route` components.",
            "Distinguishes `element` prop in v6 from `component` or `render` in v5."
          ],
          "keyConcepts": [
            "React Router v6 `element` prop",
            "Component composition",
            "Render props",
            "React Router v5 patterns"
          ],
          "evaluationCriteria": [
            "Understanding of core API changes in React Router v6.",
            "Knowledge of common React design patterns (composition vs. render props).",
            "Ability to identify the idiomatic way of defining routes in v6."
          ],
          "example": "In React Router v5:\n```jsx\n<Route path=\"/users\" component={UsersPage} />\n<Route path=\"/products\" render={() => <ProductsPage />} />\n```\nIn React Router v6:\n```jsx\n<Route path=\"/users\" element={<UsersPage />} />\n<Route path=\"/products\" element={<ProductsPage />} />\n```\nThis example clearly shows the shift from `component`/`render` props to the `element` prop in v6, which aligns with standard component composition.",
          "tags": [
            "React Router",
            "v5 vs v6",
            "Component Composition",
            "Patterns",
            "MCQ"
          ],
          "prerequisites": [
            "react_component_props",
            "react_router_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_conventional_vs_react_routing_mcq_1",
          "topic": "React Router vs. Conventional Routing",
          "level": "medium",
          "type": "mcq",
          "question": "Which statement accurately describes a key difference in performance between conventional (server-side) routing and React Router (client-side routing)?",
          "answer": "React Router offers faster transitions due to seamless content updates without full page reloads, unlike conventional routing.",
          "options": [
            "Conventional routing is generally faster due to optimized server responses, while React Router always incurs a large initial load.",
            "React Router requires a full page reload for every URL change, which is similar to conventional routing performance.",
            "React Router offers faster transitions due to seamless content updates without full page reloads, unlike conventional routing.",
            "Conventional routing benefits from better caching mechanisms natively, making it superior for repeated visits."
          ],
          "analysisPoints": [
            "Highlights the core performance advantage of SPAs (client-side routing) – avoidance of full page reloads.",
            "Contrasts the 'seamless transitions' of React Router with the 'page reloads' of conventional routing.",
            "Correctly identifies that initial load can be larger for SPAs, but subsequent navigation is faster.",
            "Addresses a common misconception about caching and performance."
          ],
          "keyConcepts": [
            "Conventional Routing",
            "React Router",
            "SPA (Single-Page Application)",
            "Page Reloads",
            "Performance",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Understanding of the fundamental performance characteristics of client-side vs. server-side routing.",
            "Ability to compare user experience implications.",
            "Recognition of the SPA benefit."
          ],
          "example": "Consider navigating from a 'Home' page to an 'About' page.\n*   **Conventional Routing:** Browser sends a request to `server.com/about`, server processes, sends back `about.html`, browser renders `about.html` (full reload).\n*   **React Router:** Browser uses `history.pushState('/about')`, React Router detects path change, renders `<AboutPage />` component without fetching new HTML (seamless transition).\nThis fundamental difference is why client-side routing generally feels faster for subsequent navigations.",
          "tags": [
            "Routing",
            "SPA",
            "Performance",
            "Web Architecture",
            "MCQ"
          ],
          "prerequisites": [
            "web_basics_http"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_spa_performance_open_1",
          "topic": "React Router vs. Conventional Routing",
          "level": "medium",
          "type": "open",
          "question": "Discuss the performance implications of using React Router for a Single-Page Application (SPA) compared to a traditional Multi-Page Application (MPA) using conventional routing. Consider both initial page load and subsequent navigations.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "**Initial Load (MPA vs. SPA):** MPAs might have faster initial content rendering due to server-side rendering, while SPAs often have a larger initial bundle size as all (or most) app code is downloaded upfront, potentially leading to a slower 'time to interactive'.",
            "**Subsequent Navigations (MPA vs. SPA):** SPAs significantly outperform MPAs here. MPAs require a full page reload and re-fetching of all assets (HTML, CSS, JS) for each navigation. SPAs, once loaded, only fetch necessary data (e.g., JSON from API) and dynamically update components, resulting in 'seamless transitions' and faster user experience.",
            "**Perceived Performance:** SPAs often feel faster due to smooth transitions and lack of full page flashes.",
            "**Network Load:** SPAs reduce repeated network requests for static assets, saving bandwidth on subsequent navigations.",
            "**Optimization Techniques:** Mention techniques like code splitting and lazy loading in SPAs to mitigate initial load issues, and server-side rendering/static site generation to improve first paint."
          ],
          "keyConcepts": [
            "SPA Performance",
            "MPA Performance",
            "Initial Load",
            "Subsequent Navigation",
            "Client-Side Rendering",
            "Server-Side Rendering",
            "Code Splitting",
            "Perceived Performance"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of performance factors.",
            "Ability to compare and contrast effectively.",
            "Knowledge of optimization strategies for SPAs.",
            "Structured and clear explanation."
          ],
          "example": "",
          "tags": [
            "SPA",
            "Performance",
            "Web Architecture",
            "Optimization",
            "Open-Ended"
          ],
          "prerequisites": [
            "web_performance_basics",
            "spa_concepts"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_seo_spa_flashcard_1",
          "topic": "React Router & SEO",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary challenge for SEO in Single-Page Applications (SPAs) that use client-side routing like React Router, and what are common solutions?",
          "answer": "Primary Challenge: Search engine crawlers traditionally prefer fully rendered HTML content. SPAs often serve a minimal HTML file that relies on JavaScript to build the content, which can make it difficult for crawlers to index all content.\n\nCommon Solutions: Server-Side Rendering (SSR), Static Site Generation (SSG), Pre-rendering, or Dynamic Rendering.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "SPA SEO",
            "Crawling",
            "Indexing",
            "SSR",
            "SSG",
            "Pre-rendering"
          ],
          "evaluationCriteria": [
            "Recall of SPA SEO challenges and solutions"
          ],
          "example": "",
          "tags": [
            "SEO",
            "SPA",
            "React Router",
            "Flashcard"
          ],
          "prerequisites": [
            "seo_basics",
            "spa_concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_changes_flashcard_1",
          "topic": "React Router vs. Conventional Routing",
          "level": "easy",
          "type": "flashcard",
          "question": "When navigating in a React Router application, what changes in the browser's URL, and what does NOT happen, compared to conventional routing?",
          "answer": "Only the History attribute (URL path) is changed; a full HTTP request to the server is NOT sent.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "History API",
            "URL changes",
            "HTTP requests",
            "Client-side routing"
          ],
          "evaluationCriteria": [
            "Understanding of how client-side routing works"
          ],
          "example": "",
          "tags": [
            "React Router",
            "Routing",
            "URL",
            "Flashcard"
          ],
          "prerequisites": [
            "web_basics_http"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_spa_pros_cons_open_1",
          "topic": "React Router vs. Conventional Routing",
          "level": "hard",
          "type": "open",
          "question": "Beyond the points mentioned in the comparison table, elaborate on the broader pros and cons of adopting a Single-Page Application (SPA) architecture with client-side routing (like React Router) versus a Multi-Page Application (MPA) with conventional server-side routing. Consider developer experience, scalability, and specific use cases.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "**SPA Pros:** Richer user experience (desktop-app like), faster subsequent page loads, easier development with strong frontend frameworks (React, Angular, Vue), better API integration (frontend decouples from backend), potential for offline capabilities.",
            "**SPA Cons:** Slower initial load times (large JS bundle), SEO challenges, memory leaks (if not managed well), browser history management complexities (handled by routers), requires JavaScript to be enabled.",
            "**MPA Pros:** Better SEO out-of-the-box, faster initial page load (for simple pages), simpler browser history, easier to build small, content-focused sites.",
            "**MPA Cons:** Slower transitions (full page reloads), less dynamic user experience, increased server load, more complex state management across pages.",
            "**Developer Experience:** SPAs often lead to a more streamlined dev experience for complex UIs, leveraging component-based architecture. MPAs might be simpler for basic content sites.",
            "**Scalability:** Both can scale. SPAs scale by scaling API servers and static file servers. MPAs scale by scaling web servers and database.",
            "**Use Cases:** SPAs are ideal for dashboards, social networks, complex interactive tools. MPAs are good for blogs, e-commerce (though many hybrid now), simple informational websites."
          ],
          "keyConcepts": [
            "SPA",
            "MPA",
            "Client-side Routing",
            "Server-side Routing",
            "Developer Experience",
            "Scalability",
            "Use Cases",
            "SEO"
          ],
          "evaluationCriteria": [
            "Demonstrates comprehensive understanding of web application architectures.",
            "Ability to analyze trade-offs for different development scenarios.",
            "Critical thinking on non-technical and technical implications.",
            "Well-structured and detailed answer."
          ],
          "example": "",
          "tags": [
            "SPA",
            "MPA",
            "Architecture",
            "Web Development",
            "Open-Ended"
          ],
          "prerequisites": [
            "web_architecture_patterns",
            "frontend_development_principles"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_nested_routes_open_1",
          "topic": "Advanced React Router: Nested Routes",
          "level": "medium",
          "type": "open",
          "question": "Describe the concept of 'nested routes' in React Router. Why are they beneficial for structuring a complex React application, and how does the `Outlet` component facilitate this in React Router v6?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "**Concept:** Nested routes allow you to define routes within other routes, creating a hierarchical URL structure that mirrors the UI's component hierarchy.",
            "**Benefits:** Promotes modularity (parent components manage shared UI, children fill in details), improves code organization, enables consistent layouts, allows for progressive loading of child components, and simplifies complex navigation paths.",
            "**`Outlet` Component:** Explains that `Outlet` acts as a placeholder within a parent route's element where its matched child route's component will be rendered. It signals where the nested UI content should be injected.",
            "**Example Scenario:** Use a dashboard with various sections (profile, settings, reports) as an example to illustrate the utility of nested routes and a common layout."
          ],
          "keyConcepts": [
            "Nested Routes",
            "React Router v6",
            "Outlet Component",
            "UI Architecture",
            "Component Hierarchy",
            "Modularity"
          ],
          "evaluationCriteria": [
            "Clear definition of nested routes.",
            "Identification of practical benefits in application design.",
            "Correct explanation of `Outlet`'s role.",
            "Ability to connect concepts to real-world application structures."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Nested Routes",
            "UI Architecture",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_router_basics",
            "component_composition"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_outlet_component_flashcard_1",
          "topic": "Advanced React Router: Nested Routes",
          "level": "easy",
          "type": "flashcard",
          "question": "In React Router v6, what is the purpose of the `<Outlet />` component?",
          "answer": "The `<Outlet />` component is used within a parent route's element to render the matched child route's component. It acts as a placeholder for nested UI.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Outlet",
            "React Router v6",
            "Nested Routes",
            "Layouts",
            "Placeholder"
          ],
          "evaluationCriteria": [
            "Recall of `Outlet`'s function"
          ],
          "example": "",
          "tags": [
            "React Router",
            "Outlet",
            "Nested Routes",
            "Flashcard"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_layouts_mcq_1",
          "topic": "Advanced React Router: Layouts",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a primary benefit of implementing shared layouts using nested routes in React Router?",
          "answer": "Eliminates the need for API calls for dynamic content.",
          "options": [
            "Ensures consistent UI elements like headers and footers across multiple pages.",
            "Promotes code reusability by avoiding duplication of common UI components.",
            "Simplifies state management across different route components.",
            "Eliminates the need for API calls for dynamic content."
          ],
          "analysisPoints": [
            "Correctly identifies that layouts provide UI consistency and reusability.",
            "Recognizes that layouts are about UI structure, not data fetching or state management (though they might house components that do these).",
            "The incorrect option describes a data-fetching concern, not a layout benefit.",
            "State management might be *influenced* by layouts (e.g., global state in a layout), but it's not a direct *benefit* of the layout pattern itself in the same way consistency and reusability are."
          ],
          "keyConcepts": [
            "Layouts",
            "Nested Routes",
            "Component Reusability",
            "UI Consistency",
            "API Calls"
          ],
          "evaluationCriteria": [
            "Understanding of the purpose and advantages of application layouts.",
            "Ability to distinguish between UI structuring concerns and data concerns.",
            "Critical evaluation of proposed benefits."
          ],
          "example": "A common layout in a dashboard includes a fixed sidebar and header. All dashboard sub-pages (e.g., '/dashboard/profile', '/dashboard/settings') share this sidebar and header, with only the main content area changing. This ensures consistent navigation and branding without duplicating the sidebar/header code for each sub-page. However, the layout itself doesn't magically fetch data; components within the layout or nested routes still handle their own data needs.",
          "tags": [
            "React Router",
            "Layouts",
            "UI Architecture",
            "MCQ"
          ],
          "prerequisites": [
            "react_router_basics",
            "component_composition"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_implement_nested_dashboard_code_1",
          "topic": "Advanced React Router: Nested Routes and Layouts",
          "level": "hard",
          "type": "code",
          "question": "Implement a simplified dashboard structure using React Router v6. It should have a main `DashboardLayout` component that includes a navigation bar (e.g., 'Overview', 'Reports', 'Settings') and an `<Outlet />`. When navigating to `/dashboard`, `/dashboard/reports`, or `/dashboard/settings`, the `DashboardLayout` should remain visible, and the corresponding child component (`DashboardOverview`, `DashboardReports`, `DashboardSettings`) should render within the layout's `Outlet`.",
          "answer": "```typescript\nimport React from 'react';\nimport { Routes, Route, Outlet, Link, BrowserRouter } from 'react-router-dom';\n\n// 1. Dashboard Layout Component\nconst DashboardLayout = () => (\n  <div style={{ display: 'flex', height: '100vh' }}>\n    <nav style={{ padding: '20px', borderRight: '1px solid #ccc', minWidth: '150px' }}>\n      <h3>Dashboard Nav</h3>\n      <ul>\n        <li><Link to=\"/dashboard\">Overview</Link></li>\n        <li><Link to=\"reports\">Reports</Link></li>\n        <li><Link to=\"settings\">Settings</Link></li>\n      </ul>\n    </nav>\n    <main style={{ flexGrow: 1, padding: '20px' }}>\n      {/* 2. The Outlet component renders the matched child route */}\n      <Outlet /> \n    </main>\n  </div>\n);\n\n// 3. Child Components\nconst DashboardOverview = () => (\n  <div>\n    <h2>Dashboard Overview</h2>\n    <p>Welcome to your dashboard overview.</p>\n  </div>\n);\n\nconst DashboardReports = () => (\n  <div>\n    <h2>Reports</h2>\n    <p>View your performance reports here.</p>\n  </div>\n);\n\nconst DashboardSettings = () => (\n  <div>\n    <h2>Settings</h2>\n    <p>Manage your account settings.</p>\n  </div>\n);\n\n// Main App Component for Routing\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      {/* Route for the Dashboard Layout and its children */}\n      <Route path=\"/dashboard\" element={<DashboardLayout />}>\n        {/* Index route for /dashboard */}\n        <Route index element={<DashboardOverview />} />\n        {/* Nested routes for /dashboard/reports and /dashboard/settings */}\n        <Route path=\"reports\" element={<DashboardReports />} />\n        <Route path=\"settings\" element={<DashboardSettings />} />\n      </Route>\n      {/* A simple home page */}\n      <Route path=\"/\" element={<h1>Welcome to the App!</h1>} />\n      {/* Catch-all for unmatched routes */}\n      <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n    </Routes>\n  </BrowserRouter>\n);\n\nexport default App;\n```",
          "options": [],
          "analysisPoints": [
            "Correctly sets up `BrowserRouter` and `Routes`.",
            "Defines a parent `Route` (`/dashboard`) that renders `DashboardLayout`.",
            "Integrates `<Outlet />` within `DashboardLayout`.",
            "Defines nested `Route` components within the parent `Route` for each dashboard section.",
            "Uses `index` prop for the default child route when the parent path is matched exactly.",
            "Uses relative paths (`reports`, `settings`) for nested routes, which implicitly become `/dashboard/reports`, `/dashboard/settings`."
          ],
          "keyConcepts": [
            "React Router v6",
            "Nested Routes",
            "Layouts",
            "Outlet Component",
            "BrowserRouter",
            "Routes Component",
            "Route Component",
            "Index Route"
          ],
          "evaluationCriteria": [
            "Ability to implement hierarchical routing structure.",
            "Correct usage of `Outlet` for layout integration.",
            "Proper definition of `Routes` and `Route` components for nesting.",
            "Demonstrates understanding of index routes and relative paths.",
            "Code correctness and readability."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Nested Routes",
            "Layouts",
            "Code Challenge",
            "UI Architecture"
          ],
          "prerequisites": [
            "react_router_basics",
            "component_composition"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_refactor_login_component",
          "title": "Refactor React Router v5 Login to v6 Hooks",
          "description": "\nYour task is to refactor an existing React Router v5 class component for login into a React Router v6 functional component using hooks. The component should still handle user input for username and password, simulate an authentication process, and upon successful 'login' (setting `isLoggedIn` to true), navigate the user to a `/dashboard` route.\n\n**Requirements:**\n1.  Convert the `LoginPage` from a class component to a functional component.\n2.  Replace `this.state` with `useState` hooks for `username`, `password`, and `isLoggedIn`.\n3.  Replace `this.handleInputChange` with inline or separate event handlers using `useState` setters.\n4.  Replace the `Redirect` component with the `useNavigate` hook for navigation.\n5.  Ensure the navigation logic is triggered correctly after a simulated successful login.\n6.  Maintain the same visual UI (input fields, button, heading) and basic authentication logic.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom';\n\n// DO NOT MODIFY THIS COMPONENT DIRECTLY. Refactor it into a new functional component.\nclass LoginPageV5Old extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      username: '',\n      password: '',\n      isLoggedIn: false\n    };\n  }\n\n  handleInputChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  };\n\n  handleLogin = () => {\n    // Simulate authentication logic\n    // In a real app, this would be an API call\n    if (this.state.username === 'user' && this.state.password === 'pass') {\n      this.setState({ isLoggedIn: true });\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n\n  render() {\n    if (this.state.isLoggedIn) {\n      return <Redirect to=\"/dashboard\" />;\n    } else {\n      return (\n        <div>\n          <h2>Login</h2>\n          <input \n            type=\"text\" \n            name=\"username\" \n            value={this.state.username} \n            onChange={this.handleInputChange} \n            placeholder=\"Username\"\n          />\n          <input \n            type=\"password\" \n            name=\"password\" \n            value={this.state.password} \n            onChange={this.handleInputChange} \n            placeholder=\"Password\"\n          />\n          <button onClick={this.handleLogin}>Login</button>\n        </div>\n      );\n    }\n  }\n}\n\n// --- Your Refactored Component Below ---\n\n// export default LoginPageV6;\n\n// Add a mock Dashboard component for testing\n// const Dashboard = () => <h2>Welcome to Dashboard!</h2>;\n\n// You will also need to set up a basic router structure in your App.js or similar file for testing:\n/*\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<LoginPageV6 />} />\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n*/",
          "solutionCode": "import React, { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst LoginPageV6 = () => {\n  const navigate = useNavigate();\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  \n  useEffect(() => {\n    if (isLoggedIn) {\n      navigate('/dashboard');\n    }\n    // 'navigate' is stable in React Router v6, but including it is harmless\n    // and satisfies exhaustive-deps lint rule if not configured otherwise.\n  }, [isLoggedIn, navigate]); \n  \n  const handleLogin = () => {\n    // Simulate authentication logic\n    if (username === 'user' && password === 'pass') {\n      setIsLoggedIn(true);\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n  \n  return (\n    <div>\n      <h2>Login (Refactored to v6)</h2>\n      <input\n        type=\"text\"\n        value={username}\n        onChange={(e) => setUsername(e.target.value)}\n        placeholder=\"Username\"\n      />\n      <input\n        type=\"password\"\n        value={password}\n        onChange={(e) => setPassword(e.target.value)}\n        placeholder=\"Password\"\n      />\n      <button onClick={handleLogin}>Login</button>\n    </div>\n  );\n};\n\nexport default LoginPageV6;\n\n// Mock Dashboard component for testing context\nexport const Dashboard = () => <h2>Welcome to Dashboard!</h2>;\n\n/* Example App setup for testing:\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport LoginPageV6, { Dashboard } from './LoginPageV6'; // Assuming the file is named LoginPageV6.js\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<LoginPageV6 />} />\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n*/\n",
          "testCases": [
            "Initial render: Login form should be displayed.",
            "Input changes: Typing in username/password fields should update the component's state correctly.",
            "Successful login: After entering 'user'/'pass' and clicking Login, the user should be redirected to '/dashboard'.",
            "Failed login: After entering incorrect credentials, an alert should be shown, and no redirection should occur."
          ],
          "hints": [
            "Remember to import `useState`, `useEffect`, and `useNavigate` from `react` and `react-router-dom` respectively.",
            "State variables in functional components are managed using `useState`.",
            "Side effects like navigation after a state change should be handled within a `useEffect` hook.",
            "The `useNavigate` hook provides a function that you call to navigate, rather than rendering a component."
          ],
          "tags": [
            "React",
            "React Router",
            "Hooks",
            "Refactoring",
            "Migration",
            "Functional Components"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_basics",
            "react_class_components",
            "react_router_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_router_v5_vs_v6_navigation"
          ]
        },
        {
          "id": "task_implement_auth_navigation",
          "title": "Implement User Authentication Flow with Conditional Routing",
          "description": "\nBuild a simple React application using React Router v6 that demonstrates conditional routing based on user authentication status. The application should have:\n\n1.  A `LoginPage` component (similar to the one in the theory) that allows users to 'log in' (e.g., by setting a `isLoggedIn` state). This component should redirect to `/dashboard` upon successful login.\n2.  A `DashboardPage` component that is only accessible if the user is 'logged in'. If an unauthenticated user tries to access `/dashboard` directly, they should be redirected back to `/login`.\n3.  A `HomePage` component accessible to everyone.\n4.  A navigation bar with links to `Home`, `Login`, and `Dashboard`.\n\n**Requirements:**\n*   Use `useNavigate` for imperative navigation.\n*   Implement a `useEffect` hook to handle the redirection logic after login.\n*   Implement a protected route mechanism for the `DashboardPage` (e.g., using a wrapper component or conditional rendering within `element` prop).\n*   Use a global state (e.g., React Context or just lifting state up to `App` component) to manage authentication status, accessible by `LoginPage` and the protected route logic.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect, createContext, useContext } from 'react';\nimport { BrowserRouter, Routes, Route, useNavigate, Link, Navigate } from 'react-router-dom';\n\n// Create an AuthContext to manage authentication state globally\nconst AuthContext = createContext(null);\n\n// Auth Provider component to wrap the application\nconst AuthProvider = ({ children }) => {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  \n  const login = () => setIsLoggedIn(true);\n  const logout = () => setIsLoggedIn(false);\n  \n  const authContextValue = { isLoggedIn, login, logout };\n  \n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// 1. HomePage component\nconst HomePage = () => {\n  const { isLoggedIn } = useContext(AuthContext);\n  return (\n    <div>\n      <h2>Home Page</h2>\n      <p>Welcome! You are {isLoggedIn ? 'logged in.' : 'not logged in.'}</p>\n    </div>\n  );\n};\n\n// 2. LoginPage component - needs implementation for login logic and navigation\nconst LoginPage = () => {\n  const navigate = useNavigate();\n  const { isLoggedIn, login } = useContext(AuthContext);\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n\n  useEffect(() => {\n    if (isLoggedIn) {\n      navigate('/dashboard');\n    }\n  }, [isLoggedIn, navigate]);\n\n  const handleLogin = () => {\n    // TODO: Implement actual login logic. For now, simulate success.\n    if (username === 'user' && password === 'pass') {\n      login(); // Call login from context\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <input\n        type=\"text\"\n        value={username}\n        onChange={(e) => setUsername(e.target.value)}\n        placeholder=\"Username\"\n      />\n      <input\n        type=\"password\"\n        value={password}\n        onChange={(e) => setPassword(e.target.value)}\n        placeholder=\"Password\"\n      />\n      <button onClick={handleLogin}>Login</button>\n    </div>\n  );\n};\n\n// 3. DashboardPage component - needs implementation for protected access\nconst DashboardPage = () => {\n  const { logout } = useContext(AuthContext);\n  return (\n    <div>\n      <h2>Dashboard Page</h2>\n      <p>This is a protected dashboard.</p>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n};\n\n// ProtectedRoute Wrapper - needs implementation for redirection logic\nconst ProtectedRoute = ({ children }) => {\n  const { isLoggedIn } = useContext(AuthContext);\n  // TODO: Implement logic to redirect to /login if not authenticated\n  // return children or <Navigate to=\"/login\" replace />\n  return null; // Placeholder\n};\n\n// Main App component to set up routes\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <AuthProvider>\n        <nav>\n          <Link to=\"/\">Home</Link> | \n          <Link to=\"/login\">Login</Link> | \n          <Link to=\"/dashboard\">Dashboard</Link>\n        </nav>\n        <hr/>\n        <Routes>\n          <Route path=\"/\" element={<HomePage />} />\n          <Route path=\"/login\" element={<LoginPage />} />\n          {/* Dashboard route needs to be protected */}\n          <Route path=\"/dashboard\" element={\n            <ProtectedRoute>\n              <DashboardPage />\n            </ProtectedRoute>\n          } />\n          <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n        </Routes>\n      </AuthProvider>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n",
          "solutionCode": "import React, { useState, useEffect, createContext, useContext } from 'react';\nimport { BrowserRouter, Routes, Route, useNavigate, Link, Navigate } from 'react-router-dom';\n\n// Create an AuthContext to manage authentication state globally\nconst AuthContext = createContext(null);\n\n// Auth Provider component to wrap the application\nconst AuthProvider = ({ children }) => {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  \n  const login = () => setIsLoggedIn(true);\n  const logout = () => setIsLoggedIn(false);\n  \n  const authContextValue = { isLoggedIn, login, logout };\n  \n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// HomePage component\nconst HomePage = () => {\n  const { isLoggedIn } = useContext(AuthContext);\n  return (\n    <div>\n      <h2>Home Page</h2>\n      <p>Welcome! You are {isLoggedIn ? 'logged in.' : 'not logged in.'}</p>\n    </div>\n  );\n};\n\n// LoginPage component\nconst LoginPage = () => {\n  const navigate = useNavigate();\n  const { isLoggedIn, login } = useContext(AuthContext);\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n\n  useEffect(() => {\n    if (isLoggedIn) {\n      navigate('/dashboard', { replace: true }); // Use replace to prevent back button to login\n    }\n  }, [isLoggedIn, navigate]);\n\n  const handleLogin = () => {\n    // Implement actual login logic here (e.g., API call)\n    // For this task, we simulate success for 'user'/'pass'\n    if (username === 'user' && password === 'pass') {\n      login(); // Call login from context\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <input\n        type=\"text\"\n        value={username}\n        onChange={(e) => setUsername(e.target.value)}\n        placeholder=\"Username\"\n      />\n      <input\n        type=\"password\"\n        value={password}\n        onChange={(e) => setPassword(e.target.value)}\n        placeholder=\"Password\"\n      />\n      <button onClick={handleLogin}>Login</button>\n    </div>\n  );\n};\n\n// DashboardPage component\nconst DashboardPage = () => {\n  const { logout } = useContext(AuthContext);\n  return (\n    <div>\n      <h2>Dashboard Page</h2>\n      <p>This is a protected dashboard.</p>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n};\n\n// ProtectedRoute Wrapper\nconst ProtectedRoute = ({ children }) => {\n  const { isLoggedIn } = useContext(AuthContext);\n  if (!isLoggedIn) {\n    // Redirect to login if not authenticated\n    return <Navigate to=\"/login\" replace />;\n  }\n  return children;\n};\n\n// Main App component to set up routes\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <AuthProvider>\n        <nav style={{ padding: '10px', backgroundColor: '#f0f0f0' }}>\n          <Link to=\"/\" style={{ margin: '0 10px' }}>Home</Link>\n          <Link to=\"/login\" style={{ margin: '0 10px' }}>Login</Link>\n          <Link to=\"/dashboard\" style={{ margin: '0 10px' }}>Dashboard</Link>\n        </nav>\n        <hr/>\n        <Routes>\n          <Route path=\"/\" element={<HomePage />} />\n          <Route path=\"/login\" element={<LoginPage />} />\n          {/* Dashboard route is protected using the ProtectedRoute component */}\n          <Route path=\"/dashboard\" element={\n            <ProtectedRoute>\n              <DashboardPage />\n            </ProtectedRoute>\n          } />\n          <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n        </Routes>\n      </AuthProvider>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n",
          "testCases": [
            "Initial state: User is not logged in. Navigating to '/' shows HomePage. Navigating to '/login' shows LoginPage. Navigating to '/dashboard' should redirect to '/login'.",
            "Successful Login: After logging in with 'user'/'pass' on '/login' page, the app should navigate to '/dashboard'. `isLoggedIn` should be true.",
            "Post-Login Navigation: After logging in, user can navigate between '/home' and '/dashboard' freely. Attempting to go back to '/login' should not be possible (or redirect to dashboard if `replace` used).",
            "Logout: Clicking 'Logout' on the DashboardPage should set `isLoggedIn` to false and potentially redirect to '/login' or '/home'. Subsequent attempt to access '/dashboard' should redirect to '/login'.",
            "Invalid Login: Entering incorrect credentials on login page should display an alert and not redirect."
          ],
          "hints": [
            "Use React Context API to manage the `isLoggedIn` state globally, so both `LoginPage` and `ProtectedRoute` can access it.",
            "The `ProtectedRoute` component can conditionally render its `children` or a `Navigate` component based on the `isLoggedIn` status.",
            "Remember to pass `replace: true` to `navigate()` or use the `<Navigate replace />` component when redirecting after login to prevent the user from going back to the login page via the browser's back button.",
            "The `useEffect` hook in `LoginPage` is ideal for handling the navigation side effect after the `isLoggedIn` state changes."
          ],
          "tags": [
            "React",
            "React Router",
            "Authentication",
            "Conditional Routing",
            "React Context",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_hooks_basics",
            "react_context_api",
            "react_router_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_react_router_v5_vs_v6_navigation"
          ]
        },
        {
          "id": "task_build_simple_spa",
          "title": "Build a Simple SPA with React Router",
          "description": "\nCreate a basic Single-Page Application (SPA) using React Router v6 that demonstrates the concept of client-side routing and seamless transitions. The application should have three main 'pages' implemented as React components:\n\n1.  **`HomePage`**: A simple component displaying 'Welcome to the Home Page!'\n2.  **`AboutPage`**: A component displaying 'Learn more about us here.'\n3.  **`ContactPage`**: A component displaying 'Contact us at example@example.com.'\n\nThe application must include a simple navigation menu with `Link` components to switch between these pages. Observe the URL changes and the lack of full page reloads.\n\n**Requirements:**\n*   Set up React Router v6 (`BrowserRouter`, `Routes`, `Route`).\n*   Create three functional React components (`HomePage`, `AboutPage`, `ContactPage`).\n*   Define routes for `/`, `/about`, and `/contact`.\n*   Implement a navigation bar using `Link` components.\n*   Demonstrate that navigation between pages updates the URL without a full browser refresh.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\n\n// TODO: Create HomePage component\nconst HomePage = () => null;\n\n// TODO: Create AboutPage component\nconst AboutPage = () => null;\n\n// TODO: Create ContactPage component\nconst ContactPage = () => null;\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <nav>\n        {/* TODO: Add navigation links */}\n      </nav>\n      <hr />\n      <Routes>\n        {/* TODO: Define routes for HomePage, AboutPage, ContactPage */}\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\n\n// HomePage component\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Home Page</h2>\n      <p>Welcome to the Home Page!</p>\n    </div>\n  );\n};\n\n// AboutPage component\nconst AboutPage = () => {\n  return (\n    <div>\n      <h2>About Us</h2>\n      <p>Learn more about us here.</p>\n    </div>\n  );\n};\n\n// ContactPage component\nconst ContactPage = () => {\n  return (\n    <div>\n      <h2>Contact Us</h2>\n      <p>Contact us at example@example.com.</p>\n    </div>\n  );\n};\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <nav style={{ padding: '10px', backgroundColor: '#e0e0e0' }}>\n        <Link to=\"/\" style={{ margin: '0 10px' }}>Home</Link>\n        <Link to=\"/about\" style={{ margin: '0 10px' }}>About</Link>\n        <Link to=\"/contact\" style={{ margin: '0 10px' }}>Contact</Link>\n      </nav>\n      <hr />\n      <Routes>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"/about\" element={<AboutPage />} />\n        <Route path=\"/contact\" element={<ContactPage />} />\n        <Route path=\"*\" element={<h2>404 - Page Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n",
          "testCases": [
            "Initial load: App renders with the home page content.",
            "Navigation to About: Clicking 'About' link changes URL to '/about' and displays AboutPage content without a full refresh.",
            "Navigation to Contact: Clicking 'Contact' link changes URL to '/contact' and displays ContactPage content without a full refresh.",
            "Back/Forward browser buttons: Should work correctly, navigating between pages while maintaining SPA behavior.",
            "Direct URL access: Navigating directly to '/about' or '/contact' in the browser should display the correct page content."
          ],
          "hints": [
            "Remember to wrap your application with `BrowserRouter`.",
            "Use `Routes` to define a collection of `Route` components.",
            "Each `Route` needs a `path` and an `element` prop that points to your component.",
            "`Link` components from `react-router-dom` are used for navigation within the SPA."
          ],
          "tags": [
            "React",
            "React Router",
            "SPA",
            "Routing",
            "Beginner",
            "UI"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_basics",
            "react_functional_components"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_react_router_vs_conventional_routing"
          ]
        },
        {
          "id": "task_implement_dashboard_layout",
          "title": "Implement Dashboard with Nested Routes and Shared Layout",
          "description": "\nImplement a multi-section dashboard application using React Router v6's nested routes and `Outlet` for a shared layout. The dashboard should have:\n\n1.  A `DashboardLayout` component that acts as the main wrapper, containing a persistent sidebar navigation and a main content area.\n2.  The sidebar should include links to 'Overview', 'Profile', and 'Settings'.\n3.  The main content area should display different components (`DashboardOverview`, `UserProfile`, `AppSettings`) based on the nested route.\n4.  The default route for `/dashboard` should display `DashboardOverview`.\n\n**Requirements:**\n*   Create a `DashboardLayout` component that renders a navigation (`Link`s) and an `Outlet`.\n*   Define a parent `Route` for `/dashboard` that uses `DashboardLayout` as its `element`.\n*   Define child `Route`s for `/dashboard`, `/dashboard/profile`, and `/dashboard/settings` within the parent `Route`.\n*   Use the `index` prop for the default child route (`/dashboard`).\n*   Ensure correct relative linking within the sidebar navigation.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Outlet, Link } from 'react-router-dom';\n\n// TODO: Implement DashboardLayout component with nav and Outlet\nconst DashboardLayout = () => {\n  return (\n    <div>\n      {/* Navigation links here */}\n      <nav>\n        {/* Links to: Overview, Profile, Settings */}\n      </nav>\n      <hr />\n      {/* Placeholder for nested routes */}\n      {/* <Outlet /> */}\n    </div>\n  );\n};\n\n// TODO: Implement DashboardOverview component\nconst DashboardOverview = () => null;\n\n// TODO: Implement UserProfile component\nconst UserProfile = () => null;\n\n// TODO: Implement AppSettings component\nconst AppSettings = () => null;\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<h1>Home Page</h1>} />\n        {/* TODO: Define parent route for /dashboard and its children */}\n        {/* <Route path=\"dashboard\" element={<DashboardLayout />}> */}\n          {/* ... nested routes ... */}\n        {/* </Route> */}\n        <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Outlet, Link } from 'react-router-dom';\n\n// DashboardLayout component\nconst DashboardLayout = () => {\n  return (\n    <div style={{ display: 'flex', height: '100vh' }}>\n      <nav style={{ padding: '20px', borderRight: '1px solid #ccc', minWidth: '150px' }}>\n        <h3>Dashboard Navigation</h3>\n        <ul>\n          <li><Link to=\"/dashboard\">Overview</Link></li>\n          <li><Link to=\"profile\">Profile</Link></li>\n          <li><Link to=\"settings\">Settings</Link></li>\n        </ul>\n      </nav>\n      <main style={{ flexGrow: 1, padding: '20px' }}>\n        {/* The Outlet component renders the matched child route */}\n        <Outlet /> \n      </main>\n    </div>\n  );\n};\n\n// DashboardOverview component\nconst DashboardOverview = () => (\n  <div>\n    <h2>Dashboard Overview</h2>\n    <p>Welcome to your personalized dashboard overview.</p>\n  </div>\n);\n\n// UserProfile component\nconst UserProfile = () => (\n  <div>\n    <h2>User Profile</h2>\n    <p>Manage your profile information here.</p>\n  </div>\n);\n\n// AppSettings component\nconst AppSettings = () => (\n  <div>\n    <h2>Application Settings</h2>\n    <p>Configure application settings.</p>\n  </div>\n);\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<h1>Home Page</h1>} />\n        {/* Parent route for dashboard layout and nested routes */}\n        <Route path=\"dashboard\" element={<DashboardLayout />}>\n          {/* Index route for /dashboard (renders when parent path exactly matches) */}\n          <Route index element={<DashboardOverview />} />\n          {/* Nested routes. Paths are relative to the parent route's path. */}\n          <Route path=\"profile\" element={<UserProfile />} />\n          <Route path=\"settings\" element={<AppSettings />} />\n        </Route>\n        {/* Catch-all route for any unmatched paths */}\n        <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n",
          "testCases": [
            "Initial navigation to `/dashboard`: Should display `DashboardLayout` with `DashboardOverview` inside the `Outlet`.",
            "Navigation to `/dashboard/profile`: Should keep `DashboardLayout` visible and render `UserProfile` inside the `Outlet`.",
            "Navigation to `/dashboard/settings`: Should keep `DashboardLayout` visible and render `AppSettings` inside the `Outlet`.",
            "Sidebar links: Clicking 'Overview' link in the sidebar navigates to `/dashboard` and shows `DashboardOverview`. Similarly for 'Profile' and 'Settings'.",
            "Direct URL access: Entering `/dashboard/profile` directly in the browser should load the correct layout and content.",
            "Non-dashboard route: Navigating to `/` should show the `Home Page` and not the `DashboardLayout`."
          ],
          "hints": [
            "The `Outlet` component is crucial; it marks where the child route's element will be rendered.",
            "Use the `index` prop on a `Route` to specify the component that renders when the parent route's path is matched exactly.",
            "When defining child routes within a parent `Route`, their `path` props are relative to the parent's path.",
            "Ensure your `Link` components for nested routes use the correct relative or absolute paths (e.g., `<Link to=\"profile\">` or `<Link to=\"/dashboard/profile\">`)."
          ],
          "tags": [
            "React Router",
            "Nested Routes",
            "Layouts",
            "UI Architecture",
            "Component Composition"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_router_basics",
            "component_composition",
            "react_functional_components"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_advanced_react_router_nested_routes_layouts"
          ]
        },
        {
          "id": "task_dynamic_nested_routes",
          "title": "Dynamic Nested Routes with Params",
          "description": "\nExtend the previous dashboard example to include a dynamic nested route for viewing individual user details. This task will combine the concepts of nested routes, layouts, and route parameters.\n\n**Requirements:**\n1.  Add a new section to the dashboard sidebar called 'Users'.\n2.  When 'Users' is clicked, it should navigate to `/dashboard/users` and display a `UserListPage` which lists a few dummy users (e.g., 'Alice', 'Bob', 'Charlie'). Each user name should be a `Link`.\n3.  Clicking on a user's name (e.g., 'Alice') should navigate to a dynamic route like `/dashboard/users/alice` and render a `UserDetailPage`.\n4.  The `UserDetailPage` should display the name of the user obtained from the URL parameter.\n5.  Both `UserListPage` and `UserDetailPage` should render within the `DashboardLayout`.\n\n**Considerations:**\n*   How will you define the dynamic route with parameters in React Router v6?\n*   How will you access the parameter value in `UserDetailPage`?\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Outlet, Link, useParams } from 'react-router-dom';\n\n// DashboardLayout, DashboardOverview, UserProfile, AppSettings from previous task (assume they are defined)\n// ... (copy/paste the solution code for DashboardLayout, DashboardOverview, UserProfile, AppSettings from task_implement_dashboard_layout)\n\n// TODO: Implement UserListPage\nconst UserListPage = () => {\n  const users = ['Alice', 'Bob', 'Charlie'];\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {/* TODO: Map users to Links to their detail pages */}\n      </ul>\n    </div>\n  );\n};\n\n// TODO: Implement UserDetailPage\nconst UserDetailPage = () => {\n  // TODO: Get user ID from URL params\n  // const { userId } = useParams();\n  return (\n    <div>\n      <h2>User Detail</h2>\n      {/* <p>Details for user: {userId}</p> */}\n    </div>\n  );\n};\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<h1>Home Page</h1>} />\n        <Route path=\"dashboard\" element={<div>{/* Assume DashboardLayout here */}</div>}> {/* Placeholder */}\n          <Route index element={<div>{/* Assume DashboardOverview here */}</div>} /> {/* Placeholder */}\n          <Route path=\"profile\" element={<div>{/* Assume UserProfile here */}</div>} /> {/* Placeholder */}\n          <Route path=\"settings\" element={<div>{/* Assume AppSettings here */}</div>} /> {/* Placeholder */}\n          {/* TODO: Add routes for users list and dynamic user detail */}\n        </Route>\n        <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Outlet, Link, useParams } from 'react-router-dom';\n\n// Reusing components from task_implement_dashboard_layout:\nconst DashboardLayout = () => {\n  return (\n    <div style={{ display: 'flex', height: '100vh' }}>\n      <nav style={{ padding: '20px', borderRight: '1px solid #ccc', minWidth: '150px' }}>\n        <h3>Dashboard Navigation</h3>\n        <ul>\n          <li><Link to=\"/dashboard\">Overview</Link></li>\n          <li><Link to=\"profile\">Profile</Link></li>\n          <li><Link to=\"settings\">Settings</Link></li>\n          <li><Link to=\"users\">Users</Link></li> {/* New link for Users */}\n        </ul>\n      </nav>\n      <main style={{ flexGrow: 1, padding: '20px' }}>\n        <Outlet /> \n      </main>\n    </div>\n  );\n};\n\nconst DashboardOverview = () => (\n  <div>\n    <h2>Dashboard Overview</h2>\n    <p>Welcome to your personalized dashboard overview.</p>\n  </div>\n);\n\nconst UserProfile = () => (\n  <div>\n    <h2>User Profile</h2>\n    <p>Manage your profile information here.</p>\n  </div>\n);\n\nconst AppSettings = () => (\n  <div>\n    <h2>Application Settings</h2>\n    <p>Configure application settings.</p>\n  </div>\n);\n\n// New: UserListPage component\nconst UserListPage = () => {\n  const users = ['alice', 'bob', 'charlie']; // Using lowercase for URL consistency\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user}>\n            <Link to={user}>{user.charAt(0).toUpperCase() + user.slice(1)}</Link>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\n// New: UserDetailPage component\nconst UserDetailPage = () => {\n  const { userId } = useParams(); // Access the dynamic URL parameter\n  return (\n    <div>\n      <h2>User Detail: {userId ? userId.charAt(0).toUpperCase() + userId.slice(1) : 'Not found'}</h2>\n      <p>This page displays details for user: <strong>{userId}</strong>.</p>\n      {/* In a real app, you would fetch user data based on userId */}\n    </div>\n  );\n};\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<h1>Home Page</h1>} />\n        <Route path=\"dashboard\" element={<DashboardLayout />}>\n          <Route index element={<DashboardOverview />} />\n          <Route path=\"profile\" element={<UserProfile />} />\n          <Route path=\"settings\" element={<AppSettings />} />\n          \n          {/* Nested routes for users */}\n          <Route path=\"users\" element={<UserListPage />} /> {/* List page */}\n          <Route path=\"users/:userId\" element={<UserDetailPage />} /> {/* Dynamic detail page */}\n        </Route>\n        <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n",
          "testCases": [
            "Navigation to `/dashboard/users`: Should display the UserListPage within the DashboardLayout.",
            "Clicking user link: Clicking 'Alice' on the UserListPage should navigate to `/dashboard/users/alice` and display 'User Detail: Alice' in the UserDetailPage.",
            "Direct URL access for dynamic route: Visiting `/dashboard/users/bob` directly should show 'User Detail: Bob'.",
            "Invalid dynamic parameter: Visiting `/dashboard/users/nonexistent` should still render `UserDetailPage` with 'nonexistent' as the user ID (demonstrating how params work, not handling invalid data yet).",
            "Back button functionality: Navigating to a user detail page and then using the browser's back button should return to the user list page, still within the layout."
          ],
          "hints": [
            "To define a dynamic segment in a route path, use a colon (`:`) followed by the parameter name (e.g., `/:userId`).",
            "The `useParams` hook from `react-router-dom` is used to access route parameters within your component.",
            "Ensure your `Link` components for dynamic routes correctly construct the path (e.g., `/dashboard/users/${user.id}`).",
            "Remember that the dynamic route must be placed after any static routes at the same level if there's ambiguity, or use `index` more carefully, though in this case `users` and `users/:userId` are distinct enough."
          ],
          "tags": [
            "React Router",
            "Nested Routes",
            "Route Params",
            "Dynamic Routing",
            "Hooks",
            "UI Architecture"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_router_basics",
            "theory_advanced_react_router_nested_routes_layouts",
            "react_hooks_basics"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_advanced_react_router_nested_routes_layouts"
          ]
        }
      ]
    }
  },
  {
    "id": "7693f2a5-396a-4ef5-9d31-e0f6c21e1415",
    "startLine": 6600,
    "endLine": 6699,
    "processedDate": "2025-06-17T10:03:28.443Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_router_basics_nested_routes",
          "title": "React Router Basics and Nested Routes",
          "content": "React Router is a standard library for routing in React applications. It enables navigation between different components based on the URL. Key components include `Routes` (a wrapper for all route definitions), `Route` (which defines a mapping between a URL path and a component), and `Outlet` (used for rendering child routes).\n\n## Core Concepts\n\n*   **`Routes` Component**: This component acts as a container for all your `Route` definitions. It listens to the URL and renders the first child `Route` that matches the current location.\n*   **`Route` Component**: Each `Route` component specifies a `path` (the URL segment it matches) and an `element` (the React component to render when the path matches).\n    *   **`path`**: A string representing the URL path. Can include dynamic segments (e.g., `:id`).\n    *   **`element`**: The JSX element to render when the route matches.\n*   **Nested Routes**: React Router allows for nested routing, where a parent route can have its own child routes. This is particularly useful for building layouts where a common UI (like a header, sidebar, or footer) remains consistent while only a specific content area changes.\n*   **`Outlet` Component**: When using nested routes, the `Outlet` component from `react-router-dom` is crucial. It acts as a placeholder where the matched child route's `element` will be rendered. The parent route's component is responsible for rendering the `Outlet` at the desired location within its layout.\n*   **`index` Route**: Within a `Route` that defines nested routes, an `index` route (a `Route` without a `path` property but with an `index` prop) serves as the default child route to render when the parent path is matched but no specific child path is specified. This is useful for defining a default view for a section of your application.\n\n## How Nested Routes Work\nWhen a parent `Route` (e.g., `/dashboard`) is matched, its `element` component is rendered. Inside this component, an `Outlet` component is placed. If a child route (e.g., `/dashboard/stats`) is then matched, the component for `/dashboard/stats` is rendered *inside* the `Outlet` of the `Dashboard` component. This allows for hierarchical UI structures and shared layouts.",
          "examples": [
            {
              "id": "example_react_router_basics_1",
              "title": "Basic App Routing Structure",
              "code": "import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport Home from './components/Home';\nimport Dashboard from './components/Dashboard';\nimport Products from './components/Products';\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Home />} />\n      <Route path=\"dashboard\" element={<Dashboard />} />\n      <Route path=\"products\" element={<Products />} />\n    </Routes>\n  );\n}",
              "explanation": "This example shows a basic `App` component setting up multiple top-level routes. When the URL matches `/`, the `Home` component is rendered. Similarly, `Dashboard` and `Products` components are rendered for their respective paths.",
              "language": "typescript"
            },
            {
              "id": "example_react_router_nested_routes_2",
              "title": "Nested Routes with Layout and Outlet",
              "code": "import React from 'react';\nimport { Routes, Route, Outlet } from 'react-router-dom';\nimport Home from './components/Home';\nimport Dashboard from './components/Dashboard';\nimport Stats from './components/Stats';\nimport Profile from './components/Profile';\nimport Products from './components/Products';\n\n// Layout component for shared UI\nfunction Layout() {\n  return (\n    <div>\n      <header>App Header</header>\n      <nav>Sidebar Navigation</nav>\n      <main>\n        {/* Child routes render here */}\n        <Outlet /> \n      </main>\n      <footer>App Footer</footer>\n    </div>\n  );\n}\n\n// Main App routing setup\nfunction App() {\n  return (\n    <Routes>\n      {/* Parent Route for shared layout */}\n      <Route path=\"/\" element={<Layout />}>\n        {/* Index route for the root path within the layout */}\n        <Route index element={<Home />} />\n        \n        {/* Nested Dashboard routes */}\n        <Route path=\"dashboard\" element={<Dashboard />}>\n          <Route path=\"stats\" element={<Stats />} />\n          <Route path=\"profile\" element={<Profile />} />\n        </Route>\n        \n        {/* Another top-level route under the main layout */}\n        <Route path=\"products\" element={<Products />} />\n      </Route>\n    </Routes>\n  );\n}",
              "explanation": "This example demonstrates nested routing. The `Layout` component provides a consistent header, sidebar, and footer. The `<Outlet />` within `Layout` determines where child routes like `Home`, `Dashboard`, and `Products` (or `Stats`/`Profile` within `Dashboard`) will be rendered. The `index` route `Home` serves as the default content for the `/` path when `Layout` is active.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_outlet_purpose",
            "question_nested_route_element",
            "question_index_route_vs_path",
            "question_nested_routes_benefit"
          ],
          "relatedTasks": [
            "task_nested_layout_implementation"
          ],
          "tags": [
            "React Router",
            "Routing",
            "Nested Routes",
            "UI Layout",
            "Outlet",
            "React"
          ],
          "technology": "React, React Router DOM",
          "prerequisites": [
            "react_components",
            "jsx",
            "functional_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_app_routing",
            "shared_layouts"
          ]
        },
        {
          "id": "theory_route_guards_authentication",
          "title": "Route Guards with Authentication (Protected Routes)",
          "content": "Route guards, or protected routes, are a crucial pattern in web applications to restrict access to certain pages based on user authentication status or roles. In React Router, this is commonly achieved by wrapping a protected component with a higher-order component or a custom component that checks the authentication state and redirects the user if they don't meet the access requirements.\n\n## Key Concepts\n\n*   **`PrivateRoute` Component Pattern**: This pattern involves creating a dedicated component (e.g., `PrivateRoute`) that acts as a gatekeeper. It takes the component to be protected (`children`) as a prop. Before rendering `children`, it checks the user's authentication status.\n*   **Authentication State (`useAuth`)**: The authentication state typically comes from a global state management solution (like Redux, React Context API, or a custom authentication hook). The `useAuth()` hook in the example is a placeholder for such a mechanism that provides `isAuthenticated` status.\n*   **`useNavigate` Hook**: This hook from `react-router-dom` is used for programmatic navigation (i.e., navigating to a different URL via code, rather than user clicks on `Link` components). It returns a `navigate` function.\n*   **`useEffect` for Redirection**: The `useEffect` hook is used within `PrivateRoute` to perform the redirection logic. It runs after every render where its dependencies change. If `auth.isAuthenticated` becomes false, or `navigate` changes, the effect checks the condition and triggers a redirection.\n*   **Passing State During Redirection**: When redirecting an unauthenticated user to a login page, it's a common practice to pass the original location they tried to access. This is done using the `state` option in `navigate('/login', { state: { from: location } })`. After successful login, the user can then be redirected back to their intended page (`location.state.from`). The `location` object itself is available via the `useLocation` hook in React Router DOM.\n*   **Conditional Rendering**: The `PrivateRoute` component conditionally renders its `children` (the protected component) only if `auth.isAuthenticated` is true. Otherwise, it might render a `LoadingSpinner` or nothing, before the `useEffect` redirects the user.\n\nThis pattern ensures that sensitive parts of the application are only accessible to authorized users, enhancing security and user experience by guiding users through the authentication flow.",
          "examples": [
            {
              "id": "example_private_route_1",
              "title": "Basic PrivateRoute Implementation",
              "code": "import React, { useEffect, useState } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\n// Dummy useAuth hook for demonstration\nconst useAuth = () => {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  // In a real app, this would check a token, context, or Redux state\n  useEffect(() => {\n    // Simulate async auth check\n    const token = localStorage.getItem('authToken');\n    setIsAuthenticated(!!token); // Set true if token exists\n  }, []);\n  return { isAuthenticated };\n};\n\nfunction PrivateRoute({ children }) {\n  const auth = useAuth(); // Your custom hook for auth state\n  const navigate = useNavigate();\n  const location = useLocation(); // To get current location and pass it\n  \n  useEffect(() => {\n    if (!auth.isAuthenticated) {\n      // Redirect to login, preserving the path user tried to access\n      navigate('/login', { state: { from: location } });\n    }\n  }, [auth.isAuthenticated, navigate, location]);\n  \n  // Render children if authenticated, otherwise a loading spinner or null\n  return auth.isAuthenticated ? children : <div>Loading...</div>; // Or a proper LoadingSpinner component\n}",
              "explanation": "This `PrivateRoute` component uses a mock `useAuth` hook to check authentication status. If the user is not authenticated, it uses `useNavigate` to redirect them to the `/login` path, passing the current `location` (the path they attempted to access) in the navigation state. If authenticated, it renders the `children` (the protected content).",
              "language": "typescript"
            },
            {
              "id": "example_app_with_private_route_2",
              "title": "Integrating PrivateRoute into App Routing",
              "code": "import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport Login from './components/Login';\nimport Signup from './components/Signup';\nimport Dashboard from './components/Dashboard';\n// Assume PrivateRoute component from the previous example is imported\n\n// ... PrivateRoute component definition ...\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/signup\" element={<Signup />} />\n      {/* Protect the Dashboard route */}\n      <Route \n        path=\"/dashboard\" \n        element={\n          <PrivateRoute>\n            <Dashboard />\n          </PrivateRoute>\n        } \n      />\n      {/* More routes... */}\n    </Routes>\n  );\n}",
              "explanation": "This example shows how `PrivateRoute` is used within the main `App` component's routing setup. The `/dashboard` path is now protected; any attempt to access it will first go through the `PrivateRoute` component, which will handle the authentication check and redirection if necessary.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_private_route_purpose",
            "question_use_navigate_in_private_route",
            "question_passing_state_on_redirect",
            "question_private_route_redirect_flow"
          ],
          "relatedTasks": [
            "task_implement_protected_route"
          ],
          "tags": [
            "React Router",
            "Authentication",
            "Authorization",
            "Route Guards",
            "Hooks",
            "Programmatic Navigation",
            "Security"
          ],
          "technology": "React, React Router DOM",
          "prerequisites": [
            "react_hooks_basics",
            "state_management_basics",
            "react_router_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "user_authentication_systems",
            "role_based_access_control"
          ]
        },
        {
          "id": "theory_react_router_redux_integration",
          "title": "React Router with Redux Integration (Legacy `react-router-redux`)",
          "content": "In applications using both React Router and Redux, there was a common need to keep the router's state synchronized with the Redux store. This integration allows the application's URL and navigation history to be part of the Redux state tree, enabling features like time-travel debugging for navigation or dispatching navigation actions from Redux actions/sagas.\n\n## Key Concepts\n\n*   **`react-router-redux` (Legacy)**: This library (and its successor `connected-react-router`) provided middleware and components to connect React Router's history object to the Redux store. This meant that changes in the URL would update the Redux state, and dispatching Redux actions could trigger navigation.\n*   **`history` Library**: `react-router-redux` internally relies on the `history` library, which provides a way to manage session history in JavaScript. `createBrowserHistory` from `history/createBrowserHistory` (for older versions) or `createBrowserHistory` from `'history'` (for newer versions) is used to create a history object that `ConnectedRouter` can then use.\n*   **`Provider` (Redux)**: As standard with Redux, the `Provider` component makes the Redux store available to any nested components that need to access it.\n*   **`ConnectedRouter`**: This component (from `react-router-redux` or `connected-react-router`) wraps your `Routes` (or `Router` in older versions) and connects the router's history to the Redux store. It takes the `history` object and the `store` as props.\n*   **Synchronization Benefit**: By syncing router state, developers could centralize more application state, enabling powerful patterns like dispatching `PUSH` or `REPLACE` actions from Redux reducers or sagas/thunks, making navigation testable and debuggable via Redux DevTools.\n\n**Note**: With React Router v6 and its focus on hooks (`useNavigate`, `useLocation`, `useParams`), the need to manually sync router state with Redux using `react-router-redux` or `connected-react-router` has largely diminished for typical use cases. Most routing logic can now be handled directly within components using these hooks. However, for specific advanced scenarios (e.g., dispatching navigation from Redux middleware or preserving router state in a global store), patterns combining `history` (from the `history` package) with Redux can still be relevant.",
          "examples": [
            {
              "id": "example_react_router_redux_setup_1",
              "title": "Redux and React Router Setup with `react-router-redux` (Legacy)",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { Route, Routes } from 'react-router-dom'; // Using Routes for modern React Router v6 syntax\nimport { createBrowserHistory } from 'history'; // Modern history library import\nimport { unstable_HistoryRouter as HistoryRouter } from 'react-router-dom'; // For using custom history object in React Router v6\n\nimport configureStore from './store'; // Assume this configures Redux store with router middleware\nimport App from './App';\n\nconst history = createBrowserHistory();\nconst store = configureStore(history); // Pass history to store configuration if router middleware is used\n\nReactDOM.render(\n  <Provider store={store}>\n    {/* \n      In React Router v6, ConnectedRouter is not directly available from react-router-redux. \n      You would typically use unstable_HistoryRouter with a custom history object \n      if you need to manage history outside of React Router's internal state. \n      The original markdown's `ConnectedRouter` is from an older version. \n    */}\n    <HistoryRouter history={history}>\n      <App /> {/* App would contain Routes and Route components */}\n    </HistoryRouter>\n  </Provider>,\n  document.getElementById('root')\n);\n",
              "explanation": "This example shows a typical setup for integrating `react-router-redux` (or `connected-react-router`) with a Redux store. A `history` object is created and used with `unstable_HistoryRouter` (for React Router v6 compatibility, acknowledging the original content's older context). The Redux `Provider` wraps the entire application, making the store available, and the `HistoryRouter` connects the routing mechanism to this external `history` object, which in turn could be connected to Redux via middleware.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_router_redux_purpose",
            "question_connected_router_role",
            "question_history_library_role",
            "question_redux_router_advantages"
          ],
          "relatedTasks": [
            "task_integrate_redux_router"
          ],
          "tags": [
            "React Router",
            "Redux",
            "State Management",
            "Integration",
            "Legacy",
            "History API"
          ],
          "technology": "React, Redux, React Router DOM",
          "prerequisites": [
            "redux_fundamentals",
            "react_router_basics",
            "middleware_concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_state_management",
            "time_travel_debugging"
          ]
        },
        {
          "id": "theory_programmatic_navigation",
          "title": "Programmatic Navigation and Redirection",
          "content": "Programmatic navigation refers to triggering a change in the URL and page without direct user interaction with a `Link` component. This is essential for scenarios like redirects after form submissions, authentication flows, or navigating based on application logic. React Router provides hooks for this purpose in modern versions, while older versions relied on a `browserHistory` object.\n\n## Key Concepts\n\n*   **Manual Redirection**: The act of changing the current URL from within your JavaScript code, often in response to an event (e.g., successful login, form submission, API call completion).\n*   **`browserHistory` (Legacy)**: In older versions of React Router (v3-v4), the `browserHistory` object was a global singleton that provided methods like `push` to imperatively change the URL. It was imported directly and could be used anywhere in the application.\n    *   `browserHistory.push('/some/path')`: Navigates to the specified path.\n    *   `browserHistory.push({ pathname: '/some/path', state: { data: 'value' } })`: Navigates to a path and passes arbitrary state data, which can be retrieved on the destination component using `location.state`.\n*   **`useNavigate` Hook (Modern)**: In React Router v6+, the `useNavigate` hook is the primary way to perform programmatic navigation. It returns a `navigate` function that you can call with a path or a path object. This hook should be used within a React component or a custom hook.\n    *   `navigate('/some/path')`: Similar to `push`, navigates to a new path.\n    *   `navigate('/some/path', { replace: true })`: Replaces the current entry in the history stack instead of adding a new one.\n    *   `navigate('/some/path', { state: { data: 'value' } })`: Passes state data, accessible via `useLocation().state` at the destination.\n    *   `navigate(-1)`: Navigates back one entry in the history stack.\n*   **Passing State**: Both `browserHistory.push` and `useNavigate` allow passing a `state` object along with the navigation. This state is not part of the URL but is accessible via the `useLocation` hook (`location.state`) on the target component. It's useful for passing small, ephemeral data between routes without cluttering the URL parameters.\n\nThe `useNavigate` hook is the recommended approach for modern React Router applications due to its integration with React's component lifecycle and its declarative nature.",
          "examples": [
            {
              "id": "example_browser_history_legacy_1",
              "title": "Programmatic Redirection with `browserHistory` (Legacy)",
              "code": "// In older versions of React Router (v3-v4)\nimport { browserHistory } from 'react-router';\n\nfunction handleLoginSuccess() {\n  // Redirect to another path\n  browserHistory.push('/dashboard');\n\n  // Redirect with state\n  browserHistory.push({\n    pathname: '/user/profile',\n    state: { userId: 123, fromDashboard: true }\n  });\n}\n\n// Example of retrieving state on the target component (e.g., in UserProfile component)\n// import { withRouter } from 'react-router'; // for class components\n// import { useLocation } from 'react-router-dom'; // for functional components\n\n// function UserProfile() {\n//   const location = useLocation();\n//   const { userId, fromDashboard } = location.state || {};\n//   // ... render logic using userId and fromDashboard\n// }",
              "explanation": "This demonstrates how `browserHistory.push` was used in older React Router versions to perform redirects. It shows both simple path navigation and navigation with an associated `state` object, which allows passing additional data to the target route without it appearing in the URL.",
              "language": "typescript"
            },
            {
              "id": "example_use_navigate_modern_2",
              "title": "Programmatic Redirection with `useNavigate` (Modern)",
              "code": "import React from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\nfunction LoginForm() {\n  const navigate = useNavigate();\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    // Simulate login success\n    const loginSuccess = true; \n\n    if (loginSuccess) {\n      // Redirect to dashboard, replacing current entry in history\n      navigate('/dashboard', { replace: true, state: { loginTime: new Date().toISOString() } });\n    } else {\n      alert('Login failed!');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"text\" placeholder=\"Username\" />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\n// On the Dashboard component, to retrieve state:\nfunction Dashboard() {\n  const location = useLocation();\n  const { loginTime } = location.state || {};\n\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      {loginTime && <p>Logged in at: {new Date(loginTime).toLocaleString()}</p>}\n    </div>\n  );\n}",
              "explanation": "This modern example uses the `useNavigate` hook for programmatic navigation. After a simulated login, it navigates to `/dashboard`, replacing the current history entry and passing a `loginTime` via the state object. The `Dashboard` component then retrieves and displays this `loginTime` using the `useLocation` hook.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_browser_history_vs_use_navigate",
            "question_when_to_use_programmatic_navigation",
            "question_pass_state_in_navigation",
            "question_navigate_replace_option"
          ],
          "relatedTasks": [
            "task_implement_programmatic_navigation"
          ],
          "tags": [
            "React Router",
            "Navigation",
            "Programmatic",
            "Hooks",
            "History API",
            "useNavigate",
            "useLocation"
          ],
          "technology": "React, React Router DOM",
          "prerequisites": [
            "react_hooks_basics",
            "react_router_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "form_handling",
            "authentication_flows"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_outlet_purpose",
          "topic": "React Router Nested Routes",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the `<Outlet />` component in React Router DOM?",
          "answer": "To render child route elements within a parent route's component.",
          "options": [
            "To define the root component of the application.",
            "To navigate programmatically between routes.",
            "To render child route elements within a parent route's component.",
            "To define a protected route that requires authentication."
          ],
          "analysisPoints": [
            "Tests understanding of React Router's nested routing mechanism.",
            "Distinguishes `Outlet` from other routing components/hooks.",
            "Emphasizes the role of `Outlet` in layout composition."
          ],
          "keyConcepts": [
            "Outlet",
            "Nested Routes",
            "React Router DOM",
            "Layouts"
          ],
          "evaluationCriteria": [
            "Correct identification of `Outlet`'s function.",
            "Ability to differentiate `Outlet` from other React Router features."
          ],
          "example": "The `<Outlet />` component acts as a placeholder in a parent layout component (e.g., `Layout.js`). When a nested route matches, its element is rendered at the position of `<Outlet />`. For example:\n\n```jsx\n// Layout.js\nfunction Layout() {\n  return (\n    <div>\n      <h1>My App Header</h1>\n      <nav>{/* Navigation links */}</nav>\n      <main>\n        <Outlet /> {/* Child components render here */}\n      </main>\n      <footer>My App Footer</footer>\n    </div>\n  );\n}\n\n// App.js\n<Routes>\n  <Route path=\"/\" element={<Layout />}>\n    <Route path=\"about\" element={<About />} />\n    <Route path=\"contact\" element={<Contact />} />\n  </Route>\n</Routes>\n```\n\nWhen navigating to `/about`, the `About` component will be rendered inside the `<main>` tag where `<Outlet />` is placed in `Layout`.",
          "tags": [
            "React Router",
            "Outlet",
            "Nested Routes",
            "Layout"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_nested_route_element",
          "topic": "React Router Nested Routes",
          "level": "medium",
          "type": "code",
          "question": "Consider the following `App` and `Dashboard` component structure using React Router v6. Complete the `Dashboard` component so that `Stats` and `Profile` components render inside it when the respective nested paths (`/dashboard/stats` and `/dashboard/profile`) are accessed, using the `Outlet` component.",
          "answer": "```jsx\nimport React from 'react';\nimport { Routes, Route, Outlet, Link } from 'react-router-dom';\n\n// Assume Home, Stats, Profile, Products components are defined elsewhere\nfunction Home() { return <h2>Home Page</h2>; }\nfunction Stats() { return <h3>Statistics View</h3>; }\nfunction Profile() { return <h3>User Profile View</h3>; }\nfunction Products() { return <h2>Products Page</h2>; }\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h2>Dashboard</h2>\n      <nav>\n        <Link to=\"stats\">View Stats</Link> | \n        <Link to=\"profile\">View Profile</Link>\n      </nav>\n      {/* Child routes render here */}\n      <Outlet />\n    </div>\n  );\n}\n\nfunction Layout() {\n  return (\n    <div>\n      <header>App Header</header>\n      <nav>\n        <Link to=\"/\">Home</Link> | \n        <Link to=\"dashboard\">Dashboard</Link> | \n        <Link to=\"products\">Products</Link>\n      </nav>\n      <main>\n        <Outlet />\n      </main>\n      <footer>App Footer</footer>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route index element={<Home />} />\n        <Route path=\"dashboard\" element={<Dashboard />}>\n          <Route path=\"stats\" element={<Stats />} />\n          <Route path=\"profile\" element={<Profile />} />\n        </Route>\n        <Route path=\"products\" element={<Products />} />\n      </Route>\n    </Routes>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to implement nested routing.",
            "Verifies correct usage of `Outlet` within a parent component.",
            "Checks understanding of how child routes are structured under a parent `Route`."
          ],
          "keyConcepts": [
            "Outlet",
            "Nested Routes",
            "React Router DOM",
            "Route"
          ],
          "evaluationCriteria": [
            "Correct placement of `<Outlet />`.",
            "Proper definition of nested `Route` components within the `Routes` tree."
          ],
          "example": "The key is to place `<Outlet />` inside the `Dashboard` component, as `Dashboard` is the parent component for `/dashboard/stats` and `/dashboard/profile`. The `<Outlet />` serves as the rendering spot for `Stats` or `Profile` when their respective paths are matched.",
          "tags": [
            "React Router",
            "Code Challenge",
            "Nested Routes",
            "Outlet"
          ],
          "prerequisites": [
            "react_router_basics",
            "jsx"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_index_route_vs_path",
          "topic": "React Router Nested Routes",
          "level": "open",
          "type": "open",
          "question": "Explain the difference between an `index` route and a `path` route within a nested routing structure in React Router DOM. Provide a scenario where an `index` route would be particularly useful.",
          "answer": "An `index` route in React Router DOM is a special type of child `Route` that renders when its parent route's `path` matches exactly, and no other child `path` route also matches. It's defined using the `index` prop instead of a `path` prop (e.g., `<Route index element={<Home />} />`).\n\nIn contrast, a `path` route is a standard `Route` that renders when its specific `path` matches, usually in conjunction with its parent's path (e.g., `<Route path=\"profile\" element={<Profile />} />` within a `/dashboard` parent route, meaning `/dashboard/profile`).\n\n**Key Differences:**\n*   **Matching Condition**: An `index` route matches when the *parent's path* is matched *without any further path segments*. A `path` route matches when its specific `path` segment (combined with its parent's path) is matched.\n*   **URL Segment**: An `index` route does not add a segment to the URL. A `path` route adds its defined segment to the URL.\n*   **Default Behavior**: An `index` route acts as the default child route that is rendered when the parent route is active but no specific child route is navigated to. This is crucial for providing a landing view for a section of the application.\n\n**Scenario where an `index` route is useful:**\nConsider a `/dashboard` route that displays a shared navigation bar and a content area. When a user navigates to `/dashboard` (i.e., exactly the parent path), you want to show a 'Dashboard Overview' component by default, without requiring a URL like `/dashboard/overview`. However, if the user navigates to `/dashboard/settings` or `/dashboard/reports`, those specific components should be shown. An `index` route is perfect for this 'Dashboard Overview' component:\n\n```jsx\n<Route path=\"dashboard\" element={<DashboardLayout />}>\n  <Route index element={<DashboardOverview />} /> {/* Renders for /dashboard */}\n  <Route path=\"settings\" element={<DashboardSettings />} /> {/* Renders for /dashboard/settings */}\n  <Route path=\"reports\" element={<DashboardReports />} /> {/* Renders for /dashboard/reports */}\n</Route>\n```\n\nIn this setup, `DashboardOverview` is the default content for `/dashboard`, providing a clean and intuitive user experience without forcing a redundant URL segment.",
          "options": [],
          "analysisPoints": [
            "Tests conceptual understanding of route matching.",
            "Ability to articulate nuanced differences.",
            "Demonstrates practical application with a relevant scenario."
          ],
          "keyConcepts": [
            "Index Route",
            "Path Route",
            "Nested Routes",
            "React Router DOM",
            "Default Route"
          ],
          "evaluationCriteria": [
            "Clear and accurate definition of both types of routes.",
            "Correctly identifies matching behavior and URL impact.",
            "Provides a fitting, clear example scenario."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Nested Routes",
            "Index Route",
            "Routing Concepts"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_private_route_purpose",
          "topic": "Route Guards with Authentication",
          "level": "flashcard",
          "type": "flashcard",
          "question": "What is the primary purpose of a `PrivateRoute` component in React Router?",
          "answer": "To restrict access to certain routes based on user authentication status or roles, redirecting unauthenticated/unauthorized users.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "PrivateRoute",
            "Route Guards",
            "Authentication",
            "Authorization",
            "Redirection"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "React Router",
            "Authentication",
            "Route Guards"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_navigate_in_private_route",
          "topic": "Route Guards with Authentication",
          "level": "mcq",
          "type": "mcq",
          "question": "In the `PrivateRoute` component provided, which hook is used to programmatically redirect an unauthenticated user to the login page?",
          "answer": "`useNavigate`",
          "options": [
            "`useLocation`",
            "`useParams`",
            "`useNavigate`",
            "`useEffect`"
          ],
          "analysisPoints": [
            "Tests knowledge of React Router DOM hooks.",
            "Specifically targets the hook for programmatic navigation.",
            "Distinguishes navigation from other routing utilities."
          ],
          "keyConcepts": [
            "useNavigate",
            "PrivateRoute",
            "Programmatic Navigation",
            "React Router Hooks"
          ],
          "evaluationCriteria": [
            "Correct identification of the `useNavigate` hook.",
            "Understanding its role in imperative navigation."
          ],
          "example": "The `useNavigate` hook returns a function that allows you to change the current URL. In the `PrivateRoute` example, `navigate('/login', { state: { from: location } })` is called when the user is not authenticated to redirect them to the login page.\n\n```typescript\nimport { useNavigate, useLocation } from 'react-router-dom';\n\nfunction PrivateRoute({ children }) {\n  const auth = { isAuthenticated: false }; // Simplified for example\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  if (!auth.isAuthenticated) {\n    // This is where navigate is used for redirection\n    navigate('/login', { state: { from: location } });\n    return null; // Or a loading spinner\n  }\n  return children;\n}\n```",
          "tags": [
            "React Router",
            "Hooks",
            "useNavigate",
            "PrivateRoute"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_router_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_passing_state_on_redirect",
          "topic": "Route Guards with Authentication",
          "level": "open",
          "type": "open",
          "question": "In the `PrivateRoute` example, why is `location` passed in the state object during redirection (`navigate('/login', { state: { from: location } })`)? How would the login component typically use this information?",
          "answer": "The `location` object is passed in the `state` object during redirection (`navigate('/login', { state: { from: location } })`) to remember the original route the user was trying to access before being redirected to the login page. This allows for a better user experience by enabling the application to redirect the user back to their intended destination after a successful login.\n\n**How the login component typically uses this information:**\n\n1.  **Retrieving the State**: The login component would use the `useLocation` hook from `react-router-dom` to access the `location.state` object.\n    ```typescript\n    import { useLocation, useNavigate } from 'react-router-dom';\n\n    function Login() {\n      const location = useLocation();\n      const navigate = useNavigate();\n      const from = location.state?.from?.pathname || '/dashboard'; // Default to dashboard\n\n      const handleLoginSuccess = () => {\n        // Simulate successful authentication\n        // ... auth logic ...\n\n        // Redirect back to the original path or a default path\n        navigate(from, { replace: true });\n      };\n\n      // ... rest of login component logic and JSX\n      return (\n        <div>\n          <h2>Login</h2>\n          <button onClick={handleLoginSuccess}>Log In</button>\n        </div>\n      );\n    }\n    ```\n\n2.  **Post-Login Redirection**: After the user successfully authenticates (e.g., by clicking a login button or submitting a form), the login component would then use `useNavigate` to redirect the user to the `from` path retrieved from `location.state`. It's common to use `{ replace: true }` with `navigate` to prevent the login page from staying in the browser history after a successful login, so the user can't hit 'back' to return to the login page.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of navigation state (`location.state`).",
            "Evaluates knowledge of common authentication flow patterns.",
            "Checks ability to connect different parts of a routing system."
          ],
          "keyConcepts": [
            "location.state",
            "useLocation",
            "useNavigate",
            "Authentication Flow",
            "Redirection",
            "PrivateRoute"
          ],
          "evaluationCriteria": [
            "Clear explanation of the purpose of passing `location`.",
            "Accurate description of how `location.state` is accessed.",
            "Correct implementation strategy for post-login redirection."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Authentication",
            "State Management",
            "Redirection",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_router_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_private_route_redirect_flow",
          "topic": "Route Guards with Authentication",
          "level": "hard",
          "type": "code",
          "question": "Implement a `ProtectedRoute` component. This component should:\n1.  Accept `children` as a prop (the component to protect).\n2.  Use a mock `useAuth` hook that returns `isAuthenticated: boolean` (you can hardcode `false` for testing the redirect).\n3.  If not authenticated, redirect the user to `/login`, passing the current location in the navigation state (`state: { from: location }`).\n4.  If authenticated, render `children`.\n5.  Include a `Login` component that, upon a simulated successful login, redirects the user back to the `from` path in the state, or to `/dashboard` if no `from` state exists. Use `replace: true` for post-login navigation.\n\nProvide the `ProtectedRoute` and `Login` components, and a minimal `App` setup to demonstrate.",
          "answer": "```jsx\nimport React, { useEffect, useState } from 'react';\nimport { Routes, Route, Outlet, useNavigate, useLocation } from 'react-router-dom';\n\n// --- Mock Authentication Hook ---\nconst useAuth = () => {\n  const [isAuthenticated, setIsAuthenticated] = useState(() => {\n    // Initialize from session storage or local storage\n    return sessionStorage.getItem('isAuthenticated') === 'true';\n  });\n\n  const login = () => {\n    setIsAuthenticated(true);\n    sessionStorage.setItem('isAuthenticated', 'true');\n  };\n  const logout = () => {\n    setIsAuthenticated(false);\n    sessionStorage.removeItem('isAuthenticated');\n  };\n\n  return { isAuthenticated, login, logout };\n};\n\n// --- ProtectedRoute Component ---\nfunction ProtectedRoute({ children }) {\n  const { isAuthenticated } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  useEffect(() => {\n    if (!isAuthenticated) {\n      console.log(`Redirecting to /login from ${location.pathname}`);\n      navigate('/login', { state: { from: location } });\n    }\n  }, [isAuthenticated, navigate, location]);\n\n  return isAuthenticated ? children : <div>Checking authentication...</div>; // Or a loading spinner\n}\n\n// --- Login Component ---\nfunction Login() {\n  const { login } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const handleLogin = () => {\n    // Simulate API call for login\n    console.log('Simulating login...');\n    setTimeout(() => {\n      login(); // Set isAuthenticated to true\n      console.log(`Login successful. Navigating to: ${from}`);\n      navigate(from, { replace: true }); // Redirect to original path or dashboard\n    }, 500);\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <p>Please log in to access the protected content.</p>\n      <button onClick={handleLogin}>Simulate Login</button>\n      <p>Redirecting to: {from}</p>\n    </div>\n  );\n}\n\n// --- Dashboard Component (Protected) ---\nfunction Dashboard() {\n  const { logout } = useAuth();\n  return (\n    <div>\n      <h1>Dashboard Content</h1>\n      <p>Welcome, authenticated user!</p>\n      <button onClick={logout}>Logout</button>\n      <p>Try refreshing the page to see protected route behavior.</p>\n    </div>\n  );\n}\n\n// --- Home Component ---\nfunction Home() {\n  return <h2>Home Page (Public)</h2>;\n}\n\n// --- App Component ---\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Home />} />\n      <Route path=\"/login\" element={<Login />} />\n      {/* Protected Route */}\n      <Route \n        path=\"/dashboard\" \n        element={\n          <ProtectedRoute>\n            <Dashboard />\n          </ProtectedRoute>\n        } \n      />\n      <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n    </Routes>\n  );\n}\n\n// To run this, you would typically render App into your root div:\n// import ReactDOM from 'react-dom/client';\n// const root = ReactDOM.createRoot(document.getElementById('root'));\n// root.render(<App />);\n\n```",
          "options": [],
          "analysisPoints": [
            "Ability to integrate `useNavigate`, `useLocation`, and `useEffect` for authentication flow.",
            "Correct handling of `location.state` for post-login redirection.",
            "Demonstrates a complete practical authentication routing pattern."
          ],
          "keyConcepts": [
            "PrivateRoute",
            "Authentication Flow",
            "useNavigate",
            "useLocation",
            "useEffect",
            "Conditional Rendering",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [
            "Correct conditional rendering and redirection logic in `ProtectedRoute`.",
            "Accurate retrieval and usage of `location.state` in `Login` component.",
            "Proper use of `replace: true` for post-login navigation.",
            "Clear demonstration of the complete flow."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Authentication",
            "Code Challenge",
            "Route Guards",
            "Hooks",
            "Complex"
          ],
          "prerequisites": [
            "react_hooks_advanced",
            "react_router_intermediate"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_router_redux_purpose",
          "topic": "React Router with Redux Integration",
          "level": "flashcard",
          "type": "flashcard",
          "question": "What was the primary purpose of libraries like `react-router-redux`?",
          "answer": "To keep the router state in sync with the Redux store, allowing navigation actions to be dispatched from Redux.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "react-router-redux",
            "Redux Integration",
            "Router State",
            "Synchronization"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "React Router",
            "Redux",
            "Integration",
            "Legacy"
          ],
          "prerequisites": [
            "redux_fundamentals"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_connected_router_role",
          "topic": "React Router with Redux Integration",
          "level": "mcq",
          "type": "mcq",
          "question": "In a setup using `react-router-redux` (or `connected-react-router`), which component is responsible for wrapping your application's routes and connecting the router's history to the Redux store?",
          "answer": "`ConnectedRouter`",
          "options": [
            "`Provider`",
            "`Routes`",
            "`ConnectedRouter`",
            "`Outlet`"
          ],
          "analysisPoints": [
            "Tests knowledge of specific components in Redux-Router integration.",
            "Distinguishes `ConnectedRouter` from standard Redux and React Router components.",
            "Focuses on the core component for this specific integration pattern."
          ],
          "keyConcepts": [
            "ConnectedRouter",
            "react-router-redux",
            "Redux Integration",
            "History Object"
          ],
          "evaluationCriteria": [
            "Correct identification of `ConnectedRouter`'s role.",
            "Understanding its position in the component tree relative to Redux `Provider`."
          ],
          "example": "The `ConnectedRouter` component acts as a bridge. It sits within the Redux `Provider` and wraps your React Router setup, effectively making the routing history accessible and dispatchable via the Redux store.\n\n```jsx\nimport { Provider } from 'react-redux';\nimport { ConnectedRouter } from 'connected-react-router'; // or react-router-redux\nimport { createBrowserHistory } from 'history';\nimport App from './App';\nimport configureStore from './store';\n\nconst history = createBrowserHistory();\nconst store = configureStore(history);\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedRouter history={history}>\n      <App /> {/* App contains your Routes, Route components */}\n    </ConnectedRouter>\n  </Provider>,\n  document.getElementById('root')\n);\n```",
          "tags": [
            "React Router",
            "Redux",
            "ConnectedRouter",
            "Integration"
          ],
          "prerequisites": [
            "redux_fundamentals",
            "react_router_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_history_library_role",
          "topic": "React Router with Redux Integration",
          "level": "flashcard",
          "type": "flashcard",
          "question": "What external library is typically used by `react-router-redux` (and `connected-react-router`) to manage browser history?",
          "answer": "The `history` library (e.g., `createBrowserHistory`).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "History Library",
            "createBrowserHistory",
            "react-router-redux",
            "connected-react-router"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "React Router",
            "Redux",
            "History API",
            "Libraries"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_router_advantages",
          "topic": "React Router with Redux Integration",
          "level": "open",
          "type": "open",
          "question": "Discuss the advantages and potential disadvantages of integrating React Router's state into the Redux store using libraries like `react-router-redux`. Why is this approach less common with modern React Router v6 and hooks?",
          "answer": "**Advantages of integrating React Router's state into Redux:**\n\n1.  **Single Source of Truth**: The URL and navigation history become part of your central Redux store, aligning with the Redux philosophy of a single, predictable state tree. This can simplify state management for complex applications.\n2.  **Time-Travel Debugging**: With router state in Redux, you can use Redux DevTools to replay navigation actions, inspect the state of the router at any point in time, and debug navigation issues more effectively.\n3.  **Programmatic Navigation from Anywhere**: You can dispatch Redux actions (e.g., `PUSH`, `REPLACE`) from Redux middleware (like Redux Thunk or Redux Saga), reducers, or actions, allowing complex navigation logic to reside within your Redux flow, separate from UI components.\n4.  **Persistent Navigation State**: In some complex applications, certain navigation-related state (e.g., scroll position per route, filtered search queries) might benefit from being persisted or managed globally within Redux.\n5.  **Server-Side Rendering (SSR)**: It can help in managing router state consistently between server and client during SSR.\n\n**Disadvantages/Why less common with modern React Router v6:**\n\n1.  **Increased Complexity**: Integrating two powerful libraries like React Router and Redux introduces additional boilerplate, setup, and concepts (`history` objects, middleware) that can be overkill for simpler applications.\n2.  **Over-Centralization**: For many common navigation needs, the router state doesn't necessarily need to be globalized in Redux. React Router's internal state is often sufficient and more localized.\n3.  **Modern React Router Hooks**: React Router v6's emphasis on hooks (`useNavigate`, `useLocation`, `useParams`) provides a more direct, React-idiomatic way to interact with router state and perform navigation directly within functional components. This reduces the need for external state management solutions for basic routing.\n    *   `useNavigate` directly provides imperative navigation.\n    *   `useLocation` provides access to the current URL state.\n    *   `useParams` handles URL parameters.\n    These hooks abstract away the underlying `history` object, making direct Redux integration less necessary unless very specific requirements (like dispatching navigation from non-component code) exist.\n4.  **Performance Overhead (Minor)**: Constantly syncing router state to Redux might introduce minor, often negligible, performance overhead or unnecessary re-renders if not managed carefully.\n\nIn essence, while Redux integration for routing offered powerful capabilities, modern React Router's design makes many of those capabilities directly accessible via hooks, reducing the default need for an additional layer of state synchronization.",
          "options": [],
          "analysisPoints": [
            "Comprehensive understanding of the trade-offs involved in Redux-Router integration.",
            "Knowledge of specific features enabled by this integration (e.g., time-travel debugging).",
            "Understanding of how modern React Router hooks have changed the landscape."
          ],
          "keyConcepts": [
            "Redux Integration",
            "React Router v6",
            "useNavigate",
            "useLocation",
            "Time-Travel Debugging",
            "Complexity",
            "Single Source of Truth"
          ],
          "evaluationCriteria": [
            "Balanced discussion of pros and cons.",
            "Accurate explanation of the shift due to React Router v6 hooks.",
            "Demonstrates advanced conceptual understanding."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Redux",
            "Architecture",
            "Hooks",
            "Advanced Concepts"
          ],
          "prerequisites": [
            "redux_fundamentals",
            "react_router_intermediate"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_browser_history_vs_use_navigate",
          "topic": "Programmatic Navigation and Redirection",
          "level": "open",
          "type": "open",
          "question": "Compare and contrast `browserHistory.push` (from older React Router versions) with the `useNavigate` hook (from React Router v6) for programmatic navigation. Discuss their usage contexts and any key differences.",
          "answer": "**`browserHistory.push` (Legacy - React Router v3-v4)**\n\n*   **Nature**: It was an imperative method available on a singleton `browserHistory` object, which was imported directly from `react-router`.\n*   **Usage Context**: Could be called from any JavaScript file, not strictly within a React component. This made it flexible but also less React-idiomatic.\n*   **Syntax**: `browserHistory.push('/some/path')` or `browserHistory.push({ pathname: '/path', state: { data: 'value' } })`.\n*   **Dependencies**: Relied on a global `history` instance that the router used.\n*   **Drawbacks**: Being a singleton, it was harder to test in isolation, and its global nature could lead to less predictable side effects in complex applications. It also didn't leverage React's hook-based paradigm.\n\n**`useNavigate` Hook (Modern - React Router v6+)**\n\n*   **Nature**: It's a React Hook that returns a `navigate` function. As a hook, it must be called inside a functional React component or a custom React Hook.\n*   **Usage Context**: Primarily used within React components to trigger navigation in response to user actions (e.g., button clicks, form submissions) or component lifecycle events (e.g., `useEffect`).\n*   **Syntax**: `const navigate = useNavigate(); navigate('/some/path')` or `navigate('/path', { state: { data: 'value' }, replace: true })`.\n*   **Dependencies**: Integrates seamlessly with React's component tree and lifecycle, relying on context provided by `BrowserRouter` or `HashRouter`.\n*   **Advantages**: More idiomatic to modern React development. Easier to test as it's scoped to the component where it's used. Provides additional options like `replace: true` (to replace the current history entry) or navigating relative paths. Embraces the functional component paradigm.\n\n**Key Differences Summarized:**\n\n| Feature           | `browserHistory.push` (Legacy)                           | `useNavigate` (Modern)                                     |\n| :---------------- | :------------------------------------------------------- | :--------------------------------------------------------- |\n| **Type**          | Global singleton method                                  | React Hook that returns a function                         |\n| **Context**       | Any JS file                                              | Functional React component or custom Hook                  |\n| **Import From**   | `react-router` (or `history` library directly)           | `react-router-dom`                                         |\n| **State Passing** | `browserHistory.push({ pathname, state: {} })`          | `navigate(path, { state: {} })`                            |\n| **Replace Entry** | `browserHistory.replace('/path')` (separate method)      | `navigate('/path', { replace: true })` (option on `navigate`) |\n| **Idiomatic**     | Less React-idiomatic, global                               | Highly React-idiomatic, component-scoped                   |\n| **Testability**   | More challenging due to global nature                  | Easier to mock and test within component scope             |\n\nIn conclusion, `useNavigate` is the current best practice for programmatic navigation in React Router v6+ applications, offering a cleaner, more React-centric, and testable approach compared to the older `browserHistory.push` method.",
          "options": [],
          "analysisPoints": [
            "Deep understanding of the evolution of programmatic navigation in React Router.",
            "Ability to articulate the technical and philosophical differences between imperative global objects and React Hooks.",
            "Highlights modern best practices."
          ],
          "keyConcepts": [
            "browserHistory",
            "useNavigate",
            "Programmatic Navigation",
            "React Router Hooks",
            "Legacy vs. Modern",
            "History API"
          ],
          "evaluationCriteria": [
            "Accurate comparison of features, syntax, and usage contexts.",
            "Clear explanation of why `useNavigate` is preferred now.",
            "Structured and comprehensive answer."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Navigation",
            "Hooks",
            "Legacy",
            "Comparison"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_router_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_when_to_use_programmatic_navigation",
          "topic": "Programmatic Navigation and Redirection",
          "level": "flashcard",
          "type": "flashcard",
          "question": "Give two common scenarios where you would use programmatic navigation (e.g., `useNavigate`) instead of a `<Link>` component.",
          "answer": "1.  After a form submission (e.g., login, signup, order placement) to redirect the user to a success page or dashboard.\n2.  Inside a `useEffect` hook for conditional redirection, such as implementing a `PrivateRoute` or redirecting based on user roles or data loading status.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Programmatic Navigation",
            "useNavigate",
            "Link Component",
            "Redirection",
            "Authentication"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "React Router",
            "Navigation",
            "useNavigate",
            "Practical Application"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pass_state_in_navigation",
          "topic": "Programmatic Navigation and Redirection",
          "level": "mcq",
          "type": "mcq",
          "question": "Which of the following is the correct way to navigate to `/order-success` and pass an `orderId` of `123` as state data using `useNavigate` in React Router v6?",
          "answer": "`navigate('/order-success', { state: { orderId: 123 } });`",
          "options": [
            "`navigate('/order-success?orderId=123');`",
            "`navigate({ pathname: '/order-success', query: { orderId: 123 } });`",
            "`navigate('/order-success', { state: { orderId: 123 } });`",
            "`navigate('/order-success', { params: { orderId: 123 } });`"
          ],
          "analysisPoints": [
            "Tests correct syntax for passing state with `useNavigate`.",
            "Differentiates between state, query parameters, and path parameters.",
            "Ensures understanding that `state` data is not part of the URL."
          ],
          "keyConcepts": [
            "useNavigate",
            "Navigation State",
            "location.state",
            "Query Parameters",
            "Path Parameters"
          ],
          "evaluationCriteria": [
            "Correct use of the `state` option in `navigate`.",
            "Understanding that `state` is distinct from URL parameters."
          ],
          "example": "The `state` option in `navigate` allows you to pass arbitrary data that will be available via `useLocation().state` on the target route. This data is not visible in the URL.\n\n```typescript\nimport { useNavigate } from 'react-router-dom';\n\nfunction OrderConfirmation() {\n  const navigate = useNavigate();\n\n  const handleConfirmOrder = () => {\n    const orderId = Math.floor(Math.random() * 1000) + 1;\n    console.log(`Order ${orderId} confirmed!`);\n    // Correct way to navigate with state\n    navigate('/order-success', { state: { orderId: orderId, message: 'Your order has been placed successfully!' } });\n  };\n\n  return (\n    <div>\n      <p>Click to confirm your order.</p>\n      <button onClick={handleConfirmOrder}>Confirm Order</button>\n    </div>\n  );\n}\n\n// On the /order-success page:\nimport { useLocation } from 'react-router-dom';\n\nfunction OrderSuccess() {\n  const location = useLocation();\n  const { orderId, message } = location.state || {}; // Safely access state\n\n  return (\n    <div>\n      <h1>Order Success!</h1>\n      {orderId && <p>Order ID: <strong>{orderId}</strong></p>}\n      {message && <p>{message}</p>}\n    </div>\n  );\n}\n```",
          "tags": [
            "React Router",
            "useNavigate",
            "State",
            "Programmatic Navigation"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_navigate_replace_option",
          "topic": "Programmatic Navigation and Redirection",
          "level": "flashcard",
          "type": "flashcard",
          "question": "What is the effect of passing `{ replace: true }` as an option to the `navigate` function in React Router v6?",
          "answer": "It replaces the current entry in the browser's history stack with the new URL, preventing the user from navigating back to the previous page using the browser's back button.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useNavigate",
            "History Stack",
            "Replace Navigation",
            "Browser History"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "React Router",
            "useNavigate",
            "History API",
            "Navigation Options"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_nested_layout_implementation",
          "title": "Implement a Multi-level Dashboard Navigation with Nested Layouts",
          "description": "\nImplement a React application using `react-router-dom` v6 that features a multi-level dashboard with shared layouts.\n\n**Requirements:**\n\n1.  **Root Layout (`MainLayout`)**: Create a `MainLayout` component that includes a shared header, a navigation menu (for Home, Dashboard, About), and renders its children using `<Outlet />`.\n2.  **Dashboard Layout (`DashboardLayout`)**: Create a `DashboardLayout` component that acts as a nested layout specifically for dashboard-related routes. It should include a dashboard-specific sidebar navigation (for Dashboard Home, Settings, Reports) and also render its children using `<Outlet />`.\n3.  **Routes Structure**: \n    *   `/`: Renders `HomePage` within `MainLayout` (as an index route).\n    *   `/about`: Renders `AboutPage` within `MainLayout`.\n    *   `/dashboard`: Renders `DashboardOverviewPage` within `DashboardLayout`, which in turn is rendered within `MainLayout`. `DashboardOverviewPage` should be the *index route* for `/dashboard`.\n    *   `/dashboard/settings`: Renders `DashboardSettingsPage` within `DashboardLayout`.\n    *   `/dashboard/reports`: Renders `DashboardReportsPage` within `DashboardLayout`.\n4.  **Navigation**: Use `<Link>` components for all navigation within the layouts.\n5.  **Dummy Components**: Create simple functional components for `HomePage`, `AboutPage`, `DashboardOverviewPage`, `DashboardSettingsPage`, and `DashboardReportsPage` that just display their names.\n\nYour solution should clearly demonstrate the use of `Routes`, `Route`, `Outlet`, and `index` routes for creating a hierarchical UI with shared layouts.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { Routes, Route, Outlet, Link } from 'react-router-dom';\n\n// Dummy Page Components\nfunction HomePage() { return <h2>Welcome to the Home Page!</h2>; }\nfunction AboutPage() { return <h2>About Us</h2>; }\nfunction DashboardOverviewPage() { return <h3>Dashboard Overview</h3>; }\nfunction DashboardSettingsPage() { return <h3>Dashboard Settings</h3>; }\nfunction DashboardReportsPage() { return <h3>Dashboard Reports</h3>; }\n\n// TODO: Implement MainLayout component\nfunction MainLayout() {\n  return (\n    <div>\n      <header style={{ background: '#eee', padding: '10px' }}>\n        <h1>My App</h1>\n        <nav>\n          {/* Main navigation links */}\n          <Link to=\"/\">Home</Link> | \n          <Link to=\"dashboard\">Dashboard</Link> | \n          <Link to=\"about\">About</Link>\n        </nav>\n      </header>\n      <main style={{ padding: '20px' }}>\n        {/* Where child routes of MainLayout will render */}\n        {/* TODO: Add Outlet here */}\n      </main>\n      <footer style={{ background: '#eee', padding: '10px' }}>App Footer</footer>\n    </div>\n  );\n}\n\n// TODO: Implement DashboardLayout component\nfunction DashboardLayout() {\n  return (\n    <div style={{ display: 'flex', border: '1px solid #ccc', marginTop: '20px' }}>\n      <aside style={{ width: '150px', background: '#f9f9f9', padding: '10px' }}>\n        <h4>Dashboard Navigation</h4>\n        <nav>\n          {/* Dashboard specific navigation links */}\n          {/* TODO: Add Dashboard navigation links */}\n        </nav>\n      </aside>\n      <section style={{ flex: 1, padding: '10px' }}>\n        {/* Where child routes of DashboardLayout will render */}\n        {/* TODO: Add Outlet here */}\n      </section>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      {/* TODO: Define routes structure as per requirements */}\n    </Routes>\n  );\n}\n\n// Example usage: ReactDOM.createRoot(document.getElementById('root')).render(<App />);\n",
          "solutionCode": "import React from 'react';\nimport { Routes, Route, Outlet, Link } from 'react-router-dom';\n\n// Dummy Page Components\nfunction HomePage() { return <h2>Welcome to the Home Page!</h2>; }\nfunction AboutPage() { return <h2>About Us</h2>; }\nfunction DashboardOverviewPage() { return <h3>Dashboard Overview</h3>; }\nfunction DashboardSettingsPage() { return <h3>Dashboard Settings</h3>; }\nfunction DashboardReportsPage() { return <h3>Dashboard Reports</h3>; }\n\n// MainLayout component\nfunction MainLayout() {\n  return (\n    <div>\n      <header style={{ background: '#eee', padding: '10px' }}>\n        <h1>My App</h1>\n        <nav>\n          <Link to=\"/\">Home</Link> | \n          <Link to=\"dashboard\">Dashboard</Link> | \n          <Link to=\"about\">About</Link>\n        </nav>\n      </header>\n      <main style={{ padding: '20px' }}>\n        <Outlet />\n      </main>\n      <footer style={{ background: '#eee', padding: '10px' }}>App Footer</footer>\n    </div>\n  );\n}\n\n// DashboardLayout component\nfunction DashboardLayout() {\n  return (\n    <div style={{ display: 'flex', border: '1px solid #ccc', marginTop: '20px' }}>\n      <aside style={{ width: '150px', background: '#f9f9f9', padding: '10px' }}>\n        <h4>Dashboard Navigation</h4>\n        <nav>\n          <Link to=\"/dashboard\">Overview</Link> | \n          <Link to=\"settings\">Settings</Link> | \n          <Link to=\"reports\">Reports</Link>\n        </nav>\n      </aside>\n      <section style={{ flex: 1, padding: '10px' }}>\n        <Outlet />\n      </section>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<MainLayout />}>\n        {/* Home page as index route for MainLayout */}\n        <Route index element={<HomePage />} />\n        <Route path=\"about\" element={<AboutPage />} />\n        \n        {/* Nested Dashboard routes with DashboardLayout */}\n        <Route path=\"dashboard\" element={<DashboardLayout />}>\n          {/* Dashboard Overview as index route for DashboardLayout */}\n          <Route index element={<DashboardOverviewPage />} />\n          <Route path=\"settings\" element={<DashboardSettingsPage />} />\n          <Route path=\"reports\" element={<DashboardReportsPage />} />\n        </Route>\n        \n        {/* Fallback route for unmatched paths */}\n        <Route path=\"*\" element={<h2>404 - Page Not Found</h2>} />\n      </Route>\n    </Routes>\n  );\n}\n",
          "testCases": [
            "Navigating to '/' should render `HomePage` inside `MainLayout`.",
            "Navigating to '/about' should render `AboutPage` inside `MainLayout`.",
            "Navigating to '/dashboard' should render `DashboardOverviewPage` inside `DashboardLayout`, which is inside `MainLayout`.",
            "Navigating to '/dashboard/settings' should render `DashboardSettingsPage` inside `DashboardLayout`.",
            "Navigating to '/dashboard/reports' should render `DashboardReportsPage` inside `DashboardLayout`.",
            "Clicking on 'Home', 'Dashboard', 'About' links in `MainLayout` should navigate correctly.",
            "Clicking on 'Overview', 'Settings', 'Reports' links in `DashboardLayout` should navigate correctly to respective dashboard sub-pages."
          ],
          "hints": [
            "Remember that `<Outlet />` is where child routes will be rendered within their parent component.",
            "An `index` route is crucial for defining the default component to render when a parent path is matched exactly, without additional segments.",
            "Pay attention to the relative paths in `<Link to=\"...\">` components, especially within nested layouts. Relative paths often work well, e.g., `to=\"settings\"` from `/dashboard`."
          ],
          "tags": [
            "React Router",
            "Nested Routes",
            "Layouts",
            "Outlet",
            "Index Route",
            "Frontend Architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_components",
            "jsx",
            "react_router_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Shared Layouts",
            "Route Matching",
            "Component Hierarchy"
          ]
        },
        {
          "id": "task_implement_protected_route",
          "title": "Implement a User Authentication Flow with Protected Routes",
          "description": "\nImplement a simplified user authentication system using React Router DOM v6 that protects a dashboard route.\n\n**Requirements:**\n\n1.  **Authentication Context/Hook**: Create a simple `AuthContext` and a `useAuth` hook (or just a `useAuth` hook with `useState` and `useEffect` for persistence) that manages an `isAuthenticated` boolean state. Include `login` and `logout` functions to toggle this state. Persist authentication status (e.g., in `sessionStorage`) so it survives page refresh.\n2.  **`PrivateRoute` Component**: Create a `PrivateRoute` component that:\n    *   Takes `children` (the protected component) as a prop.\n    *   Checks the `isAuthenticated` status from `useAuth`.\n    *   If `isAuthenticated` is `false`, it redirects the user to `/login`, passing the current `location` in the navigation state (`state: { from: location }`).\n    *   If `isAuthenticated` is `true`, it renders `children`.\n    *   While redirecting, or if `isAuthenticated` is `null`/`undefined` (meaning auth check is pending), show a simple 'Loading...' message.\n3.  **`Login` Component**: Create a `Login` component that:\n    *   Has a 'Login' button. When clicked, it calls the `login` function from `useAuth`.\n    *   After successful login, it programmatically navigates the user back to the path they originally tried to access (retrieved from `location.state.from`), or to `/dashboard` if no `from` state exists. Use `replace: true` for this navigation.\n4.  **`Dashboard` Component**: A simple component indicating the user is logged in. It should also have a 'Logout' button that calls the `logout` function from `useAuth` and redirects to `/`.\n5.  **`PublicHome` Component**: A simple component for the root path (`/`) that is publicly accessible.\n6.  **`App` Routing**: Set up `Routes` in `App.js`:\n    *   `/`: `PublicHome`\n    *   `/login`: `Login`\n    *   `/dashboard`: Protected by `PrivateRoute`, rendering `Dashboard`.\n\n**Test Cases (Manual):**\n*   Verify that navigating to `/dashboard` directly when not logged in redirects to `/login`.\n*   Verify that after logging in from `/login`, the user is redirected to `/dashboard` if they initially tried to access it.\n*   Verify that after logging in, if no specific `from` path was present (e.g., navigating to `/login` directly), the user is redirected to `/dashboard`.\n*   Verify that the authentication status persists on page refresh for authenticated users.\n*   Verify that logging out redirects to `/` and clears authentication status.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useEffect, useState, createContext, useContext } from 'react';\nimport { Routes, Route, Outlet, Link, useNavigate, useLocation } from 'react-router-dom';\n\n// --- Auth Context and Hook (to be implemented) ---\nconst AuthContext = createContext(null);\n\nconst useAuth = () => {\n  const [isAuthenticated, setIsAuthenticated] = useState(() => {\n    // TODO: Implement persistence (e.g., sessionStorage)\n    return false; // Default to false\n  });\n\n  const login = () => {\n    // TODO: Set authenticated state and persist\n    setIsAuthenticated(true);\n  };\n\n  const logout = () => {\n    // TODO: Clear authenticated state and persistence\n    setIsAuthenticated(false);\n  };\n\n  return { isAuthenticated, login, logout };\n};\n\n// --- Public Components ---\nfunction PublicHome() {\n  const { isAuthenticated, logout } = useAuth();\n  return (\n    <div>\n      <h2>Welcome to the Public Home Page!</h2>\n      {isAuthenticated ? (\n        <p>You are logged in. Go to <Link to=\"/dashboard\">Dashboard</Link> | <button onClick={logout}>Logout</button></p>\n      ) : (\n        <p>Please <Link to=\"/login\">Login</Link> to access protected content.</p>\n      )}\n    </div>\n  );\n}\n\n// TODO: Implement PrivateRoute component\nfunction PrivateRoute({ children }) {\n  const { isAuthenticated } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  useEffect(() => {\n    // TODO: Add redirection logic\n  }, [isAuthenticated, navigate, location]);\n\n  // TODO: Conditional rendering (children or loading message)\n  return children;\n}\n\n// TODO: Implement Login component\nfunction Login() {\n  const { login } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const handleLogin = () => {\n    // Simulate async login\n    setTimeout(() => {\n      login();\n      // TODO: Redirect after login\n    }, 500);\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <p>Please log in to access the protected content.</p>\n      <button onClick={handleLogin}>Log In</button>\n      <p>Will redirect to: {from}</p>\n    </div>\n  );\n}\n\n// TODO: Implement Dashboard component\nfunction Dashboard() {\n  const { logout } = useAuth();\n  return (\n    <div>\n      <h1>Dashboard Content</h1>\n      <p>Welcome, authenticated user!</p>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    // TODO: Wrap with AuthContext.Provider\n    <Routes>\n      <Route path=\"/\" element={<PublicHome />} />\n      <Route path=\"/login\" element={<Login />} />\n      {/* TODO: Protect the dashboard route */}\n      <Route path=\"/dashboard\" element={<Dashboard />} />\n      <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n    </Routes>\n  );\n}\n\n// Render App in your root (e.g., index.js)\n// import ReactDOM from 'react-dom/client';\n// const root = ReactDOM.createRoot(document.getElementById('root'));\n// root.render(<App />);\n",
          "solutionCode": "import React, { useEffect, useState, createContext, useContext } from 'react';\nimport { Routes, Route, Link, useNavigate, useLocation } from 'react-router-dom';\n\n// --- Auth Context and Hook ---\nconst AuthContext = createContext(null);\n\nconst AuthProvider = ({ children }) => {\n  const [isAuthenticated, setIsAuthenticated] = useState(() => {\n    return sessionStorage.getItem('isAuthenticated') === 'true';\n  });\n\n  const login = () => {\n    setIsAuthenticated(true);\n    sessionStorage.setItem('isAuthenticated', 'true');\n  };\n\n  const logout = () => {\n    setIsAuthenticated(false);\n    sessionStorage.removeItem('isAuthenticated');\n  };\n\n  const authValue = { isAuthenticated, login, logout };\n\n  return (\n    <AuthContext.Provider value={authValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === null) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\n// --- Public Components ---\nfunction PublicHome() {\n  const { isAuthenticated, logout } = useAuth();\n  return (\n    <div>\n      <h2>Welcome to the Public Home Page!</h2>\n      {isAuthenticated ? (\n        <p>You are logged in. Go to <Link to=\"/dashboard\">Dashboard</Link> | <button onClick={logout}>Logout</button></p>\n      ) : (\n        <p>Please <Link to=\"/login\">Login</Link> to access protected content.</p>\n      )}\n    </div>\n  );\n}\n\n// --- PrivateRoute component ---\nfunction PrivateRoute({ children }) {\n  const { isAuthenticated } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [checkedAuth, setCheckedAuth] = useState(false); // To manage loading state\n\n  useEffect(() => {\n    // Simulate an async auth check on mount if not already checked\n    if (isAuthenticated === null) { // If auth state is not yet determined\n        // In a real app, this would be an API call\n        setTimeout(() => {\n            // Assume auth check completes and updates isAuthenticated\n            setCheckedAuth(true);\n        }, 100); // Small delay to simulate async check\n    } else {\n        setCheckedAuth(true);\n    }\n\n    if (checkedAuth && !isAuthenticated) {\n      console.log(`Redirecting to /login from ${location.pathname}`);\n      navigate('/login', { state: { from: location } });\n    }\n  }, [isAuthenticated, navigate, location, checkedAuth]);\n\n  if (!checkedAuth || !isAuthenticated) {\n    return <div>Loading authentication...</div>; // Show loading while checking or if not authenticated (before redirect)\n  }\n\n  return children;\n}\n\n// --- Login component ---\nfunction Login() {\n  const { login } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const handleLogin = () => {\n    // Simulate API call for login\n    console.log('Simulating login...');\n    setTimeout(() => {\n      login(); // Set isAuthenticated to true\n      console.log(`Login successful. Navigating to: ${from}`);\n      navigate(from, { replace: true }); // Redirect to original path or dashboard\n    }, 500);\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <p>Please log in to access the protected content.</p>\n      <button onClick={handleLogin}>Log In</button>\n      <p style={{ fontSize: '0.8em', color: '#666' }}>Will redirect to: {from}</p>\n    </div>\n  );\n}\n\n// --- Dashboard component ---\nfunction Dashboard() {\n  const { logout } = useAuth();\n  return (\n    <div>\n      <h1>Dashboard Content</h1>\n      <p>Welcome, authenticated user!</p>\n      <button onClick={logout}>Logout</button>\n      <p style={{ fontSize: '0.8em', color: '#666' }}>Try refreshing the page to see protected route persistence.</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <Routes>\n        <Route path=\"/\" element={<PublicHome />} />\n        <Route path=\"/login\" element={<Login />} />\n        {/* Protected Route */}\n        <Route \n          path=\"/dashboard\" \n          element={\n            <PrivateRoute>\n              <Dashboard />\n            </PrivateRoute>\n          } \n        />\n        <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n      </Routes>\n    </AuthProvider>\n  );\n}\n",
          "testCases": [
            "Test 1: Direct access to /dashboard when not logged in -> Should redirect to /login and show 'Will redirect to: /dashboard'.",
            "Test 2: After Test 1, click 'Log In' -> Should redirect to /dashboard and show 'Welcome, authenticated user!'.",
            "Test 3: Log out from Dashboard -> Should redirect to / and 'You are logged out' message, session storage should be clear.",
            "Test 4: Refresh page on /dashboard when logged in -> Should remain on /dashboard, authentication status should persist from session storage.",
            "Test 5: Directly navigate to /login -> Click 'Log In' -> Should redirect to /dashboard (default fallback).",
            "Test 6: Type '/nonexistent' -> Should show '404 Not Found'."
          ],
          "hints": [
            "Use `sessionStorage` or `localStorage` to persist the `isAuthenticated` status across page refreshes.",
            "Remember that `useEffect` with an empty dependency array (`[]`) runs only once on mount, while with dependencies, it runs when those dependencies change.",
            "The `location.state` object is typically `undefined` or `null` if no state was passed during navigation, so use optional chaining (`?.`) or a default value.",
            "The `replace: true` option in `navigate` is important for a clean history stack after login, preventing users from going back to the login page."
          ],
          "tags": [
            "React Router",
            "Authentication",
            "Route Guards",
            "Hooks",
            "State Management",
            "Frontend Security"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_hooks_intermediate",
            "react_context_api",
            "react_router_intermediate"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Protected Routes",
            "User Experience",
            "Declarative vs Imperative Navigation"
          ]
        },
        {
          "id": "task_integrate_redux_router",
          "title": "Set up React Router v6 with Redux (Modern Approach Simulation)",
          "description": "\nThis task aims to demonstrate an understanding of how Redux can be integrated with React Router. While `react-router-redux` is largely legacy for direct state synchronization in v6, a modern approach involves passing a custom `history` object from the `history` library to `unstable_HistoryRouter` to allow external control, which can then be connected to Redux middleware.\n\n**Requirements:**\n\n1.  **Redux Store Setup**: Create a basic Redux store with a dummy reducer (e.g., managing a counter). Use `configureStore` from `@reduxjs/toolkit`.\n2.  **History Object**: Create a `browserHistory` object using `createBrowserHistory` from the `history` library.\n3.  **Router Integration**: Wrap your `App` component with `ReactReduxProvider` and `unstable_HistoryRouter` (from `react-router-dom`), passing your custom `history` object to the router.\n4.  **Middleware for Navigation (Optional but Recommended for demonstrating sync)**: Implement a simple Redux middleware that logs navigation actions (e.g., `locationChange`). While `connected-react-router` provided action creators, you can simulate this by dispatching custom actions from components and having middleware respond.\n5.  **Component for Navigation**: Create a `Home` component and a `Dashboard` component. In `Home`, add a button that dispatches a Redux action (e.g., `NAVIGATE_TO_DASHBOARD`). This action should then trigger a programmatic navigation to `/dashboard` (e.g., using `useNavigate` inside a `useEffect` triggered by Redux state, or a custom middleware that uses `history.push`). For this task, we will stick to `useNavigate` triggered by Redux state for simplicity.\n\n**Note**: This task highlights the *conceptual* integration for interview purposes, acknowledging that direct state syncing isn't the primary pattern for basic v6 apps.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { createBrowserHistory } from 'history';\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\nimport { Provider as ReactReduxProvider } from 'react-redux';\nimport { \n  Routes, \n  Route, \n  unstable_HistoryRouter as HistoryRouter, \n  Link, \n  useNavigate,\n  useLocation\n} from 'react-router-dom';\n\n// --- 1. Redux Store Setup ---\n// Define a dummy slice\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0, navigateTo: null },\n  reducers: {\n    increment: (state) => { state.value += 1; },\n    navigateToDashboard: (state) => { state.navigateTo = '/dashboard'; },\n    clearNavigation: (state) => { state.navigateTo = null; }\n  },\n});\n\nexport const { increment, navigateToDashboard, clearNavigation } = counterSlice.actions;\n\n// TODO: Create history object\n// const history = ...;\n\n// TODO: Configure Redux store with dummy reducer\n// const store = configureStore({\n//   reducer: {\n//     counter: counterSlice.reducer,\n//   },\n//   // Add middleware here if needed\n// });\n\n// --- Components ---\nfunction Home() {\n  const navigate = useNavigate();\n  const dispatch = useDispatch(); // Assume useDispatch is imported\n  const navigateTo = useSelector((state) => state.counter.navigateTo); // Assume useSelector is imported\n\n  useEffect(() => {\n    if (navigateTo) {\n      navigate(navigateTo);\n      dispatch(clearNavigation()); // Clear the navigation flag\n    }\n  }, [navigateTo, navigate, dispatch]);\n\n  return (\n    <div>\n      <h2>Home Page</h2>\n      <p>Counter: {useSelector(state => state.counter.value)}</p>\n      <button onClick={() => dispatch(increment())}>Increment Counter</button>\n      <br/><br/>\n      <button onClick={() => dispatch(navigateToDashboard())}>\n        Navigate to Dashboard (via Redux)\n      </button>\n      <p><Link to=\"/dashboard\">Go to Dashboard (via Link)</Link></p>\n    </div>\n  );\n}\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h2>Dashboard Page</h2>\n      <p>This is a protected dashboard.</p>\n      <p><Link to=\"/\">Go to Home</Link></p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Home />} />\n      <Route path=\"/dashboard\" element={<Dashboard />} />\n    </Routes>\n  );\n}\n\n// TODO: Render the App wrapped with Provider and HistoryRouter\n// const root = ReactDOM.createRoot(document.getElementById('root'));\n// root.render(\n//   <ReactReduxProvider store={store}>\n//     <HistoryRouter history={history}>\n//       <App />\n//     </HistoryRouter>\n//   </ReactReduxProvider>\n// );\n",
          "solutionCode": "import React, { useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { createBrowserHistory } from 'history';\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\nimport { Provider as ReactReduxProvider, useDispatch, useSelector } from 'react-redux';\nimport { \n  Routes, \n  Route, \n  unstable_HistoryRouter as HistoryRouter, \n  Link, \n  useNavigate\n} from 'react-router-dom';\n\n// --- 1. Redux Store Setup ---\n// Define a dummy slice\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0, navigateTo: null },\n  reducers: {\n    increment: (state) => { state.value += 1; },\n    navigateToPath: (state, action) => { state.navigateTo = action.payload; },\n    clearNavigation: (state) => { state.navigateTo = null; }\n  },\n});\n\nexport const { increment, navigateToPath, clearNavigation } = counterSlice.actions;\n\n// --- 2. Create history object ---\nconst history = createBrowserHistory();\n\n// --- Middleware for Navigation (demonstrative) ---\nconst routerMiddleware = (store) => (next) => (action) => {\n  if (action.type === 'counter/navigateToPath') {\n    // In a real connected-react-router setup, this would be an actual nav action\n    // For this example, the component will handle actual navigation via useSelector/useEffect\n    console.log(`[Router Middleware] Intercepted navigation request to: ${action.payload}`);\n  }\n  return next(action);\n};\n\n// --- 3. Configure Redux store ---\nconst store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer,\n  },\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(routerMiddleware),\n});\n\n// --- Components ---\nfunction Home() {\n  const navigate = useNavigate();\n  const dispatch = useDispatch();\n  const navigateTo = useSelector((state) => state.counter.navigateTo);\n\n  // Effect to perform navigation based on Redux state\n  useEffect(() => {\n    if (navigateTo) {\n      navigate(navigateTo); // Programmatically navigate\n      dispatch(clearNavigation()); // Clear the navigation flag in Redux\n    }\n  }, [navigateTo, navigate, dispatch]);\n\n  return (\n    <div>\n      <h2>Home Page</h2>\n      <p>Counter: {useSelector(state => state.counter.value)}</p>\n      <button onClick={() => dispatch(increment())}>Increment Counter</button>\n      <br/><br/>\n      <button onClick={() => dispatch(navigateToPath('/dashboard'))}>\n        Navigate to Dashboard (via Redux Action)\n      </button>\n      <p><Link to=\"/dashboard\">Go to Dashboard (via Link)</Link></p>\n    </div>\n  );\n}\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h2>Dashboard Page</h2>\n      <p>You landed on the dashboard.</p>\n      <p><Link to=\"/\">Go to Home</Link></p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Home />} />\n      <Route path=\"/dashboard\" element={<Dashboard />} />\n      <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n    </Routes>\n  );\n}\n\n// --- 4. Render the App wrapped with Provider and HistoryRouter ---\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <ReactReduxProvider store={store}>\n    <HistoryRouter history={history}>\n      <App />\n    </HistoryRouter>\n  </ReactReduxProvider>\n);\n",
          "testCases": [
            "Test 1: Click 'Increment Counter' button -> Counter value in Home should increase.",
            "Test 2: Click 'Navigate to Dashboard (via Redux Action)' button -> Application should navigate to '/dashboard'. Check console for middleware log.",
            "Test 3: From Dashboard, click 'Go to Home' -> Application should navigate to '/'.",
            "Test 4: Click 'Go to Dashboard (via Link)' from Home -> Application should navigate to '/dashboard'. (Standard Link behavior)"
          ],
          "hints": [
            "Remember to use `useDispatch` and `useSelector` hooks to interact with the Redux store from functional components.",
            "`unstable_HistoryRouter` is required in React Router v6 if you want to pass a custom `history` object from the `history` package.",
            "The Redux `navigateTo` state is acting as a flag that `useEffect` observes to trigger the `useNavigate` call.",
            "The middleware is for observation and can be expanded to directly dispatch navigation actions using the `history` object if needed for more complex scenarios, but for this task, the `useEffect` approach is simpler and sufficient."
          ],
          "tags": [
            "React Router",
            "Redux",
            "Integration",
            "Hooks",
            "Middleware",
            "State Management",
            "Frontend Architecture"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "redux_fundamentals",
            "react_router_intermediate",
            "react_hooks_intermediate"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Time-travel Debugging",
            "Centralized State",
            "Imperative Navigation",
            "History API"
          ]
        },
        {
          "id": "task_implement_programmatic_navigation",
          "title": "Implement Programmatic Navigation with State Passing",
          "description": "\nCreate a React application that demonstrates programmatic navigation using the `useNavigate` hook and passing state between routes.\n\n**Requirements:**\n\n1.  **Product List Component (`ProductList`)**: Create a component that displays a list of dummy products (e.g., an array of objects with `id`, `name`, `price`). Each product item should have a button like 'View Details'.\n2.  **Product Detail Component (`ProductDetail`)**: Create a component that is designed to display details of a single product. It should be able to receive and display product `name` and `price` via `location.state`.\n3.  **Navigation Logic**: When the 'View Details' button is clicked in `ProductList`, use `useNavigate` to navigate to a generic `/product-detail` route. Crucially, pass the specific product's `name` and `price` as state data within the navigation options.\n4.  **Route Setup**: Configure your `App` component with `Routes`:\n    *   `/`: Renders `ProductList`.\n    *   `/product-detail`: Renders `ProductDetail`.\n\nYour solution should clearly show how data can be passed between routes without using URL parameters, leveraging React Router's state feature.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { Routes, Route, useNavigate, useLocation } from 'react-router-dom';\n\n// Dummy product data\nconst products = [\n  { id: 'p1', name: 'Laptop', price: 1200 },\n  { id: 'p2', name: 'Mouse', price: 25 },\n  { id: 'p3', name: 'Keyboard', price: 75 },\n];\n\n// TODO: Implement ProductList component\nfunction ProductList() {\n  const navigate = useNavigate();\n\n  const handleViewDetails = (product) => {\n    // TODO: Use navigate to go to /product-detail, passing product data as state\n  };\n\n  return (\n    <div>\n      <h1>Our Products</h1>\n      <ul>\n        {products.map((product) => (\n          <li key={product.id} style={{ marginBottom: '10px' }}>\n            {product.name} - ${product.price}\n            <button \n              onClick={() => handleViewDetails(product)}\n              style={{ marginLeft: '15px', padding: '5px 10px' }}\n            >\n              View Details\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// TODO: Implement ProductDetail component\nfunction ProductDetail() {\n  const location = useLocation();\n  // TODO: Retrieve product data from location.state\n  const product = {}; // Placeholder\n\n  if (!product || !product.name) {\n    return <div>No product details found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>Product Detail</h2>\n      <p>Name: {product.name}</p>\n      <p>Price: ${product.price}</p>\n      <button onClick={() => window.history.back()}>Go Back</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      {/* TODO: Set up routes for ProductList and ProductDetail */}\n    </Routes>\n  );\n}\n\n// Example usage: ReactDOM.createRoot(document.getElementById('root')).render(<App />);\n",
          "solutionCode": "import React from 'react';\nimport { Routes, Route, useNavigate, useLocation } from 'react-router-dom';\nimport ReactDOM from 'react-dom/client';\n\n// Dummy product data\nconst products = [\n  { id: 'p1', name: 'Laptop', price: 1200 },\n  { id: 'p2', name: 'Mouse', price: 25 },\n  { id: 'p3', name: 'Keyboard', price: 75 },\n];\n\n// ProductList component\nfunction ProductList() {\n  const navigate = useNavigate();\n\n  const handleViewDetails = (product) => {\n    // Navigate to /product-detail, passing product data as state\n    navigate('/product-detail', { state: { productData: product } });\n  };\n\n  return (\n    <div>\n      <h1>Our Products</h1>\n      <ul>\n        {products.map((product) => (\n          <li key={product.id} style={{ marginBottom: '10px' }}>\n            {product.name} - ${product.price}\n            <button \n              onClick={() => handleViewDetails(product)}\n              style={{ marginLeft: '15px', padding: '5px 10px' }}\n            >\n              View Details\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// ProductDetail component\nfunction ProductDetail() {\n  const location = useLocation();\n  // Retrieve product data from location.state\n  const product = location.state?.productData; \n  const navigate = useNavigate();\n\n  if (!product || !product.name || !product.price) {\n    return (\n      <div>\n        <p>No product details found or invalid data.</p>\n        <button onClick={() => navigate('/')}>Go to Product List</button>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <h2>Product Detail</h2>\n      <p>Name: <strong>{product.name}</strong></p>\n      <p>Price: <strong>${product.price}</strong></p>\n      <button onClick={() => navigate(-1)}>Go Back</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<ProductList />} />\n      <Route path=\"/product-detail\" element={<ProductDetail />} />\n      <Route path=\"*\" element={<h2>404 - Page Not Found</h2>} />\n    </Routes>\n  );\n}\n\n// Render App\n// const root = ReactDOM.createRoot(document.getElementById('root'));\n// root.render(<App />);\n",
          "testCases": [
            "Test 1: Navigate to '/' -> Should see the list of products.",
            "Test 2: Click 'View Details' for 'Laptop' -> Should navigate to '/product-detail' and display 'Name: Laptop', 'Price: $1200'. The URL should remain '/product-detail'.",
            "Test 3: Click 'View Details' for 'Mouse' -> Should navigate to '/product-detail' and display 'Name: Mouse', 'Price: $25'.",
            "Test 4: From '/product-detail', click 'Go Back' button -> Should navigate back to the product list.",
            "Test 5: Directly navigate to '/product-detail' (e.g., by typing in URL bar) -> Should display 'No product details found or invalid data.' and a button to go back to product list.",
            "Test 6: Refresh page on '/product-detail' after navigating from product list -> Product details should disappear (as `location.state` is lost on refresh). The component should handle this gracefully."
          ],
          "hints": [
            "Remember that `useNavigate` returns a function, and you call it with the path and an optional second argument (an object) for options like `state`.",
            "The `location.state` property will contain the object you passed. Use optional chaining (`?.`) when accessing it to prevent errors if no state was passed (e.g., if the user directly navigates to the URL).",
            "For the 'Go Back' button, `navigate(-1)` is a concise way to go back one entry in the history stack.",
            "Note that `location.state` is ephemeral; it's designed for transient data. It is not persisted across page refreshes or direct URL entries."
          ],
          "tags": [
            "React Router",
            "Navigation",
            "Programmatic",
            "useNavigate",
            "useLocation",
            "State Passing",
            "Frontend Development"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_components",
            "react_hooks_basics",
            "react_router_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Single Page Application",
            "Client-side Routing",
            "URL Parameters"
          ]
        }
      ]
    }
  },
  {
    "id": "e14fd79b-957c-45c4-bdee-5719d6a3687d",
    "startLine": 6700,
    "endLine": 6799,
    "processedDate": "2025-06-17T10:05:47.116Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_redux_router_setup",
          "title": "Redux Store Configuration with React Router Redux",
          "content": "This section details how to integrate `react-router-redux` with your Redux store, enabling the router's state to be managed by Redux and allowing for programmatic navigation. The core idea is to combine `react-router` with `redux` using `react-router-redux`.\n\n## Key Components\n\n*   **`createHistory()`**: This function, typically imported from the `history` library, creates a history object (e.g., `browserHistory` or `hashHistory`) that React Router uses to keep track of the application's navigation state. This history object is then passed to `ConnectedRouter` and `routerMiddleware`.\n*   **`configureStore(initialState, history)`**: A central function responsible for setting up the Redux store. It uses Redux's `createStore` to combine the root reducer, initial state, and enhancers.\n*   **`routerMiddleware(history)`**: This middleware from `react-router-redux` connects the browser history to Redux. It dispatches actions whenever the browser history changes (e.g., URL changes) and also listens for `react-router-redux` specific actions (like `PUSH`, `REPLACE`, `GO`) to update the browser history.\n*   **`applyMiddleware(...middlewares)`**: A Redux utility that applies various middlewares to the store, enhancing its capabilities (e.g., handling asynchronous actions, routing).\n*   **`compose`**: A Redux utility that composes functions from right to left. It's used here to chain multiple store enhancers (like `applyMiddleware` and `Redux DevTools`).\n*   **`Redux DevTools Extension`**: A powerful browser extension for debugging Redux applications. The setup includes logic to conditionally enable `window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__` in development environments, which allows integrating the DevTools with other enhancers.\n*   **`Provider` (from `react-redux`)**: Makes the Redux store available to any nested components that have been wrapped in the `connect()` function.\n*   **`ConnectedRouter` (from `react-router-redux`)**: A wrapper around `react-router`'s `Router` component that uses the Redux store to keep the router's state in sync. It takes the `history` object as a prop.\n*   **`Route` (from `react-router-dom`)**: Renders a UI component when its path matches the current URL.",
          "examples": [
            {
              "id": "example_redux_router_setup_1",
              "title": "Main Application Entry Point (index.tsx)",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { ConnectedRouter } from 'react-router-redux';\nimport { Route } from 'react-router-dom';\nimport { createBrowserHistory } from 'history'; // Using createBrowserHistory for web apps\nimport configureStore from './store';\nimport App from './App';\n\nconst rootElement = document.getElementById('root');\nconst initialState = {};\nconst history = createBrowserHistory(); // Initialize browser history\nconst store = configureStore(initialState, history);\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedRouter history={history}>\n      <Route path=\"/\" component={App} />\n    </ConnectedRouter>\n  </Provider>,\n  rootElement\n);\n",
              "explanation": "This is the main entry point of a React application integrated with Redux and React Router Redux. It sets up the Redux `Provider` to make the store available, and `ConnectedRouter` to synchronize React Router's state with Redux. The `history` object is created and passed to both the store configuration and `ConnectedRouter`.",
              "language": "typescript"
            },
            {
              "id": "example_redux_router_setup_2",
              "title": "Redux Store Configuration (store.ts)",
              "code": "import { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer'; // Assuming you have a rootReducer defined\n\nexport default function configureStore(initialState: any, history: any) {\n  const routerMW = routerMiddleware(history);\n  \n  const middleWares = [\n    routerMW,\n    // Add other middleware here, e.g., redux-thunk or redux-saga\n  ];\n  \n  const enhancers = [\n    applyMiddleware(...middleWares)\n  ];\n  \n  // Conditionally add Redux DevTools Extension if available and not in production\n  const composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n  \n  const store = createStore(\n    rootReducer,\n    initialState,\n    composeEnhancers(...enhancers),\n  );\n  \n  return store;\n}",
              "explanation": "This `configureStore` function demonstrates how to set up a Redux store with `routerMiddleware`. It applies the router middleware along with any other application-specific middlewares. It also includes the crucial step of integrating with the Redux DevTools Extension for easier debugging during development.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redux_router_setup_1",
            "question_redux_router_setup_2",
            "question_redux_router_setup_3",
            "question_redux_router_setup_4",
            "question_redux_router_setup_5",
            "question_redux_router_setup_6",
            "question_redux_router_setup_7",
            "question_redux_router_setup_8"
          ],
          "relatedTasks": [
            "task_configure_redux_router_store"
          ],
          "tags": [
            "Redux",
            "React-Router-Redux",
            "Store Configuration",
            "Middleware",
            "DevTools",
            "React"
          ],
          "technology": "TypeScript",
          "prerequisites": [
            "React Basics",
            "Redux Core Concepts",
            "React Router Basics",
            "JavaScript ES6"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced Redux Patterns",
            "Complex SPA Development",
            "State Management Integration"
          ]
        },
        {
          "id": "theory_router_state_navigation",
          "title": "Accessing Router State and Programmatic Navigation in Redux",
          "content": "Once `react-router-redux` is integrated, the router's state becomes a part of your Redux store, typically under a key like `router` (if using `routerReducer` from `react-router-redux`). This allows components connected to Redux to access navigation-related information directly from the store, and also dispatch actions to trigger navigation.\n\n## Accessing Router State\n\nThe router state in Redux generally includes the following structure:\n\n*   **`state.router.location`**: Contains details about the current URL, including:\n    *   `pathname`: The path of the URL (e.g., `/dashboard`).\n    *   `search`: The query string portion of the URL (e.g., `?name=John&age=30`).\n    *   `query`: An object representation of the query string parameters (parsed from `search`).\n    *   `hash`: The URL fragment identifier (e.g., `#section1`).\n*   **`state.router.match`**: Contains details about how the current URL matched a route, including:\n    *   `params`: An object containing key-value pairs of URL parameters (e.g., for `/users/:id`, `match.params.id` would hold the actual ID).\n    *   `isExact`: A boolean indicating if the match was exact.\n    *   `path`: The path pattern used to match (e.g., `/users/:id`).\n    *   `url`: The matched portion of the URL.\n\nThese pieces of information can be mapped to component props using `mapStateToProps`.\n\n## Programmatic Navigation\n\n`react-router-redux` provides action creators to perform navigation programmatically by dispatching Redux actions. The most common action creators are:\n\n*   **`push(path)`**: Navigates to a new URL and adds a new entry to the browser's history stack.\n*   **`replace(path)`**: Navigates to a new URL and replaces the current entry in the history stack, preventing the user from navigating back to the previous page using the browser's back button.\n*   **`go(delta)`**: Navigates forward or backward in the history stack by a given number (e.g., `go(-1)` for back, `go(1)` for forward).\n\nThese actions can be dispatched using `mapDispatchToProps`.",
          "examples": [
            {
              "id": "example_router_state_navigation_1",
              "title": "Accessing Route Parameters from Redux State",
              "code": "import { connect } from 'react-redux';\n\ninterface RootState {\n  router: {\n    location: { \n      pathname: string; \n      search: string; \n      query: { [key: string]: string };\n    };\n    match: { \n      params: { [key: string]: string };\n    };\n  };\n}\n\nconst mapStateToProps = (state: RootState) => ({\n  currentPath: state.router.location.pathname,\n  queryParams: state.router.location.query, // for query parameters (e.g., ?page=2)\n  pathParams: state.router.match.params // for path parameters (e.g., /users/:id)\n});\n\n// Example usage within a connected component:\n// class MyComponent extends React.Component<typeof mapStateToProps> { ... }\n// const ConnectedMyComponent = connect(mapStateToProps)(MyComponent);\n",
              "explanation": "This example shows how to use `mapStateToProps` to extract various router-related pieces of information from the Redux store. `state.router.location` provides details about the current URL, while `state.router.match` provides information about route matching, specifically path parameters.",
              "language": "typescript"
            },
            {
              "id": "example_router_state_navigation_2",
              "title": "Programmatic Navigation Using Redux Actions",
              "code": "import { connect } from 'react-redux';\nimport { push } from 'react-router-redux';\n\ninterface MyComponentProps {\n  navigateTo: (path: string) => void;\n}\n\n// In a React component (e.g., functional component or class component method)\nconst mapDispatchToProps = (dispatch: any) => ({\n  navigateTo: (path: string) => dispatch(push(path))\n});\n\n// Example usage in a class component:\n// class MyComponent extends React.Component<MyComponentProps> {\n//   handleButtonClick = () => {\n//     this.props.navigateTo('/dashboard');\n//   };\n//   render() {\n//     return <button onClick={this.handleButtonClick}>Go to Dashboard</button>;\n//   }\n// }\n// const ConnectedMyComponent = connect(null, mapDispatchToProps)(MyComponent);\n\n// Example usage in a functional component with useDispatch hook (if not using connect)\n// import { useDispatch } from 'react-redux';\n// import { push } from 'react-router-redux';\n// function MyFunctionalComponent() {\n//   const dispatch = useDispatch();\n//   const navigateToDashboard = () => dispatch(push('/dashboard'));\n//   return <button onClick={navigateToDashboard}>Go to Dashboard</button>;\n// }\n",
              "explanation": "This example demonstrates how `mapDispatchToProps` can be used to bind the `push` action creator from `react-router-redux` to a component's props. This allows the component to trigger navigation programmatically by simply calling `this.props.navigateTo('/some-path')`, dispatching a Redux action that `routerMiddleware` intercepts to update the browser's history.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_router_state_navigation_1",
            "question_router_state_navigation_2",
            "question_router_state_navigation_3",
            "question_router_state_navigation_4",
            "question_router_state_navigation_5",
            "question_router_state_navigation_6",
            "question_router_state_navigation_7",
            "question_router_state_navigation_8",
            "question_router_state_navigation_9"
          ],
          "relatedTasks": [
            "task_route_info_navigation_component"
          ],
          "tags": [
            "Redux State",
            "React-Router-Redux",
            "Navigation",
            "mapStateToProps",
            "mapDispatchToProps",
            "Programmatic Navigation",
            "URL Parameters"
          ],
          "technology": "TypeScript",
          "prerequisites": [
            "Redux Connect",
            "React Router Basics",
            "Redux Actions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Dynamic Routing",
            "User Experience Optimization",
            "Data Fetching on Route Change"
          ]
        },
        {
          "id": "theory_url_parameters",
          "title": "Working with URL Parameters in React Router",
          "content": "URL parameters are dynamic segments in a URL that allow a route to capture variable data. They are crucial for building applications with dynamic content, such as user profiles, product details, or specific article pages. React Router provides mechanisms to define and access these parameters.\n\n## Route Definition\n\nIn React Router, you define a route with parameters using a colon `:` followed by the parameter name. For example, `path=\"/users/:id\"` defines a route where `:id` is a dynamic parameter.\n\n## Accessing Parameters in a Component\n\nWhen a `Route` matches a URL with parameters, the matched component receives `match` object in its `props`. This `match` object contains a `params` property, which is an object holding the key-value pairs of the URL parameters.\n\n*   **`this.props.match.params`**: This is the standard way to access path parameters directly within a class component rendered by a `Route`. For functional components, you can use the `useParams` hook (part of React Router v5+ hooks API) or `withRouter` HOC.\n\n## Accessing Parameters from Redux State\n\nAs discussed in the previous section, if `react-router-redux` is configured, route parameters can also be accessed from the Redux store via `state.router.match.params`. Similarly, query parameters (e.g., `?search=term`) are available under `state.router.location.query`.\n\nThis is particularly useful when you need to access route information in parts of your application that are not directly rendered by a `Route` component, or when performing data fetching in Redux sagas/thunks based on URL parameters.",
          "examples": [
            {
              "id": "example_url_parameters_1",
              "title": "Route Definition with URL Parameter",
              "code": "import { Route } from 'react-router-dom';\nimport UserProfile from './UserProfile';\n\n// In your App.tsx or routes configuration\n<Route path=\"/users/:id\" component={UserProfile} />\n\n// Example URL: /users/123 -> id = '123'\n// Example URL: /users/abc-def -> id = 'abc-def'\n",
              "explanation": "This demonstrates how to define a route that expects a dynamic segment (`:id`). When a URL like `/users/123` is matched, `123` will be captured as the `id` parameter and passed to the `UserProfile` component.",
              "language": "typescript"
            },
            {
              "id": "example_url_parameters_2",
              "title": "Accessing Path Parameters in a Class Component",
              "code": "import React from 'react';\nimport { RouteComponentProps } from 'react-router-dom';\n\ninterface UserProfileParams {\n  id: string;\n}\n\ninterface UserProfileProps extends RouteComponentProps<UserProfileParams> {\n  fetchUserData: (userId: string) => void; // Assume this prop is passed via Redux connect or parent\n}\n\nclass UserProfile extends React.Component<UserProfileProps> {\n  componentDidMount() {\n    // Access the 'id' parameter from this.props.match.params\n    const userId = this.props.match.params.id;\n    console.log('Fetching user data for ID:', userId);\n    // Example: this.props.fetchUserData(userId); // Dispatch an action to fetch data\n  }\n  \n  componentDidUpdate(prevProps: UserProfileProps) {\n    // Re-fetch data if the ID parameter changes (e.g., from /users/1 to /users/2)\n    if (prevProps.match.params.id !== this.props.match.params.id) {\n      const userId = this.props.match.params.id;\n      console.log('Refetching user data for ID:', userId);\n      // this.props.fetchUserData(userId);\n    }\n  }\n\n  render() {\n    const { id } = this.props.match.params;\n    return (\n      <div>\n        <h2>User Profile for ID: {id}</h2>\n        {/* Render user data here */}\n      </div>\n    );\n  }\n}\n\nexport default UserProfile;\n",
              "explanation": "This `UserProfile` class component demonstrates how to access the `id` URL parameter via `this.props.match.params.id`. It also includes a common pattern for fetching data in `componentDidMount` and `componentDidUpdate` to react to initial load and parameter changes, respectively.",
              "language": "typescript"
            },
            {
              "id": "example_url_parameters_3",
              "title": "Accessing Query Parameters from Redux State",
              "code": "import { connect } from 'react-redux';\n\ninterface RootState {\n  routing: {\n    locationBeforeTransitions: {\n      query: { [key: string]: string | string[] | undefined };\n    };\n  };\n}\n\nconst mapStateToProps = (state: RootState) => ({\n  // For react-router-redux v4 or older, state.routing.locationBeforeTransitions might be used\n  // For react-router-redux v5, it's typically state.router.location.query\n  userIdFromQuery: state.routing.locationBeforeTransitions.query.id, // Example: /users?id=123\n  page: state.routing.locationBeforeTransitions.query.page\n});\n\n// Usage in a connected component:\n// class MyComponent extends React.Component<typeof mapStateToProps> {\n//   componentDidMount() {\n//     const { userIdFromQuery, page } = this.props;\n//     console.log('User ID from query:', userIdFromQuery, 'Page:', page);\n//   }\n//   render() { return <div>User ID: {this.props.userIdFromQuery}</div>; }\n// }\n",
              "explanation": "This example shows how query parameters (e.g., `?id=123&page=1`) can be accessed from the Redux store. Depending on the `react-router-redux` version, the exact path to `query` might differ (e.g., `state.routing.locationBeforeTransitions.query` or `state.router.location.query`). It's useful for accessing parameters that are not part of the URL path itself.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_url_parameters_1",
            "question_url_parameters_2",
            "question_url_parameters_3",
            "question_url_parameters_4",
            "question_url_parameters_5",
            "question_url_parameters_6"
          ],
          "relatedTasks": [
            "task_fetch_user_data_by_url_param"
          ],
          "tags": [
            "React Router",
            "URL Parameters",
            "Route Matching",
            "Query Parameters",
            "Redux State Access"
          ],
          "technology": "TypeScript",
          "prerequisites": [
            "React Components",
            "React Router Basics",
            "Redux State Access"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Dynamic Content Loading",
            "RESTful API Integration",
            "SEO friendly URLs"
          ]
        },
        {
          "id": "theory_react_hooks_placeholder",
          "title": "React Hooks (No Content Provided)",
          "content": "The markdown content includes a heading for 'React Hooks' but provides no further details or examples related to them. Therefore, this section will briefly define what React Hooks are, but cannot offer specific theory, questions, or tasks based on the original content.\n\n## What are React Hooks?\n\nReact Hooks are functions that let you 'hook into' React state and lifecycle features from functional components. They allow you to write functional components with state and side effects, without needing to convert them into class components. Key hooks include:\n\n*   **`useState`**: For adding state to functional components.\n*   **`useEffect`**: For performing side effects (data fetching, subscriptions, manual DOM manipulations, etc.).\n*   **`useContext`**: For subscribing to React context.\n*   **`useReducer`**: An alternative to `useState` for more complex state logic.\n*   **`useCallback` / `useMemo`**: For performance optimizations.\n\nWhile this content is important for modern React development, the provided markdown does not elaborate on it.",
          "examples": [],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React Hooks",
            "Functional Components",
            "State Management",
            "Side Effects"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "JavaScript ES6"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Modern React Development",
            "Performance Optimization",
            "Component Reusability"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_redux_router_setup_1",
          "topic": "Redux Store Configuration",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `routerMiddleware` in `react-router-redux`?",
          "answer": "To synchronize the browser's history with the Redux store and vice versa.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of a key component in the integration.",
            "Differentiates it from other Redux middlewares."
          ],
          "keyConcepts": [
            "routerMiddleware",
            "Redux Middleware",
            "React-Router-Redux"
          ],
          "evaluationCriteria": [
            "Recall of fundamental purpose",
            "Understanding of synchronization role"
          ],
          "example": "routerMiddleware bridges the gap between `history` actions (like `push`, `pop`, `replace`) and Redux actions, allowing navigation events to update the Redux state and Redux actions to trigger navigation.",
          "tags": [
            "Redux",
            "React-Router-Redux",
            "Middleware"
          ],
          "prerequisites": [
            "Redux Core Concepts",
            "React Router Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_router_setup_2",
          "topic": "Redux Store Configuration",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following `configureStore` function, what is the role of `composeEnhancers`?",
          "answer": "To combine multiple store enhancers, including `applyMiddleware` and the Redux DevTools Extension, into a single function.",
          "options": [
            "To combine multiple store enhancers, including `applyMiddleware` and the Redux DevTools Extension, into a single function.",
            "To combine multiple reducers into a single root reducer.",
            "To apply multiple middleware functions sequentially.",
            "To create a history object for React Router."
          ],
          "analysisPoints": [
            "Tests understanding of Redux's `compose` utility.",
            "Highlights the conditional integration of Redux DevTools.",
            "Distinguishes `composeEnhancers` from `combineReducers` or `applyMiddleware` directly."
          ],
          "keyConcepts": [
            "compose",
            "Store Enhancers",
            "Redux DevTools",
            "applyMiddleware"
          ],
          "evaluationCriteria": [
            "Understanding of Redux composition",
            "Knowledge of Redux DevTools integration"
          ],
          "example": "```typescript\nimport { createStore, applyMiddleware, compose } from 'redux';\n\nconst composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n\n// Used like: createStore(rootReducer, initialState, composeEnhancers(...enhancers));\n```\n`composeEnhancers` is essential for applying multiple store enhancers. In development, it typically includes the Redux DevTools Extension's composer to allow the extension to intercept store actions and state, while in production or if the extension is unavailable, it falls back to Redux's standard `compose` function.",
          "tags": [
            "Redux",
            "Store Configuration",
            "DevTools",
            "Middleware"
          ],
          "prerequisites": [
            "Redux Core Concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_router_setup_3",
          "topic": "React Router Redux Integration",
          "level": "easy",
          "type": "mcq",
          "question": "Which component is responsible for making the Redux store available to connected components in a React application?",
          "answer": "`Provider`",
          "options": [
            "`ConnectedRouter`",
            "`Route`",
            "`Provider`",
            "`App`"
          ],
          "analysisPoints": [
            "Tests basic knowledge of `react-redux` fundamentals.",
            "Ensures understanding of the role of `Provider`."
          ],
          "keyConcepts": [
            "Provider",
            "Redux",
            "React-Redux"
          ],
          "evaluationCriteria": [
            "Basic recall of `react-redux` API",
            "Understanding of dependency injection"
          ],
          "example": "The `Provider` component from `react-redux` is always at the top level of your component tree and takes the Redux store as a prop. This allows any component wrapped with `connect` (or using `useSelector`/`useDispatch` hooks) to access the store.",
          "tags": [
            "Redux",
            "React",
            "State Management"
          ],
          "prerequisites": [
            "React Basics",
            "Redux Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_router_setup_4",
          "topic": "React Router Redux Integration",
          "level": "medium",
          "type": "open",
          "question": "Explain the relationship between `createHistory()`, `routerMiddleware`, and `ConnectedRouter` in setting up `react-router-redux`.",
          "answer": "These three components work together to integrate React Router's navigation state with Redux.\n\n1.  **`createHistory()`**: This function (from the `history` library) initializes a history object (e.g., `browserHistory` or `hashHistory`). This object is the source of truth for the browser's URL and history stack.\n2.  **`routerMiddleware(history)`**: This Redux middleware takes the `history` object as an argument. It serves two main purposes:\n    *   It listens for changes in the browser's history (e.g., user clicks back/forward, URL changes) and dispatches corresponding Redux actions (e.g., `LOCATION_CHANGE`) to update the router state in the Redux store.\n    *   It intercepts `react-router-redux` specific actions dispatched from your application (e.g., `PUSH`, `REPLACE`, `GO`) and uses the `history` object to perform the actual browser navigation.\n3.  **`ConnectedRouter history={history}`**: This component acts as the React Router's `Router` but is specifically designed to work with `react-router-redux`. It receives the same `history` object as the middleware. It listens to the Redux store for router state changes (dispatched by `routerMiddleware`) and updates its internal React Router state accordingly, re-rendering components based on the new route.\n\nIn essence, `createHistory()` provides the history object, `routerMiddleware` synchronizes this history with the Redux store, and `ConnectedRouter` uses this synced history to render the correct React components.",
          "options": [],
          "analysisPoints": [
            "Tests comprehensive understanding of the setup flow.",
            "Requires explaining the role and interaction of multiple components.",
            "Highlights the bidirectional data flow."
          ],
          "keyConcepts": [
            "createHistory",
            "routerMiddleware",
            "ConnectedRouter",
            "React-Router-Redux",
            "History API"
          ],
          "evaluationCriteria": [
            "Clarity of explanation",
            "Accuracy of component roles",
            "Demonstrates understanding of system architecture"
          ],
          "example": "",
          "tags": [
            "Redux",
            "React Router",
            "Architecture",
            "Integration"
          ],
          "prerequisites": [
            "Redux Middleware",
            "React Router API"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_router_setup_5",
          "topic": "Redux Store Configuration",
          "level": "medium",
          "type": "code",
          "question": "Complete the `configureStore` function below to correctly integrate `routerMiddleware` and conditionally enable Redux DevTools Extension. Assume `rootReducer` and `createBrowserHistory` are imported.",
          "answer": "```typescript\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer';\n\nexport default function configureStore(initialState: any, history: any) {\n  const routerMW = routerMiddleware(history);\n  \n  const middleWares = [\n    routerMW,\n    // other middleware like thunk or saga\n  ];\n  \n  const enhancers = [\n    applyMiddleware(...middleWares)\n  ];\n  \n  const composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n  \n  const store = createStore(\n    rootReducer,\n    initialState,\n    composeEnhancers(...enhancers),\n  );\n  \n  return store;\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to correctly apply Redux middleware.",
            "Checks understanding of conditional DevTools setup.",
            "Verifies knowledge of `compose` and `applyMiddleware` syntax."
          ],
          "keyConcepts": [
            "createStore",
            "applyMiddleware",
            "compose",
            "routerMiddleware",
            "Redux DevTools"
          ],
          "evaluationCriteria": [
            "Correct syntax and API usage",
            "Logical implementation of conditional DevTools",
            "Proper middleware application"
          ],
          "example": "This task requires synthesizing the store configuration logic, ensuring that `routerMiddleware` is part of the `middleWares` array and that `composeEnhancers` correctly handles the DevTools integration.",
          "tags": [
            "Redux",
            "Store Configuration",
            "Coding Task"
          ],
          "prerequisites": [
            "Redux API",
            "JavaScript Syntax"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_1",
          "topic": "Accessing Router State",
          "level": "easy",
          "type": "flashcard",
          "question": "What Redux state path typically holds the current URL's pathname when using `react-router-redux`?",
          "answer": "`state.router.location.pathname`",
          "options": [],
          "analysisPoints": [
            "Tests quick recall of common state structure.",
            "Essential for connecting components to router data."
          ],
          "keyConcepts": [
            "Router State",
            "Redux State Path",
            "pathname"
          ],
          "evaluationCriteria": [
            "Accurate path recall"
          ],
          "example": "If the URL is `http://example.com/dashboard/settings`, then `state.router.location.pathname` would be `/dashboard/settings`.",
          "tags": [
            "Redux State",
            "React-Router-Redux"
          ],
          "prerequisites": [
            "Redux State Access"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_state_navigation_2",
          "topic": "Accessing Router State",
          "level": "medium",
          "type": "mcq",
          "question": "If your route is defined as `<Route path=\"/products/:category/:id\" component={ProductDetail} />` and the current URL is `/products/electronics/123`, which `mapStateToProps` snippet correctly extracts both `category` and `id`?",
          "answer": "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.match.params.category,\n  productId: state.router.match.params.id\n});\n```",
          "options": [
            "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.location.query.category,\n  productId: state.router.location.query.id\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.match.params.category,\n  productId: state.router.match.params.id\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.location.pathname.split('/')[2],\n  productId: state.router.location.pathname.split('/')[3]\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.params.category,\n  productId: state.router.params.id\n});\n```"
          ],
          "analysisPoints": [
            "Tests understanding of the difference between path parameters (`match.params`) and query parameters (`location.query`).",
            "Checks knowledge of the Redux state structure provided by `react-router-redux`."
          ],
          "keyConcepts": [
            "mapStateToProps",
            "Path Parameters",
            "Query Parameters",
            "Router State"
          ],
          "evaluationCriteria": [
            "Correctly identifies parameter source",
            "Accurate state path usage"
          ],
          "example": "Path parameters are defined within the route path itself (e.g., `/products/:id`), and `react-router-redux` exposes them via `state.router.match.params`. Query parameters (e.g., `?category=electronics`) are appended after `?` and are available via `state.router.location.query`.",
          "tags": [
            "Redux State",
            "URL Parameters",
            "mapStateToProps"
          ],
          "prerequisites": [
            "React Router Parameters",
            "Redux Connect"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_3",
          "topic": "Programmatic Navigation",
          "level": "easy",
          "type": "flashcard",
          "question": "Which action creator from `react-router-redux` is used to navigate to a new URL and add an entry to the browser's history stack?",
          "answer": "`push`",
          "options": [],
          "analysisPoints": [
            "Tests recall of the most common navigation action.",
            "Distinguishes it from `replace`."
          ],
          "keyConcepts": [
            "push action",
            "Programmatic Navigation",
            "History Stack"
          ],
          "evaluationCriteria": [
            "Correct action creator identification"
          ],
          "example": "Dispatching `push('/new-route')` behaves like clicking a `<Link to=\"/new-route\">` and allows the user to press the browser's back button to return to the previous page.",
          "tags": [
            "React-Router-Redux",
            "Navigation"
          ],
          "prerequisites": [
            "Redux Actions"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_state_navigation_4",
          "topic": "Programmatic Navigation",
          "level": "medium",
          "type": "code",
          "question": "Write a `mapDispatchToProps` function that provides a prop `navigateToHome` to a component, which, when called, dispatches a Redux action to navigate to the `/` path using `react-router-redux`.",
          "answer": "```typescript\nimport { push } from 'react-router-redux';\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  navigateToHome: () => dispatch(push('/'))\n});\n\n// Example usage in a component:\n// class MyComponent extends React.Component<any, any> {\n//   render() {\n//     return <button onClick={this.props.navigateToHome}>Go Home</button>;\n//   }\n// }\n// export default connect(null, mapDispatchToProps)(MyComponent);\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to use `mapDispatchToProps` correctly.",
            "Verifies knowledge of dispatching `react-router-redux` actions."
          ],
          "keyConcepts": [
            "mapDispatchToProps",
            "push action",
            "Programmatic Navigation",
            "Redux Dispatch"
          ],
          "evaluationCriteria": [
            "Correct `mapDispatchToProps` signature",
            "Proper action creator usage",
            "Functionality of dispatch"
          ],
          "example": "This solution demonstrates how to create a dispatch function that maps to a prop, allowing the component to trigger navigation without directly importing `dispatch` or `push`.",
          "tags": [
            "Redux",
            "Navigation",
            "Coding Task"
          ],
          "prerequisites": [
            "Redux Connect",
            "Redux Actions"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_5",
          "topic": "Router State vs. Component Props",
          "level": "hard",
          "type": "open",
          "question": "In a React application using `react-router-redux`, describe scenarios where it's more beneficial to access router state (like URL parameters or current path) from the Redux store rather than directly from `this.props.match` or `this.props.location` in a component. Provide at least two distinct scenarios.",
          "answer": "While `this.props.match` and `this.props.location` (provided by React Router directly to components rendered by `<Route>`) are convenient, accessing router state from the Redux store offers advantages in specific scenarios:\n\n1.  **Global Access/Cross-Component Consumption**: If router information (e.g., current path, specific URL parameters) is needed by a component that is *not* directly rendered by a `<Route>` (e.g., a header, sidebar, or a deeply nested child component that shouldn't receive all router props directly through prop drilling), accessing it from the Redux store is more efficient. Any connected component can then subscribe to the relevant slice of router state without needing to be `withRouter` wrapped or having props passed down multiple levels.\n\n2.  **Logic in Redux (Sagas/Thunks)**: When asynchronous operations or complex business logic within Redux middleware (like Redux-Saga or Redux-Thunk) depend on the current route or its parameters, accessing this information directly from the Redux store's state is essential. For example, a saga might need to fetch user data based on a `userId` parameter from the URL when a `LOCATION_CHANGE` action is dispatched, or before performing an API call triggered by an unrelated action.\n\n3.  **State Persistence/Hydration**: If you need to persist or rehydrate the application's entire state, including navigation state, across page refreshes or between sessions, having the router state in Redux makes this straightforward. The Redux store is designed for state serialization and deserialization.\n\n4.  **Time Travel Debugging**: Integrating router state into Redux allows it to participate in Redux DevTools' time-travel debugging capabilities. You can step through navigation changes, inspect the router state at each point, and even 'replay' navigation sequences, which is invaluable for debugging complex routing issues.",
          "options": [],
          "analysisPoints": [
            "Tests deep understanding of Redux-Router integration benefits.",
            "Requires critical thinking beyond basic component-level access.",
            "Evaluates knowledge of Redux's broader ecosystem (middleware, dev tools)."
          ],
          "keyConcepts": [
            "Router State",
            "Redux Store",
            "Global State",
            "Middleware Logic",
            "Debugging",
            "Prop Drilling"
          ],
          "evaluationCriteria": [
            "Identification of valid, distinct scenarios",
            "Depth of explanation for each scenario",
            "Demonstration of architectural insight"
          ],
          "example": "",
          "tags": [
            "Architecture",
            "Redux",
            "React Router",
            "Best Practices"
          ],
          "prerequisites": [
            "Redux Advanced",
            "React Router Advanced"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_router_state_navigation_6",
          "topic": "Programmatic Navigation",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary difference between dispatching `push('/new-path')` and `replace('/new-path')` from `react-router-redux`?",
          "answer": "`push` adds a new entry to the history stack, while `replace` overwrites the current entry.",
          "options": [
            "`push` causes a full page reload, while `replace` does not.",
            "`push` adds a new entry to the history stack, while `replace` overwrites the current entry.",
            "`push` is synchronous, while `replace` is asynchronous.",
            "`push` is for internal navigation, `replace` is for external links."
          ],
          "analysisPoints": [
            "Tests understanding of `push` vs. `replace` behavior in browser history.",
            "Crucial for correct user experience with back/forward navigation."
          ],
          "keyConcepts": [
            "push action",
            "replace action",
            "History API",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [
            "Accurate distinction between history stack manipulation",
            "Understanding of user impact"
          ],
          "example": "If you are on `/pageA` and dispatch `push('/pageB')`, your history becomes `[pageA, pageB]`. Pressing back takes you to `/pageA`. If you were on `/pageA` and dispatched `replace('/pageB')`, your history becomes `[pageB]`. Pressing back from `/pageB` (if it was the replaced entry) would take you to the page *before* `/pageA`.",
          "tags": [
            "React-Router-Redux",
            "Navigation",
            "History Management"
          ],
          "prerequisites": [
            "Browser History API"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_7",
          "topic": "Accessing Router State",
          "level": "medium",
          "type": "code",
          "question": "Write a `mapStateToProps` function for a React component that needs to display the current URL's pathname and any query parameters (e.g., `?search=react&type=library`). Assume the Redux state structure as `state.router.location`.",
          "answer": "```typescript\nimport { connect } from 'react-redux';\n\ninterface RootState {\n  router: {\n    location: {\n      pathname: string;\n      query: { [key: string]: string | string[] | undefined };\n    };\n  };\n}\n\ninterface MyComponentProps {\n  currentPath: string;\n  queryParams: { [key: string]: string | string[] | undefined };\n}\n\nconst mapStateToProps = (state: RootState): MyComponentProps => ({\n  currentPath: state.router.location.pathname,\n  queryParams: state.router.location.query\n});\n\n// Example usage in a connected component:\n// class MySearchComponent extends React.Component<MyComponentProps> {\n//   render() {\n//     const { currentPath, queryParams } = this.props;\n//     return (\n//       <div>\n//         <p>Current Path: {currentPath}</p>\n//         <p>Search Term: {queryParams.search || 'N/A'}</p>\n//         <p>Type: {queryParams.type || 'N/A'}</p>\n//       </div>\n//     );\n//   }\n// }\n// export default connect(mapStateToProps)(MySearchComponent);\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to correctly map `pathname` and `query` from Redux state.",
            "Checks understanding of the router state object structure."
          ],
          "keyConcepts": [
            "mapStateToProps",
            "pathname",
            "query parameters",
            "Redux State"
          ],
          "evaluationCriteria": [
            "Accurate state access paths",
            "Correct return object structure",
            "TypeScript type awareness"
          ],
          "example": "This solution directly maps the required router properties from `state.router.location` to component props, making them easily accessible for display or logic within the component.",
          "tags": [
            "Redux",
            "mapStateToProps",
            "URL Parameters",
            "Coding Task"
          ],
          "prerequisites": [
            "Redux Connect",
            "JavaScript Objects"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_8",
          "topic": "Redux and React Router Ecosystem",
          "level": "medium",
          "type": "open",
          "question": "What is the primary benefit of using `react-router-redux` over simply letting React Router manage its own internal state?",
          "answer": "The primary benefit of using `react-router-redux` is that it makes the router's state (current location, URL parameters, query parameters, etc.) a first-class citizen within your Redux store. This unification offers several advantages:\n\n1.  **Centralized State Management**: All application state, including navigation, is managed in one predictable Redux store. This simplifies debugging and makes state changes more transparent.\n2.  **Predictable State Updates**: Navigation changes become regular Redux actions, allowing you to use Redux middleware (e.g., Redux-Saga, Redux-Thunk) to intercept, log, or perform side effects based on route transitions. This is incredibly powerful for data fetching, analytics, or authentication checks tied to navigation.\n3.  **Global Accessibility**: Any part of your application connected to the Redux store can access the current router state without needing to be directly rendered by a `<Route>` or wrapped by `withRouter`. This reduces prop drilling and makes router information available where it's needed (e.g., in a header component that displays the current page title based on the route).\n4.  **Time-Travel Debugging**: With router state in Redux, you can leverage the Redux DevTools Extension to inspect, replay, and time-travel through navigation actions and state changes, significantly improving the debugging experience for routing-related issues.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of the 'why' behind the integration.",
            "Highlights key advantages of Redux's architecture.",
            "Emphasizes benefits for debugging and application logic."
          ],
          "keyConcepts": [
            "Centralized State",
            "Redux Middleware",
            "Debugging",
            "Predictability",
            "Global Access"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of benefits",
            "Clear articulation of Redux principles",
            "Identification of practical advantages"
          ],
          "example": "",
          "tags": [
            "Redux",
            "React Router",
            "Architecture",
            "Benefits"
          ],
          "prerequisites": [
            "Redux Core Concepts",
            "React Router Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_9",
          "topic": "Router State",
          "level": "medium",
          "type": "flashcard",
          "question": "How do you access the path parameters (e.g., `id` from `/users/:id`) from the Redux store when using `react-router-redux`?",
          "answer": "Through `state.router.match.params`",
          "options": [],
          "analysisPoints": [
            "Tests specific knowledge of the Redux state structure for route matching.",
            "Distinguishes from `location` properties."
          ],
          "keyConcepts": [
            "Path Parameters",
            "Redux State",
            "match.params"
          ],
          "evaluationCriteria": [
            "Accurate path recall"
          ],
          "example": "If the URL is `/users/42`, then `state.router.match.params.id` would be `\"42\"`.",
          "tags": [
            "Redux State",
            "URL Parameters",
            "React-Router-Redux"
          ],
          "prerequisites": [
            "Redux State Access",
            "React Router Parameters"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_parameters_1",
          "topic": "URL Parameters",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you define a URL parameter in a React Router `Route` path?",
          "answer": "By prefixing the parameter name with a colon, e.g., `/users/:id`.",
          "options": [],
          "analysisPoints": [
            "Tests basic syntax for route definition.",
            "Fundamental to dynamic routing."
          ],
          "keyConcepts": [
            "Route Definition",
            "URL Parameters",
            "React Router"
          ],
          "evaluationCriteria": [
            "Correct syntax recall"
          ],
          "example": "<Route path=\"/posts/:slug\" component={PostDetail} />",
          "tags": [
            "React Router",
            "Routing"
          ],
          "prerequisites": [
            "React Router Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_url_parameters_2",
          "topic": "URL Parameters",
          "level": "medium",
          "type": "mcq",
          "question": "In a class component rendered by React Router, if the route is `/products/:productId` and the URL is `/products/book-123`, how would you access `book-123` within the component?",
          "answer": "`this.props.match.params.productId`",
          "options": [
            "`this.props.location.query.productId`",
            "`this.props.params.productId`",
            "`this.props.match.productId`",
            "`this.props.match.params.productId`"
          ],
          "analysisPoints": [
            "Tests knowledge of the `match` prop structure.",
            "Distinguishes `match.params` from other prop properties.",
            "Ensures understanding of parameter naming matching the route definition."
          ],
          "keyConcepts": [
            "match prop",
            "Path Parameters",
            "RouteComponentProps"
          ],
          "evaluationCriteria": [
            "Accurate prop access",
            "Understanding of parameter object structure"
          ],
          "example": "```typescript\ninterface ProductDetailParams { productId: string; }\ninterface ProductDetailProps extends RouteComponentProps<ProductDetailParams> { /* ... */ }\n\nclass ProductDetail extends React.Component<ProductDetailProps> {\n  componentDidMount() {\n    console.log(this.props.match.params.productId); // Outputs: 'book-123'\n  }\n  render() { /* ... */ }\n}\n```",
          "tags": [
            "React Router",
            "URL Parameters",
            "Component Props"
          ],
          "prerequisites": [
            "React Component Props",
            "React Router Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_parameters_3",
          "topic": "URL Parameters",
          "level": "medium",
          "type": "open",
          "question": "When fetching data in a React component based on a URL parameter, what lifecycle methods (for class components) or hooks (for functional components) would you typically use, and why?",
          "answer": "For class components, you would typically use `componentDidMount` and `componentDidUpdate`:\n\n*   **`componentDidMount()`**: This method is called once when the component is first mounted (inserted into the DOM). It's the ideal place to perform initial data fetching based on the URL parameter, as the component is ready and the `match.params` are available.\n*   **`componentDidUpdate(prevProps)`**: This method is called after every re-render (except the initial one). You need to use this to handle cases where the URL parameter changes *without* the component unmounting and remounting (e.g., navigating from `/users/1` to `/users/2`). Inside `componentDidUpdate`, you would compare `this.props.match.params.id` with `prevProps.match.params.id` and re-fetch data if they differ.\n\nFor functional components (using React Hooks, introduced in React 16.8):\n\n*   **`useEffect`**: This hook is used for side effects. You would typically use `useEffect` to fetch data. The dependencies array of `useEffect` is crucial here:\n    ```typescript\n    import React, { useEffect } from 'react';\n    import { useParams } from 'react-router-dom';\n\n    function UserProfile() {\n      const { userId } = useParams<{ userId: string }>();\n\n      useEffect(() => {\n        if (userId) {\n          console.log('Fetching user data for ID:', userId);\n          // fetchUserData(userId);\n        }\n      }, [userId]); // Dependency array: effect runs when userId changes\n\n      return <div>User ID: {userId}</div>;\n    }\n    ```\n    By including `userId` in the dependency array, the effect will run initially and also whenever the `userId` parameter in the URL changes, mimicking the behavior of `componentDidMount` and `componentDidUpdate` combined for this specific data fetching pattern.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of component lifecycle for data fetching.",
            "Covers both class components and functional components with Hooks.",
            "Emphasizes the importance of handling parameter changes (updates)."
          ],
          "keyConcepts": [
            "componentDidMount",
            "componentDidUpdate",
            "useEffect",
            "URL Parameters",
            "Data Fetching",
            "React Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct lifecycle method/hook identification",
            "Clear explanation of their purpose",
            "Handling of parameter changes"
          ],
          "example": "",
          "tags": [
            "React",
            "Data Fetching",
            "Lifecycle Methods",
            "React Hooks"
          ],
          "prerequisites": [
            "React Component Lifecycle",
            "React Hooks Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_parameters_4",
          "topic": "URL Parameters",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the difference between `path parameters` and `query parameters` in a URL?",
          "answer": "Path parameters are integral parts of the URL path that identify a specific resource (e.g., `/users/123`). Query parameters are appended to the URL after a `?` and provide additional filtering or sorting options (e.g., `/users?status=active&page=2`).",
          "options": [],
          "analysisPoints": [
            "Tests fundamental URL structure understanding.",
            "Crucial for correct route and data handling."
          ],
          "keyConcepts": [
            "Path Parameters",
            "Query Parameters",
            "URL Structure"
          ],
          "evaluationCriteria": [
            "Accurate definition of each parameter type"
          ],
          "example": "URL: `/products/electronics?sort=price_asc&limit=10`\nPath parameter: `electronics` (from `/products/:category`)\nQuery parameters: `sort=price_asc`, `limit=10`",
          "tags": [
            "URL",
            "Routing",
            "Web Fundamentals"
          ],
          "prerequisites": [
            "Web Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_url_parameters_5",
          "topic": "URL Parameters",
          "level": "medium",
          "type": "code",
          "question": "Given a route `<Route path=\"/search\" component={SearchPage} />` and a URL `/search?query=react&page=1`, write the `mapStateToProps` function to extract `query` and `page` parameters from the Redux state (assuming `state.router.location.query` structure).",
          "answer": "```typescript\nimport { connect } from 'react-redux';\n\ninterface RootState {\n  router: {\n    location: {\n      query: { [key: string]: string | string[] | undefined };\n    };\n  };\n}\n\ninterface SearchPageProps {\n  searchTerm?: string;\n  currentPage?: string;\n}\n\nconst mapStateToProps = (state: RootState): SearchPageProps => ({\n  searchTerm: state.router.location.query.query, // 'query' is the name of the URL query param\n  currentPage: state.router.location.query.page\n});\n\n// Example usage in a connected component:\n// class SearchPage extends React.Component<SearchPageProps> {\n//   render() {\n//     const { searchTerm, currentPage } = this.props;\n//     return (\n//       <div>\n//         <p>Search Term: {searchTerm || 'N/A'}</p>\n//         <p>Current Page: {currentPage || '1'}</p>\n//       </div>\n//     );\n//   }\n// }\n// export default connect(mapStateToProps)(SearchPage);\n```",
          "options": [],
          "analysisPoints": [
            "Tests correct access of query parameters from Redux state.",
            "Verifies understanding of how `location.query` object works."
          ],
          "keyConcepts": [
            "Query Parameters",
            "mapStateToProps",
            "Redux State",
            "location.query"
          ],
          "evaluationCriteria": [
            "Accurate state path for query parameters",
            "Correct property access within `query` object"
          ],
          "example": "This solution correctly extracts `query` and `page` from the `state.router.location.query` object, making them available as `searchTerm` and `currentPage` props to the component.",
          "tags": [
            "Redux",
            "URL Parameters",
            "mapStateToProps",
            "Coding Task"
          ],
          "prerequisites": [
            "Redux Connect",
            "JavaScript Objects"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_parameters_6",
          "topic": "React Router Props",
          "level": "medium",
          "type": "open",
          "question": "Outline the `this.props` object structure that a component receives when rendered by a React Router `Route`, focusing on the properties relevant to URL and route matching.",
          "answer": "When a React component is rendered by a React Router `Route`, it receives an object as `this.props` (for class components) or as arguments (for functional components using `useRouteMatch`, `useLocation`, `useParams`). The key properties relevant to URL and route matching are:\n\n1.  **`match`**: An object containing information about how the `<Route path>` matched the URL. It has the following properties:\n    *   `path`: (string) The path pattern used to match (e.g., `/users/:id`).\n    *   `url`: (string) The matched portion of the URL (e.g., `/users/123`). This is useful for building nested routes.\n    *   `isExact`: (boolean) `true` if the entire URL was matched exactly.\n    *   `params`: (object) An object containing key-value pairs of URL parameters. The keys correspond to the named segments in the `path` (e.g., if `path` is `/users/:id`, `params` would be `{ id: '123' }`).\n\n2.  **`location`**: An object representing the current URL. It has the following properties:\n    *   `pathname`: (string) The path of the URL (e.g., `/dashboard/settings`).\n    *   `search`: (string) The URL's query string (e.g., `?name=John&age=30`). This string includes the leading `?`.\n    *   `hash`: (string) The URL's hash fragment (e.g., `#section1`). This string includes the leading `#`.\n    *   `state`: (any) A value that was passed to `push` or `replace` via the `state` option.\n\n3.  **`history`**: An object containing methods to manipulate the browser's session history (e.g., `history.push()`, `history.replace()`, `history.goBack()`).\n\nThese props provide comprehensive access to the current route context, allowing components to read URL parameters, query strings, and programmatically navigate.",
          "options": [],
          "analysisPoints": [
            "Tests detailed knowledge of React Router's prop structure.",
            "Requires breakdown of `match`, `location`, and `history` objects.",
            "Emphasizes the utility of each sub-property."
          ],
          "keyConcepts": [
            "match prop",
            "location prop",
            "history prop",
            "URL Parameters",
            "Query Parameters",
            "RouteComponentProps"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of property descriptions",
            "Clarity of explanation for each sub-property",
            "Structural understanding of props object"
          ],
          "example": "",
          "tags": [
            "React Router",
            "Component Props",
            "Routing Fundamentals"
          ],
          "prerequisites": [
            "React Router Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_configure_redux_router_store",
          "title": "Configure Redux Store with `react-router-redux` and DevTools",
          "description": "\nImplement the `configureStore` function that sets up a Redux store, integrating `react-router-redux` middleware and enabling the Redux DevTools Extension for development environments.\n\n**Requirements:**\n1.  The function should accept `initialState` and a `history` object as arguments.\n2.  It must apply `routerMiddleware` using the provided `history` object.\n3.  It should use `rootReducer` (assume it's available and correctly imported).\n4.  It must conditionally enable the Redux DevTools Extension using `window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__` in non-production environments.\n5.  Return the configured Redux store.\n",
          "difficulty": "medium",
          "startingCode": "import { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer'; // Assume rootReducer is defined elsewhere\n\n/**\n * Configures and returns a Redux store with router middleware and DevTools integration.\n * @param initialState The initial state of the Redux store.\n * @param history The history object from 'history' library (e.g., createBrowserHistory()).\n * @returns The configured Redux store.\n */\nexport default function configureStore(initialState: any, history: any) {\n  // TODO: Implement the store configuration\n  // 1. Create router middleware\n  // 2. Define other middlewares (if any)\n  // 3. Create store enhancers array\n  // 4. Conditionally setup composeEnhancers for Redux DevTools\n  // 5. Create and return the store\n  \n  return null; // Replace with your store instance\n}\n",
          "solutionCode": "import { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer'; // Assume rootReducer is defined elsewhere\n\nexport default function configureStore(initialState: any, history: any) {\n  const routerMW = routerMiddleware(history);\n  \n  const middleWares = [\n    routerMW,\n    // You can add other middleware here, e.g., thunk or saga:\n    // thunk, \n    // sagaMiddleware\n  ];\n  \n  const enhancers = [\n    applyMiddleware(...middleWares)\n  ];\n  \n  // Conditionally add Redux DevTools Extension if available\n  // This ensures DevTools only loads in development and if the extension is present.\n  const composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n  \n  const store = createStore(\n    rootReducer,\n    initialState,\n    composeEnhancers(...enhancers),\n  );\n  \n  return store;\n}\n",
          "testCases": [
            "Test that `configureStore` returns a Redux store object.",
            "Test that `routerMiddleware` is applied to the store (can be inferred by store setup).",
            "Test that `composeEnhancers` is used correctly (e.g., inspect `store.dispatch` in a mock environment).",
            "Verify that DevTools integration logic is conditional based on `process.env.NODE_ENV`."
          ],
          "hints": [
            "Remember to spread the `middleWares` array when passing it to `applyMiddleware`.",
            "The `composeEnhancers` logic needs to check both `NODE_ENV` and the existence of the DevTools extension on the `window` object.",
            "Ensure `rootReducer` is correctly passed as the first argument to `createStore`."
          ],
          "tags": [
            "Redux",
            "Store Configuration",
            "Middleware",
            "DevTools",
            "React-Router-Redux",
            "TypeScript"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Redux Core Concepts",
            "JavaScript Modules",
            "Environment Variables"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Redux `createStore`",
            "Redux `applyMiddleware`",
            "Redux `compose`",
            "`react-router-redux` basics"
          ]
        },
        {
          "id": "task_route_info_navigation_component",
          "title": "Implement Route Info Display and Programmatic Navigation Component",
          "description": "\nCreate a React class component named `NavigationDashboard` that is connected to the Redux store. This component should:\n\n1.  Display the current URL's `pathname` from the Redux store.\n2.  Display any `query parameters` (e.g., `?lang=en&theme=dark`) from the Redux store.\n3.  Display any `path parameters` (e.g., `id` from `/users/:id`) from the Redux store. Assume a route like `/detail/:id` for testing path parameters.\n4.  Include a button that, when clicked, programmatically navigates to a new route (e.g., `/settings`) by dispatching a Redux action using the `push` action creator from `react-router-redux`.\n\n**Assumptions:**\n*   Your Redux store is configured with `react-router-redux`.\n*   `state.router.location` and `state.router.match` are available in your Redux state.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { connect } from 'react-redux';\nimport { push } from 'react-router-redux';\n\ninterface RootState {\n  router: {\n    location: {\n      pathname: string;\n      query: { [key: string]: string | string[] | undefined };\n    };\n    match: {\n      params: { [key: string]: string | undefined };\n    };\n  };\n}\n\ninterface NavigationDashboardProps {\n  currentPath: string;\n  queryParams: { [key: string]: string | string[] | undefined };\n  pathParams: { [key: string]: string | undefined };\n  navigateTo: (path: string) => void;\n}\n\nclass NavigationDashboard extends React.Component<NavigationDashboardProps> {\n  handleNavigateClick = () => {\n    // TODO: Dispatch action to navigate to '/settings'\n  };\n\n  render() {\n    const { currentPath, queryParams, pathParams } = this.props;\n    \n    return (\n      <div>\n        <h2>Navigation Dashboard</h2>\n        <p>Current Path: <strong>{currentPath}</strong></p>\n        <p>Query Params: <code>{JSON.stringify(queryParams)}</code></p>\n        <p>Path Params: <code>{JSON.stringify(pathParams)}</code></p>\n        <button onClick={this.handleNavigateClick}>Go to Settings</button>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state: RootState) => ({\n  // TODO: Map router state to props\n  currentPath: '', // Placeholder\n  queryParams: {}, // Placeholder\n  pathParams: {},  // Placeholder\n});\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  // TODO: Map navigation action to props\n  navigateTo: (path: string) => {}\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(NavigationDashboard);\n",
          "solutionCode": "import React from 'react';\nimport { connect } from 'react-redux';\nimport { push } from 'react-router-redux';\n\ninterface RootState {\n  router: {\n    location: {\n      pathname: string;\n      query: { [key: string]: string | string[] | undefined };\n    };\n    match: {\n      params: { [key: string]: string | undefined };\n    };\n  };\n}\n\ninterface NavigationDashboardProps {\n  currentPath: string;\n  queryParams: { [key: string]: string | string[] | undefined };\n  pathParams: { [key: string]: string | undefined };\n  navigateTo: (path: string) => void;\n}\n\nclass NavigationDashboard extends React.Component<NavigationDashboardProps> {\n  handleNavigateClick = () => {\n    this.props.navigateTo('/settings');\n  };\n\n  render() {\n    const { currentPath, queryParams, pathParams } = this.props;\n    \n    return (\n      <div>\n        <h2>Navigation Dashboard</h2>\n        <p>Current Path: <strong>{currentPath}</strong></p>\n        <p>Query Params: <code>{JSON.stringify(queryParams)}</code></p>\n        <p>Path Params: <code>{JSON.stringify(pathParams)}</code></p>\n        <button onClick={this.handleNavigateClick}>Go to Settings</button>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state: RootState) => ({\n  currentPath: state.router.location.pathname,\n  queryParams: state.router.location.query,\n  pathParams: state.router.match.params,\n});\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  navigateTo: (path: string) => dispatch(push(path))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(NavigationDashboard);\n",
          "testCases": [
            "Render the component on path `/`. Verify `Current Path` is `/`, and `Query/Path Params` are empty objects.",
            "Render the component on path `/products/123?color=red`. Verify `Current Path` is `/products/123`, `Query Params` contains `{ color: 'red' }`, and `Path Params` contains `{ id: '123' }` (assuming route `/products/:id`).",
            "Click the 'Go to Settings' button. Verify that a navigation action to `/settings` is dispatched and the URL changes (requires mocking history or running in a browser environment)."
          ],
          "hints": [
            "Ensure the `mapStateToProps` function correctly accesses the `router` slice of your Redux state and its `location` and `match` sub-properties.",
            "For `mapDispatchToProps`, import the `push` action creator from `react-router-redux`.",
            "Remember to call `this.props.navigateTo` with the target path in your button click handler."
          ],
          "tags": [
            "React",
            "Redux",
            "React-Router-Redux",
            "mapStateToProps",
            "mapDispatchToProps",
            "Programmatic Navigation",
            "URL Parameters",
            "TypeScript"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Components",
            "Redux Connect",
            "Basic React Router"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Redux state access",
            "Component-Redux connection",
            "React event handling"
          ]
        },
        {
          "id": "task_fetch_user_data_by_url_param",
          "title": "Fetch User Data Based on URL Parameter",
          "description": "\nImplement a React class component named `UserProfile` that displays user details. This component should:\n\n1.  Be rendered by a React Router `Route` with a path parameter for user ID (e.g., `/users/:id`).\n2.  Extract the `id` parameter from `this.props.match.params`.\n3.  Simulate fetching user data when the component mounts and whenever the `id` parameter in the URL changes.\n4.  Display the fetched `userId` and a loading indicator.\n\n**Requirements:**\n*   Use `componentDidMount` for initial data fetch.\n*   Use `componentDidUpdate` to re-fetch data if the `id` parameter changes.\n*   Simulate data fetching with a `setTimeout` to mimic an asynchronous API call.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { RouteComponentProps } from 'react-router-dom';\n\ninterface UserProfileParams {\n  id: string;\n}\n\ninterface UserProfileProps extends RouteComponentProps<UserProfileParams> {}\n\ninterface UserProfileState {\n  loading: boolean;\n  userId: string | null;\n}\n\nclass UserProfile extends React.Component<UserProfileProps, UserProfileState> {\n  state: UserProfileState = {\n    loading: false,\n    userId: null,\n  };\n\n  componentDidMount() {\n    // TODO: Fetch user data for the initial ID\n  }\n\n  componentDidUpdate(prevProps: UserProfileProps) {\n    // TODO: Check if ID changed and re-fetch data\n  }\n\n  fetchUserData = (id: string) => {\n    this.setState({ loading: true, userId: null });\n    setTimeout(() => {\n      // Simulate API call success\n      this.setState({ loading: false, userId: id });\n      console.log(`User data fetched for ID: ${id}`);\n    }, 1000);\n  };\n\n  render() {\n    const { loading, userId } = this.state;\n    const currentParamId = this.props.match.params.id;\n\n    return (\n      <div>\n        <h2>User Profile</h2>\n        <p>Current URL Param ID: <strong>{currentParamId}</strong></p>\n        {loading ? (\n          <p>Loading user data...</p>\n        ) : userId ? (\n          <p>Displaying data for User ID: {userId}</p>\n        ) : (\n          <p>No user data loaded.</p>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default UserProfile;\n",
          "solutionCode": "import React from 'react';\nimport { RouteComponentProps } from 'react-router-dom';\n\ninterface UserProfileParams {\n  id: string;\n}\n\ninterface UserProfileProps extends RouteComponentProps<UserProfileParams> {}\n\ninterface UserProfileState {\n  loading: boolean;\n  userId: string | null;\n}\n\nclass UserProfile extends React.Component<UserProfileProps, UserProfileState> {\n  state: UserProfileState = {\n    loading: false,\n    userId: null,\n  };\n\n  componentDidMount() {\n    const userId = this.props.match.params.id;\n    if (userId) {\n      this.fetchUserData(userId);\n    }\n  }\n\n  componentDidUpdate(prevProps: UserProfileProps) {\n    const currentUserId = this.props.match.params.id;\n    const prevUserId = prevProps.match.params.id;\n\n    // Re-fetch only if the ID has actually changed\n    if (currentUserId !== prevUserId) {\n      if (currentUserId) {\n        this.fetchUserData(currentUserId);\n      }\n    }\n  }\n\n  fetchUserData = (id: string) => {\n    this.setState({ loading: true, userId: null });\n    setTimeout(() => {\n      // Simulate API call success\n      this.setState({ loading: false, userId: id });\n      console.log(`User data fetched for ID: ${id}`);\n    }, 1000);\n  };\n\n  render() {\n    const { loading, userId } = this.state;\n    const currentParamId = this.props.match.params.id;\n\n    return (\n      <div>\n        <h2>User Profile</h2>\n        <p>Current URL Param ID: <strong>{currentParamId}</strong></p>\n        {loading ? (\n          <p>Loading user data...</p>\n        ) : userId ? (\n          <p>Displaying data for User ID: {userId}</p>\n        ) : (\n          <p>No user data loaded.</p>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default UserProfile;\n",
          "testCases": [
            "Render `UserProfile` for `/users/1`. Verify 'Loading...' appears, then 'Displaying data for User ID: 1'.",
            "Navigate from `/users/1` to `/users/2` without unmounting the component. Verify 'Loading...' appears again, then 'Displaying data for User ID: 2'.",
            "Render `UserProfile` for `/users/abc`. Verify it fetches data for 'abc'."
          ],
          "hints": [
            "The `id` parameter is available via `this.props.match.params.id`.",
            "In `componentDidUpdate`, compare `this.props.match.params.id` with `prevProps.match.params.id` to determine if a re-fetch is necessary.",
            "Ensure your `fetchUserData` function correctly updates the component's state for loading and data."
          ],
          "tags": [
            "React",
            "React Router",
            "URL Parameters",
            "Lifecycle Methods",
            "Data Fetching",
            "State Management",
            "TypeScript"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "React Class Components",
            "React Router Basics",
            "Asynchronous JavaScript"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component lifecycle",
            "Conditional rendering",
            "Asynchronous operations in React"
          ]
        }
      ]
    }
  }
]