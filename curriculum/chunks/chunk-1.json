[
  {
    "id": "54df5f6d-c31c-47d7-b3fb-3c5d22ebdb41",
    "startLine": 300,
    "endLine": 399,
    "processedDate": "2025-06-17T07:02:41.158Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_decorator_pattern",
          "title": "Decorator Pattern",
          "content": "The Decorator pattern is a structural design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. It provides a flexible alternative to subclassing for extending functionality.\n\n## Key Concepts\n-   **Wrapper**: The decorator 'wraps' the original object, adding new functionality before or after delegating to the original object's method.\n-   **Dynamic Extension**: Functionality can be added or removed at runtime, offering more flexibility than static inheritance.\n-   **Avoids Subclass Explosion**: Instead of creating many subclasses for every combination of features (e.g., `CoffeeWithMilk`, `CoffeeWithWhip`, `CoffeeWithMilkAndWhip`), decorators allow you to compose features dynamically.\n-   **Open/Closed Principle**: The original object's code remains unchanged (closed for modification), while new features can be added (open for extension) through decorators.\n\n## Structure\n-   **Component**: Defines the interface for objects that can be decorated.\n-   **Concrete Component**: The original object to which responsibilities can be attached.\n-   **Decorator**: Maintains a reference to a Component object and conforms to the Component's interface.\n-   **Concrete Decorator**: Adds responsibilities to the Component.\n\n## Use Cases\n-   Adding features to objects without altering their core structure.\n-   When inheritance is impractical due to a large number of independent extensions.\n-   To add or remove responsibilities from an object at runtime.\n\n## Advantages\n-   More flexible than static inheritance.\n-   Avoids feature-laden classes high up in the hierarchy.\n-   Maintains separation of concerns by keeping different responsibilities in separate decorator classes.\n\n## Disadvantages\n-   Can result in a large number of small objects if many decorators are used.\n-   Debugging can become more complex due to multiple layers of wrapping.\n-   The order of wrapping might matter, leading to potential issues if not managed carefully.",
          "examples": [
            {
              "id": "example_decorator_1",
              "title": "Coffee Decorator Example",
              "code": "class Coffee {\n  constructor() {\n    this.price = 5;\n    this.description = 'Basic Coffee';\n  }\n\n  cost() {\n    return this.price;\n  }\n\n  getDescription() {\n    return this.description;\n  }\n}\n\nfunction Milk(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 1; // Add milk cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Milk';\n  };\n  return coffee;\n}\n\nfunction Whip(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 2; // Add whip cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Whip';\n  };\n  return coffee;\n}\n\nfunction Vanilla(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 3; // Add vanilla cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Vanilla';\n  };\n  return coffee;\n}\n\nconst myCoffee = new Coffee();\nconsole.log(`Base: ${myCoffee.getDescription()} - $${myCoffee.cost()}`); // Base: Basic Coffee - $5\n\nconst milkCoffee = Milk(myCoffee);\nconsole.log(`Milk: ${milkCoffee.getDescription()} - $${milkCoffee.cost()}`); // Milk: Basic Coffee, Milk - $6\n\nconst whippedMilkCoffee = Whip(milkCoffee);\nconsole.log(`Whipped Milk: ${whippedMilkCoffee.getDescription()} - $${whippedMilkCoffee.cost()}`); // Whipped Milk: Basic Coffee, Milk, Whip - $8\n\nconst finalCoffee = Vanilla(whippedMilkCoffee);\nconsole.log(`Final: ${finalCoffee.getDescription()} - $${finalCoffee.cost()}`); // Final: Basic Coffee, Milk, Whip, Vanilla - $11",
              "explanation": "This example demonstrates how the `Coffee` object's `cost()` and `getDescription()` methods are dynamically extended by `Milk`, `Whip`, and `Vanilla` functions. Each decorator function captures the current state (cost and description) of the `coffee` object it receives and then redefines the `cost` and `getDescription` methods to include its own contribution. This allows for flexible combinations of additives without creating a complex inheritance hierarchy.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_decorator_1",
            "question_decorator_2",
            "question_decorator_3",
            "question_decorator_4",
            "question_decorator_5",
            "question_decorator_6"
          ],
          "relatedTasks": [
            "task_decorator_ui_component"
          ],
          "tags": [
            "design-patterns",
            "structural-patterns",
            "javascript",
            "object-oriented-programming",
            "flexibility"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "functions-as-first-class-citizens",
            "closures"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "extensible-architecture",
            "dynamic-feature-addition"
          ]
        },
        {
          "id": "theory_observer_pattern",
          "title": "Observer Pattern",
          "content": "The Observer pattern is a behavioral design pattern that defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It's often used for implementing distributed event handling systems.\n\n## Key Concepts\n-   **Subject (Publisher)**: The object that holds the state and notifies its observers when its state changes. It maintains a list of registered observers and provides methods to attach, detach, and notify them.\n-   **Observer (Subscriber)**: The object that wants to be notified of changes in the Subject's state. It provides an `update` method that the Subject calls when a change occurs.\n-   **Loose Coupling**: Subject and Observer objects are loosely coupled. They don't need to know the concrete classes of each other; they only interact through interfaces.\n-   **Broadcast Communication**: A single change in the Subject can trigger updates in multiple observers simultaneously.\n\n## Structure\n-   A `Subject` class with methods like `subscribe` (or `attach`), `unsubscribe` (or `detach`), and `notify`.\n-   An `Observer` interface or class with an `update` method.\n-   Concrete `Subject` and `Observer` implementations.\n\n## Use Cases\n-   Event handling systems in UI frameworks (e.g., DOM events).\n-   Stock market applications where many clients need to be notified of price changes.\n-   RSS feeds and news aggregators.\n-   Model-View-Controller (MVC) architectures, where the Model notifies Views of state changes.\n\n## Advantages\n-   Supports loose coupling between Subject and Observer objects.\n-   Allows dynamic addition and removal of observers.\n-   Facilitates broadcast communication.\n\n## Disadvantages\n-   Can lead to unexpected updates if not managed carefully, especially in complex systems.\n-   Debugging can be challenging if the notification chain is long or complex.\n-   Performance overhead if there are too many observers or frequent notifications.",
          "examples": [
            {
              "id": "example_observer_1",
              "title": "Basic Observer Pattern Implementation",
              "code": "// Observer Pattern\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    if (this.observers.includes(observer)) {\n      console.log('Observer already subscribed.');\n      return;\n    }\n    this.observers.push(observer);\n    console.log(`${observer.name} subscribed.`);\n  }\n  \n  unsubscribe(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n      console.log(`${observer.name} unsubscribed.`);\n    } else {\n      console.log('Observer not found.');\n    }\n  }\n  \n  notify(data) {\n    console.log(`\nSubject notifying all observers with data: ${data}`);\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}\n\nconst newsPublisher = new Subject();\n\nconst subscriber1 = new Observer('John');\nconst subscriber2 = new Observer('Alice');\nconst subscriber3 = new Observer('Bob');\n\nnewsPublisher.subscribe(subscriber1);\nnewsPublisher.subscribe(subscriber2);\n\nnewsPublisher.notify('Breaking News: New JavaScript Framework Released!');\n// Output:\n// John subscribed.\n// Alice subscribed.\n// Subject notifying all observers with data: Breaking News: New JavaScript Framework Released!\n// John received: Breaking News: New JavaScript Framework Released!\n// Alice received: Breaking News: New JavaScript Framework Released!\n\nnewsPublisher.subscribe(subscriber3);\nnewsPublisher.notify('Sports Update: Local Team Wins Championship!');\n// Output:\n// Bob subscribed.\n// Subject notifying all observers with data: Sports Update: Local Team Wins Championship!\n// John received: Sports Update: Local Team Wins Championship!\n// Alice received: Sports Update: Local Team Wins Championship!\n// Bob received: Sports Update: Local Team Wins Championship!\n\nnewsPublisher.unsubscribe(subscriber1);\nnewsPublisher.notify('Weather Alert: Heavy Rain Expected!');\n// Output:\n// John unsubscribed.\n// Subject notifying all observers with data: Weather Alert: Heavy Rain Expected!\n// Alice received: Weather Alert: Heavy Rain Expected!\n// Bob received: Weather Alert: Heavy Rain Expected!",
              "explanation": "This example showcases the core functionality of the Observer pattern. The `Subject` acts as a news publisher, maintaining a list of `Observer` (subscribers). Subscribers can register (`subscribe`) or deregister (`unsubscribe`) themselves. When the publisher has new information, it calls `notify`, which iterates through its list of observers, calling their `update` method with the new data. This demonstrates how subscribers are automatically informed of changes without the publisher needing to know their specific types.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_observer_1",
            "question_observer_2",
            "question_observer_3",
            "question_observer_4",
            "question_observer_5",
            "question_observer_6"
          ],
          "relatedTasks": [
            "task_event_bus"
          ],
          "tags": [
            "design-patterns",
            "behavioral-patterns",
            "javascript",
            "event-handling",
            "loose-coupling"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "event-driven-architecture"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "realtime-applications",
            "ui-frameworks",
            "state-management"
          ]
        },
        {
          "id": "theory_strategy_pattern",
          "title": "Strategy Pattern",
          "content": "The Strategy pattern is a behavioral design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, a client class receives run-time instructions as to which algorithm to use from a family of algorithms. The pattern encapsulates each algorithm into a separate class, making them interchangeable.\n\n## Key Concepts\n-   **Context**: The class that uses one of the strategies. It holds a reference to a strategy object and delegates the execution of the algorithm to it.\n-   **Strategy Interface**: An interface or abstract class that defines a common interface for all concrete strategies. The context uses this interface to call the algorithm defined by a concrete strategy.\n-   **Concrete Strategies**: Implement the `Strategy` interface and provide specific implementations of the algorithm.\n-   **Algorithm Interchangeability**: The ability to swap different algorithms (strategies) at runtime without changing the context's code.\n\n## Structure\n-   A `Context` class that contains a `strategy` property and a method to execute the strategy (e.g., `calculate`).\n-   A `Strategy` abstract class or interface defining the method signature (e.g., `calculate`).\n-   Multiple `ConcreteStrategy` classes implementing the `Strategy` interface.\n\n## Use Cases\n-   When you have multiple algorithms for a specific task and want to select one at runtime.\n-   When you want to avoid a large conditional (if-else or switch) statement that selects among variations of an algorithm.\n-   To keep algorithm-specific data separate from the context.\n-   When different clients need different variations of an algorithm.\n\n## Advantages\n-   Allows algorithms to be selected and changed at runtime.\n-   Eliminates large conditional statements.\n-   Promotes the Open/Closed Principle (open for extension, closed for modification).\n-   Improved code organization and reusability of algorithms.\n\n## Disadvantages\n-   Increases the number of objects in the application (one for each strategy).\n-   The client must be aware of the different strategies and choose the appropriate one.\n-   Can be overkill for very simple algorithms with few variations.",
          "examples": [
            {
              "id": "example_strategy_1",
              "title": "Shipping Cost Calculation Strategy",
              "code": "// Strategy Pattern\n\n// Base Strategy Interface/Class\nclass ShippingStrategy {\n  calculate(order) {\n    throw new Error(\"Abstract method 'calculate' must be implemented\");\n  }\n}\n\n// Concrete Strategies\nclass FedEx extends ShippingStrategy {\n  calculate(order) {\n    console.log(`Calculating FedEx cost for order weight ${order.weight}`);\n    return order.weight * 3;\n  }\n}\n\nclass UPS extends ShippingStrategy {\n  calculate(order) {\n    console.log(`Calculating UPS cost for order weight ${order.weight}`);\n    return order.weight * 4;\n  }\n}\n\nclass USPS extends ShippingStrategy {\n  calculate(order) {\n    console.log(`Calculating USPS cost for order weight ${order.weight}`);\n    return order.weight * 2.5;\n  }\n}\n\n// Context Class\nclass Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n  \n  setStrategy(strategy) {\n    if (!(strategy instanceof ShippingStrategy)) {\n      throw new Error(\"Strategy must be an instance of ShippingStrategy.\");\n    }\n    this.strategy = strategy;\n    console.log(`Shipping strategy set to ${strategy.constructor.name}`);\n  }\n  \n  calculate(order) {\n    if (!this.strategy) {\n      throw new Error(\"No shipping strategy set.\");\n    }\n    return this.strategy.calculate(order);\n  }\n}\n\n// Usage\nconst order1 = { weight: 10, destination: 'NYC' };\nconst order2 = { weight: 5, destination: 'LA' };\n\nconst shipper = new Shipping();\n\n// Calculate with FedEx\nshipper.setStrategy(new FedEx());\nconsole.log('Order 1 FedEx Cost:', shipper.calculate(order1)); // Output: 30\nconsole.log('Order 2 FedEx Cost:', shipper.calculate(order2)); // Output: 15\n\n// Calculate with UPS\nshipper.setStrategy(new UPS());\nconsole.log('Order 1 UPS Cost:', shipper.calculate(order1));   // Output: 40\nconsole.log('Order 2 UPS Cost:', shipper.calculate(order2));   // Output: 20\n\n// Calculate with USPS\nshipper.setStrategy(new USPS());\nconsole.log('Order 1 USPS Cost:', shipper.calculate(order1)); // Output: 25\nconsole.log('Order 2 USPS Cost:', shipper.calculate(order2)); // Output: 12.5",
              "explanation": "This example demonstrates how different shipping cost calculation algorithms (FedEx, UPS, USPS) can be encapsulated as separate strategies. The `Shipping` class (Context) holds a reference to a `ShippingStrategy` object and delegates the `calculate` method call to it. This allows the shipping method to be changed dynamically at runtime using `setStrategy`, eliminating the need for conditional logic within the `Shipping` class itself and making it easy to add new shipping methods without modifying existing code.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_strategy_1",
            "question_strategy_2",
            "question_strategy_3",
            "question_strategy_4",
            "question_strategy_5",
            "question_strategy_6"
          ],
          "relatedTasks": [
            "task_payment_gateway"
          ],
          "tags": [
            "design-patterns",
            "behavioral-patterns",
            "javascript",
            "algorithms",
            "flexibility"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "polymorphism"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "configurable-logic",
            "rules-engines"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_decorator_1",
          "topic": "Decorator Pattern Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the Decorator design pattern?",
          "answer": "To dynamically add responsibilities or behaviors to an individual object without altering its core structure or affecting other objects of the same class.",
          "options": [],
          "analysisPoints": [
            "Focus on 'dynamically' and 'individual object' as key aspects of the pattern."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Dynamic Behavior",
            "Object Extension"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental purpose"
          ],
          "example": "N/A",
          "tags": [
            "decorator-pattern",
            "definition",
            "design-patterns"
          ],
          "prerequisites": [
            "basic-oo-concepts"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_decorator_2",
          "topic": "Decorator vs. Inheritance",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is a key advantage of using the Decorator pattern over inheritance for adding features to an object?",
          "answer": "It avoids the explosion of subclasses when combining multiple features.",
          "options": [
            "It provides a simpler code structure with fewer classes.",
            "It allows features to be added or removed dynamically at runtime.",
            "It improves performance by reducing method call overhead.",
            "It avoids the explosion of subclasses when combining multiple features."
          ],
          "analysisPoints": [
            "The Decorator pattern is specifically designed to handle situations where multiple feature combinations would lead to a large and unwieldy class hierarchy if inheritance were used.",
            "While it does allow dynamic modification, the 'subclass explosion' is a more direct and common problem it solves compared to simple inheritance for feature addition.",
            "It typically adds, not reduces, classes (decorators are classes).",
            "It can sometimes add overhead due to method wrapping."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Inheritance",
            "Subclass Explosion",
            "Flexibility"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between design pattern advantages",
            "Understanding of common software design problems"
          ],
          "example": "The Decorator pattern allows you to compose behaviors like `Coffee -> Milk -> Whip -> Vanilla` without needing classes like `MilkCoffee`, `WhipCoffee`, `MilkWhipCoffee`, etc. This significantly reduces the number of classes compared to a purely inheritance-based approach for combining features.",
          "tags": [
            "decorator-pattern",
            "inheritance",
            "trade-offs",
            "mcq"
          ],
          "prerequisites": [
            "decorator-pattern-basics",
            "inheritance-basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_decorator_3",
          "topic": "Decorator Pattern Implementation",
          "level": "medium",
          "type": "code",
          "question": "Implement a `Logger` decorator that adds logging functionality to any function. The decorator should log the function's name and its arguments before execution, and its return value after execution. If the function throws an error, log the error message.\n\nUse the following `add` function as an example to decorate:\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n```",
          "answer": "```javascript\nfunction Logger(func) {\n  return function(...args) {\n    const funcName = func.name || 'anonymous';\n    console.log(`[LOG] Calling ${funcName} with args: ${JSON.stringify(args)}`);\n    try {\n      const result = func(...args);\n      console.log(`[LOG] ${funcName} returned: ${JSON.stringify(result)}`);\n      return result;\n    } catch (error) {\n      console.error(`[LOG] ${funcName} threw an error: ${error.message}`);\n      throw error; // Re-throw the error to maintain original behavior\n    }\n  };\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction subtract(a, b) {\n  if (b === 0) throw new Error('Cannot subtract by zero!');\n  return a - b;\n}\n\nconst loggedAdd = Logger(add);\nconsole.log(loggedAdd(5, 3)); // Logs call, args, return, then outputs 8\n\nconst loggedSubtract = Logger(subtract);\nconsole.log(loggedSubtract(10, 4)); // Logs call, args, return, then outputs 6\n\ntry {\n  loggedSubtract(7, 0); // Logs call, args, error, then throws error\n} catch (e) {\n  console.error('Caught an expected error:', e.message);\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the decorator function signature: takes a function and returns a new function.",
            "Properly uses rest parameters (`...args`) and spread syntax (`func(...args)`) to handle arbitrary arguments.",
            "Includes `try-catch` block for error handling and logging.",
            "Ensures the original function's return value or error is propagated.",
            "Uses `func.name` for better logging messages."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Higher-Order Functions",
            "Function Wrapping",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Ability to implement a functional decorator.",
            "Handling of function arguments and return values.",
            "Robustness with error scenarios."
          ],
          "example": "N/A",
          "tags": [
            "decorator-pattern",
            "javascript",
            "higher-order-functions",
            "coding-challenge",
            "medium"
          ],
          "prerequisites": [
            "javascript-functions",
            "closures"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_decorator_4",
          "topic": "Decorator Pattern Disadvantages",
          "level": "medium",
          "type": "open",
          "question": "What are some potential disadvantages or complexities that can arise when extensively using the Decorator pattern in a large-scale application?",
          "answer": "Extensive use of the Decorator pattern can lead to several disadvantages:\n1.  **Increased Complexity/Number of Objects**: Each decorator is typically a separate class or function, which can lead to a proliferation of small, similar objects. Managing many layers of wrapped objects can make the code harder to understand and navigate.\n2.  **Debugging Challenges**: When an object is wrapped by multiple decorators, tracing the flow of execution and debugging issues can become significantly more challenging. Calls might pass through several layers of wrappers before reaching the base object's method, making stack traces harder to interpret.\n3.  **Order Dependence**: The order in which decorators are applied can sometimes matter, especially if decorators modify the same aspect of the decorated object or if they have side effects that impact subsequent decorators. This can introduce subtle bugs if the application order is not strictly managed.\n4.  **Configuration Overhead**: Configuring and assembling complex decorated objects can involve many lines of code to chain decorators together, potentially making instantiation cumbersome.",
          "options": [],
          "analysisPoints": [
            "Discusses impact on code readability and maintainability.",
            "Highlights debugging difficulties in multi-layered structures.",
            "Mentions potential issues with decorator application order.",
            "Considers the overhead of object creation and configuration."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Trade-offs",
            "Complexity",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Critical thinking about design pattern implications",
            "Ability to articulate potential downsides beyond basic definition"
          ],
          "example": "N/A",
          "tags": [
            "decorator-pattern",
            "disadvantages",
            "software-design",
            "open-ended"
          ],
          "prerequisites": [
            "decorator-pattern-full-understanding"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_decorator_5",
          "topic": "Decorator Pattern vs. Adapter Pattern",
          "level": "hard",
          "type": "mcq",
          "question": "Both Decorator and Adapter patterns involve wrapping objects. What is the fundamental difference in their intent?",
          "answer": "Decorator enhances an object with new responsibilities, while Adapter converts an interface into another interface clients expect.",
          "options": [
            "Decorator is structural, Adapter is behavioral.",
            "Decorator changes an object's interface, Adapter keeps it the same.",
            "Decorator enhances an object with new responsibilities, while Adapter converts an interface into another interface clients expect.",
            "Decorator allows dynamic modification, Adapter is static."
          ],
          "analysisPoints": [
            "Decorator's intent is *enhancement* or *extension* of functionality, maintaining the original interface.",
            "Adapter's intent is *conversion* or *compatibility* between incompatible interfaces, often without adding new responsibilities beyond translation.",
            "Both are structural patterns.",
            "Decorator generally maintains the interface, sometimes extending it. Adapter explicitly changes or adapts an interface.",
            "Both can involve dynamic elements, but their core purpose differs."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Adapter Pattern",
            "Design Pattern Comparison",
            "Structural Patterns"
          ],
          "evaluationCriteria": [
            "Deep understanding of design pattern intents",
            "Ability to distinguish between similar patterns"
          ],
          "example": "A `LoggingStream` decorator adds logging to an existing `FileStream` while still behaving like a stream. An `OldSystemAdapter` makes an old, incompatible API work with a new system by translating calls, changing its interface to match the new system's expectations.",
          "tags": [
            "decorator-pattern",
            "adapter-pattern",
            "comparison",
            "design-patterns",
            "mcq"
          ],
          "prerequisites": [
            "decorator-pattern",
            "adapter-pattern-knowledge"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_decorator_6",
          "topic": "Real-world Decorator Use Cases",
          "level": "medium",
          "type": "open",
          "question": "Can you provide two real-world examples or scenarios (beyond the coffee example) where the Decorator pattern would be a suitable design choice in a frontend application?",
          "answer": "1.  **UI Component Enhancement**: Imagine a base `Button` component. You might want to add functionalities like:\n    *   `LoadingButton` (adds a loading spinner and disables it during async operations).\n    *   `TooltipButton` (adds a tooltip on hover).\n    *   `AnalyticsButton` (sends analytics data on click).\n    Instead of creating `LoadingTooltipAnalyticsButton` subclasses, you can start with a `Button` and dynamically wrap it with `LoadingDecorator`, `TooltipDecorator`, and `AnalyticsDecorator`.\n\n2.  **Form Input Validation/Formatting**: Consider a generic `InputField` component. You might need to apply various validations (e.g., `RequiredValidator`, `EmailValidator`, `MinLengthValidator`) or formatting (e.g., `CurrencyFormatter`, `PhoneNumberFormatter`). You could implement these as decorators, allowing you to compose them for specific input fields (e.g., `RequiredValidator(EmailValidator(InputField))`) without modifying the `InputField` itself or creating subclasses for every combination of validation rules.",
          "options": [],
          "analysisPoints": [
            "Identifies scenarios where incremental, dynamic feature addition is beneficial.",
            "Demonstrates understanding of how decorators prevent subclass explosion in practical contexts.",
            "Provides concrete, plausible frontend-specific examples."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Frontend Development",
            "UI Components",
            "Form Validation",
            "Real-World Examples"
          ],
          "evaluationCriteria": [
            "Ability to apply abstract pattern to practical problems",
            "Relevance to frontend domain"
          ],
          "example": "N/A",
          "tags": [
            "decorator-pattern",
            "frontend",
            "use-cases",
            "open-ended"
          ],
          "prerequisites": [
            "decorator-pattern-understanding"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_observer_1",
          "topic": "Observer Pattern Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary relationship established by the Observer design pattern?",
          "answer": "A one-to-many dependency, where one object (Subject) notifies many other objects (Observers) of its state changes.",
          "options": [],
          "analysisPoints": [
            "Emphasizes the 'one-to-many' relationship.",
            "Identifies Subject and Observer roles."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "One-to-Many",
            "Subject-Observer"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental relationship"
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "definition",
            "design-patterns"
          ],
          "prerequisites": [
            "basic-oo-concepts"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_observer_2",
          "topic": "Observer Pattern Benefits",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is a primary benefit of using the Observer pattern?",
          "answer": "It promotes loose coupling between the Subject and its Observers.",
          "options": [
            "It guarantees the order of notification for all observers.",
            "It eliminates the need for any form of communication between objects.",
            "It promotes tight coupling between the Subject and its Observers.",
            "It promotes loose coupling between the Subject and its Observers."
          ],
          "analysisPoints": [
            "Loose coupling is a hallmark of the Observer pattern, as the Subject only needs to know about the Observer interface, not concrete Observer types.",
            "The pattern does not guarantee notification order without additional mechanisms.",
            "It enables communication, not eliminates it.",
            "Tight coupling is the opposite of what the pattern aims for."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Loose Coupling",
            "Benefits",
            "Communication"
          ],
          "evaluationCriteria": [
            "Understanding of core benefits",
            "Distinguishing correct architectural principles"
          ],
          "example": "In the news publisher example, the publisher doesn't need to know if an observer is a 'MobileAppObserver' or a 'WebAppObserver', only that it implements an `update` method. This allows adding new observer types without changing the publisher.",
          "tags": [
            "observer-pattern",
            "benefits",
            "loose-coupling",
            "mcq"
          ],
          "prerequisites": [
            "observer-pattern-basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_observer_3",
          "topic": "Observer Pattern Implementation: Event Bus",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple `EventBus` class using the Observer pattern. It should have `subscribe(eventName, callback)`, `unsubscribe(eventName, callback)`, and `publish(eventName, data)` methods.\n\nDemonstrate its usage with at least two different event types and multiple subscribers for one event.",
          "answer": "```javascript\nclass EventBus {\n  constructor() {\n    this.subscribers = {}; // Stores eventName -> [callbacks]\n  }\n\n  subscribe(eventName, callback) {\n    if (typeof callback !== 'function') {\n      console.error('Callback must be a function.');\n      return;\n    }\n    if (!this.subscribers[eventName]) {\n      this.subscribers[eventName] = [];\n    }\n    if (!this.subscribers[eventName].includes(callback)) {\n      this.subscribers[eventName].push(callback);\n      console.log(`Subscribed to '${eventName}'`);\n    } else {\n      console.log(`Already subscribed to '${eventName}'.`);\n    }\n  }\n\n  unsubscribe(eventName, callback) {\n    if (!this.subscribers[eventName]) {\n      console.log(`No subscribers for '${eventName}'.`);\n      return;\n    }\n    this.subscribers[eventName] = this.subscribers[eventName].filter(cb => cb !== callback);\n    console.log(`Unsubscribed from '${eventName}'.`);\n  }\n\n  publish(eventName, data) {\n    if (!this.subscribers[eventName] || this.subscribers[eventName].length === 0) {\n      console.log(`No active subscribers for '${eventName}'.`);\n      return;\n    }\n    console.log(`\nPublishing event: '${eventName}' with data: ${JSON.stringify(data)}`);\n    this.subscribers[eventName].forEach(callback => {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error(`Error in subscriber for '${eventName}':`, error);\n      }\n    });\n  }\n}\n\n// --- Demonstration ---\nconst eventBus = new EventBus();\n\nconst handler1 = (data) => console.log(`Handler 1 for 'userLoggedIn': User ${data.username} logged in!`);\nconst handler2 = (data) => console.log(`Handler 2 for 'userLoggedIn': Welcome back, ${data.username}!`);\nconst handler3 = (data) => console.log(`Handler for 'productAdded': Item '${data.name}' added to cart.`);\n\n// Subscribe to 'userLoggedIn' event\neventBus.subscribe('userLoggedIn', handler1);\neventBus.subscribe('userLoggedIn', handler2);\n\n// Subscribe to 'productAdded' event\neventBus.subscribe('productAdded', handler3);\n\n// Publish 'userLoggedIn' event\neventBus.publish('userLoggedIn', { username: 'Alice', id: 101 });\n/* Expected Output:\nSubscribed to 'userLoggedIn'\nSubscribed to 'userLoggedIn'\nSubscribed to 'productAdded'\n\nPublishing event: 'userLoggedIn' with data: {\"username\":\"Alice\",\"id\":101}\nHandler 1 for 'userLoggedIn': User Alice logged in!\nHandler 2 for 'userLoggedIn': Welcome back, Alice!\n*/\n\n// Publish 'productAdded' event\neventBus.publish('productAdded', { name: 'Laptop', price: 1200 });\n/* Expected Output:\n\nPublishing event: 'productAdded' with data: {\"name\":\"Laptop\",\"price\":1200}\nHandler for 'productAdded': Item 'Laptop' added to cart.\n*/\n\n// Unsubscribe handler1 from 'userLoggedIn'\neventBus.unsubscribe('userLoggedIn', handler1);\n\n// Publish 'userLoggedIn' again\neventBus.publish('userLoggedIn', { username: 'Bob', id: 102 });\n/* Expected Output:\nUnsubscribed from 'userLoggedIn'.\n\nPublishing event: 'userLoggedIn' with data: {\"username\":\"Bob\",\"id\":102}\nHandler 2 for 'userLoggedIn': Welcome back, Bob!\n*/\n\n// Attempt to publish an event with no subscribers\neventBus.publish('nonExistentEvent', { message: 'hello' });\n// Expected Output: No active subscribers for 'nonExistentEvent'.\n",
          "options": [],
          "analysisPoints": [
            "Correctly uses a dictionary/map to store subscribers per event name.",
            "Implements `subscribe` to add callbacks to the correct event list.",
            "Implements `unsubscribe` to remove specific callbacks.",
            "Implements `publish` to iterate and call all relevant callbacks.",
            "Handles edge cases like no subscribers for an event or attempts to subscribe/unsubscribe non-functions/non-existent callbacks.",
            "Demonstrates robust error handling within `publish` to prevent one faulty subscriber from stopping others."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Event Bus",
            "Event Emitter",
            "Loose Coupling",
            "Callback Functions"
          ],
          "evaluationCriteria": [
            "Correct implementation of core Observer pattern methods.",
            "Handling of multiple event types and subscribers.",
            "Robustness and edge case consideration.",
            "Demonstrates understanding of event-driven architecture."
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "event-bus",
            "coding-challenge",
            "hard",
            "javascript"
          ],
          "prerequisites": [
            "object-oriented-programming",
            "closures",
            "array-methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_observer_4",
          "topic": "Observer Pattern vs. Pub/Sub Pattern",
          "level": "medium",
          "type": "open",
          "question": "Explain the key difference between the Observer pattern and the Publish/Subscribe (Pub/Sub) pattern. When might you choose one over the other?",
          "answer": "Both Observer and Publish/Subscribe patterns facilitate a form of one-to-many communication, but they differ in how the publisher and subscriber interact:\n\n**Observer Pattern (Direct Communication)**:\n*   **Relationship**: The Subject (publisher) maintains a direct reference to its Observers (subscribers). Observers register directly with the Subject.\n*   **Coupling**: While still loosely coupled (Subject knows only the Observer interface, not concrete types), there's a direct dependency: the Subject is aware of its observers.\n*   **Implementation**: Typically simpler to implement as it's a direct connection.\n*   **When to use**: Suitable when the Subject directly manages its observers and the relationship is straightforward, e.g., a GUI widget and its listeners, or a model notifying its views.\n\n**Publish/Subscribe (Indirect Communication via Broker)**:\n*   **Relationship**: Publishers and subscribers do not know each other directly. They communicate via an intermediary, often called a 'broker', 'message broker', 'event bus', or 'dispatcher'. Publishers publish messages to the broker, and subscribers subscribe to topics/events on the broker.\n*   **Coupling**: Achieves a higher degree of loose coupling (decoupled). Neither the publisher nor the subscriber needs to know about the other's existence; they only interact with the broker.\n*   **Implementation**: More complex due to the introduction of the intermediary, but offers greater flexibility and scalability.\n*   **When to use**: Ideal for distributed systems, complex event flows, or when you want to completely decouple publishers from subscribers, allowing publishers to be unaware of who or what is consuming their messages (e.g., microservices, large-scale frontend state management).\n\n**Choice**: Choose **Observer** for simpler, contained scenarios where direct subject-observer knowledge is acceptable. Choose **Pub/Sub** for more complex, decoupled, or distributed systems where greater separation and flexibility are required.",
          "options": [],
          "analysisPoints": [
            "Clearly defines the relationship and communication flow for both patterns.",
            "Highlights the coupling difference (direct vs. indirect/broker).",
            "Discusses implementation complexity.",
            "Provides clear use-case distinctions for when to choose each."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Publish/Subscribe Pattern",
            "Coupling",
            "Event Bus",
            "Design Pattern Comparison"
          ],
          "evaluationCriteria": [
            "Ability to articulate nuanced differences between related patterns",
            "Strategic understanding of pattern application"
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "pub-sub",
            "comparison",
            "design-patterns",
            "open-ended"
          ],
          "prerequisites": [
            "observer-pattern-understanding"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_observer_5",
          "topic": "Frontend Use Cases for Observer Pattern",
          "level": "medium",
          "type": "open",
          "question": "Describe two common scenarios in frontend development where the Observer pattern (or its variations like event listeners) is heavily utilized. Provide brief examples.",
          "answer": "1.  **DOM Events (Native Browser Implementation)**:\n    *   **Scenario**: Web browsers inherently use an Observer-like mechanism for handling user interactions with the DOM. Elements act as Subjects, and event listeners (functions) act as Observers.\n    *   **Example**: When a user clicks a button, the button element (`Subject`) notifies all registered click event handlers (`Observers`).\n    ```javascript\n    const myButton = document.getElementById('myButton');\n    myButton.addEventListener('click', (event) => {\n      console.log('Button clicked!', event);\n    }); // Observer subscribing to the button (Subject)\n    ```\n\n2.  **State Management Libraries (e.g., Redux, Vuex, MobX concepts)**:\n    *   **Scenario**: In many modern frontend frameworks, state management libraries often use an Observer or Pub/Sub pattern internally to notify components when the application's state changes. The 'store' or 'state' acts as the Subject, and components or reactive effects act as Observers.\n    *   **Example (conceptual for Redux/MobX)**: A component 'observes' a piece of state. When an action changes that state, the state management system (Subject) notifies the observing component, triggering a re-render.\n    ```javascript\n    // Conceptual example (simplified for illustration)\n    class Store {\n      constructor(initialState) {\n        this.state = initialState;\n        this.listeners = [];\n      }\n      subscribe(listener) { this.listeners.push(listener); }\n      dispatch(action) {\n        // ... update state based on action ...\n        this.listeners.forEach(listener => listener(this.state)); // Notify observers\n      }\n    }\n\n    const uiComponent = (state) => console.log('UI updated with new state:', state);\n    const store = new Store({ count: 0 });\n    store.subscribe(uiComponent); // UI component observes the store\n    store.dispatch({ type: 'INCREMENT' }); // Store changes, UI gets notified\n    ```",
          "options": [],
          "analysisPoints": [
            "Identifies native browser event handling as a prime example.",
            "Connects the pattern to state management in modern frameworks.",
            "Provides clear, concise code examples for each scenario.",
            "Shows practical application in frontend context."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Frontend Development",
            "DOM Events",
            "State Management",
            "Event Listeners"
          ],
          "evaluationCriteria": [
            "Ability to relate pattern to real-world frontend technology",
            "Knowledge of common frontend architectural patterns"
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "frontend",
            "use-cases",
            "open-ended"
          ],
          "prerequisites": [
            "observer-pattern-understanding",
            "javascript-dom",
            "frontend-framework-basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_observer_6",
          "topic": "Challenge: Multiple Subjects for an Observer",
          "level": "hard",
          "type": "code",
          "question": "Modify the `Observer` class from the theory example so that a single `Observer` instance can subscribe to and receive updates from multiple `Subject` instances. Demonstrate this by having one observer subscribe to two different subjects.\n\nOriginal `Observer`:\n```javascript\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}\n```\n\nOriginal `Subject`:\n```javascript\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  // ... other methods ...\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n```",
          "answer": "```javascript\nclass Subject {\n  constructor(name) {\n    this.name = name; // Added name for clarity in example\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    if (this.observers.includes(observer)) {\n      console.log(`Observer already subscribed to ${this.name}.`);\n      return;\n    }\n    this.observers.push(observer);\n    console.log(`${observer.name} subscribed to ${this.name}.`);\n  }\n  \n  unsubscribe(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n      console.log(`${observer.name} unsubscribed from ${this.name}.`);\n    }\n  }\n  \n  notify(data) {\n    console.log(`\n${this.name} notifying all observers with data: ${data}`);\n    // Pass subject name along with data for observer to identify source\n    this.observers.forEach(observer => observer.update(this.name, data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // Modified update method to accept subjectName\n  update(subjectName, data) {\n    console.log(`${this.name} received from ${subjectName}: ${data}`);\n  }\n}\n\n// --- Demonstration ---\nconst stockSubject = new Subject('Stock Exchange');\nconst weatherSubject = new Subject('Weather Service');\n\nconst personalDashboard = new Observer('My Dashboard');\n\n// My Dashboard subscribes to both subjects\nstockSubject.subscribe(personalDashboard);\nweatherSubject.subscribe(personalDashboard);\n\nstockSubject.notify('AAPL price increased to $175!');\nweatherSubject.notify('Temperature is 25C, sunny!');\n\nconst anotherObserver = new Observer('Alert System');\nstockSubject.subscribe(anotherObserver);\nstockSubject.notify('GOOGL price decreased to $150!');\n\n// Output:\n// My Dashboard subscribed to Stock Exchange.\n// My Dashboard subscribed to Weather Service.\n// \n// Stock Exchange notifying all observers with data: AAPL price increased to $175!\n// My Dashboard received from Stock Exchange: AAPL price increased to $175!\n// \n// Weather Service notifying all observers with data: Temperature is 25C, sunny!\n// My Dashboard received from Weather Service: Temperature is 25C, sunny!\n// Alert System subscribed to Stock Exchange.\n// \n// Stock Exchange notifying all observers with data: GOOGL price decreased to $150!\n// My Dashboard received from Stock Exchange: GOOGL price decreased to $150!\n// Alert System received from Stock Exchange: GOOGL price decreased to $150!\n```",
          "options": [],
          "analysisPoints": [
            "The key modification is in the `Observer.update` method signature and the `Subject.notify` call.",
            "The `Subject` now passes its `name` (or `this` reference) along with the data during notification, allowing the observer to identify the source.",
            "The `Observer` instance can indeed be registered with multiple subjects.",
            "Demonstrates subscription to multiple subjects by a single observer."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Multiple Subjects",
            "Contextual Information",
            "Advanced Observer"
          ],
          "evaluationCriteria": [
            "Ability to adapt pattern for complex scenarios.",
            "Correctly passing contextual information in notifications.",
            "Demonstration of multi-subject observation."
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "coding-challenge",
            "hard",
            "javascript"
          ],
          "prerequisites": [
            "observer-pattern-full-understanding"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_1",
          "topic": "Strategy Pattern Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main goal of the Strategy design pattern?",
          "answer": "To define a family of algorithms, encapsulate each one, and make them interchangeable at runtime.",
          "options": [],
          "analysisPoints": [
            "Highlights 'family of algorithms' and 'interchangeable at runtime' as core ideas."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Algorithms",
            "Runtime Selection"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental purpose"
          ],
          "example": "N/A",
          "tags": [
            "strategy-pattern",
            "definition",
            "design-patterns"
          ],
          "prerequisites": [
            "basic-oo-concepts"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_strategy_2",
          "topic": "Strategy Pattern vs. Large Conditional Statements",
          "level": "medium",
          "type": "mcq",
          "question": "A common problem the Strategy pattern helps to solve is the presence of large conditional statements (if-else if or switch-case). How does it achieve this?",
          "answer": "By encapsulating each algorithm in a separate class and allowing the context to delegate to the chosen strategy.",
          "options": [
            "By using higher-order functions to abstract away conditional logic.",
            "By consolidating all algorithms into a single, complex method.",
            "By encapsulating each algorithm in a separate class and allowing the context to delegate to the chosen strategy.",
            "By employing a factory pattern to create algorithms on demand."
          ],
          "analysisPoints": [
            "The essence of Strategy is delegating behavior to interchangeable objects, thus removing the need for `if/else if` inside the client.",
            "Higher-order functions can achieve similar goals but are not the direct mechanism of the Strategy pattern itself.",
            "Consolidating into one method would worsen the problem.",
            "Factory pattern is complementary but doesn't directly remove the conditionals within the algorithm selection, rather it might manage the creation of strategies."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Conditional Logic",
            "Code Smells",
            "Open/Closed Principle"
          ],
          "evaluationCriteria": [
            "Understanding of problem-solving approach",
            "Recognition of architectural improvements"
          ],
          "example": "Instead of `if (type === 'FedEx') { cost = weight * 3; } else if (type === 'UPS') { cost = weight * 4; }`, the `Shipping` context simply calls `this.strategy.calculate(order)`, with the specific `FedEx`, `UPS`, or `USPS` strategy being swapped in at runtime.",
          "tags": [
            "strategy-pattern",
            "problem-solving",
            "code-structure",
            "mcq"
          ],
          "prerequisites": [
            "strategy-pattern-basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strategy_3",
          "topic": "Strategy Pattern Implementation: Discount Calculator",
          "level": "medium",
          "type": "code",
          "question": "Implement a `DiscountStrategy` interface (or base class) and two concrete strategies: `PercentageDiscount` and `FixedAmountDiscount`. Then, create a `ShoppingCart` context class that can apply a selected discount strategy to calculate the final price.\n\n`PercentageDiscount` should apply a percentage (e.g., 10%) off the total.\n`FixedAmountDiscount` should apply a fixed amount (e.g., $5) off the total.",
          "answer": "```javascript\n// Strategy Interface/Base Class\nclass DiscountStrategy {\n  applyDiscount(total) {\n    throw new Error(\"Abstract method 'applyDiscount' must be implemented\");\n  }\n}\n\n// Concrete Strategy 1: Percentage Discount\nclass PercentageDiscount extends DiscountStrategy {\n  constructor(percentage) {\n    super();\n    this.percentage = percentage; // e.g., 0.10 for 10%\n  }\n\n  applyDiscount(total) {\n    if (total < 0) return 0; // Handle negative total if necessary\n    const discountAmount = total * this.percentage;\n    console.log(`Applying ${this.percentage * 100}% discount: -${discountAmount.toFixed(2)}`);\n    return total - discountAmount;\n  }\n}\n\n// Concrete Strategy 2: Fixed Amount Discount\nclass FixedAmountDiscount extends DiscountStrategy {\n  constructor(amount) {\n    super();\n    this.amount = amount; // e.g., 5 for $5\n  }\n\n  applyDiscount(total) {\n    if (total < 0) return 0; // Handle negative total if necessary\n    const finalTotal = total - this.amount;\n    console.log(`Applying fixed amount discount: -${this.amount.toFixed(2)}`);\n    return Math.max(0, finalTotal); // Ensure total doesn't go below zero\n  }\n}\n\n// Context Class: ShoppingCart\nclass ShoppingCart {\n  constructor() {\n    this.items = [];\n    this.discountStrategy = null; // No discount by default\n  }\n\n  addItem(name, price) {\n    this.items.push({ name, price });\n  }\n\n  calculateTotal() {\n    return this.items.reduce((sum, item) => sum + item.price, 0);\n  }\n\n  setDiscountStrategy(strategy) {\n    if (!(strategy instanceof DiscountStrategy)) {\n      throw new Error(\"Provided strategy must be an instance of DiscountStrategy.\");\n    }\n    this.discountStrategy = strategy;\n    console.log(`Discount strategy set to ${strategy.constructor.name}.`);\n  }\n\n  getFinalPrice() {\n    let total = this.calculateTotal();\n    if (this.discountStrategy) {\n      total = this.discountStrategy.applyDiscount(total);\n    }\n    return total;\n  }\n}\n\n// --- Demonstration ---\nconst cart = new ShoppingCart();\ncart.addItem('Laptop', 1000);\ncart.addItem('Mouse', 25);\n\nconsole.log(`Initial Total: $${cart.calculateTotal()}`); // Initial Total: $1025\n\n// Apply 10% percentage discount\nconst tenPercentOff = new PercentageDiscount(0.10);\ncart.setDiscountStrategy(tenPercentOff);\nconsole.log(`Price with 10% off: $${cart.getFinalPrice().toFixed(2)}`); // Price with 10% off: $922.50\n\n// Apply $50 fixed amount discount\nconst fiftyDollarsOff = new FixedAmountDiscount(50);\ncart.setDiscountStrategy(fiftyDollarsOff);\nconsole.log(`Price with $50 off: $${cart.getFinalPrice().toFixed(2)}`); // Price with $50 off: $975.00\n\n// Remove discount\ncart.setDiscountStrategy(null); // Or provide a NoDiscount strategy\nconsole.log(`Price without discount: $${cart.getFinalPrice().toFixed(2)}`); // Price without discount: $1025.00\n```",
          "options": [],
          "analysisPoints": [
            "Correctly defines a base `DiscountStrategy` and concrete implementations.",
            "Each concrete strategy implements the `applyDiscount` method with specific logic.",
            "The `ShoppingCart` acts as the context, holding a reference to the current strategy.",
            "The `getFinalPrice` method delegates the discount calculation to the active strategy.",
            "Handles edge cases like negative totals and ensuring final price doesn't go below zero for fixed discounts.",
            "Demonstrates setting and changing strategies dynamically."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Polymorphism",
            "Encapsulation",
            "Context",
            "Algorithms"
          ],
          "evaluationCriteria": [
            "Ability to structure classes according to the pattern.",
            "Correct implementation of different algorithms.",
            "Dynamic strategy selection.",
            "Handling of basic business logic and edge cases."
          ],
          "example": "N/A",
          "tags": [
            "strategy-pattern",
            "coding-challenge",
            "medium",
            "javascript"
          ],
          "prerequisites": [
            "object-oriented-programming",
            "classes"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strategy_4",
          "topic": "Strategy Pattern Disadvantages",
          "level": "medium",
          "type": "open",
          "question": "While the Strategy pattern offers great flexibility, what are some potential drawbacks or situations where it might not be the most appropriate choice?",
          "answer": "Potential drawbacks and inappropriate situations for the Strategy pattern include:\n1.  **Increased Number of Objects/Classes**: For every distinct algorithm, a new concrete strategy class must be created. If there are many algorithms, this can lead to a proliferation of small classes, making the project's structure more complex to navigate and manage.\n2.  **Client Awareness of Strategies**: The client (context) needs to know about all available concrete strategy classes to choose and set the appropriate one. This can expose implementation details to the client that might otherwise be hidden.\n3.  **Overkill for Simple Scenarios**: If an algorithm has very few, stable variations, or if the variations are very simple (e.g., a simple `if-else` or ternary operation), implementing the full Strategy pattern might introduce unnecessary overhead and complexity compared to a direct conditional statement.\n4.  **Runtime Overhead**: There's a slight runtime overhead due to polymorphism (virtual method calls) and object instantiation compared to a direct function call or conditional logic, though this is usually negligible for most applications.",
          "options": [],
          "analysisPoints": [
            "Discusses the impact on codebase size and navigation.",
            "Highlights the dependency of the client on strategy knowledge.",
            "Points out situations where simpler alternatives might be better.",
            "Mentions minor performance considerations."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Trade-offs",
            "Complexity",
            "Client Knowledge"
          ],
          "evaluationCriteria": [
            "Critical thinking about pattern applicability",
            "Understanding of design pattern overheads"
          ],
          "example": "N/A",
          "tags": [
            "strategy-pattern",
            "disadvantages",
            "software-design",
            "open-ended"
          ],
          "prerequisites": [
            "strategy-pattern-full-understanding"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_5",
          "topic": "Strategy Pattern vs. Template Method Pattern",
          "level": "hard",
          "type": "mcq",
          "question": "Both Strategy and Template Method patterns deal with algorithms. What is the main distinction regarding how they allow varying algorithm parts?",
          "answer": "Strategy varies the entire algorithm by delegating to different objects, while Template Method varies steps of an algorithm within an inheritance hierarchy.",
          "options": [
            "Strategy uses composition, Template Method uses inheritance.",
            "Strategy varies the entire algorithm by delegating to different objects, while Template Method varies steps of an algorithm within an inheritance hierarchy.",
            "Strategy is behavioral, Template Method is structural.",
            "Strategy works at compile-time, Template Method works at runtime."
          ],
          "analysisPoints": [
            "Strategy is about swapping *entire* algorithms at runtime via composition.",
            "Template Method defines an algorithm's skeleton in a base class, with specific steps implemented by subclasses (inheritance).",
            "Both are behavioral patterns.",
            "Both are typically runtime concepts, but Template Method's variability is defined at compile time through subclasses.",
            "The first option is true (composition vs. inheritance) but doesn't fully capture the essence of 'how they allow varying algorithm parts'."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Template Method Pattern",
            "Design Pattern Comparison",
            "Algorithms",
            "Composition vs Inheritance"
          ],
          "evaluationCriteria": [
            "Deep understanding of behavioral pattern mechanics",
            "Ability to articulate precise differences in algorithm variation approaches"
          ],
          "example": "In Strategy, `Shipping.calculate` delegates to `FedEx.calculate` or `UPS.calculate` (swapping the whole logic). In Template Method, a `BuildHouse` abstract class might have `buildWalls()`, `buildRoof()`, etc., with `ModernHouse` and `TraditionalHouse` subclasses overriding specific steps like `buildWalls` while the `buildHouse()` sequence remains fixed in the base class.",
          "tags": [
            "strategy-pattern",
            "template-method-pattern",
            "comparison",
            "design-patterns",
            "mcq"
          ],
          "prerequisites": [
            "strategy-pattern",
            "template-method-pattern-knowledge"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_6",
          "topic": "Frontend Use Cases for Strategy Pattern",
          "level": "medium",
          "type": "open",
          "question": "Provide two practical frontend scenarios (besides shipping costs) where the Strategy pattern would be a beneficial design choice.",
          "answer": "1.  **Form Validation**: Different input fields or forms might require different sets of validation rules (e.g., an email field needs email validation, a password field needs complexity validation, a registration form needs multiple validations). Instead of a large `if/else` block for each form or field, you can define validation strategies (e.g., `EmailValidationStrategy`, `PasswordValidationStrategy`, `RequiredValidationStrategy`) and apply them dynamically to a form context or input component.\n\n2.  **Payment Processing**: An e-commerce application needs to support various payment methods (e.g., Credit Card, PayPal, Crypto, Apple Pay). Each method involves a different set of API calls and logic. The Strategy pattern allows you to encapsulate each payment method as a concrete strategy (e.g., `CreditCardPaymentStrategy`, `PayPalPaymentStrategy`). The checkout process (context) can then simply use `paymentProcessor.execute(order)` regardless of the chosen method, swapping the strategy based on user selection.",
          "options": [],
          "analysisPoints": [
            "Identifies scenarios with multiple, interchangeable algorithms for a single operation.",
            "Demonstrates understanding of how Strategy pattern helps avoid conditional logic and promotes flexibility.",
            "Provides clear, relevant frontend examples."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Frontend Development",
            "Form Validation",
            "Payment Processing",
            "Real-World Examples"
          ],
          "evaluationCriteria": [
            "Ability to apply abstract pattern to practical problems",
            "Relevance to frontend domain"
          ],
          "example": "N/A",
          "tags": [
            "strategy-pattern",
            "frontend",
            "use-cases",
            "open-ended"
          ],
          "prerequisites": [
            "strategy-pattern-understanding"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_decorator_ui_component",
          "title": "Implement a Decorator Pattern for UI Button Enhancements",
          "description": "\nYour task is to implement a flexible `Button` component system using the Decorator pattern. You will start with a basic `Button` class and then create several decorator functions to add different visual and behavioral enhancements.\n\n**Requirements:**\n1.  Create a `Button` class with a `text` property and a `render()` method that returns its HTML string representation (e.g., `<button>Basic Button</button>`).\n2.  Implement a `DangerButton` decorator function that takes a button component and modifies its `render()` output to include a 'danger' class (e.g., `<button class=\"danger\">...`); it should also modify the text to add '(Danger)'.\n3.  Implement a `DisabledButton` decorator function that takes a button component and modifies its `render()` output to include the `disabled` attribute (e.g., `<button disabled>...`); it should also prepend '(Disabled)' to the text.\n4.  Implement a `IconButton` decorator function that takes a button component and an `iconClass` string, adding an `<i>` tag with the icon class before the button's text within the `render()` output (e.g., `<button><i class=\"fa fa-trash\"></i>Delete</button>`).\n5.  Demonstrate the usage by creating:\n    *   A basic button.\n    *   A danger button with an icon.\n    *   A disabled button.\n    *   A button with all three decorations applied.\n\n**Note**: Each decorator should return the modified button object, ensuring chainability. The original `Button` object should maintain its core functionality while being enhanced.",
          "difficulty": "medium",
          "startingCode": "class Button {\n  constructor(text) {\n    this.text = text;\n  }\n\n  render() {\n    return `<button>${this.text}</button>`;\n  }\n}\n\n// Implement decorator functions here: DangerButton, DisabledButton, IconButton\n\n// function DangerButton(button) { /* ... */ }\n// function DisabledButton(button) { /* ... */ }\n// function IconButton(button, iconClass) { /* ... */ }\n\n// Demonstrate usage below:\n// const basicButton = new Button('Submit');\n// console.log(basicButton.render());\n\n// const dangerIconDeleteButton = IconButton(DangerButton(new Button('Delete')), 'fa fa-trash');\n// console.log(dangerIconDeleteButton.render());\n",
          "solutionCode": "class Button {\n  constructor(text) {\n    this.text = text;\n    this.classes = [];\n    this.attributes = [];\n    this.icon = '';\n  }\n\n  render() {\n    const classAttr = this.classes.length > 0 ? ` class=\"${this.classes.join(' ')}\"` : '';\n    const otherAttrs = this.attributes.length > 0 ? ` ${this.attributes.join(' ')}` : '';\n    const iconHtml = this.icon ? `<i class=\"${this.icon}\"></i> ` : '';\n    return `<button${classAttr}${otherAttrs}>${iconHtml}${this.text}</button>`;\n  }\n}\n\nfunction DangerButton(button) {\n  const originalRender = button.render;\n  const originalText = button.text;\n\n  button.render = function() {\n    if (!this.classes.includes('danger')) {\n      this.classes.push('danger');\n    }\n    this.text = `(Danger) ${originalText}`;\n    return originalRender.call(this);\n  };\n  return button;\n}\n\nfunction DisabledButton(button) {\n  const originalRender = button.render;\n  const originalText = button.text;\n\n  button.render = function() {\n    if (!this.attributes.includes('disabled')) {\n      this.attributes.push('disabled');\n    }\n    this.text = `(Disabled) ${originalText}`;\n    return originalRender.call(this);\n  };\n  return button;\n}\n\nfunction IconButton(button, iconClass) {\n  const originalRender = button.render;\n\n  button.render = function() {\n    this.icon = iconClass;\n    return originalRender.call(this);\n  };\n  return button;\n}\n\n// --- Demonstration ---\nconsole.log('--- Basic Button ---');\nconst basicButton = new Button('Submit');\nconsole.log(basicButton.render());\n// Expected: <button>Submit</button>\n\nconsole.log('\\n--- Danger Button with Icon ---');\nconst dangerIconDeleteButton = IconButton(DangerButton(new Button('Delete')), 'fa fa-trash');\nconsole.log(dangerIconDeleteButton.render());\n// Expected: <button class=\"danger\"><i class=\"fa fa-trash\"></i> (Danger) Delete</button>\n\nconsole.log('\\n--- Disabled Button ---');\nconst disabledButton = DisabledButton(new Button('Click Me'));\nconsole.log(disabledButton.render());\n// Expected: <button disabled>(Disabled) Click Me</button>\n\nconsole.log('\\n--- Fully Decorated Button ---');\nconst fullFeaturedButton = IconButton(\n  DisabledButton(\n    DangerButton(new Button('Purchase'))\n  ),\n  'fa fa-shopping-cart'\n);\nconsole.log(fullFeaturedButton.render());\n// Expected: <button class=\"danger\" disabled><i class=\"fa fa-shopping-cart\"></i> (Disabled) (Danger) Purchase</button>\n\n// Test order independence (demonstrate that it can be applied in different orders)\nconsole.log('\\n--- Different Order ---');\nconst differentOrderButton = DangerButton(\n  IconButton(\n    DisabledButton(new Button('Upload')),\n    'fa fa-upload'\n  )\n);\nconsole.log(differentOrderButton.render());\n// Expected: <button disabled class=\"danger\"><i class=\"fa fa-upload\"></i> (Danger) (Disabled) Upload</button>\n",
          "testCases": [
            "A basic button should render correctly without any decorators.",
            "Applying `DangerButton` should add `class='danger'` and '(Danger)' to text.",
            "Applying `DisabledButton` should add `disabled` attribute and '(Disabled)' to text.",
            "Applying `IconButton` should add the icon `<i>` tag.",
            "Chaining multiple decorators (e.g., Danger -> Icon) should apply all effects cumulatively.",
            "Test for correct HTML structure and attribute/class/text inclusion for combined decorators.",
            "Verify that decorators modify the *returned* `button` instance, allowing for chainability.",
            "Test with different order of decorators to ensure robustness (e.g., `IconButton(DangerButton(button))` vs `DangerButton(IconButton(button))`)."
          ],
          "hints": [
            "Decorators should typically store the original method (e.g., `button.render`) and then wrap it with new logic, calling the original method to maintain the chain.",
            "Remember that the `this` context within the wrapped method should refer to the decorated object, so `originalRender.call(this)` can be useful.",
            "For adding classes or attributes, consider having properties in the base `Button` class (e.g., `this.classes = []`, `this.attributes = []`) that decorators can push into, and `render` then joins them.",
            "Ensure each decorator returns the `button` object it received to enable chaining."
          ],
          "tags": [
            "design-patterns",
            "decorator-pattern",
            "frontend",
            "ui-components",
            "javascript"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "object-oriented-programming",
            "closures",
            "html-templating"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "composition-over-inheritance",
            "higher-order-functions",
            "html-manipulation"
          ]
        },
        {
          "id": "task_event_bus",
          "title": "Build a Simple Frontend Event Bus",
          "description": "\nYour task is to implement a simple `EventBus` (or `EventEmitter`) for a frontend application based on the Observer pattern. This bus will allow different parts of your application to communicate without direct dependencies.\n\n**Requirements:**\n1.  Create an `EventBus` class with the following methods:\n    *   `on(eventName, listener)`: Registers a `listener` (callback function) for a specific `eventName`.\n    *   `off(eventName, listener)`: Unregisters a `listener` for a specific `eventName`.\n    *   `emit(eventName, data)`: Notifies all listeners registered for `eventName` with the provided `data`.\n2.  The `EventBus` should be able to manage multiple event names, and each event name can have multiple listeners.\n3.  Ensure that attempting to subscribe the same listener twice to the same event name doesn't result in duplicate notifications.\n4.  Handle cases where an event is emitted but has no subscribers, or where an attempt is made to unsubscribe a non-existent listener.\n5.  Demonstrate the `EventBus` functionality with a scenario simulating UI interactions (e.g., a 'userLoggedIn' event and a 'productAddedToCart' event) and multiple components (listeners) reacting to these events.\n",
          "difficulty": "medium",
          "startingCode": "class EventBus {\n  constructor() {\n    // Your internal storage for listeners, e.g., an object mapping event names to arrays of callbacks\n    this.listeners = {}; \n  }\n\n  /**\n   * Registers a listener for a specific event.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {function} listener - The callback function to execute when the event is emitted.\n   */\n  on(eventName, listener) {\n    // TODO: Implement subscription logic\n  }\n\n  /**\n   * Unregisters a listener from a specific event.\n   * @param {string} eventName - The name of the event to unsubscribe from.\n   * @param {function} listener - The callback function to remove.\n   */\n  off(eventName, listener) {\n    // TODO: Implement unsubscription logic\n  }\n\n  /**\n   * Emits an event, notifying all registered listeners.\n   * @param {string} eventName - The name of the event to emit.\n   * @param {*} data - The data to pass to the listeners.\n   */\n  emit(eventName, data) {\n    // TODO: Implement emission logic\n  }\n}\n\n// --- Demonstration Usage ---\n// const bus = new EventBus();\n\n// const userPanelUpdater = (userData) => console.log(`User Panel: User ${userData.username} is logged in.`);\n// const welcomeMessageDisplay = (userData) => console.log(`Welcome Message: Hello, ${userData.username}!`);\n\n// // Simulate UI components subscribing\n// bus.on('userLoggedIn', userPanelUpdater);\n// bus.on('userLoggedIn', welcomeMessageDisplay);\n\n// // Simulate a 'login' action\n// bus.emit('userLoggedIn', { username: 'Alice', id: 123 });\n\n// // More events, unsubscribing, etc.\n",
          "solutionCode": "class EventBus {\n  constructor() {\n    this.listeners = {};\n  }\n\n  on(eventName, listener) {\n    if (typeof listener !== 'function') {\n      console.warn(`EventBus: Listener for '${eventName}' must be a function.`);\n      return;\n    }\n    if (!this.listeners[eventName]) {\n      this.listeners[eventName] = [];\n    }\n    if (!this.listeners[eventName].includes(listener)) {\n      this.listeners[eventName].push(listener);\n      // console.log(`[EventBus] Subscribed to '${eventName}' with listener: ${listener.name || 'anonymous'}`);\n    } else {\n      // console.log(`[EventBus] Listener already subscribed to '${eventName}'.`);\n    }\n  }\n\n  off(eventName, listener) {\n    if (!this.listeners[eventName]) {\n      // console.log(`[EventBus] No subscribers for '${eventName}' to unsubscribe from.`);\n      return;\n    }\n    const initialLength = this.listeners[eventName].length;\n    this.listeners[eventName] = this.listeners[eventName].filter(cb => cb !== listener);\n    if (this.listeners[eventName].length < initialLength) {\n      // console.log(`[EventBus] Unsubscribed from '${eventName}' with listener: ${listener.name || 'anonymous'}`);\n    } else {\n      // console.log(`[EventBus] Listener not found for '${eventName}'.`);\n    }\n  }\n\n  emit(eventName, data) {\n    if (!this.listeners[eventName] || this.listeners[eventName].length === 0) {\n      // console.log(`[EventBus] No active subscribers for '${eventName}'.`);\n      return;\n    }\n    // console.log(`\\n[EventBus] Emitting event: '${eventName}' with data: ${JSON.stringify(data)}`);\n    // Create a copy of the listeners array to prevent issues if a listener unsubscribes itself during iteration\n    const listenersToNotify = [...this.listeners[eventName]];\n    listenersToNotify.forEach(listener => {\n      try {\n        listener(data);\n      } catch (error) {\n        console.error(`[EventBus Error] Listener for '${eventName}' failed:`, error);\n      }\n    });\n  }\n}\n\n// --- Demonstration Usage ---\nconst bus = new EventBus();\n\n// Define listeners (simulating UI components or modules)\nconst userPanelUpdater = (userData) => console.log(`User Panel: User ${userData.username} is logged in.`);\nconst welcomeMessageDisplay = (userData) => console.log(`Welcome Message: Hello, ${userData.username}!`);\nconst analyticsTracker = (eventData) => console.log(`Analytics: Tracked event '${eventData.eventName}' with data: ${JSON.stringify(eventData.data)}`);\nconst cartNotification = (productData) => console.log(`Cart: ${productData.name} added to cart!`);\n\n// Scenario 1: User Login Event\nconsole.log('--- Scenario 1: User Login ---');\nbus.on('userLoggedIn', userPanelUpdater);\nbus.on('userLoggedIn', welcomeMessageDisplay);\nbus.on('appEvent', analyticsTracker.bind(null, { eventName: 'userLoggedIn' })); // Example of binding context/extra data\n\nbus.emit('userLoggedIn', { username: 'Alice', id: 123 });\n// Expected output: User Panel: User Alice is logged in. \n//                  Welcome Message: Hello, Alice! \n//                  Analytics: Tracked event 'userLoggedIn' with data: {\"username\":\"Alice\",\"id\":123}\n\n// Scenario 2: Product Added to Cart Event\nconsole.log('\\n--- Scenario 2: Product Added to Cart ---');\nbus.on('productAddedToCart', cartNotification);\nbus.on('appEvent', analyticsTracker.bind(null, { eventName: 'productAddedToCart' }));\n\nbus.emit('productAddedToCart', { name: 'Laptop', price: 1200 });\n// Expected output: Cart: Laptop added to cart! \n//                  Analytics: Tracked event 'productAddedToCart' with data: {\"name\":\"Laptop\",\"price\":1200}\n\n// Scenario 3: Unsubscribe and Re-emit\nconsole.log('\\n--- Scenario 3: Unsubscribe ---');\nbus.off('userLoggedIn', userPanelUpdater);\nbus.emit('userLoggedIn', { username: 'Bob', id: 456 });\n// Expected output: Welcome Message: Hello, Bob! (userPanelUpdater should no longer be called)\n//                  Analytics: Tracked event 'userLoggedIn' with data: {\"username\":\"Bob\",\"id\":456}\n\n// Scenario 4: Emit event with no subscribers\nconsole.log('\\n--- Scenario 4: No Subscribers ---');\nbus.emit('nonExistentEvent', { message: 'This should not be logged by any listener.' });\n// Expected: No console output from a listener for this event.\n\n// Scenario 5: Attempt to subscribe duplicate listener (should not add)\nconsole.log('\\n--- Scenario 5: Duplicate Subscription ---');\nbus.on('productAddedToCart', cartNotification);\nbus.emit('productAddedToCart', { name: 'Keyboard', price: 75 }); // Should only log once for Keyboard\n// Expected: Cart: Keyboard added to cart!\n//           Analytics: Tracked event 'productAddedToCart' with data: {\"name\":\"Keyboard\",\"price\":75}\n\n// Scenario 6: Listener throwing an error\nconsole.log('\\n--- Scenario 6: Erroring Listener ---');\nconst erroringListener = () => { throw new Error('Something went wrong in listener!'); };\nbus.on('errorEvent', erroringListener);\nbus.on('errorEvent', (data) => console.log('Another listener for errorEvent received:', data));\nbus.emit('errorEvent', { type: 'test' });\n// Expected: Error in subscriber for 'errorEvent': ... \n//           Another listener for errorEvent received: { type: 'test' }\n",
          "testCases": [
            "A listener successfully subscribes and receives data for a single event.",
            "Multiple listeners receive data for the same event.",
            "A listener is correctly unsubscribed and no longer receives notifications.",
            "Emitting an event with no subscribers does not cause errors.",
            "Subscribing the same listener multiple times to the same event does not lead to duplicate calls.",
            "Attempting to unsubscribe a listener not currently subscribed does not cause errors.",
            "Test for `on` and `emit` with different `eventName` strings to ensure isolation between events.",
            "Verify error handling within `emit` so that one faulty listener doesn't prevent others from being called.",
            "Ensure the `data` passed to `emit` is correctly forwarded to listeners."
          ],
          "hints": [
            "Use an object (or `Map`) to store listeners, where keys are event names and values are arrays of callback functions.",
            "For `on`, check if the listener is already in the array before pushing it to avoid duplicates.",
            "For `off`, use `Array.prototype.filter()` to create a new array without the specified listener.",
            "For `emit`, iterate over the listeners for the given `eventName` and call each callback, passing the `data`.",
            "Consider using a `try-catch` block around listener calls in `emit` to prevent one listener's error from stopping the notification chain.",
            "When iterating over listeners in `emit`, make a shallow copy of the array (e.g., `[...this.listeners[eventName]]`) to prevent issues if a listener unsubscribes itself during the loop."
          ],
          "tags": [
            "design-patterns",
            "observer-pattern",
            "event-driven",
            "frontend",
            "javascript",
            "state-management"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "object-oriented-programming",
            "array-methods",
            "javascript-functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "pub-sub",
            "event-emitter",
            "custom-events",
            "loosely-coupled-systems"
          ]
        },
        {
          "id": "task_payment_gateway",
          "title": "Build a Flexible Payment Gateway with Strategy Pattern",
          "description": "\nYour task is to implement a `PaymentProcessor` that can handle various payment methods using the Strategy pattern. This allows you to easily add new payment methods without modifying the core `PaymentProcessor` logic.\n\n**Requirements:**\n1.  Define an abstract `PaymentStrategy` class (or interface) with a `pay(amount)` method.\n2.  Implement at least three concrete payment strategies:\n    *   `CreditCardPaymentStrategy`: Takes `cardNumber`, `expiryDate`, `cvv` in its constructor. Its `pay` method should simulate processing (e.g., log a message).\n    *   `PayPalPaymentStrategy`: Takes `email` in its constructor. Its `pay` method should simulate processing.\n    *   `CryptoPaymentStrategy`: Takes `walletAddress` and `currency` in its constructor. Its `pay` method should simulate processing.\n3.  Create a `PaymentProcessor` (Context) class that:\n    *   Has a `setStrategy(strategy)` method to set the active payment method.\n    *   Has a `processPayment(amount)` method that delegates the payment processing to the currently set strategy.\n4.  Include basic validation in `setStrategy` to ensure the provided object is a valid strategy.\n5.  Demonstrate the `PaymentProcessor`'s flexibility by processing payments of different amounts using different strategies.\n",
          "difficulty": "medium",
          "startingCode": "// Base Payment Strategy (abstract)\nclass PaymentStrategy {\n  pay(amount) {\n    throw new Error(\"Abstract method 'pay' must be implemented by concrete strategies.\");\n  }\n}\n\n// Implement Concrete Payment Strategies here:\n// class CreditCardPaymentStrategy extends PaymentStrategy { /* ... */ }\n// class PayPalPaymentStrategy extends PaymentStrategy { /* ... */ }\n// class CryptoPaymentStrategy extends PaymentStrategy { /* ... */ }\n\n// PaymentProcessor (Context) class\nclass PaymentProcessor {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    // TODO: Implement validation and set strategy\n  }\n\n  processPayment(amount) {\n    // TODO: Delegate to the current strategy\n  }\n}\n\n// --- Demonstration Usage ---\n// const processor = new PaymentProcessor();\n// processor.setStrategy(new CreditCardPaymentStrategy('1111...', '12/24', '123'));\n// processor.processPayment(100);\n\n// processor.setStrategy(new PayPalPaymentStrategy('user@example.com'));\n// processor.processPayment(50);\n",
          "solutionCode": "// Base Payment Strategy (abstract)\nclass PaymentStrategy {\n  pay(amount) {\n    throw new Error(\"Abstract method 'pay' must be implemented by concrete strategies.\");\n  }\n}\n\n// Concrete Payment Strategy 1: Credit Card\nclass CreditCardPaymentStrategy extends PaymentStrategy {\n  constructor(cardNumber, expiryDate, cvv) {\n    super();\n    this.cardNumber = cardNumber;\n    this.expiryDate = expiryDate;\n    this.cvv = cvv;\n  }\n\n  pay(amount) {\n    console.log(`Processing credit card payment of $${amount.toFixed(2)}.`);\n    console.log(`Card Number: **** **** **** ${this.cardNumber.slice(-4)}, Expiry: ${this.expiryDate}`);\n    // Simulate actual payment gateway interaction\n    if (amount > 0) {\n      console.log('Credit card payment successful.');\n      return true;\n    } else {\n      console.error('Credit card payment failed: Invalid amount.');\n      return false;\n    }\n  }\n}\n\n// Concrete Payment Strategy 2: PayPal\nclass PayPalPaymentStrategy extends PaymentStrategy {\n  constructor(email) {\n    super();\n    this.email = email;\n  }\n\n  pay(amount) {\n    console.log(`Processing PayPal payment of $${amount.toFixed(2)}.`);\n    console.log(`PayPal Account: ${this.email}`);\n    // Simulate actual payment gateway interaction\n    if (amount > 0) {\n      console.log('PayPal payment successful.');\n      return true;\n    } else {\n      console.error('PayPal payment failed: Invalid amount.');\n      return false;\n    }\n  }\n}\n\n// Concrete Payment Strategy 3: Crypto\nclass CryptoPaymentStrategy extends PaymentStrategy {\n  constructor(walletAddress, currency) {\n    super();\n    this.walletAddress = walletAddress;\n    this.currency = currency;\n  }\n\n  pay(amount) {\n    console.log(`Processing Crypto (${this.currency}) payment of $${amount.toFixed(2)}.`);\n    console.log(`Sending to Wallet Address: ${this.walletAddress}`);\n    // Simulate actual payment gateway interaction\n    if (amount > 0) {\n      console.log('Crypto payment successful. Please wait for confirmation.');\n      return true;\n    } else {\n      console.error('Crypto payment failed: Invalid amount.');\n      return false;\n    }\n  }\n}\n\n// PaymentProcessor (Context) class\nclass PaymentProcessor {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    if (strategy === null) {\n      this.strategy = null;\n      console.log('Payment strategy cleared.');\n      return;\n    }\n    if (!(strategy instanceof PaymentStrategy)) {\n      throw new Error(\"Invalid strategy: Must be an instance of PaymentStrategy.\");\n    }\n    this.strategy = strategy;\n    console.log(`Payment strategy set to: ${strategy.constructor.name}`);\n  }\n\n  processPayment(amount) {\n    if (!this.strategy) {\n      console.error(\"Error: No payment strategy set. Cannot process payment.\");\n      return false;\n    }\n    if (amount <= 0) {\n      console.error(\"Error: Payment amount must be positive.\");\n      return false;\n    }\n    return this.strategy.pay(amount);\n  }\n}\n\n// --- Demonstration Usage ---\nconst processor = new PaymentProcessor();\n\n// Scenario 1: Credit Card Payment\nconsole.log('--- Scenario 1: Credit Card Payment ---');\nconst creditCardStrategy = new CreditCardPaymentStrategy('4111222233334444', '12/25', '789');\nprocessor.setStrategy(creditCardStrategy);\nprocessor.processPayment(250.75);\n\n// Scenario 2: PayPal Payment\nconsole.log('\\n--- Scenario 2: PayPal Payment ---');\nconst paypalStrategy = new PayPalPaymentStrategy('customer@example.com');\nprocessor.setStrategy(paypalStrategy);\nprocessor.processPayment(50.00);\n\n// Scenario 3: Crypto Payment\nconsole.log('\\n--- Scenario 3: Crypto Payment ---');\nconst cryptoStrategy = new CryptoPaymentStrategy('0xAbCdEf1234567890', 'ETH');\nprocessor.setStrategy(cryptoStrategy);\nprocessor.processPayment(1500.20);\n\n// Scenario 4: Attempt to process without a strategy\nconsole.log('\\n--- Scenario 4: No Strategy ---');\nprocessor.setStrategy(null);\nprocessor.processPayment(30.00);\n\n// Scenario 5: Attempt to set invalid strategy\nconsole.log('\\n--- Scenario 5: Invalid Strategy ---');\ntry {\n  processor.setStrategy({});\n} catch (e) {\n  console.error(e.message);\n}\n\n// Scenario 6: Zero/Negative amount\nconsole.log('\\n--- Scenario 6: Invalid Amount ---');\nprocessor.setStrategy(creditCardStrategy);\nprocessor.processPayment(0);\nprocessor.processPayment(-10);\n",
          "testCases": [
            "A `CreditCardPaymentStrategy` processes payments correctly, logging its specific details.",
            "A `PayPalPaymentStrategy` processes payments correctly, logging its specific details.",
            "A `CryptoPaymentStrategy` processes payments correctly, logging its specific details.",
            "The `PaymentProcessor` successfully switches between different strategies.",
            "Calling `processPayment` without a strategy set outputs an error message and returns `false`.",
            "Calling `setStrategy` with an object not inheriting from `PaymentStrategy` throws an error.",
            "Processing a payment with a zero or negative amount is handled gracefully (e.g., prevents processing and logs an error).",
            "Each concrete strategy's constructor parameters are correctly stored and used in its `pay` method."
          ],
          "hints": [
            "The `PaymentStrategy` can be a base class that `throw`s an error in its `pay` method to enforce implementation by subclasses (simulating an abstract method).",
            "Use `instanceof` to validate the strategy type in the `setStrategy` method.",
            "The `PaymentProcessor`'s `processPayment` method should simply call `this.strategy.pay(amount)`.",
            "Consider adding basic logging within each `pay` method to show which strategy is active and its specific parameters."
          ],
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "frontend",
            "ecommerce",
            "javascript"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "object-oriented-programming",
            "polymorphism",
            "classes"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "factory-pattern",
            "dependency-injection",
            "configurable-logic"
          ]
        }
      ]
    }
  },
  {
    "id": "9eef224e-890b-49e4-8b7f-b86c4699f2b0",
    "startLine": 400,
    "endLine": 499,
    "processedDate": "2025-06-17T07:04:41.185Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_strategy_pattern",
          "title": "Strategy Design Pattern",
          "content": "The Strategy design pattern is a behavioral design pattern that enables selecting an algorithm's behavior at runtime. It defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows the client to choose the desired algorithm (strategy) without knowing the concrete implementation details of that algorithm, promoting flexibility and extensibility.\n\n## Core Components:\n\n1.  **Context**: Holds a reference to a Strategy object and delegates the request to the Strategy. It does not know the concrete strategy it's using.\n2.  **Strategy (Interface/Abstract Class)**: Declares an interface common to all supported algorithms. Context uses this interface to call the algorithm defined by a Concrete Strategy.\n3.  **Concrete Strategy**: Implements the Strategy interface, providing a specific algorithm.\n\n## Benefits:\n\n*   **Flexibility**: Algorithms can be changed at runtime.\n*   **Extensibility**: New strategies can be added easily without modifying the Context.\n*   **Maintainability**: Reduces conditional statements in the Context by encapsulating varying behaviors into separate classes.\n*   **Reusability**: Strategies can be reused across different contexts or parts of an application.",
          "examples": [
            {
              "id": "example_strategy_pattern_1",
              "title": "Shipping Cost Calculation with Strategy Pattern",
              "code": "class Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(order) {\n    return this.strategy.calculate(order);\n  }\n}\n\n// Strategy Interface (implicit in JS)\n// class ShippingStrategy {\n//   calculate(order) { throw new Error('Method must be implemented'); }\n// }\n\n// Concrete Strategies\nclass FedEx {\n  calculate(order) {\n    // Complex FedEx logic based on weight, distance, etc.\n    return 5 + (order.weight * 0.5);\n  }\n}\n\nclass UPS {\n  calculate(order) {\n    // Complex UPS logic\n    return 4 + (order.weight * 0.4);\n  }\n}\n\nclass USPS {\n  calculate(order) {\n    // Complex USPS logic\n    return 3 + (order.weight * 0.3);\n  }\n}\n\nconst shipping = new Shipping();\nconst order = { weight: 10 };\n\nshipping.setStrategy(new FedEx());\nconsole.log(`FedEx: $${shipping.calculate(order)}`);\n\nshipping.setStrategy(new UPS());\nconsole.log(`UPS: $${shipping.calculate(order)}`);\n\nshipping.setStrategy(new USPS());\nconsole.log(`USPS: $${shipping.calculate(order)}`);",
              "explanation": "This example demonstrates how different shipping carriers (FedEx, UPS, USPS) are implemented as concrete strategies. The `Shipping` class acts as the Context, setting and using the chosen strategy to calculate shipping costs. This allows easily switching between shipping methods without altering the `Shipping` class itself, showcasing the pattern's flexibility.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_strategy_pattern_1",
            "question_strategy_pattern_2",
            "question_strategy_pattern_3",
            "question_strategy_pattern_4",
            "question_strategy_pattern_5"
          ],
          "relatedTasks": [
            "task_strategy_pattern_calculator"
          ],
          "tags": [
            "design-patterns",
            "behavioral-patterns",
            "oop",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "polymorphism"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "scalable-architecture",
            "enterprise-application-design"
          ]
        },
        {
          "id": "theory_javascript_data_types",
          "title": "JavaScript Data Types: Primitive vs. Complex",
          "content": "JavaScript categorizes data into two main types: primitive and complex (or reference) types. Understanding this distinction is crucial for comprehending how values are stored, passed, and compared in JavaScript.\n\n## Primitive Types\n\nPrimitive values are immutable, meaning their value cannot be changed after creation. When a primitive value is assigned to a variable, the variable directly holds that value. When a primitive variable is copied, a new copy of the value is created.\n\n*   **String**: Represents sequences of characters (e.g., `'hello'`, `\"world\"`).\n*   **Number**: Represents both integer and floating-point numbers (e.g., `42`, `3.14`). Includes special values like `NaN` (Not-a-Number) and `Infinity`.\n*   **BigInt**: Represents whole numbers larger than `2^53 - 1`, which is the maximum safe integer for `Number` (e.g., `100n`).\n*   **Boolean**: Represents a logical entity with two values: `true` or `false`.\n*   **Undefined**: Represents a variable that has been declared but has not yet been assigned a value.\n*   **Symbol**: A unique and immutable data type often used as object property keys to avoid naming conflicts (e.g., `Symbol('id')`).\n*   **Null**: Represents the intentional absence of any object value. It's a primitive value.\n\n## Complex Type (Object)\n\nObjects are mutable and are stored by reference. This means that when an object is assigned to a variable, the variable holds a reference (memory address) to the object, not the object itself. When an object variable is copied, only the reference is copied, pointing to the same underlying object. Any changes made through one variable will be reflected in all other variables referencing the same object.\n\n*   **Object**: A collection of key-value pairs (e.g., `{ name: 'Alice', age: 30 }`).\n*   **Array**: A special type of object used for storing ordered collections of data (e.g., `[1, 2, 3]`).\n*   **Function**: A callable object that executes a block of code (e.g., `function() {}`).\n*   **Date**, **RegExp**, etc. are also objects.",
          "examples": [
            {
              "id": "example_primitive_vs_object_1",
              "title": "Primitive vs. Object Assignment",
              "code": "let firstObj = { name: 'Hello' };  \nlet secondObj = firstObj;  \nconsole.log(secondObj.name); // Output: Hello (both reference the same object)\n\nfirstObj = { name: 'Bye' };  // firstObj now references a *new* object\nconsole.log(secondObj.name); // Output: Hello (secondObj still references the *original* object)\n\n// Primitive example\nlet num1 = 10;\nlet num2 = num1;\nconsole.log(num2); // 10\nnum1 = 20;\nconsole.log(num2); // 10 (num2 holds a separate copy of the value)\n",
              "explanation": "This example illustrates the difference between how primitive values and object references are handled during assignment. When `firstObj` (an object) is assigned to `secondObj`, both variables point to the *same* object in memory. When `firstObj` is then reassigned to a *new* object, `secondObj` continues to point to the *original* object. In contrast, for primitive types like numbers, `num2` receives a distinct copy of `num1`'s value, so subsequent changes to `num1` do not affect `num2`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_data_types_1",
            "question_data_types_2",
            "question_data_types_3",
            "question_data_types_4",
            "question_data_types_5",
            "question_data_types_6"
          ],
          "relatedTasks": [
            "task_deep_clone_object"
          ],
          "tags": [
            "javascript-fundamentals",
            "data-types",
            "memory-management",
            "primitives",
            "objects"
          ],
          "technology": "JavaScript",
          "prerequisites": [],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "advanced-js-concepts",
            "framework-understanding"
          ]
        },
        {
          "id": "theory_javascript_type_conversion",
          "title": "JavaScript Type Conversion Methods",
          "content": "JavaScript is a loosely typed language, which means it often performs implicit type coercion. However, explicit type conversion methods are essential for precise control over data types.\n\n## `parseInt()` and `parseFloat()`\n\nThese functions are primarily used for parsing strings and extracting numerical values. They parse the string from left to right until they encounter a non-numeric character, then return the number accumulated up to that point.\n\n*   `parseInt(string, radix)`: Converts a string to an integer. The `radix` parameter (optional, defaults to 10) specifies the base of the number system (e.g., 2 for binary, 10 for decimal, 16 for hexadecimal). It truncates decimal parts.\n*   `parseFloat(string)`: Converts a string to a floating-point number. It can handle decimal points.\n\n## Other Conversion Methods\n\n*   **`Number(value)`**: A stricter conversion method compared to `parseInt()`/`parseFloat()`. It attempts to convert the entire `value` to a number. If the `value` cannot be entirely converted (e.g., contains non-numeric characters), it returns `NaN`.\n*   **`String(value)`** or `value.toString()`: Converts a value to its string representation. `String()` can be used for `null` and `undefined`, whereas `toString()` will throw an error for these.\n*   **`Boolean(value)`** or `!!value`: Converts a value to its boolean representation. Most values are 'truthy' (convert to `true`), while a specific set of values are 'falsy' (convert to `false`).\n\n### Falsy Values:\n*   `false`\n*   `0` (zero)\n*   `-0` (negative zero)\n*   `0n` (BigInt zero)\n*   `''` (empty string)\n*   `null`\n*   `undefined`\n*   `NaN`",
          "examples": [
            {
              "id": "example_type_conversion_1",
              "title": "parseInt() and parseFloat() Examples",
              "code": "// parseInt(string, radix) - converts string to integer\n// The radix parameter specifies the base of the number system (usually 10 for decimal)\nconsole.log(parseInt('42'));        // 42\nconsole.log(parseInt('42px'));      // 42 - extracts numbers until it encounters a non-numeric character\nconsole.log(parseInt('-50px'));     // -50 - handles negative numbers correctly\nconsole.log(parseInt('0xFF', 16));  // 255 - parses hexadecimal with radix 16\nconsole.log(parseInt('  123 '));    // 123 - ignores leading/trailing whitespace\nconsole.log(parseInt('abc'));       // NaN - string does not start with a number\n\n// parseFloat() - converts string to floating point number\nconsole.log(parseFloat('3.14'));          // 3.14\nconsole.log(parseFloat('3.14 meters'));   // 3.14\nconsole.log(parseFloat('  -2.5abc'));     // -2.5\nconsole.log(parseFloat('Infinity'));      // Infinity\nconsole.log(parseFloat('NaN'));           // NaN",
              "explanation": "These examples illustrate the behavior of `parseInt()` and `parseFloat()`. They stop parsing at the first non-numeric character (or invalid character for `parseInt` when a radix is specified). `parseInt` supports a `radix` for different number bases, while `parseFloat` handles decimal values.",
              "language": "javascript"
            },
            {
              "id": "example_type_conversion_2",
              "title": "Number(), String(), Boolean() Examples",
              "code": "// Number() - stricter than parseInt, doesn't allow trailing non-numeric characters\nconsole.log(Number('42'));    // 42\nconsole.log(Number('42px'));  // NaN - doesn't allow non-numeric characters\nconsole.log(Number('3.14'));  // 3.14\nconsole.log(Number(''));      // 0\nconsole.log(Number(true));    // 1\nconsole.log(Number(false));   // 0\nconsole.log(Number(null));    // 0\nconsole.log(Number(undefined));// NaN\n\n// String() - converts to string\nconsole.log(String(42));      // '42'\nconsole.log(String(true));    // 'true'\nconsole.log(String(null));    // 'null'\nconsole.log(String(undefined));// 'undefined'\nconsole.log(String({a:1}));   // '[object Object]'\n\n// Boolean() - converts to boolean\nconsole.log(Boolean(0));       // false (falsy)\nconsole.log(Boolean(1));       // true (truthy)\nconsole.log(Boolean(''));      // false (falsy)\nconsole.log(Boolean('hello')); // true (truthy)\nconsole.log(Boolean(null));    // false (falsy)\nconsole.log(Boolean(undefined));// false (falsy)\nconsole.log(Boolean(NaN));     // false (falsy)\nconsole.log(Boolean([]));      // true (truthy, empty array is an object)\nconsole.log(Boolean({}));      // true (truthy, empty object is an object)",
              "explanation": "`Number()` attempts a full conversion and returns `NaN` if the string cannot be entirely parsed as a number. `String()` converts various data types to their string representation. `Boolean()` (or `!!`) evaluates values as `true` (truthy) or `false` (falsy) based on JavaScript's rules for boolean coercion.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_type_conversion_1",
            "question_type_conversion_2",
            "question_type_conversion_3",
            "question_type_conversion_4",
            "question_type_conversion_5",
            "question_type_conversion_6"
          ],
          "relatedTasks": [
            "task_robust_string_to_number"
          ],
          "tags": [
            "type-coercion",
            "javascript-fundamentals",
            "conversion-methods",
            "operators"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript-data-types"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "debugging",
            "data-manipulation"
          ]
        },
        {
          "id": "theory_javascript_operators_and_pitfalls",
          "title": "JavaScript Operators and Common Pitfalls",
          "content": "Understanding JavaScript operators, especially increment/decrement and logical operators, is crucial. Additionally, being aware of common coding pitfalls, like incorrect loop increments, can save significant debugging time.\n\n## Increment/Decrement Operators: `i++` vs `++i`\n\nBoth `i++` (post-increment) and `++i` (pre-increment) add one to the value of `i`. The key difference lies in the value they *return*.\n\n*   **`i++` (Post-increment)**: Returns the *original* value of `i` *before* incrementing it. After the expression is evaluated, `i` is incremented.\n*   **`++i` (Pre-increment)**: Returns the *new* value of `i` *after* incrementing it. `i` is incremented first, and then its new value is used in the expression.\n\n## Loop Increment Pitfalls\n\nA common mistake in `for` loops is using `i + N` instead of `i += N` or `i = i + N`. The expression `i + N` calculates a new value but does not reassign it back to `i`, leading to an infinite loop if `i` is not modified elsewhere.\n\n*   **Incorrect**: `for (var i = 0; i < length; i + 3) {}` - `i` remains unchanged.\n*   **Correct**: `for (var i = 0; i < length; i += 3) {}` or `for (var i = 0; i < length; i = i + 3) {}` - `i` is updated in each iteration.",
          "examples": [
            {
              "id": "example_operators_1",
              "title": "i++ vs ++i Comparison",
              "code": "let i = 5;\nlet j = i++; // j gets 5, then i becomes 6\nconsole.log(`i: ${i}, j: ${j}`); // Output: i: 6, j: 5\n\nlet x = 5;\nlet y = ++x; // x becomes 6, then y gets 6\nconsole.log(`x: ${x}, y: ${y}`); // Output: x: 6, y: 6",
              "explanation": "This example clearly demonstrates the difference between post-increment (`i++`) and pre-increment (`++i`). `j` receives the value of `i` before `i` is incremented, while `y` receives the value of `x` after `x` has been incremented.",
              "language": "javascript"
            },
            {
              "id": "example_operators_2",
              "title": "Loop Increment Pitfall",
              "code": "// Incorrect: This will lead to an infinite loop if length > 0\n// The expression `i + 3` computes a value but doesn't assign it back to `i`.\n// for (var i = 0; i < myVar.length; i + 3) {\n//   console.log(i); // i never changes, loop condition remains true\n// }\n\n// Correct Way:\nlet myVar = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nfor (let i = 0; i < myVar.length; i += 3) {\n  console.log(`Processing index: ${i}`);\n}\n// Output: Processing index: 0, Processing index: 3, Processing index: 6, Processing index: 9",
              "explanation": "The first commented-out `for` loop is a common mistake. `i + 3` calculates a value but does not update `i` itself, causing an infinite loop. The corrected `for` loop uses `i += 3`, which correctly reassigns the incremented value back to `i`, allowing the loop to progress and terminate.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_operators_1",
            "question_operators_2",
            "question_operators_3",
            "question_operators_4"
          ],
          "relatedTasks": [
            "task_sparse_array_iteration"
          ],
          "tags": [
            "javascript-fundamentals",
            "operators",
            "loops",
            "common-pitfalls",
            "debugging"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript-data-types"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust-coding",
            "performance-optimization"
          ]
        },
        {
          "id": "theory_javascript_edge_cases_coercion",
          "title": "JavaScript Behavior and Edge Cases: Coercion & Operators",
          "content": "JavaScript's dynamic typing and operator overloading can lead to surprising behavior and edge cases, especially concerning type coercion and logical operations. Understanding these nuances is vital for writing robust and predictable code.\n\n## Object Property Access with Numeric/String Keys\n\nWhen accessing object properties, JavaScript often coerces numeric keys to strings. If you define a property with a numeric literal (e.g., `1`), it's stored as a string (`'1'`). Accessing it via `obj[1]` or `obj['1']` will yield the same result because the number `1` is implicitly converted to the string `'1'` for property lookup.\n\n## Mixed Type Arithmetic and Coercion\n\nJavaScript performs implicit type coercion when operators are applied to values of different types. The `+` operator behaves differently depending on operand types: if either operand is a string, it performs string concatenation; otherwise, it performs numeric addition. Other arithmetic operators (`-`, `*`, `/`, `%`) always attempt to convert operands to numbers. If conversion fails, the result is `NaN`.\n\n## Logical Operators and Short-Circuit Evaluation\n\nLogical operators (`&&` - AND, `||` - OR) in JavaScript exhibit 'short-circuit evaluation'. They evaluate from left to right and return the value of the *last evaluated operand*, not necessarily a boolean `true` or `false`.\n\n*   **`||` (OR)**: Returns the *first truthy* operand. If no operand is truthy, it returns the *last falsy* operand.\n*   **`&&` (AND)**: Returns the *first falsy* operand. If no operand is falsy, it returns the *last truthy* operand.\n\nTo explicitly get a boolean result from a logical expression, you can use the double-negation operator `!!` (e.g., `!!(a && b)`).\n\n## Array Operations with Type Coercion\n\nArrays are objects. When an array is used in an arithmetic context (especially with `+`), it's often implicitly converted to a string before the operation, which can lead to unexpected string concatenation instead of numeric addition. For example, `[1, 2] + [3, 4]` will concatenate the string representations of the arrays (`'1,2'` and `'3,4'`) resulting in `'1,23,4'`, not `[4,6]`.",
          "examples": [
            {
              "id": "example_edge_cases_1",
              "title": "Object Property Access and Mixed Arithmetic",
              "code": "// Object property access with different notations\nvar obj = {'1': 0, 1: 1, 0: 2};\nconsole.log(obj['1']); // 1 (numeric key '1' is equivalent to 1)\nconsole.log(obj[1]);   // 1 (same property, 1 is coerced to '1')\nconsole.log(obj[0]);   // 2\n\n// Mixed type arithmetic\nconsole.log(4 - \"5\" + 0xf - \"1e1\"); // Expected: 4\n// Breakdown:\n// 1. 4 - \"5\"    4 - 5 = -1 (string \"5\" converted to number in subtraction)\n// 2. -1 + 0xf   -1 + 15 = 14 (0xf is hexadecimal for 15)\n// 3. 14 - \"1e1\"  14 - 10 = 4 (\"1e1\" is scientific notation for 10)\n\nconsole.log(\"10\" + 2); // \"102\" (string concatenation)\nconsole.log(\"10\" - 2); // 8 (numeric subtraction)",
              "explanation": "This example shows that object property access with numeric keys often undergoes string coercion. It also demonstrates how JavaScript handles mixed-type arithmetic: `+` can concatenate strings, while other arithmetic operators force numeric conversion.",
              "language": "javascript"
            },
            {
              "id": "example_edge_cases_2",
              "title": "Logical Operators and Array Coercion",
              "code": "// Logical operators and short-circuit evaluation\nconsole.log(0 || \"\" || undefined || 23 || true || false); // 23 (first truthy value)\nconsole.log(\"hello\" && 0 && \"world\"); // 0 (first falsy value)\n\n// Logical operators with variables (return value, not just boolean)\nlet a = 5, b = 10;\nconsole.log(!!(a && b)); // true (converts result to boolean, `a && b` returns 10)\nconsole.log((a && b));   // 10 (returns last evaluated operand)\nconsole.log(a || b);    // 5 (returns first truthy operand)\n\n// Array operations with type coercion\nconsole.log([] + {});  // '[object Object]' (empty array becomes '', empty object becomes '[object Object]')\nconsole.log({} + []);  // '[object Object]' (object becomes '[object Object]', empty array becomes '')\nconsole.log([1, 2] + [3, 4]); // '1,23,4' (arrays are coerced to strings, then concatenated)\nconsole.log([1] - [1]); // 0 (arrays coerced to '1', then 1 - 1 = 0)\nconsole.log(null + undefined); // NaN (null coerces to 0, undefined to NaN)",
              "explanation": "This example highlights the short-circuiting behavior of `&&` and `||`, demonstrating they return the actual value of the last evaluated operand, not just `true` or `false`. It also illustrates how arrays are coerced to strings when used with the `+` operator, leading to string concatenation rather than numeric operations. Other arithmetic operators (`-`) attempt numeric conversion.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_edge_cases_1",
            "question_edge_cases_2",
            "question_edge_cases_3",
            "question_edge_cases_4",
            "question_edge_cases_5",
            "question_edge_cases_6"
          ],
          "relatedTasks": [
            "task_parse_mixed_data",
            "task_safe_boolean_coercion"
          ],
          "tags": [
            "type-coercion",
            "operators",
            "javascript-quirks",
            "edge-cases",
            "logical-operators",
            "debugging"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript-data-types",
            "javascript-type-conversion"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex-data-manipulation",
            "avoiding-bugs",
            "code-review"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_strategy_pattern_1",
          "topic": "Strategy Design Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary goal of the Strategy design pattern?",
          "answer": "To define a family of algorithms, encapsulate each one, and make them interchangeable.",
          "analysisPoints": [
            "Recall the definition of the Strategy pattern.",
            "Identify the core problem it solves (algorithm selection at runtime)."
          ],
          "keyConcepts": [
            "Strategy pattern",
            "Behavioral design patterns",
            "Algorithm encapsulation"
          ],
          "evaluationCriteria": [
            "Basic understanding of design pattern purpose."
          ],
          "example": "The Strategy pattern allows changing the behavior of a class at runtime without modifying its structure, for example, by switching between different tax calculation algorithms.",
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strategy_pattern_2",
          "topic": "Strategy Design Pattern",
          "level": "medium",
          "type": "mcq",
          "question": "Which component in the Strategy pattern is responsible for holding a reference to a Concrete Strategy object and delegating requests to it?",
          "answer": "Context",
          "options": [
            "Strategy",
            "Concrete Strategy",
            "Context",
            "Client"
          ],
          "analysisPoints": [
            "Understanding the roles of different components in the Strategy pattern.",
            "Identifying the 'Context' as the component that uses the strategy.",
            "Distinguishing Context from Strategy interface and Concrete Strategy implementations."
          ],
          "keyConcepts": [
            "Strategy pattern components",
            "Context",
            "Delegation"
          ],
          "evaluationCriteria": [
            "Correct identification of pattern roles."
          ],
          "example": "In the shipping example, the `Shipping` class is the Context, as it sets and uses the `FedEx`, `UPS`, or `USPS` strategy.",
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "mcq"
          ],
          "prerequisites": [
            "theory_strategy_pattern"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strategy_pattern_3",
          "topic": "Strategy Design Pattern",
          "level": "medium",
          "type": "open",
          "question": "Explain a real-world scenario where the Strategy pattern would be beneficial, other than the shipping example. Describe the Context, Strategy, and Concrete Strategy in your scenario.",
          "answer": "A good example is a payment processing system.\n\n*   **Context**: A `PaymentProcessor` class that needs to process a payment, but the specific payment method (credit card, PayPal, crypto) can vary.\n*   **Strategy**: An `IPaymentStrategy` interface (or abstract class in typed languages) with a method like `processPayment(amount)`.\n*   **Concrete Strategies**: `CreditCardPayment`, `PayPalPayment`, `CryptoPayment` classes, each implementing `IPaymentStrategy` with their specific payment processing logic.\n\nThis allows adding new payment methods without modifying the `PaymentProcessor` class, ensuring extensibility and adherence to the Open/Closed Principle.",
          "analysisPoints": [
            "Ability to apply the pattern to a new scenario.",
            "Correctly identifying all three core components (Context, Strategy, Concrete Strategy).",
            "Articulating the benefits of using the pattern in the given scenario."
          ],
          "keyConcepts": [
            "Strategy pattern application",
            "Context, Strategy, Concrete Strategy",
            "Real-world examples"
          ],
          "evaluationCriteria": [
            "Creative application of pattern.",
            "Clarity and accuracy of component identification.",
            "Demonstration of pattern's benefits."
          ],
          "example": null,
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "open-ended"
          ],
          "prerequisites": [
            "theory_strategy_pattern"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_pattern_4",
          "topic": "Strategy Design Pattern",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple 'SortStrategy' pattern. Create a `Sorter` class (Context) and different `SortStrategy` concrete implementations (e.g., `BubbleSort`, `QuickSort`). The `Sorter` should be able to sort an array using the currently set strategy. Provide basic implementations for the sorting algorithms.",
          "answer": "```javascript\n// Strategy Interface (implicit)\n// class SortStrategy { sort(data) { throw new Error('Method must be implemented'); } }\n\nclass BubbleSort {\n  sort(data) {\n    const arr = [...data]; // Avoid modifying original array\n    const n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n      for (let j = 0; j < n - i - 1; j++) {\n        if (arr[j] > arr[j + 1]) {\n          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        }\n      }\n    }\n    return arr;\n  }\n}\n\nclass QuickSort {\n  sort(data) {\n    const arr = [...data]; // Avoid modifying original array\n    if (arr.length <= 1) return arr;\n    \n    const pivot = arr[Math.floor(arr.length / 2)];\n    const left = [];\n    const right = [];\n    const equal = [];\n\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] < pivot) {\n        left.push(arr[i]);\n      } else if (arr[i] > pivot) {\n        right.push(arr[i]);\n      } else {\n        equal.push(arr[i]);\n      }\n    }\n    return [...this.sort(left), ...equal, ...this.sort(right)];\n  }\n}\n\n// Context\nclass Sorter {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeSort(data) {\n    if (!this.strategy) {\n      throw new Error(\"No sorting strategy set.\");\n    }\n    return this.strategy.sort(data);\n  }\n}\n\n// Usage\nconst dataToSort = [64, 25, 12, 22, 11];\nconst sorter = new Sorter();\n\nsorter.setStrategy(new BubbleSort());\nconsole.log(\"Bubble Sorted:\", sorter.executeSort(dataToSort)); // [11, 12, 22, 25, 64]\n\nsorter.setStrategy(new QuickSort());\nconsole.log(\"Quick Sorted:\", sorter.executeSort(dataToSort)); // [11, 12, 22, 25, 64]\n\nconst data2 = [3, 1, 4, 1, 5, 9, 2, 6];\nsorter.setStrategy(new BubbleSort());\nconsole.log(\"Bubble Sorted 2:\", sorter.executeSort(data2)); // [1, 1, 2, 3, 4, 5, 6, 9]\n\nsorter.setStrategy(new QuickSort());\nconsole.log(\"Quick Sorted 2:\", sorter.executeSort(data2)); // [1, 1, 2, 3, 4, 5, 6, 9]\n```",
          "analysisPoints": [
            "Correctly implements the Context (Sorter) to delegate to a Strategy.",
            "Defines clear Strategy interface (implicit in JS) and concrete implementations.",
            "Demonstrates interchangeable algorithms.",
            "Handles edge cases like empty data or no strategy set."
          ],
          "keyConcepts": [
            "Strategy pattern",
            "Polymorphism",
            "Algorithm encapsulation",
            "Bubble Sort",
            "Quick Sort"
          ],
          "evaluationCriteria": [
            "Adherence to Strategy pattern principles.",
            "Correctness of sorting algorithms.",
            "Code clarity and extensibility."
          ],
          "example": null,
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "algorithms",
            "sorting",
            "code-challenge"
          ],
          "prerequisites": [
            "theory_strategy_pattern",
            "basic-sorting-algorithms"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_pattern_5",
          "topic": "Strategy Design Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is one key benefit of using the Strategy pattern in terms of code maintainability and extensibility?",
          "answer": "It reduces conditional statements (e.g., `if-else` or `switch`) in the Context, making it easier to add new algorithms without modifying existing code (Open/Closed Principle).",
          "analysisPoints": [
            "Identify benefits related to maintainability.",
            "Connect to the Open/Closed Principle."
          ],
          "keyConcepts": [
            "Strategy pattern benefits",
            "Open/Closed Principle",
            "Maintainability",
            "Extensibility"
          ],
          "evaluationCriteria": [
            "Recall of pattern advantages."
          ],
          "example": null,
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_data_types_1",
          "topic": "JavaScript Data Types",
          "level": "easy",
          "type": "flashcard",
          "question": "Name all primitive data types in JavaScript.",
          "answer": "String, Number, BigInt, Boolean, Undefined, Symbol, Null.",
          "analysisPoints": [
            "Recall the list of primitive data types.",
            "Distinguish them from complex types."
          ],
          "keyConcepts": [
            "Primitive data types",
            "JavaScript fundamentals"
          ],
          "evaluationCriteria": [
            "Basic knowledge of JS data types."
          ],
          "example": null,
          "tags": [
            "data-types",
            "primitives",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_data_types_2",
          "topic": "JavaScript Data Types",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code:\n```javascript\nlet obj1 = { value: 10 };\nlet obj2 = obj1;\nobj1.value = 20;\n\nlet num1 = 10;\nlet num2 = num1;\nnum1 = 20;\n\nconsole.log(obj2.value);\nconsole.log(num2);\n```\nWhat will be the output of `console.log(obj2.value)` and `console.log(num2)` respectively?",
          "answer": "20, 10",
          "options": [
            "10, 10",
            "20, 20",
            "10, 20",
            "20, 10"
          ],
          "analysisPoints": [
            "Understanding pass-by-reference for objects.",
            "Understanding pass-by-value for primitives.",
            "Correctly tracing the value changes for both `obj2` and `num2`."
          ],
          "keyConcepts": [
            "Primitive vs. Object types",
            "Pass by value",
            "Pass by reference",
            "Mutable vs Immutable"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between primitive and object assignment/copying.",
            "Correctly predict output based on data type behavior."
          ],
          "example": "Objects are assigned by reference, so `obj2` points to the same memory location as `obj1`. Changing `obj1.value` changes the shared object. Primitives are assigned by value, so `num2` gets a copy of `num1`'s initial value; subsequent changes to `num1` don't affect `num2`.",
          "tags": [
            "data-types",
            "primitives",
            "objects",
            "mcq",
            "memory-management"
          ],
          "prerequisites": [
            "theory_javascript_data_types"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_data_types_3",
          "topic": "JavaScript Data Types",
          "level": "medium",
          "type": "open",
          "question": "Discuss the implications of JavaScript's primitive types being immutable and objects being mutable when designing data structures or APIs. Provide a simple example for each.",
          "answer": "The immutability of primitives means their value cannot change. If you reassign a variable holding a primitive, you're actually creating a new value, not modifying the old one. This simplifies reasoning about code, as a primitive value passed to a function won't be unexpectedly altered by that function.\n\n*   **Example (Primitive Immutability):**\n    ```javascript\n    let message = 'hello';\n    function appendWorld(str) {\n      str = str + ' world'; // Creates a new string 'hello world', doesn't change original 'message'\n      return str;\n    }\n    let newMessage = appendWorld(message);\n    console.log(message);     // 'hello' (original unchanged)\n    console.log(newMessage);  // 'hello world'\n    ```\n\nObjects, being mutable, can be changed after creation. Variables holding objects store references. This allows functions to modify the original object, which can be useful for shared state but also leads to potential side effects if not managed carefully.\n\n*   **Example (Object Mutability):**\n    ```javascript\n    let user = { name: 'Alice', age: 30 };\n    function increaseAge(person) {\n      person.age += 1; // Modifies the original 'user' object\n    }\n    increaseAge(user);\n    console.log(user.age); // 31 (original object mutated)\n\n    // Contrast with copying\n    function increaseAgeImmutable(person) {\n        return { ...person, age: person.age + 1 }; // Creates new object\n    }\n    let newUser = increaseAgeImmutable(user);\n    console.log(user.age); // 31 (still the original)\n    console.log(newUser.age); // 32 (new object)\n    ```\n\n**Implications for APIs:**\n*   **Primitives:** Safer to pass around, as they prevent unintended side effects. Functions can safely assume the input primitive won't change.\n*   **Objects:** If an API function takes an object, developers must be aware if the function mutates the object or returns a new one. Clear documentation is essential. For complex state management (e.g., Redux), immutability is often preferred to simplify change detection and debugging, leading to practices like cloning objects (`{...obj}`) before modification.",
          "analysisPoints": [
            "Clear explanation of primitive immutability and object mutability.",
            "Accurate and distinct code examples for both concepts.",
            "Discussion of practical implications for API design and common programming patterns."
          ],
          "keyConcepts": [
            "Immutability",
            "Mutability",
            "Primitive data types",
            "Object data types",
            "Pass by value vs reference",
            "Side effects",
            "API design"
          ],
          "evaluationCriteria": [
            "Depth of understanding of immutability/mutability.",
            "Quality and relevance of code examples.",
            "Insight into practical programming implications."
          ],
          "example": null,
          "tags": [
            "data-types",
            "memory-management",
            "api-design",
            "open-ended"
          ],
          "prerequisites": [
            "theory_javascript_data_types"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_data_types_4",
          "topic": "JavaScript Data Types",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following JavaScript values is considered a primitive type?",
          "answer": "Symbol",
          "options": [
            "Array",
            "Function",
            "Object",
            "Symbol"
          ],
          "analysisPoints": [
            "Recall the definition of primitive types.",
            "Distinguish between primitive and complex types."
          ],
          "keyConcepts": [
            "Primitive types",
            "Complex types",
            "JavaScript data types"
          ],
          "evaluationCriteria": [
            "Correctly identifies primitive types."
          ],
          "example": "`Array`, `Function`, and `Object` are all examples of complex (object) data types in JavaScript, while `Symbol` is a primitive introduced in ES6 for unique identifiers.",
          "tags": [
            "data-types",
            "primitives",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_data_types"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_data_types_5",
          "topic": "JavaScript Data Types",
          "level": "medium",
          "type": "flashcard",
          "question": "Is `null` an object in JavaScript? Explain why or why not, referring to its `typeof` result.",
          "answer": "No, `null` is a primitive value. While `typeof null` returns `'object'`, this is a historical bug in JavaScript that has persisted for compatibility reasons. Conceptually, `null` represents the intentional absence of any object value, making it a primitive.",
          "analysisPoints": [
            "Address the common misconception about `typeof null`.",
            "Explain the historical reason for `typeof null === 'object'`.",
            "Reinforce that `null` is conceptually a primitive."
          ],
          "keyConcepts": [
            "Null",
            "Primitive data types",
            "typeof operator",
            "JavaScript quirks"
          ],
          "evaluationCriteria": [
            "Accurate explanation of `null`'s type.",
            "Awareness of `typeof` bug."
          ],
          "example": null,
          "tags": [
            "data-types",
            "primitives",
            "quirks",
            "flashcard"
          ],
          "prerequisites": [
            "theory_javascript_data_types"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_data_types_6",
          "topic": "JavaScript Data Types",
          "level": "hard",
          "type": "code",
          "question": "Write a JavaScript function `deepCompare(a, b)` that returns `true` if two values `a` and `b` are deeply equal, and `false` otherwise. The function should handle primitive types and objects/arrays recursively. Consider edge cases like `null`, `undefined`, and circular references (optional, for extra credit).",
          "answer": "```javascript\nfunction deepCompare(a, b, seen = new WeakMap()) {\n  // 1. Primitive comparison\n  if (a === b) {\n    return true;\n  }\n\n  // 2. Handle null, undefined, NaN, and non-objects\n  if (a == null || b == null || typeof a !== 'object' && typeof b !== 'object') {\n    // Special case for NaN: NaN === NaN is false, but NaN should be deepCompare equal to NaN\n    if (Number.isNaN(a) && Number.isNaN(b)) {\n        return true;\n    }\n    return false;\n  }\n\n  // 3. Handle different constructors or types (e.g., Array vs Object)\n  if (a.constructor !== b.constructor) {\n    return false;\n  }\n\n  // 4. Handle circular references\n  if (seen.has(a) && seen.get(a) === b) {\n    return true; // Already compared this pair in the current path and found equal\n  }\n  if (seen.has(a) || seen.has(b)) {\n    // If one is seen but the other is not the same partner, it's a different path\n    // Or if different partners, then not equal\n    // For simplicity, we can return false for now or handle more robustly.\n    // A proper solution would require tracking which pairs have been compared.\n    // For interview context, mentioning it is usually sufficient.\n  }\n  seen.set(a, b);\n  seen.set(b, a); // Store both directions for robustness\n\n  // 5. Array comparison\n  if (Array.isArray(a)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (!deepCompare(a[i], b[i], seen)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // 6. Object comparison\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (const key of keysA) {\n    if (!keysB.includes(key) || !deepCompare(a[key], b[key], seen)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Test cases\nconsole.log('--- Primitives ---');\nconsole.log(deepCompare(1, 1)); // true\nconsole.log(deepCompare('hello', 'hello')); // true\nconsole.log(deepCompare(null, null)); // true\nconsole.log(deepCompare(undefined, undefined)); // true\nconsole.log(deepCompare(1, 2)); // false\nconsole.log(deepCompare(null, undefined)); // false\nconsole.log(deepCompare(NaN, NaN)); // true (special case)\n\nconsole.log('--- Objects ---');\nconst obj1 = { a: 1, b: { c: 2 } };\nconst obj2 = { a: 1, b: { c: 2 } };\nconst obj3 = { a: 1, b: { c: 3 } };\nconst obj4 = { a: 1, b: { c: 2 }, d: 4 };\nconsole.log(deepCompare(obj1, obj2)); // true\nconsole.log(deepCompare(obj1, obj3)); // false\nconsole.log(deepCompare(obj1, obj4)); // false\n\nconsole.log('--- Arrays ---');\nconst arr1 = [1, { a: 2 }, [3, 4]];\nconst arr2 = [1, { a: 2 }, [3, 4]];\nconst arr3 = [1, { a: 2 }, [3, 5]];\nconsole.log(deepCompare(arr1, arr2)); // true\nconsole.log(deepCompare(arr1, arr3)); // false\n\nconsole.log('--- Mixed Types ---');\nconsole.log(deepCompare([1], 1)); // false\nconsole.log(deepCompare({}, [])); // false\n\nconsole.log('--- Circular References (Advanced) ---');\nconst circularA = {};\nconst circularB = {};\ncircularA.b = circularB;\ncircularB.a = circularA;\nconsole.log(deepCompare(circularA, circularB)); // true (should handle gracefully, or depend on specific requirement)\n\nconst circularX = {};\nconst circularY = {};\ncircularX.self = circularX;\ncircularY.self = circularY;\nconsole.log(deepCompare(circularX, circularY)); // true\n\nconst circularP = {};\nconst circularQ = { prop: {} };\ncircularP.self = circularP;\ncircularQ.prop.self = circularQ.prop; // Different structure of circularity\nconsole.log(deepCompare(circularP, circularQ)); // false\n\nconst circularR = {};\nconst circularS = {};\ncircularR.ref = circularS;\ncircularS.ref = circularR;\n\n// Create slightly different circular structure\nconst circularT = {};\nconst circularU = {};\ncircularT.ref = circularU;\ncircularU.ref = circularT;\n\nconsole.log(deepCompare(circularR, circularT)); // true\n\nconst circularM = {};\nconst circularN = {};\ncircularM.ref = circularM;\ncircularN.ref = circularN;\nconsole.log(deepCompare(circularM, circularN)); // true\n\nconst circularV = {};\nconst circularW = {};\ncircularV.ref = circularW;\ncircularW.ref = circularV;\ncircularV.extra = 1;\nconsole.log(deepCompare(circularV, circularW)); // false (extra property)\n```",
          "analysisPoints": [
            "Handles strict equality for primitives.",
            "Checks for `null`, `undefined`, and non-object types correctly.",
            "Recursively compares properties for objects and elements for arrays.",
            "Compares lengths of arrays and number of keys for objects.",
            "Checks for different constructors (e.g., array vs. object).",
            "Includes a mechanism (WeakMap) to detect and handle circular references to prevent infinite loops.",
            "Correctly handles `NaN` comparison."
          ],
          "keyConcepts": [
            "Deep comparison",
            "Recursion",
            "Primitive vs. Object types",
            "Type checking",
            "Circular references",
            "WeakMap"
          ],
          "evaluationCriteria": [
            "Correctness for primitives, objects, and arrays.",
            "Robustness in handling edge cases (null, undefined, NaN).",
            "Efficiency (avoiding infinite loops for circular references).",
            "Code organization and readability."
          ],
          "example": null,
          "tags": [
            "data-structures",
            "algorithms",
            "recursion",
            "code-challenge",
            "advanced-js"
          ],
          "prerequisites": [
            "theory_javascript_data_types",
            "recursion",
            "hash-maps"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_type_conversion_1",
          "topic": "JavaScript Type Conversion",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `parseInt()` and `Number()` when converting a string like '123px' to a number?",
          "answer": "`parseInt('123px')` will return `123` because it parses until it encounters a non-numeric character. `Number('123px')` will return `NaN` because `Number()` is stricter and requires the entire string to be a valid number.",
          "analysisPoints": [
            "Differentiate parsing behavior for `parseInt` and `Number`.",
            "Identify when each function would return a valid number versus `NaN`."
          ],
          "keyConcepts": [
            "parseInt()",
            "Number()",
            "Type coercion",
            "NaN"
          ],
          "evaluationCriteria": [
            "Basic understanding of type conversion function behavior."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "conversion-methods",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_type_conversion_2",
          "topic": "JavaScript Type Conversion",
          "level": "medium",
          "type": "mcq",
          "question": "What will be the output of `parseInt('0xFF', 16)`?",
          "answer": "255",
          "options": [
            "0",
            "NaN",
            "FF",
            "255"
          ],
          "analysisPoints": [
            "Knowledge of `parseInt()`'s `radix` parameter.",
            "Ability to convert hexadecimal to decimal."
          ],
          "keyConcepts": [
            "parseInt()",
            "Radix",
            "Hexadecimal conversion"
          ],
          "evaluationCriteria": [
            "Correctly uses `radix` parameter."
          ],
          "example": "`0xFF` is a hexadecimal number. When `parseInt()` is called with `16` as the radix, it interprets the string as a base-16 number. In hexadecimal, `F` represents `15`. So, `0xFF` means `(0 * 16^2) + (15 * 16^1) + (15 * 16^0) = 0 + 240 + 15 = 255`.",
          "tags": [
            "type-coercion",
            "conversion-methods",
            "mcq",
            "numbers"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_type_conversion_3",
          "topic": "JavaScript Type Conversion",
          "level": "medium",
          "type": "open",
          "question": "List all 'falsy' values in JavaScript. Why is understanding falsy values important in frontend development?",
          "answer": "The 'falsy' values in JavaScript are:\n*   `false`\n*   `0` (zero)\n*   `-0` (negative zero)\n*   `0n` (BigInt zero)\n*   `''` (empty string)\n*   `null`\n*   `undefined`\n*   `NaN`\n\nUnderstanding falsy values is crucial in frontend development because they dictate how values behave in boolean contexts, such as `if` statements, logical operators (`&&`, `||`), and conditional rendering in UI frameworks. For example:\n\n*   **Conditional Logic**: `if (value)` will evaluate to `false` if `value` is any of the falsy values. This is commonly used for checking if a variable has a meaningful value (e.g., `if (username)` checks if `username` is not an empty string, `null`, or `undefined`).\n*   **Default Values**: Logical OR (`||`) operator leverages falsy values to provide default values, like `const userName = storedUser || 'Guest';`.\n*   **Boolean Coercion**: When working with APIs or external data, values might not be strict booleans (`true`/`false`), but their truthiness/falsiness determines their behavior. Knowing which values are falsy helps in correctly interpreting such data.",
          "analysisPoints": [
            "Accurate and complete list of falsy values.",
            "Clear explanation of why understanding falsy values is important, with practical examples in frontend context (conditional rendering, default values)."
          ],
          "keyConcepts": [
            "Falsy values",
            "Boolean coercion",
            "Conditional statements",
            "Logical operators",
            "Frontend best practices"
          ],
          "evaluationCriteria": [
            "Completeness of falsy list.",
            "Relevance and clarity of explanation and examples."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "javascript-fundamentals",
            "boolean",
            "open-ended"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_type_conversion_4",
          "topic": "JavaScript Type Conversion",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following expressions will result in `true`?",
          "answer": "Boolean('0')",
          "options": [
            "Boolean(0)",
            "Boolean('')",
            "Boolean(null)",
            "Boolean('0')"
          ],
          "analysisPoints": [
            "Knowledge of falsy values.",
            "Understanding that non-empty strings (even '0') are truthy."
          ],
          "keyConcepts": [
            "Falsy values",
            "Boolean coercion",
            "String truthiness"
          ],
          "evaluationCriteria": [
            "Correctly identifies truthy/falsy values."
          ],
          "example": "`0`, `''` (empty string), and `null` are all falsy values in JavaScript. However, any non-empty string, including `'0'`, is considered truthy. Therefore, `Boolean('0')` evaluates to `true`.",
          "tags": [
            "type-coercion",
            "boolean",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_type_conversion_5",
          "topic": "JavaScript Type Conversion",
          "level": "medium",
          "type": "code",
          "question": "Given a variable `input`. Write a JavaScript snippet that safely converts `input` to a number, handling cases where it might be `undefined`, `null`, an empty string, or a string with non-numeric characters, returning `0` in such invalid cases, but retaining `NaN` if `input` itself is `NaN`.",
          "answer": "```javascript\nfunction safeConvertToNumber(input) {\n  if (input === undefined || input === null || input === '') {\n    return 0; // Convert undefined, null, empty string to 0\n  }\n  const num = Number(input);\n  if (Number.isNaN(num) && input !== NaN) {\n    return 0; // If Number() results in NaN, but original input was not NaN, return 0\n  }\n  return num;\n}\n\n// Test cases\nconsole.log(safeConvertToNumber('42'));         // 42\nconsole.log(safeConvertToNumber('3.14'));        // 3.14\nconsole.log(safeConvertToNumber('42px'));        // 0\nconsole.log(safeConvertToNumber(undefined));     // 0\nconsole.log(safeConvertToNumber(null));          // 0\nconsole.log(safeConvertToNumber(''));            // 0\nconsole.log(safeConvertToNumber(0));             // 0\nconsole.log(safeConvertToNumber(NaN));           // NaN\nconsole.log(safeConvertToNumber(true));          // 1\nconsole.log(safeConvertToNumber('  -10 '));      // -10\n```",
          "analysisPoints": [
            "Uses `Number()` for strict conversion.",
            "Explicitly checks for `undefined`, `null`, `''`.",
            "Distinguishes `NaN` from input that *becomes* `NaN` due to conversion failure.",
            "Returns `0` for invalid conversions.",
            "Handles `NaN` input correctly (returns `NaN`)."
          ],
          "keyConcepts": [
            "Type conversion",
            "Number()",
            "isNaN()",
            "Edge cases",
            "Conditional logic"
          ],
          "evaluationCriteria": [
            "Correctness across various input types.",
            "Adherence to specified return values for edge cases.",
            "Code clarity and efficiency."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "data-validation",
            "code-challenge",
            "edge-cases"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_type_conversion_6",
          "topic": "JavaScript Type Conversion",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast JavaScript's implicit type coercion and explicit type conversion. When might implicit coercion lead to bugs, and why is explicit conversion generally preferred in professional code?",
          "answer": "**Implicit Type Coercion** occurs automatically when JavaScript tries to operate on values of different types. The engine silently converts one or both operands to a compatible type. Examples include:\n*   `'5' - 2` (string '5' becomes number 5)\n*   `true + 1` (boolean true becomes number 1)\n*   `if (someValue)` (any value coerced to boolean)\n\n**Explicit Type Conversion** (or type casting) involves using built-in functions or constructors (`Number()`, `String()`, `Boolean()`, `parseInt()`, `parseFloat()`) to intentionally convert a value from one type to another.\n\n**Comparison & Contrast:**\n*   **Automatic vs. Intentional:** Implicit is automatic; explicit is developer-driven.\n*   **Predictability:** Explicit conversion is generally more predictable and readable because the conversion is clearly stated in the code. Implicit coercion can be surprising and lead to unexpected results.\n*   **Debugging:** Bugs caused by implicit coercion can be harder to diagnose as the conversion happens silently.\n\n**When Implicit Coercion Leads to Bugs:**\n*   **The `+` operator:** This is the most common culprit. It acts as both numeric addition and string concatenation. `1 + '2'` results in `'12'`, not `3`. `[1,2] + [3,4]` results in `'1,23,4'`. If a developer expects numeric addition but gets string concatenation (or vice-versa), it's a bug.\n*   **Loose equality (`==`)**: `0 == false`, `'' == false`, `null == undefined` all evaluate to `true` due to implicit coercion, which can mask actual type mismatches and lead to logic errors.\n*   **Misleading Truthiness/Falsiness**: Relying purely on truthiness can hide valid `0` or empty string values, e.g., `if (count)` will be false if `count` is `0`, even if `0` is a valid quantity.\n\n**Why Explicit Conversion is Preferred:**\n1.  **Readability**: Code clearly states the intent of conversion, making it easier for other developers (and future self) to understand.\n2.  **Predictability**: Reduces the chance of unexpected behavior due to JavaScript's complex coercion rules.\n3.  **Maintainability**: Easier to debug and refactor when conversions are explicit.\n4.  **Error Prevention**: Helps prevent common bugs related to `+` operator ambiguity or loose equality.\n\nIn essence, explicit conversion makes the code's behavior transparent and less prone to subtle, hard-to-find bugs.",
          "analysisPoints": [
            "Clear definitions of implicit and explicit conversion.",
            "Effective comparison of the two approaches.",
            "Specific examples of `+` operator, `==`, and truthiness leading to bugs.",
            "Comprehensive reasons for preferring explicit conversion, linking to readability, predictability, etc."
          ],
          "keyConcepts": [
            "Implicit coercion",
            "Explicit conversion",
            "Type coercion",
            "Operators",
            "Best practices",
            "Debugging",
            "Loose equality"
          ],
          "evaluationCriteria": [
            "Depth of comparative analysis.",
            "Accuracy of examples for implicit coercion bugs.",
            "Strong justification for explicit preference.",
            "Overall clarity and structure of the explanation."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "javascript-fundamentals",
            "best-practices",
            "open-ended"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_operators_1",
          "topic": "JavaScript Operators",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary difference in behavior between `i++` and `++i` when used in an expression?",
          "answer": "`i++` returns the original value before incrementing, `++i` returns the value after incrementing.",
          "options": [
            "They are functionally identical and have no difference.",
            "`i++` returns the original value before incrementing, `++i` returns the value after incrementing.",
            "`i++` increments `i` by 1, `++i` increments `i` by 2.",
            "`i++` can only be used in `for` loops, `++i` can be used anywhere."
          ],
          "analysisPoints": [
            "Recall the definitions of pre-increment and post-increment.",
            "Focus on the 'return value' aspect."
          ],
          "keyConcepts": [
            "Increment operators",
            "Pre-increment",
            "Post-increment"
          ],
          "evaluationCriteria": [
            "Correctly identifies the behavioral difference."
          ],
          "example": "```javascript\nlet a = 5;\nlet b = a++; // b is 5, a becomes 6\n\nlet x = 5;\nlet y = ++x; // y is 6, x becomes 6\n```",
          "tags": [
            "operators",
            "javascript-fundamentals",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_operators_and_pitfalls"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_operators_2",
          "topic": "JavaScript Operators",
          "level": "medium",
          "type": "code",
          "question": "Identify and correct the bug in the following `for` loop. Explain why the original code behaves incorrectly.\n\n```javascript\nlet numbers = [10, 20, 30, 40, 50];\nlet sum = 0;\nfor (let i = 0; i < numbers.length; i + 2) {\n  sum += numbers[i];\n}\nconsole.log(sum);\n```",
          "answer": "```javascript\n// Corrected code\nlet numbers = [10, 20, 30, 40, 50];\nlet sum = 0;\nfor (let i = 0; i < numbers.length; i += 2) { // Corrected: i + 2 changed to i += 2\n  sum += numbers[i];\n}\nconsole.log(sum); // Expected output: 10 + 30 + 50 = 90\n```\n\n**Explanation of the bug:**\n\nThe original code `i + 2` in the `for` loop's increment statement calculates `i + 2` but **does not assign the result back to `i`**. This means `i` always remains `0` (its initial value) throughout the loop. As long as `numbers.length` is greater than `0`, the condition `i < numbers.length` (`0 < 5`) will always be true, leading to an **infinite loop**. The `sum` would keep adding `numbers[0]` (which is `10`) repeatedly.\n\nTo correctly increment `i` by `2` in each iteration, you need to use an assignment operator: `i += 2` (shorthand for `i = i + 2`).",
          "analysisPoints": [
            "Correctly identifies the infinite loop bug.",
            "Explains that `i + 2` doesn't modify `i`.",
            "Provides the correct syntax `i += 2`.",
            "Explains the impact on the loop execution (infinite loop)."
          ],
          "keyConcepts": [
            "For loop",
            "Assignment operators",
            "Increment operators",
            "Common pitfalls",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Accurate bug identification and correction.",
            "Clear and comprehensive explanation of the underlying problem."
          ],
          "example": null,
          "tags": [
            "operators",
            "loops",
            "common-pitfalls",
            "code-challenge",
            "debugging"
          ],
          "prerequisites": [
            "theory_javascript_operators_and_pitfalls"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_operators_3",
          "topic": "JavaScript Operators",
          "level": "hard",
          "type": "open",
          "question": "Explain a scenario where the choice between `i++` and `++i` could significantly impact performance or correctness, beyond just the return value in an expression.",
          "answer": "While often negligible in simple numeric contexts, the choice between `i++` and `++i` can matter in more complex scenarios, particularly concerning objects, iterators, or performance-critical loops.\n\n**Performance (less common in modern JS engines, but theoretically exists):**\nIn some low-level languages or very old JavaScript engines, `++i` could theoretically be slightly more performant than `i++`. This is because `i++` needs to store the *original* value of `i` in a temporary variable before incrementing `i` and returning the temporary value. `++i` simply increments `i` and then uses the new value, potentially avoiding this temporary storage. However, modern JavaScript engines are highly optimized, and this difference is almost always optimized away, making it a micro-optimization not worth considering unless profiling indicates it's a bottleneck.\n\n**Correctness (more relevant in specific patterns):**\nConsider a custom iterator or a proxy object where incrementing might involve side effects or resource allocation/deallocation based on *when* the value is used versus *when* the increment occurs. If `i` is an object with a custom `valueOf` or `Symbol.toPrimitive` method, or if it's a part of a complex chain operation, the timing difference becomes crucial.\n\n**Example Scenario (Conceptual):**\nImagine a system where incrementing a counter (`i`) also triggers a network request or updates a UI element, and the old value vs. new value is important for the *order* of operations.\n\n```javascript\nclass EventCounter {\n  constructor(initial = 0) {\n    this.count = initial;\n  }\n\n  // Mimics ++i: increments, then returns new value\n  preIncrement() {\n    this.count++;\n    console.log(`Event Fired: Counter now ${this.count}`); // Event uses new value\n    return this.count;\n  }\n\n  // Mimics i++: returns old value, then increments\n  postIncrement() {\n    const oldValue = this.count;\n    this.count++;\n    console.log(`Event Fired: Counter was ${oldValue}`); // Event uses old value\n    return oldValue;\n  }\n}\n\nconst counter1 = new EventCounter();\nconsole.log(counter1.preIncrement());  // Output: Event Fired: Counter now 1, then prints 1\n\nconst counter2 = new EventCounter();\nconsole.log(counter2.postIncrement()); // Output: Event Fired: Counter was 0, then prints 0\n```\nIn this contrived example, if the `console.log` represented a crucial side effect (like logging an event with the counter's state), the choice of pre- or post-increment dictates whether the event is logged with the state *before* or *after* the increment. While simple `number` types don't have such side effects, complex objects or iterators could.",
          "analysisPoints": [
            "Discusses performance implications (even if minor in modern JS).",
            "Highlights correctness issues, especially with custom objects or side effects.",
            "Provides a concrete (even if conceptual) example illustrating how timing affects results.",
            "Emphasizes the difference in *when* the value is used relative to the increment."
          ],
          "keyConcepts": [
            "Pre-increment",
            "Post-increment",
            "Performance optimization",
            "Side effects",
            "Object prototypes",
            "Iterators"
          ],
          "evaluationCriteria": [
            "Depth of understanding beyond basic syntax.",
            "Ability to construct a relevant scenario.",
            "Clarity of explanation regarding subtle differences."
          ],
          "example": null,
          "tags": [
            "operators",
            "performance",
            "side-effects",
            "open-ended",
            "advanced-js"
          ],
          "prerequisites": [
            "theory_javascript_operators_and_pitfalls"
          ],
          "complexity": 8,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_operators_4",
          "topic": "JavaScript Operators",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the correct way to increment a variable `x` by `5` in a loop iteration, using a shorthand operator?",
          "answer": "`x += 5;`",
          "analysisPoints": [
            "Recall arithmetic assignment operators.",
            "Distinguish from simple addition without assignment."
          ],
          "keyConcepts": [
            "Assignment operators",
            "Compound assignment",
            "Loops"
          ],
          "evaluationCriteria": [
            "Basic understanding of assignment operators."
          ],
          "example": null,
          "tags": [
            "operators",
            "loops",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_edge_cases_1",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code:\n```javascript\nvar obj = {'1': 'A', 1: 'B', 0: 'C'};\nconsole.log(obj['1']);\nconsole.log(obj[1]);\n```\nWhat will be the output?",
          "answer": "B\nB",
          "options": [
            "A\nA",
            "A\nB",
            "B\nB",
            "B\nA"
          ],
          "analysisPoints": [
            "Understanding how JavaScript handles object property keys.",
            "Recognizing implicit string conversion for numeric keys.",
            "Identifying that `obj['1']` and `obj[1]` refer to the same property if the key is numeric or stringified numeric."
          ],
          "keyConcepts": [
            "Object property access",
            "Type coercion",
            "JavaScript quirks"
          ],
          "evaluationCriteria": [
            "Correctly predicts object property access behavior."
          ],
          "example": "In JavaScript, object keys are inherently strings. When you use a numeric literal like `1` as a key, it's implicitly converted to the string `'1'`. Therefore, `{'1': 'A', 1: 'B'}` is actually defining the *same* property twice, and the last assignment (`1: 'B'`) overwrites the previous one (`'1': 'A'`). Both `obj['1']` and `obj[1]` then access this overwritten value, which is 'B'.",
          "tags": [
            "objects",
            "type-coercion",
            "edge-cases",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_edge_cases_2",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "hard",
          "type": "code",
          "question": "Predict the output of the following JavaScript expression and explain the step-by-step evaluation process, including type coercion:\n\n```javascript\nconsole.log(10 - '2' + true + null - '3.5');\n```",
          "answer": "```javascript\nconsole.log(10 - '2' + true + null - '3.5'); // Output: 5.5\n```\n\n**Step-by-step evaluation:**\n\n1.  **`10 - '2'`**: The `-` operator forces numeric conversion. `'2'` becomes `2`. Result: `10 - 2 = 8`.\n2.  **`8 + true`**: The `+` operator. Since `8` is a number and `true` is a boolean, `true` is converted to `1`. Result: `8 + 1 = 9`.\n3.  **`9 + null`**: The `+` operator. `null` is converted to `0`. Result: `9 + 0 = 9`.\n4.  **`9 - '3.5'`**: The `-` operator forces numeric conversion. `'3.5'` becomes `3.5`. Result: `9 - 3.5 = 5.5`.\n\n**Final Output**: `5.5`",
          "analysisPoints": [
            "Correctly identifies type coercion for each operator.",
            "Explains the behavior of `+` vs `-` operators with mixed types.",
            "Provides a clear step-by-step breakdown of evaluation.",
            "Correctly predicts the final output."
          ],
          "keyConcepts": [
            "Type coercion",
            "Operators",
            "Operator precedence",
            "Mixed type arithmetic",
            "Edge cases"
          ],
          "evaluationCriteria": [
            "Accuracy of step-by-step explanation.",
            "Correctness of intermediate and final results.",
            "Demonstrates deep understanding of JS coercion rules."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "edge-cases",
            "code-challenge"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_edge_cases_3",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "medium",
          "type": "mcq",
          "question": "What value will `result` hold after the following code executes?\n\n```javascript\nlet x = null;\nlet y = 'hello';\nlet z = 0;\n\nconst result = x || y || z || 100;\n```",
          "answer": "'hello'",
          "options": [
            "null",
            "'hello'",
            "0",
            "100"
          ],
          "analysisPoints": [
            "Understanding of logical OR (`||`) operator.",
            "Knowledge of truthy/falsy values.",
            "Ability to apply short-circuit evaluation."
          ],
          "keyConcepts": [
            "Logical operators",
            "Short-circuit evaluation",
            "Truthy/Falsy values"
          ],
          "evaluationCriteria": [
            "Correctly applies short-circuiting logic."
          ],
          "example": "The `||` (OR) operator returns the first truthy value it encounters. \n1. `x` is `null`, which is falsy.\n2. `y` is `'hello'`, which is truthy. The evaluation stops here and `'hello'` is returned.",
          "tags": [
            "operators",
            "truthy-falsy",
            "short-circuiting",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_edge_cases_4",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "medium",
          "type": "open",
          "question": "Explain the behavior of the `&&` (AND) operator in JavaScript when used with non-boolean operands. Provide an example.",
          "answer": "The `&&` (AND) operator in JavaScript, unlike in some other languages, does not always return a boolean `true` or `false`. Instead, it uses 'short-circuit evaluation' and returns the value of one of the operands.\n\nIts behavior is as follows:\n1.  It evaluates operands from left to right.\n2.  If the **first operand is falsy**, it stops evaluating and returns the value of that first falsy operand.\n3.  If the **first operand is truthy**, it continues to the second operand. It then returns the value of the second operand (whether that second operand is truthy or falsy).\n\n**Example:**\n```javascript\nconsole.log(5 && 10);        // Output: 10 (5 is truthy, returns the last operand)\nconsole.log('hello' && 0);   // Output: 0 ('hello' is truthy, 0 is falsy, returns 0)\nconsole.log(null && 'world'); // Output: null (null is falsy, returns null immediately)\nconsole.log(true && 'value'); // Output: 'value' (true is truthy, returns 'value')\nconsole.log(0 && false);     // Output: 0 (0 is falsy, returns 0 immediately)\n```\nThis behavior is commonly used for conditional execution or setting default values, e.g., `user && user.profile.name` to safely access nested properties, or `options.debug && runDebugger();`.",
          "analysisPoints": [
            "Clear explanation of short-circuit evaluation for `&&`.",
            "Correctly identifies what value is returned (first falsy or last truthy).",
            "Provides illustrative examples for different scenarios.",
            "Mentions practical applications (e.g., safe property access)."
          ],
          "keyConcepts": [
            "Logical AND operator",
            "Short-circuit evaluation",
            "Truthy/Falsy values",
            "Conditional execution"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of explanation.",
            "Relevance and clarity of examples.",
            "Demonstrates understanding of operator's return value."
          ],
          "example": null,
          "tags": [
            "operators",
            "short-circuiting",
            "truthy-falsy",
            "open-ended"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_edge_cases_5",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "hard",
          "type": "code",
          "question": "What is the output of the following and explain why? How can you get a numeric sum of the arrays?\n\n```javascript\nconsole.log([] + {});\nconsole.log({} + []);\nconsole.log([1,2] + [3,4]);\n```",
          "answer": "```javascript\nconsole.log([] + {});   // Output: [object Object]\nconsole.log({} + []);   // Output: [object Object] (or 0 in some contexts, see explanation)\nconsole.log([1,2] + [3,4]); // Output: 1,23,4\n```\n\n**Explanation:**\n\n1.  **`[] + {}`**: The `+` operator, when applied to objects, attempts to convert them to primitives via `valueOf()` or `toString()`. An empty array `[]` typically converts to an empty string `''`. An empty object `{}` typically converts to the string `'[object Object]'`. When string concatenation occurs, `'' + '[object Object]'` results in `'[object Object]'`.\n\n2.  **`{} + []`**: This is tricky due to JavaScript's parsing rules. If this expression appears at the *beginning of a statement* (e.g., directly in `console.log`), the `{}` is often interpreted as an empty **code block**, not an object literal. In such a case, the code block is ignored, and the expression effectively becomes `+[]`. The unary `+` operator converts `[]` to a number. `[]`'s `valueOf()` returns `[]`, then `toString()` returns `''`, and `Number('')` is `0`. So, `0` would be the result. However, if it's part of a larger expression or explicitly wrapped (e.g., `({} + [])`), then `{}` is treated as an object, leading to `[object Object]` for the same reasons as `[] + {}`.\n    *   **In `console.log({} + [])`**: Most modern browsers and Node.js will interpret `{}` as an object literal due to it being an expression argument, leading to `'[object Object]'`. The result `'[object Object]'` is what's commonly observed in console.log.\n\n3.  **`[1,2] + [3,4]`**: Again, the `+` operator performs string concatenation because arrays are objects. `[1,2]` is converted to the string `'1,2'`, and `[3,4]` is converted to `'3,4'`. Concatenating these strings gives `'1,23,4'`.\n\n**How to get a numeric sum of the arrays:**\n\nTo get a numeric sum, you need to explicitly convert the array elements to numbers and perform addition, or iterate and sum them. The `+` operator directly on arrays will *not* perform element-wise numeric addition.\n\n```javascript\n// Option 1: Summing elements individually\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\n\nconst sumArr1 = arr1.reduce((acc, val) => acc + val, 0); // 3\nconst sumArr2 = arr2.reduce((acc, val) => acc + val, 0); // 7\nconsole.log(sumArr1 + sumArr2); // Output: 10\n\n// Option 2: Combining and summing (if treating as a single list)\nconst combinedArr = [...arr1, ...arr2]; // [1,2,3,4]\nconst totalSum = combinedArr.reduce((acc, val) => acc + val, 0);\nconsole.log(totalSum); // Output: 10\n\n// If the intention was element-wise addition to create a new array:\nconst resultArr = arr1.map((val, index) => val + arr2[index]);\nconsole.log(resultArr); // Output: [4, 6]\n```",
          "analysisPoints": [
            "Correctly explains the implicit string coercion for arrays with `+` operator.",
            "Addresses the ambiguity of `{}` when at the start of a statement vs. an expression.",
            "Provides clear step-by-step reasoning for each output.",
            "Offers multiple correct ways to achieve numeric summation or element-wise addition of arrays, contrasting with the implicit behavior."
          ],
          "keyConcepts": [
            "Type coercion",
            "Operators",
            "Object to primitive conversion",
            "Array toString()",
            "Code blocks vs. object literals",
            "Array methods (map, reduce)",
            "Spread syntax"
          ],
          "evaluationCriteria": [
            "Accuracy of output prediction and explanation.",
            "Demonstrates advanced understanding of JS parsing and coercion.",
            "Provides viable solutions for desired numeric operations.",
            "Clarity and completeness of explanation."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "edge-cases",
            "operators",
            "arrays",
            "code-challenge",
            "advanced-js"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 10,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_edge_cases_6",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference in the result of `!!(a && b)` versus `(a && b)` when `a = 5` and `b = 10`?",
          "answer": "`!!(a && b)` will result in `true` (a boolean). `(a && b)` will result in `10` (the last truthy value).",
          "analysisPoints": [
            "Understand `!!` for explicit boolean conversion.",
            "Recall `&&` short-circuit behavior (returns value, not just boolean)."
          ],
          "keyConcepts": [
            "Logical operators",
            "Short-circuit evaluation",
            "Double negation (!!)",
            "Type coercion"
          ],
          "evaluationCriteria": [
            "Correctly identifies the type and value returned by each expression."
          ],
          "example": null,
          "tags": [
            "operators",
            "truthy-falsy",
            "short-circuiting",
            "flashcard"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_strategy_pattern_calculator",
          "title": "Implement a Flexible Calculator with Strategy Pattern",
          "description": "\nImplement a `Calculator` class that can perform different arithmetic operations (addition, subtraction, multiplication, division) using the Strategy design pattern.\n\n**Requirements:**\n1.  Create a `Calculator` class (Context) that has a `setStrategy` method and an `executeOperation` method.\n2.  Define an implicit `OperationStrategy` interface (e.g., a method `execute(a, b)`).\n3.  Implement at least three concrete strategy classes: `AdditionStrategy`, `SubtractionStrategy`, and `MultiplicationStrategy`.\n4.  Each strategy should implement the `execute` method to perform its respective operation.\n5.  Ensure the `Calculator` can switch between strategies dynamically and execute the operation.\n6.  Handle potential errors in `executeOperation` if no strategy is set.\n",
          "difficulty": "medium",
          "startingCode": "class Calculator {\n  // TODO: Implement Calculator (Context) class\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeOperation(a, b) {\n    // Ensure strategy is set, otherwise throw an error\n    if (!this.strategy) {\n      throw new Error(\"No operation strategy set.\");\n    }\n    return this.strategy.execute(a, b);\n  }\n}\n\n// TODO: Implement concrete strategy classes (AdditionStrategy, SubtractionStrategy, MultiplicationStrategy)\n\n// Example Usage (to be uncommented and tested):\n// const calculator = new Calculator();\n// const a = 10;\n// const b = 5;\n\n// calculator.setStrategy(new AdditionStrategy());\n// console.log(`${a} + ${b} =`, calculator.executeOperation(a, b)); // Expected: 15\n\n// calculator.setStrategy(new SubtractionStrategy());\n// console.log(`${a} - ${b} =`, calculator.executeOperation(a, b)); // Expected: 5\n\n// calculator.setStrategy(new MultiplicationStrategy());\n// console.log(`${a} * ${b} =`, calculator.executeOperation(a, b)); // Expected: 50\n\n// Test error handling\n// const emptyCalculator = new Calculator();\n// try {\n//   emptyCalculator.executeOperation(1, 2);\n// } catch (error) {\n//   console.error(error.message); // Expected: No operation strategy set.\n// }\n",
          "solutionCode": "class Calculator {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeOperation(a, b) {\n    if (!this.strategy) {\n      throw new Error(\"No operation strategy set.\");\n    }\n    return this.strategy.execute(a, b);\n  }\n}\n\nclass AdditionStrategy {\n  execute(a, b) {\n    return a + b;\n  }\n}\n\nclass SubtractionStrategy {\n  execute(a, b) {\n    return a - b;\n  }\n}\n\nclass MultiplicationStrategy {\n  execute(a, b) {\n    return a * b;\n  }\n}\n\n// Optional: Division Strategy with error handling for division by zero\nclass DivisionStrategy {\n  execute(a, b) {\n    if (b === 0) {\n      throw new Error(\"Cannot divide by zero.\");\n    }\n    return a / b;\n  }\n}\n\nconst calculator = new Calculator();\nconst a = 10;\nconst b = 5;\n\ncalculator.setStrategy(new AdditionStrategy());\nconsole.log(`${a} + ${b} =`, calculator.executeOperation(a, b));\n\ncalculator.setStrategy(new SubtractionStrategy());\nconsole.log(`${a} - ${b} =`, calculator.executeOperation(a, b));\n\ncalculator.setStrategy(new MultiplicationStrategy());\nconsole.log(`${a} * ${b} =`, calculator.executeOperation(a, b));\n\ncalculator.setStrategy(new DivisionStrategy());\nconsole.log(`${a} / ${b} =`, calculator.executeOperation(a, b));\n\n// Test error handling for missing strategy\nconst emptyCalculator = new Calculator();\ntry {\n  emptyCalculator.executeOperation(1, 2);\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\n\n// Test error handling for division by zero\ntry {\n  calculator.setStrategy(new DivisionStrategy());\n  console.log(`${a} / 0 =`, calculator.executeOperation(a, 0));\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\n",
          "testCases": [
            "Test addition: `calculator.setStrategy(new AdditionStrategy()); calculator.executeOperation(10, 5)` should return `15`.",
            "Test subtraction: `calculator.setStrategy(new SubtractionStrategy()); calculator.executeOperation(10, 5)` should return `5`.",
            "Test multiplication: `calculator.setStrategy(new MultiplicationStrategy()); calculator.executeOperation(10, 5)` should return `50`.",
            "Test error when no strategy is set: `new Calculator().executeOperation(1, 2)` should throw an error with message 'No operation strategy set.'.",
            "Test with floating-point numbers.",
            "Test with negative numbers."
          ],
          "hints": [
            "Remember that in JavaScript, interfaces are often implicit. Just ensure each strategy class has the required `execute` method.",
            "The `Calculator` (Context) should only know about the `execute` method, not the specific strategy class names.",
            "Think about adding a default strategy or robust error handling if no strategy is explicitly set."
          ],
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "oop",
            "classes",
            "frontend-architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_strategy_pattern",
            "object-oriented-programming"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "polymorphism",
            "loose-coupling",
            "open-closed-principle"
          ]
        },
        {
          "id": "task_deep_clone_object",
          "title": "Implement a Deep Clone Function for Objects and Arrays",
          "description": "\nWrite a JavaScript function `deepClone(value)` that creates a deep copy of a given value. The function should handle:\n\n1.  **Primitive types**: Return them directly.\n2.  **Objects**: Recursively clone all enumerable own properties.\n3.  **Arrays**: Recursively clone all elements.\n4.  **`null` and `undefined`**: Return them directly.\n5.  **Circular references (Bonus)**: Prevent infinite loops by detecting and handling circular references. If a circular reference is encountered, you can either return a reference to the already cloned object or throw an error, but preventing infinite loops is the primary goal. Returning the already cloned reference is a common approach.\n\nYour solution should use standard JavaScript features (no external libraries like Lodash).",
          "difficulty": "hard",
          "startingCode": "function deepClone(value, hash = new WeakMap()) {\n  // 1. Handle primitives, null, undefined\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // 2. Handle circular references (Bonus)\n  if (hash.has(value)) {\n    return hash.get(value);\n  }\n\n  // 3. Determine if value is an Array or Object and create initial clone\n  const clone = Array.isArray(value) ? [] : {};\n\n  // 4. Store the clone in hash BEFORE recursive calls to handle circular references\n  hash.set(value, clone);\n\n  // 5. Recursively clone properties/elements\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone(value[key], hash);\n    }\n  }\n\n  return clone;\n}\n\n// Example Usage (to be uncommented and tested):\n// const obj1 = { a: 1, b: { c: 2 }, d: [3, 4] };\n// const clonedObj1 = deepClone(obj1);\n// console.log(clonedObj1); // Should be a deep copy\n// console.log(clonedObj1 === obj1); // false\n// console.log(clonedObj1.b === obj1.b); // false\n// console.log(clonedObj1.d === obj1.d); // false\n\n// const arr1 = [1, { x: 10 }, [20, 30]];\n// const clonedArr1 = deepClone(arr1);\n// console.log(clonedArr1); // Should be a deep copy\n// console.log(clonedArr1 === arr1); // false\n// console.log(clonedArr1[1] === arr1[1]); // false\n\n// // Test circular reference (Bonus)\n// const circularObj = {};\n// circularObj.self = circularObj;\n// const clonedCircularObj = deepClone(circularObj);\n// console.log(clonedCircularObj.self === clonedCircularObj); // true\n// console.log(clonedCircularObj === circularObj); // false\n\n// const circularArr = [];\n// circularArr.push(circularArr);\n// const clonedCircularArr = deepClone(circularArr);\n// console.log(clonedCircularArr[0] === clonedCircularArr); // true\n\n// // Test with Date/RegExp (optional advanced)\n// const date = new Date();\n// const clonedDate = deepClone(date);\n// console.log(clonedDate instanceof Date); // false (simple clone won't copy prototype)\n// console.log(clonedDate.getTime() === date.getTime()); // Value is copied\n\n// // Test for function/Symbol/BigInt (should return directly)\n// const func = () => {};\n// console.log(deepClone(func) === func); // true\n// const sym = Symbol('test');\n// console.log(deepClone(sym) === sym); // true\n// const big = 123n;\n// console.log(deepClone(big) === big); // true\n",
          "solutionCode": "function deepClone(value, hash = new WeakMap()) {\n  // 1. Handle primitives, null, undefined, functions, symbols, BigInts\n  // For simplicity, we'll treat functions, Symbols, BigInts as non-clonable objects,\n  // meaning they are returned by reference, which is standard for deep cloning.\n  // Date and RegExp objects are also tricky. A simple deep clone usually doesn't recreate them.\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // Handle Date objects\n  if (value instanceof Date) {\n    return new Date(value.getTime());\n  }\n\n  // Handle RegExp objects\n  if (value instanceof RegExp) {\n    return new RegExp(value.source, value.flags);\n  }\n\n  // 2. Handle circular references\n  if (hash.has(value)) {\n    return hash.get(value);\n  }\n\n  // 3. Determine if value is an Array or Object and create initial clone\n  const clone = Array.isArray(value) ? [] : {};\n\n  // 4. Store the clone in hash BEFORE recursive calls to handle circular references\n  hash.set(value, clone);\n\n  // 5. Recursively clone properties/elements\n  // Use Object.keys for objects to get enumerable own properties, \n  // or iterate through arrays\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      clone[i] = deepClone(value[i], hash);\n    }\n  } else {\n    for (const key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        clone[key] = deepClone(value[key], hash);\n      }\n    }\n  }\n\n  return clone;\n}\n\n// Test cases\nconst obj1 = { a: 1, b: { c: 2 }, d: [3, 4] };\nconst clonedObj1 = deepClone(obj1);\nconsole.log(\"obj1:\", obj1);\nconsole.log(\"clonedObj1:\", clonedObj1);\nconsole.log(\"clonedObj1 === obj1:\", clonedObj1 === obj1); // false\nconsole.log(\"clonedObj1.b === obj1.b:\", clonedObj1.b === obj1.b); // false\nconsole.log(\"clonedObj1.d === obj1.d:\", clonedObj1.d === obj1.d); // false\nconsole.log(\"clonedObj1.b.c === obj1.b.c:\", clonedObj1.b.c === obj1.b.c); // true (primitive)\n\nconst arr1 = [1, { x: 10 }, [20, 30]];\nconst clonedArr1 = deepClone(arr1);\nconsole.log(\"arr1:\", arr1);\nconsole.log(\"clonedArr1:\", clonedArr1);\nconsole.log(\"clonedArr1 === arr1:\", clonedArr1 === arr1); // false\nconsole.log(\"clonedArr1[1] === arr1[1]:\", clonedArr1[1] === arr1[1]); // false\n\n// Test circular reference (Bonus)\nconst circularObj = {};\ncircularObj.self = circularObj;\nconst clonedCircularObj = deepClone(circularObj);\nconsole.log(\"circularObj:\", circularObj);\nconsole.log(\"clonedCircularObj:\", clonedCircularObj);\nconsole.log(\"clonedCircularObj.self === clonedCircularObj:\", clonedCircularObj.self === clonedCircularObj); // true\nconsole.log(\"clonedCircularObj === circularObj:\", clonedCircularObj === circularObj); // false\n\nconst circularArr = [];\ncircularArr.push(circularArr);\nconst clonedCircularArr = deepClone(circularArr);\nconsole.log(\"circularArr:\", circularArr);\nconsole.log(\"clonedCircularArr:\", clonedCircularArr);\nconsole.log(\"clonedCircularArr[0] === clonedCircularArr:\", clonedCircularArr[0] === clonedCircularArr); // true\n\n// Test with Date/RegExp\nconst date = new Date();\nconst regex = /abc/gi;\nconst mixedObj = { d: date, r: regex, f: () => {}, s: Symbol('test'), b: 123n };\nconst clonedMixedObj = deepClone(mixedObj);\nconsole.log(\"mixedObj.d instanceof Date:\", mixedObj.d instanceof Date); // true\nconsole.log(\"clonedMixedObj.d instanceof Date:\", clonedMixedObj.d instanceof Date); // true\nconsole.log(\"clonedMixedObj.d.getTime() === mixedObj.d.getTime():\", clonedMixedObj.d.getTime() === mixedObj.d.getTime()); // true\nconsole.log(\"clonedMixedObj.r instanceof RegExp:\", clonedMixedObj.r instanceof RegExp); // true\nconsole.log(\"clonedMixedObj.r.source === mixedObj.r.source:\", clonedMixedObj.r.source === mixedObj.r.source); // true\nconsole.log(\"clonedMixedObj.f === mixedObj.f:\", clonedMixedObj.f === mixedObj.f); // true (functions are not deep cloned)\nconsole.log(\"clonedMixedObj.s === mixedObj.s:\", clonedMixedObj.s === mixedObj.s); // true (Symbols are primitives in this context)\nconsole.log(\"clonedMixedObj.b === mixedObj.b:\", clonedMixedObj.b === mixedObj.b); // true (BigInts are primitives)\n",
          "testCases": [
            "Test with primitive values (number, string, boolean, null, undefined).",
            "Test with a simple flat object.",
            "Test with a nested object.",
            "Test with an array containing primitives and objects.",
            "Test with an array containing nested arrays.",
            "Test with a mixed object (containing arrays, objects, primitives).",
            "Test with a circular object reference to ensure no infinite loop and correct cloning.",
            "Test with a circular array reference.",
            "Test `Date` and `RegExp` instances (for advanced solution)."
          ],
          "hints": [
            "Start with the base case: what happens if the value is a primitive or null?",
            "Use `typeof` to check for objects and `Array.isArray()` to differentiate arrays from plain objects.",
            "A `WeakMap` is ideal for tracking objects already visited during recursion, preventing memory leaks for objects that might be garbage collected.",
            "Remember to store the *cloned* object in the `WeakMap` *before* recursively cloning its properties/elements. This is crucial for handling circular references correctly."
          ],
          "tags": [
            "data-structures",
            "recursion",
            "deep-copy",
            "object-manipulation",
            "algorithms",
            "memory-management"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_javascript_data_types",
            "recursion",
            "WeakMap"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "expert",
          "relatedConcepts": [
            "shallow-copy",
            "json-parse-stringify",
            "structured-clone"
          ]
        },
        {
          "id": "task_robust_string_to_number",
          "title": "Create a Robust String-to-Number Converter",
          "description": "\nWrite a JavaScript function `convertToStrictNumber(input)` that converts a given input to a number based on the following rules:\n\n1.  If the input is already a `Number` (and not `NaN`), return it as is.\n2.  If the input is `null` or `undefined`, return `0`.\n3.  If the input is an empty string `''`, return `0`.\n4.  If the input is a string that represents a valid integer or float (e.g., `'123'`, `'-4.5'`, `'0'`), convert it and return the number.\n5.  If the input is a string that contains any non-numeric characters (e.g., `'123px'`, `'abc'`), return `NaN`.\n6.  If the input is `NaN`, return `NaN`.\n7.  For any other type of input (e.g., boolean, object, array), return `NaN`.\n\nYour goal is to be precise about valid number strings and invalid ones, and handle edge cases gracefully.",
          "difficulty": "medium",
          "startingCode": "function convertToStrictNumber(input) {\n  // TODO: Implement the conversion logic based on the requirements.\n\n  // Example of initial checks:\n  if (typeof input === 'number') {\n    return input; // Already a number, includes NaN\n  }\n  \n  if (input === null || input === undefined || input === '') {\n    return 0;\n  }\n\n  // ... rest of the logic\n  \n  return NaN; // Placeholder for invalid conversions\n}\n\n// Example Usage (to be uncommented and tested):\n// console.log(convertToStrictNumber(42));       // Expected: 42\n// console.log(convertToStrictNumber(-3.14));    // Expected: -3.14\n// console.log(convertToStrictNumber(NaN));      // Expected: NaN\n// console.log(convertToStrictNumber(null));     // Expected: 0\n// console.log(convertToStrictNumber(undefined));  // Expected: 0\n// console.log(convertToStrictNumber(''));       // Expected: 0\n// console.log(convertToStrictNumber('123'));    // Expected: 123\n// console.log(convertToStrictNumber('-4.5'));   // Expected: -4.5\n// console.log(convertToStrictNumber('0'));      // Expected: 0\n// console.log(convertToStrictNumber('  50  ')); // Expected: 50\n// console.log(convertToStrictNumber('123px'));  // Expected: NaN\n// console.log(convertToStrictNumber('abc'));    // Expected: NaN\n// console.log(convertToStrictNumber(true));     // Expected: NaN\n// console.log(convertToStrictNumber({}));       // Expected: NaN\n// console.log(convertToStrictNumber([]));        // Expected: NaN\n",
          "solutionCode": "function convertToStrictNumber(input) {\n  // Rule 1: If the input is already a Number (and not NaN), return it as is.\n  // We check for NaN later, as the initial 'typeof number' check would include NaN.\n  if (typeof input === 'number' && !Number.isNaN(input)) {\n    return input;\n  }\n\n  // Rule 2 & 3: If the input is null, undefined, or an empty string, return 0.\n  if (input === null || input === undefined || input === '') {\n    return 0;\n  }\n\n  // Rule 4 & 5: If the input is a string that represents a valid number, convert it.\n  // If it contains non-numeric chars, return NaN.\n  if (typeof input === 'string') {\n    // Use a regular expression to check if the string contains *only* numeric characters\n    // including optional sign, decimals, and scientific notation.\n    // Trim whitespace first.\n    const trimmedInput = input.trim();\n    if (trimmedInput === '') return 0; // After trim, if empty, it's an empty string case handled already\n\n    // Regex to match valid number strings including integers, floats, and scientific notation\n    // Allows for optional leading +/- sign, digits, optional decimal with digits, optional exponent part\n    const numberRegex = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$/;\n\n    if (numberRegex.test(trimmedInput)) {\n      return Number(trimmedInput);\n    } else {\n      return NaN; // String contains non-numeric characters\n    }\n  }\n\n  // Rule 6: If the input is NaN (from initial type check), handle it.\n  if (Number.isNaN(input)) {\n    return NaN;\n  }\n\n  // Rule 7: For any other type of input (e.g., boolean, object, array), return NaN.\n  return NaN;\n}\n\n// Test cases\nconsole.log(`42 -> ${convertToStrictNumber(42)}`);           // 42\nconsole.log(`-3.14 -> ${convertToStrictNumber(-3.14)}`);     // -3.14\nconsole.log(`NaN -> ${convertToStrictNumber(NaN)}`);         // NaN\nconsole.log(`null -> ${convertToStrictNumber(null)}`);       // 0\nconsole.log(`undefined -> ${convertToStrictNumber(undefined)}`); // 0\nconsole.log(`'' -> ${convertToStrictNumber('')}`);           // 0\nconsole.log(`'123' -> ${convertToStrictNumber('123')}`);     // 123\nconsole.log(`'-4.5' -> ${convertToStrictNumber('-4.5')}`);   // -4.5\nconsole.log(`'0' -> ${convertToStrictNumber('0')}`);         // 0\nconsole.log(`'  50  ' -> ${convertToStrictNumber('  50  ')}`); // 50\nconsole.log(`'123px' -> ${convertToStrictNumber('123px')}`); // NaN\nconsole.log(`'abc' -> ${convertToStrictNumber('abc')}`);     // NaN\nconsole.log(`true -> ${convertToStrictNumber(true)}`);       // NaN\nconsole.log(`{} -> ${convertToStrictNumber({})}`);           // NaN\nconsole.log(`[] -> ${convertToStrictNumber([])}`);           // NaN\nconsole.log(`'1e-3' -> ${convertToStrictNumber('1e-3')}`);   // 0.001\nconsole.log(`' ' -> ${convertToStrictNumber(' ')}`);         // 0 (trimmed to empty string)\n",
          "testCases": [
            "Test with valid numbers (positive, negative, float, zero).",
            "Test with `NaN` as input.",
            "Test with `null`, `undefined`, and empty string `''`.",
            "Test with strings representing valid numbers (integers, floats, scientific notation).",
            "Test with strings containing non-numeric characters (e.g., '10px', 'abc', '1.2.3').",
            "Test with strings containing only whitespace (should return 0, like empty string).",
            "Test with boolean `true` and `false`.",
            "Test with empty objects `{}` and empty arrays `[]`.",
            "Test with more complex objects/arrays."
          ],
          "hints": [
            "Consider using `Number.isNaN()` for checking `NaN` reliably.",
            "Regular expressions are powerful for validating string formats. You might need to build a regex that precisely matches valid numeric strings.",
            "Remember to handle leading/trailing whitespace in strings.",
            "`Number()` is stricter than `parseInt()`/`parseFloat()` for entire string validation.",
            "Pay close attention to the order of your checks, as some rules might override others."
          ],
          "tags": [
            "type-conversion",
            "data-validation",
            "edge-cases",
            "regular-expressions",
            "javascript-fundamentals"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_data_types"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "string-parsing",
            "data-sanitization",
            "robust-functions"
          ]
        },
        {
          "id": "task_sparse_array_iteration",
          "title": "Iterate and Process a Sparse Array",
          "description": "\nImplement a function `processSparseArray(arr)` that iterates over a potentially sparse array (an array with empty slots) and performs a specific operation only on existing elements, skipping the empty slots. The function should:\n\n1.  Take an array `arr` as input.\n2.  Use a `for` loop with a custom increment (e.g., iterating by 2, or skipping a certain number of elements).\n3.  For each *existing* element at the current `i`, double its value and add it to a `totalSum`.\n4.  Return the `totalSum`.\n5.  Ensure that `i + N` vs `i += N` distinction is handled correctly for your custom increment.\n6.  Handle cases where array elements are non-numeric or are empty slots.\n\n**Example of sparse array:** `[10, , 20, undefined, 30]`\n",
          "difficulty": "medium",
          "startingCode": "function processSparseArray(arr) {\n  let totalSum = 0;\n  // TODO: Implement the for loop and processing logic\n  // Iterate by steps of 2, summing only existing numeric values\n\n  for (let i = 0; i < arr.length; i += 2) { // Example increment by 2\n    // Check if the property exists and is a number\n    if (i in arr && typeof arr[i] === 'number') {\n      totalSum += arr[i] * 2; // Double the value of existing numeric elements\n    }\n  }\n\n  return totalSum;\n}\n\n// Example Usage (to be uncommented and tested):\n// console.log(processSparseArray([1, 2, 3, 4, 5, 6])); // Expected: 2 * (1 + 3 + 5) = 18\n// console.log(processSparseArray([10, , 20, undefined, 30])); // Expected: 2 * (10 + 20 + 30) = 120\n// console.log(processSparseArray([5, , 10, , 15, , 20])); // Expected: 2 * (5 + 10 + 15 + 20) = 100\n// console.log(processSparseArray([1, 'a', 3, null, 5])); // Expected: 2 * (1 + 3 + 5) = 18 (skip 'a' and null)\n// console.log(processSparseArray([])); // Expected: 0\n// console.log(processSparseArray([, , ,])); // Expected: 0\n",
          "solutionCode": "function processSparseArray(arr) {\n  let totalSum = 0;\n  \n  // Iterate with a custom increment of 2\n  for (let i = 0; i < arr.length; i += 2) { \n    // Check if the index is actually present in the array (not an empty slot)\n    // and if the value at that index is a number.\n    if (i in arr && typeof arr[i] === 'number') {\n      totalSum += arr[i] * 2; // Double the value and add to sum\n    }\n  }\n\n  return totalSum;\n}\n\n// Test cases\nconsole.log(`[1, 2, 3, 4, 5, 6] -> ${processSparseArray([1, 2, 3, 4, 5, 6])}`); // Expected: 2 * (1 + 3 + 5) = 18\nconsole.log(`[10, , 20, undefined, 30] -> ${processSparseArray([10, , 20, undefined, 30])}`); // Expected: 2 * (10 + 20 + 30) = 120\nconsole.log(`[5, , 10, , 15, , 20] -> ${processSparseArray([5, , 10, , 15, , 20])}`); // Expected: 2 * (5 + 10 + 15 + 20) = 100\nconsole.log(`[1, 'a', 3, null, 5] -> ${processSparseArray([1, 'a', 3, null, 5])}`); // Expected: 2 * (1 + 3 + 5) = 18\nconsole.log(`[] -> ${processSparseArray([])}`); // Expected: 0\nconsole.log(`[, , ,] -> ${processSparseArray([, , ,])}`); // Expected: 0\nconsole.log(`[0, 1, 2, 3, 4] -> ${processSparseArray([0, 1, 2, 3, 4])}`); // Expected: 2 * (0 + 2 + 4) = 12\n",
          "testCases": [
            "Test with a dense array (no empty slots).",
            "Test with a sparse array containing empty slots.",
            "Test with a sparse array containing `undefined` values (which are treated as existing, but possibly non-numeric).",
            "Test with array elements that are not numbers (strings, booleans, objects).",
            "Test with an empty array `[]`.",
            "Test with an array consisting entirely of empty slots `[, , ,]`.",
            "Test with `0` as an element value.",
            "Test a combination of sparse slots and non-numeric values."
          ],
          "hints": [
            "To check if an array index actually has a value (and isn't just an empty slot in a sparse array), use `i in arr` instead of just `arr[i] !== undefined`.",
            "Ensure your loop increment is `i += 2` (or `i = i + 2`) to actually update the counter.",
            "Remember to validate that the element is a `number` before performing arithmetic operations."
          ],
          "tags": [
            "arrays",
            "loops",
            "javascript-fundamentals",
            "edge-cases",
            "data-processing"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_javascript_operators_and_pitfalls",
            "theory_javascript_data_types"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "array-iteration",
            "sparse-arrays",
            "hasOwnProperty-in-operator"
          ]
        },
        {
          "id": "task_parse_mixed_data",
          "title": "Analyze and Calculate Mixed Data Expression",
          "description": "\nGiven a complex JavaScript expression involving numbers, strings, booleans, and `null`/`undefined` with various arithmetic and logical operators. Your task is to:\n\n1.  **Analyze**: Explain the step-by-step evaluation of the expression, detailing all implicit type coercions and operator behaviors.\n2.  **Predict**: State the final output of the expression.\n3.  **Refactor (Optional Bonus)**: Rewrite the expression using explicit type conversions and clearer logic to achieve the same result, or a clearly defined alternative if the original result is ambiguous/undesirable.\n\n**Expression:**\n```javascript\n5 + \"10\" - null + \"20\" + true - \"3\" - NaN\n```",
          "difficulty": "hard",
          "startingCode": "const expression = `5 + \"10\" - null + \"20\" + true - \"3\" - NaN`;\n\n// TODO: Analyze the expression step-by-step, predicting the output.\n// Then, (optional) refactor it for clarity/explicitness.\n\nconsole.log(\"Original Expression:\", expression);\nconsole.log(\"Predicted Output:\", /* Your predicted value here */);\n\n/* \nStep-by-step Analysis:\n1. ...\n2. ...\n...\n\nOptional Refactored Code:\n```javascript\n// Refactored version\n// ...\n```\n*/\n",
          "solutionCode": "const expression = `5 + \"10\" - null + \"20\" + true - \"3\" - NaN`;\n\nconsole.log(\"Original Expression:\", expression);\n\n/* \nStep-by-step Analysis:\n\nExpression: `5 + \"10\" - null + \"20\" + true - \"3\" - NaN`\n\nOperators are evaluated from left to right, respecting precedence. `+` and `-` have the same precedence, so they are evaluated left-to-right.\n\n1.  `5 + \"10\"`\n    *   `+` operator with a number and a string leads to string concatenation.\n    *   `5` is converted to `'5'`.\n    *   Result: `'510'` (string)\n\n2.  `'510' - null`\n    *   `-` operator with a string and `null` leads to numeric conversion.\n    *   `'510'` is converted to `510`.\n    *   `null` is converted to `0`.\n    *   Result: `510 - 0 = 510` (number)\n\n3.  `510 + \"20\"`\n    *   `+` operator with a number and a string leads to string concatenation.\n    *   `510` is converted to `'510'`.\n    *   Result: `'51020'` (string)\n\n4.  `'51020' + true`\n    *   `+` operator with a string and a boolean leads to string concatenation.\n    *   `true` is converted to `'true'`.\n    *   Result: `'51020true'` (string)\n\n5.  `'51020true' - \"3\"`\n    *   `-` operator with a string and a string leads to numeric conversion.\n    *   `'51020true'` cannot be converted entirely to a number, so it becomes `NaN`.\n    *   `\"3\"` is converted to `3`.\n    *   Result: `NaN - 3 = NaN` (number)\n\n6.  `NaN - NaN`\n    *   `NaN` minus `NaN` always results in `NaN`.\n    *   Result: `NaN` (number)\n\nPredicted Output: `NaN`\n*/\n\nconsole.log(\"Predicted Output:\", NaN);\n\n// Optional Refactored Code for a numeric sum:\nconsole.log(\"--- Refactored for numeric sum ---\");\n\n// To ensure numeric operations:\nconst num1 = 5;\nconst num2 = Number(\"10\"); // Explicit conversion\nconst num3 = Number(null); // Explicit conversion (0)\nconst num4 = Number(\"20\"); // Explicit conversion\nconst num5 = Number(true); // Explicit conversion (1)\nconst num6 = Number(\"3\");  // Explicit conversion\nconst num7 = NaN;\n\nconst numericResult = num1 + num2 - num3 + num4 + num5 - num6 - num7;\nconsole.log(\"Refactored Numeric Output:\", numericResult);\n// Breakdown of refactored numeric:\n// 5 + 10 - 0 + 20 + 1 - 3 - NaN\n// 15 - 0 + 20 + 1 - 3 - NaN\n// 15 + 20 + 1 - 3 - NaN\n// 35 + 1 - 3 - NaN\n// 36 - 3 - NaN\n// 33 - NaN = NaN (any arithmetic with NaN results in NaN)\n\n// If the intent was to sum all numbers and skip non-numbers / produce a numeric result even if some parts are invalid:\nfunction safeNumericSum(...args) {\n  let sum = 0;\n  for (const arg of args) {\n    const num = Number(arg);\n    if (!Number.isNaN(num)) {\n      sum += num;\n    }\n  }\n  return sum;\n}\n\n// Example of how you might want to interpret and sum the 'numbers' if non-numeric parts were ignored\nconsole.log(\"Safe Numeric Sum (ignoring non-numeric conversion parts):\");\nconsole.log(safeNumericSum(5, \"10\", null, \"20\", true, -\"3\", -NaN));\n// 5 + 10 + 0 + 20 + 1 + (-3) + NaN (NaN is skipped by safeNumericSum)\n// Result: 33\n",
          "testCases": [
            "Step-by-step analysis should correctly identify all intermediate values and type coercions.",
            "Final predicted output should be `NaN`.",
            "Refactored code (if implemented) should demonstrate explicit conversions and clearer intent.",
            "Refactored code should either yield the same result (if the original behavior is desired) or a clearly justified alternative (e.g., pure numeric sum)."
          ],
          "hints": [
            "Remember that the `+` operator behaves differently (concatenation vs. addition) based on its operands' types.",
            "Other arithmetic operators (`-`, `*`, `/`) generally force numeric conversion.",
            "Keep track of the type of the intermediate result at each step.",
            "Any arithmetic operation involving `NaN` will typically result in `NaN`.",
            "When refactoring, consider using `Number()` or `parseInt()`/`parseFloat()` explicitly to control type conversions."
          ],
          "tags": [
            "type-coercion",
            "operators",
            "edge-cases",
            "javascript-quirks",
            "debugging",
            "code-analysis"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 10,
          "interviewRelevance": 9,
          "learningPath": "expert",
          "relatedConcepts": [
            "operator-precedence",
            "implicit-conversion",
            "explicit-conversion",
            "NaN"
          ]
        },
        {
          "id": "task_safe_boolean_coercion",
          "title": "Create a `toBoolean` Utility Function",
          "description": "\nWrite a JavaScript utility function `toBoolean(value)` that converts any given value to a boolean, strictly following the standard JavaScript 'falsy' rules, but also offering an optional `strict` mode.\n\n**Requirements:**\n\n1.  **Standard Mode (default `strict = false`):**\n    *   Returns `true` for all 'truthy' values.\n    *   Returns `false` for all 'falsy' values (`false`, `0`, `-0`, `0n`, `''`, `null`, `undefined`, `NaN`).\n    *   This should behave identically to `Boolean(value)` or `!!value`.\n\n2.  **Strict Mode (`strict = true`):**\n    *   Returns `true` only if the `value` is the boolean `true`.\n    *   Returns `false` only if the `value` is the boolean `false`.\n    *   For any other value, it should return `null` (indicating neither a strict `true` nor a strict `false`).\n\nYour function signature should be `toBoolean(value, strict = false)`.\n",
          "difficulty": "medium",
          "startingCode": "function toBoolean(value, strict = false) {\n  if (strict) {\n    // TODO: Implement strict mode logic\n    if (value === true) {\n      return true;\n    } else if (value === false) {\n      return false;\n    } else {\n      return null;\n    }\n  } else {\n    // TODO: Implement standard mode logic (truthy/falsy)\n    return !!value;\n  }\n}\n\n// Example Usage (to be uncommented and tested):\n// console.log('--- Standard Mode ---');\n// console.log(`toBoolean(true): ${toBoolean(true)}`);       // Expected: true\n// console.log(`toBoolean(1): ${toBoolean(1)}`);         // Expected: true\n// console.log(`toBoolean('hello'): ${toBoolean('hello')}`);   // Expected: true\n// console.log(`toBoolean({}): ${toBoolean({})}`);         // Expected: true\n// console.log(`toBoolean([]): ${toBoolean([])}`);         // Expected: true\n\n// console.log(`toBoolean(false): ${toBoolean(false)}`);     // Expected: false\n// console.log(`toBoolean(0): ${toBoolean(0)}`);           // Expected: false\n// console.log(`toBoolean(''): ${toBoolean('')}`);         // Expected: false\n// console.log(`toBoolean(null): ${toBoolean(null)}`);       // Expected: false\n// console.log(`toBoolean(undefined): ${toBoolean(undefined)}`); // Expected: false\n// console.log(`toBoolean(NaN): ${toBoolean(NaN)}`);       // Expected: false\n\n// console.log('--- Strict Mode ---');\n// console.log(`toBoolean(true, true): ${toBoolean(true, true)}`);     // Expected: true\n// console.log(`toBoolean(false, true): ${toBoolean(false, true)}`);   // Expected: false\n// console.log(`toBoolean(1, true): ${toBoolean(1, true)}`);         // Expected: null\n// console.log(`toBoolean(0, true): ${toBoolean(0, true)}`);         // Expected: null\n// console.log(`toBoolean('hello', true): ${toBoolean('hello', true)}`); // Expected: null\n// console.log(`toBoolean(null, true): ${toBoolean(null, true)}`);     // Expected: null\n",
          "solutionCode": "function toBoolean(value, strict = false) {\n  if (strict) {\n    // Strict mode: Only true if value is strictly boolean true/false\n    if (value === true) {\n      return true;\n    } else if (value === false) {\n      return false;\n    } else {\n      return null; // For any other value, return null\n    }\n  } else {\n    // Standard mode: Use JavaScript's built-in truthiness/falsiness rules\n    return !!value;\n  }\n}\n\n// Test cases\nconsole.log('--- Standard Mode ---');\nconsole.log(`toBoolean(true): ${toBoolean(true)}`);       \nconsole.log(`toBoolean(1): ${toBoolean(1)}`);         \nconsole.log(`toBoolean('hello'): ${toBoolean('hello')}`);   \nconsole.log(`toBoolean({}): ${toBoolean({})}`);         \nconsole.log(`toBoolean([]): ${toBoolean([])}`);         \nconsole.log(`toBoolean(false): ${toBoolean(false)}`);     \nconsole.log(`toBoolean(0): ${toBoolean(0)}`);           \nconsole.log(`toBoolean(''): ${toBoolean('')}`);         \nconsole.log(`toBoolean(null): ${toBoolean(null)}`);       \nconsole.log(`toBoolean(undefined): ${toBoolean(undefined)}`); \nconsole.log(`toBoolean(NaN): ${toBoolean(NaN)}`);       \n\nconsole.log('--- Strict Mode ---');\nconsole.log(`toBoolean(true, true): ${toBoolean(true, true)}`);     \nconsole.log(`toBoolean(false, true): ${toBoolean(false, true)}`);   \nconsole.log(`toBoolean(1, true): ${toBoolean(1, true)}`);         \nconsole.log(`toBoolean(0, true): ${toBoolean(0, true)}`);           \nconsole.log(`toBoolean('hello', true): ${toBoolean('hello', true)}`); \nconsole.log(`toBoolean('', true): ${toBoolean('', true)}`);         \nconsole.log(`toBoolean(null, true): ${toBoolean(null, true)}`);     \nconsole.log(`toBoolean(undefined, true): ${toBoolean(undefined, true)}`); \nconsole.log(`toBoolean(NaN, true): ${toBoolean(NaN, true)}`);       \nconsole.log(`toBoolean([], true): ${toBoolean([], true)}`);         \nconsole.log(`toBoolean({}, true): ${toBoolean({}, true)}`);         \n",
          "testCases": [
            "Standard Mode: Test with `true`, `1`, `'abc'`, `{}`, `[]` (expected `true`).",
            "Standard Mode: Test with `false`, `0`, `''`, `null`, `undefined`, `NaN` (expected `false`).",
            "Strict Mode: Test with `true` (expected `true`).",
            "Strict Mode: Test with `false` (expected `false`).",
            "Strict Mode: Test with `1`, `0`, `'hello'`, `''`, `null`, `undefined`, `NaN`, `{}`, `[]` (expected `null` for all).",
            "Verify default parameter behavior (`toBoolean(value)` should behave as standard mode)."
          ],
          "hints": [
            "The `!!` operator is a concise way to convert any value to its boolean equivalent in standard JavaScript truthiness/falsiness.",
            "For strict mode, you'll need to use the strict equality operator (`===`) to check for the exact boolean values `true` or `false`."
          ],
          "tags": [
            "type-conversion",
            "boolean",
            "truthy-falsy",
            "utility-function",
            "edge-cases"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "strict-equality",
            "loose-equality",
            "conditional-logic"
          ]
        }
      ]
    }
  }
]