[
  {
    "id": "8602e28f-de57-433a-b42d-db72ef760a09",
    "startLine": 0,
    "endLine": 99,
    "processedDate": "2025-06-17T06:56:22.423Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_javascript_engine_execution_context",
          "title": "JavaScript Engine: Execution Context",
          "content": "The **Execution Context** is the environment in which JavaScript code is evaluated and executed. Whenever a function is called, or the global code starts running, a new execution context is created. It's an abstract concept that holds information about the current execution environment.\n\nEach execution context has three crucial components:\n\n1.  **Variable Environment**: This is where `var` declarations and function declarations are stored. In ES6+, `let` and `const` declarations are also managed here but are initialized differently (e.g., in the Temporal Dead Zone).\n2.  **Scope Chain**: This is a list of all accessible variable environments in the current context. It's used to resolve the value of variables. When JavaScript tries to find a variable, it first looks in the current execution context's variable environment, then in its outer environment, and so on, up the scope chain until it reaches the global execution context.\n3.  **`this` Binding**: This determines the value of the `this` keyword within the execution context. Its value depends on how the function was called (e.g., global, method, constructor, explicit binding with `call`/`apply`/`bind`, or arrow functions).\n\nThere are three main types of Execution Contexts:\n\n*   **Global Execution Context (GEC)**: The default or base execution context. It's created when the JavaScript file first loads. Anything not inside a function is in the global context. There's only one GEC.\n*   **Function Execution Context (FEC)**: Created whenever a function is called. Each function call creates its own unique FEC. This is why variables inside a function are local to it.\n*   **Eval Execution Context**: Created for code executed inside an `eval()` function. This is generally discouraged due to security and performance implications.\n\nJavaScript engines manage these contexts using a **Call Stack**. The Call Stack is a LIFO (Last In, First Out) data structure that keeps track of all the execution contexts created during the execution of a script. When an execution context is finished, it is popped off the stack.",
          "examples": [
            {
              "id": "example_execution_context_1",
              "title": "Global and Function Execution Contexts",
              "code": "let globalVar = 'I am global';\n\nfunction outerFunction() {\n  let outerVar = 'I am in outer';\n\n  function innerFunction() {\n    let innerVar = 'I am in inner';\n    console.log(globalVar);  // Accesses global execution context\n    console.log(outerVar);   // Accesses outer function's execution context (closure)\n    console.log(innerVar);   // Accesses its own execution context\n  }\n\n  innerFunction();\n}\n\nouterFunction();",
              "explanation": "This example demonstrates the creation of multiple execution contexts. When the script loads, the Global Execution Context is created. When `outerFunction()` is called, a new Function Execution Context for `outerFunction` is pushed onto the Call Stack. Similarly, when `innerFunction()` is called, its own Function Execution Context is pushed. Variables are resolved by traversing the scope chain upwards through these contexts.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_execution_context_1",
            "question_execution_context_2",
            "question_execution_context_3",
            "question_execution_context_4",
            "question_execution_context_5"
          ],
          "relatedTasks": [
            "task_scope_closure_chain"
          ],
          "tags": [
            "JavaScript Core",
            "Execution Context",
            "Call Stack",
            "Scope",
            "This"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_fundamentals",
            "functions"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "closures",
            "hoisting",
            "event_loop"
          ]
        },
        {
          "id": "theory_javascript_event_loop",
          "title": "JavaScript Event Loop and Asynchronous Behavior",
          "content": "The **Event Loop** is a fundamental concept in JavaScript that enables non-blocking, asynchronous behavior despite JavaScript being inherently single-threaded. This means JavaScript can only execute one piece of code at a time.\n\nTo handle operations that take time (like fetching data from a server, reading files, or user interactions), JavaScript offloads these tasks to **Web APIs** (or Node.js APIs in a Node environment). Once these tasks complete, their respective callback functions are placed into a **Task Queue** (also known as the Callback Queue or Macro-task Queue) or a **Micro-task Queue**.\n\n**Key Components of JavaScript Runtime Environment:**\n\n1.  **Call Stack**: This is a LIFO (Last In, First Out) data structure responsible for keeping track of all the functions being executed. When a function is called, it's pushed onto the stack. When it returns, it's popped off. JavaScript executes code synchronously, one function at a time, from top to bottom of the stack.\n2.  **Web APIs (Browser APIs / Node APIs)**: These are capabilities provided by the browser (e.g., `setTimeout`, `DOM`, `fetch`, `XMLHttpRequest`) or Node.js runtime (e.g., `fs`, `http`) that are *not* part of the core JavaScript engine. They handle asynchronous operations in the background.\n3.  **Callback Queue (Macro-task Queue)**: After a Web API task (like a `setTimeout` callback or an `XMLHttpRequest` callback) completes, its associated callback function is placed into this queue. Tasks in this queue are processed one by one after the Call Stack is empty.\n4.  **Micro-task Queue**: This queue has higher priority than the Callback Queue. It holds callbacks for promises (`.then()`, `.catch()`, `.finally()`) and `MutationObserver` callbacks. All micro-tasks are processed and cleared *before* the event loop moves to the next macro-task.\n5.  **Event Loop**: This is the continuous process that orchestrates the execution. Its primary job is to monitor the Call Stack and the various task queues. When the Call Stack is empty, it first checks the Micro-task Queue. If there are micro-tasks, it moves them to the Call Stack for execution until the Micro-task Queue is empty. After the Micro-task Queue is empty, it then checks the Callback Queue. If there are tasks there, it takes the first one and pushes it onto the Call Stack. This cycle repeats indefinitely.\n\nThis mechanism ensures that long-running operations do not block the main thread, keeping the user interface responsive and allowing JavaScript to handle multiple operations concurrently.",
          "examples": [
            {
              "id": "example_event_loop_1",
              "title": "setTimeout and Promise Interaction",
              "code": "console.log('1. Start');\n\nsetTimeout(() => {\n  console.log('4. setTimeout callback');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3. Promise micro-task');\n});\n\nconsole.log('2. End');\n\n// Expected output:\n// 1. Start\n// 2. End\n// 3. Promise micro-task\n// 4. setTimeout callback",
              "explanation": "This example illustrates the order of execution due to the Event Loop:\n1.  `'1. Start'` is logged synchronously.\n2.  `setTimeout` is sent to the Web API. Its callback is placed in the Macro-task Queue after 0ms.\n3.  `Promise.resolve().then()` is executed. Its callback is placed in the Micro-task Queue.\n4.  `'2. End'` is logged synchronously.\n5.  The Call Stack is now empty. The Event Loop checks the Micro-task Queue first, finds the Promise callback, and moves it to the Call Stack. `'3. Promise micro-task'` is logged.\n6.  The Micro-task Queue is empty. The Event Loop then checks the Macro-task Queue, finds the `setTimeout` callback, and moves it to the Call Stack. `'4. setTimeout callback'` is logged.\nThis demonstrates the higher priority of micro-tasks over macro-tasks.",
              "language": "javascript"
            },
            {
              "id": "example_event_loop_2",
              "title": "Complex Asynchronous Flow",
              "code": "console.log('Script Start');\n\nsetTimeout(() => {\n  console.log('setTimeout 1');\n  Promise.resolve().then(() => {\n    console.log('Promise inside setTimeout');\n  });\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n  setTimeout(() => {\n    console.log('setTimeout inside Promise');\n  }, 0);\n});\n\nconsole.log('Script End');\n\n// Expected Output:\n// Script Start\n// Script End\n// Promise 1\n// Promise inside setTimeout\n// setTimeout 1\n// setTimeout inside Promise",
              "explanation": "This example further clarifies the Event Loop's behavior:\n1.  **Script Start** and **Script End** are logged synchronously.\n2.  `setTimeout 1` callback goes to Macro-task Queue.\n3.  `Promise 1` callback goes to Micro-task Queue.\n4.  After the synchronous code, the Call Stack is empty. The Event Loop prioritizes the Micro-task Queue. `Promise 1` is executed, logging 'Promise 1'. Inside this promise, `setTimeout inside Promise` is added to the Macro-task Queue.\n5.  Micro-task Queue is now empty (for the first tick). The Event Loop then checks the Macro-task Queue. `setTimeout 1` is executed, logging 'setTimeout 1'. Inside this `setTimeout`, `Promise inside setTimeout` is added to the Micro-task Queue.\n6.  The Call Stack is empty again. The Event Loop checks Micro-task Queue, `Promise inside setTimeout` is executed, logging 'Promise inside setTimeout'.\n7.  Micro-task Queue is empty. Event Loop checks Macro-task Queue. `setTimeout inside Promise` is executed, logging 'setTimeout inside Promise'.\nThis cyclical processing demonstrates the continuous interaction between synchronous code, micro-tasks, and macro-tasks orchestrated by the Event Loop.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_event_loop_1",
            "question_event_loop_2",
            "question_event_loop_3",
            "question_event_loop_4",
            "question_event_loop_5",
            "question_event_loop_6",
            "question_event_loop_7"
          ],
          "relatedTasks": [
            "task_event_loop_prediction",
            "task_async_data_fetch"
          ],
          "tags": [
            "JavaScript Core",
            "Event Loop",
            "Asynchronous JavaScript",
            "Call Stack",
            "Web APIs",
            "Task Queue",
            "Micro-task Queue",
            "Concurrency"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_fundamentals",
            "promises_async_await"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "requiredFor": [
            "promises_async_await",
            "frontend_performance",
            "understanding_ui_responsiveness"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_execution_context_1",
          "topic": "JavaScript Execution Context",
          "level": "easy",
          "type": "flashcard",
          "question": "What is an Execution Context in JavaScript?",
          "answer": "The environment where JavaScript code is evaluated and executed.",
          "analysisPoints": [
            "Understanding of fundamental JavaScript execution model.",
            "Ability to define core concepts concisely."
          ],
          "keyConcepts": [
            "Execution Context"
          ],
          "evaluationCriteria": [
            "Direct recall",
            "Conceptual understanding"
          ],
          "example": "",
          "tags": [
            "JavaScript Core",
            "Execution Context"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_execution_context_2",
          "topic": "Components of Execution Context",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a primary component of a JavaScript Execution Context?",
          "answer": "DOM Tree",
          "options": [
            "Variable Environment",
            "Scope Chain",
            "This Binding",
            "DOM Tree"
          ],
          "analysisPoints": [
            "Distinguishing between core JavaScript runtime components and browser APIs.",
            "Knowledge of the internal structure of an Execution Context."
          ],
          "keyConcepts": [
            "Execution Context",
            "Variable Environment",
            "Scope Chain",
            "This Binding",
            "DOM"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to distinguish between similar concepts"
          ],
          "example": "The DOM Tree is part of the Web API provided by the browser, allowing interaction with HTML elements, but it's not a direct component of the JavaScript Execution Context itself, which defines the immediate runtime environment for JavaScript code.",
          "tags": [
            "JavaScript Core",
            "Execution Context"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_execution_context_3",
          "topic": "Types of Execution Contexts",
          "level": "medium",
          "type": "open",
          "question": "Describe the three main types of Execution Contexts in JavaScript and their characteristics.",
          "answer": "The three main types of Execution Contexts are:\n\n1.  **Global Execution Context (GEC)**: This is the default context created when a JavaScript file first loads in a browser or Node.js environment. All global code (code not inside any function) runs within the GEC. There is only one GEC for any given JavaScript environment, and it's the first context pushed onto the Call Stack.\n2.  **Function Execution Context (FEC)**: A new FEC is created every time a function is called. Each function call gets its own distinct execution context, meaning its own variable environment, scope chain, and `this` binding. This allows functions to have local variables and their own isolated scope.\n3.  **Eval Execution Context**: This context is created specifically for code executed within the `eval()` function. Its use is generally discouraged due to security risks (executing arbitrary code) and performance implications (difficulty for engines to optimize).",
          "analysisPoints": [
            "Ability to identify and differentiate between GEC, FEC, and Eval contexts.",
            "Understanding of when each context is created.",
            "Awareness of the implications of using `eval()`."
          ],
          "keyConcepts": [
            "Global Execution Context",
            "Function Execution Context",
            "Eval Execution Context",
            "Call Stack"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of each type",
            "Clarity and accuracy of definitions",
            "Knowledge of best practices (regarding `eval`)"
          ],
          "example": "",
          "tags": [
            "JavaScript Core",
            "Execution Context",
            "Scope"
          ],
          "prerequisites": [
            "javascript_fundamentals",
            "functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_execution_context_4",
          "topic": "Call Stack",
          "level": "easy",
          "type": "flashcard",
          "question": "What data structure does the JavaScript engine use to manage Execution Contexts?",
          "answer": "Call Stack (or Execution Stack)",
          "analysisPoints": [
            "Recall of fundamental data structures in JavaScript runtime.",
            "Understanding the LIFO principle."
          ],
          "keyConcepts": [
            "Call Stack",
            "Execution Context"
          ],
          "evaluationCriteria": [
            "Direct recall",
            "Accuracy"
          ],
          "example": "",
          "tags": [
            "JavaScript Core",
            "Call Stack"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_execution_context_5",
          "topic": "Scope Chain and Variable Resolution",
          "level": "medium",
          "type": "open",
          "question": "How does the 'Scope Chain' within an Execution Context help JavaScript resolve variable values?",
          "answer": "The Scope Chain is an ordered list of references to the variable environments of outer (lexical) execution contexts. When JavaScript tries to resolve the value of a variable, it starts by looking in the *current* execution context's Variable Environment. If the variable is not found there, it then looks in the variable environment of the immediate *outer* execution context (the one where the function was defined, not where it was called). This process continues up the chain, context by context, until the variable is found or the Global Execution Context is reached. If the variable is not found anywhere in the scope chain, a `ReferenceError` is thrown. This mechanism is crucial for how closures work.",
          "analysisPoints": [
            "Understanding the hierarchical nature of scope resolution.",
            "Connecting scope chain to lexical environment and closures.",
            "Knowledge of `ReferenceError`."
          ],
          "keyConcepts": [
            "Scope Chain",
            "Variable Environment",
            "Lexical Scope",
            "Closures",
            "ReferenceError"
          ],
          "evaluationCriteria": [
            "Clear explanation of the search process",
            "Connection to practical implications (e.g., closures)",
            "Correct handling of unfound variables"
          ],
          "example": "",
          "tags": [
            "JavaScript Core",
            "Execution Context",
            "Scope",
            "Closures"
          ],
          "prerequisites": [
            "javascript_fundamentals",
            "functions",
            "scope_hoisting"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_1",
          "topic": "Event Loop Basic",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of the Event Loop in JavaScript?",
          "answer": "To enable non-blocking, asynchronous behavior by continuously checking if the Call Stack is empty and moving tasks from the Task Queues to the Call Stack for execution.",
          "analysisPoints": [
            "Core function of the Event Loop.",
            "Understanding of single-threaded nature of JavaScript."
          ],
          "keyConcepts": [
            "Event Loop",
            "Asynchronous JavaScript",
            "Call Stack"
          ],
          "evaluationCriteria": [
            "Direct recall",
            "Conciseness"
          ],
          "example": "",
          "tags": [
            "JavaScript Core",
            "Event Loop",
            "Asynchronous"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_loop_2",
          "topic": "Event Loop Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT considered a core component involved in the JavaScript Event Loop mechanism?",
          "answer": "Virtual DOM",
          "options": [
            "Call Stack",
            "Web APIs",
            "Micro-task Queue",
            "Virtual DOM"
          ],
          "analysisPoints": [
            "Identifying the key parts of the JavaScript runtime that facilitate asynchronous operations.",
            "Distinguishing between core JavaScript concepts and framework-specific implementations."
          ],
          "keyConcepts": [
            "Event Loop",
            "Call Stack",
            "Web APIs",
            "Micro-task Queue",
            "Virtual DOM"
          ],
          "evaluationCriteria": [
            "Accurate identification of event loop components",
            "Understanding the scope of JavaScript runtime"
          ],
          "example": "The Virtual DOM is a concept specific to React (and similar libraries) used for efficient UI updates. It is not an intrinsic component of the JavaScript Event Loop or the broader JavaScript runtime environment.",
          "tags": [
            "JavaScript Core",
            "Event Loop",
            "React",
            "Virtual DOM"
          ],
          "prerequisites": [
            "javascript_fundamentals",
            "web_apis"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_3",
          "topic": "Macro-task vs. Micro-task Queue",
          "level": "hard",
          "type": "open",
          "question": "Explain the difference between the Macro-task Queue (Callback Queue) and the Micro-task Queue, and how the Event Loop prioritizes tasks from them.",
          "answer": "Both Macro-task and Micro-task Queues hold asynchronous callbacks that are waiting to be executed, but they have different priorities and types of tasks:\n\n1.  **Macro-task Queue (Callback Queue)**: This queue holds 'larger' asynchronous tasks like `setTimeout()`, `setInterval()`, `setImmediate()` (Node.js specific), I/O operations (e.g., network requests like `XMLHttpRequest`), and UI rendering events. The Event Loop processes *one* macro-task per cycle (or 'tick') after the Call Stack is empty.\n2.  **Micro-task Queue**: This queue holds 'smaller', higher-priority asynchronous tasks, primarily promise callbacks (`.then()`, `.catch()`, `.finally()`) and `MutationObserver` callbacks. The Event Loop processes *all* micro-tasks in the micro-task queue *after* the Call Stack is empty but *before* it moves on to pick up the next macro-task. This means that all micro-tasks generated within a single macro-task execution (or the initial script execution) will complete before any subsequent macro-task runs.\n\n**Prioritization:** The Event Loop has a specific order of operation:\n    *   It first executes all synchronous code in the Call Stack.\n    *   Once the Call Stack is empty, it drains *all* tasks from the Micro-task Queue.\n    *   If the Micro-task Queue is empty, it then picks *one* task from the Macro-task Queue and pushes it to the Call Stack.\n    *   This cycle repeats.",
          "analysisPoints": [
            "Clear differentiation between task types in each queue.",
            "Accurate description of the Event Loop's prioritization rules.",
            "Understanding the 'drain all micro-tasks before next macro-task' concept."
          ],
          "keyConcepts": [
            "Event Loop",
            "Macro-task Queue",
            "Micro-task Queue",
            "Promises",
            "setTimeout",
            "Call Stack"
          ],
          "evaluationCriteria": [
            "Depth of explanation",
            "Accuracy of prioritization mechanism",
            "Relevant examples of task types"
          ],
          "example": "",
          "tags": [
            "JavaScript Core",
            "Event Loop",
            "Asynchronous",
            "Promises"
          ],
          "prerequisites": [
            "promises_async_await"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_loop_4",
          "topic": "Event Loop Prediction - Basic",
          "level": "medium",
          "type": "code",
          "question": "Predict the output of the following JavaScript code snippet. Explain your reasoning based on the Event Loop.",
          "answer": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nconsole.log('End');\n\n// Expected Output:\n// Start\n// End\n// Timeout",
          "options": [],
          "analysisPoints": [
            "Ability to distinguish synchronous vs. asynchronous execution.",
            "Understanding that `setTimeout(0)` is still asynchronous and deferred.",
            "Knowledge of Call Stack and Macro-task Queue interaction."
          ],
          "keyConcepts": [
            "Event Loop",
            "Call Stack",
            "setTimeout",
            "Macro-task Queue"
          ],
          "evaluationCriteria": [
            "Correct output prediction",
            "Clear explanation of execution flow",
            "Reference to Event Loop mechanics"
          ],
          "example": "```javascript\nconsole.log('Start'); // Synchronous: runs immediately and goes to Call Stack\n\nsetTimeout(() => {\n  console.log('Timeout'); // Asynchronous: callback sent to Web API, then Macro-task Queue\n}, 0);\n\nconsole.log('End'); // Synchronous: runs immediately after 'Start'\n\n// Execution Flow:\n// 1. 'Start' is logged.\n// 2. setTimeout is registered with the Web API. Its callback function is moved to the Macro-task Queue after 0ms.\n// 3. 'End' is logged.\n// 4. The Call Stack is now empty. The Event Loop checks the Macro-task Queue and moves the 'Timeout' callback to the Call Stack.\n// 5. 'Timeout' is logged.\n```",
          "tags": [
            "JavaScript Core",
            "Event Loop",
            "Asynchronous",
            "Coding Challenge"
          ],
          "prerequisites": [
            "javascript_fundamentals",
            "setTimeout"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_5",
          "topic": "Event Loop Prediction - Advanced",
          "level": "hard",
          "type": "code",
          "question": "Predict the exact order of console logs for the following JavaScript code. Justify your answer by detailing how the Event Loop processes the different tasks.",
          "answer": "console.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n  Promise.resolve().then(() => console.log('C'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('D');\n  setTimeout(() => console.log('E'), 0);\n});\n\nconsole.log('F');\n\n// Expected Output:\n// A\n// F\n// D\n// C\n// B\n// E",
          "options": [],
          "analysisPoints": [
            "In-depth understanding of macro-task vs. micro-task priority.",
            "Ability to trace callbacks generated within other callbacks.",
            "Accurate application of Event Loop rules across multiple cycles."
          ],
          "keyConcepts": [
            "Event Loop",
            "Call Stack",
            "Macro-task Queue",
            "Micro-task Queue",
            "Promises",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Precisely correct output order",
            "Detailed and accurate step-by-step explanation of Event Loop behavior",
            "Demonstrates mastery of asynchronous JavaScript."
          ],
          "example": "```javascript\nconsole.log('A'); // Sync\n\nsetTimeout(() => { // Macro-task 1\n  console.log('B');\n  Promise.resolve().then(() => console.log('C')); // Micro-task 2 (nested)\n}, 0);\n\nPromise.resolve().then(() => { // Micro-task 1\n  console.log('D');\n  setTimeout(() => console.log('E'), 0); // Macro-task 2 (nested)\n});\n\nconsole.log('F'); // Sync\n\n// Step-by-step Execution:\n// 1. **Initial Sync Execution:**\n//    - 'A' is logged. Call Stack: [log('A')]\n//    - setTimeout(B, C) is sent to Web API, then its callback goes to Macro-task Queue (MQ1).\n//    - Promise.then(D, E) is sent to Micro-task Queue (MiQ1).\n//    - 'F' is logged. Call Stack: [log('F')]\n//    - Call Stack becomes empty.\n//    Output so far: A, F\n\n// 2. **Event Loop Cycle 1: Drain Micro-task Queue:**\n//    - Event Loop sees MiQ1. Moves `Promise.then(D,E)` to Call Stack.\n//    - 'D' is logged.\n//    - `setTimeout(E)` is sent to Web API, then its callback goes to Macro-task Queue (MQ2).\n//    - Call Stack becomes empty.\n//    Output so far: A, F, D\n\n// 3. **Event Loop Cycle 1: Drain Micro-task Queue (again, it was modified):**\n//    - Micro-task Queue is currently empty. (No 'C' yet, it's not even registered).\n\n// 4. **Event Loop Cycle 1: Pick one Macro-task:**\n//    - Event Loop sees MQ1. Moves `setTimeout(B,C)` to Call Stack.\n//    - 'B' is logged.\n//    - `Promise.resolve().then(() => console.log('C'))` is sent to Micro-task Queue (MiQ2).\n//    - Call Stack becomes empty.\n//    Output so far: A, F, D, B\n\n// 5. **Event Loop Cycle 2: Drain Micro-task Queue:**\n//    - Event Loop sees MiQ2. Moves `Promise.then(C)` to Call Stack.\n//    - 'C' is logged.\n//    - Call Stack becomes empty.\n//    Output so far: A, F, D, B, C\n\n// 6. **Event Loop Cycle 2: Pick one Macro-task:**\n//    - Event Loop sees MQ2. Moves `setTimeout(E)` to Call Stack.\n//    - 'E' is logged.\n//    - Call Stack becomes empty.\n//    Output so far: A, F, D, B, C, E\n\n// All queues are empty. Script finishes.\n```",
          "tags": [
            "JavaScript Core",
            "Event Loop",
            "Asynchronous",
            "Promises",
            "setTimeout",
            "Coding Challenge"
          ],
          "prerequisites": [
            "promises_async_await",
            "event_loop_intermediate"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_loop_6",
          "topic": "Blocking the Event Loop",
          "level": "medium",
          "type": "open",
          "question": "What does it mean to 'block the Event Loop'? Provide an example and explain its consequences for a frontend application.",
          "answer": "To 'block the Event Loop' means to perform a long-running, synchronous operation on the main thread (Call Stack) that prevents the Event Loop from pushing other tasks (from the Macro-task or Micro-task queues) onto the Call Stack for execution. Since JavaScript is single-threaded, if the main thread is busy with a synchronous task, it cannot process any other events or update the UI.\n\n**Example:**\n```javascript\nconsole.log('Start');\n\nfunction longRunningTask() {\n  let i = 0;\n  while (i < 5000000000) { // A very long loop\n    i++;\n  }\n  console.log('Long task finished');\n}\n\nsetTimeout(() => {\n  console.log('Timeout callback (will be delayed)');\n}, 0);\n\nlongRunningTask();\n\nconsole.log('End');\n```\nIn this example, the `longRunningTask` will execute fully before `setTimeout`'s callback can be processed, even though `setTimeout` has a 0ms delay. The browser tab might become unresponsive or 'frozen' during the `while` loop.\n\n**Consequences for a frontend application:**\n*   **Unresponsive UI**: The user interface will freeze. Users cannot click buttons, type into input fields, or scroll. Animations will stop.\n*   **Poor User Experience (UX)**: Users perceive the application as slow or crashed, leading to frustration and potentially abandoning the application.\n*   **Delayed Interactions**: Any pending user interactions, network responses, or timers will not be processed until the blocking code finishes, leading to noticeable lag.\n*   **Browser Warnings/Crashes**: Browsers might display a 'Page Unresponsive' warning, asking the user to kill the page.",
          "analysisPoints": [
            "Definition of blocking the Event Loop.",
            "Demonstration with a clear synchronous blocking example.",
            "Explanation of negative impacts on UI and UX.",
            "Connection to single-threaded nature of JavaScript."
          ],
          "keyConcepts": [
            "Event Loop",
            "Single-threaded",
            "Blocking",
            "UI Responsiveness",
            "Performance"
          ],
          "evaluationCriteria": [
            "Accurate definition",
            "Effective example",
            "Comprehensive description of consequences"
          ],
          "example": "```javascript\n// See answer for example code.\n```",
          "tags": [
            "JavaScript Core",
            "Event Loop",
            "Performance",
            "Blocking",
            "UX"
          ],
          "prerequisites": [
            "javascript_fundamentals",
            "event_loop_basic"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_loop_7",
          "topic": "Web APIs",
          "level": "easy",
          "type": "flashcard",
          "question": "Name three common Web APIs that interact with the Event Loop.",
          "answer": "1.  `setTimeout()`\n2.  `fetch()` (or `XMLHttpRequest`)\n3.  DOM manipulation functions (e.g., `addEventListener`)\n\n*(Other valid answers include `setInterval()`, `FileReader`, Web Workers, Geolocation API, etc.)*",
          "analysisPoints": [
            "Identifying functions that are not part of the core JS engine.",
            "Understanding how asynchronous operations are initiated."
          ],
          "keyConcepts": [
            "Web APIs",
            "Event Loop",
            "setTimeout",
            "Fetch API",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Direct recall",
            "Correct examples"
          ],
          "example": "",
          "tags": [
            "JavaScript Core",
            "Web APIs",
            "Event Loop"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_event_loop_prediction",
          "title": "Predict and Explain Event Loop Execution Order",
          "description": "\nGiven a JavaScript code snippet that uses a combination of synchronous code, `setTimeout`, and `Promise.resolve().then()`, your task is to:\n\n1.  **Predict the exact order of console logs.**\n2.  **Provide a step-by-step explanation** of how the JavaScript Event Loop processes these operations, detailing the roles of the Call Stack, Web APIs, Micro-task Queue, and Macro-task Queue.\n\nThis task assesses your deep understanding of asynchronous JavaScript and the Event Loop.\n",
          "difficulty": "hard",
          "startingCode": "function runEventLoopPuzzle() {\n  console.log('A');\n\n  setTimeout(() => {\n    console.log('B');\n    Promise.resolve().then(() => console.log('C'));\n  }, 0);\n\n  Promise.resolve().then(() => {\n    console.log('D');\n    setTimeout(() => console.log('E'), 0);\n  });\n\n  console.log('F');\n}\n\nrunEventLoopPuzzle();",
          "solutionCode": "function runEventLoopPuzzle() {\n  console.log('A');\n\n  setTimeout(() => {\n    console.log('B');\n    Promise.resolve().then(() => console.log('C'));\n  }, 0);\n\n  Promise.resolve().then(() => {\n    console.log('D');\n    setTimeout(() => console.log('E'), 0);\n  });\n\n  console.log('F');\n}\n\nrunEventLoopPuzzle();\n\n/*\nExpected Output:\nA\nF\nD\nB\nC\nE\n\nDetailed Explanation:\n\n1.  **Initial Synchronous Execution:**\n    - `console.log('A')` executes. 'A' is logged. (Call Stack: [log('A')])\n    - `setTimeout(() => { console.log('B'); ... }, 0)` is encountered. The callback function is registered with the Web API. After 0ms, it's moved to the **Macro-task Queue** (let's call it MQ1).\n    - `Promise.resolve().then(() => { console.log('D'); ... })` is encountered. The promise resolves immediately. Its `.then()` callback is moved to the **Micro-task Queue** (let's call it MiQ1).\n    - `console.log('F')` executes. 'F' is logged. (Call Stack: [log('F')])\n    - The Call Stack becomes empty.\n    Current output: A, F\n    MQ: [MQ1 (for 'B', 'C')]\n    MiQ: [MiQ1 (for 'D', 'E')]\n\n2.  **Event Loop Tick 1: Draining Micro-task Queue (MiQ1):**\n    - The Event Loop checks the Call Stack (empty) and then the Micro-task Queue.\n    - MiQ1 (the promise callback for 'D', 'E') is moved to the Call Stack.\n    - `console.log('D')` executes. 'D' is logged.\n    - `setTimeout(() => console.log('E'), 0)` is encountered. Its callback is registered with the Web API and then moved to the **Macro-task Queue** (MQ2).\n    - The Call Stack becomes empty.\n    Current output: A, F, D\n    MQ: [MQ1 (for 'B', 'C'), MQ2 (for 'E')]\n    MiQ: []\n\n3.  **Event Loop Tick 1: Picking one Macro-task (MQ1):**\n    - The Event Loop checks the Call Stack (empty) and then the Micro-task Queue (empty). It then picks *one* task from the Macro-task Queue.\n    - MQ1 (the `setTimeout` callback for 'B', 'C') is moved to the Call Stack.\n    - `console.log('B')` executes. 'B' is logged.\n    - `Promise.resolve().then(() => console.log('C'))` is encountered. The promise resolves immediately. Its `.then()` callback is moved to the **Micro-task Queue** (MiQ2).\n    - The Call Stack becomes empty.\n    Current output: A, F, D, B\n    MQ: [MQ2 (for 'E')]\n    MiQ: [MiQ2 (for 'C')]\n\n4.  **Event Loop Tick 2: Draining Micro-task Queue (MiQ2):**\n    - The Event Loop checks the Call Stack (empty) and then the Micro-task Queue.\n    - MiQ2 (the promise callback for 'C') is moved to the Call Stack.\n    - `console.log('C')` executes. 'C' is logged.\n    - The Call Stack becomes empty.\n    Current output: A, F, D, B, C\n    MQ: [MQ2 (for 'E')]\n    MiQ: []\n\n5.  **Event Loop Tick 2: Picking one Macro-task (MQ2):**\n    - The Event Loop checks the Call Stack (empty) and then the Micro-task Queue (empty). It then picks *one* task from the Macro-task Queue.\n    - MQ2 (the `setTimeout` callback for 'E') is moved to the Call Stack.\n    - `console.log('E')` executes. 'E' is logged.\n    - The Call Stack becomes empty.\n    Current output: A, F, D, B, C, E\n    MQ: []\n    MiQ: []\n\nAll queues are now empty, and the script finishes execution.\n*/",
          "testCases": [
            "The output must match 'A', 'F', 'D', 'B', 'C', 'E' in exact order.",
            "The explanation should correctly describe the roles of Call Stack, Web APIs, Macro-task Queue, and Micro-task Queue.",
            "The explanation should correctly illustrate the prioritization of micro-tasks over macro-tasks."
          ],
          "hints": [
            "Remember that synchronous code always executes first.",
            "Promises (`.then()`) always go to the Micro-task Queue, which is drained completely before any Macro-tasks are processed.",
            "`setTimeout` callbacks go to the Macro-task Queue.",
            "Each full 'tick' of the Event Loop involves draining the Micro-task Queue completely before picking just *one* Macro-task."
          ],
          "tags": [
            "JavaScript Core",
            "Event Loop",
            "Asynchronous",
            "Promises",
            "setTimeout",
            "Coding Challenge"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "promises_async_await",
            "javascript_engine_execution_context",
            "theory_javascript_event_loop"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Call Stack",
            "Web APIs",
            "Macro-task Queue",
            "Micro-task Queue"
          ]
        },
        {
          "id": "task_async_data_fetch",
          "title": "Simulate Asynchronous Data Fetching with UI Update",
          "description": "\nImplement a function `fetchAndDisplayData` that simulates fetching user data from an API and then updating a DOM element with the received data. This task aims to test your understanding of asynchronous operations, handling delays, and basic DOM manipulation within the context of the Event Loop.\n\n**Requirements:**\n\n1.  The `fetchAndDisplayData` function should take a `userId` as an argument.\n2.  Inside `fetchAndDisplayData`, simulate an API call using `setTimeout` with a delay of at least 500ms.\n3.  The simulated API should return a user object (e.g., `{ id: userId, name: 'John Doe', email: 'john@example.com' }`).\n4.  After the 'data fetch' is complete, simulate a UI update by calling a function `updateDisplay(data)` which logs a message indicating the data has been displayed.\n5.  Add `console.log` statements at the start and end of `fetchAndDisplayData` to observe its execution flow.\n6.  Ensure the main script flow is not blocked while the 'fetch' is ongoing.\n",
          "difficulty": "medium",
          "startingCode": "function updateDisplay(data) {\n  console.log(`Displaying data for user: ${data.name} (ID: ${data.id})`);\n  // In a real app, you would update a DOM element here.\n}\n\nfunction fetchAndDisplayData(userId) {\n  console.log(`Starting data fetch for user ${userId}...`);\n\n  // TODO: Simulate an API call with setTimeout\n  // TODO: Resolve with a user object like { id: userId, name: '...', email: '...' }\n  // TODO: Call updateDisplay with the fetched data\n\n  console.log(`Data fetch initiated for user ${userId}.`);\n}\n\n// Example usage:\nfetchAndDisplayData(123);\nconsole.log('Application continues running while data fetches...');\n\n// Expected (rough) output order:\n// Starting data fetch for user 123...\n// Data fetch initiated for user 123.\n// Application continues running while data fetches...\n// Displaying data for user: John Doe (ID: 123)",
          "solutionCode": "function updateDisplay(data) {\n  console.log(`Displaying data for user: ${data.name} (ID: ${data.id})`);\n  // In a real app, you would update a DOM element here.\n  // Example: document.getElementById('user-info').innerText = `User: ${data.name}`; \n}\n\nfunction fetchAndDisplayData(userId) {\n  console.log(`Starting data fetch for user ${userId}...`);\n\n  // Simulate an API call with setTimeout\n  setTimeout(() => {\n    const userData = {\n      id: userId,\n      name: `User Name ${userId}`,\n      email: `user${userId}@example.com`\n    };\n    console.log(`Simulated API response received for user ${userId}.`);\n    updateDisplay(userData); // Call updateDisplay with the fetched data\n  }, 500); // Simulate network latency\n\n  console.log(`Data fetch initiated for user ${userId}.`);\n}\n\n// Example usage:\nfetchAndDisplayData(123);\nconsole.log('Application continues running while data fetches...');\n\nfetchAndDisplayData(456);\nconsole.log('Another fetch initiated...');",
          "testCases": [
            "Calling `fetchAndDisplayData` should immediately log 'Starting...' and 'Data fetch initiated...', demonstrating non-blocking behavior.",
            "The `updateDisplay` message should appear *after* 'Application continues running...', confirming asynchronous processing.",
            "Calling `fetchAndDisplayData` multiple times should result in correct data for each call, indicating proper closure/scope handling for `userId`.",
            "The delay introduced by `setTimeout` should be respected before `updateDisplay` is called."
          ],
          "hints": [
            "`setTimeout` is your primary tool for simulating asynchronous operations that interact with the Event Loop.",
            "Pay attention to the order of `console.log` statements to verify your understanding of synchronous vs. asynchronous execution.",
            "Ensure the `userId` passed to `fetchAndDisplayData` is correctly used within the `setTimeout` callback."
          ],
          "tags": [
            "JavaScript Core",
            "Asynchronous",
            "Event Loop",
            "setTimeout",
            "DOM Manipulation",
            "Frontend Fundamentals"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "javascript_fundamentals",
            "theory_javascript_event_loop"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Web APIs",
            "Callback Queue",
            "Non-blocking I/O"
          ]
        }
      ]
    }
  },
  {
    "id": "78e4b679-6da5-4d51-818d-03c853484d41",
    "startLine": 100,
    "endLine": 199,
    "processedDate": "2025-06-17T06:57:54.052Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_event_loop",
          "title": "The JavaScript Event Loop and Asynchronous Programming",
          "content": "The JavaScript Event Loop is a fundamental concept for understanding how JavaScript, a single-threaded language, handles asynchronous operations without blocking the main execution thread. It orchestrates the execution of code, prioritizing different types of tasks.\n\n## Key Components:\n\n1.  **Call Stack**: This is a Last-In, First-Out (LIFO) stack that stores the execution context of the program. When a function is called, it's pushed onto the stack. When it returns, it's popped off. JavaScript executes whatever is at the top of the call stack.\n    *   ![JavaScript Call Stack 1](images/event_loop_2.jpeg)\n    *   ![JavaScript Call Stack 2](images/event_loop_3.jpeg)\n    *   ![JavaScript Call Stack 3](images/event_loop_4.jpeg)\n    *   ![JavaScript Call Stack 4](images/event_loop_5.jpeg)\n    *   The sequence above shows how functions enter and exit the call stack, and how asynchronous callbacks are processed.\n\n2.  **Web APIs (Browser APIs / Node.js APIs)**: These are environmentspecific functionalities provided by the browser (like `setTimeout`, `fetch`, `DOM` events, `XMLHttpRequest`) or Node.js (like `fs.readFile`). When an asynchronous function is called, it's handed over to a Web API, which performs the operation in the background.\n    *   ![JavaScript Event Loop 7](images/event_loop_6.jpeg)\n    *   The diagram above shows how the Event Loop connects the Call Stack, Web APIs, and Callback Queue.\n\n3.  **Callback Queue (Task Queue / MacroTask Queue)**: After a Web API completes its asynchronous operation, the callback function associated with that operation (e.g., the function passed to `setTimeout` or `fetch.then()`) is placed into the Callback Queue. Tasks in this queue are processed in a First-In, First-Out (FIFO) manner.\n\n4.  **Microtask Queue**: This queue has a higher priority than the Callback Queue. It holds callbacks for Promises (`.then()`, `.catch()`, `.finally()`) and `MutationObserver` callbacks. All microtasks are executed before the browser renders the UI and before any macrotasks (from the Callback Queue) are processed.\n\n5.  **Event Loop**: This is a constantly running process that monitors the Call Stack and the task queues. Its primary job is to check if the Call Stack is empty. If the Call Stack is empty, it first checks the Microtask Queue and moves any pending microtasks to the Call Stack. Once the Microtask Queue is empty, it then checks the Callback Queue and moves the oldest task (callback) from it to the Call Stack, allowing it to be executed. This cycle repeats indefinitely.\n    *   ![JavaScript Event Loop Processing](images/event_loop_1.png)\n    *   This visualization demonstrates how asynchronous operations flow through the JavaScript runtime.\n\n## Event Loop Algorithm Summary:\n\n1.  **Execute Call Stack**: JavaScript first executes all synchronous code in the Call Stack until it becomes empty.\n2.  **Process Microtasks**: Once the Call Stack is empty, the Event Loop checks the Microtask Queue. It executes *all* tasks within the Microtask Queue, pushing them onto the Call Stack one by one, until the Microtask Queue is empty. This effectively means Promises resolve their `.then()` callbacks before `setTimeout` callbacks.\n3.  **UI Rendering (if needed)**: After processing all microtasks, the browser might perform UI rendering updates if there are any pending changes.\n4.  **Process Macrotasks**: After UI rendering, the Event Loop checks the Callback Queue (macrotask queue). It takes the *oldest* task from this queue and pushes it onto the Call Stack for execution. Only one macrotask is processed per loop iteration before returning to step 2.\n5.  **Repeat**: The Event Loop continues this cycle indefinitely, constantly checking the Call Stack, Microtask Queue, and Callback Queue.\n\n## Common Event Loop Example:\n\n```javascript\nconsole.log('Start'); // 1. Runs immediately\n\nsetTimeout(() => {\n  console.log('Timeout callback'); // 4. Placed in Callback Queue after 0ms, runs after stack and microtasks are empty\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise callback'); // 3. Placed in Microtask Queue, runs after stack is empty but before timeout\n});\n\nconsole.log('End'); // 2. Runs immediately\n\n// Expected Output Order:\n// 'Start'\n// 'End'\n// 'Promise callback' (microtask)\n// 'Timeout callback' (macrotask)\n```",
          "examples": [
            {
              "id": "example_event_loop_1",
              "title": "Basic Asynchronous Flow",
              "code": "console.log('Synchronous 1');\n\nsetTimeout(() => {\n  console.log('Timeout 1 (Macrotask)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1 (Microtask)');\n});\n\nsetTimeout(() => {\n  console.log('Timeout 2 (Macrotask)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 2 (Microtask)');\n});\n\nconsole.log('Synchronous 2');\n\n// Predicted Output:\n// Synchronous 1\n// Synchronous 2\n// Promise 1 (Microtask)\n// Promise 2 (Microtask)\n// Timeout 1 (Macrotask)\n// Timeout 2 (Macrotask)\n",
              "explanation": "This example demonstrates the typical flow. Synchronous code executes first. Then, all microtasks from the current tick are executed. Finally, macrotasks are processed one by one in subsequent event loop iterations.",
              "language": "javascript"
            },
            {
              "id": "example_event_loop_2",
              "title": "Complex Nested Asynchronicity",
              "code": "console.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n  Promise.resolve().then(() => console.log('C'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('D');\n  setTimeout(() => console.log('E'), 0);\n});\n\nconsole.log('F');\n\n// Predicted Output:\n// A\n// F\n// D\n// E\n// B\n// C\n",
              "explanation": "This example shows nesting. 'A' and 'F' execute synchronously. 'D' (from the first promise) executes next. Inside 'D', 'E' is scheduled as a macrotask. Then, 'B' (from the first setTimeout) executes. Inside 'B', 'C' is scheduled as a microtask, which runs immediately after 'B' finishes, but before any further macrotasks ('E').",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "JavaScript",
            "Asynchronous",
            "Event Loop",
            "Concurrency",
            "Web APIs",
            "Promises",
            "setTimeout"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Functions",
            "Callbacks",
            "Basic JavaScript Syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Node.js performance",
            "Frontend framework understanding",
            "Complex async applications"
          ]
        },
        {
          "id": "theory_creational_patterns",
          "title": "JavaScript Creational Design Patterns",
          "content": "Creational Design Patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable for the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by controlling the object creation process.\n\n## Constructor Pattern\n\nThe Constructor Pattern is one of the most common ways to create objects in JavaScript. It leverages constructor functions to create new objects based on a blueprint. A constructor function is essentially a regular function that is used with the `new` keyword.\n\nWhen a function is called with `new`:\n1.  A new empty object is created.\n2.  The `this` context within the constructor function is bound to this new object.\n3.  The constructor function's code is executed, which typically adds properties and methods to the `this` object.\n4.  The newly created object is returned (if the constructor doesn't explicitly return another object).\n\n### Usage:\n```javascript\n// Constructor Pattern\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  \n  this.sayHello = function() {\n    console.log(`Hello, my name is ${this.name}`);\n  };\n}\n\nconst john = new Person('John', 30);\njohn.sayHello(); // Hello, my name is John\n\nconst jane = new Person('Jane', 25);\njane.sayHello(); // Hello, my name is Jane\n```\n\n### Benefits:\n*   **Simplicity**: Straightforward way to create multiple instances of a similar type of object.\n*   **Object-oriented**: Mimics class-based object creation, which is familiar to developers from other languages.\n*   **Encapsulation**: Properties and methods are encapsulated within the object instance.\n\n### Drawbacks:\n*   **Method Duplication**: Each instance of an object created with a constructor gets its own copy of methods. For many instances, this can lead to memory inefficiency. (This is typically mitigated by using `prototype` for methods).\n*   **Lack of Privacy**: All properties and methods are public by default.\n\n## Factory Pattern\n\nThe Factory Pattern is a creational pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created. In JavaScript, this often means a function (the 'factory') that creates and returns different types of objects based on some input parameters, abstracting away the object creation logic.\n\nIt's useful when:\n*   The object creation process is complex and involves multiple steps.\n*   You want to create different types of objects based on certain conditions or inputs.\n*   You want to decouple the client code from the concrete classes of the objects it creates.\n\n### Usage:\n```javascript\n// Factory Pattern\nfunction createUser(type) {\n  if (type === 'admin') {\n    return {\n      name: 'Admin',\n      permissions: ['read', 'write', 'delete'],\n      dashboard: true,\n      greet: function() { console.log('Welcome, Admin!'); }\n    };\n  } else if (type === 'user') {\n    return {\n      name: 'User',\n      permissions: ['read'],\n      greet: function() { console.log('Hello, User!'); }\n    };\n  } else {\n    throw new Error('Invalid user type specified.');\n  }\n}\n\nconst admin = createUser('admin');\nconsole.log(admin); // { name: 'Admin', permissions: [ 'read', 'write', 'delete' ], dashboard: true, greet: [Function: greet] }\nadmin.greet(); // Welcome, Admin!\n\nconst regularUser = createUser('user');\nconsole.log(regularUser); // { name: 'User', permissions: [ 'read' ], greet: [Function: greet] }\nregularUser.greet(); // Hello, User!\n\n// const guest = createUser('guest'); // Throws Error\n```\n\n### Benefits:\n*   **Decoupling**: The client code doesn't need to know the specific classes or constructors of the objects it's creating. It just asks the factory.\n*   **Flexibility**: Easy to add new types of objects without modifying existing client code.\n*   **Centralized creation**: Object creation logic is encapsulated in one place.\n\n### Drawbacks:\n*   **Increased Complexity**: Can add an extra layer of abstraction, which might be overkill for very simple object creation.\n*   **Debugging**: Can sometimes be harder to trace the origin of an object if multiple factories are involved.",
          "examples": [
            {
              "id": "example_creational_constructor_prototype",
              "title": "Constructor with Prototype for Methods",
              "code": "function Car(make, model) {\n  this.make = make;\n  this.model = model;\n}\n\n// Add methods to the prototype to avoid duplication\nCar.prototype.getDetails = function() {\n  return `${this.make} ${this.model}`;\n};\n\nCar.prototype.startEngine = function() {\n  console.log(`${this.make} ${this.model} engine started.`);\n};\n\nconst myCar = new Car('Toyota', 'Camry');\nconsole.log(myCar.getDetails()); // Toyota Camry\nmyCar.startEngine(); // Toyota Camry engine started.\n\nconst anotherCar = new Car('Honda', 'Civic');\nconsole.log(anotherCar.getDetails()); // Honda Civic\n",
              "explanation": "This example shows the best practice for using the Constructor Pattern by placing methods on the `prototype` chain. This ensures that all instances share the same method function, saving memory, while properties remain instance-specific. It's a common interview topic to discuss the memory efficiency difference.",
              "language": "javascript"
            },
            {
              "id": "example_creational_factory_abstract",
              "title": "Abstracting Object Creation with Factory",
              "code": "function ProductFactory() {\n  this.createProduct = function(type, options) {\n    let product;\n\n    switch (type) {\n      case 'laptop':\n        product = { name: options.name, price: options.price, cpu: options.cpu };\n        break;\n      case 'smartphone':\n        product = { name: options.name, price: options.price, os: options.os };\n        break;\n      default:\n        throw new Error('Unknown product type');\n    }\n\n    product.getType = function() { return type; };\n    product.getFormattedPrice = function() { return `$${this.price.toFixed(2)}`; };\n\n    return product;\n  };\n}\n\nconst factory = new ProductFactory();\nconst laptop = factory.createProduct('laptop', { name: 'XPS 15', price: 1500, cpu: 'i7' });\nconsole.log(laptop.getType(), laptop.getFormattedPrice(), laptop.cpu); // laptop $1500.00 i7\n\nconst phone = factory.createProduct('smartphone', { name: 'Galaxy S23', price: 900, os: 'Android' });\nconsole.log(phone.getType(), phone.getFormattedPrice(), phone.os); // smartphone $900.00 Android\n",
              "explanation": "This demonstrates a more robust Factory pattern where a `ProductFactory` object has a method `createProduct`. This method acts as the factory, returning different product types (laptop, smartphone) based on the input 'type'. It abstracts away the details of how each specific product object is structured and also adds common methods to all created products. This pattern is particularly useful when the construction of objects is complex and varies by type.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "JavaScript",
            "Design Patterns",
            "Creational Patterns",
            "Constructor Pattern",
            "Factory Pattern",
            "Object-Oriented Programming"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Objects",
            "Functions",
            "`this` keyword",
            "`new` keyword"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Software Architecture",
            "Framework Development",
            "Large-scale applications"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_event_loop_1",
          "topic": "Event Loop Basic Output Prediction",
          "level": "easy",
          "type": "mcq",
          "question": "What will be the output of the following JavaScript code snippet?\n\n```javascript\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n}, 0);\n\nconsole.log('C');\n```",
          "answer": "A, C, B",
          "options": [
            "A, B, C",
            "A, C, B",
            "B, A, C",
            "C, A, B"
          ],
          "analysisPoints": [
            "Understanding of synchronous vs. asynchronous execution.",
            "Knowledge that `setTimeout` with a 0ms delay still puts the callback in the macrotask queue.",
            "Order of execution: Call Stack first, then macrotask queue."
          ],
          "keyConcepts": [
            "Call Stack",
            "Callback Queue",
            "setTimeout",
            "Synchronous vs. Asynchronous"
          ],
          "evaluationCriteria": [
            "Ability to trace code execution flow.",
            "Correct identification of async behavior."
          ],
          "example": "Explanation: 'A' and 'C' are synchronous operations and will execute immediately one after another as they are pushed onto and popped from the Call Stack. The `setTimeout` callback 'B' is handed to the Web API, and after 0ms, it's moved to the Callback Queue. The Event Loop only pushes 'B' to the Call Stack *after* the Call Stack is completely empty of synchronous code. Thus, 'A' and 'C' print first, then 'B'.",
          "tags": [
            "Event Loop",
            "setTimeout",
            "Asynchronous",
            "Basic"
          ],
          "prerequisites": [
            "Functions",
            "console.log"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_loop_2",
          "topic": "Microtask vs. Macrotask Priority",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code. What is the correct order of output?\n\n```javascript\nconsole.log('1');\n\nPromise.resolve().then(() => {\n  console.log('2');\n});\n\nsetTimeout(() => {\n  console.log('3');\n}, 0);\n\nconsole.log('4');\n```",
          "answer": "1, 4, 2, 3",
          "options": [
            "1, 2, 3, 4",
            "1, 4, 2, 3",
            "1, 3, 2, 4",
            "4, 1, 2, 3"
          ],
          "analysisPoints": [
            "Understanding of synchronous code execution.",
            "Distinction between microtask queue (Promises) and macrotask queue (setTimeout).",
            "Priority: Call Stack -> Microtask Queue -> Macrotask Queue."
          ],
          "keyConcepts": [
            "Event Loop",
            "Microtask Queue",
            "Callback Queue",
            "Promises",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Ability to prioritize different types of asynchronous tasks.",
            "Knowledge of Event Loop's processing order."
          ],
          "example": "Explanation: '1' and '4' are synchronous and execute immediately. `Promise.resolve().then()` adds its callback ('2') to the Microtask Queue. `setTimeout()` adds its callback ('3') to the Callback Queue (macrotask queue). After the synchronous code finishes, the Event Loop prioritizes the Microtask Queue, so '2' runs. Finally, it processes the Macrotask Queue, so '3' runs. Thus, the order is 1, 4, 2, 3.",
          "tags": [
            "Event Loop",
            "Promises",
            "setTimeout",
            "Priority",
            "Asynchronous"
          ],
          "prerequisites": [
            "Event Loop Basic Output Prediction"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_3",
          "topic": "Detailed Event Loop Flow",
          "level": "hard",
          "type": "code",
          "question": "Predict the exact output of the following JavaScript code. Explain your reasoning step-by-step, tracing how each `console.log` statement enters and leaves the Call Stack, and how callbacks are handled by the queues.",
          "answer": "```javascript\n// Step-by-step Execution Trace:\n\n// 1. Initial execution starts. 'Script start' is pushed to Call Stack and executed.\n//    console.log('Script start');\n//    Output: Script start\n\n// 2. `setTimeout` callback ('Timeout 1') is registered with Web APIs, then moved to Macrotask Queue.\n//    setTimeout(() => console.log('Timeout 1'), 0);\n\n// 3. `Promise.resolve()` immediately resolves, its `.then()` callback ('Promise 1') is moved to Microtask Queue.\n//    Promise.resolve().then(() => console.log('Promise 1'));\n\n// 4. `setTimeout` callback ('Timeout 2') is registered with Web APIs, then moved to Macrotask Queue (after 'Timeout 1').\n//    setTimeout(() => console.log('Timeout 2'), 0);\n\n// 5. 'Script end' is pushed to Call Stack and executed.\n//    console.log('Script end');\n//    Output: Script end\n\n// ---- End of synchronous execution. Call Stack is empty. Event Loop starts. ----\n\n// 6. Event Loop checks Microtask Queue. 'Promise 1' is found.\n//    'Promise 1' is moved to Call Stack and executed.\n//    Output: Promise 1\n\n// ---- Microtask Queue is now empty. ----\n\n// 7. Event Loop checks Macrotask Queue. 'Timeout 1' is found.\n//    'Timeout 1' is moved to Call Stack and executed.\n//    Output: Timeout 1\n\n// ---- Event Loop checks for more microtasks (none). Checks macrotasks. ----\n\n// 8. Event Loop checks Macrotask Queue. 'Timeout 2' is found.\n//    'Timeout 2' is moved to Call Stack and executed.\n//    Output: Timeout 2\n\n// Final Output:\n// Script start\n// Script end\n// Promise 1\n// Timeout 1\n// Timeout 2\n```",
          "options": [],
          "analysisPoints": [
            "Ability to precisely trace synchronous code.",
            "Understanding the queueing mechanism of `setTimeout` and `Promise.then()`.",
            "Correct application of microtask queue priority over macrotask queue.",
            "Understanding that macrotasks are processed one per event loop cycle after all microtasks."
          ],
          "keyConcepts": [
            "Call Stack",
            "Microtask Queue",
            "Callback Queue",
            "Event Loop Algorithm",
            "Asynchronous Execution Order"
          ],
          "evaluationCriteria": [
            "Accuracy of output prediction.",
            "Clarity and completeness of the step-by-step explanation.",
            "Demonstrated deep understanding of Event Loop mechanics."
          ],
          "example": "```javascript\nconsole.log('Script start');\n\nsetTimeout(() => console.log('Timeout 1'), 0);\n\nPromise.resolve().then(() => console.log('Promise 1'));\n\nsetTimeout(() => console.log('Timeout 2'), 0);\n\nconsole.log('Script end');\n```",
          "tags": [
            "Event Loop",
            "Promises",
            "setTimeout",
            "Asynchronous",
            "Advanced",
            "Code Trace"
          ],
          "prerequisites": [
            "Event Loop Basic Output Prediction",
            "Microtask vs. Macrotask Priority"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_loop_4",
          "topic": "Components of the Event Loop",
          "level": "easy",
          "type": "flashcard",
          "question": "Name the key components involved in the JavaScript Event Loop.",
          "answer": "Call Stack, Web APIs, Callback Queue (Macrotask Queue), Microtask Queue, Event Loop.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Event Loop Components"
          ],
          "evaluationCriteria": [
            "Recall of fundamental terms."
          ],
          "example": "",
          "tags": [
            "Event Loop",
            "Definitions",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_loop_5",
          "topic": "Role of the Event Loop",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary role of the Event Loop in JavaScript's concurrency model. How does it enable non-blocking I/O operations despite JavaScript being single-threaded?",
          "answer": "The Event Loop's primary role is to continuously check if the Call Stack is empty. If it is, it then moves tasks from the task queues (Microtask Queue first, then Callback Queue) to the Call Stack for execution. This mechanism is crucial for non-blocking I/O because:\n\n1.  **Asynchronous Operations Offloaded**: When an asynchronous operation (like `setTimeout`, `fetch`, or a DOM event listener) is initiated, JavaScript doesn't wait for it. Instead, it offloads the task to a Web API (or Node.js API). The Call Stack remains free to execute other synchronous code.\n2.  **Callbacks Queued**: Once the Web API completes the background task, it places the associated callback function into the appropriate queue (Microtask or Callback Queue).\n3.  **Event Loop Orchestration**: The single JavaScript thread continues to execute code from the Call Stack. Only when the Call Stack is empty does the Event Loop step in. It pulls the next ready callback from the queues and pushes it onto the Call Stack. This ensures that long-running I/O operations or delays don't block the main thread, allowing the UI to remain responsive or other code to execute. Essentially, the Event Loop constantly checks for work to do when the main thread is idle.",
          "options": [],
          "analysisPoints": [
            "Understanding of the single-threaded nature of JavaScript.",
            "Explanation of how Web APIs handle background tasks.",
            "Description of how the Event Loop transfers callbacks from queues to the Call Stack.",
            "Articulation of 'non-blocking' in the context of a single thread."
          ],
          "keyConcepts": [
            "Event Loop",
            "Single-threaded",
            "Non-blocking I/O",
            "Call Stack",
            "Web APIs",
            "Callback Queue",
            "Microtask Queue"
          ],
          "evaluationCriteria": [
            "Completeness of explanation.",
            "Accuracy of technical terms.",
            "Ability to connect different components of the Event Loop.",
            "Demonstrated understanding of concurrency in JavaScript."
          ],
          "example": "",
          "tags": [
            "Event Loop",
            "Concurrency",
            "Asynchronous",
            "Open-Ended",
            "Core Concepts"
          ],
          "prerequisites": [
            "Event Loop Detailed Diagrams"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_constructor_pattern_1",
          "topic": "Constructor Pattern Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is true about JavaScript's Constructor Pattern when creating new objects?",
          "answer": "The `this` keyword inside the constructor refers to the newly created object.",
          "options": [
            "Methods defined directly on `this` inside the constructor are shared by all instances.",
            "The `new` keyword is optional when calling a constructor function.",
            "The `this` keyword inside the constructor refers to the newly created object.",
            "Constructor functions implicitly return `null` if no explicit return statement is present."
          ],
          "analysisPoints": [
            "Understanding of `this` binding with `new`.",
            "Knowledge of method duplication vs. sharing via prototype.",
            "The necessity of `new` for constructor behavior.",
            "Default return value of constructors."
          ],
          "keyConcepts": [
            "Constructor Pattern",
            "`new` keyword",
            "`this` context",
            "Object instantiation"
          ],
          "evaluationCriteria": [
            "Correct understanding of constructor function mechanics.",
            "Ability to distinguish between correct and incorrect statements about `new`."
          ],
          "example": "Explanation: When a function is invoked with `new`, a new empty object is created, and `this` is bound to that new object. Methods defined directly on `this` are created for *each* instance, leading to duplication. The `new` keyword is essential for the constructor behavior; without it, it's just a regular function call. Constructors implicitly return `this` (the new object) if no explicit return of an object/function is made.",
          "tags": [
            "Constructor Pattern",
            "JavaScript",
            "Objects",
            "`this`",
            "Design Patterns"
          ],
          "prerequisites": [
            "Functions",
            "Objects",
            "`this` keyword"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_factory_pattern_1",
          "topic": "Factory Pattern Use Cases",
          "level": "medium",
          "type": "mcq",
          "question": "In which scenario would the Factory Pattern be most beneficial in JavaScript?",
          "answer": "When the object creation logic is complex and involves creating different types of objects based on certain conditions.",
          "options": [
            "When you need to ensure only one instance of an object exists throughout the application.",
            "When you want to define a blueprint for objects with shared methods via `prototype`.",
            "When you need to explicitly expose all object properties and methods for direct manipulation.",
            "When the object creation logic is complex and involves creating different types of objects based on certain conditions."
          ],
          "analysisPoints": [
            "Understanding the core purpose of the Factory Pattern (abstracting complex creation).",
            "Distinguishing Factory Pattern from Singleton Pattern (option 1).",
            "Distinguishing Factory Pattern from Constructor/Prototype Pattern (option 2).",
            "Understanding encapsulation vs. exposure (option 3)."
          ],
          "keyConcepts": [
            "Factory Pattern",
            "Creational Patterns",
            "Object Creation",
            "Decoupling"
          ],
          "evaluationCriteria": [
            "Correct identification of Factory Pattern's strengths.",
            "Ability to differentiate between various design patterns."
          ],
          "example": "Explanation: The Factory Pattern shines when the process of creating objects is not straightforward and depends on certain criteria, leading to different types of objects being instantiated. It hides the complexity of creation from the client. Option 1 describes the Singleton Pattern. Option 2 describes the Constructor/Prototype Pattern. Option 3 contradicts the typical goal of controlled object creation.",
          "tags": [
            "Factory Pattern",
            "Design Patterns",
            "Use Cases",
            "Intermediate"
          ],
          "prerequisites": [
            "Constructor Pattern"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_constructor_factory_compare_1",
          "topic": "Constructor vs. Factory Pattern",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the Constructor Pattern and the Factory Pattern in JavaScript. Discuss their primary use cases, benefits, and drawbacks, and provide a scenario where you would prefer one over the other.",
          "answer": "### Constructor Pattern\n*   **Primary Use Case**: Creating multiple instances of a *single type* of object with shared properties and methods (often using `prototype` for methods).\n*   **Benefits**: Simple, familiar (resembles classes), direct instantiation with `new`.\n*   **Drawbacks**: Direct coupling to the constructor function, can lead to method duplication if prototype is not used, less flexible for creating different object types based on runtime conditions.\n*   **Scenario Preference**: When you have a clear, single 'blueprint' for an object (e.g., `User`, `Product`) and you just need to create many instances of that specific type, especially if using ES6 classes or prototype methods for efficiency.\n\n### Factory Pattern\n*   **Primary Use Case**: Creating different types of related objects, abstracting away the object creation logic, and decoupling the client from the concrete implementation of the created objects.\n*   **Benefits**: Decouples client from concrete object types, highly flexible for adding new object types, centralizes complex object creation logic.\n*   **Drawbacks**: Adds a layer of abstraction that might be overkill for simple object creation, can be slightly harder to trace object origins during debugging.\n*   **Scenario Preference**: When you need to create diverse objects based on inputs or configurations, where the client doesn't need to know *how* the object is created, only *what* type of object it needs (e.g., a `VehicleFactory` that creates `Car`, `Bike`, or `Truck` objects based on a string input).\n\n### Comparison:\n*   **`new` keyword**: Constructor *requires* `new`. Factory *does not* (it's a regular function returning an object).\n*   **Object Type**: Constructor creates instances of *one* specific type. Factory can create *multiple* different types.\n*   **Flexibility**: Factory is generally more flexible for varied object creation.\n*   **Coupling**: Constructor leads to tighter coupling; Factory promotes looser coupling.",
          "options": [],
          "analysisPoints": [
            "Clear distinction of 'purpose' for each pattern.",
            "Accurate identification of benefits and drawbacks for both.",
            "Demonstrated understanding of when to apply each pattern.",
            "Highlighting the role of `new` and `prototype` in Constructor Pattern.",
            "Emphasizing decoupling and flexibility for Factory Pattern."
          ],
          "keyConcepts": [
            "Constructor Pattern",
            "Factory Pattern",
            "Design Patterns",
            "Object Creation",
            "Coupling",
            "Flexibility",
            "Prototypal Inheritance"
          ],
          "evaluationCriteria": [
            "Depth and clarity of comparison.",
            "Quality of example scenarios.",
            "Comprehensive coverage of pros and cons.",
            "Structured and well-reasoned answer."
          ],
          "example": "",
          "tags": [
            "Design Patterns",
            "Comparison",
            "Constructor Pattern",
            "Factory Pattern",
            "Advanced",
            "Open-Ended"
          ],
          "prerequisites": [
            "Constructor Pattern",
            "Factory Pattern"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_constructor_pattern_2",
          "topic": "Constructor Pattern and `this`",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the value of `this` inside a function called using the `new` keyword?",
          "answer": "When a function is called using the `new` keyword (i.e., as a constructor), `this` inside that function refers to the newly created, empty object instance.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "`this` keyword",
            "Constructor Pattern",
            "`new` operator"
          ],
          "evaluationCriteria": [
            "Accurate recall of `this` binding rules."
          ],
          "example": "",
          "tags": [
            "Constructor Pattern",
            "`this`",
            "Flashcard",
            "JavaScript"
          ],
          "prerequisites": [
            "`this` keyword basic understanding"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_factory_pattern_2",
          "topic": "Purpose of Factory Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main purpose of the Factory Pattern?",
          "answer": "The main purpose of the Factory Pattern is to encapsulate the object creation logic and provide an interface for creating objects without specifying their exact class or constructor. It promotes decoupling between the client code and the concrete types of objects being created.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Factory Pattern",
            "Object Creation",
            "Decoupling"
          ],
          "evaluationCriteria": [
            "Ability to state the core purpose of the pattern."
          ],
          "example": "",
          "tags": [
            "Factory Pattern",
            "Definitions",
            "Flashcard",
            "Design Patterns"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_event_loop_demonstration",
          "title": "Interactive Event Loop Demonstration",
          "description": "\nImplement a simple HTML page with JavaScript that visually or interactively demonstrates the Event Loop's behavior. \n\n**Requirements:**\n\n1.  Create an HTML page with a few buttons or areas to display output.\n2.  Write JavaScript code that includes:\n    *   Synchronous `console.log` statements.\n    *   At least two `setTimeout` calls with different delays (e.g., 0ms and 100ms).\n    *   At least two `Promise.resolve().then()` calls.\n    *   One `setTimeout` that contains a `Promise.resolve().then()` inside its callback.\n    *   One `Promise.resolve().then()` that contains a `setTimeout` inside its callback.\n3.  Instead of just `console.log`, update the HTML content (e.g., append text to a `div`) to show the order of execution in real-time.\n4.  Add a 'Start Demo' button to trigger the execution.\n5.  (Optional, for extra credit) Explain the output order in a text area below the output.",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Event Loop Demo</title>\n    <style>\n        body { font-family: monospace; padding: 20px; }\n        #output { border: 1px solid #ccc; padding: 10px; min-height: 150px; margin-top: 20px; background-color: #f9f9f9; }\n        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer; }\n    </style>\n</head>\n<body>\n    <h1>Event Loop Demonstration</h1>\n    <button id=\"startButton\">Start Demo</button>\n    <pre id=\"output\"></pre>\n    <script>\n        const outputDiv = document.getElementById('output');\n        const startButton = document.getElementById('startButton');\n\n        function logToOutput(message) {\n            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });\n            outputDiv.textContent += `[${timestamp}] ${message}\\n`;\n        }\n\n        startButton.addEventListener('click', () => {\n            outputDiv.textContent = ''; // Clear previous output\n            logToOutput('--- Demo Started ---');\n\n            // TODO: Implement your Event Loop demonstration logic here\n            // Use logToOutput instead of console.log\n\n            logToOutput('Synchronous code continues...');\n            setTimeout(() => {\n                logToOutput('Timeout with 0ms delay');\n            }, 0);\n            logToOutput('Synchronous code ends.');\n            // ... more async calls\n\n            logToOutput('--- Demo Finished Scheduling ---');\n        });\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Event Loop Demo</title>\n    <style>\n        body { font-family: monospace; padding: 20px; }\n        #output { border: 1px solid #ccc; padding: 10px; min-height: 250px; margin-top: 20px; background-color: #f9f9f9; overflow-y: scroll; }\n        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer; }\n    </style>\n</head>\n<body>\n    <h1>Event Loop Demonstration</h1>\n    <button id=\"startButton\">Start Demo</button>\n    <pre id=\"output\"></pre>\n    <script>\n        const outputDiv = document.getElementById('output');\n        const startButton = document.getElementById('startButton');\n\n        function logToOutput(message) {\n            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });\n            outputDiv.textContent += `[${timestamp}] ${message}\\n`;\n            outputDiv.scrollTop = outputDiv.scrollHeight; // Scroll to bottom\n        }\n\n        startButton.addEventListener('click', () => {\n            outputDiv.textContent = ''; // Clear previous output\n            logToOutput('--- Demo Started ---');\n\n            logToOutput('Synchronous Code 1');\n\n            setTimeout(() => {\n                logToOutput('Timeout 0ms (Macrotask 1)');\n                Promise.resolve().then(() => {\n                    logToOutput('Promise inside Timeout (Microtask)');\n                });\n            }, 0);\n\n            Promise.resolve().then(() => {\n                logToOutput('Promise 1 (Microtask 1)');\n            });\n\n            setTimeout(() => {\n                logToOutput('Timeout 100ms (Macrotask 2)');\n            }, 100);\n\n            Promise.resolve().then(() => {\n                logToOutput('Promise 2 (Microtask 2)');\n                setTimeout(() => {\n                    logToOutput('Timeout inside Promise (Macrotask 3)');\n                }, 0);\n            });\n\n            logToOutput('Synchronous Code 2');\n\n            logToOutput('--- Demo Finished Scheduling ---');\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Verify 'Synchronous Code 1' appears first.",
            "Verify 'Synchronous Code 2' appears before any async callbacks.",
            "Verify 'Promise 1' and 'Promise 2' (microtasks) appear before 'Timeout 0ms' (macrotask).",
            "Verify 'Promise inside Timeout' appears immediately after 'Timeout 0ms'.",
            "Verify 'Timeout inside Promise' appears *after* other microtasks and the current macrotask (Timeout 0ms).",
            "Verify 'Timeout 100ms' appears roughly after 100ms and after other 0ms tasks/promises."
          ],
          "hints": [
            "Remember that `setTimeout(..., 0)` doesn't mean immediate execution; it means the callback is queued as soon as possible.",
            "Microtasks (Promises) always run before macrotasks (setTimeout) if the Call Stack is empty.",
            "A new macrotask scheduled within a microtask or another macrotask will be processed in a *subsequent* event loop iteration.",
            "Use a consistent `logToOutput` function to easily trace the flow."
          ],
          "tags": [
            "Event Loop",
            "Asynchronous",
            "JavaScript",
            "Frontend",
            "DOM Manipulation"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Event Loop theory",
            "DOM manipulation basics",
            "Promises",
            "setTimeout"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Call Stack",
            "Microtask Queue",
            "Callback Queue",
            "Web APIs"
          ]
        },
        {
          "id": "task_constructor_pattern_employee_management",
          "title": "Employee Management with Constructor Pattern",
          "description": "\nImplement a `Employee` constructor function that allows creating new employee objects. This task tests your understanding of the Constructor Pattern and how to attach methods to the prototype for efficiency.\n\n**Requirements:**\n\n1.  Create a `Employee` constructor function that takes `name`, `id`, and `department` as arguments.\n2.  Instances of `Employee` should have these properties directly.\n3.  Add a method `getDetails` to the `Employee` prototype that returns a string like: `\"Name: [name], ID: [id], Dept: [department]\"`.\n4.  Add another method `assignDepartment` to the `Employee` prototype that takes a `newDepartment` string and updates the employee's department.\n5.  Demonstrate the creation of at least two `Employee` instances and call both methods on them to show the functionality.",
          "difficulty": "easy",
          "startingCode": "function Employee(name, id, department) {\n  // TODO: Initialize properties\n}\n\n// TODO: Add getDetails method to prototype\n\n// TODO: Add assignDepartment method to prototype\n\n// Example Usage (to be completed):\n// const emp1 = new Employee('Alice', 'E001', 'HR');\n// console.log(emp1.getDetails()); // Expected: \"Name: Alice, ID: E001, Dept: HR\"\n// emp1.assignDepartment('Finance');\n// console.log(emp1.getDetails()); // Expected: \"Name: Alice, ID: E001, Dept: Finance\"\n",
          "solutionCode": "function Employee(name, id, department) {\n  this.name = name;\n  this.id = id;\n  this.department = department;\n}\n\n// Add getDetails method to prototype\nEmployee.prototype.getDetails = function() {\n  return `Name: ${this.name}, ID: ${this.id}, Dept: ${this.department}`;\n};\n\n// Add assignDepartment method to prototype\nEmployee.prototype.assignDepartment = function(newDepartment) {\n  this.department = newDepartment;\n  console.log(`${this.name}'s department updated to ${newDepartment}.`);\n};\n\n// Example Usage:\nconst emp1 = new Employee('Alice Smith', 'E001', 'HR');\nconsole.log(emp1.getDetails());\nemp1.assignDepartment('Finance');\nconsole.log(emp1.getDetails());\n\nconst emp2 = new Employee('Bob Johnson', 'E002', 'IT');\nconsole.log(emp2.getDetails());\nemp2.assignDepartment('Development');\nconsole.log(emp2.getDetails());\n\n// Check if methods are shared via prototype\nconsole.log('Are getDetails methods shared?', emp1.getDetails === emp2.getDetails);\nconsole.log('Are assignDepartment methods shared?', emp1.assignDepartment === emp2.assignDepartment);\n",
          "testCases": [
            "Create an employee and verify initial details.",
            "Assign a new department and verify the update reflects in details.",
            "Create multiple employees and ensure their methods are shared (refer to the same function in memory) via `prototype`.",
            "Test with empty strings or null for properties to ensure graceful handling (or proper validation if implemented)."
          ],
          "hints": [
            "Remember to use the `this` keyword inside the constructor to assign properties to the instance.",
            "Methods intended to be shared across all instances should be added to `Constructor.prototype`.",
            "The `new` keyword is crucial when instantiating objects using a constructor function."
          ],
          "tags": [
            "Constructor Pattern",
            "Design Patterns",
            "JavaScript",
            "OOP",
            "Prototype"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "Functions",
            "Objects",
            "`this` keyword",
            "Prototypes"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Prototype Chain",
            "ES6 Classes"
          ]
        },
        {
          "id": "task_factory_pattern_notification_service",
          "title": "Notification Service with Factory Pattern",
          "description": "\nDesign and implement a `NotificationFactory` that creates different types of notification objects (e.g., 'email', 'sms', 'push') based on a given type. This task emphasizes decoupling object creation logic.\n\n**Requirements:**\n\n1.  Create a `NotificationFactory` function or object.\n2.  The `NotificationFactory` should have a method, `createNotification(type, message, recipient)`, that returns different notification objects based on the `type` string.\n3.  Implement at least three types of notification objects:\n    *   **Email Notification**: Properties: `message`, `recipient`, `subject` (default: 'Important Update'). Method: `send()` that logs `\"Sending Email to [recipient] with message: [message] (Subject: [subject])\"`.\n    *   **SMS Notification**: Properties: `message`, `recipient`. Method: `send()` that logs `\"Sending SMS to [recipient] with message: [message]\"`.\n    *   **Push Notification**: Properties: `message`, `recipient`, `icon` (default: 'bell'). Method: `send()` that logs `\"Sending Push Notification to [recipient] with message: [message] (Icon: [icon])\"`.\n4.  If an unknown type is requested, the factory should throw an error or return `null`.\n5.  Demonstrate creating instances of each notification type using the factory and calling their `send()` methods.",
          "difficulty": "medium",
          "startingCode": "function NotificationFactory() {\n  // TODO: Implement createNotification method\n  this.createNotification = function(type, message, recipient) {\n    let notification;\n\n    switch (type) {\n      case 'email':\n        // TODO: Create email notification object\n        break;\n      case 'sms':\n        // TODO: Create SMS notification object\n        break;\n      case 'push':\n        // TODO: Create push notification object\n        break;\n      default:\n        throw new Error(`Unknown notification type: ${type}`);\n    }\n\n    // Each notification type should have a .send() method\n    // Example: notification.send = function() { ... };\n\n    return notification;\n  };\n}\n\n// Example Usage:\n// const factory = new NotificationFactory();\n// const emailNotif = factory.createNotification('email', 'Hello World', 'test@example.com');\n// emailNotif.send();\n",
          "solutionCode": "function NotificationFactory() {\n  this.createNotification = function(type, message, recipient) {\n    let notification;\n\n    switch (type) {\n      case 'email':\n        notification = {\n          message: message,\n          recipient: recipient,\n          subject: 'Important Update',\n          send: function() {\n            console.log(`Sending Email to ${this.recipient} with message: '${this.message}' (Subject: ${this.subject})`);\n          }\n        };\n        break;\n      case 'sms':\n        notification = {\n          message: message,\n          recipient: recipient,\n          send: function() {\n            console.log(`Sending SMS to ${this.recipient} with message: '${this.message}'`);\n          }\n        };\n        break;\n      case 'push':\n        notification = {\n          message: message,\n          recipient: recipient,\n          icon: 'bell',\n          send: function() {\n            console.log(`Sending Push Notification to ${this.recipient} with message: '${this.message}' (Icon: ${this.icon})`);\n          }\n        };\n        break;\n      default:\n        throw new Error(`Unknown notification type: ${type}`);\n    }\n\n    return notification;\n  };\n}\n\n// Demo Usage:\nconst factory = new NotificationFactory();\n\ntry {\n  console.log('\\n--- Email Notification ---');\n  const emailNotif = factory.createNotification('email', 'Your order #123 has shipped!', 'john.doe@example.com');\n  emailNotif.send();\n  \n  console.log('\\n--- SMS Notification ---');\n  const smsNotif = factory.createNotification('sms', 'Your verification code is 4567.', '+1234567890');\n  smsNotif.send();\n\n  console.log('\\n--- Push Notification ---');\n  const pushNotif = factory.createNotification('push', 'New message from Alice.', 'user_device_token');\n  pushNotif.send();\n  \n  // Test with custom icon for push notification\n  const customPushNotif = factory.createNotification('push', 'Reminder: Meeting at 3 PM.', 'user_device_token_2');\n  customPushNotif.icon = 'calendar'; // Modify after creation\n  customPushNotif.send();\n\n  console.log('\\n--- Invalid Type Test ---');\n  const invalidNotif = factory.createNotification('fax', 'Fax message', '123-456-7890');\n  invalidNotif.send();\n\n} catch (error) {\n  console.error(`Error: ${error.message}`);\n}\n",
          "testCases": [
            "Create an 'email' notification and verify its properties and `send` method output.",
            "Create an 'sms' notification and verify its properties and `send` method output.",
            "Create a 'push' notification and verify its properties (including default `icon`) and `send` method output.",
            "Attempt to create an unknown notification type and ensure it throws an error or handles it gracefully.",
            "Verify that `subject` and `icon` properties can be overridden if needed after creation."
          ],
          "hints": [
            "Use a `switch` statement or `if/else if` chain within `createNotification` to determine which object type to return.",
            "Each object type should be a plain JavaScript object literal (`{}`) with its specific properties and `send` method.",
            "Ensure the `send` method for each notification type correctly logs the message using its specific properties."
          ],
          "tags": [
            "Factory Pattern",
            "Design Patterns",
            "JavaScript",
            "Object Creation",
            "Decoupling"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Objects",
            "Functions",
            "Basic JavaScript control flow"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Polymorphism",
            "Abstraction"
          ]
        }
      ]
    }
  },
  {
    "id": "100bf5d7-a836-4e5a-8bc3-aa83cea7f416",
    "startLine": 200,
    "endLine": 299,
    "processedDate": "2025-06-17T06:59:05.064Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_singleton_pattern",
          "title": "Singleton Pattern",
          "content": "The Singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global point of access to that instance. It's useful when you need to coordinate actions across the system from a single, centralized object, such as a database connection, a configuration manager, or a logger.\n\n## Key Concepts\n-   **Single Instance:** Guarantees that only one object of a particular class can be instantiated.\n-   **Global Access:** Provides a well-known global point of access to that single instance.\n-   **Lazy Initialization:** The instance is often created only when it's first requested, saving resources if the instance is not always needed immediately.\n-   **Self-Encapsulation:** The Singleton class itself is responsible for managing its single instance.\n\n## Implementation in JavaScript\nIn JavaScript, the Singleton pattern is typically implemented using an Immediately Invoked Function Expression (IIFE) and a closure to maintain a private `instance` variable. The IIFE executes once and returns an object with a `getInstance` method. This method checks if an instance already exists; if not, it creates one and stores it, ensuring subsequent calls return the same instance.\n\n## Advantages\n-   **Controlled Access to Sole Instance:** Clients can access the instance only through the controlled `getInstance` method.\n-   **Reduced Namespace Pollution:** Avoids polluting the global namespace with numerous global variables.\n-   **Resource Management:** Useful for managing shared resources (e.g., database connections, file systems) to prevent conflicts and ensure efficient usage.\n-   **Lazy Instantiation:** The instance is created only when needed.\n\n## Disadvantages\n-   **Global State:** Can lead to tightly coupled code and make unit testing difficult due to shared global state.\n-   **Testing Challenges:** Mocking or isolating singletons for testing can be complex.\n-   **Violation of Single Responsibility Principle:** The class takes on two responsibilities: creating its own instance and performing its core business logic.",
          "examples": [
            {
              "id": "example_singleton_1",
              "title": "Basic Singleton Implementation",
              "code": "const Singleton = (function() {\n  let instance;\n  \n  function createInstance() {\n    // This function creates the actual object instance\n    return {\n      data: [],\n      addItem: function(item) {\n        this.data.push(item);\n        console.log(`Item added: ${item}. Current data: ${this.data}`);\n      },\n      getData: function() {\n        return this.data;\n      }\n    };\n  }\n  \n  return {\n    // The public method to get the single instance\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance(); // Create instance only if it doesn't exist\n      }\n      return instance;\n    }\n  };\n})();\n\nconst instance1 = Singleton.getInstance();\ninstance1.addItem('Apple');\n\nconst instance2 = Singleton.getInstance();\ninstance2.addItem('Banana');\n\nconsole.log(instance1 === instance2); // true - Both variables reference the exact same object\nconsole.log(instance1.getData()); // ['Apple', 'Banana'] - Data is shared\nconsole.log(instance2.getData()); // ['Apple', 'Banana']\n",
              "explanation": "This example demonstrates the classic JavaScript Singleton pattern using an IIFE. The `createInstance` function defines the actual object that will be single. The `getInstance` method within the returned object ensures that `createInstance` is called only once, lazily initializing the `instance` variable. Subsequent calls to `getInstance` simply return the already created instance, proving that `instance1` and `instance2` are indeed the same object.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_singleton_1",
            "question_singleton_2",
            "question_singleton_3",
            "question_singleton_4",
            "question_singleton_5"
          ],
          "relatedTasks": [
            "task_singleton_1"
          ],
          "tags": [
            "design-patterns",
            "creational-patterns",
            "javascript",
            "architecture",
            "state-management"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "iife",
            "closures",
            "object-oriented-programming"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced-state-management",
            "application-architecture"
          ]
        },
        {
          "id": "theory_adapter_pattern",
          "title": "Adapter Pattern",
          "content": "The Adapter pattern (also known as Wrapper) is a structural design pattern that allows objects with incompatible interfaces to collaborate. It acts as a bridge between two incompatible interfaces by wrapping an existing class with a new interface. This pattern is particularly useful when integrating legacy code or third-party libraries into a modern application without modifying their original source code.\n\n## Key Concepts\n-   **Incompatible Interfaces:** Two or more classes have functionalities that you want to use together, but their method signatures or structures do not match.\n-   **Adapter:** A new class that implements the target interface (the one the client expects) and contains an instance of the adaptee (the class with the incompatible interface). It translates calls from the target interface to the adaptee's interface.\n-   **Adaptee:** The existing class with the incompatible interface that needs to be adapted.\n-   **Client:** The code that uses the target interface and expects certain methods.\n\n## How it Works\nThe Adapter class contains an instance of the Adaptee class. When the Client calls a method on the Adapter, the Adapter translates this call into a corresponding method call on the Adaptee, effectively making the Adaptee compatible with the Client's expectations.\n\n## Advantages\n-   **Reusability:** Allows you to reuse existing classes whose interfaces don't match the one you need.\n-   **Flexibility:** Promotes loose coupling by allowing clients to interact with a consistent interface, regardless of the underlying implementation's original interface.\n-   **Legacy Integration:** Ideal for integrating legacy systems or third-party components into new applications without extensive refactoring.\n-   **Single Responsibility Principle:** The adapter's sole responsibility is to convert one interface to another, keeping the original classes focused on their own responsibilities.\n\n## Disadvantages\n-   **Increased Complexity:** Introduces new classes and objects, potentially making the codebase more complex, especially for small differences.\n-   **Performance Overhead:** A slight performance overhead can be introduced due to the additional layer of abstraction (method call delegation), though often negligible.\n\n## When to Use\n-   When you want to use an existing class, but its interface doesn't match the one you need.\n-   When you want to create a reusable class that cooperates with unrelated or unforeseen classes, meaning classes that don't necessarily have compatible interfaces.",
          "examples": [
            {
              "id": "example_adapter_1",
              "title": "Calculator Adapter Example",
              "code": "// Old Calculator with a single 'operate' method handling all operations\nclass OldCalculator {\n  operate(term1, term2, operation) {\n    switch(operation) {\n      case 'add': return term1 + term2;\n      case 'sub': return term1 - term2;\n      default: return NaN;\n    }\n  }\n}\n\n// New Calculator with separate methods for each operation\nclass NewCalculator {\n  add(term1, term2) {\n    return term1 + term2;\n  }\n  \n  sub(term1, term2) {\n    return term1 - term2;\n  }\n  \n  multiply(term1, term2) {\n    return term1 * term2;\n  }\n}\n\n// Adapter: Makes NewCalculator compatible with OldCalculator's 'operate' interface\nclass CalcAdapter {\n  constructor() {\n    this.calc = new NewCalculator(); // The Adaptee\n  }\n  \n  // Implements the target interface (OldCalculator's operate method signature)\n  operate(term1, term2, operation) {\n    switch(operation) {\n      case 'add': return this.calc.add(term1, term2);\n      case 'sub': return this.calc.sub(term1, term2);\n      // Can also add new operations from NewCalculator if needed\n      case 'multiply': return this.calc.multiply(term1, term2);\n      default: return NaN;\n    }\n  }\n}\n\n// Usage with OldCalculator (Client expects this interface)\nconst oldCalc = new OldCalculator();\nconsole.log('Old Calculator (add):', oldCalc.operate(10, 5, 'add')); // 15\nconsole.log('Old Calculator (sub):', oldCalc.operate(10, 5, 'sub')); // 5\n\n// Usage with Adapter (Client still uses the 'operate' interface, but NewCalculator logic is behind it)\nconst newCalcAdapter = new CalcAdapter();\nconsole.log('New Calculator (via Adapter add):', newCalcAdapter.operate(10, 5, 'add')); // 15\nconsole.log('New Calculator (via Adapter sub):', newCalcAdapter.operate(10, 5, 'sub')); // 5\nconsole.log('New Calculator (via Adapter multiply):', newCalcAdapter.operate(10, 5, 'multiply')); // 50\n",
              "explanation": "This example clearly illustrates the Adapter pattern. `OldCalculator` represents an existing system expecting a unified `operate` method. `NewCalculator` is a newer, perhaps more granular, system with separate methods for each operation. `CalcAdapter` acts as the bridge. It holds an instance of `NewCalculator` and implements the `operate` method that `OldCalculator` (and its clients) expect. Inside its `operate` method, it translates the generic operation string into specific method calls on the `NewCalculator` instance, effectively making `NewCalculator` compatible with the `OldCalculator`'s client code without modifying either original calculator class.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_adapter_1",
            "question_adapter_2",
            "question_adapter_3",
            "question_adapter_4",
            "question_adapter_5"
          ],
          "relatedTasks": [
            "task_adapter_1"
          ],
          "tags": [
            "design-patterns",
            "structural-patterns",
            "javascript",
            "integration",
            "api-design"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "interfaces"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "legacy-system-integration",
            "frontend-api-integration"
          ]
        },
        {
          "id": "theory_decorator_pattern",
          "title": "Decorator Pattern",
          "content": "The Decorator pattern is a structural design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. It provides a flexible alternative to subclassing for extending functionality.\n\n## Key Concepts\n-   **Component:** The interface or abstract class that defines the core behavior that decorators can add to.\n-   **Concrete Component:** An implementation of the Component, which is the object being decorated.\n-   **Decorator:** An abstract class that implements the Component interface and maintains a reference to a Component object. It serves as the base for concrete decorators.\n-   **Concrete Decorator:** Specific decorator classes that extend the Decorator and add new responsibilities or modify existing ones.\n\n## How it Works\nDecorators wrap the original object (or another decorator) and add their own functionality before or after calling the original object's method. They typically have the same interface as the object they decorate, allowing for transparent wrapping and stacking of multiple decorators.\n\n## Advantages\n-   **Flexible Functionality Extension:** Adds responsibilities to objects dynamically and transparently, avoiding the 'subclassing explosion' problem where you create many subclasses for different combinations of features.\n-   **Adherence to Open/Closed Principle:** You can extend an object's behavior without modifying its existing code (open for extension, closed for modification).\n-   **Composition over Inheritance:** Encourages building functionality by composing objects rather than relying solely on inheritance hierarchies, which can become rigid.\n-   **Run-time Configuration:** Behaviors can be added or removed at runtime.\n\n## Disadvantages\n-   **Many Small Objects:** Can result in a large number of small, similar objects if many combinations are needed, potentially increasing complexity.\n-   **Order Dependency:** The order of applying decorators might sometimes matter, leading to potential issues if not managed carefully.\n-   **Identity Issues:** Decorators add a layer of wrapping, so checking for object identity (`===`) might not work as expected if you're looking for the original wrapped object.\n\n## When to Use\n-   When you need to add responsibilities to individual objects dynamically and transparently.\n-   When you want to define objects that can have responsibilities removed.\n-   When extension by subclassing is impractical (e.g., too many independent extensions, or the class hierarchy is too large to manage).\n-   In frontend, common use cases include adding logging, caching, authentication checks, or UI enhancements to components or functions.",
          "examples": [
            {
              "id": "example_decorator_1",
              "title": "Coffee Shop Decorator Example (Completed)",
              "code": "/**\n * Component: Defines the interface for objects that can be decorated.\n * In this case, Coffee is the base component.\n */\nfunction Coffee() {\n  this.cost = function() {\n    return 5;\n  };\n  this.getDescription = function() {\n    return 'Basic Coffee';\n  };\n}\n\n/**\n * Concrete Decorator: Adds Milk functionality to a coffee object.\n * It wraps an existing coffee object and modifies its cost and description.\n */\nfunction Milk(coffee) {\n  const originalCost = coffee.cost();\n  const originalDescription = coffee.getDescription();\n  \n  coffee.cost = function() {\n    return originalCost + 1; // Add cost for milk\n  };\n  coffee.getDescription = function() {\n    return originalDescription + ', Milk'; // Add description for milk\n  };\n}\n\n/**\n * Concrete Decorator: Adds Whip functionality to a coffee object.\n */\nfunction Whip(coffee) {\n  const originalCost = coffee.cost();\n  const originalDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return originalCost + 0.5; // Add cost for whip\n  };\n  coffee.getDescription = function() {\n    return originalDescription + ', Whip'; // Add description for whip\n  };\n}\n\n// Usage:\nlet myCoffee = new Coffee();\nconsole.log(`Cost: ${myCoffee.cost()}, Description: ${myCoffee.getDescription()}`); // Cost: 5, Description: Basic Coffee\n\nMilk(myCoffee); // Decorate with Milk\nconsole.log(`Cost: ${myCoffee.cost()}, Description: ${myCoffee.getDescription()}`); // Cost: 6, Description: Basic Coffee, Milk\n\nWhip(myCoffee); // Decorate with Whip (after Milk)\nconsole.log(`Cost: ${myCoffee.cost()}, Description: ${myCoffee.getDescription()}`); // Cost: 6.5, Description: Basic Coffee, Milk, Whip\n\n// Another example: Coffee with only Whip\nlet anotherCoffee = new Coffee();\nWhip(anotherCoffee);\nconsole.log(`Cost: ${anotherCoffee.cost()}, Description: ${anotherCoffee.getDescription()}`); // Cost: 5.5, Description: Basic Coffee, Whip\n",
              "explanation": "This is a completed and functional example of the Decorator pattern. `Coffee` is the base component. `Milk` and `Whip` are concrete decorators. Each decorator takes a `coffee` object (which could be the base `Coffee` or another decorated `Coffee`) and wraps it, overriding its `cost` and `getDescription` methods to add new functionality (the cost and description of the topping). This demonstrates how you can dynamically stack decorators to add multiple functionalities to an object without altering its original class structure, adhering to the Open/Closed Principle.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_decorator_1",
            "question_decorator_2",
            "question_decorator_3",
            "question_decorator_4",
            "question_decorator_5"
          ],
          "relatedTasks": [
            "task_decorator_1"
          ],
          "tags": [
            "design-patterns",
            "structural-patterns",
            "javascript",
            "composition",
            "functional-programming"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "inheritance",
            "composition"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "component-enhancement",
            "flexible-api-design"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_singleton_1",
          "topic": "Singleton Pattern Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the Singleton design pattern?",
          "answer": "To ensure that a class has only one instance and provides a global point of access to it.",
          "options": [
            "To ensure that a class has only one instance and provides a global point of access to it.",
            "To allow objects with incompatible interfaces to work together.",
            "To attach new responsibilities to an object dynamically.",
            "To separate the construction of a complex object from its representation."
          ],
          "analysisPoints": [
            "Tests basic definition of Singleton.",
            "Distinguishes Singleton from other common patterns like Adapter, Decorator, and Builder."
          ],
          "keyConcepts": [
            "Singleton Pattern",
            "Creational Patterns",
            "Single Instance"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to distinguish between similar concepts"
          ],
          "example": "The Singleton pattern's core idea is to control instantiation to exactly one object, which is useful for resources like configuration managers or loggers where only one instance makes sense for consistency and resource management.",
          "tags": [
            "design-patterns",
            "singleton",
            "fundamentals"
          ],
          "prerequisites": [
            "basic-design-patterns"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_singleton_2",
          "topic": "Singleton Pattern Implementation in JavaScript",
          "level": "medium",
          "type": "code",
          "question": "Consider the following JavaScript Singleton implementation:\n\n```javascript\nconst ConfigManager = (function() {\n  let configInstance;\n\n  function createConfig() {\n    const settings = {\n      theme: 'dark',\n      fontSize: 16\n    };\n    return {\n      getSetting: (key) => settings[key],\n      setSetting: (key, value) => settings[key] = value\n    };\n  }\n\n  return {\n    getManager: function() {\n      if (!configInstance) {\n        configInstance = createConfig();\n      }\n      return configInstance;\n    }\n  };\n})();\n\nconst manager1 = ConfigManager.getManager();\nmanager1.setSetting('theme', 'light');\n\nconst manager2 = ConfigManager.getManager();\nconsole.log(manager2.getSetting('theme')); // What will be logged here?\nconsole.log(manager1 === manager2); // What will be logged here?\n```\n\nWhat will be the output of the `console.log` statements?",
          "answer": "light\ntrue",
          "options": [
            "dark\nfalse",
            "light\nfalse",
            "dark\ntrue",
            "light\ntrue"
          ],
          "analysisPoints": [
            "Tests understanding of Singleton's shared state.",
            "Evaluates knowledge of how `getInstance` ensures a single object reference."
          ],
          "keyConcepts": [
            "Singleton Pattern",
            "Shared State",
            "Closures",
            "IIFE"
          ],
          "evaluationCriteria": [
            "Ability to trace code execution",
            "Understanding of JavaScript closures and scope"
          ],
          "example": "The `ConfigManager` is a Singleton. When `manager1` modifies the `theme` setting, it changes the state of the *single* instance. Since `manager2` retrieves the *same* instance, it reflects the updated state. Therefore, `manager2.getSetting('theme')` will log 'light'. The comparison `manager1 === manager2` will be `true` because both variables point to the exact same object in memory.",
          "tags": [
            "design-patterns",
            "singleton",
            "javascript",
            "code-analysis"
          ],
          "prerequisites": [
            "closures",
            "iife"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_singleton_3",
          "topic": "Singleton Pattern Use Cases and Disadvantages",
          "level": "medium",
          "type": "open",
          "question": "Describe a real-world frontend scenario where the Singleton pattern would be beneficial. Also, discuss one major disadvantage of using Singletons, particularly in the context of testability.",
          "answer": "A beneficial real-world frontend scenario for a Singleton pattern is a global `AnalyticsManager` or `Logger`. For instance, an `AnalyticsManager` might be responsible for collecting user interactions and sending them to a backend analytics service. Having only one instance ensures that all analytics events are processed through a single, consistent pipeline, preventing duplicate event submissions or inconsistent data.\n\nOne major disadvantage of using Singletons is their impact on **testability**. Because Singletons provide a global point of access and maintain a global state, they introduce tight coupling within the application. During unit testing, it becomes difficult to isolate components that depend on a Singleton. You cannot easily replace the Singleton with a mock or stub implementation for a specific test case without affecting other tests or the entire application's state, leading to brittle tests and unpredictable results. This makes dependency injection harder and can lead to hidden dependencies.",
          "analysisPoints": [
            "Tests practical application of the pattern.",
            "Evaluates understanding of the pattern's drawbacks.",
            "Encourages critical thinking about architecture and testing."
          ],
          "keyConcepts": [
            "Singleton Pattern",
            "Use Cases",
            "Testability",
            "Global State",
            "Dependency Injection"
          ],
          "evaluationCriteria": [
            "Ability to identify appropriate use cases",
            "Understanding of design pattern trade-offs",
            "Knowledge of testing implications"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "singleton",
            "architecture",
            "testing"
          ],
          "prerequisites": [
            "software-architecture",
            "unit-testing"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_singleton_4",
          "topic": "Singleton Pattern vs. Global Variables",
          "level": "hard",
          "type": "open",
          "question": "While a Singleton provides a single instance, it's often argued that simply using a global variable can achieve a similar effect. Explain the key differences and advantages of using the Singleton pattern over a simple global variable for managing a single application-wide state (e.g., user preferences).",
          "answer": "While both a Singleton and a global variable provide a single point of access, the Singleton pattern offers several advantages:\n\n1.  **Controlled Instantiation and Lazy Loading:** A global variable is instantiated immediately when the script loads. A Singleton, on the other hand, typically uses lazy instantiation, meaning its instance is only created when `getInstance()` is called for the first time. This saves resources if the instance is not always needed.\n2.  **Encapsulation and API Control:** A global variable directly exposes its internal structure, allowing any part of the code to directly modify it without control. A Singleton encapsulates its instance creation logic and provides a controlled API (`getInstance()`) through which the instance is accessed. This allows for validation, logging, or other logic to be added to the access point.\n3.  **Namespace Pollution:** A global variable directly pollutes the global namespace, increasing the risk of naming conflicts. A Singleton, especially when implemented with an IIFE, keeps its internal workings private and exposes only its `getInstance` method, minimizing global footprint.\n4.  **Flexibility for Future Changes:** If requirements change and you need to manage multiple instances, or perhaps modify the instantiation logic, a Singleton provides a clearer structure to adapt. Refactoring from a global variable to a more complex object manager is often harder than modifying a Singleton's internal `createInstance` logic.\n5.  **Constructor Control:** In object-oriented languages, a Singleton can restrict direct instantiation (e.g., private constructors). While JavaScript doesn't have private constructors, the IIFE pattern achieves a similar effect by keeping `createInstance` private.\n\nIn essence, a Singleton provides a more structured, encapsulated, and controlled way to manage a single instance compared to the loose and less controllable nature of a bare global variable.",
          "analysisPoints": [
            "Distinguishes between a pattern and a simple language feature.",
            "Highlights benefits beyond mere single access.",
            "Tests understanding of good software design principles (encapsulation, lazy loading)."
          ],
          "keyConcepts": [
            "Singleton Pattern",
            "Global Variables",
            "Encapsulation",
            "Lazy Loading",
            "Namespace Pollution",
            "Design Principles"
          ],
          "evaluationCriteria": [
            "Depth of understanding of design principles",
            "Ability to articulate subtle differences",
            "Architectural reasoning"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "singleton",
            "architecture",
            "best-practices",
            "comparison"
          ],
          "prerequisites": [
            "object-oriented-programming",
            "javascript-fundamentals"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_singleton_5",
          "topic": "Singleton Pattern Flashcard",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core characteristic of the Singleton design pattern?",
          "answer": "It ensures that a class has only one instance and provides a global point of access to it.",
          "analysisPoints": [
            "Quick recall of core definition."
          ],
          "keyConcepts": [
            "Singleton Pattern",
            "Single Instance"
          ],
          "evaluationCriteria": [
            "Memory recall"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "singleton",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_adapter_1",
          "topic": "Adapter Pattern Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "What problem does the Adapter design pattern primarily solve?",
          "answer": "Allows objects with incompatible interfaces to work together.",
          "options": [
            "Ensures a class has only one instance.",
            "Allows behavior to be added to an individual object dynamically.",
            "Allows objects with incompatible interfaces to work together.",
            "Separates the construction of a complex object from its representation."
          ],
          "analysisPoints": [
            "Tests basic definition of Adapter.",
            "Distinguishes Adapter from other common patterns like Singleton, Decorator, and Builder."
          ],
          "keyConcepts": [
            "Adapter Pattern",
            "Structural Patterns",
            "Incompatible Interfaces"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to distinguish between similar concepts"
          ],
          "example": "The Adapter pattern is essentially a 'translator' between different interfaces, making existing components usable without modification.",
          "tags": [
            "design-patterns",
            "adapter",
            "fundamentals"
          ],
          "prerequisites": [
            "basic-design-patterns"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_adapter_2",
          "topic": "Adapter Pattern Implementation Details",
          "level": "medium",
          "type": "code",
          "question": "Given the following scenario where you have a legacy `Logger` and a new `AnalyticsService`:\n\n```javascript\n// Legacy logging system\nclass LegacyLogger {\n  logMessage(level, message) {\n    console.log(`[LEGACY ${level.toUpperCase()}]: ${message}`);\n  }\n}\n\n// New analytics service with a different method signature\nclass NewAnalyticsService {\n  sendEvent(eventName, payload) {\n    console.log(`[ANALYTICS EVENT]: ${eventName}, Payload:`, payload);\n  }\n}\n\n// Your goal is to create an adapter so that existing code expecting LegacyLogger's\n// `logMessage` interface can use NewAnalyticsService. Complete the `AnalyticsAdapter` class.\nclass AnalyticsAdapter {\n  constructor() {\n    this.analyticsService = new NewAnalyticsService();\n  }\n\n  logMessage(level, message) {\n    // TODO: Implement the adaptation logic here.\n    // Call this.analyticsService.sendEvent appropriately.\n  }\n}\n\n// Usage (existing code expecting LegacyLogger interface):\nconst adapter = new AnalyticsAdapter();\nadapter.logMessage('info', 'User logged in');\nadapter.logMessage('error', 'Failed to fetch data');\n```\n\nComplete the `logMessage` method in `AnalyticsAdapter` to correctly adapt calls to `NewAnalyticsService.sendEvent`.",
          "answer": "```javascript\nclass AnalyticsAdapter {\n  constructor() {\n    this.analyticsService = new NewAnalyticsService();\n  }\n\n  logMessage(level, message) {\n    // Adapting 'logMessage' to 'sendEvent'\n    const eventName = `log_${level}`;\n    const payload = { message: message };\n    this.analyticsService.sendEvent(eventName, payload);\n  }\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to implement the Adapter pattern.",
            "Requires understanding of translating parameters between different method signatures.",
            "Demonstrates knowledge of object composition for adaptation."
          ],
          "keyConcepts": [
            "Adapter Pattern",
            "Structural Patterns",
            "Interface Adaptation",
            "Object Composition"
          ],
          "evaluationCriteria": [
            "Correct implementation of the pattern",
            "Logical mapping of parameters"
          ],
          "example": "The `AnalyticsAdapter` wraps the `NewAnalyticsService`. Its `logMessage` method takes the `level` and `message` parameters and transforms them into an `eventName` (e.g., 'log_info') and a `payload` object, which are then passed to the `sendEvent` method of the `NewAnalyticsService`. This allows existing code to continue using `logMessage` while new analytics are sent.",
          "tags": [
            "design-patterns",
            "adapter",
            "javascript",
            "coding-challenge"
          ],
          "prerequisites": [
            "classes",
            "object-oriented-programming"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_adapter_3",
          "topic": "Adapter Pattern vs. Other Patterns",
          "level": "medium",
          "type": "open",
          "question": "How does the Adapter pattern differ from the Facade pattern, and in what scenarios would you choose one over the other in a frontend application?",
          "answer": "The Adapter and Facade patterns are both structural patterns that simplify interactions with complex systems, but they serve different purposes:\n\n*   **Adapter Pattern:** Its primary goal is to **make existing incompatible interfaces work together** without changing their source code. It wraps one class to match an expected interface. Think of it as a 'translator' between two existing, incompatible systems.\n    *   **Scenario:** You have a third-party charting library that expects data in `[{ x: ..., y: ... }]` format, but your application's data is in `[{ valueA: ..., valueB: ... }]`. An Adapter would convert your application's data format to the library's expected format.\n\n*   **Facade Pattern:** Its primary goal is to **provide a simplified, unified interface to a complex subsystem** composed of many classes. It hides the complexity of the subsystem and makes it easier to use. Think of it as a 'front desk' that simplifies access to multiple services.\n    *   **Scenario:** You have a complex authentication process involving multiple steps (user validation, token generation, session storage, refresh token handling). A Facade could expose a simple `login(username, password)` method that orchestrates all these underlying complex operations.\n\n**Key Differences:**\n*   **Purpose:** Adapter for interface compatibility; Facade for system simplification.\n*   **Scope:** Adapter typically works with two specific, incompatible interfaces; Facade aggregates multiple classes/objects into one simpler interface.\n*   **Direction of Change:** Adapter adjusts one existing interface to fit another; Facade creates a *new* simplified interface to a complex system.\n\n**When to choose:**\n*   Choose **Adapter** when you need to integrate existing components with differing interfaces, and you want to reuse those components without modifying them.\n*   Choose **Facade** when you want to simplify interactions with a complex set of classes or a subsystem, providing a higher-level, more user-friendly entry point.",
          "analysisPoints": [
            "Tests ability to differentiate similar patterns.",
            "Requires understanding of pattern intent and context.",
            "Encourages practical application through scenario discussion."
          ],
          "keyConcepts": [
            "Adapter Pattern",
            "Facade Pattern",
            "Interface Compatibility",
            "System Simplification",
            "Design Pattern Comparison"
          ],
          "evaluationCriteria": [
            "Clear distinction between patterns",
            "Relevant and accurate scenarios",
            "Architectural reasoning"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "adapter",
            "facade",
            "comparison",
            "architecture"
          ],
          "prerequisites": [
            "basic-design-patterns"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_adapter_4",
          "topic": "Adapter Pattern Flashcard",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main role of the 'adapter' class in the Adapter pattern?",
          "answer": "It implements the target interface and contains an instance of the adaptee, translating calls to make them compatible.",
          "analysisPoints": [
            "Quick recall of the adapter's role."
          ],
          "keyConcepts": [
            "Adapter Pattern",
            "Adapter Role",
            "Interface"
          ],
          "evaluationCriteria": [
            "Memory recall"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "adapter",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_adapter_5",
          "topic": "Adapter Pattern vs. Inheritance",
          "level": "hard",
          "type": "open",
          "question": "The Adapter pattern typically uses composition to achieve its goal. Could inheritance be used instead for interface adaptation? Discuss the pros and cons of using inheritance for adapting interfaces compared to composition (the typical approach).",
          "answer": "While inheritance *can* sometimes be used for adaptation (e.g., a class inherits from the Adaptee and implements the Target interface, or inherits from the Target and overrides methods to call Adaptee logic), it's generally **not the preferred approach** for the Adapter pattern compared to composition.\n\n**Using Composition (Preferred Method for Adapter):**\n*   **Pros:**\n    *   **Flexibility:** An adapter can adapt any instance of the adaptee, even if the adaptee is a final class or has no suitable hierarchy for inheritance.\n    *   **Loose Coupling:** The adapter is loosely coupled to the adaptee; it doesn't become part of the adaptee's hierarchy.\n    *   **Open/Closed Principle:** You can adapt new types of adaptees by creating new adapter classes without modifying existing ones.\n    *   **Runtime Flexibility:** You can change the adaptee instance at runtime if needed.\n*   **Cons:**\n    *   Slightly more boilerplate code (delegation).\n\n**Using Inheritance (Alternative, Less Preferred for Adapter):**\n*   **Pros:**\n    *   Can seem simpler for very specific, tightly coupled adaptations.\n*   **Cons:**\n    *   **Tight Coupling:** The adapter becomes tightly coupled to the adaptee's implementation details. Changes in the adaptee's internal structure can break the adapter.\n    *   **Limited Reusability/Flexibility:** An adapter using inheritance can only adapt a specific concrete adaptee class or one within its direct hierarchy. You can't easily adapt a different type of adaptee.\n    *   **Breaks Liskov Substitution Principle (LSP) often:** If the adapter inherits from the Adaptee, it means the adapter *is-a* Adaptee, but its behavior is altered, which can violate LSP.\n    *   **Subclassing Explosion:** If you have many adaptees or target interfaces, an inheritance-based approach can lead to a proliferation of subclasses.\n    *   **No Runtime Flexibility:** The adaptee is fixed at compile time (or class definition time).\n\n**Conclusion:** Composition is strongly preferred for the Adapter pattern because it promotes greater flexibility, loose coupling, and adherence to design principles like the Open/Closed Principle. Inheritance for adaptation introduces significant rigidity and reusability limitations that generally outweigh any perceived simplicity.",
          "analysisPoints": [
            "Deep understanding of design principles (composition vs. inheritance, Open/Closed, LSP).",
            "Ability to analyze the trade-offs of different implementation approaches.",
            "Demonstrates mature architectural thinking."
          ],
          "keyConcepts": [
            "Adapter Pattern",
            "Composition over Inheritance",
            "Inheritance",
            "Loose Coupling",
            "Open/Closed Principle",
            "Liskov Substitution Principle"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison",
            "Accurate explanation of principles",
            "Strong reasoning for preference"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "adapter",
            "inheritance",
            "composition",
            "advanced-concepts"
          ],
          "prerequisites": [
            "object-oriented-programming",
            "design-principles"
          ],
          "complexity": 9,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_decorator_1",
          "topic": "Decorator Pattern Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary goal of the Decorator design pattern?",
          "answer": "To attach new responsibilities to an object dynamically.",
          "options": [
            "To ensure a class has only one instance.",
            "To allow objects with incompatible interfaces to work together.",
            "To attach new responsibilities to an object dynamically.",
            "To provide a simplified interface to a complex subsystem."
          ],
          "analysisPoints": [
            "Tests basic definition of Decorator.",
            "Distinguishes Decorator from other common patterns like Singleton, Adapter, and Facade."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Structural Patterns",
            "Dynamic Behavior Extension"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to distinguish between similar concepts"
          ],
          "example": "The Decorator pattern is about adding 'wrappers' around an object to augment its behavior without altering its core class, much like adding toppings to a coffee.",
          "tags": [
            "design-patterns",
            "decorator",
            "fundamentals"
          ],
          "prerequisites": [
            "basic-design-patterns"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_decorator_2",
          "topic": "Decorator Pattern Implementation and Principles",
          "level": "medium",
          "type": "code",
          "question": "Consider a scenario where you have a basic `Button` component and you want to add logging and debouncing features to its `onClick` method without modifying the `Button`'s source code.\n\n```javascript\n// Base Component\nclass Button {\n  constructor(text) {\n    this.text = text;\n  }\n\n  onClick() {\n    console.log(`${this.text} clicked!`);\n  }\n}\n\n// Decorator: Adds logging to onClick\nfunction LogDecorator(button) {\n  const originalOnClick = button.onClick;\n  button.onClick = function() {\n    console.log(`[LOG] Button '${this.text}' click initiated.`);\n    originalOnClick.apply(this, arguments);\n    console.log(`[LOG] Button '${this.text}' click completed.`);\n  };\n}\n\n// Decorator: Adds debouncing to onClick (function needs to be provided)\nfunction DebounceDecorator(button, delay) {\n  const originalOnClick = button.onClick;\n  let timeoutId;\n  button.onClick = function() {\n    // TODO: Implement debouncing logic here.\n    // Call originalOnClick after 'delay' milliseconds, ensuring previous calls are cancelled.\n  };\n}\n\n// Usage\nconst myButton = new Button('Submit');\nLogDecorator(myButton);\nDebounceDecorator(myButton, 500); // 500ms delay\n\nmyButton.onClick(); // Should log and debounce\nmyButton.onClick(); // Should cancel the first call and only execute after delay\n```\n\nComplete the `DebounceDecorator` function to correctly debounce the `onClick` method.",
          "answer": "```javascript\n// Decorator: Adds debouncing to onClick (function needs to be provided)\nfunction DebounceDecorator(button, delay) {\n  const originalOnClick = button.onClick;\n  let timeoutId;\n  button.onClick = function(...args) {\n    const context = this;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      originalOnClick.apply(context, args);\n    }, delay);\n  };\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to implement a practical decorator.",
            "Requires understanding of closures and `this` context in JavaScript.",
            "Applies knowledge of debouncing algorithm.",
            "Demonstrates adherence to Open/Closed Principle."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Debouncing",
            "Closures",
            "Context (`this`)",
            "Open/Closed Principle"
          ],
          "evaluationCriteria": [
            "Correct implementation of debouncing",
            "Proper preservation of context",
            "Understanding of decorator mechanism"
          ],
          "example": "The `DebounceDecorator` takes the `button` object and a `delay`. It stores the `originalOnClick` method. It then replaces `button.onClick` with a new function that uses `clearTimeout` and `setTimeout` to ensure the `originalOnClick` is only called once after a `delay` period, effectively debouncing it. The `apply(context, args)` ensures the original function's `this` context and arguments are preserved.",
          "tags": [
            "design-patterns",
            "decorator",
            "javascript",
            "coding-challenge",
            "performance"
          ],
          "prerequisites": [
            "closures",
            "function-binding",
            "timers"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_decorator_3",
          "topic": "Decorator Pattern vs. Inheritance",
          "level": "medium",
          "type": "open",
          "question": "The Decorator pattern is often presented as a flexible alternative to subclassing. Explain why you might prefer using the Decorator pattern over inheritance when adding new responsibilities to objects, providing an example relevant to frontend development.",
          "answer": "You would prefer the Decorator pattern over inheritance for adding new responsibilities primarily due to its **flexibility** and adherence to the **Open/Closed Principle**.\n\n**Problems with Inheritance for Feature Extension:**\n1.  **Subclassing Explosion (Combinatorial Hell):** If you have a base class (e.g., `Button`) and several independent features to add (e.g., `Logging`, `Debouncing`, `Styling`), using inheritance would force you to create a large number of subclasses (e.g., `LoggingButton`, `DebouncedButton`, `StyledButton`, `LoggedDebouncedButton`, `LoggedStyledButton`, `DebouncedStyledButton`, `LoggedDebouncedStyledButton`). This quickly becomes unmanageable.\n2.  **Static Behavior:** Inheritance adds behavior at compile time. Once an object is instantiated, its behavior is fixed by its class hierarchy. You cannot dynamically add or remove behaviors at runtime.\n3.  **Tight Coupling:** Inheritance creates a tight coupling between the parent and child classes.\n\n**Advantages of Decorator Pattern:**\n1.  **Dynamic Behavior Addition:** Decorators allow you to add responsibilities to individual objects at runtime, rather than to an entire class hierarchy. This means you can pick and choose which specific features apply to a specific instance.\n2.  **Flexible Combinations:** You can combine multiple decorators in various ways, stacking them on top of each other, providing immense flexibility without creating a new class for every combination.\n3.  **Adherence to Open/Closed Principle:** The original class (e.g., `Button`) remains closed for modification, but its behavior is open for extension by new decorators. You don't need to touch the `Button` class code when adding new features.\n4.  **Composition over Inheritance:** Promotes a more flexible design by favoring composition, which allows for more dynamic relationships between objects.\n\n**Frontend Example:**\nConsider a `ProgressBar` component. You might want different progress bars to have different features:\n*   One `ProgressBar` might need **visual percentage updates**.\n*   Another might need **logging** of its progress changes.\n*   A third might need to trigger an **analytics event** when it reaches 100%.\n\nUsing inheritance would mean `LoggingProgressBar`, `AnalyticsProgressBar`, `LoggingAnalyticsProgressBar`, etc. With **Decorators**, you'd have a base `ProgressBar`, then functions like `withLogging(progressBar)`, `withAnalytics(progressBar)`, `withVisualUpdates(progressBar)`. You could then apply them dynamically:\n\n```javascript\nlet simpleProgressBar = new ProgressBar();\n\nlet loggedProgressBar = new ProgressBar();\nwithLogging(loggedProgressBar);\n\nlet analyticsLoggedProgressBar = new ProgressBar();\nwithLogging(analyticsLoggedProgressBar);\nwithAnalytics(analyticsLoggedProgressBar);\n```\nThis approach is far more scalable and maintainable.",
          "analysisPoints": [
            "Tests ability to compare and contrast design patterns.",
            "Evaluates understanding of software design principles (Open/Closed, composition vs. inheritance).",
            "Requires a clear, relevant frontend example."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Inheritance",
            "Subclassing Explosion",
            "Open/Closed Principle",
            "Composition over Inheritance",
            "Dynamic Behavior"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison",
            "Accurate explanation of principles",
            "Strong example"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "decorator",
            "inheritance",
            "comparison",
            "architecture"
          ],
          "prerequisites": [
            "object-oriented-programming",
            "design-principles"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_decorator_4",
          "topic": "Decorator Pattern Flashcard",
          "level": "easy",
          "type": "flashcard",
          "question": "What design principle is strongly supported by the Decorator pattern?",
          "answer": "The Open/Closed Principle (Open for extension, Closed for modification).",
          "analysisPoints": [
            "Quick recall of supported design principles."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Open/Closed Principle"
          ],
          "evaluationCriteria": [
            "Memory recall"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "decorator",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_decorator_5",
          "topic": "Decorator Pattern Limitations",
          "level": "hard",
          "type": "open",
          "question": "While powerful, the Decorator pattern is not without its drawbacks. Discuss at least two potential disadvantages or complexities that can arise when extensively using the Decorator pattern in a large frontend application.",
          "answer": "1.  **Many Small, Similar Objects and Increased Complexity:** Extensive use of the Decorator pattern can lead to a proliferation of many small, wrapper objects. Each decorator adds another layer of abstraction. While this provides flexibility, it can make the codebase harder to navigate and debug, especially when tracing calls through multiple layers of decorators. The object graph can become quite deep, obscuring the direct interaction with the core component.\n\n2.  **Identity Issues and Type Checking:** Because decorators wrap the original object, the decorated object is no longer strictly identical to the original one (`decoratedObject !== originalObject`). This can cause issues with identity checks (`===`) or `instanceof` checks if the client code expects a specific type of the *original* component rather than its decorated version. For example, if a function checks `if (component instanceof MyComponent)`, it might fail if `component` is actually `MyComponentDecoratedWithLogging`.\n\n3.  **Order Dependency:** In some cases, the order in which decorators are applied can matter significantly, especially if decorators modify shared state or interact with each other's modifications. Managing and enforcing the correct order can add complexity and lead to subtle bugs if not handled carefully.\n\n4.  **Configuration Overhead:** While flexible, constructing a highly decorated object (e.g., `new ConcreteComponent().decorateA().decorateB().decorateC()`) can become verbose and cumbersome. This often leads to needing a Factory or Builder pattern to manage the creation of pre-configured decorated objects.",
          "analysisPoints": [
            "Tests a deeper understanding of pattern trade-offs.",
            "Requires critical thinking about scaling pattern usage.",
            "Focuses on practical challenges in real-world applications."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Disadvantages",
            "Complexity",
            "Identity Issues",
            "Order Dependency"
          ],
          "evaluationCriteria": [
            "Identification of relevant disadvantages",
            "Clear explanation of complexities",
            "Practical insight"
          ],
          "example": "",
          "tags": [
            "design-patterns",
            "decorator",
            "limitations",
            "architecture"
          ],
          "prerequisites": [
            "advanced-design-patterns"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_singleton_1",
          "title": "Implement a Frontend Theme Manager using Singleton",
          "description": "\nImplement a global `ThemeManager` using the Singleton pattern. This manager should be responsible for setting and getting the current theme of the application (e.g., 'light', 'dark') and notifying subscribers when the theme changes. Ensure only one instance of the `ThemeManager` can ever exist.\n\n**Requirements:**\n1.  The `ThemeManager` must be implemented as a Singleton.\n2.  It should have methods `setTheme(themeName: string)` and `getTheme(): string`.\n3.  It should support a subscription mechanism: `subscribe(callback: (theme: string) => void)` which registers a callback to be invoked whenever the theme changes.\n4.  It should have an `unsubscribe(callback: (theme: string) => void)` method.\n5.  The initial theme should be 'light'.\n6.  Demonstrate its usage by setting a theme, retrieving it, and showing that multiple 'instances' actually point to the same object, and that subscribers are notified.\n",
          "difficulty": "medium",
          "startingCode": "type Theme = 'light' | 'dark' | 'system';\n\nconst ThemeManager = (function() {\n  let instance: any; // Use 'any' for simplicity, or define a proper interface\n  let currentTheme: Theme = 'light';\n  const subscribers: ((theme: string) => void)[] = [];\n\n  function createInstance() {\n    // TODO: Implement the methods for the ThemeManager instance\n    return {\n      getTheme: function(): Theme {\n        return currentTheme;\n      },\n      setTheme: function(newTheme: Theme): void {\n        if (currentTheme !== newTheme) {\n          currentTheme = newTheme;\n          // TODO: Notify all subscribers\n        }\n      },\n      subscribe: function(callback: (theme: string) => void): void {\n        // TODO: Add callback to subscribers list\n      },\n      unsubscribe: function(callback: (theme: string) => void): void {\n        // TODO: Remove callback from subscribers list\n      }\n    };\n  }\n\n  return {\n    getManager: function(): any {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// --- Demonstration Usage ---\n// const manager1 = ThemeManager.getManager();\n// const manager2 = ThemeManager.getManager();\n\n// console.log(manager1 === manager2); // Expected: true\n\n// manager1.subscribe((theme) => console.log('Subscriber 1:', theme));\n// const sub2 = (theme: string) => console.log('Subscriber 2:', theme);\n// manager2.subscribe(sub2);\n\n// manager1.setTheme('dark');\n// manager2.setTheme('system');\n// manager1.unsubscribe(sub2);\n// manager1.setTheme('light');\n",
          "solutionCode": "type Theme = 'light' | 'dark' | 'system';\n\nconst ThemeManager = (function() {\n  let instance: any;\n  let currentTheme: Theme = 'light';\n  const subscribers: ((theme: string) => void)[] = [];\n\n  function createInstance() {\n    return {\n      getTheme: function(): Theme {\n        return currentTheme;\n      },\n      setTheme: function(newTheme: Theme): void {\n        if (currentTheme !== newTheme) {\n          console.log(`Setting theme from '${currentTheme}' to '${newTheme}'`);\n          currentTheme = newTheme;\n          subscribers.forEach(callback => callback(currentTheme));\n        }\n      },\n      subscribe: function(callback: (theme: string) => void): void {\n        if (!subscribers.includes(callback)) {\n          subscribers.push(callback);\n          console.log('Subscriber added. Current subscribers:', subscribers.length);\n        }\n      },\n      unsubscribe: function(callback: (theme: string) => void): void {\n        const index = subscribers.indexOf(callback);\n        if (index > -1) {\n          subscribers.splice(index, 1);\n          console.log('Subscriber removed. Current subscribers:', subscribers.length);\n        }\n      }\n    };\n  }\n\n  return {\n    getManager: function(): any {\n      if (!instance) {\n        instance = createInstance();\n        console.log('ThemeManager instance created.');\n      }\n      return instance;\n    }\n  };\n})();\n\n// --- Demonstration Usage ---\nconsole.log('--- ThemeManager Demonstration ---');\nconst manager1 = ThemeManager.getManager();\nconst manager2 = ThemeManager.getManager();\n\nconsole.log('\\nAre manager1 and manager2 the same instance?', manager1 === manager2); // Expected: true\n\nconsole.log('\\nCurrent theme:', manager1.getTheme()); // Expected: light\n\nconst sub1 = (theme: string) => console.log('Subscriber 1 notified:', theme);\nmanager1.subscribe(sub1);\nconst sub2 = (theme: string) => console.log('Subscriber 2 notified:', theme);\nmanager2.subscribe(sub2);\n\nconsole.log('\\nSetting theme to dark via manager1...');\nmanager1.setTheme('dark'); // Both subscribers should be notified\n\nconsole.log('\\nCurrent theme:', manager2.getTheme()); // Expected: dark\n\nmanager1.unsubscribe(sub2);\nconsole.log('\\nSetting theme to system via manager2 (sub2 unsubscribed)...');\nmanager2.setTheme('system'); // Only sub1 should be notified\n\nconsole.log('\\nSetting theme to light (no change, no notification)...');\nmanager1.setTheme('system'); // No change, no notification\n\nconsole.log('\\nSetting theme to light again...');\nmanager1.setTheme('light');\n\n",
          "testCases": [
            "Calling `ThemeManager.getManager()` multiple times should always return the same instance.",
            "Initial theme retrieved by `getTheme()` should be 'light'.",
            "Calling `setTheme()` should update the theme and notify all subscribed callbacks.",
            "Unsubscribing a callback should prevent it from being notified on subsequent theme changes.",
            "Calling `setTheme()` with the current theme should not trigger notifications.",
            "Subscribing the same callback multiple times should only register it once."
          ],
          "hints": [
            "Remember to use a closure to hold the `instance` variable privately.",
            "The `setTheme` method needs to iterate through the `subscribers` array and call each callback.",
            "For `unsubscribe`, consider using `Array.prototype.indexOf` and `Array.prototype.splice` to remove the specific callback.",
            "Ensure `subscribe` does not add the same callback multiple times."
          ],
          "tags": [
            "design-patterns",
            "singleton",
            "state-management",
            "event-driven",
            "javascript"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "closures",
            "iife",
            "basic-oop"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "event-emitter",
            "pub-sub",
            "global-state"
          ]
        },
        {
          "id": "task_adapter_1",
          "title": "Create an API Data Adapter for a UI Component",
          "description": "\nImagine you have a `UserCard` UI component that expects user data in a specific format: `{ id: string, name: string, email: string }`. However, your backend API returns user data in a different, inconsistent format, such as `users/123` returning `{ userId: number, userName: string, userContact: { emailAddress: string } }` or another endpoint returning `users/456` as `{ uuid: string, fullName: string, contactEmail: string }`.\n\nYour task is to implement an `ApiUserAdapter` that takes raw API user data (from either format) and converts it into the format expected by the `UserCard` component. This allows the `UserCard` to remain unchanged while handling various backend data structures.\n\n**Requirements:**\n1.  Define a `UserCard` component (can be a simple class/function) that expects data `{ id: string, name: string, email: string }`.\n2.  Implement an `ApiUserAdapter` class.\n3.  The `ApiUserAdapter`'s constructor should accept the raw user data object from the API.\n4.  The `ApiUserAdapter` should have a method, e.g., `getAdaptedUserData()`, that returns the user data in the `UserCard`'s expected format.\n5.  The adapter must handle at least two different raw API data formats (as described above) and transform them correctly.\n6.  Demonstrate usage with example raw data and show the `UserCard` rendering the adapted data.\n",
          "difficulty": "medium",
          "startingCode": "interface UserCardData {\n  id: string;\n  name: string;\n  email: string;\n}\n\n// UserCard Component (simplified for demonstration)\nclass UserCard {\n  constructor(userData: UserCardData) {\n    this.userData = userData;\n  }\n\n  render() {\n    console.log(`\\n--- User Card ---\\nID: ${this.userData.id}\\nName: ${this.userData.name}\\nEmail: ${this.userData.email}\\n------------------`);\n  }\n}\n\n// Raw API Data Formats (mimic backend responses)\nconst apiUserFormat1 = {\n  userId: 101,\n  userName: 'Alice Smith',\n  userContact: { emailAddress: 'alice.smith@example.com' }\n};\n\nconst apiUserFormat2 = {\n  uuid: 'abc-123-def-456',\n  fullName: 'Bob Johnson',\n  contactEmail: 'bob.j@example.com'\n};\n\n// TODO: Implement the ApiUserAdapter class\nclass ApiUserAdapter {\n  private rawData: any;\n\n  constructor(rawData: any) {\n    this.rawData = rawData;\n  }\n\n  getAdaptedUserData(): UserCardData {\n    // Your adaptation logic here\n    // Check rawData structure and transform accordingly\n    if (this.rawData.hasOwnProperty('userId')) {\n      // Adapt format 1\n      return {\n        id: String(this.rawData.userId),\n        name: this.rawData.userName,\n        email: this.rawData.userContact.emailAddress\n      };\n    } else if (this.rawData.hasOwnProperty('uuid')) {\n      // Adapt format 2\n      return {\n        id: this.rawData.uuid,\n        name: this.rawData.fullName,\n        email: this.rawData.contactEmail\n      };\n    } else {\n      throw new Error('Unknown API user data format');\n    }\n  }\n}\n\n// --- Demonstration Usage ---\n// const adapter1 = new ApiUserAdapter(apiUserFormat1);\n// const userCard1 = new UserCard(adapter1.getAdaptedUserData());\n// userCard1.render();\n\n// const adapter2 = new ApiUserAdapter(apiUserFormat2);\n// const userCard2 = new UserCard(adapter2.getAdaptedUserData());\n// userCard2.render();\n",
          "solutionCode": "interface UserCardData {\n  id: string;\n  name: string;\n  email: string;\n}\n\n// UserCard Component (simplified for demonstration)\nclass UserCard {\n  private userData: UserCardData;\n\n  constructor(userData: UserCardData) {\n    this.userData = userData;\n  }\n\n  render() {\n    console.log(`\\n--- User Card ---\\nID: ${this.userData.id}\\nName: ${this.userData.name}\\nEmail: ${this.userData.email}\\n------------------`);\n  }\n}\n\n// Raw API Data Formats (mimic backend responses)\nconst apiUserFormat1 = {\n  userId: 101,\n  userName: 'Alice Smith',\n  userContact: { emailAddress: 'alice.smith@example.com' }\n};\n\nconst apiUserFormat2 = {\n  uuid: 'abc-123-def-456',\n  fullName: 'Bob Johnson',\n  contactEmail: 'bob.j@example.com'\n};\n\nconst apiUserFormat3Invalid = {\n  someId: 789,\n  firstName: 'Charlie',\n  lastName: 'Brown'\n};\n\n// ApiUserAdapter class\nclass ApiUserAdapter {\n  private rawData: any;\n\n  constructor(rawData: any) {\n    this.rawData = rawData;\n  }\n\n  getAdaptedUserData(): UserCardData {\n    if (this.rawData && typeof this.rawData === 'object') {\n      if (this.rawData.hasOwnProperty('userId') && this.rawData.hasOwnProperty('userName') && this.rawData.userContact && this.rawData.userContact.hasOwnProperty('emailAddress')) {\n        // Adapt format 1\n        return {\n          id: String(this.rawData.userId),\n          name: this.rawData.userName,\n          email: this.rawData.userContact.emailAddress\n        };\n      } else if (this.rawData.hasOwnProperty('uuid') && this.rawData.hasOwnProperty('fullName') && this.rawData.hasOwnProperty('contactEmail')) {\n        // Adapt format 2\n        return {\n          id: this.rawData.uuid,\n          name: this.rawData.fullName,\n          email: this.rawData.contactEmail\n        };\n      }\n    }\n    throw new Error('Unknown or invalid API user data format provided to adapter.');\n  }\n}\n\n// --- Demonstration Usage ---\nconsole.log('--- API User Adapter Demonstration ---');\n\n// Test Case 1: Format 1\nconsole.log('\\nAdapting API User Format 1:');\nconst adapter1 = new ApiUserAdapter(apiUserFormat1);\nconst userCard1 = new UserCard(adapter1.getAdaptedUserData());\nuserCard1.render();\n\n// Test Case 2: Format 2\nconsole.log('\\nAdapting API User Format 2:');\nconst adapter2 = new ApiUserAdapter(apiUserFormat2);\nconst userCard2 = new UserCard(adapter2.getAdaptedUserData());\nuserCard2.render();\n\n// Test Case 3: Invalid Format\nconsole.log('\\nTesting with Invalid API User Format:');\ntry {\n  const adapter3 = new ApiUserAdapter(apiUserFormat3Invalid);\n  const userCard3 = new UserCard(adapter3.getAdaptedUserData());\n  userCard3.render();\n} catch (error: any) {\n  console.error('Error caught as expected:', error.message);\n}\n\n// Test Case 4: Null/Undefined input\nconsole.log('\\nTesting with Null input:');\ntry {\n  const adapter4 = new ApiUserAdapter(null);\n  adapter4.getAdaptedUserData();\n} catch (error: any) {\n  console.error('Error caught as expected:', error.message);\n}\n",
          "testCases": [
            "Should correctly adapt `apiUserFormat1` to `UserCardData`.",
            "Should correctly adapt `apiUserFormat2` to `UserCardData`.",
            "Should throw an error for an unknown or invalid input format.",
            "Should handle null or undefined raw data gracefully (e.g., throw error)."
          ],
          "hints": [
            "Use conditional logic (e.g., `if/else if` or `switch`) to detect the incoming API data format based on unique keys.",
            "Ensure data types are correct, e.g., convert `userId` (number) to `id` (string) if necessary.",
            "Consider adding robust validation and error handling for unexpected input formats."
          ],
          "tags": [
            "design-patterns",
            "adapter",
            "api-integration",
            "data-transformation",
            "frontend"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "object-oriented-programming",
            "typescript-basics",
            "data-structures"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "data-modeling",
            "api-consumption",
            "loose-coupling"
          ]
        },
        {
          "id": "task_decorator_1",
          "title": "Build a Custom Event Logger for a DOM Element using Decorator",
          "description": "\nImplement a `DecoratedDiv` class that represents a simple `<div>` element. Your task is to use the Decorator pattern to add a `ClickLogger` feature to this `div`, so that every time it's clicked, a log message is printed to the console without modifying the original `DecoratedDiv` class or its event handling logic directly.\n\n**Requirements:**\n1.  Create a base `DecoratedDiv` class that creates a simple `div` element and appends it to the body. It should have a public `onClick` method that can be triggered (e.g., directly or by simulating a click).\n2.  Implement a `ClickLogger` decorator function (or class method) that takes a `DecoratedDiv` instance.\n3.  The `ClickLogger` decorator should augment the `onClick` method of the `DecoratedDiv` to log a message like `'[LOG]: Div with ID [divId] was clicked.'` **before** the original `onClick` logic executes.\n4.  Demonstrate the usage by creating a `DecoratedDiv`, applying the `ClickLogger` decorator, and then simulating clicks on it to observe the logging behavior.\n\n**Bonus:** Implement a `StylingDecorator` that changes the background color and adds a border to the `div` when applied. Make sure multiple decorators can be applied (e.g., `ClickLogger` and `StylingDecorator`).\n",
          "difficulty": "medium",
          "startingCode": "interface ClickableElement {\n  element: HTMLElement; // The actual DOM element\n  onClick(): void;\n}\n\n// Base Component: A simple div with a click handler\nclass DecoratedDiv implements ClickableElement {\n  public element: HTMLDivElement;\n  private id: string;\n\n  constructor(id: string = `div-${Math.random().toString(36).substr(2, 9)}`) {\n    this.id = id;\n    this.element = document.createElement('div');\n    this.element.id = this.id;\n    this.element.style.width = '100px';\n    this.element.style.height = '100px';\n    this.element.style.border = '1px solid black';\n    this.element.style.margin = '10px';\n    this.element.textContent = `Div ${this.id}`;\n    document.body.appendChild(this.element);\n\n    // Basic click listener to show original behavior\n    this.element.addEventListener('click', () => this.onClick());\n  }\n\n  onClick(): void {\n    console.log(`Original onClick for Div ID: ${this.id}`);\n  }\n}\n\n// TODO: Implement ClickLogger decorator\nfunction ClickLogger(target: DecoratedDiv): void {\n  const originalOnClick = target.onClick;\n  target.onClick = function() {\n    console.log(`[LOG]: Div with ID ${this.element.id} was clicked.`);\n    originalOnClick.apply(this, arguments);\n  };\n}\n\n// TODO (Bonus): Implement StylingDecorator\nfunction StylingDecorator(target: DecoratedDiv, color: string, border: string): void {\n  // Implement logic to apply styles\n}\n\n// --- Demonstration Usage ---\n// const myDiv = new DecoratedDiv('my-special-div');\n// ClickLogger(myDiv);\n// StylingDecorator(myDiv, 'lightblue', '2px dashed blue');\n\n// Simulate clicks\n// myDiv.element.click();\n// setTimeout(() => myDiv.element.click(), 500);\n",
          "solutionCode": "interface ClickableElement {\n  element: HTMLElement; // The actual DOM element\n  onClick(): void;\n}\n\n// Base Component: A simple div with a click handler\nclass DecoratedDiv implements ClickableElement {\n  public element: HTMLDivElement;\n  private id: string;\n\n  constructor(id: string = `div-${Math.random().toString(36).substr(2, 9)}`) {\n    this.id = id;\n    this.element = document.createElement('div');\n    this.element.id = this.id;\n    this.element.style.width = '120px'; // Slightly larger for better visibility\n    this.element.style.height = '120px';\n    this.element.style.border = '1px solid black';\n    this.element.style.margin = '10px';\n    this.element.style.padding = '5px';\n    this.element.style.textAlign = 'center';\n    this.element.style.lineHeight = '110px';\n    this.element.textContent = `Div ${this.id}`;\n    document.body.appendChild(this.element);\n\n    // Basic click listener to show original behavior\n    this.element.addEventListener('click', () => this.onClick());\n  }\n\n  onClick(): void {\n    console.log(`Original onClick for Div ID: ${this.id}`);\n  }\n\n  // Method to get the div's ID, useful for decorators\n  getId(): string {\n    return this.id;\n  }\n}\n\n// Decorator: Adds logging to onClick\nfunction ClickLogger(target: DecoratedDiv): void {\n  const originalOnClick = target.onClick;\n  target.onClick = function(...args: any[]): void {\n    console.log(`[LOG]: Div with ID ${target.getId()} was clicked.`);\n    originalOnClick.apply(this, args); // Use originalOnClick from closure, apply 'this' context\n  };\n}\n\n// Bonus Decorator: Adds styling\nfunction StylingDecorator(target: DecoratedDiv, backgroundColor: string, borderColor: string, borderWidth: string = '2px', borderStyle: string = 'solid'): void {\n  const originalRender = target.element.style.backgroundColor; // Capture original style if needed\n  target.element.style.backgroundColor = backgroundColor;\n  target.element.style.border = `${borderWidth} ${borderStyle} ${borderColor}`;\n  target.element.textContent = `Div ${target.getId()} (Styled)`;\n}\n\n// --- Demonstration Usage ---\nconsole.log('--- Decorator Pattern Demonstration ---');\n\n// Test Case 1: Basic Div\nconst div1 = new DecoratedDiv('div-A');\nconsole.log('Click div-A:');\ndiv1.element.click();\n\n// Test Case 2: Div with Click Logger\nconst div2 = new DecoratedDiv('div-B');\nClickLogger(div2);\nconsole.log('\\nClick div-B (with Logger):');\ndiv2.element.click();\nsetTimeout(() => div2.element.click(), 200);\n\n// Test Case 3: Div with Styling\nconst div3 = new DecoratedDiv('div-C');\nStylingDecorator(div3, 'lightgreen', 'darkgreen', '3px', 'dashed');\nconsole.log('\\nClick div-C (with Styling):');\ndiv3.element.click();\n\n// Test Case 4: Div with Both Click Logger and Styling\nconst div4 = new DecoratedDiv('div-D');\nClickLogger(div4);\nStylingDecorator(div4, 'coral', 'red', '4px', 'double');\nconsole.log('\\nClick div-D (with Logger & Styling):');\ndiv4.element.click();\nsetTimeout(() => div4.element.click(), 200);\n\n// Test Case 5: Apply decorators in different order (ClickLogger then Styling)\nconst div5 = new DecoratedDiv('div-E');\nStylingDecorator(div5, 'lightblue', 'blue', '2px', 'solid');\nClickLogger(div5);\nconsole.log('\\nClick div-E (with Styling then Logger):');\ndiv5.element.click();\n\n// Test Case 6: Verify identity issues (optional, illustrative)\nconst div6 = new DecoratedDiv('div-F');\nconst originalOnClickRef = div6.onClick;\nClickLogger(div6);\nconsole.log('\\nChecking identity after decoration:', originalOnClickRef === div6.onClick); // Expected: false\n",
          "testCases": [
            "A `DecoratedDiv` without decorators should only log its original `onClick` message.",
            "A `DecoratedDiv` with `ClickLogger` should log the decorator message *and then* the original `onClick` message.",
            "A `DecoratedDiv` with `StylingDecorator` should have its element's styles changed.",
            "A `DecoratedDiv` with both `ClickLogger` and `StylingDecorator` should exhibit both behaviors (logs and styles applied).",
            "The order of applying `ClickLogger` and `StylingDecorator` should not affect their individual functionality, demonstrating independence of concerns."
          ],
          "hints": [
            "To 'decorate' a method, store the `original` method first, then reassign the target's method to a new function that calls both your new logic and the `original` method.",
            "Remember to use `apply(this, arguments)` or `call(this, ...args)` to preserve the `this` context and pass all original arguments to the wrapped function.",
            "For the `StylingDecorator`, simply modify the `target.element.style` properties."
          ],
          "tags": [
            "design-patterns",
            "decorator",
            "dom-manipulation",
            "event-handling",
            "javascript",
            "frontend"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "closures",
            "this-keyword",
            "dom-api",
            "event-listeners"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "higher-order-functions",
            "component-enhancement",
            "aspect-oriented-programming"
          ]
        }
      ]
    }
  },
  {
    "id": "54df5f6d-c31c-47d7-b3fb-3c5d22ebdb41",
    "startLine": 300,
    "endLine": 399,
    "processedDate": "2025-06-17T07:02:41.158Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_decorator_pattern",
          "title": "Decorator Pattern",
          "content": "The Decorator pattern is a structural design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. It provides a flexible alternative to subclassing for extending functionality.\n\n## Key Concepts\n-   **Wrapper**: The decorator 'wraps' the original object, adding new functionality before or after delegating to the original object's method.\n-   **Dynamic Extension**: Functionality can be added or removed at runtime, offering more flexibility than static inheritance.\n-   **Avoids Subclass Explosion**: Instead of creating many subclasses for every combination of features (e.g., `CoffeeWithMilk`, `CoffeeWithWhip`, `CoffeeWithMilkAndWhip`), decorators allow you to compose features dynamically.\n-   **Open/Closed Principle**: The original object's code remains unchanged (closed for modification), while new features can be added (open for extension) through decorators.\n\n## Structure\n-   **Component**: Defines the interface for objects that can be decorated.\n-   **Concrete Component**: The original object to which responsibilities can be attached.\n-   **Decorator**: Maintains a reference to a Component object and conforms to the Component's interface.\n-   **Concrete Decorator**: Adds responsibilities to the Component.\n\n## Use Cases\n-   Adding features to objects without altering their core structure.\n-   When inheritance is impractical due to a large number of independent extensions.\n-   To add or remove responsibilities from an object at runtime.\n\n## Advantages\n-   More flexible than static inheritance.\n-   Avoids feature-laden classes high up in the hierarchy.\n-   Maintains separation of concerns by keeping different responsibilities in separate decorator classes.\n\n## Disadvantages\n-   Can result in a large number of small objects if many decorators are used.\n-   Debugging can become more complex due to multiple layers of wrapping.\n-   The order of wrapping might matter, leading to potential issues if not managed carefully.",
          "examples": [
            {
              "id": "example_decorator_1",
              "title": "Coffee Decorator Example",
              "code": "class Coffee {\n  constructor() {\n    this.price = 5;\n    this.description = 'Basic Coffee';\n  }\n\n  cost() {\n    return this.price;\n  }\n\n  getDescription() {\n    return this.description;\n  }\n}\n\nfunction Milk(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 1; // Add milk cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Milk';\n  };\n  return coffee;\n}\n\nfunction Whip(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 2; // Add whip cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Whip';\n  };\n  return coffee;\n}\n\nfunction Vanilla(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 3; // Add vanilla cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Vanilla';\n  };\n  return coffee;\n}\n\nconst myCoffee = new Coffee();\nconsole.log(`Base: ${myCoffee.getDescription()} - $${myCoffee.cost()}`); // Base: Basic Coffee - $5\n\nconst milkCoffee = Milk(myCoffee);\nconsole.log(`Milk: ${milkCoffee.getDescription()} - $${milkCoffee.cost()}`); // Milk: Basic Coffee, Milk - $6\n\nconst whippedMilkCoffee = Whip(milkCoffee);\nconsole.log(`Whipped Milk: ${whippedMilkCoffee.getDescription()} - $${whippedMilkCoffee.cost()}`); // Whipped Milk: Basic Coffee, Milk, Whip - $8\n\nconst finalCoffee = Vanilla(whippedMilkCoffee);\nconsole.log(`Final: ${finalCoffee.getDescription()} - $${finalCoffee.cost()}`); // Final: Basic Coffee, Milk, Whip, Vanilla - $11",
              "explanation": "This example demonstrates how the `Coffee` object's `cost()` and `getDescription()` methods are dynamically extended by `Milk`, `Whip`, and `Vanilla` functions. Each decorator function captures the current state (cost and description) of the `coffee` object it receives and then redefines the `cost` and `getDescription` methods to include its own contribution. This allows for flexible combinations of additives without creating a complex inheritance hierarchy.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_decorator_1",
            "question_decorator_2",
            "question_decorator_3",
            "question_decorator_4",
            "question_decorator_5",
            "question_decorator_6"
          ],
          "relatedTasks": [
            "task_decorator_ui_component"
          ],
          "tags": [
            "design-patterns",
            "structural-patterns",
            "javascript",
            "object-oriented-programming",
            "flexibility"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "functions-as-first-class-citizens",
            "closures"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "extensible-architecture",
            "dynamic-feature-addition"
          ]
        },
        {
          "id": "theory_observer_pattern",
          "title": "Observer Pattern",
          "content": "The Observer pattern is a behavioral design pattern that defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It's often used for implementing distributed event handling systems.\n\n## Key Concepts\n-   **Subject (Publisher)**: The object that holds the state and notifies its observers when its state changes. It maintains a list of registered observers and provides methods to attach, detach, and notify them.\n-   **Observer (Subscriber)**: The object that wants to be notified of changes in the Subject's state. It provides an `update` method that the Subject calls when a change occurs.\n-   **Loose Coupling**: Subject and Observer objects are loosely coupled. They don't need to know the concrete classes of each other; they only interact through interfaces.\n-   **Broadcast Communication**: A single change in the Subject can trigger updates in multiple observers simultaneously.\n\n## Structure\n-   A `Subject` class with methods like `subscribe` (or `attach`), `unsubscribe` (or `detach`), and `notify`.\n-   An `Observer` interface or class with an `update` method.\n-   Concrete `Subject` and `Observer` implementations.\n\n## Use Cases\n-   Event handling systems in UI frameworks (e.g., DOM events).\n-   Stock market applications where many clients need to be notified of price changes.\n-   RSS feeds and news aggregators.\n-   Model-View-Controller (MVC) architectures, where the Model notifies Views of state changes.\n\n## Advantages\n-   Supports loose coupling between Subject and Observer objects.\n-   Allows dynamic addition and removal of observers.\n-   Facilitates broadcast communication.\n\n## Disadvantages\n-   Can lead to unexpected updates if not managed carefully, especially in complex systems.\n-   Debugging can be challenging if the notification chain is long or complex.\n-   Performance overhead if there are too many observers or frequent notifications.",
          "examples": [
            {
              "id": "example_observer_1",
              "title": "Basic Observer Pattern Implementation",
              "code": "// Observer Pattern\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    if (this.observers.includes(observer)) {\n      console.log('Observer already subscribed.');\n      return;\n    }\n    this.observers.push(observer);\n    console.log(`${observer.name} subscribed.`);\n  }\n  \n  unsubscribe(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n      console.log(`${observer.name} unsubscribed.`);\n    } else {\n      console.log('Observer not found.');\n    }\n  }\n  \n  notify(data) {\n    console.log(`\nSubject notifying all observers with data: ${data}`);\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}\n\nconst newsPublisher = new Subject();\n\nconst subscriber1 = new Observer('John');\nconst subscriber2 = new Observer('Alice');\nconst subscriber3 = new Observer('Bob');\n\nnewsPublisher.subscribe(subscriber1);\nnewsPublisher.subscribe(subscriber2);\n\nnewsPublisher.notify('Breaking News: New JavaScript Framework Released!');\n// Output:\n// John subscribed.\n// Alice subscribed.\n// Subject notifying all observers with data: Breaking News: New JavaScript Framework Released!\n// John received: Breaking News: New JavaScript Framework Released!\n// Alice received: Breaking News: New JavaScript Framework Released!\n\nnewsPublisher.subscribe(subscriber3);\nnewsPublisher.notify('Sports Update: Local Team Wins Championship!');\n// Output:\n// Bob subscribed.\n// Subject notifying all observers with data: Sports Update: Local Team Wins Championship!\n// John received: Sports Update: Local Team Wins Championship!\n// Alice received: Sports Update: Local Team Wins Championship!\n// Bob received: Sports Update: Local Team Wins Championship!\n\nnewsPublisher.unsubscribe(subscriber1);\nnewsPublisher.notify('Weather Alert: Heavy Rain Expected!');\n// Output:\n// John unsubscribed.\n// Subject notifying all observers with data: Weather Alert: Heavy Rain Expected!\n// Alice received: Weather Alert: Heavy Rain Expected!\n// Bob received: Weather Alert: Heavy Rain Expected!",
              "explanation": "This example showcases the core functionality of the Observer pattern. The `Subject` acts as a news publisher, maintaining a list of `Observer` (subscribers). Subscribers can register (`subscribe`) or deregister (`unsubscribe`) themselves. When the publisher has new information, it calls `notify`, which iterates through its list of observers, calling their `update` method with the new data. This demonstrates how subscribers are automatically informed of changes without the publisher needing to know their specific types.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_observer_1",
            "question_observer_2",
            "question_observer_3",
            "question_observer_4",
            "question_observer_5",
            "question_observer_6"
          ],
          "relatedTasks": [
            "task_event_bus"
          ],
          "tags": [
            "design-patterns",
            "behavioral-patterns",
            "javascript",
            "event-handling",
            "loose-coupling"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "event-driven-architecture"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "realtime-applications",
            "ui-frameworks",
            "state-management"
          ]
        },
        {
          "id": "theory_strategy_pattern",
          "title": "Strategy Pattern",
          "content": "The Strategy pattern is a behavioral design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, a client class receives run-time instructions as to which algorithm to use from a family of algorithms. The pattern encapsulates each algorithm into a separate class, making them interchangeable.\n\n## Key Concepts\n-   **Context**: The class that uses one of the strategies. It holds a reference to a strategy object and delegates the execution of the algorithm to it.\n-   **Strategy Interface**: An interface or abstract class that defines a common interface for all concrete strategies. The context uses this interface to call the algorithm defined by a concrete strategy.\n-   **Concrete Strategies**: Implement the `Strategy` interface and provide specific implementations of the algorithm.\n-   **Algorithm Interchangeability**: The ability to swap different algorithms (strategies) at runtime without changing the context's code.\n\n## Structure\n-   A `Context` class that contains a `strategy` property and a method to execute the strategy (e.g., `calculate`).\n-   A `Strategy` abstract class or interface defining the method signature (e.g., `calculate`).\n-   Multiple `ConcreteStrategy` classes implementing the `Strategy` interface.\n\n## Use Cases\n-   When you have multiple algorithms for a specific task and want to select one at runtime.\n-   When you want to avoid a large conditional (if-else or switch) statement that selects among variations of an algorithm.\n-   To keep algorithm-specific data separate from the context.\n-   When different clients need different variations of an algorithm.\n\n## Advantages\n-   Allows algorithms to be selected and changed at runtime.\n-   Eliminates large conditional statements.\n-   Promotes the Open/Closed Principle (open for extension, closed for modification).\n-   Improved code organization and reusability of algorithms.\n\n## Disadvantages\n-   Increases the number of objects in the application (one for each strategy).\n-   The client must be aware of the different strategies and choose the appropriate one.\n-   Can be overkill for very simple algorithms with few variations.",
          "examples": [
            {
              "id": "example_strategy_1",
              "title": "Shipping Cost Calculation Strategy",
              "code": "// Strategy Pattern\n\n// Base Strategy Interface/Class\nclass ShippingStrategy {\n  calculate(order) {\n    throw new Error(\"Abstract method 'calculate' must be implemented\");\n  }\n}\n\n// Concrete Strategies\nclass FedEx extends ShippingStrategy {\n  calculate(order) {\n    console.log(`Calculating FedEx cost for order weight ${order.weight}`);\n    return order.weight * 3;\n  }\n}\n\nclass UPS extends ShippingStrategy {\n  calculate(order) {\n    console.log(`Calculating UPS cost for order weight ${order.weight}`);\n    return order.weight * 4;\n  }\n}\n\nclass USPS extends ShippingStrategy {\n  calculate(order) {\n    console.log(`Calculating USPS cost for order weight ${order.weight}`);\n    return order.weight * 2.5;\n  }\n}\n\n// Context Class\nclass Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n  \n  setStrategy(strategy) {\n    if (!(strategy instanceof ShippingStrategy)) {\n      throw new Error(\"Strategy must be an instance of ShippingStrategy.\");\n    }\n    this.strategy = strategy;\n    console.log(`Shipping strategy set to ${strategy.constructor.name}`);\n  }\n  \n  calculate(order) {\n    if (!this.strategy) {\n      throw new Error(\"No shipping strategy set.\");\n    }\n    return this.strategy.calculate(order);\n  }\n}\n\n// Usage\nconst order1 = { weight: 10, destination: 'NYC' };\nconst order2 = { weight: 5, destination: 'LA' };\n\nconst shipper = new Shipping();\n\n// Calculate with FedEx\nshipper.setStrategy(new FedEx());\nconsole.log('Order 1 FedEx Cost:', shipper.calculate(order1)); // Output: 30\nconsole.log('Order 2 FedEx Cost:', shipper.calculate(order2)); // Output: 15\n\n// Calculate with UPS\nshipper.setStrategy(new UPS());\nconsole.log('Order 1 UPS Cost:', shipper.calculate(order1));   // Output: 40\nconsole.log('Order 2 UPS Cost:', shipper.calculate(order2));   // Output: 20\n\n// Calculate with USPS\nshipper.setStrategy(new USPS());\nconsole.log('Order 1 USPS Cost:', shipper.calculate(order1)); // Output: 25\nconsole.log('Order 2 USPS Cost:', shipper.calculate(order2)); // Output: 12.5",
              "explanation": "This example demonstrates how different shipping cost calculation algorithms (FedEx, UPS, USPS) can be encapsulated as separate strategies. The `Shipping` class (Context) holds a reference to a `ShippingStrategy` object and delegates the `calculate` method call to it. This allows the shipping method to be changed dynamically at runtime using `setStrategy`, eliminating the need for conditional logic within the `Shipping` class itself and making it easy to add new shipping methods without modifying existing code.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_strategy_1",
            "question_strategy_2",
            "question_strategy_3",
            "question_strategy_4",
            "question_strategy_5",
            "question_strategy_6"
          ],
          "relatedTasks": [
            "task_payment_gateway"
          ],
          "tags": [
            "design-patterns",
            "behavioral-patterns",
            "javascript",
            "algorithms",
            "flexibility"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "polymorphism"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "configurable-logic",
            "rules-engines"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_decorator_1",
          "topic": "Decorator Pattern Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the Decorator design pattern?",
          "answer": "To dynamically add responsibilities or behaviors to an individual object without altering its core structure or affecting other objects of the same class.",
          "options": [],
          "analysisPoints": [
            "Focus on 'dynamically' and 'individual object' as key aspects of the pattern."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Dynamic Behavior",
            "Object Extension"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental purpose"
          ],
          "example": "N/A",
          "tags": [
            "decorator-pattern",
            "definition",
            "design-patterns"
          ],
          "prerequisites": [
            "basic-oo-concepts"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_decorator_2",
          "topic": "Decorator vs. Inheritance",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is a key advantage of using the Decorator pattern over inheritance for adding features to an object?",
          "answer": "It avoids the explosion of subclasses when combining multiple features.",
          "options": [
            "It provides a simpler code structure with fewer classes.",
            "It allows features to be added or removed dynamically at runtime.",
            "It improves performance by reducing method call overhead.",
            "It avoids the explosion of subclasses when combining multiple features."
          ],
          "analysisPoints": [
            "The Decorator pattern is specifically designed to handle situations where multiple feature combinations would lead to a large and unwieldy class hierarchy if inheritance were used.",
            "While it does allow dynamic modification, the 'subclass explosion' is a more direct and common problem it solves compared to simple inheritance for feature addition.",
            "It typically adds, not reduces, classes (decorators are classes).",
            "It can sometimes add overhead due to method wrapping."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Inheritance",
            "Subclass Explosion",
            "Flexibility"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between design pattern advantages",
            "Understanding of common software design problems"
          ],
          "example": "The Decorator pattern allows you to compose behaviors like `Coffee -> Milk -> Whip -> Vanilla` without needing classes like `MilkCoffee`, `WhipCoffee`, `MilkWhipCoffee`, etc. This significantly reduces the number of classes compared to a purely inheritance-based approach for combining features.",
          "tags": [
            "decorator-pattern",
            "inheritance",
            "trade-offs",
            "mcq"
          ],
          "prerequisites": [
            "decorator-pattern-basics",
            "inheritance-basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_decorator_3",
          "topic": "Decorator Pattern Implementation",
          "level": "medium",
          "type": "code",
          "question": "Implement a `Logger` decorator that adds logging functionality to any function. The decorator should log the function's name and its arguments before execution, and its return value after execution. If the function throws an error, log the error message.\n\nUse the following `add` function as an example to decorate:\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n```",
          "answer": "```javascript\nfunction Logger(func) {\n  return function(...args) {\n    const funcName = func.name || 'anonymous';\n    console.log(`[LOG] Calling ${funcName} with args: ${JSON.stringify(args)}`);\n    try {\n      const result = func(...args);\n      console.log(`[LOG] ${funcName} returned: ${JSON.stringify(result)}`);\n      return result;\n    } catch (error) {\n      console.error(`[LOG] ${funcName} threw an error: ${error.message}`);\n      throw error; // Re-throw the error to maintain original behavior\n    }\n  };\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction subtract(a, b) {\n  if (b === 0) throw new Error('Cannot subtract by zero!');\n  return a - b;\n}\n\nconst loggedAdd = Logger(add);\nconsole.log(loggedAdd(5, 3)); // Logs call, args, return, then outputs 8\n\nconst loggedSubtract = Logger(subtract);\nconsole.log(loggedSubtract(10, 4)); // Logs call, args, return, then outputs 6\n\ntry {\n  loggedSubtract(7, 0); // Logs call, args, error, then throws error\n} catch (e) {\n  console.error('Caught an expected error:', e.message);\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the decorator function signature: takes a function and returns a new function.",
            "Properly uses rest parameters (`...args`) and spread syntax (`func(...args)`) to handle arbitrary arguments.",
            "Includes `try-catch` block for error handling and logging.",
            "Ensures the original function's return value or error is propagated.",
            "Uses `func.name` for better logging messages."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Higher-Order Functions",
            "Function Wrapping",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Ability to implement a functional decorator.",
            "Handling of function arguments and return values.",
            "Robustness with error scenarios."
          ],
          "example": "N/A",
          "tags": [
            "decorator-pattern",
            "javascript",
            "higher-order-functions",
            "coding-challenge",
            "medium"
          ],
          "prerequisites": [
            "javascript-functions",
            "closures"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_decorator_4",
          "topic": "Decorator Pattern Disadvantages",
          "level": "medium",
          "type": "open",
          "question": "What are some potential disadvantages or complexities that can arise when extensively using the Decorator pattern in a large-scale application?",
          "answer": "Extensive use of the Decorator pattern can lead to several disadvantages:\n1.  **Increased Complexity/Number of Objects**: Each decorator is typically a separate class or function, which can lead to a proliferation of small, similar objects. Managing many layers of wrapped objects can make the code harder to understand and navigate.\n2.  **Debugging Challenges**: When an object is wrapped by multiple decorators, tracing the flow of execution and debugging issues can become significantly more challenging. Calls might pass through several layers of wrappers before reaching the base object's method, making stack traces harder to interpret.\n3.  **Order Dependence**: The order in which decorators are applied can sometimes matter, especially if decorators modify the same aspect of the decorated object or if they have side effects that impact subsequent decorators. This can introduce subtle bugs if the application order is not strictly managed.\n4.  **Configuration Overhead**: Configuring and assembling complex decorated objects can involve many lines of code to chain decorators together, potentially making instantiation cumbersome.",
          "options": [],
          "analysisPoints": [
            "Discusses impact on code readability and maintainability.",
            "Highlights debugging difficulties in multi-layered structures.",
            "Mentions potential issues with decorator application order.",
            "Considers the overhead of object creation and configuration."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Trade-offs",
            "Complexity",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Critical thinking about design pattern implications",
            "Ability to articulate potential downsides beyond basic definition"
          ],
          "example": "N/A",
          "tags": [
            "decorator-pattern",
            "disadvantages",
            "software-design",
            "open-ended"
          ],
          "prerequisites": [
            "decorator-pattern-full-understanding"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_decorator_5",
          "topic": "Decorator Pattern vs. Adapter Pattern",
          "level": "hard",
          "type": "mcq",
          "question": "Both Decorator and Adapter patterns involve wrapping objects. What is the fundamental difference in their intent?",
          "answer": "Decorator enhances an object with new responsibilities, while Adapter converts an interface into another interface clients expect.",
          "options": [
            "Decorator is structural, Adapter is behavioral.",
            "Decorator changes an object's interface, Adapter keeps it the same.",
            "Decorator enhances an object with new responsibilities, while Adapter converts an interface into another interface clients expect.",
            "Decorator allows dynamic modification, Adapter is static."
          ],
          "analysisPoints": [
            "Decorator's intent is *enhancement* or *extension* of functionality, maintaining the original interface.",
            "Adapter's intent is *conversion* or *compatibility* between incompatible interfaces, often without adding new responsibilities beyond translation.",
            "Both are structural patterns.",
            "Decorator generally maintains the interface, sometimes extending it. Adapter explicitly changes or adapts an interface.",
            "Both can involve dynamic elements, but their core purpose differs."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Adapter Pattern",
            "Design Pattern Comparison",
            "Structural Patterns"
          ],
          "evaluationCriteria": [
            "Deep understanding of design pattern intents",
            "Ability to distinguish between similar patterns"
          ],
          "example": "A `LoggingStream` decorator adds logging to an existing `FileStream` while still behaving like a stream. An `OldSystemAdapter` makes an old, incompatible API work with a new system by translating calls, changing its interface to match the new system's expectations.",
          "tags": [
            "decorator-pattern",
            "adapter-pattern",
            "comparison",
            "design-patterns",
            "mcq"
          ],
          "prerequisites": [
            "decorator-pattern",
            "adapter-pattern-knowledge"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_decorator_6",
          "topic": "Real-world Decorator Use Cases",
          "level": "medium",
          "type": "open",
          "question": "Can you provide two real-world examples or scenarios (beyond the coffee example) where the Decorator pattern would be a suitable design choice in a frontend application?",
          "answer": "1.  **UI Component Enhancement**: Imagine a base `Button` component. You might want to add functionalities like:\n    *   `LoadingButton` (adds a loading spinner and disables it during async operations).\n    *   `TooltipButton` (adds a tooltip on hover).\n    *   `AnalyticsButton` (sends analytics data on click).\n    Instead of creating `LoadingTooltipAnalyticsButton` subclasses, you can start with a `Button` and dynamically wrap it with `LoadingDecorator`, `TooltipDecorator`, and `AnalyticsDecorator`.\n\n2.  **Form Input Validation/Formatting**: Consider a generic `InputField` component. You might need to apply various validations (e.g., `RequiredValidator`, `EmailValidator`, `MinLengthValidator`) or formatting (e.g., `CurrencyFormatter`, `PhoneNumberFormatter`). You could implement these as decorators, allowing you to compose them for specific input fields (e.g., `RequiredValidator(EmailValidator(InputField))`) without modifying the `InputField` itself or creating subclasses for every combination of validation rules.",
          "options": [],
          "analysisPoints": [
            "Identifies scenarios where incremental, dynamic feature addition is beneficial.",
            "Demonstrates understanding of how decorators prevent subclass explosion in practical contexts.",
            "Provides concrete, plausible frontend-specific examples."
          ],
          "keyConcepts": [
            "Decorator Pattern",
            "Frontend Development",
            "UI Components",
            "Form Validation",
            "Real-World Examples"
          ],
          "evaluationCriteria": [
            "Ability to apply abstract pattern to practical problems",
            "Relevance to frontend domain"
          ],
          "example": "N/A",
          "tags": [
            "decorator-pattern",
            "frontend",
            "use-cases",
            "open-ended"
          ],
          "prerequisites": [
            "decorator-pattern-understanding"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_observer_1",
          "topic": "Observer Pattern Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary relationship established by the Observer design pattern?",
          "answer": "A one-to-many dependency, where one object (Subject) notifies many other objects (Observers) of its state changes.",
          "options": [],
          "analysisPoints": [
            "Emphasizes the 'one-to-many' relationship.",
            "Identifies Subject and Observer roles."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "One-to-Many",
            "Subject-Observer"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental relationship"
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "definition",
            "design-patterns"
          ],
          "prerequisites": [
            "basic-oo-concepts"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_observer_2",
          "topic": "Observer Pattern Benefits",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is a primary benefit of using the Observer pattern?",
          "answer": "It promotes loose coupling between the Subject and its Observers.",
          "options": [
            "It guarantees the order of notification for all observers.",
            "It eliminates the need for any form of communication between objects.",
            "It promotes tight coupling between the Subject and its Observers.",
            "It promotes loose coupling between the Subject and its Observers."
          ],
          "analysisPoints": [
            "Loose coupling is a hallmark of the Observer pattern, as the Subject only needs to know about the Observer interface, not concrete Observer types.",
            "The pattern does not guarantee notification order without additional mechanisms.",
            "It enables communication, not eliminates it.",
            "Tight coupling is the opposite of what the pattern aims for."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Loose Coupling",
            "Benefits",
            "Communication"
          ],
          "evaluationCriteria": [
            "Understanding of core benefits",
            "Distinguishing correct architectural principles"
          ],
          "example": "In the news publisher example, the publisher doesn't need to know if an observer is a 'MobileAppObserver' or a 'WebAppObserver', only that it implements an `update` method. This allows adding new observer types without changing the publisher.",
          "tags": [
            "observer-pattern",
            "benefits",
            "loose-coupling",
            "mcq"
          ],
          "prerequisites": [
            "observer-pattern-basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_observer_3",
          "topic": "Observer Pattern Implementation: Event Bus",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple `EventBus` class using the Observer pattern. It should have `subscribe(eventName, callback)`, `unsubscribe(eventName, callback)`, and `publish(eventName, data)` methods.\n\nDemonstrate its usage with at least two different event types and multiple subscribers for one event.",
          "answer": "```javascript\nclass EventBus {\n  constructor() {\n    this.subscribers = {}; // Stores eventName -> [callbacks]\n  }\n\n  subscribe(eventName, callback) {\n    if (typeof callback !== 'function') {\n      console.error('Callback must be a function.');\n      return;\n    }\n    if (!this.subscribers[eventName]) {\n      this.subscribers[eventName] = [];\n    }\n    if (!this.subscribers[eventName].includes(callback)) {\n      this.subscribers[eventName].push(callback);\n      console.log(`Subscribed to '${eventName}'`);\n    } else {\n      console.log(`Already subscribed to '${eventName}'.`);\n    }\n  }\n\n  unsubscribe(eventName, callback) {\n    if (!this.subscribers[eventName]) {\n      console.log(`No subscribers for '${eventName}'.`);\n      return;\n    }\n    this.subscribers[eventName] = this.subscribers[eventName].filter(cb => cb !== callback);\n    console.log(`Unsubscribed from '${eventName}'.`);\n  }\n\n  publish(eventName, data) {\n    if (!this.subscribers[eventName] || this.subscribers[eventName].length === 0) {\n      console.log(`No active subscribers for '${eventName}'.`);\n      return;\n    }\n    console.log(`\nPublishing event: '${eventName}' with data: ${JSON.stringify(data)}`);\n    this.subscribers[eventName].forEach(callback => {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error(`Error in subscriber for '${eventName}':`, error);\n      }\n    });\n  }\n}\n\n// --- Demonstration ---\nconst eventBus = new EventBus();\n\nconst handler1 = (data) => console.log(`Handler 1 for 'userLoggedIn': User ${data.username} logged in!`);\nconst handler2 = (data) => console.log(`Handler 2 for 'userLoggedIn': Welcome back, ${data.username}!`);\nconst handler3 = (data) => console.log(`Handler for 'productAdded': Item '${data.name}' added to cart.`);\n\n// Subscribe to 'userLoggedIn' event\neventBus.subscribe('userLoggedIn', handler1);\neventBus.subscribe('userLoggedIn', handler2);\n\n// Subscribe to 'productAdded' event\neventBus.subscribe('productAdded', handler3);\n\n// Publish 'userLoggedIn' event\neventBus.publish('userLoggedIn', { username: 'Alice', id: 101 });\n/* Expected Output:\nSubscribed to 'userLoggedIn'\nSubscribed to 'userLoggedIn'\nSubscribed to 'productAdded'\n\nPublishing event: 'userLoggedIn' with data: {\"username\":\"Alice\",\"id\":101}\nHandler 1 for 'userLoggedIn': User Alice logged in!\nHandler 2 for 'userLoggedIn': Welcome back, Alice!\n*/\n\n// Publish 'productAdded' event\neventBus.publish('productAdded', { name: 'Laptop', price: 1200 });\n/* Expected Output:\n\nPublishing event: 'productAdded' with data: {\"name\":\"Laptop\",\"price\":1200}\nHandler for 'productAdded': Item 'Laptop' added to cart.\n*/\n\n// Unsubscribe handler1 from 'userLoggedIn'\neventBus.unsubscribe('userLoggedIn', handler1);\n\n// Publish 'userLoggedIn' again\neventBus.publish('userLoggedIn', { username: 'Bob', id: 102 });\n/* Expected Output:\nUnsubscribed from 'userLoggedIn'.\n\nPublishing event: 'userLoggedIn' with data: {\"username\":\"Bob\",\"id\":102}\nHandler 2 for 'userLoggedIn': Welcome back, Bob!\n*/\n\n// Attempt to publish an event with no subscribers\neventBus.publish('nonExistentEvent', { message: 'hello' });\n// Expected Output: No active subscribers for 'nonExistentEvent'.\n",
          "options": [],
          "analysisPoints": [
            "Correctly uses a dictionary/map to store subscribers per event name.",
            "Implements `subscribe` to add callbacks to the correct event list.",
            "Implements `unsubscribe` to remove specific callbacks.",
            "Implements `publish` to iterate and call all relevant callbacks.",
            "Handles edge cases like no subscribers for an event or attempts to subscribe/unsubscribe non-functions/non-existent callbacks.",
            "Demonstrates robust error handling within `publish` to prevent one faulty subscriber from stopping others."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Event Bus",
            "Event Emitter",
            "Loose Coupling",
            "Callback Functions"
          ],
          "evaluationCriteria": [
            "Correct implementation of core Observer pattern methods.",
            "Handling of multiple event types and subscribers.",
            "Robustness and edge case consideration.",
            "Demonstrates understanding of event-driven architecture."
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "event-bus",
            "coding-challenge",
            "hard",
            "javascript"
          ],
          "prerequisites": [
            "object-oriented-programming",
            "closures",
            "array-methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_observer_4",
          "topic": "Observer Pattern vs. Pub/Sub Pattern",
          "level": "medium",
          "type": "open",
          "question": "Explain the key difference between the Observer pattern and the Publish/Subscribe (Pub/Sub) pattern. When might you choose one over the other?",
          "answer": "Both Observer and Publish/Subscribe patterns facilitate a form of one-to-many communication, but they differ in how the publisher and subscriber interact:\n\n**Observer Pattern (Direct Communication)**:\n*   **Relationship**: The Subject (publisher) maintains a direct reference to its Observers (subscribers). Observers register directly with the Subject.\n*   **Coupling**: While still loosely coupled (Subject knows only the Observer interface, not concrete types), there's a direct dependency: the Subject is aware of its observers.\n*   **Implementation**: Typically simpler to implement as it's a direct connection.\n*   **When to use**: Suitable when the Subject directly manages its observers and the relationship is straightforward, e.g., a GUI widget and its listeners, or a model notifying its views.\n\n**Publish/Subscribe (Indirect Communication via Broker)**:\n*   **Relationship**: Publishers and subscribers do not know each other directly. They communicate via an intermediary, often called a 'broker', 'message broker', 'event bus', or 'dispatcher'. Publishers publish messages to the broker, and subscribers subscribe to topics/events on the broker.\n*   **Coupling**: Achieves a higher degree of loose coupling (decoupled). Neither the publisher nor the subscriber needs to know about the other's existence; they only interact with the broker.\n*   **Implementation**: More complex due to the introduction of the intermediary, but offers greater flexibility and scalability.\n*   **When to use**: Ideal for distributed systems, complex event flows, or when you want to completely decouple publishers from subscribers, allowing publishers to be unaware of who or what is consuming their messages (e.g., microservices, large-scale frontend state management).\n\n**Choice**: Choose **Observer** for simpler, contained scenarios where direct subject-observer knowledge is acceptable. Choose **Pub/Sub** for more complex, decoupled, or distributed systems where greater separation and flexibility are required.",
          "options": [],
          "analysisPoints": [
            "Clearly defines the relationship and communication flow for both patterns.",
            "Highlights the coupling difference (direct vs. indirect/broker).",
            "Discusses implementation complexity.",
            "Provides clear use-case distinctions for when to choose each."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Publish/Subscribe Pattern",
            "Coupling",
            "Event Bus",
            "Design Pattern Comparison"
          ],
          "evaluationCriteria": [
            "Ability to articulate nuanced differences between related patterns",
            "Strategic understanding of pattern application"
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "pub-sub",
            "comparison",
            "design-patterns",
            "open-ended"
          ],
          "prerequisites": [
            "observer-pattern-understanding"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_observer_5",
          "topic": "Frontend Use Cases for Observer Pattern",
          "level": "medium",
          "type": "open",
          "question": "Describe two common scenarios in frontend development where the Observer pattern (or its variations like event listeners) is heavily utilized. Provide brief examples.",
          "answer": "1.  **DOM Events (Native Browser Implementation)**:\n    *   **Scenario**: Web browsers inherently use an Observer-like mechanism for handling user interactions with the DOM. Elements act as Subjects, and event listeners (functions) act as Observers.\n    *   **Example**: When a user clicks a button, the button element (`Subject`) notifies all registered click event handlers (`Observers`).\n    ```javascript\n    const myButton = document.getElementById('myButton');\n    myButton.addEventListener('click', (event) => {\n      console.log('Button clicked!', event);\n    }); // Observer subscribing to the button (Subject)\n    ```\n\n2.  **State Management Libraries (e.g., Redux, Vuex, MobX concepts)**:\n    *   **Scenario**: In many modern frontend frameworks, state management libraries often use an Observer or Pub/Sub pattern internally to notify components when the application's state changes. The 'store' or 'state' acts as the Subject, and components or reactive effects act as Observers.\n    *   **Example (conceptual for Redux/MobX)**: A component 'observes' a piece of state. When an action changes that state, the state management system (Subject) notifies the observing component, triggering a re-render.\n    ```javascript\n    // Conceptual example (simplified for illustration)\n    class Store {\n      constructor(initialState) {\n        this.state = initialState;\n        this.listeners = [];\n      }\n      subscribe(listener) { this.listeners.push(listener); }\n      dispatch(action) {\n        // ... update state based on action ...\n        this.listeners.forEach(listener => listener(this.state)); // Notify observers\n      }\n    }\n\n    const uiComponent = (state) => console.log('UI updated with new state:', state);\n    const store = new Store({ count: 0 });\n    store.subscribe(uiComponent); // UI component observes the store\n    store.dispatch({ type: 'INCREMENT' }); // Store changes, UI gets notified\n    ```",
          "options": [],
          "analysisPoints": [
            "Identifies native browser event handling as a prime example.",
            "Connects the pattern to state management in modern frameworks.",
            "Provides clear, concise code examples for each scenario.",
            "Shows practical application in frontend context."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Frontend Development",
            "DOM Events",
            "State Management",
            "Event Listeners"
          ],
          "evaluationCriteria": [
            "Ability to relate pattern to real-world frontend technology",
            "Knowledge of common frontend architectural patterns"
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "frontend",
            "use-cases",
            "open-ended"
          ],
          "prerequisites": [
            "observer-pattern-understanding",
            "javascript-dom",
            "frontend-framework-basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_observer_6",
          "topic": "Challenge: Multiple Subjects for an Observer",
          "level": "hard",
          "type": "code",
          "question": "Modify the `Observer` class from the theory example so that a single `Observer` instance can subscribe to and receive updates from multiple `Subject` instances. Demonstrate this by having one observer subscribe to two different subjects.\n\nOriginal `Observer`:\n```javascript\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}\n```\n\nOriginal `Subject`:\n```javascript\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  // ... other methods ...\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n```",
          "answer": "```javascript\nclass Subject {\n  constructor(name) {\n    this.name = name; // Added name for clarity in example\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    if (this.observers.includes(observer)) {\n      console.log(`Observer already subscribed to ${this.name}.`);\n      return;\n    }\n    this.observers.push(observer);\n    console.log(`${observer.name} subscribed to ${this.name}.`);\n  }\n  \n  unsubscribe(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n      console.log(`${observer.name} unsubscribed from ${this.name}.`);\n    }\n  }\n  \n  notify(data) {\n    console.log(`\n${this.name} notifying all observers with data: ${data}`);\n    // Pass subject name along with data for observer to identify source\n    this.observers.forEach(observer => observer.update(this.name, data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // Modified update method to accept subjectName\n  update(subjectName, data) {\n    console.log(`${this.name} received from ${subjectName}: ${data}`);\n  }\n}\n\n// --- Demonstration ---\nconst stockSubject = new Subject('Stock Exchange');\nconst weatherSubject = new Subject('Weather Service');\n\nconst personalDashboard = new Observer('My Dashboard');\n\n// My Dashboard subscribes to both subjects\nstockSubject.subscribe(personalDashboard);\nweatherSubject.subscribe(personalDashboard);\n\nstockSubject.notify('AAPL price increased to $175!');\nweatherSubject.notify('Temperature is 25°C, sunny!');\n\nconst anotherObserver = new Observer('Alert System');\nstockSubject.subscribe(anotherObserver);\nstockSubject.notify('GOOGL price decreased to $150!');\n\n// Output:\n// My Dashboard subscribed to Stock Exchange.\n// My Dashboard subscribed to Weather Service.\n// \n// Stock Exchange notifying all observers with data: AAPL price increased to $175!\n// My Dashboard received from Stock Exchange: AAPL price increased to $175!\n// \n// Weather Service notifying all observers with data: Temperature is 25°C, sunny!\n// My Dashboard received from Weather Service: Temperature is 25°C, sunny!\n// Alert System subscribed to Stock Exchange.\n// \n// Stock Exchange notifying all observers with data: GOOGL price decreased to $150!\n// My Dashboard received from Stock Exchange: GOOGL price decreased to $150!\n// Alert System received from Stock Exchange: GOOGL price decreased to $150!\n```",
          "options": [],
          "analysisPoints": [
            "The key modification is in the `Observer.update` method signature and the `Subject.notify` call.",
            "The `Subject` now passes its `name` (or `this` reference) along with the data during notification, allowing the observer to identify the source.",
            "The `Observer` instance can indeed be registered with multiple subjects.",
            "Demonstrates subscription to multiple subjects by a single observer."
          ],
          "keyConcepts": [
            "Observer Pattern",
            "Multiple Subjects",
            "Contextual Information",
            "Advanced Observer"
          ],
          "evaluationCriteria": [
            "Ability to adapt pattern for complex scenarios.",
            "Correctly passing contextual information in notifications.",
            "Demonstration of multi-subject observation."
          ],
          "example": "N/A",
          "tags": [
            "observer-pattern",
            "coding-challenge",
            "hard",
            "javascript"
          ],
          "prerequisites": [
            "observer-pattern-full-understanding"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_1",
          "topic": "Strategy Pattern Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main goal of the Strategy design pattern?",
          "answer": "To define a family of algorithms, encapsulate each one, and make them interchangeable at runtime.",
          "options": [],
          "analysisPoints": [
            "Highlights 'family of algorithms' and 'interchangeable at runtime' as core ideas."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Algorithms",
            "Runtime Selection"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental purpose"
          ],
          "example": "N/A",
          "tags": [
            "strategy-pattern",
            "definition",
            "design-patterns"
          ],
          "prerequisites": [
            "basic-oo-concepts"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_strategy_2",
          "topic": "Strategy Pattern vs. Large Conditional Statements",
          "level": "medium",
          "type": "mcq",
          "question": "A common problem the Strategy pattern helps to solve is the presence of large conditional statements (if-else if or switch-case). How does it achieve this?",
          "answer": "By encapsulating each algorithm in a separate class and allowing the context to delegate to the chosen strategy.",
          "options": [
            "By using higher-order functions to abstract away conditional logic.",
            "By consolidating all algorithms into a single, complex method.",
            "By encapsulating each algorithm in a separate class and allowing the context to delegate to the chosen strategy.",
            "By employing a factory pattern to create algorithms on demand."
          ],
          "analysisPoints": [
            "The essence of Strategy is delegating behavior to interchangeable objects, thus removing the need for `if/else if` inside the client.",
            "Higher-order functions can achieve similar goals but are not the direct mechanism of the Strategy pattern itself.",
            "Consolidating into one method would worsen the problem.",
            "Factory pattern is complementary but doesn't directly remove the conditionals within the algorithm selection, rather it might manage the creation of strategies."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Conditional Logic",
            "Code Smells",
            "Open/Closed Principle"
          ],
          "evaluationCriteria": [
            "Understanding of problem-solving approach",
            "Recognition of architectural improvements"
          ],
          "example": "Instead of `if (type === 'FedEx') { cost = weight * 3; } else if (type === 'UPS') { cost = weight * 4; }`, the `Shipping` context simply calls `this.strategy.calculate(order)`, with the specific `FedEx`, `UPS`, or `USPS` strategy being swapped in at runtime.",
          "tags": [
            "strategy-pattern",
            "problem-solving",
            "code-structure",
            "mcq"
          ],
          "prerequisites": [
            "strategy-pattern-basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strategy_3",
          "topic": "Strategy Pattern Implementation: Discount Calculator",
          "level": "medium",
          "type": "code",
          "question": "Implement a `DiscountStrategy` interface (or base class) and two concrete strategies: `PercentageDiscount` and `FixedAmountDiscount`. Then, create a `ShoppingCart` context class that can apply a selected discount strategy to calculate the final price.\n\n`PercentageDiscount` should apply a percentage (e.g., 10%) off the total.\n`FixedAmountDiscount` should apply a fixed amount (e.g., $5) off the total.",
          "answer": "```javascript\n// Strategy Interface/Base Class\nclass DiscountStrategy {\n  applyDiscount(total) {\n    throw new Error(\"Abstract method 'applyDiscount' must be implemented\");\n  }\n}\n\n// Concrete Strategy 1: Percentage Discount\nclass PercentageDiscount extends DiscountStrategy {\n  constructor(percentage) {\n    super();\n    this.percentage = percentage; // e.g., 0.10 for 10%\n  }\n\n  applyDiscount(total) {\n    if (total < 0) return 0; // Handle negative total if necessary\n    const discountAmount = total * this.percentage;\n    console.log(`Applying ${this.percentage * 100}% discount: -${discountAmount.toFixed(2)}`);\n    return total - discountAmount;\n  }\n}\n\n// Concrete Strategy 2: Fixed Amount Discount\nclass FixedAmountDiscount extends DiscountStrategy {\n  constructor(amount) {\n    super();\n    this.amount = amount; // e.g., 5 for $5\n  }\n\n  applyDiscount(total) {\n    if (total < 0) return 0; // Handle negative total if necessary\n    const finalTotal = total - this.amount;\n    console.log(`Applying fixed amount discount: -${this.amount.toFixed(2)}`);\n    return Math.max(0, finalTotal); // Ensure total doesn't go below zero\n  }\n}\n\n// Context Class: ShoppingCart\nclass ShoppingCart {\n  constructor() {\n    this.items = [];\n    this.discountStrategy = null; // No discount by default\n  }\n\n  addItem(name, price) {\n    this.items.push({ name, price });\n  }\n\n  calculateTotal() {\n    return this.items.reduce((sum, item) => sum + item.price, 0);\n  }\n\n  setDiscountStrategy(strategy) {\n    if (!(strategy instanceof DiscountStrategy)) {\n      throw new Error(\"Provided strategy must be an instance of DiscountStrategy.\");\n    }\n    this.discountStrategy = strategy;\n    console.log(`Discount strategy set to ${strategy.constructor.name}.`);\n  }\n\n  getFinalPrice() {\n    let total = this.calculateTotal();\n    if (this.discountStrategy) {\n      total = this.discountStrategy.applyDiscount(total);\n    }\n    return total;\n  }\n}\n\n// --- Demonstration ---\nconst cart = new ShoppingCart();\ncart.addItem('Laptop', 1000);\ncart.addItem('Mouse', 25);\n\nconsole.log(`Initial Total: $${cart.calculateTotal()}`); // Initial Total: $1025\n\n// Apply 10% percentage discount\nconst tenPercentOff = new PercentageDiscount(0.10);\ncart.setDiscountStrategy(tenPercentOff);\nconsole.log(`Price with 10% off: $${cart.getFinalPrice().toFixed(2)}`); // Price with 10% off: $922.50\n\n// Apply $50 fixed amount discount\nconst fiftyDollarsOff = new FixedAmountDiscount(50);\ncart.setDiscountStrategy(fiftyDollarsOff);\nconsole.log(`Price with $50 off: $${cart.getFinalPrice().toFixed(2)}`); // Price with $50 off: $975.00\n\n// Remove discount\ncart.setDiscountStrategy(null); // Or provide a NoDiscount strategy\nconsole.log(`Price without discount: $${cart.getFinalPrice().toFixed(2)}`); // Price without discount: $1025.00\n```",
          "options": [],
          "analysisPoints": [
            "Correctly defines a base `DiscountStrategy` and concrete implementations.",
            "Each concrete strategy implements the `applyDiscount` method with specific logic.",
            "The `ShoppingCart` acts as the context, holding a reference to the current strategy.",
            "The `getFinalPrice` method delegates the discount calculation to the active strategy.",
            "Handles edge cases like negative totals and ensuring final price doesn't go below zero for fixed discounts.",
            "Demonstrates setting and changing strategies dynamically."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Polymorphism",
            "Encapsulation",
            "Context",
            "Algorithms"
          ],
          "evaluationCriteria": [
            "Ability to structure classes according to the pattern.",
            "Correct implementation of different algorithms.",
            "Dynamic strategy selection.",
            "Handling of basic business logic and edge cases."
          ],
          "example": "N/A",
          "tags": [
            "strategy-pattern",
            "coding-challenge",
            "medium",
            "javascript"
          ],
          "prerequisites": [
            "object-oriented-programming",
            "classes"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strategy_4",
          "topic": "Strategy Pattern Disadvantages",
          "level": "medium",
          "type": "open",
          "question": "While the Strategy pattern offers great flexibility, what are some potential drawbacks or situations where it might not be the most appropriate choice?",
          "answer": "Potential drawbacks and inappropriate situations for the Strategy pattern include:\n1.  **Increased Number of Objects/Classes**: For every distinct algorithm, a new concrete strategy class must be created. If there are many algorithms, this can lead to a proliferation of small classes, making the project's structure more complex to navigate and manage.\n2.  **Client Awareness of Strategies**: The client (context) needs to know about all available concrete strategy classes to choose and set the appropriate one. This can expose implementation details to the client that might otherwise be hidden.\n3.  **Overkill for Simple Scenarios**: If an algorithm has very few, stable variations, or if the variations are very simple (e.g., a simple `if-else` or ternary operation), implementing the full Strategy pattern might introduce unnecessary overhead and complexity compared to a direct conditional statement.\n4.  **Runtime Overhead**: There's a slight runtime overhead due to polymorphism (virtual method calls) and object instantiation compared to a direct function call or conditional logic, though this is usually negligible for most applications.",
          "options": [],
          "analysisPoints": [
            "Discusses the impact on codebase size and navigation.",
            "Highlights the dependency of the client on strategy knowledge.",
            "Points out situations where simpler alternatives might be better.",
            "Mentions minor performance considerations."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Trade-offs",
            "Complexity",
            "Client Knowledge"
          ],
          "evaluationCriteria": [
            "Critical thinking about pattern applicability",
            "Understanding of design pattern overheads"
          ],
          "example": "N/A",
          "tags": [
            "strategy-pattern",
            "disadvantages",
            "software-design",
            "open-ended"
          ],
          "prerequisites": [
            "strategy-pattern-full-understanding"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_5",
          "topic": "Strategy Pattern vs. Template Method Pattern",
          "level": "hard",
          "type": "mcq",
          "question": "Both Strategy and Template Method patterns deal with algorithms. What is the main distinction regarding how they allow varying algorithm parts?",
          "answer": "Strategy varies the entire algorithm by delegating to different objects, while Template Method varies steps of an algorithm within an inheritance hierarchy.",
          "options": [
            "Strategy uses composition, Template Method uses inheritance.",
            "Strategy varies the entire algorithm by delegating to different objects, while Template Method varies steps of an algorithm within an inheritance hierarchy.",
            "Strategy is behavioral, Template Method is structural.",
            "Strategy works at compile-time, Template Method works at runtime."
          ],
          "analysisPoints": [
            "Strategy is about swapping *entire* algorithms at runtime via composition.",
            "Template Method defines an algorithm's skeleton in a base class, with specific steps implemented by subclasses (inheritance).",
            "Both are behavioral patterns.",
            "Both are typically runtime concepts, but Template Method's variability is defined at compile time through subclasses.",
            "The first option is true (composition vs. inheritance) but doesn't fully capture the essence of 'how they allow varying algorithm parts'."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Template Method Pattern",
            "Design Pattern Comparison",
            "Algorithms",
            "Composition vs Inheritance"
          ],
          "evaluationCriteria": [
            "Deep understanding of behavioral pattern mechanics",
            "Ability to articulate precise differences in algorithm variation approaches"
          ],
          "example": "In Strategy, `Shipping.calculate` delegates to `FedEx.calculate` or `UPS.calculate` (swapping the whole logic). In Template Method, a `BuildHouse` abstract class might have `buildWalls()`, `buildRoof()`, etc., with `ModernHouse` and `TraditionalHouse` subclasses overriding specific steps like `buildWalls` while the `buildHouse()` sequence remains fixed in the base class.",
          "tags": [
            "strategy-pattern",
            "template-method-pattern",
            "comparison",
            "design-patterns",
            "mcq"
          ],
          "prerequisites": [
            "strategy-pattern",
            "template-method-pattern-knowledge"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_6",
          "topic": "Frontend Use Cases for Strategy Pattern",
          "level": "medium",
          "type": "open",
          "question": "Provide two practical frontend scenarios (besides shipping costs) where the Strategy pattern would be a beneficial design choice.",
          "answer": "1.  **Form Validation**: Different input fields or forms might require different sets of validation rules (e.g., an email field needs email validation, a password field needs complexity validation, a registration form needs multiple validations). Instead of a large `if/else` block for each form or field, you can define validation strategies (e.g., `EmailValidationStrategy`, `PasswordValidationStrategy`, `RequiredValidationStrategy`) and apply them dynamically to a form context or input component.\n\n2.  **Payment Processing**: An e-commerce application needs to support various payment methods (e.g., Credit Card, PayPal, Crypto, Apple Pay). Each method involves a different set of API calls and logic. The Strategy pattern allows you to encapsulate each payment method as a concrete strategy (e.g., `CreditCardPaymentStrategy`, `PayPalPaymentStrategy`). The checkout process (context) can then simply use `paymentProcessor.execute(order)` regardless of the chosen method, swapping the strategy based on user selection.",
          "options": [],
          "analysisPoints": [
            "Identifies scenarios with multiple, interchangeable algorithms for a single operation.",
            "Demonstrates understanding of how Strategy pattern helps avoid conditional logic and promotes flexibility.",
            "Provides clear, relevant frontend examples."
          ],
          "keyConcepts": [
            "Strategy Pattern",
            "Frontend Development",
            "Form Validation",
            "Payment Processing",
            "Real-World Examples"
          ],
          "evaluationCriteria": [
            "Ability to apply abstract pattern to practical problems",
            "Relevance to frontend domain"
          ],
          "example": "N/A",
          "tags": [
            "strategy-pattern",
            "frontend",
            "use-cases",
            "open-ended"
          ],
          "prerequisites": [
            "strategy-pattern-understanding"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_decorator_ui_component",
          "title": "Implement a Decorator Pattern for UI Button Enhancements",
          "description": "\nYour task is to implement a flexible `Button` component system using the Decorator pattern. You will start with a basic `Button` class and then create several decorator functions to add different visual and behavioral enhancements.\n\n**Requirements:**\n1.  Create a `Button` class with a `text` property and a `render()` method that returns its HTML string representation (e.g., `<button>Basic Button</button>`).\n2.  Implement a `DangerButton` decorator function that takes a button component and modifies its `render()` output to include a 'danger' class (e.g., `<button class=\"danger\">...`); it should also modify the text to add '(Danger)'.\n3.  Implement a `DisabledButton` decorator function that takes a button component and modifies its `render()` output to include the `disabled` attribute (e.g., `<button disabled>...`); it should also prepend '(Disabled)' to the text.\n4.  Implement a `IconButton` decorator function that takes a button component and an `iconClass` string, adding an `<i>` tag with the icon class before the button's text within the `render()` output (e.g., `<button><i class=\"fa fa-trash\"></i>Delete</button>`).\n5.  Demonstrate the usage by creating:\n    *   A basic button.\n    *   A danger button with an icon.\n    *   A disabled button.\n    *   A button with all three decorations applied.\n\n**Note**: Each decorator should return the modified button object, ensuring chainability. The original `Button` object should maintain its core functionality while being enhanced.",
          "difficulty": "medium",
          "startingCode": "class Button {\n  constructor(text) {\n    this.text = text;\n  }\n\n  render() {\n    return `<button>${this.text}</button>`;\n  }\n}\n\n// Implement decorator functions here: DangerButton, DisabledButton, IconButton\n\n// function DangerButton(button) { /* ... */ }\n// function DisabledButton(button) { /* ... */ }\n// function IconButton(button, iconClass) { /* ... */ }\n\n// Demonstrate usage below:\n// const basicButton = new Button('Submit');\n// console.log(basicButton.render());\n\n// const dangerIconDeleteButton = IconButton(DangerButton(new Button('Delete')), 'fa fa-trash');\n// console.log(dangerIconDeleteButton.render());\n",
          "solutionCode": "class Button {\n  constructor(text) {\n    this.text = text;\n    this.classes = [];\n    this.attributes = [];\n    this.icon = '';\n  }\n\n  render() {\n    const classAttr = this.classes.length > 0 ? ` class=\"${this.classes.join(' ')}\"` : '';\n    const otherAttrs = this.attributes.length > 0 ? ` ${this.attributes.join(' ')}` : '';\n    const iconHtml = this.icon ? `<i class=\"${this.icon}\"></i> ` : '';\n    return `<button${classAttr}${otherAttrs}>${iconHtml}${this.text}</button>`;\n  }\n}\n\nfunction DangerButton(button) {\n  const originalRender = button.render;\n  const originalText = button.text;\n\n  button.render = function() {\n    if (!this.classes.includes('danger')) {\n      this.classes.push('danger');\n    }\n    this.text = `(Danger) ${originalText}`;\n    return originalRender.call(this);\n  };\n  return button;\n}\n\nfunction DisabledButton(button) {\n  const originalRender = button.render;\n  const originalText = button.text;\n\n  button.render = function() {\n    if (!this.attributes.includes('disabled')) {\n      this.attributes.push('disabled');\n    }\n    this.text = `(Disabled) ${originalText}`;\n    return originalRender.call(this);\n  };\n  return button;\n}\n\nfunction IconButton(button, iconClass) {\n  const originalRender = button.render;\n\n  button.render = function() {\n    this.icon = iconClass;\n    return originalRender.call(this);\n  };\n  return button;\n}\n\n// --- Demonstration ---\nconsole.log('--- Basic Button ---');\nconst basicButton = new Button('Submit');\nconsole.log(basicButton.render());\n// Expected: <button>Submit</button>\n\nconsole.log('\\n--- Danger Button with Icon ---');\nconst dangerIconDeleteButton = IconButton(DangerButton(new Button('Delete')), 'fa fa-trash');\nconsole.log(dangerIconDeleteButton.render());\n// Expected: <button class=\"danger\"><i class=\"fa fa-trash\"></i> (Danger) Delete</button>\n\nconsole.log('\\n--- Disabled Button ---');\nconst disabledButton = DisabledButton(new Button('Click Me'));\nconsole.log(disabledButton.render());\n// Expected: <button disabled>(Disabled) Click Me</button>\n\nconsole.log('\\n--- Fully Decorated Button ---');\nconst fullFeaturedButton = IconButton(\n  DisabledButton(\n    DangerButton(new Button('Purchase'))\n  ),\n  'fa fa-shopping-cart'\n);\nconsole.log(fullFeaturedButton.render());\n// Expected: <button class=\"danger\" disabled><i class=\"fa fa-shopping-cart\"></i> (Disabled) (Danger) Purchase</button>\n\n// Test order independence (demonstrate that it can be applied in different orders)\nconsole.log('\\n--- Different Order ---');\nconst differentOrderButton = DangerButton(\n  IconButton(\n    DisabledButton(new Button('Upload')),\n    'fa fa-upload'\n  )\n);\nconsole.log(differentOrderButton.render());\n// Expected: <button disabled class=\"danger\"><i class=\"fa fa-upload\"></i> (Danger) (Disabled) Upload</button>\n",
          "testCases": [
            "A basic button should render correctly without any decorators.",
            "Applying `DangerButton` should add `class='danger'` and '(Danger)' to text.",
            "Applying `DisabledButton` should add `disabled` attribute and '(Disabled)' to text.",
            "Applying `IconButton` should add the icon `<i>` tag.",
            "Chaining multiple decorators (e.g., Danger -> Icon) should apply all effects cumulatively.",
            "Test for correct HTML structure and attribute/class/text inclusion for combined decorators.",
            "Verify that decorators modify the *returned* `button` instance, allowing for chainability.",
            "Test with different order of decorators to ensure robustness (e.g., `IconButton(DangerButton(button))` vs `DangerButton(IconButton(button))`)."
          ],
          "hints": [
            "Decorators should typically store the original method (e.g., `button.render`) and then wrap it with new logic, calling the original method to maintain the chain.",
            "Remember that the `this` context within the wrapped method should refer to the decorated object, so `originalRender.call(this)` can be useful.",
            "For adding classes or attributes, consider having properties in the base `Button` class (e.g., `this.classes = []`, `this.attributes = []`) that decorators can push into, and `render` then joins them.",
            "Ensure each decorator returns the `button` object it received to enable chaining."
          ],
          "tags": [
            "design-patterns",
            "decorator-pattern",
            "frontend",
            "ui-components",
            "javascript"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "object-oriented-programming",
            "closures",
            "html-templating"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "composition-over-inheritance",
            "higher-order-functions",
            "html-manipulation"
          ]
        },
        {
          "id": "task_event_bus",
          "title": "Build a Simple Frontend Event Bus",
          "description": "\nYour task is to implement a simple `EventBus` (or `EventEmitter`) for a frontend application based on the Observer pattern. This bus will allow different parts of your application to communicate without direct dependencies.\n\n**Requirements:**\n1.  Create an `EventBus` class with the following methods:\n    *   `on(eventName, listener)`: Registers a `listener` (callback function) for a specific `eventName`.\n    *   `off(eventName, listener)`: Unregisters a `listener` for a specific `eventName`.\n    *   `emit(eventName, data)`: Notifies all listeners registered for `eventName` with the provided `data`.\n2.  The `EventBus` should be able to manage multiple event names, and each event name can have multiple listeners.\n3.  Ensure that attempting to subscribe the same listener twice to the same event name doesn't result in duplicate notifications.\n4.  Handle cases where an event is emitted but has no subscribers, or where an attempt is made to unsubscribe a non-existent listener.\n5.  Demonstrate the `EventBus` functionality with a scenario simulating UI interactions (e.g., a 'userLoggedIn' event and a 'productAddedToCart' event) and multiple components (listeners) reacting to these events.\n",
          "difficulty": "medium",
          "startingCode": "class EventBus {\n  constructor() {\n    // Your internal storage for listeners, e.g., an object mapping event names to arrays of callbacks\n    this.listeners = {}; \n  }\n\n  /**\n   * Registers a listener for a specific event.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {function} listener - The callback function to execute when the event is emitted.\n   */\n  on(eventName, listener) {\n    // TODO: Implement subscription logic\n  }\n\n  /**\n   * Unregisters a listener from a specific event.\n   * @param {string} eventName - The name of the event to unsubscribe from.\n   * @param {function} listener - The callback function to remove.\n   */\n  off(eventName, listener) {\n    // TODO: Implement unsubscription logic\n  }\n\n  /**\n   * Emits an event, notifying all registered listeners.\n   * @param {string} eventName - The name of the event to emit.\n   * @param {*} data - The data to pass to the listeners.\n   */\n  emit(eventName, data) {\n    // TODO: Implement emission logic\n  }\n}\n\n// --- Demonstration Usage ---\n// const bus = new EventBus();\n\n// const userPanelUpdater = (userData) => console.log(`User Panel: User ${userData.username} is logged in.`);\n// const welcomeMessageDisplay = (userData) => console.log(`Welcome Message: Hello, ${userData.username}!`);\n\n// // Simulate UI components subscribing\n// bus.on('userLoggedIn', userPanelUpdater);\n// bus.on('userLoggedIn', welcomeMessageDisplay);\n\n// // Simulate a 'login' action\n// bus.emit('userLoggedIn', { username: 'Alice', id: 123 });\n\n// // More events, unsubscribing, etc.\n",
          "solutionCode": "class EventBus {\n  constructor() {\n    this.listeners = {};\n  }\n\n  on(eventName, listener) {\n    if (typeof listener !== 'function') {\n      console.warn(`EventBus: Listener for '${eventName}' must be a function.`);\n      return;\n    }\n    if (!this.listeners[eventName]) {\n      this.listeners[eventName] = [];\n    }\n    if (!this.listeners[eventName].includes(listener)) {\n      this.listeners[eventName].push(listener);\n      // console.log(`[EventBus] Subscribed to '${eventName}' with listener: ${listener.name || 'anonymous'}`);\n    } else {\n      // console.log(`[EventBus] Listener already subscribed to '${eventName}'.`);\n    }\n  }\n\n  off(eventName, listener) {\n    if (!this.listeners[eventName]) {\n      // console.log(`[EventBus] No subscribers for '${eventName}' to unsubscribe from.`);\n      return;\n    }\n    const initialLength = this.listeners[eventName].length;\n    this.listeners[eventName] = this.listeners[eventName].filter(cb => cb !== listener);\n    if (this.listeners[eventName].length < initialLength) {\n      // console.log(`[EventBus] Unsubscribed from '${eventName}' with listener: ${listener.name || 'anonymous'}`);\n    } else {\n      // console.log(`[EventBus] Listener not found for '${eventName}'.`);\n    }\n  }\n\n  emit(eventName, data) {\n    if (!this.listeners[eventName] || this.listeners[eventName].length === 0) {\n      // console.log(`[EventBus] No active subscribers for '${eventName}'.`);\n      return;\n    }\n    // console.log(`\\n[EventBus] Emitting event: '${eventName}' with data: ${JSON.stringify(data)}`);\n    // Create a copy of the listeners array to prevent issues if a listener unsubscribes itself during iteration\n    const listenersToNotify = [...this.listeners[eventName]];\n    listenersToNotify.forEach(listener => {\n      try {\n        listener(data);\n      } catch (error) {\n        console.error(`[EventBus Error] Listener for '${eventName}' failed:`, error);\n      }\n    });\n  }\n}\n\n// --- Demonstration Usage ---\nconst bus = new EventBus();\n\n// Define listeners (simulating UI components or modules)\nconst userPanelUpdater = (userData) => console.log(`User Panel: User ${userData.username} is logged in.`);\nconst welcomeMessageDisplay = (userData) => console.log(`Welcome Message: Hello, ${userData.username}!`);\nconst analyticsTracker = (eventData) => console.log(`Analytics: Tracked event '${eventData.eventName}' with data: ${JSON.stringify(eventData.data)}`);\nconst cartNotification = (productData) => console.log(`Cart: ${productData.name} added to cart!`);\n\n// Scenario 1: User Login Event\nconsole.log('--- Scenario 1: User Login ---');\nbus.on('userLoggedIn', userPanelUpdater);\nbus.on('userLoggedIn', welcomeMessageDisplay);\nbus.on('appEvent', analyticsTracker.bind(null, { eventName: 'userLoggedIn' })); // Example of binding context/extra data\n\nbus.emit('userLoggedIn', { username: 'Alice', id: 123 });\n// Expected output: User Panel: User Alice is logged in. \n//                  Welcome Message: Hello, Alice! \n//                  Analytics: Tracked event 'userLoggedIn' with data: {\"username\":\"Alice\",\"id\":123}\n\n// Scenario 2: Product Added to Cart Event\nconsole.log('\\n--- Scenario 2: Product Added to Cart ---');\nbus.on('productAddedToCart', cartNotification);\nbus.on('appEvent', analyticsTracker.bind(null, { eventName: 'productAddedToCart' }));\n\nbus.emit('productAddedToCart', { name: 'Laptop', price: 1200 });\n// Expected output: Cart: Laptop added to cart! \n//                  Analytics: Tracked event 'productAddedToCart' with data: {\"name\":\"Laptop\",\"price\":1200}\n\n// Scenario 3: Unsubscribe and Re-emit\nconsole.log('\\n--- Scenario 3: Unsubscribe ---');\nbus.off('userLoggedIn', userPanelUpdater);\nbus.emit('userLoggedIn', { username: 'Bob', id: 456 });\n// Expected output: Welcome Message: Hello, Bob! (userPanelUpdater should no longer be called)\n//                  Analytics: Tracked event 'userLoggedIn' with data: {\"username\":\"Bob\",\"id\":456}\n\n// Scenario 4: Emit event with no subscribers\nconsole.log('\\n--- Scenario 4: No Subscribers ---');\nbus.emit('nonExistentEvent', { message: 'This should not be logged by any listener.' });\n// Expected: No console output from a listener for this event.\n\n// Scenario 5: Attempt to subscribe duplicate listener (should not add)\nconsole.log('\\n--- Scenario 5: Duplicate Subscription ---');\nbus.on('productAddedToCart', cartNotification);\nbus.emit('productAddedToCart', { name: 'Keyboard', price: 75 }); // Should only log once for Keyboard\n// Expected: Cart: Keyboard added to cart!\n//           Analytics: Tracked event 'productAddedToCart' with data: {\"name\":\"Keyboard\",\"price\":75}\n\n// Scenario 6: Listener throwing an error\nconsole.log('\\n--- Scenario 6: Erroring Listener ---');\nconst erroringListener = () => { throw new Error('Something went wrong in listener!'); };\nbus.on('errorEvent', erroringListener);\nbus.on('errorEvent', (data) => console.log('Another listener for errorEvent received:', data));\nbus.emit('errorEvent', { type: 'test' });\n// Expected: Error in subscriber for 'errorEvent': ... \n//           Another listener for errorEvent received: { type: 'test' }\n",
          "testCases": [
            "A listener successfully subscribes and receives data for a single event.",
            "Multiple listeners receive data for the same event.",
            "A listener is correctly unsubscribed and no longer receives notifications.",
            "Emitting an event with no subscribers does not cause errors.",
            "Subscribing the same listener multiple times to the same event does not lead to duplicate calls.",
            "Attempting to unsubscribe a listener not currently subscribed does not cause errors.",
            "Test for `on` and `emit` with different `eventName` strings to ensure isolation between events.",
            "Verify error handling within `emit` so that one faulty listener doesn't prevent others from being called.",
            "Ensure the `data` passed to `emit` is correctly forwarded to listeners."
          ],
          "hints": [
            "Use an object (or `Map`) to store listeners, where keys are event names and values are arrays of callback functions.",
            "For `on`, check if the listener is already in the array before pushing it to avoid duplicates.",
            "For `off`, use `Array.prototype.filter()` to create a new array without the specified listener.",
            "For `emit`, iterate over the listeners for the given `eventName` and call each callback, passing the `data`.",
            "Consider using a `try-catch` block around listener calls in `emit` to prevent one listener's error from stopping the notification chain.",
            "When iterating over listeners in `emit`, make a shallow copy of the array (e.g., `[...this.listeners[eventName]]`) to prevent issues if a listener unsubscribes itself during the loop."
          ],
          "tags": [
            "design-patterns",
            "observer-pattern",
            "event-driven",
            "frontend",
            "javascript",
            "state-management"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "object-oriented-programming",
            "array-methods",
            "javascript-functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "pub-sub",
            "event-emitter",
            "custom-events",
            "loosely-coupled-systems"
          ]
        },
        {
          "id": "task_payment_gateway",
          "title": "Build a Flexible Payment Gateway with Strategy Pattern",
          "description": "\nYour task is to implement a `PaymentProcessor` that can handle various payment methods using the Strategy pattern. This allows you to easily add new payment methods without modifying the core `PaymentProcessor` logic.\n\n**Requirements:**\n1.  Define an abstract `PaymentStrategy` class (or interface) with a `pay(amount)` method.\n2.  Implement at least three concrete payment strategies:\n    *   `CreditCardPaymentStrategy`: Takes `cardNumber`, `expiryDate`, `cvv` in its constructor. Its `pay` method should simulate processing (e.g., log a message).\n    *   `PayPalPaymentStrategy`: Takes `email` in its constructor. Its `pay` method should simulate processing.\n    *   `CryptoPaymentStrategy`: Takes `walletAddress` and `currency` in its constructor. Its `pay` method should simulate processing.\n3.  Create a `PaymentProcessor` (Context) class that:\n    *   Has a `setStrategy(strategy)` method to set the active payment method.\n    *   Has a `processPayment(amount)` method that delegates the payment processing to the currently set strategy.\n4.  Include basic validation in `setStrategy` to ensure the provided object is a valid strategy.\n5.  Demonstrate the `PaymentProcessor`'s flexibility by processing payments of different amounts using different strategies.\n",
          "difficulty": "medium",
          "startingCode": "// Base Payment Strategy (abstract)\nclass PaymentStrategy {\n  pay(amount) {\n    throw new Error(\"Abstract method 'pay' must be implemented by concrete strategies.\");\n  }\n}\n\n// Implement Concrete Payment Strategies here:\n// class CreditCardPaymentStrategy extends PaymentStrategy { /* ... */ }\n// class PayPalPaymentStrategy extends PaymentStrategy { /* ... */ }\n// class CryptoPaymentStrategy extends PaymentStrategy { /* ... */ }\n\n// PaymentProcessor (Context) class\nclass PaymentProcessor {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    // TODO: Implement validation and set strategy\n  }\n\n  processPayment(amount) {\n    // TODO: Delegate to the current strategy\n  }\n}\n\n// --- Demonstration Usage ---\n// const processor = new PaymentProcessor();\n// processor.setStrategy(new CreditCardPaymentStrategy('1111...', '12/24', '123'));\n// processor.processPayment(100);\n\n// processor.setStrategy(new PayPalPaymentStrategy('user@example.com'));\n// processor.processPayment(50);\n",
          "solutionCode": "// Base Payment Strategy (abstract)\nclass PaymentStrategy {\n  pay(amount) {\n    throw new Error(\"Abstract method 'pay' must be implemented by concrete strategies.\");\n  }\n}\n\n// Concrete Payment Strategy 1: Credit Card\nclass CreditCardPaymentStrategy extends PaymentStrategy {\n  constructor(cardNumber, expiryDate, cvv) {\n    super();\n    this.cardNumber = cardNumber;\n    this.expiryDate = expiryDate;\n    this.cvv = cvv;\n  }\n\n  pay(amount) {\n    console.log(`Processing credit card payment of $${amount.toFixed(2)}.`);\n    console.log(`Card Number: **** **** **** ${this.cardNumber.slice(-4)}, Expiry: ${this.expiryDate}`);\n    // Simulate actual payment gateway interaction\n    if (amount > 0) {\n      console.log('Credit card payment successful.');\n      return true;\n    } else {\n      console.error('Credit card payment failed: Invalid amount.');\n      return false;\n    }\n  }\n}\n\n// Concrete Payment Strategy 2: PayPal\nclass PayPalPaymentStrategy extends PaymentStrategy {\n  constructor(email) {\n    super();\n    this.email = email;\n  }\n\n  pay(amount) {\n    console.log(`Processing PayPal payment of $${amount.toFixed(2)}.`);\n    console.log(`PayPal Account: ${this.email}`);\n    // Simulate actual payment gateway interaction\n    if (amount > 0) {\n      console.log('PayPal payment successful.');\n      return true;\n    } else {\n      console.error('PayPal payment failed: Invalid amount.');\n      return false;\n    }\n  }\n}\n\n// Concrete Payment Strategy 3: Crypto\nclass CryptoPaymentStrategy extends PaymentStrategy {\n  constructor(walletAddress, currency) {\n    super();\n    this.walletAddress = walletAddress;\n    this.currency = currency;\n  }\n\n  pay(amount) {\n    console.log(`Processing Crypto (${this.currency}) payment of $${amount.toFixed(2)}.`);\n    console.log(`Sending to Wallet Address: ${this.walletAddress}`);\n    // Simulate actual payment gateway interaction\n    if (amount > 0) {\n      console.log('Crypto payment successful. Please wait for confirmation.');\n      return true;\n    } else {\n      console.error('Crypto payment failed: Invalid amount.');\n      return false;\n    }\n  }\n}\n\n// PaymentProcessor (Context) class\nclass PaymentProcessor {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    if (strategy === null) {\n      this.strategy = null;\n      console.log('Payment strategy cleared.');\n      return;\n    }\n    if (!(strategy instanceof PaymentStrategy)) {\n      throw new Error(\"Invalid strategy: Must be an instance of PaymentStrategy.\");\n    }\n    this.strategy = strategy;\n    console.log(`Payment strategy set to: ${strategy.constructor.name}`);\n  }\n\n  processPayment(amount) {\n    if (!this.strategy) {\n      console.error(\"Error: No payment strategy set. Cannot process payment.\");\n      return false;\n    }\n    if (amount <= 0) {\n      console.error(\"Error: Payment amount must be positive.\");\n      return false;\n    }\n    return this.strategy.pay(amount);\n  }\n}\n\n// --- Demonstration Usage ---\nconst processor = new PaymentProcessor();\n\n// Scenario 1: Credit Card Payment\nconsole.log('--- Scenario 1: Credit Card Payment ---');\nconst creditCardStrategy = new CreditCardPaymentStrategy('4111222233334444', '12/25', '789');\nprocessor.setStrategy(creditCardStrategy);\nprocessor.processPayment(250.75);\n\n// Scenario 2: PayPal Payment\nconsole.log('\\n--- Scenario 2: PayPal Payment ---');\nconst paypalStrategy = new PayPalPaymentStrategy('customer@example.com');\nprocessor.setStrategy(paypalStrategy);\nprocessor.processPayment(50.00);\n\n// Scenario 3: Crypto Payment\nconsole.log('\\n--- Scenario 3: Crypto Payment ---');\nconst cryptoStrategy = new CryptoPaymentStrategy('0xAbCdEf1234567890', 'ETH');\nprocessor.setStrategy(cryptoStrategy);\nprocessor.processPayment(1500.20);\n\n// Scenario 4: Attempt to process without a strategy\nconsole.log('\\n--- Scenario 4: No Strategy ---');\nprocessor.setStrategy(null);\nprocessor.processPayment(30.00);\n\n// Scenario 5: Attempt to set invalid strategy\nconsole.log('\\n--- Scenario 5: Invalid Strategy ---');\ntry {\n  processor.setStrategy({});\n} catch (e) {\n  console.error(e.message);\n}\n\n// Scenario 6: Zero/Negative amount\nconsole.log('\\n--- Scenario 6: Invalid Amount ---');\nprocessor.setStrategy(creditCardStrategy);\nprocessor.processPayment(0);\nprocessor.processPayment(-10);\n",
          "testCases": [
            "A `CreditCardPaymentStrategy` processes payments correctly, logging its specific details.",
            "A `PayPalPaymentStrategy` processes payments correctly, logging its specific details.",
            "A `CryptoPaymentStrategy` processes payments correctly, logging its specific details.",
            "The `PaymentProcessor` successfully switches between different strategies.",
            "Calling `processPayment` without a strategy set outputs an error message and returns `false`.",
            "Calling `setStrategy` with an object not inheriting from `PaymentStrategy` throws an error.",
            "Processing a payment with a zero or negative amount is handled gracefully (e.g., prevents processing and logs an error).",
            "Each concrete strategy's constructor parameters are correctly stored and used in its `pay` method."
          ],
          "hints": [
            "The `PaymentStrategy` can be a base class that `throw`s an error in its `pay` method to enforce implementation by subclasses (simulating an abstract method).",
            "Use `instanceof` to validate the strategy type in the `setStrategy` method.",
            "The `PaymentProcessor`'s `processPayment` method should simply call `this.strategy.pay(amount)`.",
            "Consider adding basic logging within each `pay` method to show which strategy is active and its specific parameters."
          ],
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "frontend",
            "ecommerce",
            "javascript"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "object-oriented-programming",
            "polymorphism",
            "classes"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "factory-pattern",
            "dependency-injection",
            "configurable-logic"
          ]
        }
      ]
    }
  },
  {
    "id": "9eef224e-890b-49e4-8b7f-b86c4699f2b0",
    "startLine": 400,
    "endLine": 499,
    "processedDate": "2025-06-17T07:04:41.185Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_strategy_pattern",
          "title": "Strategy Design Pattern",
          "content": "The Strategy design pattern is a behavioral design pattern that enables selecting an algorithm's behavior at runtime. It defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows the client to choose the desired algorithm (strategy) without knowing the concrete implementation details of that algorithm, promoting flexibility and extensibility.\n\n## Core Components:\n\n1.  **Context**: Holds a reference to a Strategy object and delegates the request to the Strategy. It does not know the concrete strategy it's using.\n2.  **Strategy (Interface/Abstract Class)**: Declares an interface common to all supported algorithms. Context uses this interface to call the algorithm defined by a Concrete Strategy.\n3.  **Concrete Strategy**: Implements the Strategy interface, providing a specific algorithm.\n\n## Benefits:\n\n*   **Flexibility**: Algorithms can be changed at runtime.\n*   **Extensibility**: New strategies can be added easily without modifying the Context.\n*   **Maintainability**: Reduces conditional statements in the Context by encapsulating varying behaviors into separate classes.\n*   **Reusability**: Strategies can be reused across different contexts or parts of an application.",
          "examples": [
            {
              "id": "example_strategy_pattern_1",
              "title": "Shipping Cost Calculation with Strategy Pattern",
              "code": "class Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(order) {\n    return this.strategy.calculate(order);\n  }\n}\n\n// Strategy Interface (implicit in JS)\n// class ShippingStrategy {\n//   calculate(order) { throw new Error('Method must be implemented'); }\n// }\n\n// Concrete Strategies\nclass FedEx {\n  calculate(order) {\n    // Complex FedEx logic based on weight, distance, etc.\n    return 5 + (order.weight * 0.5);\n  }\n}\n\nclass UPS {\n  calculate(order) {\n    // Complex UPS logic\n    return 4 + (order.weight * 0.4);\n  }\n}\n\nclass USPS {\n  calculate(order) {\n    // Complex USPS logic\n    return 3 + (order.weight * 0.3);\n  }\n}\n\nconst shipping = new Shipping();\nconst order = { weight: 10 };\n\nshipping.setStrategy(new FedEx());\nconsole.log(`FedEx: $${shipping.calculate(order)}`);\n\nshipping.setStrategy(new UPS());\nconsole.log(`UPS: $${shipping.calculate(order)}`);\n\nshipping.setStrategy(new USPS());\nconsole.log(`USPS: $${shipping.calculate(order)}`);",
              "explanation": "This example demonstrates how different shipping carriers (FedEx, UPS, USPS) are implemented as concrete strategies. The `Shipping` class acts as the Context, setting and using the chosen strategy to calculate shipping costs. This allows easily switching between shipping methods without altering the `Shipping` class itself, showcasing the pattern's flexibility.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_strategy_pattern_1",
            "question_strategy_pattern_2",
            "question_strategy_pattern_3",
            "question_strategy_pattern_4",
            "question_strategy_pattern_5"
          ],
          "relatedTasks": [
            "task_strategy_pattern_calculator"
          ],
          "tags": [
            "design-patterns",
            "behavioral-patterns",
            "oop",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object-oriented-programming",
            "polymorphism"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "scalable-architecture",
            "enterprise-application-design"
          ]
        },
        {
          "id": "theory_javascript_data_types",
          "title": "JavaScript Data Types: Primitive vs. Complex",
          "content": "JavaScript categorizes data into two main types: primitive and complex (or reference) types. Understanding this distinction is crucial for comprehending how values are stored, passed, and compared in JavaScript.\n\n## Primitive Types\n\nPrimitive values are immutable, meaning their value cannot be changed after creation. When a primitive value is assigned to a variable, the variable directly holds that value. When a primitive variable is copied, a new copy of the value is created.\n\n*   **String**: Represents sequences of characters (e.g., `'hello'`, `\"world\"`).\n*   **Number**: Represents both integer and floating-point numbers (e.g., `42`, `3.14`). Includes special values like `NaN` (Not-a-Number) and `Infinity`.\n*   **BigInt**: Represents whole numbers larger than `2^53 - 1`, which is the maximum safe integer for `Number` (e.g., `100n`).\n*   **Boolean**: Represents a logical entity with two values: `true` or `false`.\n*   **Undefined**: Represents a variable that has been declared but has not yet been assigned a value.\n*   **Symbol**: A unique and immutable data type often used as object property keys to avoid naming conflicts (e.g., `Symbol('id')`).\n*   **Null**: Represents the intentional absence of any object value. It's a primitive value.\n\n## Complex Type (Object)\n\nObjects are mutable and are stored by reference. This means that when an object is assigned to a variable, the variable holds a reference (memory address) to the object, not the object itself. When an object variable is copied, only the reference is copied, pointing to the same underlying object. Any changes made through one variable will be reflected in all other variables referencing the same object.\n\n*   **Object**: A collection of key-value pairs (e.g., `{ name: 'Alice', age: 30 }`).\n*   **Array**: A special type of object used for storing ordered collections of data (e.g., `[1, 2, 3]`).\n*   **Function**: A callable object that executes a block of code (e.g., `function() {}`).\n*   **Date**, **RegExp**, etc. are also objects.",
          "examples": [
            {
              "id": "example_primitive_vs_object_1",
              "title": "Primitive vs. Object Assignment",
              "code": "let firstObj = { name: 'Hello' };  \nlet secondObj = firstObj;  \nconsole.log(secondObj.name); // Output: Hello (both reference the same object)\n\nfirstObj = { name: 'Bye' };  // firstObj now references a *new* object\nconsole.log(secondObj.name); // Output: Hello (secondObj still references the *original* object)\n\n// Primitive example\nlet num1 = 10;\nlet num2 = num1;\nconsole.log(num2); // 10\nnum1 = 20;\nconsole.log(num2); // 10 (num2 holds a separate copy of the value)\n",
              "explanation": "This example illustrates the difference between how primitive values and object references are handled during assignment. When `firstObj` (an object) is assigned to `secondObj`, both variables point to the *same* object in memory. When `firstObj` is then reassigned to a *new* object, `secondObj` continues to point to the *original* object. In contrast, for primitive types like numbers, `num2` receives a distinct copy of `num1`'s value, so subsequent changes to `num1` do not affect `num2`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_data_types_1",
            "question_data_types_2",
            "question_data_types_3",
            "question_data_types_4",
            "question_data_types_5",
            "question_data_types_6"
          ],
          "relatedTasks": [
            "task_deep_clone_object"
          ],
          "tags": [
            "javascript-fundamentals",
            "data-types",
            "memory-management",
            "primitives",
            "objects"
          ],
          "technology": "JavaScript",
          "prerequisites": [],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "advanced-js-concepts",
            "framework-understanding"
          ]
        },
        {
          "id": "theory_javascript_type_conversion",
          "title": "JavaScript Type Conversion Methods",
          "content": "JavaScript is a loosely typed language, which means it often performs implicit type coercion. However, explicit type conversion methods are essential for precise control over data types.\n\n## `parseInt()` and `parseFloat()`\n\nThese functions are primarily used for parsing strings and extracting numerical values. They parse the string from left to right until they encounter a non-numeric character, then return the number accumulated up to that point.\n\n*   `parseInt(string, radix)`: Converts a string to an integer. The `radix` parameter (optional, defaults to 10) specifies the base of the number system (e.g., 2 for binary, 10 for decimal, 16 for hexadecimal). It truncates decimal parts.\n*   `parseFloat(string)`: Converts a string to a floating-point number. It can handle decimal points.\n\n## Other Conversion Methods\n\n*   **`Number(value)`**: A stricter conversion method compared to `parseInt()`/`parseFloat()`. It attempts to convert the entire `value` to a number. If the `value` cannot be entirely converted (e.g., contains non-numeric characters), it returns `NaN`.\n*   **`String(value)`** or `value.toString()`: Converts a value to its string representation. `String()` can be used for `null` and `undefined`, whereas `toString()` will throw an error for these.\n*   **`Boolean(value)`** or `!!value`: Converts a value to its boolean representation. Most values are 'truthy' (convert to `true`), while a specific set of values are 'falsy' (convert to `false`).\n\n### Falsy Values:\n*   `false`\n*   `0` (zero)\n*   `-0` (negative zero)\n*   `0n` (BigInt zero)\n*   `''` (empty string)\n*   `null`\n*   `undefined`\n*   `NaN`",
          "examples": [
            {
              "id": "example_type_conversion_1",
              "title": "parseInt() and parseFloat() Examples",
              "code": "// parseInt(string, radix) - converts string to integer\n// The radix parameter specifies the base of the number system (usually 10 for decimal)\nconsole.log(parseInt('42'));        // 42\nconsole.log(parseInt('42px'));      // 42 - extracts numbers until it encounters a non-numeric character\nconsole.log(parseInt('-50px'));     // -50 - handles negative numbers correctly\nconsole.log(parseInt('0xFF', 16));  // 255 - parses hexadecimal with radix 16\nconsole.log(parseInt('  123 '));    // 123 - ignores leading/trailing whitespace\nconsole.log(parseInt('abc'));       // NaN - string does not start with a number\n\n// parseFloat() - converts string to floating point number\nconsole.log(parseFloat('3.14'));          // 3.14\nconsole.log(parseFloat('3.14 meters'));   // 3.14\nconsole.log(parseFloat('  -2.5abc'));     // -2.5\nconsole.log(parseFloat('Infinity'));      // Infinity\nconsole.log(parseFloat('NaN'));           // NaN",
              "explanation": "These examples illustrate the behavior of `parseInt()` and `parseFloat()`. They stop parsing at the first non-numeric character (or invalid character for `parseInt` when a radix is specified). `parseInt` supports a `radix` for different number bases, while `parseFloat` handles decimal values.",
              "language": "javascript"
            },
            {
              "id": "example_type_conversion_2",
              "title": "Number(), String(), Boolean() Examples",
              "code": "// Number() - stricter than parseInt, doesn't allow trailing non-numeric characters\nconsole.log(Number('42'));    // 42\nconsole.log(Number('42px'));  // NaN - doesn't allow non-numeric characters\nconsole.log(Number('3.14'));  // 3.14\nconsole.log(Number(''));      // 0\nconsole.log(Number(true));    // 1\nconsole.log(Number(false));   // 0\nconsole.log(Number(null));    // 0\nconsole.log(Number(undefined));// NaN\n\n// String() - converts to string\nconsole.log(String(42));      // '42'\nconsole.log(String(true));    // 'true'\nconsole.log(String(null));    // 'null'\nconsole.log(String(undefined));// 'undefined'\nconsole.log(String({a:1}));   // '[object Object]'\n\n// Boolean() - converts to boolean\nconsole.log(Boolean(0));       // false (falsy)\nconsole.log(Boolean(1));       // true (truthy)\nconsole.log(Boolean(''));      // false (falsy)\nconsole.log(Boolean('hello')); // true (truthy)\nconsole.log(Boolean(null));    // false (falsy)\nconsole.log(Boolean(undefined));// false (falsy)\nconsole.log(Boolean(NaN));     // false (falsy)\nconsole.log(Boolean([]));      // true (truthy, empty array is an object)\nconsole.log(Boolean({}));      // true (truthy, empty object is an object)",
              "explanation": "`Number()` attempts a full conversion and returns `NaN` if the string cannot be entirely parsed as a number. `String()` converts various data types to their string representation. `Boolean()` (or `!!`) evaluates values as `true` (truthy) or `false` (falsy) based on JavaScript's rules for boolean coercion.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_type_conversion_1",
            "question_type_conversion_2",
            "question_type_conversion_3",
            "question_type_conversion_4",
            "question_type_conversion_5",
            "question_type_conversion_6"
          ],
          "relatedTasks": [
            "task_robust_string_to_number"
          ],
          "tags": [
            "type-coercion",
            "javascript-fundamentals",
            "conversion-methods",
            "operators"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript-data-types"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "debugging",
            "data-manipulation"
          ]
        },
        {
          "id": "theory_javascript_operators_and_pitfalls",
          "title": "JavaScript Operators and Common Pitfalls",
          "content": "Understanding JavaScript operators, especially increment/decrement and logical operators, is crucial. Additionally, being aware of common coding pitfalls, like incorrect loop increments, can save significant debugging time.\n\n## Increment/Decrement Operators: `i++` vs `++i`\n\nBoth `i++` (post-increment) and `++i` (pre-increment) add one to the value of `i`. The key difference lies in the value they *return*.\n\n*   **`i++` (Post-increment)**: Returns the *original* value of `i` *before* incrementing it. After the expression is evaluated, `i` is incremented.\n*   **`++i` (Pre-increment)**: Returns the *new* value of `i` *after* incrementing it. `i` is incremented first, and then its new value is used in the expression.\n\n## Loop Increment Pitfalls\n\nA common mistake in `for` loops is using `i + N` instead of `i += N` or `i = i + N`. The expression `i + N` calculates a new value but does not reassign it back to `i`, leading to an infinite loop if `i` is not modified elsewhere.\n\n*   **Incorrect**: `for (var i = 0; i < length; i + 3) {}` - `i` remains unchanged.\n*   **Correct**: `for (var i = 0; i < length; i += 3) {}` or `for (var i = 0; i < length; i = i + 3) {}` - `i` is updated in each iteration.",
          "examples": [
            {
              "id": "example_operators_1",
              "title": "i++ vs ++i Comparison",
              "code": "let i = 5;\nlet j = i++; // j gets 5, then i becomes 6\nconsole.log(`i: ${i}, j: ${j}`); // Output: i: 6, j: 5\n\nlet x = 5;\nlet y = ++x; // x becomes 6, then y gets 6\nconsole.log(`x: ${x}, y: ${y}`); // Output: x: 6, y: 6",
              "explanation": "This example clearly demonstrates the difference between post-increment (`i++`) and pre-increment (`++i`). `j` receives the value of `i` before `i` is incremented, while `y` receives the value of `x` after `x` has been incremented.",
              "language": "javascript"
            },
            {
              "id": "example_operators_2",
              "title": "Loop Increment Pitfall",
              "code": "// Incorrect: This will lead to an infinite loop if length > 0\n// The expression `i + 3` computes a value but doesn't assign it back to `i`.\n// for (var i = 0; i < myVar.length; i + 3) {\n//   console.log(i); // i never changes, loop condition remains true\n// }\n\n// Correct Way:\nlet myVar = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nfor (let i = 0; i < myVar.length; i += 3) {\n  console.log(`Processing index: ${i}`);\n}\n// Output: Processing index: 0, Processing index: 3, Processing index: 6, Processing index: 9",
              "explanation": "The first commented-out `for` loop is a common mistake. `i + 3` calculates a value but does not update `i` itself, causing an infinite loop. The corrected `for` loop uses `i += 3`, which correctly reassigns the incremented value back to `i`, allowing the loop to progress and terminate.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_operators_1",
            "question_operators_2",
            "question_operators_3",
            "question_operators_4"
          ],
          "relatedTasks": [
            "task_sparse_array_iteration"
          ],
          "tags": [
            "javascript-fundamentals",
            "operators",
            "loops",
            "common-pitfalls",
            "debugging"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript-data-types"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust-coding",
            "performance-optimization"
          ]
        },
        {
          "id": "theory_javascript_edge_cases_coercion",
          "title": "JavaScript Behavior and Edge Cases: Coercion & Operators",
          "content": "JavaScript's dynamic typing and operator overloading can lead to surprising behavior and edge cases, especially concerning type coercion and logical operations. Understanding these nuances is vital for writing robust and predictable code.\n\n## Object Property Access with Numeric/String Keys\n\nWhen accessing object properties, JavaScript often coerces numeric keys to strings. If you define a property with a numeric literal (e.g., `1`), it's stored as a string (`'1'`). Accessing it via `obj[1]` or `obj['1']` will yield the same result because the number `1` is implicitly converted to the string `'1'` for property lookup.\n\n## Mixed Type Arithmetic and Coercion\n\nJavaScript performs implicit type coercion when operators are applied to values of different types. The `+` operator behaves differently depending on operand types: if either operand is a string, it performs string concatenation; otherwise, it performs numeric addition. Other arithmetic operators (`-`, `*`, `/`, `%`) always attempt to convert operands to numbers. If conversion fails, the result is `NaN`.\n\n## Logical Operators and Short-Circuit Evaluation\n\nLogical operators (`&&` - AND, `||` - OR) in JavaScript exhibit 'short-circuit evaluation'. They evaluate from left to right and return the value of the *last evaluated operand*, not necessarily a boolean `true` or `false`.\n\n*   **`||` (OR)**: Returns the *first truthy* operand. If no operand is truthy, it returns the *last falsy* operand.\n*   **`&&` (AND)**: Returns the *first falsy* operand. If no operand is falsy, it returns the *last truthy* operand.\n\nTo explicitly get a boolean result from a logical expression, you can use the double-negation operator `!!` (e.g., `!!(a && b)`).\n\n## Array Operations with Type Coercion\n\nArrays are objects. When an array is used in an arithmetic context (especially with `+`), it's often implicitly converted to a string before the operation, which can lead to unexpected string concatenation instead of numeric addition. For example, `[1, 2] + [3, 4]` will concatenate the string representations of the arrays (`'1,2'` and `'3,4'`) resulting in `'1,23,4'`, not `[4,6]`.",
          "examples": [
            {
              "id": "example_edge_cases_1",
              "title": "Object Property Access and Mixed Arithmetic",
              "code": "// Object property access with different notations\nvar obj = {'1': 0, 1: 1, 0: 2};\nconsole.log(obj['1']); // 1 (numeric key '1' is equivalent to 1)\nconsole.log(obj[1]);   // 1 (same property, 1 is coerced to '1')\nconsole.log(obj[0]);   // 2\n\n// Mixed type arithmetic\nconsole.log(4 - \"5\" + 0xf - \"1e1\"); // Expected: 4\n// Breakdown:\n// 1. 4 - \"5\"   → 4 - 5 = -1 (string \"5\" converted to number in subtraction)\n// 2. -1 + 0xf  → -1 + 15 = 14 (0xf is hexadecimal for 15)\n// 3. 14 - \"1e1\" → 14 - 10 = 4 (\"1e1\" is scientific notation for 10)\n\nconsole.log(\"10\" + 2); // \"102\" (string concatenation)\nconsole.log(\"10\" - 2); // 8 (numeric subtraction)",
              "explanation": "This example shows that object property access with numeric keys often undergoes string coercion. It also demonstrates how JavaScript handles mixed-type arithmetic: `+` can concatenate strings, while other arithmetic operators force numeric conversion.",
              "language": "javascript"
            },
            {
              "id": "example_edge_cases_2",
              "title": "Logical Operators and Array Coercion",
              "code": "// Logical operators and short-circuit evaluation\nconsole.log(0 || \"\" || undefined || 23 || true || false); // 23 (first truthy value)\nconsole.log(\"hello\" && 0 && \"world\"); // 0 (first falsy value)\n\n// Logical operators with variables (return value, not just boolean)\nlet a = 5, b = 10;\nconsole.log(!!(a && b)); // true (converts result to boolean, `a && b` returns 10)\nconsole.log((a && b));   // 10 (returns last evaluated operand)\nconsole.log(a || b);    // 5 (returns first truthy operand)\n\n// Array operations with type coercion\nconsole.log([] + {});  // '[object Object]' (empty array becomes '', empty object becomes '[object Object]')\nconsole.log({} + []);  // '[object Object]' (object becomes '[object Object]', empty array becomes '')\nconsole.log([1, 2] + [3, 4]); // '1,23,4' (arrays are coerced to strings, then concatenated)\nconsole.log([1] - [1]); // 0 (arrays coerced to '1', then 1 - 1 = 0)\nconsole.log(null + undefined); // NaN (null coerces to 0, undefined to NaN)",
              "explanation": "This example highlights the short-circuiting behavior of `&&` and `||`, demonstrating they return the actual value of the last evaluated operand, not just `true` or `false`. It also illustrates how arrays are coerced to strings when used with the `+` operator, leading to string concatenation rather than numeric operations. Other arithmetic operators (`-`) attempt numeric conversion.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_edge_cases_1",
            "question_edge_cases_2",
            "question_edge_cases_3",
            "question_edge_cases_4",
            "question_edge_cases_5",
            "question_edge_cases_6"
          ],
          "relatedTasks": [
            "task_parse_mixed_data",
            "task_safe_boolean_coercion"
          ],
          "tags": [
            "type-coercion",
            "operators",
            "javascript-quirks",
            "edge-cases",
            "logical-operators",
            "debugging"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript-data-types",
            "javascript-type-conversion"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex-data-manipulation",
            "avoiding-bugs",
            "code-review"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_strategy_pattern_1",
          "topic": "Strategy Design Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary goal of the Strategy design pattern?",
          "answer": "To define a family of algorithms, encapsulate each one, and make them interchangeable.",
          "analysisPoints": [
            "Recall the definition of the Strategy pattern.",
            "Identify the core problem it solves (algorithm selection at runtime)."
          ],
          "keyConcepts": [
            "Strategy pattern",
            "Behavioral design patterns",
            "Algorithm encapsulation"
          ],
          "evaluationCriteria": [
            "Basic understanding of design pattern purpose."
          ],
          "example": "The Strategy pattern allows changing the behavior of a class at runtime without modifying its structure, for example, by switching between different tax calculation algorithms.",
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strategy_pattern_2",
          "topic": "Strategy Design Pattern",
          "level": "medium",
          "type": "mcq",
          "question": "Which component in the Strategy pattern is responsible for holding a reference to a Concrete Strategy object and delegating requests to it?",
          "answer": "Context",
          "options": [
            "Strategy",
            "Concrete Strategy",
            "Context",
            "Client"
          ],
          "analysisPoints": [
            "Understanding the roles of different components in the Strategy pattern.",
            "Identifying the 'Context' as the component that uses the strategy.",
            "Distinguishing Context from Strategy interface and Concrete Strategy implementations."
          ],
          "keyConcepts": [
            "Strategy pattern components",
            "Context",
            "Delegation"
          ],
          "evaluationCriteria": [
            "Correct identification of pattern roles."
          ],
          "example": "In the shipping example, the `Shipping` class is the Context, as it sets and uses the `FedEx`, `UPS`, or `USPS` strategy.",
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "mcq"
          ],
          "prerequisites": [
            "theory_strategy_pattern"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strategy_pattern_3",
          "topic": "Strategy Design Pattern",
          "level": "medium",
          "type": "open",
          "question": "Explain a real-world scenario where the Strategy pattern would be beneficial, other than the shipping example. Describe the Context, Strategy, and Concrete Strategy in your scenario.",
          "answer": "A good example is a payment processing system.\n\n*   **Context**: A `PaymentProcessor` class that needs to process a payment, but the specific payment method (credit card, PayPal, crypto) can vary.\n*   **Strategy**: An `IPaymentStrategy` interface (or abstract class in typed languages) with a method like `processPayment(amount)`.\n*   **Concrete Strategies**: `CreditCardPayment`, `PayPalPayment`, `CryptoPayment` classes, each implementing `IPaymentStrategy` with their specific payment processing logic.\n\nThis allows adding new payment methods without modifying the `PaymentProcessor` class, ensuring extensibility and adherence to the Open/Closed Principle.",
          "analysisPoints": [
            "Ability to apply the pattern to a new scenario.",
            "Correctly identifying all three core components (Context, Strategy, Concrete Strategy).",
            "Articulating the benefits of using the pattern in the given scenario."
          ],
          "keyConcepts": [
            "Strategy pattern application",
            "Context, Strategy, Concrete Strategy",
            "Real-world examples"
          ],
          "evaluationCriteria": [
            "Creative application of pattern.",
            "Clarity and accuracy of component identification.",
            "Demonstration of pattern's benefits."
          ],
          "example": null,
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "open-ended"
          ],
          "prerequisites": [
            "theory_strategy_pattern"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_pattern_4",
          "topic": "Strategy Design Pattern",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple 'SortStrategy' pattern. Create a `Sorter` class (Context) and different `SortStrategy` concrete implementations (e.g., `BubbleSort`, `QuickSort`). The `Sorter` should be able to sort an array using the currently set strategy. Provide basic implementations for the sorting algorithms.",
          "answer": "```javascript\n// Strategy Interface (implicit)\n// class SortStrategy { sort(data) { throw new Error('Method must be implemented'); } }\n\nclass BubbleSort {\n  sort(data) {\n    const arr = [...data]; // Avoid modifying original array\n    const n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n      for (let j = 0; j < n - i - 1; j++) {\n        if (arr[j] > arr[j + 1]) {\n          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        }\n      }\n    }\n    return arr;\n  }\n}\n\nclass QuickSort {\n  sort(data) {\n    const arr = [...data]; // Avoid modifying original array\n    if (arr.length <= 1) return arr;\n    \n    const pivot = arr[Math.floor(arr.length / 2)];\n    const left = [];\n    const right = [];\n    const equal = [];\n\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] < pivot) {\n        left.push(arr[i]);\n      } else if (arr[i] > pivot) {\n        right.push(arr[i]);\n      } else {\n        equal.push(arr[i]);\n      }\n    }\n    return [...this.sort(left), ...equal, ...this.sort(right)];\n  }\n}\n\n// Context\nclass Sorter {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeSort(data) {\n    if (!this.strategy) {\n      throw new Error(\"No sorting strategy set.\");\n    }\n    return this.strategy.sort(data);\n  }\n}\n\n// Usage\nconst dataToSort = [64, 25, 12, 22, 11];\nconst sorter = new Sorter();\n\nsorter.setStrategy(new BubbleSort());\nconsole.log(\"Bubble Sorted:\", sorter.executeSort(dataToSort)); // [11, 12, 22, 25, 64]\n\nsorter.setStrategy(new QuickSort());\nconsole.log(\"Quick Sorted:\", sorter.executeSort(dataToSort)); // [11, 12, 22, 25, 64]\n\nconst data2 = [3, 1, 4, 1, 5, 9, 2, 6];\nsorter.setStrategy(new BubbleSort());\nconsole.log(\"Bubble Sorted 2:\", sorter.executeSort(data2)); // [1, 1, 2, 3, 4, 5, 6, 9]\n\nsorter.setStrategy(new QuickSort());\nconsole.log(\"Quick Sorted 2:\", sorter.executeSort(data2)); // [1, 1, 2, 3, 4, 5, 6, 9]\n```",
          "analysisPoints": [
            "Correctly implements the Context (Sorter) to delegate to a Strategy.",
            "Defines clear Strategy interface (implicit in JS) and concrete implementations.",
            "Demonstrates interchangeable algorithms.",
            "Handles edge cases like empty data or no strategy set."
          ],
          "keyConcepts": [
            "Strategy pattern",
            "Polymorphism",
            "Algorithm encapsulation",
            "Bubble Sort",
            "Quick Sort"
          ],
          "evaluationCriteria": [
            "Adherence to Strategy pattern principles.",
            "Correctness of sorting algorithms.",
            "Code clarity and extensibility."
          ],
          "example": null,
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "algorithms",
            "sorting",
            "code-challenge"
          ],
          "prerequisites": [
            "theory_strategy_pattern",
            "basic-sorting-algorithms"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_strategy_pattern_5",
          "topic": "Strategy Design Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is one key benefit of using the Strategy pattern in terms of code maintainability and extensibility?",
          "answer": "It reduces conditional statements (e.g., `if-else` or `switch`) in the Context, making it easier to add new algorithms without modifying existing code (Open/Closed Principle).",
          "analysisPoints": [
            "Identify benefits related to maintainability.",
            "Connect to the Open/Closed Principle."
          ],
          "keyConcepts": [
            "Strategy pattern benefits",
            "Open/Closed Principle",
            "Maintainability",
            "Extensibility"
          ],
          "evaluationCriteria": [
            "Recall of pattern advantages."
          ],
          "example": null,
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_data_types_1",
          "topic": "JavaScript Data Types",
          "level": "easy",
          "type": "flashcard",
          "question": "Name all primitive data types in JavaScript.",
          "answer": "String, Number, BigInt, Boolean, Undefined, Symbol, Null.",
          "analysisPoints": [
            "Recall the list of primitive data types.",
            "Distinguish them from complex types."
          ],
          "keyConcepts": [
            "Primitive data types",
            "JavaScript fundamentals"
          ],
          "evaluationCriteria": [
            "Basic knowledge of JS data types."
          ],
          "example": null,
          "tags": [
            "data-types",
            "primitives",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_data_types_2",
          "topic": "JavaScript Data Types",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code:\n```javascript\nlet obj1 = { value: 10 };\nlet obj2 = obj1;\nobj1.value = 20;\n\nlet num1 = 10;\nlet num2 = num1;\nnum1 = 20;\n\nconsole.log(obj2.value);\nconsole.log(num2);\n```\nWhat will be the output of `console.log(obj2.value)` and `console.log(num2)` respectively?",
          "answer": "20, 10",
          "options": [
            "10, 10",
            "20, 20",
            "10, 20",
            "20, 10"
          ],
          "analysisPoints": [
            "Understanding pass-by-reference for objects.",
            "Understanding pass-by-value for primitives.",
            "Correctly tracing the value changes for both `obj2` and `num2`."
          ],
          "keyConcepts": [
            "Primitive vs. Object types",
            "Pass by value",
            "Pass by reference",
            "Mutable vs Immutable"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between primitive and object assignment/copying.",
            "Correctly predict output based on data type behavior."
          ],
          "example": "Objects are assigned by reference, so `obj2` points to the same memory location as `obj1`. Changing `obj1.value` changes the shared object. Primitives are assigned by value, so `num2` gets a copy of `num1`'s initial value; subsequent changes to `num1` don't affect `num2`.",
          "tags": [
            "data-types",
            "primitives",
            "objects",
            "mcq",
            "memory-management"
          ],
          "prerequisites": [
            "theory_javascript_data_types"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_data_types_3",
          "topic": "JavaScript Data Types",
          "level": "medium",
          "type": "open",
          "question": "Discuss the implications of JavaScript's primitive types being immutable and objects being mutable when designing data structures or APIs. Provide a simple example for each.",
          "answer": "The immutability of primitives means their value cannot change. If you reassign a variable holding a primitive, you're actually creating a new value, not modifying the old one. This simplifies reasoning about code, as a primitive value passed to a function won't be unexpectedly altered by that function.\n\n*   **Example (Primitive Immutability):**\n    ```javascript\n    let message = 'hello';\n    function appendWorld(str) {\n      str = str + ' world'; // Creates a new string 'hello world', doesn't change original 'message'\n      return str;\n    }\n    let newMessage = appendWorld(message);\n    console.log(message);     // 'hello' (original unchanged)\n    console.log(newMessage);  // 'hello world'\n    ```\n\nObjects, being mutable, can be changed after creation. Variables holding objects store references. This allows functions to modify the original object, which can be useful for shared state but also leads to potential side effects if not managed carefully.\n\n*   **Example (Object Mutability):**\n    ```javascript\n    let user = { name: 'Alice', age: 30 };\n    function increaseAge(person) {\n      person.age += 1; // Modifies the original 'user' object\n    }\n    increaseAge(user);\n    console.log(user.age); // 31 (original object mutated)\n\n    // Contrast with copying\n    function increaseAgeImmutable(person) {\n        return { ...person, age: person.age + 1 }; // Creates new object\n    }\n    let newUser = increaseAgeImmutable(user);\n    console.log(user.age); // 31 (still the original)\n    console.log(newUser.age); // 32 (new object)\n    ```\n\n**Implications for APIs:**\n*   **Primitives:** Safer to pass around, as they prevent unintended side effects. Functions can safely assume the input primitive won't change.\n*   **Objects:** If an API function takes an object, developers must be aware if the function mutates the object or returns a new one. Clear documentation is essential. For complex state management (e.g., Redux), immutability is often preferred to simplify change detection and debugging, leading to practices like cloning objects (`{...obj}`) before modification.",
          "analysisPoints": [
            "Clear explanation of primitive immutability and object mutability.",
            "Accurate and distinct code examples for both concepts.",
            "Discussion of practical implications for API design and common programming patterns."
          ],
          "keyConcepts": [
            "Immutability",
            "Mutability",
            "Primitive data types",
            "Object data types",
            "Pass by value vs reference",
            "Side effects",
            "API design"
          ],
          "evaluationCriteria": [
            "Depth of understanding of immutability/mutability.",
            "Quality and relevance of code examples.",
            "Insight into practical programming implications."
          ],
          "example": null,
          "tags": [
            "data-types",
            "memory-management",
            "api-design",
            "open-ended"
          ],
          "prerequisites": [
            "theory_javascript_data_types"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_data_types_4",
          "topic": "JavaScript Data Types",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following JavaScript values is considered a primitive type?",
          "answer": "Symbol",
          "options": [
            "Array",
            "Function",
            "Object",
            "Symbol"
          ],
          "analysisPoints": [
            "Recall the definition of primitive types.",
            "Distinguish between primitive and complex types."
          ],
          "keyConcepts": [
            "Primitive types",
            "Complex types",
            "JavaScript data types"
          ],
          "evaluationCriteria": [
            "Correctly identifies primitive types."
          ],
          "example": "`Array`, `Function`, and `Object` are all examples of complex (object) data types in JavaScript, while `Symbol` is a primitive introduced in ES6 for unique identifiers.",
          "tags": [
            "data-types",
            "primitives",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_data_types"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_data_types_5",
          "topic": "JavaScript Data Types",
          "level": "medium",
          "type": "flashcard",
          "question": "Is `null` an object in JavaScript? Explain why or why not, referring to its `typeof` result.",
          "answer": "No, `null` is a primitive value. While `typeof null` returns `'object'`, this is a historical bug in JavaScript that has persisted for compatibility reasons. Conceptually, `null` represents the intentional absence of any object value, making it a primitive.",
          "analysisPoints": [
            "Address the common misconception about `typeof null`.",
            "Explain the historical reason for `typeof null === 'object'`.",
            "Reinforce that `null` is conceptually a primitive."
          ],
          "keyConcepts": [
            "Null",
            "Primitive data types",
            "typeof operator",
            "JavaScript quirks"
          ],
          "evaluationCriteria": [
            "Accurate explanation of `null`'s type.",
            "Awareness of `typeof` bug."
          ],
          "example": null,
          "tags": [
            "data-types",
            "primitives",
            "quirks",
            "flashcard"
          ],
          "prerequisites": [
            "theory_javascript_data_types"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_data_types_6",
          "topic": "JavaScript Data Types",
          "level": "hard",
          "type": "code",
          "question": "Write a JavaScript function `deepCompare(a, b)` that returns `true` if two values `a` and `b` are deeply equal, and `false` otherwise. The function should handle primitive types and objects/arrays recursively. Consider edge cases like `null`, `undefined`, and circular references (optional, for extra credit).",
          "answer": "```javascript\nfunction deepCompare(a, b, seen = new WeakMap()) {\n  // 1. Primitive comparison\n  if (a === b) {\n    return true;\n  }\n\n  // 2. Handle null, undefined, NaN, and non-objects\n  if (a == null || b == null || typeof a !== 'object' && typeof b !== 'object') {\n    // Special case for NaN: NaN === NaN is false, but NaN should be deepCompare equal to NaN\n    if (Number.isNaN(a) && Number.isNaN(b)) {\n        return true;\n    }\n    return false;\n  }\n\n  // 3. Handle different constructors or types (e.g., Array vs Object)\n  if (a.constructor !== b.constructor) {\n    return false;\n  }\n\n  // 4. Handle circular references\n  if (seen.has(a) && seen.get(a) === b) {\n    return true; // Already compared this pair in the current path and found equal\n  }\n  if (seen.has(a) || seen.has(b)) {\n    // If one is seen but the other is not the same partner, it's a different path\n    // Or if different partners, then not equal\n    // For simplicity, we can return false for now or handle more robustly.\n    // A proper solution would require tracking which pairs have been compared.\n    // For interview context, mentioning it is usually sufficient.\n  }\n  seen.set(a, b);\n  seen.set(b, a); // Store both directions for robustness\n\n  // 5. Array comparison\n  if (Array.isArray(a)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (!deepCompare(a[i], b[i], seen)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // 6. Object comparison\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (const key of keysA) {\n    if (!keysB.includes(key) || !deepCompare(a[key], b[key], seen)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Test cases\nconsole.log('--- Primitives ---');\nconsole.log(deepCompare(1, 1)); // true\nconsole.log(deepCompare('hello', 'hello')); // true\nconsole.log(deepCompare(null, null)); // true\nconsole.log(deepCompare(undefined, undefined)); // true\nconsole.log(deepCompare(1, 2)); // false\nconsole.log(deepCompare(null, undefined)); // false\nconsole.log(deepCompare(NaN, NaN)); // true (special case)\n\nconsole.log('--- Objects ---');\nconst obj1 = { a: 1, b: { c: 2 } };\nconst obj2 = { a: 1, b: { c: 2 } };\nconst obj3 = { a: 1, b: { c: 3 } };\nconst obj4 = { a: 1, b: { c: 2 }, d: 4 };\nconsole.log(deepCompare(obj1, obj2)); // true\nconsole.log(deepCompare(obj1, obj3)); // false\nconsole.log(deepCompare(obj1, obj4)); // false\n\nconsole.log('--- Arrays ---');\nconst arr1 = [1, { a: 2 }, [3, 4]];\nconst arr2 = [1, { a: 2 }, [3, 4]];\nconst arr3 = [1, { a: 2 }, [3, 5]];\nconsole.log(deepCompare(arr1, arr2)); // true\nconsole.log(deepCompare(arr1, arr3)); // false\n\nconsole.log('--- Mixed Types ---');\nconsole.log(deepCompare([1], 1)); // false\nconsole.log(deepCompare({}, [])); // false\n\nconsole.log('--- Circular References (Advanced) ---');\nconst circularA = {};\nconst circularB = {};\ncircularA.b = circularB;\ncircularB.a = circularA;\nconsole.log(deepCompare(circularA, circularB)); // true (should handle gracefully, or depend on specific requirement)\n\nconst circularX = {};\nconst circularY = {};\ncircularX.self = circularX;\ncircularY.self = circularY;\nconsole.log(deepCompare(circularX, circularY)); // true\n\nconst circularP = {};\nconst circularQ = { prop: {} };\ncircularP.self = circularP;\ncircularQ.prop.self = circularQ.prop; // Different structure of circularity\nconsole.log(deepCompare(circularP, circularQ)); // false\n\nconst circularR = {};\nconst circularS = {};\ncircularR.ref = circularS;\ncircularS.ref = circularR;\n\n// Create slightly different circular structure\nconst circularT = {};\nconst circularU = {};\ncircularT.ref = circularU;\ncircularU.ref = circularT;\n\nconsole.log(deepCompare(circularR, circularT)); // true\n\nconst circularM = {};\nconst circularN = {};\ncircularM.ref = circularM;\ncircularN.ref = circularN;\nconsole.log(deepCompare(circularM, circularN)); // true\n\nconst circularV = {};\nconst circularW = {};\ncircularV.ref = circularW;\ncircularW.ref = circularV;\ncircularV.extra = 1;\nconsole.log(deepCompare(circularV, circularW)); // false (extra property)\n```",
          "analysisPoints": [
            "Handles strict equality for primitives.",
            "Checks for `null`, `undefined`, and non-object types correctly.",
            "Recursively compares properties for objects and elements for arrays.",
            "Compares lengths of arrays and number of keys for objects.",
            "Checks for different constructors (e.g., array vs. object).",
            "Includes a mechanism (WeakMap) to detect and handle circular references to prevent infinite loops.",
            "Correctly handles `NaN` comparison."
          ],
          "keyConcepts": [
            "Deep comparison",
            "Recursion",
            "Primitive vs. Object types",
            "Type checking",
            "Circular references",
            "WeakMap"
          ],
          "evaluationCriteria": [
            "Correctness for primitives, objects, and arrays.",
            "Robustness in handling edge cases (null, undefined, NaN).",
            "Efficiency (avoiding infinite loops for circular references).",
            "Code organization and readability."
          ],
          "example": null,
          "tags": [
            "data-structures",
            "algorithms",
            "recursion",
            "code-challenge",
            "advanced-js"
          ],
          "prerequisites": [
            "theory_javascript_data_types",
            "recursion",
            "hash-maps"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_type_conversion_1",
          "topic": "JavaScript Type Conversion",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `parseInt()` and `Number()` when converting a string like '123px' to a number?",
          "answer": "`parseInt('123px')` will return `123` because it parses until it encounters a non-numeric character. `Number('123px')` will return `NaN` because `Number()` is stricter and requires the entire string to be a valid number.",
          "analysisPoints": [
            "Differentiate parsing behavior for `parseInt` and `Number`.",
            "Identify when each function would return a valid number versus `NaN`."
          ],
          "keyConcepts": [
            "parseInt()",
            "Number()",
            "Type coercion",
            "NaN"
          ],
          "evaluationCriteria": [
            "Basic understanding of type conversion function behavior."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "conversion-methods",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_type_conversion_2",
          "topic": "JavaScript Type Conversion",
          "level": "medium",
          "type": "mcq",
          "question": "What will be the output of `parseInt('0xFF', 16)`?",
          "answer": "255",
          "options": [
            "0",
            "NaN",
            "FF",
            "255"
          ],
          "analysisPoints": [
            "Knowledge of `parseInt()`'s `radix` parameter.",
            "Ability to convert hexadecimal to decimal."
          ],
          "keyConcepts": [
            "parseInt()",
            "Radix",
            "Hexadecimal conversion"
          ],
          "evaluationCriteria": [
            "Correctly uses `radix` parameter."
          ],
          "example": "`0xFF` is a hexadecimal number. When `parseInt()` is called with `16` as the radix, it interprets the string as a base-16 number. In hexadecimal, `F` represents `15`. So, `0xFF` means `(0 * 16^2) + (15 * 16^1) + (15 * 16^0) = 0 + 240 + 15 = 255`.",
          "tags": [
            "type-coercion",
            "conversion-methods",
            "mcq",
            "numbers"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_type_conversion_3",
          "topic": "JavaScript Type Conversion",
          "level": "medium",
          "type": "open",
          "question": "List all 'falsy' values in JavaScript. Why is understanding falsy values important in frontend development?",
          "answer": "The 'falsy' values in JavaScript are:\n*   `false`\n*   `0` (zero)\n*   `-0` (negative zero)\n*   `0n` (BigInt zero)\n*   `''` (empty string)\n*   `null`\n*   `undefined`\n*   `NaN`\n\nUnderstanding falsy values is crucial in frontend development because they dictate how values behave in boolean contexts, such as `if` statements, logical operators (`&&`, `||`), and conditional rendering in UI frameworks. For example:\n\n*   **Conditional Logic**: `if (value)` will evaluate to `false` if `value` is any of the falsy values. This is commonly used for checking if a variable has a meaningful value (e.g., `if (username)` checks if `username` is not an empty string, `null`, or `undefined`).\n*   **Default Values**: Logical OR (`||`) operator leverages falsy values to provide default values, like `const userName = storedUser || 'Guest';`.\n*   **Boolean Coercion**: When working with APIs or external data, values might not be strict booleans (`true`/`false`), but their truthiness/falsiness determines their behavior. Knowing which values are falsy helps in correctly interpreting such data.",
          "analysisPoints": [
            "Accurate and complete list of falsy values.",
            "Clear explanation of why understanding falsy values is important, with practical examples in frontend context (conditional rendering, default values)."
          ],
          "keyConcepts": [
            "Falsy values",
            "Boolean coercion",
            "Conditional statements",
            "Logical operators",
            "Frontend best practices"
          ],
          "evaluationCriteria": [
            "Completeness of falsy list.",
            "Relevance and clarity of explanation and examples."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "javascript-fundamentals",
            "boolean",
            "open-ended"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_type_conversion_4",
          "topic": "JavaScript Type Conversion",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following expressions will result in `true`?",
          "answer": "Boolean('0')",
          "options": [
            "Boolean(0)",
            "Boolean('')",
            "Boolean(null)",
            "Boolean('0')"
          ],
          "analysisPoints": [
            "Knowledge of falsy values.",
            "Understanding that non-empty strings (even '0') are truthy."
          ],
          "keyConcepts": [
            "Falsy values",
            "Boolean coercion",
            "String truthiness"
          ],
          "evaluationCriteria": [
            "Correctly identifies truthy/falsy values."
          ],
          "example": "`0`, `''` (empty string), and `null` are all falsy values in JavaScript. However, any non-empty string, including `'0'`, is considered truthy. Therefore, `Boolean('0')` evaluates to `true`.",
          "tags": [
            "type-coercion",
            "boolean",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_type_conversion_5",
          "topic": "JavaScript Type Conversion",
          "level": "medium",
          "type": "code",
          "question": "Given a variable `input`. Write a JavaScript snippet that safely converts `input` to a number, handling cases where it might be `undefined`, `null`, an empty string, or a string with non-numeric characters, returning `0` in such invalid cases, but retaining `NaN` if `input` itself is `NaN`.",
          "answer": "```javascript\nfunction safeConvertToNumber(input) {\n  if (input === undefined || input === null || input === '') {\n    return 0; // Convert undefined, null, empty string to 0\n  }\n  const num = Number(input);\n  if (Number.isNaN(num) && input !== NaN) {\n    return 0; // If Number() results in NaN, but original input was not NaN, return 0\n  }\n  return num;\n}\n\n// Test cases\nconsole.log(safeConvertToNumber('42'));         // 42\nconsole.log(safeConvertToNumber('3.14'));        // 3.14\nconsole.log(safeConvertToNumber('42px'));        // 0\nconsole.log(safeConvertToNumber(undefined));     // 0\nconsole.log(safeConvertToNumber(null));          // 0\nconsole.log(safeConvertToNumber(''));            // 0\nconsole.log(safeConvertToNumber(0));             // 0\nconsole.log(safeConvertToNumber(NaN));           // NaN\nconsole.log(safeConvertToNumber(true));          // 1\nconsole.log(safeConvertToNumber('  -10 '));      // -10\n```",
          "analysisPoints": [
            "Uses `Number()` for strict conversion.",
            "Explicitly checks for `undefined`, `null`, `''`.",
            "Distinguishes `NaN` from input that *becomes* `NaN` due to conversion failure.",
            "Returns `0` for invalid conversions.",
            "Handles `NaN` input correctly (returns `NaN`)."
          ],
          "keyConcepts": [
            "Type conversion",
            "Number()",
            "isNaN()",
            "Edge cases",
            "Conditional logic"
          ],
          "evaluationCriteria": [
            "Correctness across various input types.",
            "Adherence to specified return values for edge cases.",
            "Code clarity and efficiency."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "data-validation",
            "code-challenge",
            "edge-cases"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_type_conversion_6",
          "topic": "JavaScript Type Conversion",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast JavaScript's implicit type coercion and explicit type conversion. When might implicit coercion lead to bugs, and why is explicit conversion generally preferred in professional code?",
          "answer": "**Implicit Type Coercion** occurs automatically when JavaScript tries to operate on values of different types. The engine silently converts one or both operands to a compatible type. Examples include:\n*   `'5' - 2` (string '5' becomes number 5)\n*   `true + 1` (boolean true becomes number 1)\n*   `if (someValue)` (any value coerced to boolean)\n\n**Explicit Type Conversion** (or type casting) involves using built-in functions or constructors (`Number()`, `String()`, `Boolean()`, `parseInt()`, `parseFloat()`) to intentionally convert a value from one type to another.\n\n**Comparison & Contrast:**\n*   **Automatic vs. Intentional:** Implicit is automatic; explicit is developer-driven.\n*   **Predictability:** Explicit conversion is generally more predictable and readable because the conversion is clearly stated in the code. Implicit coercion can be surprising and lead to unexpected results.\n*   **Debugging:** Bugs caused by implicit coercion can be harder to diagnose as the conversion happens silently.\n\n**When Implicit Coercion Leads to Bugs:**\n*   **The `+` operator:** This is the most common culprit. It acts as both numeric addition and string concatenation. `1 + '2'` results in `'12'`, not `3`. `[1,2] + [3,4]` results in `'1,23,4'`. If a developer expects numeric addition but gets string concatenation (or vice-versa), it's a bug.\n*   **Loose equality (`==`)**: `0 == false`, `'' == false`, `null == undefined` all evaluate to `true` due to implicit coercion, which can mask actual type mismatches and lead to logic errors.\n*   **Misleading Truthiness/Falsiness**: Relying purely on truthiness can hide valid `0` or empty string values, e.g., `if (count)` will be false if `count` is `0`, even if `0` is a valid quantity.\n\n**Why Explicit Conversion is Preferred:**\n1.  **Readability**: Code clearly states the intent of conversion, making it easier for other developers (and future self) to understand.\n2.  **Predictability**: Reduces the chance of unexpected behavior due to JavaScript's complex coercion rules.\n3.  **Maintainability**: Easier to debug and refactor when conversions are explicit.\n4.  **Error Prevention**: Helps prevent common bugs related to `+` operator ambiguity or loose equality.\n\nIn essence, explicit conversion makes the code's behavior transparent and less prone to subtle, hard-to-find bugs.",
          "analysisPoints": [
            "Clear definitions of implicit and explicit conversion.",
            "Effective comparison of the two approaches.",
            "Specific examples of `+` operator, `==`, and truthiness leading to bugs.",
            "Comprehensive reasons for preferring explicit conversion, linking to readability, predictability, etc."
          ],
          "keyConcepts": [
            "Implicit coercion",
            "Explicit conversion",
            "Type coercion",
            "Operators",
            "Best practices",
            "Debugging",
            "Loose equality"
          ],
          "evaluationCriteria": [
            "Depth of comparative analysis.",
            "Accuracy of examples for implicit coercion bugs.",
            "Strong justification for explicit preference.",
            "Overall clarity and structure of the explanation."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "javascript-fundamentals",
            "best-practices",
            "open-ended"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_operators_1",
          "topic": "JavaScript Operators",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary difference in behavior between `i++` and `++i` when used in an expression?",
          "answer": "`i++` returns the original value before incrementing, `++i` returns the value after incrementing.",
          "options": [
            "They are functionally identical and have no difference.",
            "`i++` returns the original value before incrementing, `++i` returns the value after incrementing.",
            "`i++` increments `i` by 1, `++i` increments `i` by 2.",
            "`i++` can only be used in `for` loops, `++i` can be used anywhere."
          ],
          "analysisPoints": [
            "Recall the definitions of pre-increment and post-increment.",
            "Focus on the 'return value' aspect."
          ],
          "keyConcepts": [
            "Increment operators",
            "Pre-increment",
            "Post-increment"
          ],
          "evaluationCriteria": [
            "Correctly identifies the behavioral difference."
          ],
          "example": "```javascript\nlet a = 5;\nlet b = a++; // b is 5, a becomes 6\n\nlet x = 5;\nlet y = ++x; // y is 6, x becomes 6\n```",
          "tags": [
            "operators",
            "javascript-fundamentals",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_operators_and_pitfalls"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_operators_2",
          "topic": "JavaScript Operators",
          "level": "medium",
          "type": "code",
          "question": "Identify and correct the bug in the following `for` loop. Explain why the original code behaves incorrectly.\n\n```javascript\nlet numbers = [10, 20, 30, 40, 50];\nlet sum = 0;\nfor (let i = 0; i < numbers.length; i + 2) {\n  sum += numbers[i];\n}\nconsole.log(sum);\n```",
          "answer": "```javascript\n// Corrected code\nlet numbers = [10, 20, 30, 40, 50];\nlet sum = 0;\nfor (let i = 0; i < numbers.length; i += 2) { // Corrected: i + 2 changed to i += 2\n  sum += numbers[i];\n}\nconsole.log(sum); // Expected output: 10 + 30 + 50 = 90\n```\n\n**Explanation of the bug:**\n\nThe original code `i + 2` in the `for` loop's increment statement calculates `i + 2` but **does not assign the result back to `i`**. This means `i` always remains `0` (its initial value) throughout the loop. As long as `numbers.length` is greater than `0`, the condition `i < numbers.length` (`0 < 5`) will always be true, leading to an **infinite loop**. The `sum` would keep adding `numbers[0]` (which is `10`) repeatedly.\n\nTo correctly increment `i` by `2` in each iteration, you need to use an assignment operator: `i += 2` (shorthand for `i = i + 2`).",
          "analysisPoints": [
            "Correctly identifies the infinite loop bug.",
            "Explains that `i + 2` doesn't modify `i`.",
            "Provides the correct syntax `i += 2`.",
            "Explains the impact on the loop execution (infinite loop)."
          ],
          "keyConcepts": [
            "For loop",
            "Assignment operators",
            "Increment operators",
            "Common pitfalls",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Accurate bug identification and correction.",
            "Clear and comprehensive explanation of the underlying problem."
          ],
          "example": null,
          "tags": [
            "operators",
            "loops",
            "common-pitfalls",
            "code-challenge",
            "debugging"
          ],
          "prerequisites": [
            "theory_javascript_operators_and_pitfalls"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_operators_3",
          "topic": "JavaScript Operators",
          "level": "hard",
          "type": "open",
          "question": "Explain a scenario where the choice between `i++` and `++i` could significantly impact performance or correctness, beyond just the return value in an expression.",
          "answer": "While often negligible in simple numeric contexts, the choice between `i++` and `++i` can matter in more complex scenarios, particularly concerning objects, iterators, or performance-critical loops.\n\n**Performance (less common in modern JS engines, but theoretically exists):**\nIn some low-level languages or very old JavaScript engines, `++i` could theoretically be slightly more performant than `i++`. This is because `i++` needs to store the *original* value of `i` in a temporary variable before incrementing `i` and returning the temporary value. `++i` simply increments `i` and then uses the new value, potentially avoiding this temporary storage. However, modern JavaScript engines are highly optimized, and this difference is almost always optimized away, making it a micro-optimization not worth considering unless profiling indicates it's a bottleneck.\n\n**Correctness (more relevant in specific patterns):**\nConsider a custom iterator or a proxy object where incrementing might involve side effects or resource allocation/deallocation based on *when* the value is used versus *when* the increment occurs. If `i` is an object with a custom `valueOf` or `Symbol.toPrimitive` method, or if it's a part of a complex chain operation, the timing difference becomes crucial.\n\n**Example Scenario (Conceptual):**\nImagine a system where incrementing a counter (`i`) also triggers a network request or updates a UI element, and the old value vs. new value is important for the *order* of operations.\n\n```javascript\nclass EventCounter {\n  constructor(initial = 0) {\n    this.count = initial;\n  }\n\n  // Mimics ++i: increments, then returns new value\n  preIncrement() {\n    this.count++;\n    console.log(`Event Fired: Counter now ${this.count}`); // Event uses new value\n    return this.count;\n  }\n\n  // Mimics i++: returns old value, then increments\n  postIncrement() {\n    const oldValue = this.count;\n    this.count++;\n    console.log(`Event Fired: Counter was ${oldValue}`); // Event uses old value\n    return oldValue;\n  }\n}\n\nconst counter1 = new EventCounter();\nconsole.log(counter1.preIncrement());  // Output: Event Fired: Counter now 1, then prints 1\n\nconst counter2 = new EventCounter();\nconsole.log(counter2.postIncrement()); // Output: Event Fired: Counter was 0, then prints 0\n```\nIn this contrived example, if the `console.log` represented a crucial side effect (like logging an event with the counter's state), the choice of pre- or post-increment dictates whether the event is logged with the state *before* or *after* the increment. While simple `number` types don't have such side effects, complex objects or iterators could.",
          "analysisPoints": [
            "Discusses performance implications (even if minor in modern JS).",
            "Highlights correctness issues, especially with custom objects or side effects.",
            "Provides a concrete (even if conceptual) example illustrating how timing affects results.",
            "Emphasizes the difference in *when* the value is used relative to the increment."
          ],
          "keyConcepts": [
            "Pre-increment",
            "Post-increment",
            "Performance optimization",
            "Side effects",
            "Object prototypes",
            "Iterators"
          ],
          "evaluationCriteria": [
            "Depth of understanding beyond basic syntax.",
            "Ability to construct a relevant scenario.",
            "Clarity of explanation regarding subtle differences."
          ],
          "example": null,
          "tags": [
            "operators",
            "performance",
            "side-effects",
            "open-ended",
            "advanced-js"
          ],
          "prerequisites": [
            "theory_javascript_operators_and_pitfalls"
          ],
          "complexity": 8,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_operators_4",
          "topic": "JavaScript Operators",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the correct way to increment a variable `x` by `5` in a loop iteration, using a shorthand operator?",
          "answer": "`x += 5;`",
          "analysisPoints": [
            "Recall arithmetic assignment operators.",
            "Distinguish from simple addition without assignment."
          ],
          "keyConcepts": [
            "Assignment operators",
            "Compound assignment",
            "Loops"
          ],
          "evaluationCriteria": [
            "Basic understanding of assignment operators."
          ],
          "example": null,
          "tags": [
            "operators",
            "loops",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_edge_cases_1",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code:\n```javascript\nvar obj = {'1': 'A', 1: 'B', 0: 'C'};\nconsole.log(obj['1']);\nconsole.log(obj[1]);\n```\nWhat will be the output?",
          "answer": "B\nB",
          "options": [
            "A\nA",
            "A\nB",
            "B\nB",
            "B\nA"
          ],
          "analysisPoints": [
            "Understanding how JavaScript handles object property keys.",
            "Recognizing implicit string conversion for numeric keys.",
            "Identifying that `obj['1']` and `obj[1]` refer to the same property if the key is numeric or stringified numeric."
          ],
          "keyConcepts": [
            "Object property access",
            "Type coercion",
            "JavaScript quirks"
          ],
          "evaluationCriteria": [
            "Correctly predicts object property access behavior."
          ],
          "example": "In JavaScript, object keys are inherently strings. When you use a numeric literal like `1` as a key, it's implicitly converted to the string `'1'`. Therefore, `{'1': 'A', 1: 'B'}` is actually defining the *same* property twice, and the last assignment (`1: 'B'`) overwrites the previous one (`'1': 'A'`). Both `obj['1']` and `obj[1]` then access this overwritten value, which is 'B'.",
          "tags": [
            "objects",
            "type-coercion",
            "edge-cases",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_edge_cases_2",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "hard",
          "type": "code",
          "question": "Predict the output of the following JavaScript expression and explain the step-by-step evaluation process, including type coercion:\n\n```javascript\nconsole.log(10 - '2' + true + null - '3.5');\n```",
          "answer": "```javascript\nconsole.log(10 - '2' + true + null - '3.5'); // Output: 5.5\n```\n\n**Step-by-step evaluation:**\n\n1.  **`10 - '2'`**: The `-` operator forces numeric conversion. `'2'` becomes `2`. Result: `10 - 2 = 8`.\n2.  **`8 + true`**: The `+` operator. Since `8` is a number and `true` is a boolean, `true` is converted to `1`. Result: `8 + 1 = 9`.\n3.  **`9 + null`**: The `+` operator. `null` is converted to `0`. Result: `9 + 0 = 9`.\n4.  **`9 - '3.5'`**: The `-` operator forces numeric conversion. `'3.5'` becomes `3.5`. Result: `9 - 3.5 = 5.5`.\n\n**Final Output**: `5.5`",
          "analysisPoints": [
            "Correctly identifies type coercion for each operator.",
            "Explains the behavior of `+` vs `-` operators with mixed types.",
            "Provides a clear step-by-step breakdown of evaluation.",
            "Correctly predicts the final output."
          ],
          "keyConcepts": [
            "Type coercion",
            "Operators",
            "Operator precedence",
            "Mixed type arithmetic",
            "Edge cases"
          ],
          "evaluationCriteria": [
            "Accuracy of step-by-step explanation.",
            "Correctness of intermediate and final results.",
            "Demonstrates deep understanding of JS coercion rules."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "edge-cases",
            "code-challenge"
          ],
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_edge_cases_3",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "medium",
          "type": "mcq",
          "question": "What value will `result` hold after the following code executes?\n\n```javascript\nlet x = null;\nlet y = 'hello';\nlet z = 0;\n\nconst result = x || y || z || 100;\n```",
          "answer": "'hello'",
          "options": [
            "null",
            "'hello'",
            "0",
            "100"
          ],
          "analysisPoints": [
            "Understanding of logical OR (`||`) operator.",
            "Knowledge of truthy/falsy values.",
            "Ability to apply short-circuit evaluation."
          ],
          "keyConcepts": [
            "Logical operators",
            "Short-circuit evaluation",
            "Truthy/Falsy values"
          ],
          "evaluationCriteria": [
            "Correctly applies short-circuiting logic."
          ],
          "example": "The `||` (OR) operator returns the first truthy value it encounters. \n1. `x` is `null`, which is falsy.\n2. `y` is `'hello'`, which is truthy. The evaluation stops here and `'hello'` is returned.",
          "tags": [
            "operators",
            "truthy-falsy",
            "short-circuiting",
            "mcq"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_edge_cases_4",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "medium",
          "type": "open",
          "question": "Explain the behavior of the `&&` (AND) operator in JavaScript when used with non-boolean operands. Provide an example.",
          "answer": "The `&&` (AND) operator in JavaScript, unlike in some other languages, does not always return a boolean `true` or `false`. Instead, it uses 'short-circuit evaluation' and returns the value of one of the operands.\n\nIts behavior is as follows:\n1.  It evaluates operands from left to right.\n2.  If the **first operand is falsy**, it stops evaluating and returns the value of that first falsy operand.\n3.  If the **first operand is truthy**, it continues to the second operand. It then returns the value of the second operand (whether that second operand is truthy or falsy).\n\n**Example:**\n```javascript\nconsole.log(5 && 10);        // Output: 10 (5 is truthy, returns the last operand)\nconsole.log('hello' && 0);   // Output: 0 ('hello' is truthy, 0 is falsy, returns 0)\nconsole.log(null && 'world'); // Output: null (null is falsy, returns null immediately)\nconsole.log(true && 'value'); // Output: 'value' (true is truthy, returns 'value')\nconsole.log(0 && false);     // Output: 0 (0 is falsy, returns 0 immediately)\n```\nThis behavior is commonly used for conditional execution or setting default values, e.g., `user && user.profile.name` to safely access nested properties, or `options.debug && runDebugger();`.",
          "analysisPoints": [
            "Clear explanation of short-circuit evaluation for `&&`.",
            "Correctly identifies what value is returned (first falsy or last truthy).",
            "Provides illustrative examples for different scenarios.",
            "Mentions practical applications (e.g., safe property access)."
          ],
          "keyConcepts": [
            "Logical AND operator",
            "Short-circuit evaluation",
            "Truthy/Falsy values",
            "Conditional execution"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of explanation.",
            "Relevance and clarity of examples.",
            "Demonstrates understanding of operator's return value."
          ],
          "example": null,
          "tags": [
            "operators",
            "short-circuiting",
            "truthy-falsy",
            "open-ended"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_edge_cases_5",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "hard",
          "type": "code",
          "question": "What is the output of the following and explain why? How can you get a numeric sum of the arrays?\n\n```javascript\nconsole.log([] + {});\nconsole.log({} + []);\nconsole.log([1,2] + [3,4]);\n```",
          "answer": "```javascript\nconsole.log([] + {});   // Output: [object Object]\nconsole.log({} + []);   // Output: [object Object] (or 0 in some contexts, see explanation)\nconsole.log([1,2] + [3,4]); // Output: 1,23,4\n```\n\n**Explanation:**\n\n1.  **`[] + {}`**: The `+` operator, when applied to objects, attempts to convert them to primitives via `valueOf()` or `toString()`. An empty array `[]` typically converts to an empty string `''`. An empty object `{}` typically converts to the string `'[object Object]'`. When string concatenation occurs, `'' + '[object Object]'` results in `'[object Object]'`.\n\n2.  **`{} + []`**: This is tricky due to JavaScript's parsing rules. If this expression appears at the *beginning of a statement* (e.g., directly in `console.log`), the `{}` is often interpreted as an empty **code block**, not an object literal. In such a case, the code block is ignored, and the expression effectively becomes `+[]`. The unary `+` operator converts `[]` to a number. `[]`'s `valueOf()` returns `[]`, then `toString()` returns `''`, and `Number('')` is `0`. So, `0` would be the result. However, if it's part of a larger expression or explicitly wrapped (e.g., `({} + [])`), then `{}` is treated as an object, leading to `[object Object]` for the same reasons as `[] + {}`.\n    *   **In `console.log({} + [])`**: Most modern browsers and Node.js will interpret `{}` as an object literal due to it being an expression argument, leading to `'[object Object]'`. The result `'[object Object]'` is what's commonly observed in console.log.\n\n3.  **`[1,2] + [3,4]`**: Again, the `+` operator performs string concatenation because arrays are objects. `[1,2]` is converted to the string `'1,2'`, and `[3,4]` is converted to `'3,4'`. Concatenating these strings gives `'1,23,4'`.\n\n**How to get a numeric sum of the arrays:**\n\nTo get a numeric sum, you need to explicitly convert the array elements to numbers and perform addition, or iterate and sum them. The `+` operator directly on arrays will *not* perform element-wise numeric addition.\n\n```javascript\n// Option 1: Summing elements individually\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\n\nconst sumArr1 = arr1.reduce((acc, val) => acc + val, 0); // 3\nconst sumArr2 = arr2.reduce((acc, val) => acc + val, 0); // 7\nconsole.log(sumArr1 + sumArr2); // Output: 10\n\n// Option 2: Combining and summing (if treating as a single list)\nconst combinedArr = [...arr1, ...arr2]; // [1,2,3,4]\nconst totalSum = combinedArr.reduce((acc, val) => acc + val, 0);\nconsole.log(totalSum); // Output: 10\n\n// If the intention was element-wise addition to create a new array:\nconst resultArr = arr1.map((val, index) => val + arr2[index]);\nconsole.log(resultArr); // Output: [4, 6]\n```",
          "analysisPoints": [
            "Correctly explains the implicit string coercion for arrays with `+` operator.",
            "Addresses the ambiguity of `{}` when at the start of a statement vs. an expression.",
            "Provides clear step-by-step reasoning for each output.",
            "Offers multiple correct ways to achieve numeric summation or element-wise addition of arrays, contrasting with the implicit behavior."
          ],
          "keyConcepts": [
            "Type coercion",
            "Operators",
            "Object to primitive conversion",
            "Array toString()",
            "Code blocks vs. object literals",
            "Array methods (map, reduce)",
            "Spread syntax"
          ],
          "evaluationCriteria": [
            "Accuracy of output prediction and explanation.",
            "Demonstrates advanced understanding of JS parsing and coercion.",
            "Provides viable solutions for desired numeric operations.",
            "Clarity and completeness of explanation."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "edge-cases",
            "operators",
            "arrays",
            "code-challenge",
            "advanced-js"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 10,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_edge_cases_6",
          "topic": "JavaScript Behavior & Edge Cases",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference in the result of `!!(a && b)` versus `(a && b)` when `a = 5` and `b = 10`?",
          "answer": "`!!(a && b)` will result in `true` (a boolean). `(a && b)` will result in `10` (the last truthy value).",
          "analysisPoints": [
            "Understand `!!` for explicit boolean conversion.",
            "Recall `&&` short-circuit behavior (returns value, not just boolean)."
          ],
          "keyConcepts": [
            "Logical operators",
            "Short-circuit evaluation",
            "Double negation (!!)",
            "Type coercion"
          ],
          "evaluationCriteria": [
            "Correctly identifies the type and value returned by each expression."
          ],
          "example": null,
          "tags": [
            "operators",
            "truthy-falsy",
            "short-circuiting",
            "flashcard"
          ],
          "prerequisites": [
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_strategy_pattern_calculator",
          "title": "Implement a Flexible Calculator with Strategy Pattern",
          "description": "\nImplement a `Calculator` class that can perform different arithmetic operations (addition, subtraction, multiplication, division) using the Strategy design pattern.\n\n**Requirements:**\n1.  Create a `Calculator` class (Context) that has a `setStrategy` method and an `executeOperation` method.\n2.  Define an implicit `OperationStrategy` interface (e.g., a method `execute(a, b)`).\n3.  Implement at least three concrete strategy classes: `AdditionStrategy`, `SubtractionStrategy`, and `MultiplicationStrategy`.\n4.  Each strategy should implement the `execute` method to perform its respective operation.\n5.  Ensure the `Calculator` can switch between strategies dynamically and execute the operation.\n6.  Handle potential errors in `executeOperation` if no strategy is set.\n",
          "difficulty": "medium",
          "startingCode": "class Calculator {\n  // TODO: Implement Calculator (Context) class\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeOperation(a, b) {\n    // Ensure strategy is set, otherwise throw an error\n    if (!this.strategy) {\n      throw new Error(\"No operation strategy set.\");\n    }\n    return this.strategy.execute(a, b);\n  }\n}\n\n// TODO: Implement concrete strategy classes (AdditionStrategy, SubtractionStrategy, MultiplicationStrategy)\n\n// Example Usage (to be uncommented and tested):\n// const calculator = new Calculator();\n// const a = 10;\n// const b = 5;\n\n// calculator.setStrategy(new AdditionStrategy());\n// console.log(`${a} + ${b} =`, calculator.executeOperation(a, b)); // Expected: 15\n\n// calculator.setStrategy(new SubtractionStrategy());\n// console.log(`${a} - ${b} =`, calculator.executeOperation(a, b)); // Expected: 5\n\n// calculator.setStrategy(new MultiplicationStrategy());\n// console.log(`${a} * ${b} =`, calculator.executeOperation(a, b)); // Expected: 50\n\n// Test error handling\n// const emptyCalculator = new Calculator();\n// try {\n//   emptyCalculator.executeOperation(1, 2);\n// } catch (error) {\n//   console.error(error.message); // Expected: No operation strategy set.\n// }\n",
          "solutionCode": "class Calculator {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeOperation(a, b) {\n    if (!this.strategy) {\n      throw new Error(\"No operation strategy set.\");\n    }\n    return this.strategy.execute(a, b);\n  }\n}\n\nclass AdditionStrategy {\n  execute(a, b) {\n    return a + b;\n  }\n}\n\nclass SubtractionStrategy {\n  execute(a, b) {\n    return a - b;\n  }\n}\n\nclass MultiplicationStrategy {\n  execute(a, b) {\n    return a * b;\n  }\n}\n\n// Optional: Division Strategy with error handling for division by zero\nclass DivisionStrategy {\n  execute(a, b) {\n    if (b === 0) {\n      throw new Error(\"Cannot divide by zero.\");\n    }\n    return a / b;\n  }\n}\n\nconst calculator = new Calculator();\nconst a = 10;\nconst b = 5;\n\ncalculator.setStrategy(new AdditionStrategy());\nconsole.log(`${a} + ${b} =`, calculator.executeOperation(a, b));\n\ncalculator.setStrategy(new SubtractionStrategy());\nconsole.log(`${a} - ${b} =`, calculator.executeOperation(a, b));\n\ncalculator.setStrategy(new MultiplicationStrategy());\nconsole.log(`${a} * ${b} =`, calculator.executeOperation(a, b));\n\ncalculator.setStrategy(new DivisionStrategy());\nconsole.log(`${a} / ${b} =`, calculator.executeOperation(a, b));\n\n// Test error handling for missing strategy\nconst emptyCalculator = new Calculator();\ntry {\n  emptyCalculator.executeOperation(1, 2);\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\n\n// Test error handling for division by zero\ntry {\n  calculator.setStrategy(new DivisionStrategy());\n  console.log(`${a} / 0 =`, calculator.executeOperation(a, 0));\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\n",
          "testCases": [
            "Test addition: `calculator.setStrategy(new AdditionStrategy()); calculator.executeOperation(10, 5)` should return `15`.",
            "Test subtraction: `calculator.setStrategy(new SubtractionStrategy()); calculator.executeOperation(10, 5)` should return `5`.",
            "Test multiplication: `calculator.setStrategy(new MultiplicationStrategy()); calculator.executeOperation(10, 5)` should return `50`.",
            "Test error when no strategy is set: `new Calculator().executeOperation(1, 2)` should throw an error with message 'No operation strategy set.'.",
            "Test with floating-point numbers.",
            "Test with negative numbers."
          ],
          "hints": [
            "Remember that in JavaScript, interfaces are often implicit. Just ensure each strategy class has the required `execute` method.",
            "The `Calculator` (Context) should only know about the `execute` method, not the specific strategy class names.",
            "Think about adding a default strategy or robust error handling if no strategy is explicitly set."
          ],
          "tags": [
            "design-patterns",
            "strategy-pattern",
            "oop",
            "classes",
            "frontend-architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_strategy_pattern",
            "object-oriented-programming"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "polymorphism",
            "loose-coupling",
            "open-closed-principle"
          ]
        },
        {
          "id": "task_deep_clone_object",
          "title": "Implement a Deep Clone Function for Objects and Arrays",
          "description": "\nWrite a JavaScript function `deepClone(value)` that creates a deep copy of a given value. The function should handle:\n\n1.  **Primitive types**: Return them directly.\n2.  **Objects**: Recursively clone all enumerable own properties.\n3.  **Arrays**: Recursively clone all elements.\n4.  **`null` and `undefined`**: Return them directly.\n5.  **Circular references (Bonus)**: Prevent infinite loops by detecting and handling circular references. If a circular reference is encountered, you can either return a reference to the already cloned object or throw an error, but preventing infinite loops is the primary goal. Returning the already cloned reference is a common approach.\n\nYour solution should use standard JavaScript features (no external libraries like Lodash).",
          "difficulty": "hard",
          "startingCode": "function deepClone(value, hash = new WeakMap()) {\n  // 1. Handle primitives, null, undefined\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // 2. Handle circular references (Bonus)\n  if (hash.has(value)) {\n    return hash.get(value);\n  }\n\n  // 3. Determine if value is an Array or Object and create initial clone\n  const clone = Array.isArray(value) ? [] : {};\n\n  // 4. Store the clone in hash BEFORE recursive calls to handle circular references\n  hash.set(value, clone);\n\n  // 5. Recursively clone properties/elements\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone(value[key], hash);\n    }\n  }\n\n  return clone;\n}\n\n// Example Usage (to be uncommented and tested):\n// const obj1 = { a: 1, b: { c: 2 }, d: [3, 4] };\n// const clonedObj1 = deepClone(obj1);\n// console.log(clonedObj1); // Should be a deep copy\n// console.log(clonedObj1 === obj1); // false\n// console.log(clonedObj1.b === obj1.b); // false\n// console.log(clonedObj1.d === obj1.d); // false\n\n// const arr1 = [1, { x: 10 }, [20, 30]];\n// const clonedArr1 = deepClone(arr1);\n// console.log(clonedArr1); // Should be a deep copy\n// console.log(clonedArr1 === arr1); // false\n// console.log(clonedArr1[1] === arr1[1]); // false\n\n// // Test circular reference (Bonus)\n// const circularObj = {};\n// circularObj.self = circularObj;\n// const clonedCircularObj = deepClone(circularObj);\n// console.log(clonedCircularObj.self === clonedCircularObj); // true\n// console.log(clonedCircularObj === circularObj); // false\n\n// const circularArr = [];\n// circularArr.push(circularArr);\n// const clonedCircularArr = deepClone(circularArr);\n// console.log(clonedCircularArr[0] === clonedCircularArr); // true\n\n// // Test with Date/RegExp (optional advanced)\n// const date = new Date();\n// const clonedDate = deepClone(date);\n// console.log(clonedDate instanceof Date); // false (simple clone won't copy prototype)\n// console.log(clonedDate.getTime() === date.getTime()); // Value is copied\n\n// // Test for function/Symbol/BigInt (should return directly)\n// const func = () => {};\n// console.log(deepClone(func) === func); // true\n// const sym = Symbol('test');\n// console.log(deepClone(sym) === sym); // true\n// const big = 123n;\n// console.log(deepClone(big) === big); // true\n",
          "solutionCode": "function deepClone(value, hash = new WeakMap()) {\n  // 1. Handle primitives, null, undefined, functions, symbols, BigInts\n  // For simplicity, we'll treat functions, Symbols, BigInts as non-clonable objects,\n  // meaning they are returned by reference, which is standard for deep cloning.\n  // Date and RegExp objects are also tricky. A simple deep clone usually doesn't recreate them.\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // Handle Date objects\n  if (value instanceof Date) {\n    return new Date(value.getTime());\n  }\n\n  // Handle RegExp objects\n  if (value instanceof RegExp) {\n    return new RegExp(value.source, value.flags);\n  }\n\n  // 2. Handle circular references\n  if (hash.has(value)) {\n    return hash.get(value);\n  }\n\n  // 3. Determine if value is an Array or Object and create initial clone\n  const clone = Array.isArray(value) ? [] : {};\n\n  // 4. Store the clone in hash BEFORE recursive calls to handle circular references\n  hash.set(value, clone);\n\n  // 5. Recursively clone properties/elements\n  // Use Object.keys for objects to get enumerable own properties, \n  // or iterate through arrays\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      clone[i] = deepClone(value[i], hash);\n    }\n  } else {\n    for (const key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        clone[key] = deepClone(value[key], hash);\n      }\n    }\n  }\n\n  return clone;\n}\n\n// Test cases\nconst obj1 = { a: 1, b: { c: 2 }, d: [3, 4] };\nconst clonedObj1 = deepClone(obj1);\nconsole.log(\"obj1:\", obj1);\nconsole.log(\"clonedObj1:\", clonedObj1);\nconsole.log(\"clonedObj1 === obj1:\", clonedObj1 === obj1); // false\nconsole.log(\"clonedObj1.b === obj1.b:\", clonedObj1.b === obj1.b); // false\nconsole.log(\"clonedObj1.d === obj1.d:\", clonedObj1.d === obj1.d); // false\nconsole.log(\"clonedObj1.b.c === obj1.b.c:\", clonedObj1.b.c === obj1.b.c); // true (primitive)\n\nconst arr1 = [1, { x: 10 }, [20, 30]];\nconst clonedArr1 = deepClone(arr1);\nconsole.log(\"arr1:\", arr1);\nconsole.log(\"clonedArr1:\", clonedArr1);\nconsole.log(\"clonedArr1 === arr1:\", clonedArr1 === arr1); // false\nconsole.log(\"clonedArr1[1] === arr1[1]:\", clonedArr1[1] === arr1[1]); // false\n\n// Test circular reference (Bonus)\nconst circularObj = {};\ncircularObj.self = circularObj;\nconst clonedCircularObj = deepClone(circularObj);\nconsole.log(\"circularObj:\", circularObj);\nconsole.log(\"clonedCircularObj:\", clonedCircularObj);\nconsole.log(\"clonedCircularObj.self === clonedCircularObj:\", clonedCircularObj.self === clonedCircularObj); // true\nconsole.log(\"clonedCircularObj === circularObj:\", clonedCircularObj === circularObj); // false\n\nconst circularArr = [];\ncircularArr.push(circularArr);\nconst clonedCircularArr = deepClone(circularArr);\nconsole.log(\"circularArr:\", circularArr);\nconsole.log(\"clonedCircularArr:\", clonedCircularArr);\nconsole.log(\"clonedCircularArr[0] === clonedCircularArr:\", clonedCircularArr[0] === clonedCircularArr); // true\n\n// Test with Date/RegExp\nconst date = new Date();\nconst regex = /abc/gi;\nconst mixedObj = { d: date, r: regex, f: () => {}, s: Symbol('test'), b: 123n };\nconst clonedMixedObj = deepClone(mixedObj);\nconsole.log(\"mixedObj.d instanceof Date:\", mixedObj.d instanceof Date); // true\nconsole.log(\"clonedMixedObj.d instanceof Date:\", clonedMixedObj.d instanceof Date); // true\nconsole.log(\"clonedMixedObj.d.getTime() === mixedObj.d.getTime():\", clonedMixedObj.d.getTime() === mixedObj.d.getTime()); // true\nconsole.log(\"clonedMixedObj.r instanceof RegExp:\", clonedMixedObj.r instanceof RegExp); // true\nconsole.log(\"clonedMixedObj.r.source === mixedObj.r.source:\", clonedMixedObj.r.source === mixedObj.r.source); // true\nconsole.log(\"clonedMixedObj.f === mixedObj.f:\", clonedMixedObj.f === mixedObj.f); // true (functions are not deep cloned)\nconsole.log(\"clonedMixedObj.s === mixedObj.s:\", clonedMixedObj.s === mixedObj.s); // true (Symbols are primitives in this context)\nconsole.log(\"clonedMixedObj.b === mixedObj.b:\", clonedMixedObj.b === mixedObj.b); // true (BigInts are primitives)\n",
          "testCases": [
            "Test with primitive values (number, string, boolean, null, undefined).",
            "Test with a simple flat object.",
            "Test with a nested object.",
            "Test with an array containing primitives and objects.",
            "Test with an array containing nested arrays.",
            "Test with a mixed object (containing arrays, objects, primitives).",
            "Test with a circular object reference to ensure no infinite loop and correct cloning.",
            "Test with a circular array reference.",
            "Test `Date` and `RegExp` instances (for advanced solution)."
          ],
          "hints": [
            "Start with the base case: what happens if the value is a primitive or null?",
            "Use `typeof` to check for objects and `Array.isArray()` to differentiate arrays from plain objects.",
            "A `WeakMap` is ideal for tracking objects already visited during recursion, preventing memory leaks for objects that might be garbage collected.",
            "Remember to store the *cloned* object in the `WeakMap` *before* recursively cloning its properties/elements. This is crucial for handling circular references correctly."
          ],
          "tags": [
            "data-structures",
            "recursion",
            "deep-copy",
            "object-manipulation",
            "algorithms",
            "memory-management"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_javascript_data_types",
            "recursion",
            "WeakMap"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "expert",
          "relatedConcepts": [
            "shallow-copy",
            "json-parse-stringify",
            "structured-clone"
          ]
        },
        {
          "id": "task_robust_string_to_number",
          "title": "Create a Robust String-to-Number Converter",
          "description": "\nWrite a JavaScript function `convertToStrictNumber(input)` that converts a given input to a number based on the following rules:\n\n1.  If the input is already a `Number` (and not `NaN`), return it as is.\n2.  If the input is `null` or `undefined`, return `0`.\n3.  If the input is an empty string `''`, return `0`.\n4.  If the input is a string that represents a valid integer or float (e.g., `'123'`, `'-4.5'`, `'0'`), convert it and return the number.\n5.  If the input is a string that contains any non-numeric characters (e.g., `'123px'`, `'abc'`), return `NaN`.\n6.  If the input is `NaN`, return `NaN`.\n7.  For any other type of input (e.g., boolean, object, array), return `NaN`.\n\nYour goal is to be precise about valid number strings and invalid ones, and handle edge cases gracefully.",
          "difficulty": "medium",
          "startingCode": "function convertToStrictNumber(input) {\n  // TODO: Implement the conversion logic based on the requirements.\n\n  // Example of initial checks:\n  if (typeof input === 'number') {\n    return input; // Already a number, includes NaN\n  }\n  \n  if (input === null || input === undefined || input === '') {\n    return 0;\n  }\n\n  // ... rest of the logic\n  \n  return NaN; // Placeholder for invalid conversions\n}\n\n// Example Usage (to be uncommented and tested):\n// console.log(convertToStrictNumber(42));       // Expected: 42\n// console.log(convertToStrictNumber(-3.14));    // Expected: -3.14\n// console.log(convertToStrictNumber(NaN));      // Expected: NaN\n// console.log(convertToStrictNumber(null));     // Expected: 0\n// console.log(convertToStrictNumber(undefined));  // Expected: 0\n// console.log(convertToStrictNumber(''));       // Expected: 0\n// console.log(convertToStrictNumber('123'));    // Expected: 123\n// console.log(convertToStrictNumber('-4.5'));   // Expected: -4.5\n// console.log(convertToStrictNumber('0'));      // Expected: 0\n// console.log(convertToStrictNumber('  50  ')); // Expected: 50\n// console.log(convertToStrictNumber('123px'));  // Expected: NaN\n// console.log(convertToStrictNumber('abc'));    // Expected: NaN\n// console.log(convertToStrictNumber(true));     // Expected: NaN\n// console.log(convertToStrictNumber({}));       // Expected: NaN\n// console.log(convertToStrictNumber([]));        // Expected: NaN\n",
          "solutionCode": "function convertToStrictNumber(input) {\n  // Rule 1: If the input is already a Number (and not NaN), return it as is.\n  // We check for NaN later, as the initial 'typeof number' check would include NaN.\n  if (typeof input === 'number' && !Number.isNaN(input)) {\n    return input;\n  }\n\n  // Rule 2 & 3: If the input is null, undefined, or an empty string, return 0.\n  if (input === null || input === undefined || input === '') {\n    return 0;\n  }\n\n  // Rule 4 & 5: If the input is a string that represents a valid number, convert it.\n  // If it contains non-numeric chars, return NaN.\n  if (typeof input === 'string') {\n    // Use a regular expression to check if the string contains *only* numeric characters\n    // including optional sign, decimals, and scientific notation.\n    // Trim whitespace first.\n    const trimmedInput = input.trim();\n    if (trimmedInput === '') return 0; // After trim, if empty, it's an empty string case handled already\n\n    // Regex to match valid number strings including integers, floats, and scientific notation\n    // Allows for optional leading +/- sign, digits, optional decimal with digits, optional exponent part\n    const numberRegex = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$/;\n\n    if (numberRegex.test(trimmedInput)) {\n      return Number(trimmedInput);\n    } else {\n      return NaN; // String contains non-numeric characters\n    }\n  }\n\n  // Rule 6: If the input is NaN (from initial type check), handle it.\n  if (Number.isNaN(input)) {\n    return NaN;\n  }\n\n  // Rule 7: For any other type of input (e.g., boolean, object, array), return NaN.\n  return NaN;\n}\n\n// Test cases\nconsole.log(`42 -> ${convertToStrictNumber(42)}`);           // 42\nconsole.log(`-3.14 -> ${convertToStrictNumber(-3.14)}`);     // -3.14\nconsole.log(`NaN -> ${convertToStrictNumber(NaN)}`);         // NaN\nconsole.log(`null -> ${convertToStrictNumber(null)}`);       // 0\nconsole.log(`undefined -> ${convertToStrictNumber(undefined)}`); // 0\nconsole.log(`'' -> ${convertToStrictNumber('')}`);           // 0\nconsole.log(`'123' -> ${convertToStrictNumber('123')}`);     // 123\nconsole.log(`'-4.5' -> ${convertToStrictNumber('-4.5')}`);   // -4.5\nconsole.log(`'0' -> ${convertToStrictNumber('0')}`);         // 0\nconsole.log(`'  50  ' -> ${convertToStrictNumber('  50  ')}`); // 50\nconsole.log(`'123px' -> ${convertToStrictNumber('123px')}`); // NaN\nconsole.log(`'abc' -> ${convertToStrictNumber('abc')}`);     // NaN\nconsole.log(`true -> ${convertToStrictNumber(true)}`);       // NaN\nconsole.log(`{} -> ${convertToStrictNumber({})}`);           // NaN\nconsole.log(`[] -> ${convertToStrictNumber([])}`);           // NaN\nconsole.log(`'1e-3' -> ${convertToStrictNumber('1e-3')}`);   // 0.001\nconsole.log(`' ' -> ${convertToStrictNumber(' ')}`);         // 0 (trimmed to empty string)\n",
          "testCases": [
            "Test with valid numbers (positive, negative, float, zero).",
            "Test with `NaN` as input.",
            "Test with `null`, `undefined`, and empty string `''`.",
            "Test with strings representing valid numbers (integers, floats, scientific notation).",
            "Test with strings containing non-numeric characters (e.g., '10px', 'abc', '1.2.3').",
            "Test with strings containing only whitespace (should return 0, like empty string).",
            "Test with boolean `true` and `false`.",
            "Test with empty objects `{}` and empty arrays `[]`.",
            "Test with more complex objects/arrays."
          ],
          "hints": [
            "Consider using `Number.isNaN()` for checking `NaN` reliably.",
            "Regular expressions are powerful for validating string formats. You might need to build a regex that precisely matches valid numeric strings.",
            "Remember to handle leading/trailing whitespace in strings.",
            "`Number()` is stricter than `parseInt()`/`parseFloat()` for entire string validation.",
            "Pay close attention to the order of your checks, as some rules might override others."
          ],
          "tags": [
            "type-conversion",
            "data-validation",
            "edge-cases",
            "regular-expressions",
            "javascript-fundamentals"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_data_types"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "string-parsing",
            "data-sanitization",
            "robust-functions"
          ]
        },
        {
          "id": "task_sparse_array_iteration",
          "title": "Iterate and Process a Sparse Array",
          "description": "\nImplement a function `processSparseArray(arr)` that iterates over a potentially sparse array (an array with empty slots) and performs a specific operation only on existing elements, skipping the empty slots. The function should:\n\n1.  Take an array `arr` as input.\n2.  Use a `for` loop with a custom increment (e.g., iterating by 2, or skipping a certain number of elements).\n3.  For each *existing* element at the current `i`, double its value and add it to a `totalSum`.\n4.  Return the `totalSum`.\n5.  Ensure that `i + N` vs `i += N` distinction is handled correctly for your custom increment.\n6.  Handle cases where array elements are non-numeric or are empty slots.\n\n**Example of sparse array:** `[10, , 20, undefined, 30]`\n",
          "difficulty": "medium",
          "startingCode": "function processSparseArray(arr) {\n  let totalSum = 0;\n  // TODO: Implement the for loop and processing logic\n  // Iterate by steps of 2, summing only existing numeric values\n\n  for (let i = 0; i < arr.length; i += 2) { // Example increment by 2\n    // Check if the property exists and is a number\n    if (i in arr && typeof arr[i] === 'number') {\n      totalSum += arr[i] * 2; // Double the value of existing numeric elements\n    }\n  }\n\n  return totalSum;\n}\n\n// Example Usage (to be uncommented and tested):\n// console.log(processSparseArray([1, 2, 3, 4, 5, 6])); // Expected: 2 * (1 + 3 + 5) = 18\n// console.log(processSparseArray([10, , 20, undefined, 30])); // Expected: 2 * (10 + 20 + 30) = 120\n// console.log(processSparseArray([5, , 10, , 15, , 20])); // Expected: 2 * (5 + 10 + 15 + 20) = 100\n// console.log(processSparseArray([1, 'a', 3, null, 5])); // Expected: 2 * (1 + 3 + 5) = 18 (skip 'a' and null)\n// console.log(processSparseArray([])); // Expected: 0\n// console.log(processSparseArray([, , ,])); // Expected: 0\n",
          "solutionCode": "function processSparseArray(arr) {\n  let totalSum = 0;\n  \n  // Iterate with a custom increment of 2\n  for (let i = 0; i < arr.length; i += 2) { \n    // Check if the index is actually present in the array (not an empty slot)\n    // and if the value at that index is a number.\n    if (i in arr && typeof arr[i] === 'number') {\n      totalSum += arr[i] * 2; // Double the value and add to sum\n    }\n  }\n\n  return totalSum;\n}\n\n// Test cases\nconsole.log(`[1, 2, 3, 4, 5, 6] -> ${processSparseArray([1, 2, 3, 4, 5, 6])}`); // Expected: 2 * (1 + 3 + 5) = 18\nconsole.log(`[10, , 20, undefined, 30] -> ${processSparseArray([10, , 20, undefined, 30])}`); // Expected: 2 * (10 + 20 + 30) = 120\nconsole.log(`[5, , 10, , 15, , 20] -> ${processSparseArray([5, , 10, , 15, , 20])}`); // Expected: 2 * (5 + 10 + 15 + 20) = 100\nconsole.log(`[1, 'a', 3, null, 5] -> ${processSparseArray([1, 'a', 3, null, 5])}`); // Expected: 2 * (1 + 3 + 5) = 18\nconsole.log(`[] -> ${processSparseArray([])}`); // Expected: 0\nconsole.log(`[, , ,] -> ${processSparseArray([, , ,])}`); // Expected: 0\nconsole.log(`[0, 1, 2, 3, 4] -> ${processSparseArray([0, 1, 2, 3, 4])}`); // Expected: 2 * (0 + 2 + 4) = 12\n",
          "testCases": [
            "Test with a dense array (no empty slots).",
            "Test with a sparse array containing empty slots.",
            "Test with a sparse array containing `undefined` values (which are treated as existing, but possibly non-numeric).",
            "Test with array elements that are not numbers (strings, booleans, objects).",
            "Test with an empty array `[]`.",
            "Test with an array consisting entirely of empty slots `[, , ,]`.",
            "Test with `0` as an element value.",
            "Test a combination of sparse slots and non-numeric values."
          ],
          "hints": [
            "To check if an array index actually has a value (and isn't just an empty slot in a sparse array), use `i in arr` instead of just `arr[i] !== undefined`.",
            "Ensure your loop increment is `i += 2` (or `i = i + 2`) to actually update the counter.",
            "Remember to validate that the element is a `number` before performing arithmetic operations."
          ],
          "tags": [
            "arrays",
            "loops",
            "javascript-fundamentals",
            "edge-cases",
            "data-processing"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_javascript_operators_and_pitfalls",
            "theory_javascript_data_types"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "array-iteration",
            "sparse-arrays",
            "hasOwnProperty-in-operator"
          ]
        },
        {
          "id": "task_parse_mixed_data",
          "title": "Analyze and Calculate Mixed Data Expression",
          "description": "\nGiven a complex JavaScript expression involving numbers, strings, booleans, and `null`/`undefined` with various arithmetic and logical operators. Your task is to:\n\n1.  **Analyze**: Explain the step-by-step evaluation of the expression, detailing all implicit type coercions and operator behaviors.\n2.  **Predict**: State the final output of the expression.\n3.  **Refactor (Optional Bonus)**: Rewrite the expression using explicit type conversions and clearer logic to achieve the same result, or a clearly defined alternative if the original result is ambiguous/undesirable.\n\n**Expression:**\n```javascript\n5 + \"10\" - null + \"20\" + true - \"3\" - NaN\n```",
          "difficulty": "hard",
          "startingCode": "const expression = `5 + \"10\" - null + \"20\" + true - \"3\" - NaN`;\n\n// TODO: Analyze the expression step-by-step, predicting the output.\n// Then, (optional) refactor it for clarity/explicitness.\n\nconsole.log(\"Original Expression:\", expression);\nconsole.log(\"Predicted Output:\", /* Your predicted value here */);\n\n/* \nStep-by-step Analysis:\n1. ...\n2. ...\n...\n\nOptional Refactored Code:\n```javascript\n// Refactored version\n// ...\n```\n*/\n",
          "solutionCode": "const expression = `5 + \"10\" - null + \"20\" + true - \"3\" - NaN`;\n\nconsole.log(\"Original Expression:\", expression);\n\n/* \nStep-by-step Analysis:\n\nExpression: `5 + \"10\" - null + \"20\" + true - \"3\" - NaN`\n\nOperators are evaluated from left to right, respecting precedence. `+` and `-` have the same precedence, so they are evaluated left-to-right.\n\n1.  `5 + \"10\"`\n    *   `+` operator with a number and a string leads to string concatenation.\n    *   `5` is converted to `'5'`.\n    *   Result: `'510'` (string)\n\n2.  `'510' - null`\n    *   `-` operator with a string and `null` leads to numeric conversion.\n    *   `'510'` is converted to `510`.\n    *   `null` is converted to `0`.\n    *   Result: `510 - 0 = 510` (number)\n\n3.  `510 + \"20\"`\n    *   `+` operator with a number and a string leads to string concatenation.\n    *   `510` is converted to `'510'`.\n    *   Result: `'51020'` (string)\n\n4.  `'51020' + true`\n    *   `+` operator with a string and a boolean leads to string concatenation.\n    *   `true` is converted to `'true'`.\n    *   Result: `'51020true'` (string)\n\n5.  `'51020true' - \"3\"`\n    *   `-` operator with a string and a string leads to numeric conversion.\n    *   `'51020true'` cannot be converted entirely to a number, so it becomes `NaN`.\n    *   `\"3\"` is converted to `3`.\n    *   Result: `NaN - 3 = NaN` (number)\n\n6.  `NaN - NaN`\n    *   `NaN` minus `NaN` always results in `NaN`.\n    *   Result: `NaN` (number)\n\nPredicted Output: `NaN`\n*/\n\nconsole.log(\"Predicted Output:\", NaN);\n\n// Optional Refactored Code for a numeric sum:\nconsole.log(\"--- Refactored for numeric sum ---\");\n\n// To ensure numeric operations:\nconst num1 = 5;\nconst num2 = Number(\"10\"); // Explicit conversion\nconst num3 = Number(null); // Explicit conversion (0)\nconst num4 = Number(\"20\"); // Explicit conversion\nconst num5 = Number(true); // Explicit conversion (1)\nconst num6 = Number(\"3\");  // Explicit conversion\nconst num7 = NaN;\n\nconst numericResult = num1 + num2 - num3 + num4 + num5 - num6 - num7;\nconsole.log(\"Refactored Numeric Output:\", numericResult);\n// Breakdown of refactored numeric:\n// 5 + 10 - 0 + 20 + 1 - 3 - NaN\n// 15 - 0 + 20 + 1 - 3 - NaN\n// 15 + 20 + 1 - 3 - NaN\n// 35 + 1 - 3 - NaN\n// 36 - 3 - NaN\n// 33 - NaN = NaN (any arithmetic with NaN results in NaN)\n\n// If the intent was to sum all numbers and skip non-numbers / produce a numeric result even if some parts are invalid:\nfunction safeNumericSum(...args) {\n  let sum = 0;\n  for (const arg of args) {\n    const num = Number(arg);\n    if (!Number.isNaN(num)) {\n      sum += num;\n    }\n  }\n  return sum;\n}\n\n// Example of how you might want to interpret and sum the 'numbers' if non-numeric parts were ignored\nconsole.log(\"Safe Numeric Sum (ignoring non-numeric conversion parts):\");\nconsole.log(safeNumericSum(5, \"10\", null, \"20\", true, -\"3\", -NaN));\n// 5 + 10 + 0 + 20 + 1 + (-3) + NaN (NaN is skipped by safeNumericSum)\n// Result: 33\n",
          "testCases": [
            "Step-by-step analysis should correctly identify all intermediate values and type coercions.",
            "Final predicted output should be `NaN`.",
            "Refactored code (if implemented) should demonstrate explicit conversions and clearer intent.",
            "Refactored code should either yield the same result (if the original behavior is desired) or a clearly justified alternative (e.g., pure numeric sum)."
          ],
          "hints": [
            "Remember that the `+` operator behaves differently (concatenation vs. addition) based on its operands' types.",
            "Other arithmetic operators (`-`, `*`, `/`) generally force numeric conversion.",
            "Keep track of the type of the intermediate result at each step.",
            "Any arithmetic operation involving `NaN` will typically result in `NaN`.",
            "When refactoring, consider using `Number()` or `parseInt()`/`parseFloat()` explicitly to control type conversions."
          ],
          "tags": [
            "type-coercion",
            "operators",
            "edge-cases",
            "javascript-quirks",
            "debugging",
            "code-analysis"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 10,
          "interviewRelevance": 9,
          "learningPath": "expert",
          "relatedConcepts": [
            "operator-precedence",
            "implicit-conversion",
            "explicit-conversion",
            "NaN"
          ]
        },
        {
          "id": "task_safe_boolean_coercion",
          "title": "Create a `toBoolean` Utility Function",
          "description": "\nWrite a JavaScript utility function `toBoolean(value)` that converts any given value to a boolean, strictly following the standard JavaScript 'falsy' rules, but also offering an optional `strict` mode.\n\n**Requirements:**\n\n1.  **Standard Mode (default `strict = false`):**\n    *   Returns `true` for all 'truthy' values.\n    *   Returns `false` for all 'falsy' values (`false`, `0`, `-0`, `0n`, `''`, `null`, `undefined`, `NaN`).\n    *   This should behave identically to `Boolean(value)` or `!!value`.\n\n2.  **Strict Mode (`strict = true`):**\n    *   Returns `true` only if the `value` is the boolean `true`.\n    *   Returns `false` only if the `value` is the boolean `false`.\n    *   For any other value, it should return `null` (indicating neither a strict `true` nor a strict `false`).\n\nYour function signature should be `toBoolean(value, strict = false)`.\n",
          "difficulty": "medium",
          "startingCode": "function toBoolean(value, strict = false) {\n  if (strict) {\n    // TODO: Implement strict mode logic\n    if (value === true) {\n      return true;\n    } else if (value === false) {\n      return false;\n    } else {\n      return null;\n    }\n  } else {\n    // TODO: Implement standard mode logic (truthy/falsy)\n    return !!value;\n  }\n}\n\n// Example Usage (to be uncommented and tested):\n// console.log('--- Standard Mode ---');\n// console.log(`toBoolean(true): ${toBoolean(true)}`);       // Expected: true\n// console.log(`toBoolean(1): ${toBoolean(1)}`);         // Expected: true\n// console.log(`toBoolean('hello'): ${toBoolean('hello')}`);   // Expected: true\n// console.log(`toBoolean({}): ${toBoolean({})}`);         // Expected: true\n// console.log(`toBoolean([]): ${toBoolean([])}`);         // Expected: true\n\n// console.log(`toBoolean(false): ${toBoolean(false)}`);     // Expected: false\n// console.log(`toBoolean(0): ${toBoolean(0)}`);           // Expected: false\n// console.log(`toBoolean(''): ${toBoolean('')}`);         // Expected: false\n// console.log(`toBoolean(null): ${toBoolean(null)}`);       // Expected: false\n// console.log(`toBoolean(undefined): ${toBoolean(undefined)}`); // Expected: false\n// console.log(`toBoolean(NaN): ${toBoolean(NaN)}`);       // Expected: false\n\n// console.log('--- Strict Mode ---');\n// console.log(`toBoolean(true, true): ${toBoolean(true, true)}`);     // Expected: true\n// console.log(`toBoolean(false, true): ${toBoolean(false, true)}`);   // Expected: false\n// console.log(`toBoolean(1, true): ${toBoolean(1, true)}`);         // Expected: null\n// console.log(`toBoolean(0, true): ${toBoolean(0, true)}`);         // Expected: null\n// console.log(`toBoolean('hello', true): ${toBoolean('hello', true)}`); // Expected: null\n// console.log(`toBoolean(null, true): ${toBoolean(null, true)}`);     // Expected: null\n",
          "solutionCode": "function toBoolean(value, strict = false) {\n  if (strict) {\n    // Strict mode: Only true if value is strictly boolean true/false\n    if (value === true) {\n      return true;\n    } else if (value === false) {\n      return false;\n    } else {\n      return null; // For any other value, return null\n    }\n  } else {\n    // Standard mode: Use JavaScript's built-in truthiness/falsiness rules\n    return !!value;\n  }\n}\n\n// Test cases\nconsole.log('--- Standard Mode ---');\nconsole.log(`toBoolean(true): ${toBoolean(true)}`);       \nconsole.log(`toBoolean(1): ${toBoolean(1)}`);         \nconsole.log(`toBoolean('hello'): ${toBoolean('hello')}`);   \nconsole.log(`toBoolean({}): ${toBoolean({})}`);         \nconsole.log(`toBoolean([]): ${toBoolean([])}`);         \nconsole.log(`toBoolean(false): ${toBoolean(false)}`);     \nconsole.log(`toBoolean(0): ${toBoolean(0)}`);           \nconsole.log(`toBoolean(''): ${toBoolean('')}`);         \nconsole.log(`toBoolean(null): ${toBoolean(null)}`);       \nconsole.log(`toBoolean(undefined): ${toBoolean(undefined)}`); \nconsole.log(`toBoolean(NaN): ${toBoolean(NaN)}`);       \n\nconsole.log('--- Strict Mode ---');\nconsole.log(`toBoolean(true, true): ${toBoolean(true, true)}`);     \nconsole.log(`toBoolean(false, true): ${toBoolean(false, true)}`);   \nconsole.log(`toBoolean(1, true): ${toBoolean(1, true)}`);         \nconsole.log(`toBoolean(0, true): ${toBoolean(0, true)}`);           \nconsole.log(`toBoolean('hello', true): ${toBoolean('hello', true)}`); \nconsole.log(`toBoolean('', true): ${toBoolean('', true)}`);         \nconsole.log(`toBoolean(null, true): ${toBoolean(null, true)}`);     \nconsole.log(`toBoolean(undefined, true): ${toBoolean(undefined, true)}`); \nconsole.log(`toBoolean(NaN, true): ${toBoolean(NaN, true)}`);       \nconsole.log(`toBoolean([], true): ${toBoolean([], true)}`);         \nconsole.log(`toBoolean({}, true): ${toBoolean({}, true)}`);         \n",
          "testCases": [
            "Standard Mode: Test with `true`, `1`, `'abc'`, `{}`, `[]` (expected `true`).",
            "Standard Mode: Test with `false`, `0`, `''`, `null`, `undefined`, `NaN` (expected `false`).",
            "Strict Mode: Test with `true` (expected `true`).",
            "Strict Mode: Test with `false` (expected `false`).",
            "Strict Mode: Test with `1`, `0`, `'hello'`, `''`, `null`, `undefined`, `NaN`, `{}`, `[]` (expected `null` for all).",
            "Verify default parameter behavior (`toBoolean(value)` should behave as standard mode)."
          ],
          "hints": [
            "The `!!` operator is a concise way to convert any value to its boolean equivalent in standard JavaScript truthiness/falsiness.",
            "For strict mode, you'll need to use the strict equality operator (`===`) to check for the exact boolean values `true` or `false`."
          ],
          "tags": [
            "type-conversion",
            "boolean",
            "truthy-falsy",
            "utility-function",
            "edge-cases"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_javascript_type_conversion",
            "theory_javascript_edge_cases_coercion"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "strict-equality",
            "loose-equality",
            "conditional-logic"
          ]
        }
      ]
    }
  },
  {
    "id": "ab704af7-a36c-4098-9c2d-a7e4d43abdbc",
    "startLine": 500,
    "endLine": 599,
    "processedDate": "2025-06-17T03:02:31.787Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_type_coercion",
          "title": "JavaScript Type Coercion and Operator Behavior",
          "content": "Type coercion in JavaScript is the automatic or implicit conversion of values from one data type to another. This is a common source of unexpected behavior, especially when using loose equality (`==`) or arithmetic operators.\n\n## Implicit Type Coercion Rules\nJavaScript attempts to convert operands to a compatible type before performing an operation. This conversion is often guided by internal operations like `ToPrimitive`, `ToNumber`, `ToString`, and `ToBoolean`.\n\n### The `+` Operator\n- If one of the operands is a string, the `+` operator performs string concatenation. Both operands are converted to strings (via `ToString`).\n- Otherwise, both operands are converted to numbers (via `ToNumber`) and addition is performed.\n\n### Arithmetic Operators (`-`, `*`, `/`, `%`)\n- These operators always attempt to convert both operands to numbers (via `ToNumber`).\n- If a value cannot be meaningfully converted to a number, the result is `NaN` (Not-a-Number).\n\n### Loose Equality (`==`) vs Strict Equality (`===`)\n- The `==` (loose equality) operator performs type coercion before comparison. If the operands are of different types, JavaScript tries to convert one or both to a common type.\n- The `===` (strict equality) operator compares both the value and the type without any type coercion. This is generally preferred to avoid unexpected behavior.\n\n### Division by Zero\n- In JavaScript, dividing a number by zero does not throw an error but results in `Infinity` for positive numbers and `-Infinity` for negative numbers. Dividing `0` by `0` results in `NaN`.\n\n### Operations with `undefined` and `null`\n- `null` typically converts to `0` in numeric contexts (e.g., `null + 1` is `1`), but `undefined` typically converts to `NaN` (e.g., `undefined + 1` is `NaN`).\n- When comparing with `==`:\n    - `null == undefined` is `true`.\n    - `null` is only `==` to `null` or `undefined`.\n    - `undefined` is only `==` to `undefined` or `null`.\n\n### Logical Operators (`&&`, `||`)\n- Logical operators `&&` (AND) and `||` (OR) are \"short-circuiting\" and return the value of one of their operands, not necessarily a boolean `true` or `false`.\n    - `A && B`: Returns `A` if `A` is falsy, otherwise returns `B`.\n    - `A || B`: Returns `A` if `A` is truthy, otherwise returns `B`.\n\n### Object Property Access\n- When accessing object properties, numeric string keys and number keys are treated as equivalent (e.g., `obj['1']` is the same as `obj[1]`).\n",
          "examples": [
            {
              "id": "example_coercion_1",
              "title": "Complex Coercion Scenario",
              "code": "const result1 = [] + false - null + true;\n// Breakdown:\n// 1. [] + false  \n//    [] (ToPrimitive) -> \"\"\n//    false (ToString) -> \"false\"\n//    \"\" + \"false\" -> \"false\" (string concatenation)\n// 2. \"false\" - null\n//    \"false\" (ToNumber) -> NaN\n//    null (ToNumber) -> 0\n//    NaN - 0 -> NaN\n// 3. NaN + true\n//    NaN + true (ToNumber) -> NaN\n//    NaN + 1 -> NaN\nconsole.log(result1); // NaN",
              "explanation": "This example demonstrates a complex series of type coercions involving array to string, boolean to string/number, and null to number conversions. The presence of `NaN` in an arithmetic operation propagates `NaN` through subsequent operations.",
              "language": "javascript"
            },
            {
              "id": "example_coercion_2",
              "title": "Division by Zero and Undefined Operations",
              "code": "let result2 = 5 / 0; // Infinity\nlet negativeResult2 = -5 / 0; // -Infinity\nlet zeroByZero = 0 / 0; // NaN\nlet undefinedAddition = 5 + undefined; // NaN\nlet nullAddition = 5 + null; // 5\n\nconsole.log(result2, negativeResult2, zeroByZero, undefinedAddition, nullAddition);",
              "explanation": "This illustrates JavaScript's handling of division by zero, which yields `Infinity` or `-Infinity`, and `0/0` which yields `NaN`. It also shows the different numeric coercions of `undefined` (to `NaN`) and `null` (to `0`).",
              "language": "javascript"
            },
            {
              "id": "example_coercion_3",
              "title": "Loose vs. Strict Equality",
              "code": "console.log(0 == false);    // true (0 is loosely equal to false)\nconsole.log(0 === false);   // false (different types)\nconsole.log('1' == 1);      // true (string '1' converted to number 1)\nconsole.log('1' === 1);     // false (different types)\nconsole.log(null == undefined); // true\nconsole.log(null === undefined); // false\nconsole.log([] == 0);       // true ([] -> \"\" -> 0)\nconsole.log([] == \"\");     // true ([] -> \"\")",
              "explanation": "This example highlights the key differences between loose (`==`) and strict (`===`) equality. Loose equality often leads to unexpected results due to implicit type conversions, whereas strict equality avoids this by requiring both value and type to be identical.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_coercion_1",
            "question_coercion_2",
            "question_coercion_3",
            "question_coercion_4",
            "question_coercion_5",
            "question_coercion_6",
            "question_coercion_7",
            "question_coercion_8"
          ],
          "relatedTasks": [
            "task_coercion_quiz",
            "task_analyze_coercion_expression"
          ],
          "tags": [
            "type-coercion",
            "javascript-fundamentals",
            "operators",
            "equality",
            "NaN",
            "infinity"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "debugging",
            "writing_robust_code"
          ]
        },
        {
          "id": "theory_hoisting",
          "title": "Variable and Function Hoisting",
          "content": "Hoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their containing scope during the compilation phase, before code execution. This means you can use variables and call functions before they are declared in the code.\n\n## Hoisting Behavior by Declaration Type\n\n### `var` Declarations\n- `var` declarations are hoisted to the top of their function or global scope.\n- They are initialized with `undefined` during the hoisting phase. This means you can access a `var` variable before its declaration, but its value will be `undefined` until the line of its actual assignment is reached.\n\n### Function Declarations\n- Function declarations are fully hoisted. This means both the function name and its definition (the function body) are moved to the top of the scope.\n- You can call a function declared with `function` keyword before its definition in the code.\n\n### `let` and `const` Declarations\n- `let` and `const` declarations are also hoisted, but they are *not initialized* during the hoisting phase.\n- They are placed in a **Temporal Dead Zone (TDZ)** from the start of their block scope until their actual declaration line is executed.\n- Attempting to access a `let` or `const` variable within the TDZ results in a `ReferenceError`.\n- This behavior is designed to make `let` and `const` variables safer by preventing their use before declaration and initialization.\n\n## Hoisting Priority and Overwriting\n- In the same scope, function declarations have a higher hoisting priority than variable declarations (`var`).\n- If a function declaration and a `var` variable share the same name, the function declaration takes precedence and is hoisted first. However, a subsequent `var` assignment or any direct assignment will overwrite the function reference.\n\n",
          "examples": [
            {
              "id": "example_hoisting_1",
              "title": "Var Variable Hoisting",
              "code": "console.log(x); // Outputs: undefined\nvar x = 5;\nconsole.log(x); // Outputs: 5\n\n// Explanation: 'x' is declared and initialized to undefined at the top of the scope.\n// When 'var x = 5;' is encountered, 'x' is assigned the value 5.",
              "explanation": "This example shows that `var` variables are hoisted and initialized to `undefined`. Accessing `x` before its declaration results in `undefined`, not an error, because the declaration itself is moved to the top.",
              "language": "javascript"
            },
            {
              "id": "example_hoisting_2",
              "title": "Function Declaration Hoisting",
              "code": "console.log(foo()); // Outputs: \"bar\"\n\nfunction foo() {\n  return \"bar\";\n}\n\n// Explanation: The entire function declaration 'foo' is moved to the top.\n// So, 'foo()' can be called before its physical declaration.",
              "explanation": "Function declarations are fully hoisted, meaning their entire definition is available at the top of the scope. This allows them to be called before their actual position in the code.",
              "language": "javascript"
            },
            {
              "id": "example_hoisting_3",
              "title": "Let/Const and Temporal Dead Zone",
              "code": "// console.log(z); // Throws ReferenceError: Cannot access 'z' before initialization\nlet z = 5;\nconsole.log(z);\n\n// console.log(y); // Throws ReferenceError: Cannot access 'y' before initialization\nconst y = 10;\nconsole.log(y);",
              "explanation": "This demonstrates the Temporal Dead Zone (TDZ) for `let` and `const`. While hoisted, these variables are not initialized until their declaration line is executed. Any access before this point results in a `ReferenceError`.",
              "language": "javascript"
            },
            {
              "id": "example_hoisting_4",
              "title": "Hoisting Priority: Function vs. Var",
              "code": "(function() {\n  var x = 1;\n  function x() {};\n  console.log(x); // Outputs: 1\n})();\n\n(function() {\n  function y() {};\n  var y = 1;\n  console.log(y); // Outputs: 1\n})();\n\n// Explanation:\n// In both cases, the function declaration 'x' or 'y' is hoisted first.\n// Then, 'var x = 1;' or 'var y = 1;' assigns the value 1 to 'x'/'y', overwriting the function reference.",
              "explanation": "This complex example illustrates that function declarations are hoisted with higher priority than `var` variables. However, if a `var` declaration with an initializer or any assignment to the variable name occurs later, it will overwrite the function reference.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_hoisting_1",
            "question_hoisting_2",
            "question_hoisting_3",
            "question_hoisting_4",
            "question_hoisting_5",
            "question_hoisting_6",
            "question_hoisting_7"
          ],
          "relatedTasks": [
            "task_predict_hoisting_output",
            "task_refactor_for_tdz"
          ],
          "tags": [
            "hoisting",
            "javascript-scope",
            "var",
            "let",
            "const",
            "temporal-dead-zone",
            "function-declaration"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_variables",
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "understanding_execution_context",
            "debugging_javascript"
          ]
        },
        {
          "id": "theory_function_mechanics",
          "title": "Function Declarations, Expressions, and IIFEs",
          "content": "JavaScript provides several ways to define functions, each with distinct characteristics regarding hoisting, syntax, and `this` binding.\n\n## Function Declaration\n- Defined using the `function` keyword, followed by a name, parameters, and a function body.\n- Example: `function add(a, b) { return a + b; }`\n- **Hoisting**: Function declarations are fully hoisted. This means you can call them before they are physically defined in the code.\n\n## Function Expression\n- Defined as part of an expression, often assigned to a variable.\n- Can be named (named function expression) or anonymous.\n- Example: `const add = function(a, b) { return a + b; };`\n- **Hoisting**: Function expressions are *not* hoisted in the same way as declarations. Only the variable holding the function (e.g., `add` in `const add = ...`) is hoisted according to `var`, `let`, or `const` rules. The function definition itself is only available after the line where it is assigned is executed. Trying to call the function before this assignment will result in an error (`TypeError: ... is not a function` for `var` or `ReferenceError` for `let`/`const`).\n\n### Arrow Functions (Arrow Function Expression)\n- A concise syntax for writing function expressions, introduced in ES6.\n- Example: `const add = (a, b) => a + b;`\n- **No `this` binding**: Arrow functions do not have their own `this` context; they inherit `this` from the enclosing lexical scope.\n- **No `arguments` object**: They do not have their own `arguments` object.\n- **Cannot be used as constructors**: They cannot be called with `new`.\n- **Hoisting**: Like other function expressions, arrow functions are not fully hoisted. The variable they are assigned to is hoisted according to its declaration type (`var`, `let`, `const`).\n\n## IIFE (Immediately Invoked Function Expression)\n- An IIFE is a JavaScript function that runs as soon as it is defined. It's a design pattern that creates a private scope for variables and functions, preventing them from polluting the global namespace.\n- Syntax: `(function() { /* code */ })();` or `(() => { /* code */ })();`\n- **Purpose**: \n    - **Scoping**: Creates a private scope, preventing variable collisions with the global scope.\n    - **Data Privacy**: Encapsulates variables and functions, making them private to the IIFE.\n    - **Initialization**: Can be used to initialize complex modules or libraries.\n    - **Avoiding Global Pollution**: Especially useful in older JavaScript environments or when integrating multiple scripts.\n\n",
          "examples": [
            {
              "id": "example_function_1",
              "title": "Function Declaration vs. Expression Hoisting",
              "code": "// Function Declaration (hoisted)\nconsole.log(declareAdd(1, 2)); // Outputs: 3\nfunction declareAdd(a, b) {\n  return a + b;\n}\n\n// Function Expression (not fully hoisted)\n// console.log(expressAdd(3, 4)); // Throws ReferenceError for let/const or TypeError for var\nconst expressAdd = function(a, b) {\n  return a + b;\n};\nconsole.log(expressAdd(3, 4)); // Outputs: 7\n\n// Arrow Function Expression (not fully hoisted)\n// console.log(arrowAdd(5, 6)); // Throws ReferenceError\nconst arrowAdd = (a, b) => a + b;\nconsole.log(arrowAdd(5, 6)); // Outputs: 11",
              "explanation": "This example clearly shows the hoisting behavior differences. Function declarations can be called before their definition. Function expressions (including arrow functions) are assigned to a variable, and only the variable declaration is hoisted, not the function definition, leading to errors if called prematurely.",
              "language": "javascript"
            },
            {
              "id": "example_function_2",
              "title": "Basic IIFE Structure and Purpose",
              "code": "(function() {\n  var privateVar = \"I am private!\";\n  console.log(privateVar);\n})();\n\n// console.log(privateVar); // Throws ReferenceError: privateVar is not defined\n\n// Arrow IIFE\n(() => {\n  const message = \"Hello from Arrow IIFE!\";\n  console.log(message);\n})();",
              "explanation": "This demonstrates a basic IIFE, showcasing its primary use case: creating a private scope for variables (`privateVar` is not accessible outside the IIFE). This helps in avoiding global scope pollution and achieving modularity.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_function_mechanics_1",
            "question_function_mechanics_2",
            "question_function_mechanics_3",
            "question_function_mechanics_4",
            "question_function_mechanics_5",
            "question_function_mechanics_6"
          ],
          "relatedTasks": [
            "task_refactor_to_iife",
            "task_implement_utility_function"
          ],
          "tags": [
            "functions",
            "function-declaration",
            "function-expression",
            "arrow-functions",
            "IIFE",
            "scoping",
            "hoisting"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_variables",
            "javascript_scope",
            "javascript_es6"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "module_patterns",
            "javascript_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_coercion_1",
          "topic": "JavaScript Type Coercion",
          "level": "easy",
          "type": "mcq",
          "question": "What will be the result of `\"5\" - 3` in JavaScript?",
          "answer": "The result will be `2`. The `-` operator always attempts to convert its operands to numbers. The string `\"5\"` is successfully converted to the number `5`, and then `5 - 3` is performed.",
          "options": [
            "2",
            "\"53\"",
            "NaN",
            "TypeError"
          ],
          "analysisPoints": [
            "Understanding that the `-` operator implies numeric conversion.",
            "Distinguishing `+` (concatenation/addition) from other arithmetic operators."
          ],
          "keyConcepts": [
            "Type Coercion",
            "Arithmetic Operators",
            "ToNumber internal operation"
          ],
          "evaluationCriteria": [
            "Correct application of arithmetic coercion rules."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "javascript-fundamentals"
          ],
          "prerequisites": [
            "javascript_operators"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_coercion_2",
          "topic": "JavaScript Type Coercion",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of `[] + {}` in JavaScript?",
          "answer": "The result will be `\"[object Object]\"`. The `+` operator attempts to convert both operands to primitive values. `[]` becomes `\"\"` (empty string). `{}` becomes `\"[object Object]\"`. Then, string concatenation occurs: `\"\" + \"[object Object]\"` results in `\"[object Object]\"`.",
          "options": [
            "\"[object Object]\"",
            "NaN",
            "[object Object]",
            "\"\""
          ],
          "analysisPoints": [
            "Understanding the `ToPrimitive` conversion for arrays and objects.",
            "Knowing how the `+` operator behaves with strings."
          ],
          "keyConcepts": [
            "Type Coercion",
            "ToPrimitive",
            "ToString",
            "Object to String Conversion"
          ],
          "evaluationCriteria": [
            "Ability to trace complex coercion paths involving objects and arrays."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "javascript-fundamentals",
            "object-coercion"
          ],
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_coercion_3",
          "topic": "JavaScript Type Coercion",
          "level": "hard",
          "type": "open",
          "question": "Explain the step-by-step evaluation of the expression `[] + false - null + true;` to arrive at `NaN`. Detail the internal type coercion rules applied at each binary operation.",
          "answer": "Let's break down the expression `[] + false - null + true;`:\n\n1.  **`[] + false`**: The `+` operator is encountered. Since one operand (`[]`) might resolve to a string, string concatenation is prioritized. `[]` is first converted to its primitive value via `ToPrimitive`, which results in `\"\"` (empty string). `false` is converted to `\"false\"` via `ToString`. Result: `\"\" + \"false\"` which evaluates to `\"false\"`.\n\n2.  **`\"false\" - null`**: The `-` operator is encountered. This operator performs numeric operations, so both operands are converted to numbers via `ToNumber`. `\"false\"` converts to `NaN`. `null` converts to `0`. Result: `NaN - 0` which evaluates to `NaN`.\n\n3.  **`NaN + true`**: The `+` operator is encountered again. Since one operand (`NaN`) is already a number, numeric addition is prioritized. `true` is converted to `1` via `ToNumber`. Result: `NaN + 1` which evaluates to `NaN`.\n\nTherefore, the final result is `NaN`.",
          "analysisPoints": [
            "Understanding the `+` operator's dual behavior (concatenation vs. addition).",
            "Knowing how `ToPrimitive`, `ToString`, and `ToNumber` apply to different data types (`array`, `boolean`, `null`).",
            "Recognizing that `NaN` propagates through arithmetic operations."
          ],
          "keyConcepts": [
            "Type Coercion",
            "Operator Precedence",
            "ToPrimitive",
            "ToString",
            "ToNumber",
            "NaN Propagation"
          ],
          "evaluationCriteria": [
            "Accuracy in detailing each step of coercion.",
            "Correct identification of internal conversion processes.",
            "Logical flow of explanation."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "javascript-interview",
            "NaN"
          ],
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_coercion_4",
          "topic": "JavaScript Equality Operators",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `==` and `===` in JavaScript?",
          "answer": "`==` (loose equality) performs type coercion before comparing values, while `===` (strict equality) compares values and types without any coercion.",
          "analysisPoints": [
            "Distinguishing type coercion behavior.",
            "Understanding the implications for comparison reliability."
          ],
          "keyConcepts": [
            "Loose Equality",
            "Strict Equality",
            "Type Coercion"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition of each operator."
          ],
          "example": null,
          "tags": [
            "equality",
            "operators",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_operators"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_coercion_5",
          "topic": "JavaScript Operator Behavior",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following expressions will result in `NaN`?",
          "answer": "C) `\"hello\" * 2` is `NaN` because the string `\"hello\"` cannot be converted to a valid number for multiplication. A) `5 / 0` is `Infinity`. B) `true + true` is `2` (`true` converts to `1`). D) `!\"\"` is `true` (`\"\"` is falsy, `!` negates it).",
          "options": [
            "A) `5 / 0`",
            "B) `true + true`",
            "C) `\"hello\" * 2`",
            "D) `!\"\"`"
          ],
          "analysisPoints": [
            "Understanding numeric coercion for multiplication.",
            "Knowing results of division by zero.",
            "Recalling boolean to number coercion for addition.",
            "Understanding logical NOT operator with truthy/falsy values."
          ],
          "keyConcepts": [
            "NaN",
            "Infinity",
            "Type Coercion",
            "Arithmetic Operators",
            "Boolean Coercion"
          ],
          "evaluationCriteria": [
            "Ability to predict outcomes of various operator applications."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "NaN"
          ],
          "prerequisites": [
            "javascript_operators",
            "javascript_datatypes"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_coercion_6",
          "topic": "JavaScript Operator Behavior",
          "level": "medium",
          "type": "open",
          "question": "In JavaScript, `5 / 0` results in `Infinity`, not an error. What are the implications of this behavior for frontend development, and how might you handle it to prevent unexpected application states?",
          "answer": "Implications of `5 / 0` resulting in `Infinity`:\n1.  **Unexpected Display**: Displaying `Infinity` directly to users can be confusing or misleading, especially in calculations (e.g., a 'price per item' suddenly becoming 'Infinity').\n2.  **Further Calculations**: `Infinity` is a valid number, so it can participate in further arithmetic operations, potentially propagating `Infinity` or `NaN` through the application's data flow, leading to incorrect results.\n3.  **Validation**: If not explicitly checked, `Infinity` might pass numeric validation checks that only look for `NaN` or non-numeric types.\n\nHandling strategies:\n1.  **Input Validation**: Before performing division, validate the denominator. If it's `0`, either prevent the calculation, show an error message, or assign a default/fallback value.\n    ```javascript\n    function safeDivide(numerator, denominator) {\n      if (denominator === 0) {\n        console.warn(\"Attempted division by zero.\");\n        return 0; // Or throw an error, or return null/undefined\n      }\n      return numerator / denominator;\n    }\n    ```\n2.  **Output Formatting/Conditional Rendering**: Check the result of division before displaying it. If it's `Infinity` or `NaN`, display a user-friendly message like 'N/A' or 'Calculation Error'.\n    ```javascript\n    const result = value1 / value2;\n    if (result === Infinity || result === -Infinity || isNaN(result)) {\n      document.getElementById('output').textContent = 'Cannot calculate';\n    } else {\n      document.getElementById('output').textContent = result;\n    }\n    ```\n3.  **Error Boundaries/Fallbacks**: In frameworks like React, error boundaries can catch such calculation errors in components and display a fallback UI.\n4.  **Backend Validation**: For critical calculations, perform validation on the backend as well, as frontend validation can be bypassed.",
          "analysisPoints": [
            "Understanding the specific numerical behavior of JavaScript.",
            "Identifying practical problems arising from this behavior in UI/UX.",
            "Proposing concrete, actionable solutions for prevention and handling."
          ],
          "keyConcepts": [
            "Infinity",
            "NaN",
            "Error Handling",
            "Input Validation",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Depth of understanding of `Infinity`'s implications.",
            "Practicality and completeness of proposed solutions.",
            "Awareness of frontend best practices for data display and validation."
          ],
          "example": null,
          "tags": [
            "javascript-gotchas",
            "frontend-development",
            "error-handling",
            "NaN",
            "infinity"
          ],
          "prerequisites": [
            "javascript_operators",
            "javascript_error_handling"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_coercion_7",
          "topic": "JavaScript Logical Operators",
          "level": "medium",
          "type": "mcq",
          "question": "What is the value of `let result = 0 || \"hello\" && null;`?",
          "answer": "B) `null`\n\nExplanation:\n1.  `\"hello\" && null`: The `&&` operator evaluates from left to right. `\"hello\"` is truthy, so it proceeds to `null`. `null` is falsy, so `&&` returns `null`. The expression becomes `0 || null`.\n2.  `0 || null`: The `||` operator evaluates from left to right. `0` is falsy, so it proceeds to `null`. `null` is also falsy, so `||` returns the last falsy value, which is `null`.",
          "options": [
            "A) `0`",
            "B) `null`",
            "C) `\"hello\"`",
            "D) `true`"
          ],
          "analysisPoints": [
            "Understanding operator precedence (`&&` before `||`).",
            "Knowing the short-circuiting behavior of `&&` and `||`.",
            "Identifying truthy and falsy values in JavaScript."
          ],
          "keyConcepts": [
            "Logical Operators",
            "Short-circuiting",
            "Truthy/Falsy Values",
            "Operator Precedence"
          ],
          "evaluationCriteria": [
            "Correctly applying operator precedence.",
            "Accurate prediction of short-circuiting behavior."
          ],
          "example": null,
          "tags": [
            "operators",
            "logical-operators",
            "truthy-falsy"
          ],
          "prerequisites": [
            "javascript_operators"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_coercion_8",
          "topic": "JavaScript Type Coercion",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `5 + undefined` evaluate to in JavaScript?",
          "answer": "`NaN` (Not a Number)",
          "analysisPoints": [
            "Recalling the numeric coercion behavior of `undefined`."
          ],
          "keyConcepts": [
            "NaN",
            "Type Coercion",
            "Undefined"
          ],
          "evaluationCriteria": [
            "Quick recall of fundamental coercion rules."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "NaN",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_datatypes"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoisting_1",
          "topic": "JavaScript Hoisting",
          "level": "easy",
          "type": "mcq",
          "question": "What will be printed to the console by the following code snippet?\n```javascript\nconsole.log(myVar);\nvar myVar = 10;\n```",
          "answer": "B) `undefined`\n\nExplanation: Due to hoisting, the declaration `var myVar` is moved to the top of its scope and initialized with `undefined`. The assignment `myVar = 10` happens only on the second line. Therefore, `console.log(myVar)` outputs `undefined`.",
          "options": [
            "A) `10`",
            "B) `undefined`",
            "C) `ReferenceError`",
            "D) `null`"
          ],
          "analysisPoints": [
            "Understanding `var` hoisting and its initialization behavior.",
            "Distinguishing between declaration and assignment in hoisted variables."
          ],
          "keyConcepts": [
            "Hoisting",
            "Var Keyword",
            "Undefined"
          ],
          "evaluationCriteria": [
            "Correct prediction of `var` hoisting outcome."
          ],
          "example": "\n```javascript\nconsole.log(myVar);\nvar myVar = 10;\n```",
          "tags": [
            "hoisting",
            "var",
            "javascript-fundamentals"
          ],
          "prerequisites": [
            "javascript_variables"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoisting_2",
          "topic": "JavaScript Hoisting",
          "level": "medium",
          "type": "mcq",
          "question": "What will be the output of the following code?\n```javascript\nconsole.log(foo());\n\nfunction foo() {\n  return 'Hello';\n}\n\nconsole.log(bar());\n\nvar bar = function() {\n  return 'World';\n};\n```",
          "answer": "C) `Hello` followed by a `TypeError`\n\nExplanation:\n1.  `console.log(foo());`: `foo` is a function declaration, which is fully hoisted. So, `foo()` executes successfully and returns `\"Hello\"`.\n2.  `console.log(bar());`: `bar` is a function expression assigned to a `var` variable. While `var bar` is hoisted and initialized to `undefined`, the function assignment happens later. When `bar()` is called before its assignment, `bar` is `undefined`, and `undefined()` results in a `TypeError` (attempting to call `undefined` as a function).",
          "options": [
            "A) `Hello` followed by `World`",
            "B) `ReferenceError` followed by `World`",
            "C) `Hello` followed by a `TypeError`",
            "D) `TypeError` followed by `TypeError`"
          ],
          "analysisPoints": [
            "Differentiating hoisting behavior of function declarations and function expressions.",
            "Understanding what happens when an `undefined` variable is called as a function."
          ],
          "keyConcepts": [
            "Hoisting",
            "Function Declaration",
            "Function Expression",
            "TypeError",
            "Var Hoisting"
          ],
          "evaluationCriteria": [
            "Correctly identifying the hoisting mechanism for different function types.",
            "Predicting runtime errors based on hoisting."
          ],
          "example": "\n```javascript\nconsole.log(foo());\n\nfunction foo() {\n  return 'Hello';\n}\n\nconsole.log(bar());\n\nvar bar = function() {\n  return 'World';\n};\n```",
          "tags": [
            "hoisting",
            "function-declaration",
            "function-expression",
            "TypeError"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_variables"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoisting_3",
          "topic": "JavaScript Hoisting and TDZ",
          "level": "medium",
          "type": "mcq",
          "question": "What happens when you try to access a `let` variable before its declaration in the same block scope?",
          "answer": "B) It throws a `ReferenceError`.",
          "options": [
            "A) It returns `undefined`.",
            "B) It throws a `ReferenceError`.",
            "C) It returns `null`.",
            "D) The code executes normally if assigned later."
          ],
          "analysisPoints": [
            "Understanding the Temporal Dead Zone (TDZ) concept.",
            "Distinguishing `let`/`const` hoisting from `var` hoisting."
          ],
          "keyConcepts": [
            "Temporal Dead Zone (TDZ)",
            "Let Keyword",
            "Const Keyword",
            "ReferenceError",
            "Hoisting"
          ],
          "evaluationCriteria": [
            "Correctly identifying the error associated with TDZ."
          ],
          "example": "\n```javascript\n// console.log(myLetVar); // This line would throw a ReferenceError\nlet myLetVar = 'value';\n```",
          "tags": [
            "hoisting",
            "let",
            "const",
            "temporal-dead-zone"
          ],
          "prerequisites": [
            "javascript_variables",
            "javascript_es6"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoisting_4",
          "topic": "JavaScript Hoisting Priority",
          "level": "hard",
          "type": "open",
          "question": "Consider the following code. Explain in detail the output and why, focusing on hoisting priority and variable assignment.\n```javascript\n(function() {\n  console.log(funcVar);\n  var funcVar = 1;\n  function funcVar() {};\n  console.log(funcVar);\n})();\n```",
          "answer": "Let's analyze the execution within the IIFE:\n\n1.  **Hoisting Phase**: During compilation, JavaScript processes declarations.\n    *   The `function funcVar() {};` declaration is hoisted to the top of the IIFE's scope. This means `funcVar` is initially a function.\n    *   The `var funcVar = 1;` declaration is also hoisted. Since `function` declarations have higher priority, the `var` declaration does not *overwrite* the function declaration at this stage. However, the `var` declaration means that `funcVar` is now also identified as a variable within the scope, and will participate in variable assignments.\n\n    Conceptually, the code becomes:\n    ```javascript\n    (function() {\n      function funcVar() {}; // Hoisted first\n      var funcVar;          // Hoisted second, but does not overwrite the function yet\n\n      console.log(funcVar); // Line 1 in original code\n      funcVar = 1;          // Assignment part of 'var funcVar = 1;'\n      // The function funcVar() {}; is effectively ignored because funcVar is already declared\n      // as a function and then reassigned below.\n      console.log(funcVar); // Line 2 in original code\n    })();\n    ```\n\n2.  **Execution Phase**:\n    *   **`console.log(funcVar);` (first line)**: At this point, `funcVar` refers to the hoisted function `function funcVar() {}`. So, the console will output the *function definition itself*.\n        Output: `ƒ funcVar() {}` (or the full function code representation).\n\n    *   **`var funcVar = 1;`**: This line executes. The `var` declaration part has already been processed by hoisting, but the assignment `funcVar = 1` occurs now. This assignment *overwrites* the `funcVar` identifier, changing its value from the function to the number `1`.\n\n    *   **`function funcVar() {};`**: This line is effectively ignored during execution because `funcVar` has already been declared (and potentially assigned) earlier in the scope. It doesn't re-declare or re-assign `funcVar`.\n\n    *   **`console.log(funcVar);` (second line)**: Now, `funcVar` holds the value `1` because of the previous assignment. So, the console will output `1`.\n\n**Final Output:**\n```\nƒ funcVar() {}\n1\n```",
          "analysisPoints": [
            "Detailed understanding of the two-phase (hoisting/execution) process.",
            "Accurate application of hoisting priority rules (function declarations over `var` declarations).",
            "Understanding how assignments overwrite hoisted declarations during execution.",
            "Ability to trace variable values through scope and time."
          ],
          "keyConcepts": [
            "Hoisting Priority",
            "Function Declaration",
            "Var Keyword",
            "Scope",
            "Assignment",
            "Execution Context"
          ],
          "evaluationCriteria": [
            "Precision in explaining hoisting mechanisms.",
            "Correctly identifying the value of `funcVar` at each `console.log`.",
            "Clarity of explanation regarding function vs. variable declarations."
          ],
          "example": null,
          "tags": [
            "hoisting",
            "var",
            "function-declaration",
            "scope",
            "javascript-interview"
          ],
          "prerequisites": [
            "javascript_scope",
            "javascript_variables",
            "javascript_functions"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoisting_5",
          "topic": "JavaScript Hoisting",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the Temporal Dead Zone (TDZ) in JavaScript?",
          "answer": "The Temporal Dead Zone (TDZ) is the period of time between the start of a `let` or `const` variable's block scope and the actual declaration line. During this period, the variable cannot be accessed, or it will throw a `ReferenceError`.",
          "analysisPoints": [
            "Defining TDZ accurately.",
            "Associating TDZ with `let` and `const`."
          ],
          "keyConcepts": [
            "Temporal Dead Zone",
            "Let Keyword",
            "Const Keyword",
            "ReferenceError"
          ],
          "evaluationCriteria": [
            "Concise and correct definition."
          ],
          "example": null,
          "tags": [
            "hoisting",
            "TDZ",
            "let",
            "const",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_es6"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoisting_6",
          "topic": "JavaScript Hoisting",
          "level": "medium",
          "type": "code",
          "question": "Given the following code, what will be the output? Explain your reasoning.",
          "answer": "```javascript\nfunction greet() {\n  console.log(message);\n  let message = \"Hello\";\n}\n\ngreet(); // Output: ReferenceError: Cannot access 'message' before initialization\n```\n\n**Explanation:**\nInside the `greet` function, `message` is declared with `let`. While `let` variables are hoisted to the top of their block scope, they are placed in the Temporal Dead Zone (TDZ). This means they are not initialized until their declaration line is executed. Attempting to access `message` on the `console.log(message)` line, before `let message = \"Hello\";` is executed, results in a `ReferenceError` because `message` is in its TDZ.",
          "options": [],
          "analysisPoints": [
            "Understanding lexical scoping for `let`.",
            "Applying the TDZ concept within a function scope.",
            "Correctly identifying the type of error (`ReferenceError`)."
          ],
          "keyConcepts": [
            "Hoisting",
            "Let Keyword",
            "Temporal Dead Zone",
            "Function Scope",
            "ReferenceError"
          ],
          "evaluationCriteria": [
            "Correctly predicting the error.",
            "Providing a clear, concise, and accurate explanation based on TDZ.",
            "Demonstrating knowledge of `let`'s hoisting behavior."
          ],
          "example": "\n```javascript\nfunction greet() {\n  console.log(message);\n  let message = \"Hello\";\n}\n\ngreet();\n```",
          "tags": [
            "hoisting",
            "let",
            "TDZ",
            "scope",
            "ReferenceError"
          ],
          "prerequisites": [
            "javascript_scope",
            "javascript_es6"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoisting_7",
          "topic": "JavaScript Hoisting",
          "level": "hard",
          "type": "open",
          "question": "Discuss the practical implications of JavaScript hoisting for code organization and debugging. Provide examples where understanding hoisting is critical.",
          "answer": "Understanding hoisting is critical for writing robust and debuggable JavaScript code:\n\n**Practical Implications for Code Organization:**\n1.  **`var` - Source of Confusion & Bugs**: Because `var` variables are hoisted and initialized to `undefined`, developers might accidentally use them before their intended assignment, leading to `undefined` values instead of a `ReferenceError`. This makes debugging harder as the error isn't immediate.\n    *   *Example*: Calculating `tax` using `rate` before `rate` is assigned can lead to `NaN` or incorrect results that are hard to trace.\n    ```javascript\n    function calculateTotal(price) {\n      console.log(tax); // undefined, but no error\n      // ... some complex logic ...\n      var tax = price * rate; // 'rate' is also undefined if not declared/assigned\n      var rate = 0.05; // Declared here, but tax was calculated before this assignment\n      return price + tax;\n    }\n    ```\n2.  **`let`/`const` - Encouraging Safer Practices**: The Temporal Dead Zone (TDZ) for `let` and `const` provides early feedback (a `ReferenceError`) if a variable is accessed before its declaration. This forces developers to declare variables before use, leading to more predictable code flow and fewer accidental `undefined` values.\n    *   *Best Practice*: Always declare `let`/`const` variables at the top of their scope if possible, or right before their first use, to minimize the TDZ.\n3.  **Function Declarations - Flexibility and Readability (with caution)**: Full hoisting of function declarations means utility functions can be defined at the bottom of a file or after their calls, which can sometimes improve readability by putting the 'main' logic first. However, over-reliance can lead to 'spaghetti code' where function definitions are scattered, making it hard to find them.\n4.  **Function Expressions - Predictable Order**: Function expressions (especially arrow functions or named function expressions with `let`/`const`) enforce a more synchronous, top-to-bottom execution order, as the function is only callable after its assignment. This can lead to more predictable code flow.\n\n**Criticality for Debugging:**\n1.  **`undefined` vs `ReferenceError`**: When debugging, an `undefined` value from a `var` variable accessed before assignment is much harder to trace than a clear `ReferenceError` from a `let`/`const` in its TDZ. The `ReferenceError` immediately points to the declaration issue.\n2.  **Scope and Closure Interactions**: Hoisting can interact subtly with closures. If a `var` variable is unexpectedly hoisted out of an inner loop, it might lead to closure bugs where all closures capture the *final* value of the variable, not the value at each iteration.\n    *   *Example*: Common loop problem with `var`:\n    ```javascript\n    for (var i = 0; i < 3; i++) {\n      setTimeout(function() {\n        console.log(i); // Outputs 3, 3, 3 (not 0, 1, 2) due to 'i' being function-scoped and hoisted\n      }, 100);\n    }\n    ```\n    Using `let` fixes this: `for (let i = 0; i < 3; i++)` because `let` creates a new `i` for each loop iteration.\n\nIn summary, understanding hoisting prevents `undefined` surprises, helps debug `ReferenceError`s efficiently, and guides choices between `var`, `let`, `const`, and function types for clearer, more maintainable code.",
          "analysisPoints": [
            "Comprehensive discussion of `var`, `let`, `const` and function hoisting implications.",
            "Specific examples illustrating problematic scenarios and how hoisting explains them.",
            "Focus on debugging challenges and how `let`/`const` mitigate them.",
            "Connecting theoretical concepts to practical code organization principles."
          ],
          "keyConcepts": [
            "Hoisting",
            "Var",
            "Let",
            "Const",
            "Temporal Dead Zone",
            "Debugging",
            "Code Organization",
            "Scope",
            "Closures"
          ],
          "evaluationCriteria": [
            "Depth of analysis on practical implications.",
            "Quality and relevance of provided code examples.",
            "Ability to articulate the pros and cons of different declaration types concerning hoisting.",
            "Clarity and structure of the argument."
          ],
          "example": null,
          "tags": [
            "hoisting",
            "best-practices",
            "debugging",
            "javascript-interview",
            "var-let-const"
          ],
          "prerequisites": [
            "javascript_scope",
            "javascript_closures"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_function_mechanics_1",
          "topic": "Function Types",
          "level": "easy",
          "type": "mcq",
          "question": "Which type of function can be called before its definition in the code?",
          "answer": "A) Function Declaration",
          "options": [
            "A) Function Declaration",
            "B) Function Expression",
            "C) Arrow Function",
            "D) IIFE"
          ],
          "analysisPoints": [
            "Understanding the hoisting behavior specific to function declarations."
          ],
          "keyConcepts": [
            "Hoisting",
            "Function Declaration",
            "Function Expression"
          ],
          "evaluationCriteria": [
            "Correctly identifying the function type with full hoisting."
          ],
          "example": null,
          "tags": [
            "functions",
            "hoisting",
            "function-declaration"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_hoisting"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_function_mechanics_2",
          "topic": "Function Types",
          "level": "medium",
          "type": "open",
          "question": "Contrast Function Declarations and Function Expressions in JavaScript. Discuss their hoisting behavior and provide a scenario where choosing one over the other would be beneficial.",
          "answer": "## Function Declaration vs. Function Expression\n\n**Function Declaration:**\n-   **Syntax**: `function functionName(parameters) { /* code */ }`\n-   **Hoisting**: Fully hoisted. Both the function name and its definition are moved to the top of the enclosing scope. This means you can call a function declaration before its definition in the code.\n-   **Named**: Always named.\n-   **Example**: `function greet() { console.log('Hello'); }`\n\n**Function Expression:**\n-   **Syntax**: `const functionName = function(parameters) { /* code */ };` (can also be anonymous or named: `const functionName = function innerName() {}`) or `const functionName = (parameters) => { /* code */ };` (Arrow Function)\n-   **Hoisting**: Not fully hoisted. Only the variable (e.g., `functionName` if declared with `var`, `let`, or `const`) is hoisted. The function's *definition* itself is only available after the line where it is assigned is executed. If declared with `var`, calling it before assignment results in `TypeError: ... is not a function`. If with `let`/`const`, it's a `ReferenceError` (TDZ).\n-   **Named/Anonymous**: Can be anonymous or named (named function expression).\n-   **Example**: `const greet = function() { console.log('Hello'); };` or `const greet = () => console.log('Hello');`\n\n## Scenario for Choosing One Over the Other:\n\n**Benefit of Function Declaration (when readability favors 'main logic first'):**\nConsider a script where you want to immediately show the main application flow, and helper functions are detailed later in the file. Function declarations allow you to call these helper functions at the top of the file even if their definitions are at the bottom.\n```javascript\n// Main application flow\ninitApp(); // Works because initApp and its dependencies are function declarations\n\nfunction initApp() {\n  setupUI();\n  loadData();\n}\n\n// Helper functions (defined later but still hoisted and callable)\nfunction setupUI() {\n  console.log('UI ready');\n}\n\nfunction loadData() {\n  console.log('Data loaded');\n}\n```\n\n**Benefit of Function Expression (for clear execution order and encapsulation):**\nWhen you need to ensure a function is not accessible before a certain point in the code, or when you are assigning functions conditionally or passing them as arguments. For example, using a function expression within an IIFE to create a private scope, or assigning a function dynamically based on a condition.\n```javascript\n// Function expression, not callable here yet (TDZ)\n// greetUser(); // ReferenceError\n\nlet greetUser;\nconst hour = new Date().getHours();\n\nif (hour < 12) {\n  greetUser = function() { // Function expression\n    console.log('Good morning!');\n  };\n} else {\n  greetUser = () => { // Arrow function expression\n    console.log('Good afternoon!');\n  };\n}\n\ngreetUser(); // Callable after assignment, based on condition\n```\n\nIn general, modern JavaScript development often favors function expressions (especially arrow functions with `const`) for their predictable behavior (`let`/`const` TDZ makes it clear when a function is ready) and suitability for functional programming paradigms. Function declarations remain useful for top-level, general-purpose functions.",
          "analysisPoints": [
            "Clear definition of both function types.",
            "Accurate comparison of their hoisting behavior and implications (TDZ, TypeError).",
            "Providing distinct, practical scenarios where each type is advantageous.",
            "Discussing modern preferences and why."
          ],
          "keyConcepts": [
            "Function Declaration",
            "Function Expression",
            "Arrow Function",
            "Hoisting",
            "Temporal Dead Zone",
            "Scope",
            "Readability",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Thoroughness of the comparison.",
            "Relevance and clarity of example scenarios.",
            "Understanding of practical implications for code structure.",
            "Demonstration of nuanced understanding of JS function mechanics."
          ],
          "example": null,
          "tags": [
            "functions",
            "hoisting",
            "function-declaration",
            "function-expression",
            "arrow-functions",
            "javascript-interview"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_hoisting",
            "javascript_scope"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_function_mechanics_3",
          "topic": "IIFE (Immediately Invoked Function Expression)",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary benefit of using an IIFE (Immediately Invoked Function Expression) in JavaScript?",
          "answer": "B) To create a private scope for variables and functions, preventing global pollution.",
          "options": [
            "A) To ensure the function is hoisted to the top of the global scope.",
            "B) To create a private scope for variables and functions, preventing global pollution.",
            "C) To allow `this` binding to work correctly in all contexts.",
            "D) To define a function that can be reused multiple times without re-declaration."
          ],
          "analysisPoints": [
            "Identifying the core purpose of IIFEs.",
            "Distinguishing IIFE benefits from other function-related concepts."
          ],
          "keyConcepts": [
            "IIFE",
            "Scope",
            "Global Pollution",
            "Data Privacy"
          ],
          "evaluationCriteria": [
            "Correctly identifying the main advantage of IIFEs."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "scoping",
            "javascript-patterns"
          ],
          "prerequisites": [
            "javascript_scope"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_function_mechanics_4",
          "topic": "Arrow Functions",
          "level": "medium",
          "type": "flashcard",
          "question": "What are two key differences between arrow functions and traditional function expressions regarding `this` and `arguments`?",
          "answer": "Arrow functions do not have their own `this` binding; they lexically inherit `this` from the enclosing scope. They also do not have their own `arguments` object.",
          "analysisPoints": [
            "Recalling the `this` binding difference.",
            "Remembering the absence of `arguments` object."
          ],
          "keyConcepts": [
            "Arrow Functions",
            "This Keyword",
            "Lexical Scoping",
            "Arguments Object"
          ],
          "evaluationCriteria": [
            "Concise and accurate recall of arrow function characteristics."
          ],
          "example": null,
          "tags": [
            "arrow-functions",
            "this",
            "arguments",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_this_keyword",
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_function_mechanics_5",
          "topic": "IIFE (Immediately Invoked Function Expression)",
          "level": "hard",
          "type": "code",
          "question": "Refactor the following code to use an IIFE to encapsulate `secretMessage` and `displayMessage` function, so they are not accessible globally. Then, explain why this pattern is useful for modularity.",
          "answer": "```javascript\n// Original code (global variables and function)\n// var secretMessage = \"This is a secret!\";\n// function displayMessage() {\n//   console.log(secretMessage);\n// }\n// displayMessage();\n\n// Refactored with IIFE\n(function() {\n  var secretMessage = \"This is a secret encapsulated by IIFE!\";\n  function displayMessage() {\n    console.log(secretMessage);\n  }\n\n  // To expose functionality, you might return it, e.g., if it needs to be called later.\n  // For this specific case, it runs immediately and is then gone.\n  displayMessage(); // Invoked immediately within its private scope\n})();\n\n// console.log(secretMessage); // ReferenceError: secretMessage is not defined\n// displayMessage();         // ReferenceError: displayMessage is not defined\n\n// Explanation:\n// The IIFE creates a new function execution context (scope). All variables\n// (like secretMessage) and functions (like displayMessage) declared inside\n// this IIFE are private to it. They are not added to the global scope.\n// This prevents naming collisions and keeps the global namespace clean, which\n// is crucial for modularity, especially in larger applications or when integrating\n// third-party scripts. It ensures that internal logic does not interfere with other\n// parts of the application or with other libraries. While modern JavaScript\n// uses ES Modules for this, IIFEs were a foundational pattern before modules\n// were widely adopted and are still seen in older codebases or for quick, isolated scripts.\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implementing the IIFE pattern.",
            "Demonstrating that variables/functions are no longer global.",
            "Articulating the benefits of IIFE for modularity and global scope protection.",
            "Comparing with modern module systems (optional but good)."
          ],
          "keyConcepts": [
            "IIFE",
            "Scope",
            "Modularity",
            "Global Scope",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Functional correctness of the refactored code.",
            "Clear explanation of modularity benefits.",
            "Understanding of scope isolation provided by IIFEs."
          ],
          "example": "\n```typescript\n// Original code (global variables and function)\nvar secretMessage = \"This is a secret!\";\nfunction displayMessage() {\n  console.log(secretMessage);\n}\ndisplayMessage();\n```",
          "tags": [
            "IIFE",
            "scoping",
            "modularity",
            "javascript-patterns"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_function_mechanics_6",
          "topic": "Function Mechanics",
          "level": "medium",
          "type": "flashcard",
          "question": "Can an arrow function be used as a constructor with the `new` keyword? Why or why not?",
          "answer": "No, an arrow function cannot be used as a constructor with the `new` keyword. Arrow functions do not have their own `this` binding or a `prototype` property, which are essential for constructor functions to create new instances and establish prototypal inheritance.",
          "analysisPoints": [
            "Recalling the limitations of arrow functions.",
            "Understanding the requirements for constructor functions."
          ],
          "keyConcepts": [
            "Arrow Functions",
            "Constructor Functions",
            "New Keyword",
            "This Keyword",
            "Prototype"
          ],
          "evaluationCriteria": [
            "Correctly stating the limitation.",
            "Providing the underlying technical reason."
          ],
          "example": null,
          "tags": [
            "arrow-functions",
            "constructor",
            "this",
            "prototype",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_oop",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_coercion_quiz",
          "title": "Predict JavaScript Type Coercion Outcomes",
          "description": "\nYou are given a series of JavaScript expressions involving various operators and data types. Your task is to predict the exact output for each expression, explaining the step-by-step type coercion process that leads to your answer. This task tests your understanding of JavaScript's implicit type conversion rules and operator precedence.\n\n**Requirements:**\n1.  For each `console.log` statement, write down the predicted output.\n2.  For expressions involving coercion, provide a brief explanation of how each step of coercion (e.g., `ToPrimitive`, `ToNumber`, `ToString`) occurs.\n3.  Identify any cases resulting in `NaN`, `Infinity`, `TypeError`, or `ReferenceError` and explain why.\n",
          "difficulty": "medium",
          "startingCode": "console.log(1 + '2' + 3);\nconsole.log('5' - true);\nconsole.log(true == '1');\nconsole.log(null == 0);\nconsole.log(null > 0);\nconsole.log(null >= 0);\nconsole.log(1 / 'abc');\nconsole.log(Boolean(''));\nconsole.log(!!'hello');\nconsole.log(5 && 0);\nconsole.log([] == ![]);\n",
          "solutionCode": "// Predicted Outputs and Explanations:\n\n// 1. console.log(1 + '2' + 3);\n//    1 + '2' -> '12' (number to string, then concatenation)\n//    '12' + 3 -> '123' (number to string, then concatenation)\n//    Output: \"123\"\n\n// 2. console.log('5' - true);\n//    '5' (ToNumber) -> 5\n//    true (ToNumber) -> 1\n//    5 - 1 -> 4\n//    Output: 4\n\n// 3. console.log(true == '1');\n//    true (ToNumber) -> 1\n//    '1' (ToNumber) -> 1\n//    1 == 1 -> true\n//    Output: true\n\n// 4. console.log(null == 0);\n//    Special rule: null only loosely equals null or undefined. It does not coerce to 0 for ==.\n//    Output: false\n\n// 5. console.log(null > 0);\n//    null (ToNumber) -> 0\n//    0 > 0 -> false\n//    Output: false\n\n// 6. console.log(null >= 0);\n//    null (ToNumber) -> 0\n//    0 >= 0 -> true\n//    Output: true\n\n// 7. console.log(1 / 'abc');\n//    'abc' (ToNumber) -> NaN\n//    1 / NaN -> NaN\n//    Output: NaN\n\n// 8. console.log(Boolean(''));\n//    '' is a falsy value. Boolean('') converts it to false.\n//    Output: false\n\n// 9. console.log(!!'hello');\n//    'hello' is a truthy value. !'hello' -> false. !false -> true.\n//    Output: true\n\n// 10. console.log(5 && 0);\n//     5 is truthy, so && evaluates to the second operand.\n//     Output: 0\n\n// 11. console.log([] == ![]);\n//     ![]: [] is truthy, so ![] -> false.\n//     [] == false: [] (ToPrimitive) -> \"\". \"\" (ToNumber) -> 0.\n//     false (ToNumber) -> 0.\n//     0 == 0 -> true\n//     Output: true\n",
          "testCases": [
            "Expected output for `1 + '2' + 3` should be `\"123\"`.",
            "Expected output for `'5' - true` should be `4`.",
            "Expected output for `true == '1'` should be `true`.",
            "Expected output for `null == 0` should be `false`.",
            "Expected output for `null > 0` should be `false`.",
            "Expected output for `null >= 0` should be `true`.",
            "Expected output for `1 / 'abc'` should be `NaN`.",
            "Expected output for `Boolean('')` should be `false`.",
            "Expected output for `!!'hello'` should be `true`.",
            "Expected output for `5 && 0` should be `0`.",
            "Expected output for `[] == ![]` should be `true`."
          ],
          "hints": [
            "Remember the `+` operator's dual nature: string concatenation if any operand is a string, otherwise numeric addition.",
            "Other arithmetic operators (`-`, `*`, `/`) always try to convert operands to numbers.",
            "Pay close attention to the special rules for `null` and `undefined` in comparisons (`==` vs `===`) and arithmetic operations.",
            "Boolean coercion to numbers: `true` is `1`, `false` is `0`.",
            "How do empty arrays (`[]`) and empty objects (`{}`) convert to primitives and then to numbers/strings?",
            "Recall the short-circuiting behavior of logical `&&` and `||` operators."
          ],
          "tags": [
            "type-coercion",
            "operators",
            "javascript-fundamentals",
            "quiz"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_type_coercion"
          ]
        },
        {
          "id": "task_analyze_coercion_expression",
          "title": "Analyze and Correct a Coercion Bug",
          "description": "\nYou are debugging a frontend application where a user's input for a numeric quantity is causing incorrect calculations. The input is initially a string, and a developer tried to perform a calculation that resulted in `NaN`. Your task is to analyze the provided problematic code snippet, identify the source of `NaN` due to type coercion, and then correct it to perform the intended numeric calculation.\n\n**Problematic Code:**\n```javascript\nfunction calculateTotal(price, quantityInput) {\n  // price is a number, e.g., 10.50\n  // quantityInput is a string, e.g., \"2\"\n  // This line is causing issues:\n  const total = price + quantityInput;\n  console.log(`Calculated Total: ${total}`);\n  return total;\n}\n\n// Test cases:\ncalculateTotal(10.50, \"2\"); // Expected: 21.00, Actual: 10.502\ncalculateTotal(5, \"3\");   // Expected: 15, Actual: 53\n```\n\n**Requirements:**\n1.  Explain *why* `price + quantityInput` results in an incorrect value (e.g., `10.502` instead of `21.00`). Detail the type coercion occurring.\n2.  Modify the `calculateTotal` function to correctly perform numeric addition, ensuring `quantityInput` is treated as a number.\n3.  Ensure the corrected function passes the provided test cases.\n",
          "difficulty": "easy",
          "startingCode": "function calculateTotal(price, quantityInput) {\n  // price is a number, e.g., 10.50\n  // quantityInput is a string, e.g., \"2\"\n  // This line is causing issues:\n  const total = price + quantityInput;\n  console.log(`Calculated Total: ${total}`);\n  return total;\n}\n\n// Test cases:\ncalculateTotal(10.50, \"2\"); // Expected: 21.00, Actual: 10.502\ncalculateTotal(5, \"3\");   // Expected: 15, Actual: 53\n",
          "solutionCode": "function calculateTotal(price, quantityInput) {\n  // Explanation of the bug:\n  // The '+' operator in JavaScript performs string concatenation if one of the operands is a string.\n  // Here, 'price' is a number and 'quantityInput' is a string (\"2\").\n  // JavaScript coerces 'price' (10.50) to a string (\"10.50\") and then concatenates it with \"2\",\n  // resulting in \"10.502\", which is not the intended numeric sum.\n\n  // Correction: Explicitly convert quantityInput to a number.\n  // Options: Number(), parseInt(), parseFloat(), or unary plus (+)\n  const numericQuantity = Number(quantityInput); // Or +quantityInput; or parseFloat(quantityInput);\n\n  // Now perform the correct numeric addition\n  const total = price * numericQuantity; // Using multiplication for clarity on price * quantity\n                                        // If the intention was actually price + quantity, then it would be:\n                                        // const total = price + numericQuantity;\n\n  console.log(`Calculated Total: ${total}`);\n  return total;\n}\n\n// Test cases:\nconsole.log(\"Test 1:\");\ncalculateTotal(10.50, \"2\"); // Expected: 21.00\nconsole.log(\"Test 2:\");\ncalculateTotal(5, \"3\");   // Expected: 15\n\n// Bonus: Handle invalid quantity input\nfunction calculateTotalSafe(price, quantityInput) {\n  const numericQuantity = Number(quantityInput);\n  if (isNaN(numericQuantity)) {\n    console.error(\"Invalid quantity input: Not a number\");\n    return NaN; // Or throw an error, or return 0\n  }\n  const total = price * numericQuantity;\n  console.log(`Calculated Total Safe: ${total}`);\n  return total;\n}\n\nconsole.log(\"Test 3 (Safe):\");\ncalculateTotalSafe(10, \"abc\"); // Expected: NaN (or handled error)\nconsole.log(\"Test 4 (Safe):\");\ncalculateTotalSafe(7, \"0\");    // Expected: 0\n",
          "testCases": [
            "Calling `calculateTotal(10.50, \"2\")` should return `21` (or `21.00`).",
            "Calling `calculateTotal(5, \"3\")` should return `15`.",
            "Consider an edge case: `calculateTotal(10, \"0\")` should return `0`.",
            "Consider invalid input: `calculateTotal(10, \"abc\")` should ideally handle gracefully (e.g., return `NaN` or throw an error)."
          ],
          "hints": [
            "The `+` operator has a special behavior when one operand is a string.",
            "To ensure numeric addition, you must explicitly convert the string to a number.",
            "Common ways to convert a string to a number include `Number()`, `parseInt()`, `parseFloat()`, or the unary plus operator (`+str`).",
            "Think about what operation `price` and `quantity` should actually perform: addition or multiplication?"
          ],
          "tags": [
            "type-coercion",
            "debugging",
            "javascript-fundamentals",
            "numeric-conversion"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_type_coercion"
          ]
        },
        {
          "id": "task_predict_hoisting_output",
          "title": "Predict Hoisting Behavior Output",
          "description": "\nThis task presents several JavaScript code snippets involving `var`, `let`, `const`, and function declarations/expressions. Your goal is to predict the exact output of each `console.log` statement and explain your reasoning, specifically focusing on how hoisting, scope, and the Temporal Dead Zone (TDZ) affect the variables and functions.\n\n**Requirements:**\n1.  For each snippet, write down the predicted output for each `console.log` statement.\n2.  Explain *why* that output occurs, referencing hoisting rules, `var` initialization, `let`/`const` TDZ, and function hoisting behavior.\n3.  Identify any `ReferenceError` or `TypeError` and explain their cause.\n",
          "difficulty": "medium",
          "startingCode": "// Snippet 1\nconsole.log(a);\nvar a = 10;\n\n// Snippet 2\nconsole.log(b);\nlet b = 20;\n\n// Snippet 3\nfunction outer() {\n  console.log(c);\n  var c = 30;\n}\nouter();\n\n// Snippet 4\nfunction doSomething() {\n  console.log(myFunc());\n  function myFunc() {\n    return \"Hello from func declaration\";\n  }\n}\ndoSomething();\n\n// Snippet 5\nfunction doAnotherThing() {\n  console.log(myArrowFunc());\n  const myArrowFunc = () => \"Hello from arrow func\";\n}\ndoAnotherThing();\n\n// Snippet 6\n(function() {\n  console.log(x);\n  var x = 1;\n  function x() {};\n  console.log(x);\n})();\n",
          "solutionCode": "// Snippet 1\nconsole.log(a); // Output: undefined\nvar a = 10;\n// Explanation: 'var a' is hoisted to the top and initialized with undefined. The console.log runs before 'a' is assigned 10.\n\n// Snippet 2\n// console.log(b); // Output: ReferenceError: Cannot access 'b' before initialization\n// let b = 20;\n// Explanation: 'let b' is hoisted but placed in the Temporal Dead Zone (TDZ). Accessing it before its declaration line throws a ReferenceError.\n\n// Snippet 3\nfunction outer() {\n  console.log(c); // Output: undefined\n  var c = 30;\n}\nouter();\n// Explanation: 'var c' is hoisted to the top of the 'outer' function's scope and initialized with undefined. So, logging it before assignment yields undefined.\n\n// Snippet 4\nfunction doSomething() {\n  console.log(myFunc()); // Output: \"Hello from func declaration\"\n  function myFunc() {\n    return \"Hello from func declaration\";\n  }\n}\ndoSomething();\n// Explanation: Function declarations (myFunc) are fully hoisted, meaning their definition is available throughout their containing scope. Thus, myFunc() can be called before its definition.\n\n// Snippet 5\nfunction doAnotherThing() {\n  // console.log(myArrowFunc()); // Output: ReferenceError: Cannot access 'myArrowFunc' before initialization\n  const myArrowFunc = () => \"Hello from arrow func\";\n}\ndoAnotherThing();\n// Explanation: Arrow functions are function expressions. They are assigned to a variable (myArrowFunc in this case, declared with const). The 'const' variable is hoisted but is in the Temporal Dead Zone (TDZ). Accessing it before its declaration/initialization results in a ReferenceError.\n\n// Snippet 6\n(function() {\n  console.log(x); // Output: ƒ x() {}\n  var x = 1;\n  function x() {};\n  console.log(x); // Output: 1\n})();\n// Explanation:\n// During hoisting:\n// 1. function x() {} is hoisted first (higher priority).\n// 2. var x; is hoisted second, but does not overwrite the function declaration.\n// First console.log(x): 'x' refers to the hoisted function. So, the function definition is logged.\n// After var x = 1;: The assignment `x = 1` takes place, overwriting the function reference with the number 1.\n// Second console.log(x): 'x' now holds the value 1. So, 1 is logged.\n",
          "testCases": [
            "Snippet 1 should output `undefined`.",
            "Snippet 2 should throw `ReferenceError`.",
            "Snippet 3 should output `undefined`.",
            "Snippet 4 should output `\"Hello from func declaration\"`.",
            "Snippet 5 should throw `ReferenceError`.",
            "Snippet 6 should first output the function definition, then `1`."
          ],
          "hints": [
            "Remember that `var` variables are initialized to `undefined` upon hoisting, while `let` and `const` enter the Temporal Dead Zone (TDZ).",
            "Function *declarations* are fully hoisted, but function *expressions* are not.",
            "Pay attention to the order of declarations and assignments within the scope.",
            "When a `var` variable and a function declaration share the same name, which one takes precedence during hoisting?"
          ],
          "tags": [
            "hoisting",
            "var",
            "let",
            "const",
            "function-declaration",
            "function-expression",
            "temporal-dead-zone"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_variables",
            "javascript_functions",
            "javascript_scope",
            "javascript_es6"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_hoisting"
          ]
        },
        {
          "id": "task_refactor_for_tdz",
          "title": "Refactor Code to Avoid Temporal Dead Zone Issues",
          "description": "\nYou've inherited a JavaScript codebase with sections that occasionally throw `ReferenceError` due to improper use of `let` and `const`. Your task is to refactor the provided code snippets to eliminate these `ReferenceError`s by correctly handling the Temporal Dead Zone (TDZ).\n\n**Requirements:**\n1.  For each snippet, identify the line causing the `ReferenceError`.\n2.  Modify the code to ensure `let` and `const` variables are accessed only after their declaration, without changing the logical intent or introducing `var`.\n3.  Explain *why* your changes resolve the TDZ issue.\n\n**Snippet 1 (Function Scope):**\n```javascript\nfunction greetUser(name) {\n  console.log(`Hello, ${greeting}`);\n  let greeting = \"Good morning\";\n  console.log(`Hello, ${name}!`);\n}\ngreetUser(\"Alice\");\n```\n\n**Snippet 2 (Block Scope):**\n```javascript\nif (true) {\n  console.log(config);\n  const config = { api: 'v1' };\n  console.log(config.api);\n}\n```\n\n**Snippet 3 (Loop Scope - conceptual):**\n*(No code to fix, but explain how `let` addresses a common `var` loop issue which is related to scope/TDZ conceptual understanding)*\n\n```javascript\n// Consider this common problematic pattern with var (no fix needed for this snippet, just explain):\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}\n// Explain how 'let i' in the loop fixes this and why.\n```\n",
          "difficulty": "medium",
          "startingCode": "function greetUser(name) {\n  console.log(`Hello, ${greeting}`);\n  let greeting = \"Good morning\";\n  console.log(`Hello, ${name}!`);\n}\ngreetUser(\"Alice\");\n\nif (true) {\n  console.log(config);\n  const config = { api: 'v1' };\n  console.log(config.api);\n}\n\n// Consider this common problematic pattern with var (no fix needed for this snippet, just explain):\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}\n// Explain how 'let i' in the loop fixes this and why.\n",
          "solutionCode": "// Snippet 1 (Function Scope) - Solution\nfunction greetUser(name) {\n  let greeting = \"Good morning\"; // Moved declaration above usage\n  console.log(`Hello, ${greeting}`);\n  console.log(`Hello, ${name}!`);\n}\ngreetUser(\"Alice\");\n// Explanation: The 'let greeting' declaration was moved before its first usage in console.log. This ensures 'greeting' is out of its Temporal Dead Zone (TDZ) when accessed, preventing the ReferenceError.\n\n// Snippet 2 (Block Scope) - Solution\nif (true) {\n  const config = { api: 'v1' }; // Moved declaration above usage\n  console.log(config);\n  console.log(config.api);\n}\n// Explanation: Similar to Snippet 1, 'const config' was moved before the console.log. 'const' variables also have a TDZ, and accessing them before declaration results in a ReferenceError. Placing the declaration first resolves this.\n\n// Snippet 3 (Loop Scope - conceptual explanation)\n// Problematic code with var:\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}\n// Output: 3, 3, 3\n// Explanation of the problem: With 'var', 'i' is function-scoped (or global if outside a function). It's effectively one variable shared across all loop iterations. By the time setTimeout's callbacks execute (asynchronously, after the loop finishes), 'i' has already reached its final value of 3. All closures formed by the setTimeout callbacks close over the *same* 'i' variable, which is 3.\n\n// Solution with let:\n// for (let i = 0; i < 3; i++) {\n//   setTimeout(function() {\n//     console.log(i);\n//   }, 100);\n// }\n// Expected Output: 0, 1, 2\n// Explanation of the fix: 'let' creates a new lexical scope for each iteration of the loop. This means a *new* 'i' variable is created and initialized for each pass of the loop. Each setTimeout callback then captures the 'i' specific to its iteration, resolving the closure problem related to the shared variable. This behavior is related to the TDZ because it enforces block-scoping, making variables inaccessible outside their specific iteration's scope until declared within that iteration.\n",
          "testCases": [
            "Snippet 1 should execute without `ReferenceError` and print `Hello, Good morning` then `Hello, Alice!`.",
            "Snippet 2 should execute without `ReferenceError` and print the `config` object then `v1`.",
            "Conceptual explanation for Snippet 3 should correctly describe why `var` causes an issue and how `let` resolves it due to block scoping for each iteration."
          ],
          "hints": [
            "Remember that `let` and `const` variables are hoisted but are in a Temporal Dead Zone until their declaration line is executed.",
            "To resolve a `ReferenceError` caused by TDZ, simply move the declaration of the `let` or `const` variable *before* its first usage.",
            "Think about the difference between function scope (`var`) and block scope (`let`/`const`) when analyzing loops."
          ],
          "tags": [
            "hoisting",
            "let",
            "const",
            "temporal-dead-zone",
            "scope",
            "refactoring",
            "debugging"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_variables",
            "javascript_scope",
            "javascript_es6",
            "javascript_hoisting"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_hoisting"
          ]
        },
        {
          "id": "task_implement_utility_function",
          "title": "Implement a Secure Utility Function with IIFE or modern modules",
          "description": "\nDesign and implement a JavaScript utility module that provides a simple counter functionality. The module should allow incrementing the counter and retrieving its current value, but the internal counter variable itself should not be directly accessible from outside the module.\n\n**Requirements:**\n1.  Implement this functionality using an Immediately Invoked Function Expression (IIFE) for encapsulation.\n2.  Alternatively, demonstrate how you would achieve the same encapsulation using modern ES Modules syntax if the environment supports it (optional, but encouraged).\n3.  The module should expose a public API with `increment()` and `getValue()` methods.\n4.  Ensure the internal counter cannot be modified or accessed directly.\n\n",
          "difficulty": "medium",
          "startingCode": "/*\nImplement a counter utility module here.\nIt should expose:\n- increment(): increments the internal counter\n- getValue(): returns the current counter value\n\nThe internal counter should be private.\n*/\n\n// Example usage:\n// const counter = YourCounterModule();\n// counter.increment();\n// console.log(counter.getValue()); // Should log 1\n// counter.increment();\n// console.log(counter.getValue()); // Should log 2\n// console.log(counter.internalCounter); // Should be undefined or error\n",
          "solutionCode": "// Solution using IIFE for encapsulation\nconst counterModuleIIFE = (function() {\n  let count = 0; // Private internal variable\n\n  function increment() {\n    count++;\n  }\n\n  function getValue() {\n    return count;\n  }\n\n  // Expose public API\n  return {\n    increment: increment,\n    getValue: getValue\n  };\n})();\n\n// Example usage for IIFE module:\nconsole.log(\"--- IIFE Counter ---\");\ncounterModuleIIFE.increment();\nconsole.log(counterModuleIIFE.getValue()); // Expected: 1\ncounterModuleIIFE.increment();\ncounterModuleIIFE.increment();\nconsole.log(counterModuleIIFE.getValue()); // Expected: 3\n// console.log(counterModuleIIFE.count); // Undefined, demonstrating privacy\n\n\n// Solution using Modern ES Modules (conceptual, as it requires a module environment)\n/*\n// File: counter.js\nlet count = 0; // Private to the module\n\nexport function increment() {\n  count++;\n}\n\nexport function getValue() {\n  return count;\n}\n\n// File: main.js (or any other module importing this)\n// import { increment, getValue } from './counter.js';\n// increment();\n// console.log(getValue());\n// console.log(count); // ReferenceError, count is not exported\n*/\n",
          "testCases": [
            "After initializing the counter, `getValue()` should return 0.",
            "Calling `increment()` once should make `getValue()` return 1.",
            "Calling `increment()` multiple times should correctly increase the value.",
            "Attempting to access `counter.count` (or equivalent internal variable) should result in `undefined` or a `ReferenceError`."
          ],
          "hints": [
            "An IIFE creates a new function scope. Variables declared inside this scope are not accessible from the outside.",
            "To expose functionality from an IIFE, you can return an object containing references to the public methods.",
            "For ES Modules, `export` is used to make functions/variables public, while anything not exported remains private to the module."
          ],
          "tags": [
            "IIFE",
            "encapsulation",
            "modularity",
            "javascript-patterns",
            "closures",
            "es-modules"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_functions",
            "javascript_scope",
            "javascript_closures"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_function_mechanics"
          ]
        }
      ]
    }
  },
  {
    "id": "d26bdc0e-3d15-4e30-8986-f93d6425d6fe",
    "startLine": 600,
    "endLine": 699,
    "processedDate": "2025-06-17T07:19:58.741Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_iife",
          "title": "Immediately Invoked Function Expressions (IIFE)",
          "content": "An Immediately Invoked Function Expression (IIFE, pronounced \"iffy\") is a JavaScript design pattern that executes a function as soon as it is defined. It consists of two main parts:\n\n1.  **The Function Expression**: An anonymous function (or named, though less common) wrapped in parentheses `(function() { ... })`. This makes it a function expression rather than a function declaration.\n2.  **The Invocation**: The `()` at the end immediately calls the function `(function() { ... })()`. Alternatively, you can place the parentheses inside `(function() { ... }())`.\n\n### Purpose and Benefits\n\n*   **Scope Encapsulation / Data Privacy**: Variables and functions declared inside an IIFE are not accessible from the global scope, preventing them from polluting the global namespace. This helps in avoiding naming collisions, especially in applications with multiple scripts or third-party libraries.\n*   **Creating Private Variables and Closures**: IIFEs can be used to create private variables and methods that are only accessible within the IIFE's scope, similar to private members in object-oriented languages. This is often achieved in conjunction with closures.\n*   **Module Pattern**: IIFEs are fundamental to the module pattern in JavaScript, allowing you to return an object containing public methods while keeping other variables and functions private.\n*   **Aliasing Global Variables**: You can pass global objects (like `window` or `jQuery`) as arguments to an IIFE, aliasing them to shorter, more manageable names within the IIFE's scope, which can also help performance by avoiding repeated scope lookups for global variables.",
          "examples": [
            {
              "id": "example_iife_1",
              "title": "Basic IIFE for Scope Encapsulation",
              "code": "(function() {\n  const privateVar = 'This is private';\n  console.log(privateVar); // Accessible inside\n})();\n\n// console.log(privateVar); // ReferenceError: privateVar is not defined",
              "explanation": "This example shows the basic structure of an IIFE. The `privateVar` is contained within the IIFE's scope and cannot be accessed from outside, demonstrating global scope protection.",
              "language": "javascript"
            },
            {
              "id": "example_iife_2",
              "title": "IIFE with Parameters",
              "code": "(function(name) {\n  console.log(`Hello, ${name}!`);\n})('John');",
              "explanation": "This IIFE takes a parameter `name`. The value `'John'` is passed immediately upon invocation. This is useful for passing global variables or dependencies into the IIFE's private scope.",
              "language": "javascript"
            },
            {
              "id": "example_iife_3",
              "title": "IIFE as a Module Pattern",
              "code": "const counterModule = (function() {\n  let count = 0; // Private variable\n\n  function increment() {\n    count++;\n  }\n\n  function getCount() {\n    return count;\n  }\n\n  return {\n    increment: increment,\n    getCount: getCount\n  };\n})();\n\ncounterModule.increment();\nconsole.log(counterModule.getCount()); // 1\ncounterModule.increment();\nconsole.log(counterModule.getCount()); // 2\n// console.log(counterModule.count); // undefined (private)",
              "explanation": "This example demonstrates how an IIFE can be used to implement the Module Pattern, creating a private `count` variable and exposing only `increment` and `getCount` methods, providing encapsulation.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_iife_1",
            "question_iife_2",
            "question_iife_3",
            "question_iife_4",
            "question_iife_5"
          ],
          "relatedTasks": [
            "task_iife_1"
          ],
          "tags": [
            "JavaScript",
            "Functions",
            "Scope",
            "IIFE",
            "Closures",
            "Module Pattern"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_scope",
            "javascript_closures"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "module_pattern",
            "frontend_architecture"
          ]
        },
        {
          "id": "theory_function_context_this",
          "title": "Function Context and 'this'",
          "content": "The `this` keyword in JavaScript is a special identifier that refers to the context in which a function is executed. Its value is not fixed but is determined dynamically by how a function is called, also known as the \"invocation pattern\" or \"calling context\". Understanding `this` is crucial for writing correct and predictable JavaScript code, especially when dealing with objects, methods, and event handling.\n\n### Rules for `this` Binding\n\n1.  **Global Context (Default Binding)**:\n    *   When a function is called without any explicit object, `this` refers to the global object (`window` in browsers, `global` in Node.js) in non-strict mode.\n    *   In strict mode (`'use strict';`), `this` will be `undefined` when a function is called without an owning object.\n\n2.  **Method Context (Implicit Binding)**:\n    *   When a function is called as a method of an object (i.e., `object.method()`), `this` refers to the object on which the method was called.\n\n3.  **Event Handler Context**:\n    *   When a function is used as an event handler (e.g., with `addEventListener`), `this` typically refers to the DOM element that the listener is attached to, or the element that triggered the event.\n\n4.  **Arrow Functions (Lexical Binding)**:\n    *   Arrow functions do *not* have their own `this` binding. Instead, `this` inside an arrow function is lexically scoped; it inherits the `this` value from the enclosing execution context (i.e., where the arrow function was defined, not where it was called). This makes them very useful for preserving the `this` context from the surrounding code.\n\n5.  **Explicit Binding (`call`, `apply`, `bind`)**: These methods allow you to explicitly set the value of `this` for a function call. (See the \"Function Borrowing\" theory block for details).\n\n6.  **Constructor Context (`new` binding)**:\n    *   When a function is called with the `new` keyword (as a constructor), `this` refers to the newly created instance of the object.",
          "examples": [
            {
              "id": "example_this_1",
              "title": "'this' in Methods (Implicit Binding)",
              "code": "const user = {\n  name: 'John',\n  greet() {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\nuser.greet(); // Hello, John!\n\nconst greetFunction = user.greet;\ngreetFunction(); // Hello, undefined! (or Hello, ! in browser non-strict mode as 'this' is window)",
              "explanation": "When `greet` is called as a method of `user` (`user.greet()`), `this` inside `greet` refers to `user`. However, when `greet` is assigned to a new variable `greetFunction` and then called directly (`greetFunction()`), `this` loses its context and defaults to the global object (or `undefined` in strict mode), as it's no longer invoked as a method of `user`.",
              "language": "javascript"
            },
            {
              "id": "example_this_2",
              "title": "'this' in Event Handlers (DOM Context)",
              "code": "const button = document.createElement('button');\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nbutton.addEventListener('click', function() {\n  console.log(this.textContent); // refers to the button element ('Click Me')\n});",
              "explanation": "In a traditional function expression used as an event listener, `this` refers to the DOM element on which the event listener was attached (the `button` in this case).",
              "language": "javascript"
            },
            {
              "id": "example_this_3",
              "title": "'this' in Arrow Functions (Lexical Binding)",
              "code": "const button = document.createElement('button');\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nconst myObject = {\n  name: 'Outer Scope',\n  attachListener: function() {\n    // 'this' here refers to myObject\n    button.addEventListener('click', () => {\n      // 'this' here is lexically bound to 'this' of attachListener, which is myObject\n      console.log(`Button clicked. Context: ${this.name}`); \n    });\n  }\n};\n\nmyObject.attachListener();\n// When button is clicked, it logs: 'Button clicked. Context: Outer Scope'",
              "explanation": "Arrow functions do not bind their own `this`. Instead, they inherit `this` from their enclosing lexical scope. In this example, the `this` inside the arrow function `() => { ... }` refers to the `this` of the `attachListener` method, which is `myObject`, not the `button` element.",
              "language": "javascript"
            },
            {
              "id": "example_this_4",
              "title": "'this' in Global Context and Strict Mode",
              "code": "// Non-strict mode (default for browser scripts unless explicitly set)\nfunction showThisNonStrict() {\n  console.log(this); // In browsers, typically window object\n}\nshowThisNonStrict();\n\n// Strict mode\n'use strict';\nfunction showThisStrict() {\n  console.log(this); // undefined\n}\nshowThisStrict();",
              "explanation": "In non-strict mode, `this` defaults to the global object (`window` in browsers) when a function is called without an explicit context. In strict mode, `this` is `undefined` in such standalone function calls, preventing accidental global variable creation.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_this_1",
            "question_this_2",
            "question_this_3",
            "question_this_4",
            "question_this_5",
            "question_this_6",
            "question_this_7"
          ],
          "relatedTasks": [
            "task_this_1"
          ],
          "tags": [
            "JavaScript",
            "Functions",
            "Context",
            "this",
            "Arrow Functions",
            "Scope"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "object_oriented_js",
            "event_handling",
            "react_components"
          ]
        },
        {
          "id": "theory_function_borrowing",
          "title": "Function Borrowing with call, apply, and bind",
          "content": "Function borrowing is a technique in JavaScript where a function (or method) is called with a `this` context that is different from its original owner. This is achieved using the `call`, `apply`, and `bind` methods, which are all part of `Function.prototype`. These methods are essential for controlling the `this` keyword's value and are commonly used for tasks like explicit context binding, array manipulation, and creating new functions with pre-set contexts.\n\n### 1. `call()`\n*   **Purpose**: Invokes a function immediately with a specified `this` value and arguments provided individually.\n*   **Syntax**: `func.call(thisArg, arg1, arg2, ...)`\n*   **Characteristics**: Executes the function directly. Arguments are passed as a comma-separated list.\n\n### 2. `apply()`\n*   **Purpose**: Invokes a function immediately with a specified `this` value and arguments provided as an array (or an array-like object).\n*   **Syntax**: `func.apply(thisArg, [argsArray])`\n*   **Characteristics**: Executes the function directly. Arguments are passed as a single array.\n*   **Common Use Case**: When you have an array of arguments or when you don't know the number of arguments beforehand (e.g., `Math.max.apply(null, numbersArray)`).\n\n### 3. `bind()`\n*   **Purpose**: Returns a *new function* (a \"bound function\") with a specified `this` value and, optionally, initial arguments. The original function is *not* executed immediately.\n*   **Syntax**: `func.bind(thisArg, arg1, arg2, ...)`\n*   **Characteristics**: Does not execute the function. Creates a new function whose `this` is permanently bound to `thisArg` (and whose initial arguments are permanently bound as well, if provided). The bound function can then be called later.\n*   **Common Use Case**: Event listeners, `setTimeout`/`setInterval` callbacks, or when passing a function to another function that might lose its `this` context.",
          "examples": [
            {
              "id": "example_borrowing_1",
              "title": "Function Borrowing with call()",
              "code": "const person1 = {\n  fullName: function() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nconst person2 = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\nconst person3 = {\n  firstName: 'Jane',\n  lastName: 'Smith'\n};\n\n// person1's fullName method is called with person2 as its 'this' context\nconsole.log(person1.fullName.call(person2)); // \"John Doe\"\nconsole.log(person1.fullName.call(person3)); // \"Jane Smith\"\n\n// Example with arguments\nfunction greet(greeting, punctuation) {\n  return `${greeting}, ${this.firstName} ${this.lastName}${punctuation}`;\n}\n\nconsole.log(greet.call(person2, 'Hello', '!')); // \"Hello, John Doe!\"",
              "explanation": "`call()` immediately invokes the `fullName` function, setting `this` to `person2` (or `person3`). When arguments are needed, they are passed individually after the `thisArg`.",
              "language": "javascript"
            },
            {
              "id": "example_borrowing_2",
              "title": "Function Borrowing with apply()",
              "code": "const person1 = {\n  fullName: function() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nconst person2 = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\n// person1's fullName method is called with person2 as its 'this' context\nconsole.log(person1.fullName.apply(person2)); // \"John Doe\"\n\n// Example with arguments (as an array)\nfunction showDetails(age, city) {\n  return `${this.firstName} is ${age} years old and lives in ${city}.`;\n}\n\nconst detailsArgs = [30, 'New York'];\nconsole.log(showDetails.apply(person2, detailsArgs)); // \"John is 30 years old and lives in New York.\"",
              "explanation": "Similar to `call()`, `apply()` immediately invokes the function and sets `this`. The key difference is that arguments are passed as an array. This is useful when the number of arguments is dynamic or already in an array format.",
              "language": "javascript"
            },
            {
              "id": "example_borrowing_3",
              "title": "Function Borrowing with bind()",
              "code": "const person1 = {\n  fullName: function() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nconst person2 = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\n// bind() returns a NEW function, does not execute immediately\nconst getJohnFullName = person1.fullName.bind(person2);\nconsole.log(getJohnFullName()); // \"John Doe\"\n\n// Example: Binding 'this' for an event listener\nconst button = document.createElement('button');\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nconst handlerObject = {\n  name: 'My Handler',\n  handleClick: function() {\n    console.log(`${this.name} handled the click.`);\n    console.log(`Event target: ${event.target.textContent}`); // 'this' is handlerObject, not button\n  }\n};\n\n// Without bind, 'this' in handleClick would refer to the button\n// With bind, 'this' in handleClick will always refer to handlerObject\nbutton.addEventListener('click', handlerObject.handleClick.bind(handlerObject));\n\n// When button is clicked, it logs:\n// My Handler handled the click.\n// Event target: Click Me",
              "explanation": "`bind()` creates a new function (`getJohnFullName`) where `this` is permanently set to `person2`. This bound function can be called later without losing its context. The event listener example shows its practical use in ensuring `this` refers to the `handlerObject` even when the function is invoked by the DOM.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_borrowing_1",
            "question_borrowing_2",
            "question_borrowing_3",
            "question_borrowing_4",
            "question_borrowing_5",
            "question_borrowing_6"
          ],
          "relatedTasks": [
            "task_borrowing_1"
          ],
          "tags": [
            "JavaScript",
            "Functions",
            "this",
            "Call",
            "Apply",
            "Bind",
            "Context"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "theory_function_context_this"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_event_handling",
            "higher_order_functions"
          ]
        },
        {
          "id": "theory_currying",
          "title": "Currying",
          "content": "Currying is a functional programming technique that transforms a function that takes multiple arguments into a sequence of functions, each taking a single argument. This transformation allows for partial application of a function, meaning you can supply a subset of arguments and get a new function that expects the remaining arguments.\n\n### How Currying Works\n\nInstead of a function `f(a, b, c)` that takes three arguments at once, currying transforms it into `f(a)(b)(c)`. Each call returns a new function until all arguments are provided, at which point the final result is computed.\n\n### Benefits of Currying\n\n1.  **Reusability and Composability**: Curried functions are highly reusable. By partially applying arguments, you can create specialized versions of a function without rewriting it.\n2.  **Easier Function Composition**: Currying makes it easier to compose functions, as each function in the chain operates on a single input and produces a single output, fitting nicely into a pipeline of operations.\n3.  **Delayed Execution / Partial Application**: You can supply arguments incrementally over time, which is useful in scenarios like event handling or configuration, where not all data is available at once.\n4.  **Reduced Errors**: By ensuring functions only take one argument at a time, it can lead to more predictable and testable code.\n\n### Relationship with Partial Application\n\nCurrying is a form of partial application, but not all partial applications are currying. Currying strictly transforms a function to take one argument at a time. Partial application, more broadly, refers to fixing a number of arguments to a function, producing another function that takes fewer arguments, but not necessarily one at a time.",
          "examples": [
            {
              "id": "example_currying_1",
              "title": "Basic Curried Function",
              "code": "// Regular function\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\nconsole.log(add(1, 2, 3));        // 6\nconsole.log(curriedAdd(1)(2)(3)); // 6",
              "explanation": "This example shows the transformation from a regular `add` function to its curried equivalent `curriedAdd`. Instead of calling `curriedAdd(1, 2, 3)`, you call it sequentially: `curriedAdd(1)` returns a function, which you then call with `(2)`, which returns another function, finally called with `(3)` to get the result.",
              "language": "javascript"
            },
            {
              "id": "example_currying_2",
              "title": "Practical Currying Example: Discount Calculator",
              "code": "function discount(price) {\n  return function(percent) {\n    return price * (1 - percent / 100);\n  };\n}\n\n// Create specialized discount functions\nconst tenDollarItem = discount(10);\nconst twentyDollarItem = discount(20);\n\n// Apply different percentages\nconsole.log(tenDollarItem(20));  // 8 (20% off $10)\nconsole.log(tenDollarItem(50));  // 5 (50% off $10)\nconsole.log(twentyDollarItem(10)); // 18 (10% off $20)",
              "explanation": "This demonstrates a practical use case for currying. The `discount` function is curried, allowing you to first specify the `price` and then create new, specialized functions (like `tenDollarItem`) that are pre-configured with that price. You then apply different discount `percent` values to these specialized functions, showcasing reusability and partial application.",
              "language": "javascript"
            },
            {
              "id": "example_currying_3",
              "title": "Creating a Generic Curry Helper",
              "code": "function curry(func) {\n  return function curried(...args) {\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    } else {\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      }\n    }\n  };\n}\n\nconst add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\n\nconsole.log(curriedAdd(1)(2)(3));    // 6\nconsole.log(curriedAdd(1, 2)(3));   // 6\nconsole.log(curriedAdd(1)(2, 3));   // 6\nconsole.log(curriedAdd(1, 2, 3));   // 6",
              "explanation": "This `curry` helper function takes any function `func` and returns its curried version. It recursively collects arguments until all expected arguments (based on `func.length`) are provided, then it executes the original function. This makes it easy to curry any multi-argument function.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_currying_1",
            "question_currying_2",
            "question_currying_3",
            "question_currying_4",
            "question_currying_5"
          ],
          "relatedTasks": [
            "task_currying_1"
          ],
          "tags": [
            "JavaScript",
            "Functional Programming",
            "Currying",
            "Higher-Order Functions",
            "Partial Application"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_higher_order_functions",
            "javascript_closures"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "functional_programming",
            "redux_middleware"
          ]
        },
        {
          "id": "theory_memoization",
          "title": "Memoization",
          "content": "Memoization is an optimization technique used primarily to speed up computer programs by caching the results of expensive function calls and returning the cached result when the same inputs occur again. It's a form of caching specifically for function results.\n\n### How Memoization Works\n\nA memoized function typically maintains a cache (often an object or Map) where it stores the results of previous computations. When the function is called:\n\n1.  It first checks if the arguments it received have already been processed and their result stored in the cache.\n2.  If a result for those arguments is found in the cache, it returns the cached result immediately, avoiding re-computation.\n3.  If the arguments are new, the function performs the computation, stores the result in the cache associated with these arguments, and then returns the result.\n\n### When to Use Memoization\n\nMmization is most effective for:\n\n*   **Pure Functions**: Functions that always return the same output for the same input and have no side effects.\n*   **Expensive Computations**: Functions whose execution takes a significant amount of time or resources (e.g., recursive algorithms like Fibonacci, complex calculations, API calls).\n*   **Functions with Frequent Calls to Same Inputs**: If a function is called many times with the same arguments, memoization will yield significant performance benefits.\n\n### Trade-offs and Considerations\n\n*   **Memory Overhead**: Storing results in a cache consumes memory. For functions with a very large number of unique inputs, the cache can grow excessively large.\n*   **Key Generation**: The key used for caching must uniquely represent the function's arguments. For primitive arguments, `JSON.stringify` works, but for objects or complex data structures, a more robust serialization or hashing might be needed to ensure correct caching and avoid reference issues.\n*   **Side Effects**: Memoization should generally be applied only to pure functions. If a function has side effects (e.g., modifies external state, performs network requests), memoizing it might lead to unexpected behavior because the side effects won't occur on subsequent calls from cache.",
          "examples": [
            {
              "id": "example_memoization_1",
              "title": "Basic Memoization Implementation",
              "code": "function memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args); // Simple key for primitive args\n    if (cache[key]) {\n      console.log('Fetching from cache for key:', key);\n      return cache[key];\n    } else {\n      console.log('Calculating result for key:', key);\n      const result = fn.apply(this, args); // Use apply to preserve 'this' context if needed\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n\n// An expensive, pure function (e.g., Fibonacci)\nfunction fibonacci(n) {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconst memoizedFibonacci = memoize(fibonacci);\n\nconsole.log(memoizedFibonacci(10)); // Calculates, then caches\nconsole.log(memoizedFibonacci(10)); // Fetches from cache\nconsole.log(memoizedFibonacci(5));  // Calculates, then caches\nconsole.log(memoizedFibonacci(5));  // Fetches from cache\nconsole.log(memoizedFibonacci(10)); // Fetches from cache again",
              "explanation": "This example shows a generic `memoize` function that wraps any given function `fn`. It uses a simple object `cache` and `JSON.stringify(args)` to create a unique key for each set of arguments. The `fibonacci` function, which is computationally expensive due to recursion, is then memoized. Subsequent calls with the same input `n` retrieve the result from the cache, significantly speeding up execution.",
              "language": "javascript"
            },
            {
              "id": "example_memoization_2",
              "title": "Memoization with Complex Arguments (Considerations)",
              "code": "function memoizeComplex(fn) {\n  const cache = new Map(); // Using Map for better key handling (e.g., objects)\n  return function(...args) {\n    // A more robust key generation for complex scenarios might involve deep hashing\n    // For this example, we'll keep it simple for demonstration.\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      console.log('Fetching from cache (complex) for key:', key);\n      return cache.get(key);\n    } else {\n      console.log('Calculating result (complex) for key:', key);\n      const result = fn.apply(this, args);\n      cache.set(key, result);\n      return result;\n    }\n  };\n}\n\nfunction processData(data, config) {\n  // Simulate a complex operation that depends on data content and config\n  // For real-world, this would be CPU-bound or I/O-bound\n  console.log(`Processing data ${data.id} with config ${config.type}`);\n  return data.value * config.multiplier;\n}\n\nconst memoizedProcessData = memoizeComplex(processData);\n\nconst obj1 = { id: 1, value: 10 };\nconst obj2 = { id: 2, value: 20 };\nconst conf1 = { type: 'A', multiplier: 2 };\nconst conf2 = { type: 'B', multiplier: 3 };\n\nconsole.log(memoizedProcessData(obj1, conf1)); // Calculates (20)\nconsole.log(memoizedProcessData(obj1, conf1)); // Fetches from cache (20)\nconsole.log(memoizedProcessData(obj2, conf1)); // Calculates (40)\nconsole.log(memoizedProcessData(obj1, conf2)); // Calculates (30)\n\n// Note: JSON.stringify for objects works only if object structure and order of keys are consistent.\n// For true object comparison, a more advanced hashing or WeakMap approach would be needed.\nconst obj1_clone = { value: 10, id: 1 }; // Key might differ due to property order\nconsole.log(memoizedProcessData(obj1_clone, conf1)); // Calculates if key differs, otherwise cached\n",
              "explanation": "This example highlights the complexity of key generation for memoization when arguments are objects. While `JSON.stringify` works for simple objects or consistent structures, for robust object comparison, deep equality checks or a different caching strategy (like using a `WeakMap` if arguments are object references and you need garbage collection) might be required. It also shows applying memoization to a function with multiple, non-primitive arguments.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_memoization_1",
            "question_memoization_2",
            "question_memoization_3",
            "question_memoization_4",
            "question_memoization_5"
          ],
          "relatedTasks": [
            "task_memoization_1"
          ],
          "tags": [
            "JavaScript",
            "Optimization",
            "Caching",
            "Memoization",
            "Performance",
            "Pure Functions",
            "Higher-Order Functions"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_closures",
            "javascript_objects"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "performance_optimization",
            "functional_programming",
            "react_performance_optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_iife_1",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "easy",
          "type": "flashcard",
          "question": "What does IIFE stand for?",
          "answer": "Immediately Invoked Function Expression",
          "analysisPoints": [
            "Basic recall of the acronym."
          ],
          "keyConcepts": [
            "IIFE"
          ],
          "evaluationCriteria": [
            "Memorization of terminology."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "JavaScript",
            "Terminology"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_iife_2",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the primary benefit of using an IIFE in JavaScript?",
          "answer": "To prevent variable pollution in the global scope.",
          "options": [
            "To prevent variable pollution in the global scope.",
            "To make asynchronous calls synchronous.",
            "To create new classes dynamically.",
            "To enable server-side rendering."
          ],
          "analysisPoints": [
            "Understanding the core purpose of IIFEs.",
            "Distinguishing IIFEs from other JavaScript features."
          ],
          "keyConcepts": [
            "IIFE",
            "Scope",
            "Global Scope",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Ability to identify the main advantage of IIFEs.",
            "Knowledge of scope management in JavaScript."
          ],
          "example": "IIFEs encapsulate variables within their own function scope, preventing them from being accidentally declared in or overwriting variables in the global scope.\n\n```javascript\n(function() {\n  const tempVar = 'I am private';\n  // console.log(window.tempVar); // undefined\n})();\n// console.log(tempVar); // ReferenceError\n```",
          "tags": [
            "IIFE",
            "Scope",
            "Global Scope",
            "Encapsulation"
          ],
          "prerequisites": [
            "javascript_scope"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_iife_3",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "medium",
          "type": "open",
          "question": "Explain how an IIFE can be used to achieve data privacy in JavaScript. Provide a simple code example.",
          "answer": "An IIFE creates its own private scope. Variables and functions declared inside the IIFE are confined to that scope and are not directly accessible from the outside. This prevents them from polluting the global namespace and allows for the creation of 'private' members, similar to private properties in object-oriented programming. If you need to expose certain functionalities, you can return an object containing public methods, which then form a closure over the private variables.\n\n```javascript\nconst counter = (function() {\n  let privateCount = 0; // This variable is private to the IIFE\n\n  function changeBy(val) {\n    privateCount += val;\n  }\n\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCount;\n    }\n  };\n})();\n\nconsole.log(counter.value()); // 0\ncounter.increment();\ncounter.increment();\nconsole.log(counter.value()); // 2\n// console.log(counter.privateCount); // undefined - cannot access privateCount directly\n```",
          "analysisPoints": [
            "Ability to explain the concept of data privacy through IIFEs.",
            "Demonstrates understanding of closures in conjunction with IIFEs.",
            "Provides a correct and relevant code example."
          ],
          "keyConcepts": [
            "IIFE",
            "Scope",
            "Data Privacy",
            "Closures",
            "Module Pattern"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Correctness of code example.",
            "Identification of related concepts like closures."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "Data Privacy",
            "Closures",
            "Module Pattern"
          ],
          "prerequisites": [
            "javascript_scope",
            "javascript_closures"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_iife_4",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple module using an IIFE that manages a collection of items. The module should expose methods to `addItem(item)`, `removeItem(item)`, and `getAllItems()`, but the internal array storing items should remain private.",
          "answer": "```javascript\nconst itemManager = (function() {\n  const items = []; // Private array\n\n  return {\n    addItem: function(item) {\n      if (item) {\n        items.push(item);\n        console.log(`Added: ${item}`);\n      }\n    },\n    removeItem: function(item) {\n      const index = items.indexOf(item);\n      if (index > -1) {\n        items.splice(index, 1);\n        console.log(`Removed: ${item}`);\n      }\n    },\n    getAllItems: function() {\n      // Return a copy to prevent external modification of the private array\n      return [...items]; \n    },\n    getItemCount: function() {\n      return items.length;\n    }\n  };\n})();\n\n// Test cases\nitemManager.addItem('Apple');\nitemManager.addItem('Banana');\nconsole.log('All items:', itemManager.getAllItems()); // Output: [ 'Apple', 'Banana' ]\nconsole.log('Item count:', itemManager.getItemCount()); // Output: 2\n\nitemManager.removeItem('Apple');\nconsole.log('All items:', itemManager.getAllItems()); // Output: [ 'Banana' ]\n\nitemManager.addItem('Orange');\nconsole.log('All items:', itemManager.getAllItems()); // Output: [ 'Banana', 'Orange' ]\n\n// Attempt to modify private array (should fail if getAllItems returns a copy)\nconst currentItems = itemManager.getAllItems();\ncurrentItems.push('Grape'); // Modifies the copy, not the original\nconsole.log('All items after external push:', itemManager.getAllItems()); // Output: [ 'Banana', 'Orange' ] (Grape not present)\n```",
          "analysisPoints": [
            "Correct use of IIFE for encapsulation.",
            "Proper implementation of public methods.",
            "Ensuring the internal array remains private (e.g., returning a copy of the array).",
            "Handling basic logic for add/remove operations."
          ],
          "keyConcepts": [
            "IIFE",
            "Module Pattern",
            "Encapsulation",
            "Data Privacy",
            "Closures",
            "Array Methods"
          ],
          "evaluationCriteria": [
            "Functional correctness.",
            "Adherence to the IIFE pattern.",
            "Effective data encapsulation.",
            "Robustness against external modification (by returning a copy)."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "Module Pattern",
            "Encapsulation",
            "Coding Challenge"
          ],
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_iife_5",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main benefit of using an IIFE regarding global variables?",
          "answer": "It prevents pollution of the global namespace.",
          "analysisPoints": [
            "Core understanding of IIFE's scope benefit."
          ],
          "keyConcepts": [
            "IIFE",
            "Global Scope",
            "Pollution"
          ],
          "evaluationCriteria": [
            "Quick recall of a key benefit."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "Scope",
            "Global Scope"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_1",
          "topic": "Function Context and 'this'",
          "level": "easy",
          "type": "flashcard",
          "question": "In JavaScript, what determines the value of `this` inside a regular function?",
          "answer": "The way the function is called (its invocation context).",
          "analysisPoints": [
            "Understanding the dynamic nature of `this`."
          ],
          "keyConcepts": [
            "this",
            "Context",
            "Invocation"
          ],
          "evaluationCriteria": [
            "Basic recall of `this` behavior."
          ],
          "example": null,
          "tags": [
            "this",
            "JavaScript",
            "Context"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_2",
          "topic": "Function Context and 'this'",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code snippet:\n\n```javascript\nconst person = {\n  name: 'Alice',\n  greet: function() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n};\n\nconst sayHello = person.greet;\nsayHello();\n```\n\nWhat will be the output of `sayHello()`?",
          "answer": "Hello, my name is undefined",
          "options": [
            "Hello, my name is Alice",
            "Hello, my name is undefined",
            "ReferenceError: name is not defined",
            "TypeError: this.name is not a function"
          ],
          "analysisPoints": [
            "Understanding the loss of `this` context when a method is assigned to a new variable and called without an explicit receiver.",
            "Knowing that in non-strict mode, `this` defaults to global object, and `name` might not exist there, resulting in `undefined`.",
            "Recognizing the difference between implicit and default binding."
          ],
          "keyConcepts": [
            "this",
            "Implicit Binding",
            "Default Binding",
            "Global Object",
            "Strict Mode"
          ],
          "evaluationCriteria": [
            "Ability to predict `this` value in a specific scenario.",
            "Understanding of method detachment and its effect on `this`."
          ],
          "example": "When `person.greet` is called directly as `person.greet()`, `this` refers to `person`. However, when `person.greet` is assigned to `sayHello` and then called as a standalone function `sayHello()`, `this` falls back to the default binding. In non-strict mode (common in browser scripts by default), `this` would be the global object (`window`), and `window.name` is likely `undefined` or an empty string. In strict mode, `this` would be `undefined`, leading to an error if attempting `undefined.name` directly, but `console.log` would output 'undefined'.",
          "tags": [
            "this",
            "Context",
            "JavaScript",
            "Functions"
          ],
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_3",
          "topic": "Function Context and 'this'",
          "level": "medium",
          "type": "mcq",
          "question": "What is the key difference in `this` binding between a regular function expression and an arrow function?",
          "answer": "Arrow functions do not have their own 'this' binding; they inherit 'this' from their lexical (enclosing) scope.",
          "options": [
            "Arrow functions do not have their own 'this' binding; they inherit 'this' from their lexical (enclosing) scope.",
            "Regular functions always bind 'this' to the global object, while arrow functions bind 'this' to the local scope.",
            "Arrow functions bind 'this' to the function's arguments, while regular functions bind it to the function itself.",
            "There is no difference; 'this' behaves identically in both."
          ],
          "analysisPoints": [
            "Understanding the lexical `this` binding of arrow functions.",
            "Contrasting it with the dynamic `this` binding of regular functions.",
            "Debunking common misconceptions about `this` behavior."
          ],
          "keyConcepts": [
            "this",
            "Arrow Functions",
            "Lexical Scope",
            "Dynamic Binding",
            "Function Expression"
          ],
          "evaluationCriteria": [
            "Accurate understanding of arrow function `this`.",
            "Ability to differentiate `this` rules for different function types."
          ],
          "example": "```javascript\nconst obj = {\n  value: 42,\n  regularFn: function() {\n    console.log(this.value); // 'this' refers to obj (dynamic binding)\n\n    const arrowFn = () => {\n      console.log(this.value); // 'this' refers to obj (lexical binding, inherits from regularFn's 'this')\n    };\n    arrowFn();\n  },\n  arrowFnDirect: () => {\n    console.log(this.value); // 'this' refers to the global object (window/undefined), as it inherits from the global lexical scope\n  }\n};\n\nobj.regularFn(); // Output: 42, 42\nobj.arrowFnDirect(); // Output: undefined (in strict mode, or depends on global `value` in non-strict)",
          "tags": [
            "this",
            "Arrow Functions",
            "Lexical Scope"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_4",
          "topic": "Function Context and 'this'",
          "level": "hard",
          "type": "code",
          "question": "Consider the following HTML and JavaScript. Predict the output of clicking the button twice, and explain why. Then, modify the JavaScript using an `arrow function` or `bind` to ensure that `this.clicks` correctly increments the `clicks` property of the `counter` object.",
          "answer": "Original Output and Explanation:\nWhen the button is clicked the first time, the original `console.log(this.clicks)` will output `undefined`. The second click will also output `undefined`.\n\n**Explanation**: In the original code, the `function() { ... }` used as an event listener has its `this` bound to the `button` DOM element that triggered the event, not the `counter` object. Since the `button` element does not have a `clicks` property, `this.clicks` (i.e., `button.clicks`) will be `undefined`.\n\nModified JavaScript using `bind` (or arrow function below):\n\n```javascript\nconst button = document.createElement('button');\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nconst counter = {\n  clicks: 0,\n  increment: function() {\n    this.clicks++;\n    console.log(`Clicks: ${this.clicks}`);\n  }\n};\n\n// Using .bind(this)\nbutton.addEventListener('click', counter.increment.bind(counter));\n\n// Alternatively, using an arrow function to preserve lexical 'this'\n// button.addEventListener('click', () => {\n//   counter.increment(); // Directly call counter.increment without losing context\n// });\n\n// Or, if increment itself was an arrow function *inside* a method of counter:\n// const counter = {\n//   clicks: 0,\n//   setupListener: function() {\n//     button.addEventListener('click', () => {\n//       this.clicks++; // 'this' here refers to 'counter' due to lexical scoping\n//       console.log(`Clicks: ${this.clicks}`);\n//     });\n//   }\n// };\n// counter.setupListener();\n```\n\n**Modified Output**:\nFirst click: `Clicks: 1`\nSecond click: `Clicks: 2`\n\n**Explanation of Modification**:\n*   **`bind(counter)`**: The `bind` method creates a new function where `this` is permanently set to `counter`. When the event listener fires, the bound function is called, and `this` inside `increment` correctly refers to the `counter` object, allowing `counter.clicks` to be incremented.\n*   **Arrow Function (direct call)**: By using `() => { counter.increment(); }`, we explicitly call `counter.increment()`. In this case, `increment` is called as a method of `counter`, so `this` inside `increment` will correctly refer to `counter`.\n*   **Arrow Function (lexical `this` within `setupListener`)**: If the arrow function is defined within another method of `counter` (e.g., `setupListener`), `this` inside the arrow function will lexically inherit `this` from `setupListener`, which would be `counter` itself.",
          "analysisPoints": [
            "Diagnosing `this` context issues in event handlers.",
            "Proposing and implementing solutions using `bind` or arrow functions.",
            "Explaining the mechanism of `this` binding in both original and corrected code."
          ],
          "keyConcepts": [
            "this",
            "Event Handlers",
            "Bind",
            "Arrow Functions",
            "Lexical Scope",
            "Implicit Binding",
            "Default Binding"
          ],
          "evaluationCriteria": [
            "Correct identification of the problem.",
            "Effective application of `bind` or arrow functions.",
            "Clear and accurate explanation of `this` behavior."
          ],
          "example": null,
          "tags": [
            "this",
            "Event Handling",
            "Bind",
            "Arrow Functions",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing",
            "dom_events"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_5",
          "topic": "Function Context and 'this'",
          "level": "easy",
          "type": "flashcard",
          "question": "When a function is called as a method of an object (e.g., `obj.method()`), what does `this` refer to inside that method?",
          "answer": "The object itself (`obj`).",
          "analysisPoints": [
            "Recall of implicit binding rule."
          ],
          "keyConcepts": [
            "this",
            "Implicit Binding",
            "Object Method"
          ],
          "evaluationCriteria": [
            "Basic recall of `this` behavior."
          ],
          "example": null,
          "tags": [
            "this",
            "Context",
            "Objects"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_6",
          "topic": "Function Context and 'this'",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where using an arrow function for a callback (e.g., in `setTimeout` or `addEventListener`) is particularly beneficial regarding the `this` keyword. Provide a short code example.",
          "answer": "Arrow functions are particularly beneficial for callbacks in scenarios where you want to preserve the `this` context from the surrounding (lexical) scope. Traditional function expressions create their own `this` context, which often defaults to the global object or the event target, leading to `this` being different from what's expected.\n\n**Scenario**: Inside an object method, if you have an asynchronous operation (like `setTimeout`) or an event listener callback, and you need to access properties of the *outer* object using `this`.\n\n**Example**: Without arrow function, `this.count` would be `undefined`.\n\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n    this.button = document.createElement('button');\n    this.button.textContent = 'Increment';\n    document.body.appendChild(this.button);\n\n    // Using arrow function: 'this' inside the callback refers to the Counter instance\n    this.button.addEventListener('click', () => {\n      this.count++;\n      console.log(`Count: ${this.count}`);\n    });\n\n    // If it were a regular function:\n    // this.button.addEventListener('click', function() {\n    //   console.log(this); // 'this' would be the button element\n    //   // console.log(this.count); // undefined, as button doesn't have a 'count' property\n    // });\n  }\n}\n\nconst myCounter = new Counter();\n```",
          "analysisPoints": [
            "Identifies a common problem with `this` in callbacks.",
            "Explains why arrow functions solve this problem (lexical binding).",
            "Provides a clear and concise code example demonstrating the benefit."
          ],
          "keyConcepts": [
            "this",
            "Arrow Functions",
            "Lexical Scope",
            "Callbacks",
            "Event Handling",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Relevance of the scenario.",
            "Correctness and effectiveness of the code example."
          ],
          "example": null,
          "tags": [
            "this",
            "Arrow Functions",
            "Callbacks",
            "Event Handling",
            "Asynchronous JavaScript"
          ],
          "prerequisites": [
            "theory_function_context_this"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_7",
          "topic": "Function Context and 'this'",
          "level": "hard",
          "type": "code",
          "question": "Analyze the following code. What will be logged to the console? Explain your reasoning. Then, rewrite the `logMessage` method to ensure that when `obj.delayedLog()` is called, it correctly logs 'Hello, World!' after a delay, without manually referencing `obj.message` inside `setTimeout`.",
          "answer": "Original Code Analysis:\n```javascript\nconst obj = {\n  message: 'Hello, World!',\n  logMessage: function() {\n    setTimeout(function() {\n      console.log(this.message); \n    }, 100);\n  }\n};\n\nobj.delayedLog(); // Output: undefined (after 100ms)\n```\n\n**Explanation**: When `obj.delayedLog()` is called, `logMessage` is executed as a method of `obj`, so `this` inside `logMessage` initially refers to `obj`. However, `setTimeout` takes a *regular function expression* as its callback. Inside this callback, `this` is **not** bound to `obj`. In non-strict mode, `this` inside the `setTimeout` callback will default to the global object (`window` in a browser), and `window.message` is `undefined` (or empty string). In strict mode, `this` would be `undefined`.\n\nRewritten `logMessage` (using an arrow function or `bind`):\n\n**Option 1: Using an Arrow Function** (preferred for simplicity and common use cases)\n```javascript\nconst obj = {\n  message: 'Hello, World!',\n  delayedLog: function() {\n    setTimeout(() => {\n      console.log(this.message); // 'this' lexically binds to obj from delayedLog's scope\n    }, 100);\n  }\n};\nobj.delayedLog(); // Output: Hello, World! (after 100ms)\n```\n\n**Option 2: Using `bind`**\n```javascript\nconst obj = {\n  message: 'Hello, World!',\n  delayedLog: function() {\n    setTimeout(function() {\n      console.log(this.message);\n    }.bind(this), 100); // .bind(this) ensures 'this' inside callback is 'obj'\n  }\n};\nobj.delayedLog(); // Output: Hello, World! (after 100ms)\n```\n\n**Explanation of Rewrite**: Both solutions successfully preserve the `this` context:\n*   **Arrow Function**: Arrow functions do not have their own `this` context; they inherit `this` from their parent scope. In this case, the `setTimeout` callback (an arrow function) inherits `this` from the `delayedLog` method, where `this` correctly refers to `obj`.\n*   **`bind(this)`**: The `bind()` method creates a *new function* that has its `this` keyword set to the provided value. By binding `this` (which is `obj` at the point of `setTimeout` call) to the callback function, we ensure that `this.message` inside the `setTimeout` callback correctly references `obj.message`.",
          "analysisPoints": [
            "Correctly identify the `this` binding issue with `setTimeout` callbacks.",
            "Explain the default/global binding of `this` in such scenarios.",
            "Provide and justify solutions using arrow functions and/or `bind`.",
            "Demonstrate understanding of lexical vs. dynamic `this`."
          ],
          "keyConcepts": [
            "this",
            "setTimeout",
            "Arrow Functions",
            "Bind",
            "Lexical Scope",
            "Dynamic Binding",
            "Callbacks"
          ],
          "evaluationCriteria": [
            "Accuracy of initial prediction and explanation.",
            "Effectiveness and correctness of the rewritten code.",
            "Thoroughness of explanation for the solutions."
          ],
          "example": null,
          "tags": [
            "this",
            "setTimeout",
            "Asynchronous JavaScript",
            "Coding Challenge",
            "Bind",
            "Arrow Functions"
          ],
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing",
            "javascript_asynchronous"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_borrowing_1",
          "topic": "Function Borrowing",
          "level": "easy",
          "type": "flashcard",
          "question": "Which `Function.prototype` method returns a *new function* with `this` bound, instead of executing immediately?",
          "answer": "`bind()`",
          "analysisPoints": [
            "Differentiating `bind` from `call` and `apply` based on its return value and immediate execution."
          ],
          "keyConcepts": [
            "bind",
            "Function Borrowing",
            "this"
          ],
          "evaluationCriteria": [
            "Quick recall of method behavior."
          ],
          "example": null,
          "tags": [
            "Bind",
            "JavaScript",
            "Functions"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_borrowing_2",
          "topic": "Function Borrowing",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following objects and function:\n\n```javascript\nconst car = {\n  brand: 'Toyota',\n  getBrand: function() {\n    return this.brand;\n  }\n};\n\nconst anotherCar = {\n  brand: 'Honda'\n};\n\n// What will be the output of:\nconsole.log(car.getBrand.call(anotherCar));\n```",
          "answer": "Honda",
          "options": [
            "Toyota",
            "Honda",
            "undefined",
            "TypeError"
          ],
          "analysisPoints": [
            "Understanding how `call` explicitly sets the `this` context.",
            "Identifying that `this` inside `getBrand` will refer to `anotherCar`."
          ],
          "keyConcepts": [
            "call",
            "Function Borrowing",
            "this",
            "Explicit Binding"
          ],
          "evaluationCriteria": [
            "Ability to correctly predict `this` behavior with `call`.",
            "Understanding of explicit binding."
          ],
          "example": "The `call()` method allows you to invoke `car.getBrand` with `anotherCar` as its `this` context. Therefore, `this.brand` inside `getBrand` will evaluate to `anotherCar.brand`, which is 'Honda'.\n\n```javascript\nconst car = {\n  brand: 'Toyota',\n  getBrand: function() {\n    return this.brand;\n  }\n};\n\nconst anotherCar = {\n  brand: 'Honda'\n};\n\nconsole.log(car.getBrand.call(anotherCar)); // Output: Honda\n```",
          "tags": [
            "call",
            "this",
            "Function Borrowing"
          ],
          "prerequisites": [
            "theory_function_context_this"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_borrowing_3",
          "topic": "Function Borrowing",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast `call()` and `apply()`. When would you choose one over the other?",
          "answer": "Both `call()` and `apply()` are `Function.prototype` methods used for explicit function invocation. They allow you to call a function with a specified `this` context.\n\n**Similarities:**\n*   Both execute the function *immediately*.\n*   Both allow you to explicitly set the `this` value for the function call.\n*   Both take `thisArg` as their first argument.\n\n**Differences:**\n*   **Argument Handling**: `call()` accepts arguments as a comma-separated list (`func.call(thisArg, arg1, arg2, ...)`).\n    `apply()` accepts arguments as an array or an array-like object (`func.apply(thisArg, [argsArray])`).\n\n**When to choose which:**\n*   **Choose `call()`** when you know the arguments beforehand and they are few and distinct, or when you are simply passing individual variables.\n    *   *Example*: `Math.max.call(null, 10, 20, 5);`\n*   **Choose `apply()`** when you have an array of arguments, or when the number of arguments is dynamic and not known at the time of writing the code (e.g., when accepting `arguments` object in a function).\n    *   *Example*: `Math.max.apply(null, [10, 20, 5]);` or `Array.prototype.push.apply(arr1, arr2);` (for concatenating arrays).\n\nIn ES6, with the spread syntax (`...`), the distinction for passing arguments has become less critical, as you can often use `call` with spread: `func.call(thisArg, ...argsArray);`. However, understanding the original intent and historical use cases of `apply` is still important.",
          "analysisPoints": [
            "Accurate comparison of argument handling.",
            "Correct identification of when to use each method.",
            "Mentioning similarities and differences.",
            "Discussing the impact of ES6 spread syntax."
          ],
          "keyConcepts": [
            "call",
            "apply",
            "Function Borrowing",
            "this",
            "Explicit Binding",
            "Arguments"
          ],
          "evaluationCriteria": [
            "Thoroughness of comparison.",
            "Clarity of explanation for use cases.",
            "Accuracy of technical details."
          ],
          "example": null,
          "tags": [
            "call",
            "apply",
            "Function Borrowing",
            "this"
          ],
          "prerequisites": [
            "theory_function_context_this"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_borrowing_4",
          "topic": "Function Borrowing",
          "level": "hard",
          "type": "code",
          "question": "You have a `Logger` object that logs messages with a prefix and timestamp. You want to use its `log` method as a callback for an array iteration, but ensure `this` inside `log` always refers to the `Logger` instance. Write the code to achieve this.\n\n```javascript\nconst logger = {\n  prefix: '[APP]',\n  log: function(message) {\n    const timestamp = new Date().toLocaleTimeString();\n    console.log(`${this.prefix} ${timestamp}: ${message}`);\n  }\n};\n\nconst messages = [\n  'User logged in',\n  'Data fetched',\n  'Error occurred'\n];\n\n// Your code here: Use forEach with logger.log as callback, preserving 'this'\n```\n\nExpected Output (timestamps will vary):\n`[APP] 10:30:00 AM: User logged in`\n`[APP] 10:30:00 AM: Data fetched`\n`[APP] 10:30:00 AM: Error occurred`",
          "answer": "```javascript\nconst logger = {\n  prefix: '[APP]',\n  log: function(message) {\n    const timestamp = new Date().toLocaleTimeString();\n    // 'this' must refer to 'logger' object\n    console.log(`${this.prefix} ${timestamp}: ${message}`);\n  }\n};\n\nconst messages = [\n  'User logged in',\n  'Data fetched',\n  'Error occurred'\n];\n\n// Using .bind() to create a new function with 'this' permanently bound to 'logger'\nmessages.forEach(logger.log.bind(logger));\n\n// Alternative using an arrow function for the forEach callback (less direct function borrowing):\n// messages.forEach(message => logger.log(message));\n```\n\n**Explanation**:\nWhen `messages.forEach(logger.log)` is used directly, the `log` function is called by `forEach`. In this context, `this` inside `log` would typically be `undefined` (in strict mode) or the global object (in non-strict mode), not `logger`. This would cause `this.prefix` to be `undefined`.\n\nBy using `logger.log.bind(logger)`, we create a *new function* (a bound version of `logger.log`) where the `this` context is permanently set to the `logger` object. This bound function is then passed to `forEach`. Now, when `forEach` calls this bound function for each `message`, `this.prefix` correctly resolves to `logger.prefix`.",
          "analysisPoints": [
            "Correctly identify the `this` context issue when `logger.log` is passed as a callback.",
            "Apply `bind` to explicitly set `this` for the `log` method.",
            "Demonstrate proper usage of `forEach` with a bound function."
          ],
          "keyConcepts": [
            "bind",
            "Function Borrowing",
            "this",
            "forEach",
            "Callbacks",
            "Explicit Binding"
          ],
          "evaluationCriteria": [
            "Functional correctness.",
            "Correct application of `bind`.",
            "Understanding of `this` in callbacks."
          ],
          "example": null,
          "tags": [
            "Bind",
            "this",
            "Callbacks",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing",
            "javascript_arrays"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_borrowing_5",
          "topic": "Function Borrowing",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `call()` and `apply()` in terms of how they handle arguments?",
          "answer": "`call()` takes arguments individually (comma-separated), while `apply()` takes arguments as an array.",
          "analysisPoints": [
            "Differentiating `call` and `apply` based on argument passing."
          ],
          "keyConcepts": [
            "call",
            "apply",
            "Arguments"
          ],
          "evaluationCriteria": [
            "Quick recall of method signatures."
          ],
          "example": null,
          "tags": [
            "call",
            "apply",
            "JavaScript"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_borrowing_6",
          "topic": "Function Borrowing",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is `Function.prototype.bind()` most suitable for?\n\n```javascript\nconst data = {\n  value: 10,\n  update: function(newValue) {\n    this.value = newValue;\n    console.log(this.value);\n  }\n};\n\n// You need to pass data.update as a callback to a function \n// that will execute it later, and ensure 'this' always refers to 'data'.\n```",
          "answer": "Using it as an event listener for a DOM element.",
          "options": [
            "Using it as an event listener for a DOM element.",
            "Immediately invoking it with a different 'this' context and a known set of arguments.",
            "Invoking it immediately with a different 'this' context and arguments supplied as an array.",
            "Performing a one-time function call with a specific 'this' for debugging."
          ],
          "analysisPoints": [
            "Understanding that `bind` creates a *new* function for *later* execution.",
            "Recognizing that `call` and `apply` are for immediate execution.",
            "Identifying scenarios where preserving `this` over time is critical."
          ],
          "keyConcepts": [
            "bind",
            "Function Borrowing",
            "this",
            "Callbacks",
            "Event Handling",
            "Partial Application"
          ],
          "evaluationCriteria": [
            "Ability to choose the correct method for a given scenario.",
            "Understanding the `bind` method's primary use cases."
          ],
          "example": "`bind` is ideal when you need to pass a method as a callback to another function or API (like `setTimeout`, `addEventListener`, or React component methods) where the original `this` context would otherwise be lost. It pre-configures the `this` value, returning a new function that can be called anytime later.\n\n```javascript\nconst data = {\n  value: 10,\n  update: function(newValue) {\n    this.value = newValue;\n    console.log(this.value);\n  }\n};\n\nconst button = document.createElement('button');\nbutton.textContent = 'Update';\ndocument.body.appendChild(button);\n\n// Without bind, 'this' inside update would be the button when clicked\n// With bind, 'this' inside update will always be 'data'\nbutton.addEventListener('click', data.update.bind(data, 20)); // Binds 'this' to data and partially applies '20'\n```",
          "tags": [
            "Bind",
            "this",
            "Callbacks",
            "Event Handling"
          ],
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_currying_1",
          "topic": "Currying",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core idea behind currying a function?",
          "answer": "Transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument.",
          "analysisPoints": [
            "Basic definition of currying."
          ],
          "keyConcepts": [
            "Currying",
            "Functional Programming",
            "Higher-Order Functions"
          ],
          "evaluationCriteria": [
            "Recall of definition."
          ],
          "example": null,
          "tags": [
            "Currying",
            "Functional Programming"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_currying_2",
          "topic": "Currying",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following curried `multiply` function:\n\n```javascript\nfunction multiply(a) {\n  return function(b) {\n    return function(c) {\n      return a * b * c;\n    };\n  };\n}\n\n// What will be the output of:\nconst multiplyByFive = multiply(5);\nconst multiplyByFiveAndTen = multiplyByFive(10);\nconsole.log(multiplyByFiveAndTen(2));\n```",
          "answer": "100",
          "options": [
            "5",
            "10",
            "100",
            "TypeError"
          ],
          "analysisPoints": [
            "Understanding how curried functions are invoked step-by-step.",
            "Tracing the flow of arguments through nested functions."
          ],
          "keyConcepts": [
            "Currying",
            "Closure",
            "Partial Application"
          ],
          "evaluationCriteria": [
            "Ability to correctly evaluate curried function calls.",
            "Understanding of argument persistence through closures."
          ],
          "example": "The `multiply` function is curried. `multiply(5)` returns a new function (closure) where `a` is 5. `multiplyByFive(10)` then calls this new function, binding `b` to 10 and returning another function. Finally, `multiplyByFiveAndTen(2)` calls the last function, binding `c` to 2, and performs the calculation: `5 * 10 * 2 = 100`.\n\n```javascript\nfunction multiply(a) {\n  return function(b) {\n    return function(c) {\n      return a * b * c;\n    };\n  };\n}\n\nconst multiplyByFive = multiply(5); // a = 5\nconst multiplyByFiveAndTen = multiplyByFive(10); // b = 10\nconsole.log(multiplyByFiveAndTen(2)); // c = 2 -> 5 * 10 * 2 = 100\n```",
          "tags": [
            "Currying",
            "Functional Programming",
            "Closure"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_closures"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_currying_3",
          "topic": "Currying",
          "level": "medium",
          "type": "open",
          "question": "What are some practical benefits or use cases for currying in frontend development?",
          "answer": "Currying offers several practical benefits in frontend development:\n\n1.  **Reusability and Configuration**: You can create specialized, reusable functions by pre-setting some arguments. For example, a `makeHttpRequest` function can be curried to create specific `getJson`, `postXml` functions by fixing the method and content type.\n2.  **Partial Application**: It naturally supports partial application, allowing you to pass arguments incrementally. This is useful for event handlers where you might want to pass some fixed data along with the event object, or for creating utility functions that are configured once and then used multiple times.\n3.  **Function Composition**: Curried functions fit well into function composition pipelines (e.g., using `compose` or `pipe` utilities), as each function takes a single argument and returns a single output, making data flow more predictable.\n4.  **Cleaner Code for Higher-Order Components/Functions**: In frameworks like React, currying can make higher-order components or functions more declarative and easier to read, especially when passing multiple configuration parameters.\n5.  **Simplified Form Validation**: A validator function for an input could be curried to first take the validation rule (e.g., `minLength`, `isEmail`) and then return a function that takes the actual input value.\n\n**Example (Partial Application for Event Handlers)**:\n```javascript\nfunction logEvent(eventType) {\n  return function(event) {\n    console.log(`${eventType} occurred at ${event.target.id || event.target.tagName}`);\n  };\n}\n\nconst button = document.createElement('button');\nbutton.id = 'myButton';\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nbutton.addEventListener('click', logEvent('UserClick'));\n// When button is clicked, logs: 'UserClick occurred at myButton'\n```",
          "analysisPoints": [
            "Identifies multiple benefits beyond just syntax.",
            "Provides relevant frontend specific use cases.",
            "Offers a clear, concise example."
          ],
          "keyConcepts": [
            "Currying",
            "Partial Application",
            "Function Composition",
            "Reusability",
            "Higher-Order Functions"
          ],
          "evaluationCriteria": [
            "Breadth of knowledge on benefits.",
            "Relevance of examples.",
            "Clarity of explanation."
          ],
          "example": null,
          "tags": [
            "Currying",
            "Functional Programming",
            "Frontend Development",
            "Use Cases"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_higher_order_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_currying_4",
          "topic": "Currying",
          "level": "hard",
          "type": "code",
          "question": "Write a generic `curry` helper function that takes any function `func` and returns its curried version. The curried function should support calling with one argument at a time, or multiple arguments until all arguments are satisfied (based on `func.length`).\n\n```javascript\n// Your curry function here\n\nconst sum = (a, b, c) => a + b + c;\nconst curriedSum = curry(sum);\n\nconsole.log(curriedSum(1)(2)(3));   // Should output 6\nconsole.log(curriedSum(1, 2)(3));   // Should output 6\nconsole.log(curriedSum(1)(2, 3));   // Should output 6\nconsole.log(curriedSum(1, 2, 3));   // Should output 6\n```",
          "answer": "```javascript\nfunction curry(func) {\n  // `func.length` gives the number of arguments the function expects\n  return function curried(...args) {\n    // If enough arguments are gathered, execute the original function\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    } else {\n      // Otherwise, return a new function that expects more arguments\n      // It concatenates the new arguments with the previously gathered ones\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      };\n    }\n  };\n}\n\nconst sum = (a, b, c) => a + b + c;\nconst curriedSum = curry(sum);\n\nconsole.log(curriedSum(1)(2)(3));   // 6\nconsole.log(curriedSum(1, 2)(3));   // 6\nconsole.log(curriedSum(1)(2, 3));   // 6\nconsole.log(curriedSum(1, 2, 3));   // 6\n\n// Example with a different function\nconst greet = (greeting, name) => `${greeting}, ${name}!`;\nconst curriedGreet = curry(greet);\n\nconsole.log(curriedGreet('Hello')('John')); // Hello, John!\nconsole.log(curriedGreet('Hi', 'Jane'));   // Hi, Jane!\n```",
          "analysisPoints": [
            "Correctly uses recursion or a loop to collect arguments.",
            "Leverages `func.length` to determine when to execute the original function.",
            "Handles `this` context correctly (using `apply` or arrow functions).",
            "Supports both single and multiple arguments per call."
          ],
          "keyConcepts": [
            "Currying",
            "Higher-Order Functions",
            "Recursion",
            "Closures",
            "Rest Parameters",
            "Spread Syntax"
          ],
          "evaluationCriteria": [
            "Functional correctness of the `curry` helper.",
            "Robustness to various argument passing styles.",
            "Efficiency and clarity of the implementation."
          ],
          "example": null,
          "tags": [
            "Currying",
            "Higher-Order Functions",
            "Functional Programming",
            "Coding Challenge"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_closures",
            "javascript_rest_spread"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_currying_5",
          "topic": "Currying",
          "level": "easy",
          "type": "flashcard",
          "question": "True or False: Currying necessarily means a function takes arguments one at a time.",
          "answer": "True",
          "analysisPoints": [
            "Reinforces the strict definition of currying vs. partial application."
          ],
          "keyConcepts": [
            "Currying",
            "Partial Application"
          ],
          "evaluationCriteria": [
            "Accuracy of fundamental definition."
          ],
          "example": null,
          "tags": [
            "Currying",
            "Definition"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_memoization_1",
          "topic": "Memoization",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary goal of memoization?",
          "answer": "To optimize the performance of functions by caching their results.",
          "analysisPoints": [
            "Core purpose of memoization."
          ],
          "keyConcepts": [
            "Memoization",
            "Optimization",
            "Caching"
          ],
          "evaluationCriteria": [
            "Recall of primary goal."
          ],
          "example": null,
          "tags": [
            "Memoization",
            "Optimization"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_memoization_2",
          "topic": "Memoization",
          "level": "medium",
          "type": "mcq",
          "question": "Which type of function is best suited for memoization?",
          "answer": "Pure functions that perform expensive computations and are frequently called with the same inputs.",
          "options": [
            "Functions that have side effects and modify external state.",
            "Functions that rely heavily on random number generation.",
            "Functions that perform frequent I/O operations (e.g., fetching data from a server).",
            "Pure functions that perform expensive computations and are frequently called with the same inputs."
          ],
          "analysisPoints": [
            "Understanding the prerequisites for effective memoization (purity, expense, recurring inputs).",
            "Excluding scenarios where memoization is not suitable (side effects, non-deterministic, I/O)."
          ],
          "keyConcepts": [
            "Memoization",
            "Pure Functions",
            "Performance",
            "Caching"
          ],
          "evaluationCriteria": [
            "Knowledge of ideal memoization candidates.",
            "Ability to identify unsuitable functions."
          ],
          "example": "Memoization works best with pure functions because their output is solely determined by their inputs, making caching reliable. Expensive computations benefit most, and frequent calls with identical inputs ensure the cache is utilized often.\n\n```javascript\n// Good candidate: pure, expensive, potentially repetitive calls\nfunction calculateFactorial(n) {\n  if (n === 0 || n === 1) return 1;\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\n// Bad candidate: side effect\nlet globalCounter = 0;\nfunction incrementAndReturn(n) {\n  globalCounter++;\n  return n + 1;\n}\n// Memoizing this would lead to globalCounter not incrementing on cache hits.\n```",
          "tags": [
            "Memoization",
            "Pure Functions",
            "Optimization"
          ],
          "prerequisites": [
            "javascript_functions",
            "functional_programming_concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_memoization_3",
          "topic": "Memoization",
          "level": "medium",
          "type": "open",
          "question": "Explain the trade-off involved when using memoization. When might memoization be counterproductive?",
          "answer": "The primary trade-off with memoization is **memory consumption versus computational speed**. While memoization reduces re-computation time by storing results, it consumes memory to maintain the cache.\n\n**Counterproductive scenarios:**\n1.  **Functions with few repeated calls / highly unique inputs**: If a function is rarely called with the same inputs, the overhead of managing the cache (checking, storing) might outweigh the benefit of avoiding re-computation. The cache would mostly store unique results that are never reused.\n2.  **Small / Inexpensive Computations**: For very fast functions, the overhead of cache lookup and key generation might be greater than the time saved by avoiding re-execution, making memoization a net negative for performance.\n3.  **Functions with Complex Object Arguments**: Generating unique and reliable cache keys for complex objects or functions (e.g., using `JSON.stringify` on objects with non-deterministic key order, or functions as arguments) can be tricky and inefficient. Deep equality checks or custom hashing can be expensive.\n4.  **Functions with Side Effects / Non-deterministic Output**: Memoizing functions that have side effects (e.g., modifying global state, making network requests) or return different results for the same input (e.g., `Math.random()`, `Date.now()`) will lead to incorrect or unexpected behavior because the side effects won't re-occur on cache hits, and the non-deterministic output won't be re-calculated.",
          "analysisPoints": [
            "Identifies the memory-speed trade-off.",
            "Lists multiple scenarios where memoization is inappropriate or detrimental.",
            "Explains the reasons behind each counterproductive scenario."
          ],
          "keyConcepts": [
            "Memoization",
            "Trade-offs",
            "Performance Optimization",
            "Pure Functions",
            "Caching"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of memoization's limitations.",
            "Ability to articulate when to avoid it.",
            "Clarity of explanation."
          ],
          "example": null,
          "tags": [
            "Memoization",
            "Optimization",
            "Trade-offs",
            "Performance"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_memoization_4",
          "topic": "Memoization",
          "level": "hard",
          "type": "code",
          "question": "Implement a `memoize` higher-order function that can memoize any single-argument function. Test it with a recursive Fibonacci function. Your memoization function should handle cases where `fn` might be called with `this` context.\n\n```javascript\nfunction memoize(fn) {\n  // Your implementation here\n}\n\n// Test with Fibonacci\nfunction fib(n) {\n  // Simulate heavy computation\n  for (let i = 0; i < 100000; i++) {}; \n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\nconst memoizedFib = memoize(fib);\n\nconsole.time('fib 15 (no memo)');\nfib(15);\nconsole.timeEnd('fib 15 (no memo)');\n\nconsole.time('memoizedFib 15 (first call)');\nmemoizedFib(15);\nconsole.timeEnd('memoizedFib 15 (first call)');\n\nconsole.time('memoizedFib 15 (second call)');\nmemoizedFib(15);\nconsole.timeEnd('memoizedFib 15 (second call)');\n```\n\nExpected output should show a significant time difference between `memoizedFib 15 (first call)` and `memoizedFib 15 (second call)`.",
          "answer": "```javascript\nfunction memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    // For a single argument, the arg itself can be the key.\n    // For multiple arguments, JSON.stringify or a more complex key generation is needed.\n    const key = args[0]; \n\n    if (cache[key] !== undefined) {\n      // console.log(`Cache hit for ${key}`);\n      return cache[key];\n    } else {\n      // console.log(`Cache miss for ${key}, calculating...`);\n      // Use apply to correctly pass arguments and preserve 'this' context\n      const result = fn.apply(this, args);\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n\n// Test with Fibonacci\nfunction fib(n) {\n  // Simulate heavy computation\n  for (let i = 0; i < 100000; i++) {}; // Simulate work\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\nconst memoizedFib = memoize(fib);\n\nconsole.time('fib 15 (no memo)');\nfib(15);\nconsole.timeEnd('fib 15 (no memo)');\n\nconsole.time('memoizedFib 15 (first call)');\nmemoizedFib(15);\nconsole.timeEnd('memoizedFib 15 (first call)');\n\nconsole.time('memoizedFib 15 (second call)');\nmemoizedFib(15);\nconsole.timeEnd('memoizedFib 15 (second call)');\n\n// Expected behavior:\n// fib 15 (no memo): ~[high time]\n// memoizedFib 15 (first call): ~[high time]\n// memoizedFib 15 (second call): ~[very low time]\n```",
          "analysisPoints": [
            "Correctly implements a higher-order `memoize` function.",
            "Uses a cache (e.g., object or Map).",
            "Generates a suitable cache key (simple for single argument, or `JSON.stringify` for multiple/complex).",
            "Correctly applies the original function using `fn.apply(this, args)` to preserve `this`.",
            "Demonstrates performance improvement with `console.time`."
          ],
          "keyConcepts": [
            "Memoization",
            "Higher-Order Functions",
            "Caching",
            "Performance Optimization",
            "Pure Functions",
            "this",
            "apply"
          ],
          "evaluationCriteria": [
            "Functional correctness of memoization logic.",
            "Efficiency improvement demonstration.",
            "Handling of `this` context.",
            "Appropriate use of `console.time` for benchmarking."
          ],
          "example": null,
          "tags": [
            "Memoization",
            "Optimization",
            "Coding Challenge",
            "Higher-Order Functions"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "javascript_closures",
            "theory_function_borrowing"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_memoization_5",
          "topic": "Memoization",
          "level": "easy",
          "type": "flashcard",
          "question": "What data structure is commonly used to store cached results in a memoized function?",
          "answer": "An object or a Map.",
          "analysisPoints": [
            "Common implementation details of memoization."
          ],
          "keyConcepts": [
            "Memoization",
            "Cache",
            "Object",
            "Map"
          ],
          "evaluationCriteria": [
            "Recall of common data structures."
          ],
          "example": null,
          "tags": [
            "Memoization",
            "Data Structures"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_iife_1",
          "title": "Create a User Management IIFE Module",
          "description": "\nImplement a JavaScript module using an Immediately Invoked Function Expression (IIFE) for basic user management. This module should keep user data private and expose only public methods to interact with it.\n\n**Requirements:**\n1.  The module should be encapsulated within an IIFE.\n2.  Maintain a private array `_users` to store user objects (e.g., `{ id: 1, name: 'Alice' }`).\n3.  Expose the following public methods:\n    *   `addUser(userObject)`: Adds a new user to the `_users` array. Assigns a unique `id` (e.g., incrementing counter) if not provided.\n    *   `getUserById(id)`: Returns the user object with the matching `id`, or `undefined` if not found.\n    *   `getAllUsers()`: Returns a *copy* of the `_users` array to prevent external modification.\n    *   `removeUser(id)`: Removes the user with the specified `id` from the array.\n4.  Ensure all internal variables and the `_users` array are not accessible from the global scope.\n",
          "difficulty": "medium",
          "startingCode": "const userManager = (function() {\n  let _nextId = 1; // Private counter for user IDs\n  let _users = []; // Private array to store users\n\n  return {\n    // Implement addUser, getUserById, getAllUsers, removeUser here\n  };\n})();\n\n// Example Usage (for testing your implementation):\n// userManager.addUser({ name: 'Alice' });\n// userManager.addUser({ name: 'Bob' });\n// console.log('All Users:', userManager.getAllUsers());\n// console.log('User with ID 1:', userManager.getUserById(1));\n// userManager.removeUser(1);\n// console.log('All Users after removal:', userManager.getAllUsers());\n// console.log('Attempting to access private _users:', userManager._users); // Should be undefined",
          "solutionCode": "const userManager = (function() {\n  let _nextId = 1;\n  let _users = [];\n\n  return {\n    addUser: function(userObject) {\n      if (!userObject || typeof userObject !== 'object' || !userObject.name) {\n        console.error('Invalid user object. Must have a name.');\n        return;\n      }\n      const newUser = { ...userObject, id: userObject.id || _nextId++ };\n      _users.push(newUser);\n      console.log(`User added: ${newUser.name} (ID: ${newUser.id})`);\n      return newUser;\n    },\n\n    getUserById: function(id) {\n      return _users.find(user => user.id === id);\n    },\n\n    getAllUsers: function() {\n      // Return a shallow copy to prevent direct modification of the private array\n      return [..._users]; \n    },\n\n    removeUser: function(id) {\n      const initialLength = _users.length;\n      _users = _users.filter(user => user.id !== id);\n      if (_users.length < initialLength) {\n        console.log(`User with ID ${id} removed.`);\n        return true;\n      } else {\n        console.warn(`User with ID ${id} not found.`);\n        return false;\n      }\n    }\n  };\n})();\n\n// Test cases\nconsole.log('--- Initial State ---');\nconsole.log('Users:', userManager.getAllUsers());\n\nconsole.log('\\n--- Adding Users ---');\nuserManager.addUser({ name: 'Alice' });\nuserManager.addUser({ name: 'Bob', id: 10 }); // Custom ID\nuserManager.addUser({ name: 'Charlie' });\nconsole.log('All Users:', userManager.getAllUsers());\n\nconsole.log('\\n--- Getting User by ID ---');\nconst alice = userManager.getUserById(1);\nconsole.log('User 1:', alice); // { id: 1, name: 'Alice' }\nconst bob = userManager.getUserById(10);\nconsole.log('User 10:', bob); // { id: 10, name: 'Bob' }\nconst nonExistent = userManager.getUserById(99);\nconsole.log('User 99:', nonExistent); // undefined\n\nconsole.log('\\n--- Removing Users ---');\nuserManager.removeUser(1);\nuserManager.removeUser(99); // Non-existent\nconsole.log('All Users after removals:', userManager.getAllUsers());\n\nconsole.log('\\n--- Testing Privacy ---');\nconst exposedUsers = userManager.getAllUsers();\nexposedUsers.push({ id: 999, name: 'Evil User' }); // This should only modify the copy\nconsole.log('Original private users after external push attempt:', userManager.getAllUsers()); // Should not contain 'Evil User'\n// console.log(userManager._users); // This would cause an error if uncommented (good!)",
          "testCases": [
            "Adding users with and without custom IDs.",
            "Retrieving existing and non-existing users by ID.",
            "Removing existing and non-existing users by ID.",
            "Verifying that `getAllUsers()` returns a copy, not the original private array.",
            "Ensuring private variables (`_nextId`, `_users`) are not globally accessible."
          ],
          "hints": [
            "Remember to use `let` or `const` inside the IIFE for private variables.",
            "The `id` for new users can be a simple incrementing counter.",
            "When returning the array of all users, make sure to return a *copy* to maintain encapsulation. `[...array]` or `array.slice()` can create a shallow copy.",
            "Consider edge cases for `addUser` (e.g., null/invalid user objects) and `removeUser` (user not found)."
          ],
          "tags": [
            "IIFE",
            "Module Pattern",
            "Encapsulation",
            "Data Privacy",
            "Closures",
            "Frontend Architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_functions",
            "javascript_scope",
            "javascript_arrays",
            "javascript_objects"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "module_pattern",
            "closures",
            "data_hiding"
          ]
        },
        {
          "id": "task_this_1",
          "title": "Build a Simple Carousel Component with 'this' Management",
          "description": "\nCreate a basic JavaScript carousel component that manages its internal state (current slide index) and handles user interactions (next/previous buttons). This task specifically focuses on correctly managing the `this` context within event listeners.\n\n**Requirements:**\n1.  Create a `Carousel` class or constructor function.\n2.  The `Carousel` should have a `currentIndex` property, initialized to 0.\n3.  It should accept an array of `slides` (strings or URLs) in its constructor.\n4.  It should have methods: `nextSlide()`, `prevSlide()`, and `render()`.\n5.  `render()` should create DOM elements for the carousel (e.g., a container, image/text display, and 'Next'/'Prev' buttons). Append these to `document.body`.\n6.  Attach `click` event listeners to the 'Next' and 'Prev' buttons.\n7.  **Crucially**, ensure that `this` inside the event listener callbacks correctly refers to the `Carousel` instance, allowing `this.currentIndex` to be updated and `this.slides` to be accessed.\n8.  Update the displayed slide when buttons are clicked.\n\n**Constraints:**\n*   Do not use arrow functions for the `nextSlide()` and `prevSlide()` methods themselves.\n*   You *must* use either `.bind()` or an arrow function directly in the `addEventListener` call to manage `this` context.\n",
          "difficulty": "hard",
          "startingCode": "class Carousel {\n  constructor(slides) {\n    this.slides = slides; // Array of slide content\n    this.currentIndex = 0;\n\n    // DOM elements\n    this.container = document.createElement('div');\n    this.display = document.createElement('div');\n    this.prevBtn = document.createElement('button');\n    this.nextBtn = document.createElement('button');\n\n    this.prevBtn.textContent = 'Previous';\n    this.nextBtn.textContent = 'Next';\n    this.container.appendChild(this.prevBtn);\n    this.container.appendChild(this.display);\n    this.container.appendChild(this.nextBtn);\n    document.body.appendChild(this.container);\n\n    this.updateDisplay(); // Initial display\n\n    // TODO: Attach event listeners to prevBtn and nextBtn\n    // Ensure 'this' in the event handler correctly refers to the Carousel instance.\n    // e.g., this.prevBtn.addEventListener('click', this.prevSlide.YOUR_BINDING_METHOD_HERE);\n  }\n\n  updateDisplay() {\n    this.display.textContent = `Slide ${this.currentIndex + 1}: ${this.slides[this.currentIndex]}`;\n  }\n\n  nextSlide() {\n    this.currentIndex = (this.currentIndex + 1) % this.slides.length;\n    this.updateDisplay();\n    console.log('Next clicked, current index:', this.currentIndex);\n  }\n\n  prevSlide() {\n    this.currentIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;\n    this.updateDisplay();\n    console.log('Prev clicked, current index:', this.currentIndex);\n  }\n}\n\n// Example usage:\n// const myCarousel = new Carousel(['Image 1', 'Image 2', 'Image 3']);\n",
          "solutionCode": "class Carousel {\n  constructor(slides) {\n    this.slides = slides;\n    this.currentIndex = 0;\n\n    this.container = document.createElement('div');\n    this.container.style.border = '1px solid black';\n    this.container.style.padding = '10px';\n    this.container.style.margin = '20px';\n    this.container.style.textAlign = 'center';\n\n    this.display = document.createElement('div');\n    this.display.style.fontSize = '24px';\n    this.display.style.minHeight = '50px';\n    this.display.style.lineHeight = '50px';\n    this.display.style.borderBottom = '1px solid #ccc';\n    this.display.style.marginBottom = '10px';\n\n    this.prevBtn = document.createElement('button');\n    this.nextBtn = document.createElement('button');\n\n    this.prevBtn.textContent = 'Previous';\n    this.nextBtn.textContent = 'Next';\n    this.prevBtn.style.marginRight = '10px';\n\n    this.container.appendChild(this.prevBtn);\n    this.container.appendChild(this.display);\n    this.container.appendChild(this.nextBtn);\n    document.body.appendChild(this.container);\n\n    this.updateDisplay();\n\n    // Method 1: Using .bind(this) to ensure 'this' refers to the Carousel instance\n    this.nextBtn.addEventListener('click', this.nextSlide.bind(this));\n    this.prevBtn.addEventListener('click', this.prevSlide.bind(this));\n\n    // Method 2: Using an arrow function directly in addEventListener\n    // this.nextBtn.addEventListener('click', () => this.nextSlide());\n    // this.prevBtn.addEventListener('click', () => this.prevSlide());\n  }\n\n  updateDisplay() {\n    if (this.slides.length === 0) {\n      this.display.textContent = 'No slides available.';\n      return;\n    }\n    this.display.textContent = `Slide ${this.currentIndex + 1}: ${this.slides[this.currentIndex]}`;\n  }\n\n  nextSlide() {\n    // Ensure 'this' refers to the Carousel instance here\n    this.currentIndex = (this.currentIndex + 1) % this.slides.length;\n    this.updateDisplay();\n    console.log('Next clicked, current index:', this.currentIndex);\n  }\n\n  prevSlide() {\n    // Ensure 'this' refers to the Carousel instance here\n    this.currentIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;\n    this.updateDisplay();\n    console.log('Prev clicked, current index:', this.currentIndex);\n  }\n}\n\n// Example usage:\nconst mySlides = ['Hello from Slide 1!', 'This is Slide 2.', 'Final Slide 3.'];\nconst myCarousel = new Carousel(mySlides);\n\n// Test with empty slides\nconst emptyCarousel = new Carousel([]);\n",
          "testCases": [
            "Initialize with a few slides and verify initial display.",
            "Click 'Next' multiple times and verify slide change and wrap-around.",
            "Click 'Previous' multiple times and verify slide change and wrap-around.",
            "Verify `this.currentIndex` updates correctly after each click.",
            "Test with an empty `slides` array to ensure graceful handling.",
            "Verify that `this` inside `nextSlide` and `prevSlide` correctly refers to the `Carousel` instance."
          ],
          "hints": [
            "When `addEventListener` invokes a callback, `this` inside that callback usually refers to the DOM element (`button` in this case).",
            "To preserve the `this` context of your `Carousel` instance, you can use `this.nextSlide.bind(this)` or wrap the call in an arrow function `() => this.nextSlide()`.",
            "Remember to handle the wrap-around logic for `currentIndex` using the modulo operator (`%`) for `next` and a slightly modified calculation for `prev` to ensure it always stays positive."
          ],
          "tags": [
            "this",
            "Event Handling",
            "Bind",
            "Arrow Functions",
            "Classes",
            "DOM Manipulation",
            "Frontend Component"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing",
            "javascript_classes",
            "dom_manipulation"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "event_delegation",
            "component_architecture",
            "state_management"
          ]
        },
        {
          "id": "task_borrowing_1",
          "title": "Create a Flexible Logger with Function Borrowing",
          "description": "\nBuild a `Logger` utility that can be used to log messages to different output targets (e.g., console, a DOM element) using function borrowing techniques (`call`, `apply`, `bind`).\n\n**Requirements:**\n1.  Create a base `logger` object with a `logMessage` method:\n    ```javascript\n    const baseLogger = {\n      logMessage: function(prefix, message) {\n        console.log(`${prefix} ${message}`);\n      }\n    };\n    ```\n2.  Create a `consoleLogger` object that uses `baseLogger.logMessage` to log to the console, always prepending `[CONSOLE]`. Use `bind` for this.\n3.  Create a `domLogger` object. Its `logMessage` method should append messages to a specific DOM element (e.g., a `div` with `id=\"log-output\"`). It should prepend `[DOM]`. Use `call` or `apply` within this method to invoke `baseLogger.logMessage` (or a variation of it) with `[DOM]` prefix, but direct its output to the DOM.\n4.  Demonstrate usage of both loggers. Also, show how to use `baseLogger.logMessage` directly with `call` or `apply` for a one-off log with a custom prefix and context.\n\n**HTML Structure (you can assume this exists):**\n```html\n<div id=\"log-output\"></div>\n```\n",
          "difficulty": "hard",
          "startingCode": "const baseLogger = {\n  logMessage: function(prefix, message) {\n    // This method needs to be flexible enough to be 'borrowed'\n    // It will be invoked with different 'this' contexts and prefixes\n    // For this task, assume 'this' might refer to the actual output target or just be 'null'\n    // and we'll focus on passing the output string directly.\n    // console.log(`${prefix} ${message}`); // Default console behavior\n    \n    // For the DOM logger, we'll need to know where to append. \n    // Let's modify baseLogger slightly to be more generic, or assume \n    // the borrowing function will handle the actual output channel.\n    \n    // Revised baseLogger to return the formatted string, letting the caller handle output\n    formatMessage: function(prefix, message) {\n      return `${prefix} ${new Date().toLocaleTimeString()}: ${message}`;\n    }\n};\n\n// TODO: Implement consoleLogger using bind\nconst consoleLogger = {}; // Fill this in\n\n// TODO: Implement domLogger using call/apply within its method\nconst domLogger = {\n  outputElement: document.getElementById('log-output'),\n  log: function(message) {\n    // Use call/apply here to format the message using baseLogger.formatMessage\n    // Then append to this.outputElement\n  }\n};\n\n// Example Usage (for testing your implementation):\n// consoleLogger.log('Application started');\n// domLogger.log('DOM updated');\n// baseLogger.formatMessage.call(null, '[DIRECT]', 'One-off log');\n",
          "solutionCode": "const baseLogger = {\n  // This method just formats the message, leaving output channel flexible\n  formatMessage: function(prefix, message) {\n    const timestamp = new Date().toLocaleTimeString();\n    return `${prefix} ${timestamp}: ${message}`;\n  }\n};\n\n// 1. Console Logger using bind\n// We bind baseLogger.formatMessage to null (no specific 'this' needed for formatting) \n// and partially apply '[CONSOLE]' as the first argument (prefix).\n// The returned function then only needs the 'message' argument.\nconst consoleLogger = {\n  log: baseLogger.formatMessage.bind(null, '[CONSOLE]'),\n  // This is a simple wrapper, the actual console.log happens here:\n  // The `log` method calls the bound `formatMessage` and then prints it.\n  // A more direct bind would be if baseLogger.logMessage itself did the console.log.\n  // Let's adjust to make it more direct application of bind:\n};\n\n// Revised Console Logger to directly use baseLogger's logMessage functionality if it existed\n// For this example, we make a simple log method and use the formatted message.\nconst consoleOutputLogger = {\n  log: function(message) {\n    console.log(baseLogger.formatMessage('[CONSOLE]', message));\n  }\n};\n\n// 2. DOM Logger using call/apply\nconst domOutputElement = document.createElement('div');\ndomOutputElement.id = 'log-output';\ndomOutputElement.style.border = '1px dashed grey';\ndomOutputElement.style.margin = '10px';\ndomOutputElement.style.padding = '5px';\ndocument.body.appendChild(domOutputElement);\n\nconst domLogger = {\n  outputElement: domOutputElement,\n  log: function(message) {\n    // Use `call` to invoke baseLogger.formatMessage with its context set to null\n    // and pass the prefix '[DOM]' and the 'message' as individual arguments.\n    const formatted = baseLogger.formatMessage.call(null, '[DOM]', message);\n    \n    const p = document.createElement('p');\n    p.textContent = formatted;\n    this.outputElement.appendChild(p); // 'this' here refers to domLogger\n  }\n};\n\n// Example Usage:\nconsole.log('--- Using Loggers ---');\nconsoleOutputLogger.log('Application started successfully.');\ndomLogger.log('DOM logger initialized.');\ndomLogger.log('New item added to list.');\nconsoleOutputLogger.log('Background process completed.');\n\nconsole.log('\\n--- Direct Function Borrowing (One-off) ---');\n// Using .call() for a one-off log to console with a custom prefix\nconsole.log(baseLogger.formatMessage.call(null, '[CUSTOM]', 'This is a direct call message.'));\n\n// Using .apply() for a one-off log with arguments in an array\nconst argsForApply = ['[APPLY]', 'This message came via apply.'];\nconsole.log(baseLogger.formatMessage.apply(null, argsForApply));\n",
          "testCases": [
            "Verify consoleLogger logs messages with `[CONSOLE]` prefix to the console.",
            "Verify domLogger logs messages with `[DOM]` prefix to the specified DOM element.",
            "Check that messages include timestamps.",
            "Ensure `baseLogger.formatMessage.call(null, ...)` works for direct, one-off formatting.",
            "Ensure `baseLogger.formatMessage.apply(null, [...])` works for direct, one-off formatting with an array of arguments."
          ],
          "hints": [
            "For the `consoleLogger`, you can use `bind` to create a new function that always calls `baseLogger.formatMessage` with `[CONSOLE]` as its first argument. Then, wrap this bound function in another function to actually call `console.log`.",
            "For the `domLogger`, inside its `log` method, you'll need to use `baseLogger.formatMessage.call(null, '[DOM]', message)` to get the formatted string. Then, append this string to `this.outputElement`.",
            "Remember to assume the `div#log-output` element exists in the HTML.",
            "The `this` context for `baseLogger.formatMessage` itself doesn't need to be `logger` in this setup, so `null` or `undefined` can be passed as the `thisArg` for `call` and `apply`."
          ],
          "tags": [
            "Function Borrowing",
            "Call",
            "Apply",
            "Bind",
            "this",
            "Logger",
            "DOM Manipulation",
            "Frontend Architecture"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_function_borrowing",
            "theory_function_context_this",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "higher_order_functions",
            "design_patterns"
          ]
        },
        {
          "id": "task_currying_1",
          "title": "Implement a Curried Form Validator",
          "description": "\nCreate a flexible form validation system using currying. You will implement a `validator` function that can be partially applied to create specific validation rules, which can then be applied to input values.\n\n**Requirements:**\n1.  Create a curried `validator` function with the signature `validator(rule)(message)(value)`.\n    *   `rule`: A function that takes a `value` and returns `true` if valid, `false` otherwise.\n    *   `message`: The error message string to return if validation fails.\n    *   `value`: The input value to validate.\n    *   The `validator` should return `true` if `rule(value)` is `true`, otherwise it should return the `message`.\n\n2.  Create specific curried validation functions using `validator`:\n    *   `isRequired`: Checks if a string `value` is not empty. Returns \"Field is required\" if empty.\n    *   `minLength(length)`: A curried function that checks if a string `value` has at least `length` characters. Returns \"Must be at least X characters\" if too short.\n    *   `isEmail`: Checks if a string `value` is a valid email format. Returns \"Invalid email format\" if not.\n\n3.  Demonstrate the usage of these curried validators with example input values.\n",
          "difficulty": "hard",
          "startingCode": "// 1. Implement the curried validator function\nfunction validator(rule) {\n  return function(message) {\n    return function(value) {\n      // Your logic here\n    };\n  };\n}\n\n// 2. Define rule functions\nconst notEmpty = (str) => str && str.trim() !== '';\nconst isEmailPattern = (email) => /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/.test(email);\n\n// 3. Create specific curried validators using `validator`\nconst isRequired = validator(notEmpty)('Field is required');\n\nfunction minLength(minLen) {\n  // This needs to return a curried function based on validator\n  // Hint: You'll need to define the rule function inline or separately.\n  return validator((value) => value.length >= minLen)(`Must be at least ${minLen} characters`);\n}\n\nconst isEmail = validator(isEmailPattern)('Invalid email format');\n\n// Example Usage (for testing):\n// console.log('Required field (valid):', isRequired('hello'));\n// console.log('Required field (invalid):', isRequired(''));\n// console.log('Min length 5 (valid):', minLength(5)('testing'));\n// console.log('Min length 5 (invalid):', minLength(5)('test'));\n// console.log('Email (valid):', isEmail('test@example.com'));\n// console.log('Email (invalid):', isEmail('invalid-email'));\n",
          "solutionCode": "// 1. Implement the curried validator function\nfunction validator(rule) {\n  return function(message) {\n    return function(value) {\n      if (rule(value)) {\n        return true; // Valid\n      } else {\n        return message; // Invalid, return error message\n      }\n    };\n  };\n}\n\n// 2. Define base rule functions (pure functions returning boolean)\nconst notEmpty = (str) => str && str.trim() !== '';\nconst isEmailPattern = (email) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(email);\n\n// 3. Create specific curried validators using `validator`\n// Basic rules (message is fixed)\nconst isRequired = validator(notEmpty)('Field is required');\nconst isEmail = validator(isEmailPattern)('Invalid email format');\n\n// Rule with a parameter (minLength), so it's a function returning a curried validator\nconst minLength = (minLen) => {\n  const ruleFn = (value) => value && value.length >= minLen;\n  return validator(ruleFn)(`Must be at least ${minLen} characters`);\n};\n\n// Optional: max Length example\nconst maxLength = (maxLen) => {\n  const ruleFn = (value) => value && value.length <= maxLen;\n  return validator(ruleFn)(`Cannot exceed ${maxLen} characters`);\n};\n\n// Example Usage:\nconsole.log('--- isRequired ---');\nconsole.log('Valid (hello):', isRequired('hello'));    // true\nconsole.log('Invalid (empty):', isRequired(''));       // Field is required\nconsole.log('Invalid (whitespace):', isRequired('   ')); // Field is required\n\nconsole.log('\\n--- minLength(5) ---');\nconst checkMinLength5 = minLength(5);\nconsole.log('Valid (testing):', checkMinLength5('testing')); // true\nconsole.log('Invalid (test):', checkMinLength5('test'));    // Must be at least 5 characters\nconsole.log('Valid (abcde):', checkMinLength5('abcde'));  // true\n\nconsole.log('\\n--- isEmail ---');\nconsole.log('Valid (test@example.com):', isEmail('test@example.com')); // true\nconsole.log('Invalid (invalid-email):', isEmail('invalid-email'));  // Invalid email format\nconsole.log('Invalid (no @):', isEmail('testexample.com')); // Invalid email format\nconsole.log('Invalid (empty):', isEmail('')); // Invalid email format (because notEmpty is not part of this specific email rule)\n\nconsole.log('\\n--- Chaining Validators (Conceptual) ---');\n// In a real system, you'd apply a list of validators to an input\nconst usernameValidators = [\n  isRequired,\n  minLength(3),\n  maxLength(10)\n];\n\nfunction validateInput(value, validators) {\n  for (const validatorFn of validators) {\n    const result = validatorFn(value);\n    if (result !== true) {\n      return result; // Return first error message\n    }\n  }\n  return true; // All good\n}\n\nconsole.log('Validate Username \"john\":', validateInput('john', usernameValidators)); // true\nconsole.log('Validate Username \"jo\":', validateInput('jo', usernameValidators));   // Must be at least 3 characters\nconsole.log('Validate Username \"johndoesnotfit\":', validateInput('johndoesnotfit', usernameValidators)); // Cannot exceed 10 characters\nconsole.log('Validate Username \"\":', validateInput('', usernameValidators));     // Field is required\n",
          "testCases": [
            "Test `isRequired` with empty, whitespace, and valid strings.",
            "Test `minLength` with strings shorter, equal to, and longer than the specified length.",
            "Test `isEmail` with valid and invalid email formats (missing '@', missing domain, etc.).",
            "Ensure the `validator` function correctly returns `true` or the error `message`.",
            "Verify that `minLength` is correctly curried and accepts its length parameter first."
          ],
          "hints": [
            "Remember that currying means each function in the sequence takes only one argument.",
            "The `rule` argument of your `validator` should be a function that returns a boolean.",
            "When implementing `minLength`, the outer function `minLength(len)` needs to *return* the result of calling `validator(rule)(message)` where `rule` itself is a function that checks the length against `len`."
          ],
          "tags": [
            "Currying",
            "Functional Programming",
            "Validation",
            "Higher-Order Functions",
            "Frontend Development"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_currying",
            "javascript_functions",
            "javascript_closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "functional_composition",
            "pipeline_pattern",
            "higher_order_components"
          ]
        },
        {
          "id": "task_memoization_1",
          "title": "Implement a Memoized Calculator for Expensive Operations",
          "description": "\nCreate a memoized version of a computationally expensive function. This task will test your understanding of memoization, cache management, and performance optimization.\n\n**Requirements:**\n1.  Implement a generic `memoize` higher-order function:\n    ```javascript\n    function memoize(func) {\n      // Your implementation here\n    }\n    ```\n    *   It should take any function `func` as an argument.\n    *   It should return a new, memoized version of `func`.\n    *   The memoized function should store results in a `cache` (e.g., a JavaScript `Object` or `Map`).\n    *   For the cache key, assume arguments are primitive (numbers, strings, booleans). If multiple arguments are present, concatenate them or use `JSON.stringify` for simplicity.\n    *   Ensure the `this` context is correctly preserved when the original function `func` is called from within the memoized wrapper.\n\n2.  Apply `memoize` to a computationally expensive function:\n    *   `calculateHeavySum(n)`: This function should simulate a heavy computation (e.g., a loop from 0 to `n * 1000000`) and then return the sum of numbers from 1 to `n`.\n\n3.  Demonstrate the performance improvement using `console.time` and `console.timeEnd`:\n    *   Call the original `calculateHeavySum` once.\n    *   Call the `memoizedHeavySum` once (first time, will compute).\n    *   Call the `memoizedHeavySum` again with the *same input* (should be from cache, much faster).\n    *   Call the `memoizedHeavySum` with a *different input* (should compute again).\n",
          "difficulty": "hard",
          "startingCode": "function memoize(func) {\n  const cache = {};\n  return function(...args) {\n    // TODO: Implement cache key generation\n    const key = JSON.stringify(args); // Simple approach for general arguments\n    \n    // TODO: Implement cache lookup and return cached result\n    \n    // TODO: If not in cache, compute result, store, and return\n    // Remember to preserve 'this' context when calling 'func'\n  };\n}\n\n// An expensive function to test memoization\nfunction calculateHeavySum(n) {\n  console.log(`Calculating heavy sum for ${n}...`);\n  // Simulate heavy computation\n  for (let i = 0; i < n * 1000000; i++) {}; \n  \n  // Actual calculation (sum of numbers up to n)\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\n// TODO: Apply memoize to calculateHeavySum\n// const memoizedHeavySum = memoize(calculateHeavySum);\n\n// TODO: Demonstrate performance with console.time\n// console.time('Original Call');\n// calculateHeavySum(100);\n// console.timeEnd('Original Call');\n\n// console.time('Memoized First Call');\n// memoizedHeavySum(100);\n// console.timeEnd('Memoized First Call');\n\n// console.time('Memoized Second Call (cached)');\n// memoizedHeavySum(100);\n// console.timeEnd('Memoized Second Call (cached)');\n\n// console.time('Memoized Different Call');\n// memoizedHeavySum(50);\n// console.timeEnd('Memoized Different Call');\n",
          "solutionCode": "function memoize(func) {\n  const cache = {}; // Using a simple object for cache\n\n  return function(...args) {\n    // A simple key for primitive arguments. For complex objects, \n    // a more sophisticated hashing or deep comparison would be needed.\n    const key = JSON.stringify(args); \n\n    if (cache[key] !== undefined) {\n      console.log(`Cache hit for args: ${key}`);\n      return cache[key];\n    } else {\n      console.log(`Cache miss for args: ${key}. Computing...`);\n      // Use apply to call the original function, preserving 'this' context\n      // and passing arguments as an array.\n      const result = func.apply(this, args);\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n\n// An expensive function to test memoization\nfunction calculateHeavySum(n) {\n  // Simulate heavy computation (e.g., 1 million iterations per 'n')\n  for (let i = 0; i < n * 1000000; i++) {}; \n  \n  // Actual calculation (sum of numbers up to n)\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\n// Apply memoize to calculateHeavySum\nconst memoizedHeavySum = memoize(calculateHeavySum);\n\n// Demonstrate performance\nconst testValue1 = 100;\nconst testValue2 = 50;\n\nconsole.log('\\n--- Original Function Calls ---');\nconsole.time(`Original Call (${testValue1})`);\ncalculateHeavySum(testValue1);\nconsole.timeEnd(`Original Call (${testValue1})`);\n\nconsole.time(`Original Call (${testValue2})`);\ncalculateHeavySum(testValue2);\nconsole.timeEnd(`Original Call (${testValue2})`);\n\nconsole.log('\\n--- Memoized Function Calls ---');\n\nconsole.time(`Memoized First Call (${testValue1})`);\nmemoizedHeavySum(testValue1);\nconsole.timeEnd(`Memoized First Call (${testValue1})`);\n\nconsole.time(`Memoized Second Call (cached) (${testValue1})`);\nmemoizedHeavySum(testValue1);\nconsole.timeEnd(`Memoized Second Call (cached) (${testValue1})`);\n\nconsole.time(`Memoized Different Call (${testValue2})`);\nmemoizedHeavySum(testValue2);\nconsole.timeEnd(`Memoized Different Call (${testValue2})`);\n\nconsole.time(`Memoized Cached Call (${testValue2})`);\nmemoizedHeavySum(testValue2);\nconsole.timeEnd(`Memoized Cached Call (${testValue2})`);\n\n// Example with a function that uses 'this'\nconst calculator = {\n  multiplier: 2,\n  multiplyAndAdd: function(a, b) {\n    for (let i = 0; i < 500000; i++) {}; // Simulate work\n    return (a + b) * this.multiplier;\n  }\n};\n\nconst memoizedMultiplyAndAdd = memoize(calculator.multiplyAndAdd);\n\nconsole.log('\\n--- Memoized Function with `this` Context ---');\nconsole.time('Memoized `this` first call (5, 10)');\nconsole.log(memoizedMultiplyAndAdd.call(calculator, 5, 10)); // Pass calculator as 'this' context\nconsole.timeEnd('Memoized `this` first call (5, 10)');\n\nconsole.time('Memoized `this` second call (5, 10)');\nconsole.log(memoizedMultiplyAndAdd.call(calculator, 5, 10)); // Cache hit\nconsole.timeEnd('Memoized `this` second call (5, 10)');\n\n// If `this` changes, it's a new call for simple keying, or the keying needs to incorporate `this`.\n// For this setup, we assume 'this' is part of the call but not part of the key unless explicitly added.\n// For full robustness, you might stringify `this` as part of the key, but it has implications.\n// console.time('Memoized `this` different context (5, 10)');\n// console.log(memoizedMultiplyAndAdd.call({ multiplier: 3 }, 5, 10)); // Different 'this'\n// console.timeEnd('Memoized `this` different context (5, 10)');\n",
          "testCases": [
            "Calling the memoized function multiple times with the same input to verify cache hits (significant time reduction).",
            "Calling the memoized function with new inputs to verify new computations.",
            "Verifying the correct result is returned from both calculations and cache hits.",
            "Testing a function that utilizes `this` to ensure the `this` context is correctly passed and preserved through `func.apply(this, args)`."
          ],
          "hints": [
            "An object (`{}`) or `Map` is suitable for the `cache`.",
            "For the cache `key`, `JSON.stringify(args)` is a simple way to create a unique string from an array of primitive arguments. Be aware of its limitations with non-primitive arguments (objects, functions, non-deterministic order of keys).",
            "When calling the original `func` inside the memoized wrapper, use `func.apply(this, args)` or `func.call(this, ...args)` to correctly pass the `this` context and arguments."
          ],
          "tags": [
            "Memoization",
            "Optimization",
            "Higher-Order Functions",
            "Performance",
            "Caching",
            "Functional Programming",
            "this"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_memoization",
            "javascript_functions",
            "javascript_closures",
            "javascript_objects",
            "theory_function_borrowing"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "dynamic_programming",
            "pure_functions",
            "performance_tuning"
          ]
        }
      ]
    }
  },
  {
    "id": "7de717d6-b9cc-4698-9f91-2dc19f734b4c",
    "startLine": 700,
    "endLine": 799,
    "processedDate": "2025-06-17T07:22:33.806Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_memoization",
          "title": "Memoization: Caching Function Results for Performance",
          "content": "Memoization is an optimization technique used to speed up computer programs by caching the results of expensive function calls and returning the cached result when the same inputs occur again. It's particularly useful for pure functions (functions that always produce the same output for the same input and have no side effects) and recursive functions where the same sub-problems are computed multiple times.\n\n### How Memoization Works\nAt its core, memoization involves:\n1.  **Caching**: Storing the function's output in a data structure (e.g., an object or Map) against its input arguments.\n2.  **Key Generation**: Creating a unique key from the function's arguments to store and retrieve results. For simple arguments, direct use might work, but for complex arguments (objects, arrays), serialization (like `JSON.stringify`) or custom hashing is often needed.\n3.  **Context Preservation**: Ensuring that the original function's `this` context is maintained when the function is actually executed (i.e., when a cache miss occurs).\n\n### Benefits\n-   **Performance Improvement**: Avoids redundant computations, significantly speeding up applications, especially for CPU-bound tasks.\n-   **Efficiency**: Reduces the workload on the system.\n\n### Considerations\n-   **Memory Usage**: Storing results consumes memory. For functions with many unique inputs, the cache can grow very large.\n-   **Pure Functions**: Most effective for pure functions. Memoizing functions with side effects or external dependencies can lead to stale results.\n-   **Argument Complexity**: Generating unique keys for complex arguments can be challenging and sometimes negate performance gains if the key generation itself is expensive.",
          "examples": [
            {
              "id": "example_memoization_1",
              "title": "Basic Memoization Implementation",
              "code": "function memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    // Create a unique key from arguments. JSON.stringify works for simple types.\n    // For complex objects, it might not be suitable if order or non-enumerable props matter.\n    const key = JSON.stringify(args);\n    if (cache[key]) {\n      console.log(`Fetching '${key}' from cache`);\n      return cache[key];\n    }\n    console.log(`Calculating result for '${key}'`);\n    // Use apply to ensure 'this' context is correctly passed if 'fn' relies on it.\n    const result = fn.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n\nconst factorial = memoize(function(n) {\n  if (n === 0 || n === 1) return 1;\n  return n * factorial(n - 1);\n});\n\nconsole.log(factorial(5)); // Calculating result, then 120\nconsole.log(factorial(5)); // Fetching from cache, then 120\nconsole.log(factorial(3)); // Calculating result, then 6\nconsole.log(factorial(3)); // Fetching from cache, then 6",
              "explanation": "This example demonstrates a `memoize` higher-order function. It takes a function `fn` and returns a new function. This new function checks a `cache` object before executing `fn`. If the result for the given arguments (`key`) is found in the cache, it's returned immediately. Otherwise, `fn` is executed, its result is stored in the cache, and then returned. `fn.apply(this, args)` is crucial here to ensure that if `fn` itself is a method of an object and relies on its `this` context, that context is correctly preserved.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_memoization_1",
            "question_memoization_2",
            "question_memoization_3",
            "question_memoization_4",
            "question_memoization_5"
          ],
          "relatedTasks": [
            "task_memoization_1"
          ],
          "tags": [
            "optimization",
            "performance",
            "caching",
            "higher-order functions",
            "closures"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures",
            "this_keyword",
            "function_apply_call_bind",
            "pure_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "dynamic_programming",
            "performance_optimization",
            "functional_programming"
          ]
        },
        {
          "id": "theory_generator_functions",
          "title": "Generator Functions: Iteration Control with Yield",
          "content": "Generator functions are a special type of function in JavaScript that can pause their execution, yield control to the caller, and then resume execution from where they left off. They are defined using `function*` syntax and use the `yield` keyword to produce a sequence of values.\n\n### Key Concepts\n-   **`function*`**: Declares a generator function.\n-   **`yield`**: Pauses the generator function's execution and sends a value back to the caller. When `next()` is called again, the generator resumes execution immediately after the `yield` statement.\n-   **Iterator Protocol**: Generator functions, when called, do not execute their body immediately. Instead, they return an `iterator` object (a Generator object). This iterator has a `next()` method.\n-   **`next()` Method**: Calling `next()` on the generator's iterator object resumes execution until the next `yield` expression or a `return` statement is encountered. It returns an object of the form `{ value: any, done: boolean }`. `done` is `true` when the generator has finished yielding all values.\n-   **Infinite Sequences**: Generators can be used to create potentially infinite sequences of values, as they compute values on demand.\n-   **`for...of` Loop**: The `for...of` loop is specifically designed to work with iterable objects, including generator functions, consuming their yielded values sequentially until `done` is `true`.\n\n### Use Cases\n-   **Lazy Evaluation**: Generate a sequence of values only when needed, which is memory-efficient for large or infinite sequences.\n-   **Asynchronous Programming**: Can simplify asynchronous code by allowing an `async` flow to be written in a synchronous-like manner (though `async/await` is now more common for this).\n-   **Custom Iterators**: Easily create custom iterators for complex data structures.\n-   **State Management**: Maintain internal state across multiple invocations.",
          "examples": [
            {
              "id": "example_generator_1",
              "title": "Basic ID Generator",
              "code": "function* idGenerator() {\n  let id = 1;\n  while (true) {\n    yield id++;\n  }\n}\n\nconst gen = idGenerator();\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // 3",
              "explanation": "This `idGenerator` function demonstrates an infinite generator. Each call to `gen.next().value` yields the next sequential ID, and the internal `id` variable retains its state across calls.",
              "language": "javascript"
            },
            {
              "id": "example_generator_2",
              "title": "Finite Range Generator",
              "code": "function* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nfor (const num of range(1, 5)) {\n  console.log(num); // 1, 2, 3, 4, 5\n}",
              "explanation": "This `range` generator produces a finite sequence of numbers. The `for...of` loop elegantly iterates over the yielded values, automatically handling the `next()` calls until the generator is `done`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_generator_1",
            "question_generator_2",
            "question_generator_3",
            "question_generator_4",
            "question_generator_5"
          ],
          "relatedTasks": [
            "task_generator_1"
          ],
          "tags": [
            "generators",
            "iterators",
            "yield",
            "iteration",
            "ES6"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "functions",
            "loops",
            "iterables"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "custom_iterators",
            "lazy_evaluation",
            "asynchronous_patterns"
          ]
        },
        {
          "id": "theory_async_functions",
          "title": "Async Functions: Asynchronous Programming Made Easier",
          "content": "Asynchronous functions (`async`/`await`) provide a more synchronous-like syntax for working with Promises, making asynchronous code easier to read and write. They are built on top of Promises and the JavaScript event loop.\n\n### Key Concepts\n-   **`async` Keyword**: Declares a function as asynchronous. An `async` function implicitly returns a Promise. If the function returns a non-Promise value, it will be wrapped in a resolved Promise. If it throws an error, the Promise will be rejected.\n-   **`await` Keyword**: Can only be used inside an `async` function. `await` pauses the execution of the `async` function until the Promise it's waiting on settles (either resolves or rejects). Once the Promise settles, `await` returns its resolved value. If the Promise rejects, `await` throws the error, which can then be caught by a `try...catch` block.\n-   **Non-Blocking Nature**: Despite `await` pausing the `async` function, it does *not* block the main thread of execution. When an `await` expression is encountered, the `async` function is suspended, and control is returned to the event loop, allowing other tasks to run. Once the awaited Promise resolves, the `async` function is put back in the event queue to resume execution.\n-   **Error Handling**: `try...catch` blocks are the idiomatic way to handle errors in `async` functions, just like with synchronous code.\n-   **Immediately Invoked Async Function Expression (IIAFE)**: `(async () => { /* ... */ })();` is a common pattern to create an `async` execution context at the top level of a script or module, allowing `await` to be used without defining a named `async` function.\n\n### Advantages\n-   **Readability**: Code looks more like traditional synchronous code, making it easier to follow the flow.\n-   **Error Handling**: Simple `try...catch` blocks for errors, similar to synchronous error handling.\n-   **Debugging**: Easier to debug compared to complex `.then().catch()` chains.",
          "examples": [
            {
              "id": "example_async_1",
              "title": "Basic Async Data Fetching",
              "code": "async function fetchData() {\n  try {\n    // Await pauses execution until the fetch Promise resolves\n    const response = await fetch('https://api.example.com/data');\n    if (!response.ok) {\n      // Throwing an error here will cause the catch block to execute\n      throw new Error(`Network response was not ok: ${response.status}`);\n    }\n    // Await pauses until the json() Promise resolves\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching data:', error.message);\n    // Re-throw or return a default value based on desired behavior\n    throw error; \n  }\n}\n\n// Using async function (it returns a Promise)\nfetchData()\n  .then(data => console.log('Fetched data (then):', data))\n  .catch(error => console.error('Caught error (then):', error.message));\n\n// Async IIFE for immediate execution and top-level await-like behavior\n(async () => {\n  try {\n    const data = await fetchData();\n    console.log('Fetched data (IIFE):', data);\n  } catch (error) {\n    console.error('Caught error (IIFE):', error.message);\n  }\n})();",
              "explanation": "This example shows an `async` function `fetchData` that uses `await` to pause execution while fetching data and parsing the JSON response. Error handling is managed with a `try...catch` block. The example also demonstrates how to consume the Promise returned by `fetchData` using `.then()` and how to use an Immediately Invoked Async Function Expression (IIAFE) to execute `async/await` code directly.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_async_1",
            "question_async_2",
            "question_async_3",
            "question_async_4",
            "question_async_5"
          ],
          "relatedTasks": [
            "task_async_1"
          ],
          "tags": [
            "async",
            "await",
            "promises",
            "asynchronous_programming",
            "event_loop",
            "ES2017"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "event_loop",
            "error_handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_web_development",
            "API_integration",
            "concurrency_control"
          ]
        },
        {
          "id": "theory_regular_vs_arrow_functions",
          "title": "Regular vs. Arrow Functions: Key Differences",
          "content": "JavaScript offers two primary ways to define functions: traditional `function` declarations/expressions (regular functions) and arrow function expressions (introduced in ES6). While both allow you to create callable units of code, they have fundamental differences, especially regarding `this` binding and their suitability for certain use cases.\n\n### Key Differences\n\n1.  **`this` Binding (Lexical `this`)**:\n    *   **Regular Functions**: Have their own `this` context. The value of `this` is dynamically determined by how the function is called. It can be the global object (in non-strict mode), `undefined` (in strict mode), the object the function is a method of, or explicitly set via `call()`, `apply()`, or `bind()`.\n    *   **Arrow Functions**: Do *not* have their own `this` context. They lexically bind `this`, meaning `this` refers to the `this` value of the *enclosing* (outer) scope where the arrow function is defined. This makes them ideal for callbacks or methods where you want to preserve the `this` context of the surrounding code.\n\n2.  **`arguments` Object**: \n    *   **Regular Functions**: Have their own `arguments` object, which is an array-like object containing all arguments passed to the function.\n    *   **Arrow Functions**: Do *not* have their own `arguments` object. If you try to access `arguments` inside an arrow function, it will refer to the `arguments` object of the nearest enclosing *regular* function. To get arguments in an arrow function, you should use [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`...args`).\n\n3.  **Use as Constructors (`new` Keyword)**:\n    *   **Regular Functions**: Can be used as constructor functions with the `new` keyword to create new instances. When called with `new`, they create a new object, set `this` to that object, execute the constructor, and return the new object.\n    *   **Arrow Functions**: Cannot be used as constructors. Attempting to use `new` with an arrow function will throw a `TypeError`.\n\n4.  **`prototype` Property**: \n    *   **Regular Functions**: Have a `prototype` property, which is an object that contains properties and methods that will be inherited by instances created with that constructor function.\n    *   **Arrow Functions**: Do not have a `prototype` property. This is a direct consequence of them not being usable as constructors.\n\n5.  **`super` Keyword**: Arrow functions do not have their own `super` binding. If used in a class, `super` refers to the `super` of the nearest enclosing non-arrow function (e.g., method).\n\n6.  **Named Functions**: Regular functions can be named (e.g., `function foo() {}`), which is useful for debugging stack traces. Arrow functions are typically anonymous (e.g., `const foo = () => {}`). While you can assign them to named variables, the function itself is anonymous.\n\n### When to Use Which?\n-   **Arrow Functions**: Ideal for callbacks (especially in methods where `this` binding is important), short, concise functions, and anywhere `this` should lexically bind.\n-   **Regular Functions**: Necessary for constructors, methods that need their own `this` context, event handlers where `this` should refer to the element, and functions that might need the `arguments` object.",
          "examples": [
            {
              "id": "example_arrow_this_problem",
              "title": "Problem with `this` in Regular Functions (Pre-Arrow Functions)",
              "code": "// Problem with regular functions and this\nfunction Person() {\n  // In the Person constructor, 'this' refers to the new instance\n  this.age = 0;\n  \n  // setInterval's callback is a regular function.\n  // In non-strict mode, within growUp(), 'this' refers to the global object (window/global).\n  // In strict mode, 'this' would be undefined.\n  setInterval(function growUp() {\n    this.age++; // 'this' is not the Person instance!\n    console.log(this.age); // Will log NaN or increment global.age\n  }, 1000);\n}\n\n// To fix this with regular functions, you'd typically use a closure or .bind()\nfunction PersonFixed() {\n  this.age = 0;\n  const self = this; // Capture 'this'\n  setInterval(function growUp() {\n    self.age++;\n    console.log(`Fixed (self): ${self.age}`);\n  }, 1000);\n}\n\nfunction PersonBound() {\n  this.age = 0;\n  setInterval(function growUp() {\n    this.age++;\n    console.log(`Fixed (bind): ${this.age}`);\n  }.bind(this), 1000); // Bind 'this' explicitly\n}\n\n// var p = new Person(); // This will not work as expected\n// var pf = new PersonFixed();\n// var pb = new PersonBound();",
              "explanation": "This example illustrates a common pitfall with `this` in regular functions. Inside `setInterval`, the callback function `growUp` is called without an explicit context, so `this` defaults to the global object (or `undefined` in strict mode). This means `this.age++` doesn't increment the `age` property of the `Person` instance. The 'Fixed (self)' and 'Fixed (bind)' variants show common workarounds using a `self` variable (closure) or `Function.prototype.bind()`.",
              "language": "javascript"
            },
            {
              "id": "example_arrow_this_solution",
              "title": "Solving `this` Binding with Arrow Functions",
              "code": "// Solution with arrow functions and lexical this\nfunction PersonArrow() {\n  this.age = 0;\n  \n  // Arrow function inherits 'this' from its enclosing scope (PersonArrow constructor)\n  setInterval(() => {\n    this.age++; // 'this' correctly refers to the PersonArrow instance\n    console.log(`Arrow Function: ${this.age}`);\n  }, 1000);\n}\n\nconst pArrow = new PersonArrow();",
              "explanation": "This example demonstrates how arrow functions elegantly solve the `this` binding problem. Because arrow functions do not have their own `this`, they inherit `this` from the `PersonArrow` constructor's scope. Thus, `this.age++` correctly modifies the `age` property of the `pArrow` instance.",
              "language": "javascript"
            },
            {
              "id": "example_arrow_arguments",
              "title": "`arguments` Object vs. Rest Parameters",
              "code": "function regularFunction() {\n  console.log('Regular function arguments:', arguments); // Has its own arguments object\n  console.log('Type of arguments:', typeof arguments); // object\n}\n\nconst arrowFunction = (...args) => {\n  console.log('Arrow function rest parameters:', args); // Uses rest parameters\n  // console.log(arguments); // Error in strict mode or refers to outer arguments\n};\n\nregularFunction(1, 2, 3);\narrowFunction('a', 'b', 'c');\n\n// Example of arrow function inheriting arguments from outer regular function\nfunction outerRegular() {\n  const innerArrow = () => {\n    console.log('Inner arrow function accessing outer arguments:', arguments);\n  };\n  innerArrow();\n}\nouterRegular(10, 20);",
              "explanation": "This example highlights the difference in argument handling. Regular functions have their own `arguments` object. Arrow functions do not and should use rest parameters (`...args`) to gather arguments. If an arrow function is nested within a regular function, it will inherit the `arguments` object of that outer regular function.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_arrow_regular_1",
            "question_arrow_regular_2",
            "question_arrow_regular_3",
            "question_arrow_regular_4",
            "question_arrow_regular_5",
            "question_arrow_regular_6"
          ],
          "relatedTasks": [
            "task_arrow_regular_1"
          ],
          "tags": [
            "arrow_functions",
            "regular_functions",
            "this_binding",
            "ES6",
            "arguments_object",
            "constructors"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "functions",
            "this_keyword",
            "scope",
            "closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "object_oriented_programming",
            "event_handling",
            "react_components",
            "callback_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_memoization_1",
          "topic": "Memoization Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of memoization?",
          "answer": "To cache the results of expensive function calls and return the cached result when the same inputs occur again, thereby speeding up execution.",
          "options": [],
          "analysisPoints": [
            "Definition of memoization",
            "Purpose: performance optimization",
            "Mechanism: caching results"
          ],
          "keyConcepts": [
            "Memoization",
            "Caching",
            "Performance"
          ],
          "evaluationCriteria": [
            "Ability to define memoization concisely."
          ],
          "example": "",
          "tags": [
            "memoization",
            "performance",
            "flashcard"
          ],
          "prerequisites": [
            "functions"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_memoization_2",
          "topic": "Memoization Implementation Details",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `memoize` function provided:\n```javascript\nfunction memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache[key]) {\n      return cache[key];\n    }\n    const result = fn.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n```\nWhy is `fn.apply(this, args)` used instead of `fn(...args)`?",
          "answer": "To ensure the original function `fn` executes with its correct `this` context.",
          "options": [
            "To ensure the original function `fn` executes with its correct `this` context.",
            "Because `apply` is faster than the spread operator for function calls.",
            "To convert the `args` array into a list of arguments for `fn`.",
            "To prevent `fn` from accessing the `cache` object directly."
          ],
          "analysisPoints": [
            "Understanding of `this` binding in JavaScript.",
            "Knowledge of `call`, `apply`, and `bind` methods.",
            "Distinguishing between argument passing (`...args` vs `apply` with array) and context binding."
          ],
          "keyConcepts": [
            "this_keyword",
            "function_apply",
            "memoization",
            "function_context"
          ],
          "evaluationCriteria": [
            "Correct identification of `this` binding as the primary reason.",
            "Understanding the difference between `apply` and spread operator in this context."
          ],
          "example": "The `this` context inside the `memoized` function (the one returned by `memoize`) depends on how *it* is called. If `fn` is a method of an object (e.g., `obj.myMethod`), then `this` inside `myMethod` should refer to `obj`. By using `fn.apply(this, args)`, the `this` value of the *memoized* function call is explicitly passed as the `this` context for the original `fn` call, preserving its intended behavior.",
          "tags": [
            "memoization",
            "this_keyword",
            "functions",
            "mcq"
          ],
          "prerequisites": [
            "this_keyword",
            "function_apply_call_bind"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_memoization_3",
          "topic": "Limitations of Memoization",
          "level": "medium",
          "type": "open",
          "question": "What are some potential drawbacks or situations where memoization might not be the optimal solution?",
          "answer": "1.  **Memory Consumption**: Storing all computed results in a cache can lead to high memory usage, especially for functions with a large number of unique inputs.\n2.  **Overhead of Key Generation**: For functions with complex arguments (e.g., objects, arrays, functions), generating a unique and consistent cache key (e.g., using `JSON.stringify` or deep hashing) can be computationally expensive, potentially negating the benefits of memoization.\n3.  **Impure Functions**: Memoization is most effective for pure functions (functions that always produce the same output for the same input and have no side effects). For impure functions (e.g., functions that depend on global state, make network requests, or produce random numbers), memoization can lead to stale or incorrect results because the output might change even with the same inputs.\n4.  **Limited Re-computations**: If a function is called with the same inputs only a few times, the overhead of the memoization logic (cache lookup, key generation) might outweigh the benefit of avoiding re-computation.",
          "analysisPoints": [
            "Discussion of memory implications.",
            "Understanding of performance trade-offs for key generation.",
            "Distinction between pure and impure functions.",
            "Consideration of frequency of calls with same inputs."
          ],
          "keyConcepts": [
            "Memoization",
            "Performance_tradeoffs",
            "Pure_functions",
            "Memory_management"
          ],
          "evaluationCriteria": [
            "Ability to articulate multiple drawbacks.",
            "Demonstrates understanding of pure function concept.",
            "Considers practical implications like memory and key generation cost."
          ],
          "example": "",
          "tags": [
            "memoization",
            "optimization",
            "design_patterns",
            "open-ended"
          ],
          "prerequisites": [
            "pure_functions",
            "data_structures",
            "algorithm_analysis"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_memoization_4",
          "topic": "Memoization Application",
          "level": "hard",
          "type": "code",
          "question": "Implement a `memoize` function that can handle function arguments which are objects, where object key order might vary but the content is logically the same. For simplicity, assume arguments are always primitive or plain objects/arrays that can be safely deep-sorted and stringified. If the function takes multiple arguments, ensure all are considered for the key.",
          "answer": "```javascript\nfunction deepSortAndStringify(arg) {\n  if (typeof arg !== 'object' || arg === null) {\n    return JSON.stringify(arg);\n  }\n  if (Array.isArray(arg)) {\n    return '[' + arg.map(item => deepSortAndStringify(item)).join(',') + ']';\n  }\n  const sortedKeys = Object.keys(arg).sort();\n  const sortedObject = {};\n  for (const key of sortedKeys) {\n    sortedObject[key] = arg[key];\n  }\n  return '{' + sortedKeys.map(key => `\"${key}\":${deepSortAndStringify(sortedObject[key])}`).join(',') + '}';\n}\n\nfunction memoizeComplex(fn) {\n  const cache = new Map(); // Using Map for better key handling with complex types potentially\n  return function(...args) {\n    // Create a robust key for complex arguments\n    const key = deepSortAndStringify(args);\n    \n    if (cache.has(key)) {\n      console.log('Fetching from cache (complex key):', key);\n      return cache.get(key);\n    }\n\n    console.log('Calculating result (complex key):', key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Example usage:\nconst sumObjects = memoizeComplex(function(obj1, obj2) {\n  const sumKeys = [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])];\n  const result = {};\n  for (const key of sumKeys) {\n    result[key] = (obj1[key] || 0) + (obj2[key] || 0);\n  }\n  return result;\n});\n\nconsole.log(sumObjects({a: 1, b: 2}, {b: 3, c: 4})); // Calculates\nconsole.log(sumObjects({b: 2, a: 1}, {c: 4, b: 3})); // Fetches from cache due to sorted key\nconsole.log(sumObjects({a: 5}, {b: 6})); // Calculates\n```",
          "options": [],
          "analysisPoints": [
            "Understanding of object serialization for cache keys.",
            "Ability to handle deep comparisons or canonicalization of objects.",
            "Correct usage of `this` context with `apply`.",
            "Demonstrates robustness beyond simple `JSON.stringify`."
          ],
          "keyConcepts": [
            "Memoization",
            "Deep_comparison",
            "Serialization",
            "Function_apply",
            "Caching_strategies"
          ],
          "evaluationCriteria": [
            "Correct implementation of `deepSortAndStringify`.",
            "Successful integration of the custom key generation into `memoize`.",
            "Preservation of `this` context.",
            "Handling of multiple arguments."
          ],
          "example": "",
          "tags": [
            "memoization",
            "coding_challenge",
            "optimization",
            "algorithms"
          ],
          "prerequisites": [
            "recursion",
            "object_manipulation",
            "data_structures",
            "JSON"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_memoization_5",
          "topic": "Memoization vs. Dynamic Programming",
          "level": "medium",
          "type": "open",
          "question": "How does memoization relate to Dynamic Programming (DP)? Can all DP problems be solved with memoization?",
          "answer": "Memoization is a technique used within Dynamic Programming (DP) to optimize recursive solutions. It's often referred to as 'top-down' DP.\n\n**Relationship:**\n*   **Dynamic Programming:** A method for solving complex problems by breaking them down into simpler subproblems. It solves each subproblem only once and stores the solutions to avoid redundant computations. This can be implemented in two ways: memoization (top-down, recursive with caching) or tabulation (bottom-up, iterative with a table).\n*   **Memoization:** Specifically, it's the caching aspect of DP. When a recursive function is called, it first checks if the result for the current inputs is already in the cache. If so, it returns the cached value. Otherwise, it computes the result, stores it in the cache, and then returns it.\n\n**Can all DP problems be solved with memoization?**\nYes, conceptually, any problem that can be solved with dynamic programming can also be solved using memoization. This is because both techniques rely on the principle of overlapping subproblems and optimal substructure. Memoization implicitly handles the order of computation by only computing subproblems when they are first needed. The choice between memoization (top-down) and tabulation (bottom-up) often comes down to personal preference, readability, or performance characteristics (e.g., iterative tabulation can sometimes be more memory-efficient or faster due to less recursion overhead, but memoization can be simpler to write for complex state transitions).",
          "analysisPoints": [
            "Correctly identifies memoization as a DP technique.",
            "Explains the 'top-down' nature of memoization in DP.",
            "Compares/contrasts with tabulation (bottom-up DP).",
            "Accurately states that all DP problems can be solved with memoization.",
            "Discusses the underlying principles (overlapping subproblems, optimal substructure)."
          ],
          "keyConcepts": [
            "Memoization",
            "Dynamic_Programming",
            "Recursion",
            "Top-down_DP",
            "Tabulation",
            "Overlapping_subproblems"
          ],
          "evaluationCriteria": [
            "Clear explanation of the relationship.",
            "Accuracy in stating applicability.",
            "Demonstrates deeper understanding of DP concepts."
          ],
          "example": "",
          "tags": [
            "memoization",
            "dynamic_programming",
            "algorithms",
            "open-ended"
          ],
          "prerequisites": [
            "recursion",
            "algorithms"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_generator_1",
          "topic": "Generator Function Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary keyword used to define a generator function in JavaScript?",
          "answer": "`function*`",
          "options": [],
          "analysisPoints": [
            "Recall syntax for generator functions."
          ],
          "keyConcepts": [
            "Generators",
            "Syntax",
            "JavaScript"
          ],
          "evaluationCriteria": [
            "Correctly identifies the `function*` syntax."
          ],
          "example": "",
          "tags": [
            "generators",
            "ES6",
            "flashcard"
          ],
          "prerequisites": [
            "functions"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_generator_2",
          "topic": "Generator Function Execution",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following generator function:\n```javascript\nfunction* countUpTo(limit) {\n  for (let i = 1; i <= limit; i++) {\n    yield i;\n  }\n}\nconst counter = countUpTo(3);\n```\nWhat will be the output of `console.log(counter.next().value); console.log(counter.next().done);` executed sequentially?",
          "answer": "1, false",
          "options": [
            "1, false",
            "undefined, true",
            "1, true",
            "3, false"
          ],
          "analysisPoints": [
            "Understanding of `yield` keyword.",
            "Knowledge of the `next()` method's return value `{ value, done }`.",
            "Ability to trace generator execution step-by-step."
          ],
          "keyConcepts": [
            "Generators",
            "Yield",
            "Next_method",
            "Iterator_protocol"
          ],
          "evaluationCriteria": [
            "Correctly identifies the first yielded value.",
            "Accurately determines the `done` status after the first yield."
          ],
          "example": "The first call to `counter.next()` executes the loop up to `yield i;` where `i` is 1. So, `value` will be 1. Since there are more values to yield (2 and 3), `done` will be `false`.",
          "tags": [
            "generators",
            "ES6",
            "mcq",
            "iteration"
          ],
          "prerequisites": [
            "loops",
            "functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_generator_3",
          "topic": "Generator Use Cases",
          "level": "medium",
          "type": "open",
          "question": "Describe a practical scenario where a generator function would be a more suitable choice than a regular function that returns an array.",
          "answer": "A practical scenario where a generator function is more suitable than a regular function returning an array is when dealing with **potentially very large or infinite sequences of data**, or when you need to **process data lazily (on-demand)**.\n\n**Example: Processing a large log file or a data stream.**\nImagine you have a massive log file (e.g., gigabytes in size) or a continuous data stream, and you need to filter or transform its entries one by one without loading the entire content into memory.\n\n*   **Regular Function (returning array):** You would have to read the entire file/stream, process all entries, store them in an array, and then return the array. This would consume a huge amount of memory, potentially leading to out-of-memory errors, and delay processing until the entire array is built.\n\n*   **Generator Function:** A generator function could read one line (or chunk) at a time, process it, and `yield` the result. It would then pause, waiting for the next `next()` call. This allows you to process data piece by piece, consuming minimal memory (only holding the current chunk in memory), and start processing results immediately as they become available. It's especially powerful when you might only need a few initial results or if the stream is truly infinite (like a real-time event log).\n\nThis lazy evaluation makes generators ideal for iterating over large datasets, implementing infinite sequences (like an ID generator or Fibonacci sequence), or handling asynchronous data streams.",
          "analysisPoints": [
            "Identifies scenarios with large/infinite data.",
            "Highlights memory efficiency as a key benefit.",
            "Explains lazy evaluation concept.",
            "Provides a concrete, relatable example (e.g., large file processing, data streams).",
            "Compares memory/performance implications with traditional array return."
          ],
          "keyConcepts": [
            "Generators",
            "Lazy_evaluation",
            "Memory_efficiency",
            "Infinite_sequences",
            "Data_streams",
            "Use_cases"
          ],
          "evaluationCriteria": [
            "Clear and concise explanation of the advantage.",
            "Relevant and well-explained example.",
            "Demonstrates understanding of generator's core benefits."
          ],
          "example": "",
          "tags": [
            "generators",
            "performance",
            "memory_management",
            "open-ended"
          ],
          "prerequisites": [
            "data_structures",
            "functions"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_generator_4",
          "topic": "Generator Control Flow",
          "level": "hard",
          "type": "code",
          "question": "Write a generator function `throttleGenerator(func, delay)` that takes a function `func` and a `delay` in milliseconds. The generator should yield the result of `func()` at most once every `delay` milliseconds. Subsequent calls to `next()` within the `delay` period should return the previously yielded value without re-executing `func`. After the `delay` expires, the next `next()` call should re-execute `func`.",
          "answer": "```javascript\nfunction* throttleGenerator(func, delay) {\n  let lastExecutionTime = 0;\n  let lastResult = undefined;\n\n  while (true) {\n    const currentTime = Date.now();\n\n    if (currentTime - lastExecutionTime >= delay) {\n      // Time elapsed, re-execute func\n      lastResult = func();\n      lastExecutionTime = currentTime;\n      yield lastResult;\n    } else {\n      // Within delay, yield the last result without re-execution\n      yield lastResult; \n    }\n  }\n}\n\n// Example usage:\nlet callCount = 0;\nconst throttledFunc = () => {\n  callCount++;\n  return `Called at ${Date.now()}, count: ${callCount}`;\n};\n\nconst throttler = throttleGenerator(throttledFunc, 2000); // 2-second delay\n\nconsole.log(throttler.next().value); // Should execute func\n\nsetTimeout(() => {\n  console.log(throttler.next().value); // Should return cached value\n}, 500);\n\nsetTimeout(() => {\n  console.log(throttler.next().value); // Should return cached value\n}, 1500);\n\nsetTimeout(() => {\n  console.log(throttler.next().value); // Should execute func again\n}, 2500);\n\nsetTimeout(() => {\n  console.log(throttler.next().value); // Should return cached value\n}, 3000);\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `yield` for pausing and resuming.",
            "Manages state (`lastExecutionTime`, `lastResult`) within the generator closure.",
            "Implements the throttling logic based on `delay`.",
            "Distinguishes between re-execution and cached return.",
            "Demonstrates understanding of generator's ability to maintain state across calls."
          ],
          "keyConcepts": [
            "Generators",
            "Throttling",
            "State_management",
            "Closures",
            "Time-based_logic",
            "Control_flow"
          ],
          "evaluationCriteria": [
            "Correct implementation of throttling logic.",
            "Effective use of generator features (`yield`, state persistence).",
            "Handles both re-execution and caching scenarios."
          ],
          "example": "",
          "tags": [
            "generators",
            "algorithms",
            "throttling",
            "coding_challenge"
          ],
          "prerequisites": [
            "closures",
            "Date_object",
            "setTimeout"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_generator_5",
          "topic": "Generator Advanced Usage",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a feature or direct capability of JavaScript generator functions?",
          "answer": "Automatically handling uncaught promise rejections within the generator without explicit `try...catch`.",
          "options": [
            "Pausing and resuming function execution at specific points.",
            "Generating potentially infinite sequences of values.",
            "Receiving values back from the consumer using `yield` as an expression.",
            "Automatically handling uncaught promise rejections within the generator without explicit `try...catch`."
          ],
          "analysisPoints": [
            "Understanding of `yield` as both a statement and an expression (sending values *into* a generator).",
            "Knowledge of generator's ability for infinite sequences and pausing.",
            "Distinguishing generator features from `async/await` error handling."
          ],
          "keyConcepts": [
            "Generators",
            "Yield",
            "Iteration",
            "Error_handling",
            "Promises"
          ],
          "evaluationCriteria": [
            "Correctly identifies the false statement regarding error handling.",
            "Demonstrates understanding of core generator capabilities."
          ],
          "example": "While generators can be used for asynchronous patterns (like with `co` library), they do not inherently handle promise rejections. That functionality is built into `async/await`. Generators can `yield` promises, and `next()` can resolve them, but error propagation requires explicit `try...catch` or `.catch()` on the Promise returned by `next()`.",
          "tags": [
            "generators",
            "ES6",
            "promises",
            "mcq"
          ],
          "prerequisites": [
            "promises",
            "error_handling"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_1",
          "topic": "Async/Await Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What type of value does an `async` function always return, implicitly or explicitly?",
          "answer": "A Promise.",
          "options": [],
          "analysisPoints": [
            "Fundamental understanding of `async` function return type."
          ],
          "keyConcepts": [
            "Async_functions",
            "Promises",
            "Return_values"
          ],
          "evaluationCriteria": [
            "Correctly identifies that `async` functions return Promises."
          ],
          "example": "",
          "tags": [
            "async_await",
            "promises",
            "flashcard"
          ],
          "prerequisites": [
            "promises"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_2",
          "topic": "Await Keyword Behavior",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about the `await` keyword is TRUE?",
          "answer": "It can only be used inside an `async` function.",
          "options": [
            "It can be used anywhere in JavaScript code, including the global scope.",
            "It pauses the entire JavaScript execution thread until the Promise settles.",
            "It can only be used inside an `async` function.",
            "It automatically catches any errors thrown by the awaited Promise."
          ],
          "analysisPoints": [
            "Understanding of the scope limitation of `await`.",
            "Distinguishing between pausing an `async` function vs. blocking the thread.",
            "Knowledge of error handling mechanisms (`try...catch`)."
          ],
          "keyConcepts": [
            "Await_keyword",
            "Async_functions",
            "Event_loop",
            "Non-blocking",
            "Error_handling"
          ],
          "evaluationCriteria": [
            "Correctly identifies the scope of `await`.",
            "Distinguishes between thread blocking and `async` function suspension."
          ],
          "example": "`await` is designed to work cooperatively with the event loop. When `await` encounters a pending promise, it suspends the *async function's execution* and allows the JavaScript engine to perform other tasks. It does not block the main thread. Error handling requires `try...catch`.",
          "tags": [
            "async_await",
            "promises",
            "event_loop",
            "mcq"
          ],
          "prerequisites": [
            "promises",
            "event_loop"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_3",
          "topic": "Async Error Handling",
          "level": "medium",
          "type": "open",
          "question": "Explain how error handling is typically managed in `async` functions, providing a simple code example.",
          "answer": "Error handling in `async` functions is typically managed using `try...catch` blocks, similar to synchronous code. When a Promise awaited by `await` rejects, `await` itself will throw an error. This error can then be caught by a surrounding `try...catch` block.\n\n**Explanation:**\n1.  **`try` block**: Contains the `await` expressions and other code that might throw errors (e.g., network issues, invalid responses).\n2.  **`catch` block**: If any `await`ed Promise rejects, or any synchronous code within the `try` block throws an error, execution immediately jumps to the `catch` block. The `catch` block receives the error object, allowing you to log it, display a message, or take corrective action.\n3.  **Return/Re-throw**: Within the `catch` block, you can choose to return a default value, return a new rejected Promise (if the `async` function is consumed by `.then().catch()`), or re-throw the error to propagate it further up the call stack.\n\n**Example:**\n```javascript\nasync function safeFetchData(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      // This will cause the Promise returned by fetch to reject if status is not 2xx\n      // Or, as shown here, we can explicitly throw for non-ok responses\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Failed to fetch data:', error.message);\n    // Re-throw the error so consumers of safeFetchData can also catch it\n    throw error;\n    // Alternatively, return a default value or handle gracefully:\n    // return { error: true, message: error.message };\n  }\n}\n\n// Usage with error handling\nsafeFetchData('https://api.example.com/invalid-endpoint')\n  .then(data => console.log('Success:', data))\n  .catch(err => console.error('Caught in consumer:', err.message));\n\nsafeFetchData('https://jsonplaceholder.typicode.com/todos/1')\n  .then(data => console.log('Success:', data))\n  .catch(err => console.error('Caught in consumer:', err.message));\n```",
          "analysisPoints": [
            "Clear explanation of `try...catch` usage with `async/await`.",
            "Demonstrates how rejected Promises are handled by `await`.",
            "Provides a relevant and correct code example.",
            "Discusses options within the `catch` block (re-throw, return default)."
          ],
          "keyConcepts": [
            "Async_functions",
            "Await_keyword",
            "Error_handling",
            "Try_catch",
            "Promises"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of error handling strategy.",
            "Accurate code example demonstrating the concept.",
            "Ability to discuss error propagation."
          ],
          "example": "",
          "tags": [
            "async_await",
            "error_handling",
            "promises",
            "open-ended"
          ],
          "prerequisites": [
            "promises",
            "try_catch"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_4",
          "topic": "Async Parallel Execution",
          "level": "hard",
          "type": "code",
          "question": "You have two asynchronous functions, `fetchUser(id)` and `fetchPosts(userId)`, both returning Promises. Write an `async` function `getUserAndPosts(id)` that fetches the user and their posts **concurrently** (in parallel) and returns an object `{ user: ..., posts: ... }`. Ensure proper error handling if either fetch fails.",
          "answer": "```javascript\n// Mock async functions\nfunction fetchUser(id) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (id === 1) resolve({ id: 1, name: 'Alice' });\n      else if (id === 2) resolve({ id: 2, name: 'Bob' });\n      else reject(new Error('User not found'));\n    }, 500);\n  });\n}\n\nfunction fetchPosts(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 1) resolve([{ postId: 101, title: 'Post A' }, { postId: 102, title: 'Post B' }]);\n      else if (userId === 2) resolve([{ postId: 201, title: 'Post C' }]);\n      else reject(new Error('Posts not found for user'));\n    }, 700);\n  });\n}\n\nasync function getUserAndPosts(id) {\n  try {\n    // Use Promise.all to run promises concurrently\n    const [user, posts] = await Promise.all([\n      fetchUser(id),\n      fetchPosts(id) \n    ]);\n    \n    return { user, posts };\n  } catch (error) {\n    console.error(`Error fetching data for user ${id}:`, error.message);\n    // Re-throw the error or return a partial result/error object\n    throw error; \n  }\n}\n\n// Example Usage:\n(async () => {\n  console.log('--- Successful Fetch ---');\n  try {\n    const data = await getUserAndPosts(1);\n    console.log('Result:', data);\n  } catch (err) {\n    console.error('Caught error in main:', err.message);\n  }\n\n  console.log('\\n--- User Not Found Error ---');\n  try {\n    const data = await getUserAndPosts(99);\n    console.log('Result:', data);\n  } catch (err) {\n    console.error('Caught error in main:', err.message);\n  }\n\n  console.log('\\n--- Posts Not Found Error ---');\n  // To simulate posts not found specifically, might need to adjust mock\n  // Or assume a generic error covers it.\n  // For this example, let's assume fetchPosts(id) can throw for certain IDs\n  // (e.g., if fetchUser succeeds but fetchPosts fails for that user)\n  // A more robust mock would be needed to test this precisely.\n  try {\n    const data = await getUserAndPosts(2); // If fetchPosts for 2 was designed to fail\n    console.log('Result:', data);\n  } catch (err) {\n    console.error('Caught error in main:', err.message);\n  }\n})();\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `Promise.all` for parallel execution.",
            "Understanding of destructuring assignment for results.",
            "Proper `try...catch` block for error handling in `async` functions.",
            "Ability to structure and combine asynchronous operations."
          ],
          "keyConcepts": [
            "Async_await",
            "Promise.all",
            "Parallel_execution",
            "Error_handling",
            "API_integration"
          ],
          "evaluationCriteria": [
            "Successful implementation of concurrent fetching.",
            "Robust error handling.",
            "Returns the specified object structure."
          ],
          "example": "",
          "tags": [
            "async_await",
            "promises",
            "coding_challenge",
            "API_calls",
            "concurrency"
          ],
          "prerequisites": [
            "promises",
            "async_await",
            "error_handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_5",
          "topic": "Async vs. Promise Chains",
          "level": "medium",
          "type": "open",
          "question": "While `async/await` is syntactic sugar over Promises, what are the main advantages `async/await` offers over traditional Promise `.then().catch()` chains, especially for complex asynchronous flows?",
          "answer": "The main advantages of `async/await` over traditional Promise `.then().catch()` chains for complex asynchronous flows are primarily related to **readability, error handling, and debugging**.\n\n1.  **Readability and Maintainability (Synchronous-like Code)**:\n    *   `async/await` allows writing asynchronous code in a sequential, synchronous-looking style. This eliminates callback hell and makes the control flow much easier to follow, especially when multiple dependent asynchronous operations are involved. Nested `.then()` calls can quickly become difficult to read and manage.\n\n2.  **Simpler Error Handling (`try...catch`)**:\n    *   With `async/await`, error handling is done using standard `try...catch` blocks, which is familiar to developers from synchronous programming. In contrast, Promise chains require `.catch()` calls at the end of a chain or after each `.then()` for granular error handling, which can sometimes be less intuitive or lead to missed errors if not placed correctly. A single `try...catch` can wrap multiple `await` calls.\n\n3.  **Better Debugging Experience**:\n    *   Debugging `async/await` code is generally easier. When an `await` pauses execution, the debugger can step through the code line by line as if it were synchronous. Debugging deeply nested `.then()` callbacks often involves jumping between different stack frames, which can be disorienting.\n\n4.  **Conditional Asynchronous Operations**: Writing conditional logic (if/else, loops) with `await` is much more straightforward. You can use standard control flow structures directly. With `.then()`, you often need to chain promises conditionally or use auxiliary variables, which can complicate the logic.\n\n5.  **Less Verbosity**: `async/await` often results in more concise code, especially when you need to extract values from multiple promises or handle intermediate results.",
          "analysisPoints": [
            "Highlights readability and synchronous-like syntax.",
            "Emphasizes simplified `try...catch` error handling.",
            "Discusses improved debugging experience.",
            "Mentions easier conditional logic.",
            "Acknowledges `async/await` as syntactic sugar."
          ],
          "keyConcepts": [
            "Async_await",
            "Promises",
            "Readability",
            "Error_handling",
            "Debugging",
            "Syntactic_sugar"
          ],
          "evaluationCriteria": [
            "Clear articulation of the advantages.",
            "Focus on practical benefits for complex scenarios.",
            "Compares directly to Promise chains."
          ],
          "example": "",
          "tags": [
            "async_await",
            "promises",
            "architecture",
            "open-ended"
          ],
          "prerequisites": [
            "promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_arrow_regular_1",
          "topic": "Arrow vs. Regular Function `this`",
          "level": "easy",
          "type": "flashcard",
          "question": "Which type of function (regular or arrow) has a `this` value that is lexically bound?",
          "answer": "Arrow functions.",
          "options": [],
          "analysisPoints": [
            "Recall the core difference in `this` binding."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "Regular_functions",
            "this_binding",
            "Lexical_this"
          ],
          "evaluationCriteria": [
            "Correctly identifies arrow functions for lexical `this`."
          ],
          "example": "",
          "tags": [
            "arrow_functions",
            "this_keyword",
            "flashcard"
          ],
          "prerequisites": [
            "this_keyword"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_arrow_regular_2",
          "topic": "Arrow vs. Regular Function `arguments` Object",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code snippet:\n```javascript\nfunction outer() {\n  const arrowFunc = () => {\n    console.log(arguments);\n  };\n  arrowFunc(4, 5, 6);\n}\nouter(1, 2, 3);\n```\nWhat will be logged to the console by `arrowFunc`?",
          "answer": "An `arguments` object containing `[1, 2, 3]`.",
          "options": [
            "An `arguments` object containing `[4, 5, 6]`.",
            "An `arguments` object containing `[1, 2, 3]`.",
            "An empty object `{}`.",
            "A `ReferenceError` because arrow functions do not have an `arguments` object."
          ],
          "analysisPoints": [
            "Understanding that arrow functions do not have their own `arguments` object.",
            "Knowledge that arrow functions inherit `arguments` from the nearest *enclosing regular function*.",
            "Tracing the scope chain correctly."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "Arguments_object",
            "Lexical_scope",
            "Regular_functions"
          ],
          "evaluationCriteria": [
            "Correctly identifies the source of the `arguments` object.",
            "Demonstrates understanding of lexical scope for arrow functions."
          ],
          "example": "Arrow functions do not have their own `arguments` object. When `arguments` is referenced inside an arrow function, it looks up the scope chain for the nearest enclosing *regular* function's `arguments` object. In this case, `outer` is the enclosing regular function, and it was called with `(1, 2, 3)`.",
          "tags": [
            "arrow_functions",
            "arguments_object",
            "scope",
            "mcq"
          ],
          "prerequisites": [
            "scope",
            "arguments_object"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_arrow_regular_3",
          "topic": "Function Types and `new`",
          "level": "medium",
          "type": "open",
          "question": "Can an arrow function be used as a constructor with the `new` keyword? Explain why or why not, and describe the implications.",
          "answer": "No, an arrow function cannot be used as a constructor with the `new` keyword.\n\n**Why not?**\nArrow functions fundamentally lack internal methods and properties that are essential for constructor behavior:\n1.  **No `[[Construct]]` method**: Regular functions have an internal `[[Construct]]` method that is invoked when they are called with `new`. Arrow functions do not have this internal method.\n2.  **No `prototype` property**: Constructor functions rely on their `prototype` property to set up the prototype chain for new instances. Arrow functions do not have their own `prototype` property.\n3.  **No `this` binding**: When a regular function is called with `new`, a new object is created, and `this` inside the constructor refers to this new object. Since arrow functions lexically bind `this` (they inherit `this` from their enclosing scope), they cannot bind `this` to a newly created instance.\n\n**Implications:**\n-   If you attempt to use `new` with an arrow function, it will throw a `TypeError` (e.g., `TypeError: Class constructor ArrowFunction cannot be invoked without 'new'` or `TypeError: someArrowFunction is not a constructor`).\n-   This means arrow functions are not suitable for defining classes or creating object instances in the traditional way.\n-   They are designed for functions where context binding is fixed and for concise expressions, not for object-oriented construction.",
          "analysisPoints": [
            "Clear 'No' answer.",
            "Explains the lack of `[[Construct]]` method.",
            "Mentions the absence of `prototype` property.",
            "Connects to the `this` binding behavior of arrow functions.",
            "States the resulting `TypeError` and implications for OOP."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "Constructors",
            "New_keyword",
            "Prototype",
            "this_binding",
            "TypeError"
          ],
          "evaluationCriteria": [
            "Accurate explanation of why arrow functions can't be constructors.",
            "Demonstrates understanding of underlying JavaScript mechanisms.",
            "Describes practical implications."
          ],
          "example": "",
          "tags": [
            "arrow_functions",
            "constructors",
            "object_oriented_programming",
            "open-ended"
          ],
          "prerequisites": [
            "prototypal_inheritance",
            "this_keyword"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_arrow_regular_4",
          "topic": "Choosing Function Types",
          "level": "medium",
          "type": "mcq",
          "question": "You are writing a React component and need to define a class method `handleClick` that will be passed as a callback to an event listener (e.g., `onClick`). Which approach is generally recommended for `handleClick` to ensure `this` correctly refers to the component instance inside the handler?",
          "answer": "Define `handleClick` as an arrow function property of the class.",
          "options": [
            "Define `handleClick` as a regular method and bind it in the constructor (`this.handleClick = this.handleClick.bind(this);`).",
            "Define `handleClick` as a regular method and use `onClick={this.handleClick.bind(this)}` in the JSX.",
            "Define `handleClick` as an arrow function property of the class.",
            "Define `handleClick` as a regular method and call `super()` inside it."
          ],
          "analysisPoints": [
            "Understanding `this` binding in class methods and event handlers.",
            "Knowledge of arrow function's lexical `this`.",
            "Familiarity with common React patterns for event handling.",
            "Comparing different binding strategies."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "this_binding",
            "React",
            "Event_handlers",
            "Class_components"
          ],
          "evaluationCriteria": [
            "Identifies the most modern and often preferred solution for `this` in React event handlers.",
            "Demonstrates practical application of arrow function `this` behavior."
          ],
          "example": "```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    // Option A: Binding in constructor (traditional)\n    // this.handleClickRegular = this.handleClickRegular.bind(this);\n  }\n\n  // Option A: Regular method\n  handleClickRegular() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  // Option C: Arrow function as class property (recommended ESNext)\n  handleClickArrow = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        {/* Option A usage */}\n        {/* <button onClick={this.handleClickRegular}>Increment Regular</button> */}\n        {/* Option B usage */}\n        {/* <button onClick={this.handleClickRegular.bind(this)}>Increment Bound Inline</button> */}\n        {/* Option C usage */}\n        <button onClick={this.handleClickArrow}>Increment Arrow</button>\n      </div>\n    );\n  }\n}\n```\nDefining an arrow function as a class property (`handleClickArrow = () => { ... };`) ensures that `this` inside `handleClickArrow` is lexically bound to the `MyComponent` instance, avoiding the need for explicit binding in the constructor or inline binding in JSX, which can be less performant for frequent re-renders.",
          "tags": [
            "arrow_functions",
            "this_keyword",
            "react",
            "event_handling",
            "mcq"
          ],
          "prerequisites": [
            "this_keyword",
            "react_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_arrow_regular_5",
          "topic": "Function Types in Different Contexts",
          "level": "hard",
          "type": "code",
          "question": "Given the following HTML and JavaScript:\n\nHTML:\n```html\n<button id=\"myButton\">Click Me</button>\n```\n\nJavaScript:\n```javascript\nconst button = document.getElementById('myButton');\n\nconst handler1 = function() {\n  console.log('Handler 1 this:', this.id);\n};\n\nconst handler2 = () => {\n  console.log('Handler 2 this:', this);\n};\n\nbutton.addEventListener('click', handler1);\n// button.addEventListener('click', handler2); // If uncommented\n\n// What would be logged if handler2 was also attached?\n// Assume this script is run in the global context of a browser.\n```\n\nExplain what `this` refers to in `handler1` and `handler2` when they are invoked by the `click` event listener. Predict the output for both if `handler2` were uncommented.",
          "answer": "For `handler1` (regular function):\nWhen a regular function is used as an event listener, `this` inside the handler refers to the **element on which the listener was placed**.\n\nOutput for `handler1`:\n`Handler 1 this: myButton`\n\nFor `handler2` (arrow function):\nArrow functions do not have their own `this` binding; they lexically inherit `this` from their enclosing scope. In this case, `handler2` is defined in the global scope (outside any other function or class).\n\nOutput for `handler2`:\n`Handler 2 this: Window` (in a browser environment)\n\n**Explanation:**\n-   `handler1`: As a regular function, `this` is dynamically set by the event listener mechanism to the `button` element itself, because the function is called as `button.handler1()`. This is a common and useful behavior for event handlers.\n-   `handler2`: As an arrow function, it captures `this` from its definition context. Since it's defined directly in the global script scope, its `this` will always refer to the global object, which is `window` in a browser. It will *not* refer to the `button` element, making it generally unsuitable for standard `this`-dependent event listeners unless you explicitly want the global `this` or are relying on some other context management (e.g., passing `event.currentTarget`).\n\n```javascript\nconst button = document.getElementById('myButton');\n\nconst handler1 = function() {\n  console.log('Handler 1 this:', this.id);\n};\n\nconst handler2 = () => {\n  console.log('Handler 2 this:', this); // 'this' will be window\n};\n\nbutton.addEventListener('click', handler1);\nbutton.addEventListener('click', handler2); // Uncommented\n\n// When clicked, output will be:\n// Handler 1 this: myButton\n// Handler 2 this: Window { /* ... */ }\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies `this` for regular function event handlers.",
            "Correctly identifies `this` for arrow function event handlers based on lexical scope.",
            "Understands the global `this` context in browsers.",
            "Predicts the exact output.",
            "Explains the underlying reasons for `this` binding."
          ],
          "keyConcepts": [
            "this_keyword",
            "Event_listeners",
            "Regular_functions",
            "Arrow_functions",
            "Global_object",
            "Lexical_scope"
          ],
          "evaluationCriteria": [
            "Accurate prediction and explanation for both function types.",
            "Demonstrates deep understanding of `this` in various contexts.",
            "Properly applies lexical vs. dynamic `this`."
          ],
          "example": "",
          "tags": [
            "this_keyword",
            "arrow_functions",
            "regular_functions",
            "event_handling",
            "coding_challenge"
          ],
          "prerequisites": [
            "this_keyword",
            "event_listeners",
            "browser_environment"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_arrow_regular_6",
          "topic": "Arrow vs. Regular Function Summary",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is TRUE regarding arrow functions compared to regular functions?",
          "answer": "Arrow functions do not have their own `arguments` object.",
          "options": [
            "Arrow functions can be used as constructors with the `new` keyword.",
            "Arrow functions have their own `arguments` object, similar to regular functions.",
            "Arrow functions lexically bind `this`, meaning `this` is determined by where they are defined.",
            "Arrow functions have a `prototype` property that allows for prototypal inheritance."
          ],
          "analysisPoints": [
            "Recap of key differences: `this` binding, `arguments`, `new`, `prototype`."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "Regular_functions",
            "this_binding",
            "Arguments_object",
            "Constructors",
            "Prototype"
          ],
          "evaluationCriteria": [
            "Correct identification of a true statement among common misconceptions."
          ],
          "example": "Arrow functions are explicitly designed *not* to have their own `this` binding, `arguments` object, `prototype` property, or to be constructible with `new`. Their primary strength lies in their lexical `this` binding, making them excellent for callbacks where the surrounding context's `this` needs to be preserved.",
          "tags": [
            "arrow_functions",
            "regular_functions",
            "mcq"
          ],
          "prerequisites": [
            "functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_memoization_1",
          "title": "Implement a Memoized Fibonacci Sequence Calculator",
          "description": "\nYour task is to implement a memoized version of the Fibonacci sequence calculation. The `fibonacci(n)` function should calculate the nth Fibonacci number. Implement a generic `memoize` higher-order function that can cache the results of any single-argument function. Then, apply this `memoize` function to your `fibonacci` calculation.\n\n**Requirements:**\n1.  Create a `memoize` function that takes another function `fn` as its argument and returns a memoized version of `fn`.\n2.  The `memoize` function should use an internal cache (e.g., an object or `Map`).\n3.  For simplicity, assume the memoized function will only take a single primitive argument (like a number or string) for which `JSON.stringify` can reliably generate a key.\n4.  Implement a `fibonacci(n)` function (recursive, non-memoized initially).\n5.  Apply the `memoize` function to `fibonacci` to create `memoizedFibonacci`.\n6.  Demonstrate that `memoizedFibonacci` correctly calculates results and efficiently retrieves them from the cache for repeated calls.\n",
          "difficulty": "medium",
          "startingCode": "function memoize(fn) {\n  const cache = {};\n  return function(arg) {\n    // TODO: Implement cache logic for single argument\n    // const key = String(arg); // Simple key for primitive args\n    // if (cache.hasOwnProperty(key)) { ... }\n    // else { ... cache[key] = fn(arg); ... }\n    throw new Error(\"Not implemented\");\n  };\n}\n\n// Initial non-memoized recursive Fibonacci function\nfunction fibonacci(n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// TODO: Apply memoize to fibonacci\n// const memoizedFibonacci = memoize(fibonacci);\n\n// console.log(\"Fib(10) (first call):\", memoizedFibonacci(10));\n// console.log(\"Fib(10) (second call):\", memoizedFibonacci(10));\n// console.log(\"Fib(5) (first call):\", memoizedFibonacci(5));\n",
          "solutionCode": "function memoize(fn) {\n  const cache = {};\n  return function(arg) {\n    // Use a simple string conversion for primitive arguments as key\n    const key = String(arg);\n\n    if (cache.hasOwnProperty(key)) {\n      console.log(`Fetching fib(${arg}) from cache`);\n      return cache[key];\n    }\n\n    console.log(`Calculating fib(${arg})`);\n    // Note: 'this' context is not critical for standalone fibonacci function,\n    // but for completeness in a generic memoize, fn.apply(this, [arg]) could be used.\n    const result = fn(arg);\n    cache[key] = result;\n    return result;\n  };\n}\n\n// Initial non-memoized recursive Fibonacci function\nfunction fibonacci(n) {\n  // console.log(`Calculating F(${n})`); // Uncomment to see many calls without memoization\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Apply memoize to fibonacci\nconst memoizedFibonacci = memoize(fibonacci);\n\nconsole.log(\"Calculating Fibonacci sequence with memoization:\");\nconsole.log(\"Fib(10) (first call):\", memoizedFibonacci(10)); // Should calculate all sub-problems once\nconsole.log(\"Fib(10) (second call):\", memoizedFibonacci(10)); // Should fetch from cache\nconsole.log(\"Fib(5) (first call):\", memoizedFibonacci(5));   // Should calculate, some sub-problems might be from prior F(10) calculation\nconsole.log(\"Fib(8) (first call):\", memoizedFibonacci(8));   // Should calculate, leveraging existing cached values\nconsole.log(\"Fib(5) (second call):\", memoizedFibonacci(5));  // Should fetch from cache\n\n// Demonstrating difference without memoization (will be slow for large N)\n// console.log(\"\\nCalculating Fibonacci sequence without memoization:\");\n// const startTime = Date.now();\n// console.log(\"Fib(35) (non-memoized):\", fibonacci(35)); // This will be very slow\n// console.log(\"Time taken (non-memoized):\", Date.now() - startTime, \"ms\");\n\n// const memoizedStartTime = Date.now();\n// console.log(\"Fib(35) (memoized):\", memoizedFibonacci(35)); // This will be fast\n// console.log(\"Fib(35) (memoized, again):\", memoizedFibonacci(35)); // This will be instantaneous\n// console.log(\"Time taken (memoized):\", Date.now() - memoizedStartTime, \"ms\");\n",
          "testCases": [
            "`memoizedFibonacci(0)` should return 0 (calculated).",
            "`memoizedFibonacci(1)` should return 1 (calculated).",
            "`memoizedFibonacci(5)` should return 5 (calculated).",
            "`memoizedFibonacci(10)` should return 55 (calculated).",
            "Subsequent call to `memoizedFibonacci(10)` should log 'Fetching fib(10) from cache' and return 55 without recalculation.",
            "`memoizedFibonacci(5)` after `memoizedFibonacci(10)` should still calculate for `fib(5)` initially, but leverage any already computed `fib(0), fib(1), fib(2), fib(3), fib(4)` from the `fib(10)` calculation.",
            "Performance for `memoizedFibonacci(35)` should be significantly faster on subsequent calls compared to the first call, and dramatically faster than a non-memoized `fibonacci(35)`."
          ],
          "hints": [
            "The `memoize` function will need a way to store results associated with inputs. A plain JavaScript object can work if keys are simple strings, or a `Map` for more complex keys.",
            "For a simple `fibonacci(n)`, `String(n)` is a sufficient key. For functions with multiple or complex arguments, `JSON.stringify(args)` or a more sophisticated hashing might be needed.",
            "Remember to ensure the original function `fn` is called correctly, passing its arguments and potentially preserving its `this` context (though for `fibonacci` it's not strictly necessary)."
          ],
          "tags": [
            "memoization",
            "recursion",
            "dynamic_programming",
            "higher-order_functions",
            "performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "closures",
            "recursion",
            "objects_maps"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "pure_functions",
            "caching",
            "time_complexity"
          ]
        },
        {
          "id": "task_generator_1",
          "title": "Build a Simple Pagination Generator",
          "description": "\nYour task is to create a generator function that simulates pagination for a large dataset. The generator should yield 'pages' of items from an input array, given a specified page size. This is useful for fetching data in chunks without loading the entire dataset into memory.\n\n**Requirements:**\n1.  Create a generator function `paginate(items, pageSize)`.\n2.  `items` will be an array of any type of data.\n3.  `pageSize` will be a positive integer specifying the number of items per page.\n4.  The generator should `yield` an array for each page. The last page might contain fewer items than `pageSize`.\n5.  If `items` is empty, or `pageSize` is invalid (e.g., non-positive), the generator should handle it gracefully (e.g., yield nothing or throw an error).\n\n**Example Usage:**\n```javascript\nconst data = Array.from({ length: 10 }, (_, i) => `Item ${i + 1}`);\nconst paginator = paginate(data, 3);\n\nconsole.log(paginator.next().value); // ['Item 1', 'Item 2', 'Item 3']\nconsole.log(paginator.next().value); // ['Item 4', 'Item 5', 'Item 6']\nconsole.log(paginator.next().value); // ['Item 7', 'Item 8', 'Item 9']\nconsole.log(paginator.next().value); // ['Item 10']\nconsole.log(paginator.next().done);  // true\n```\n",
          "difficulty": "medium",
          "startingCode": "function* paginate(items, pageSize) {\n  if (!Array.isArray(items) || pageSize <= 0) {\n    // TODO: Handle invalid input\n    return;\n  }\n\n  // TODO: Implement pagination logic using yield\n  // let startIndex = 0;\n  // while (startIndex < items.length) {\n  //   const page = items.slice(startIndex, startIndex + pageSize);\n  //   yield page;\n  //   startIndex += pageSize;\n  // }\n}\n\n// Example Usage:\n// const data = Array.from({ length: 10 }, (_, i) => `Item ${i + 1}`);\n// const paginator = paginate(data, 3);\n// console.log(paginator.next().value);\n// console.log(paginator.next().value);\n// console.log(paginator.next().value);\n// console.log(paginator.next().value);\n// console.log(paginator.next().done);\n",
          "solutionCode": "function* paginate(items, pageSize) {\n  if (!Array.isArray(items)) {\n    throw new Error('Input items must be an array.');\n  }\n  if (pageSize <= 0) {\n    throw new Error('Page size must be a positive integer.');\n  }\n  if (items.length === 0) {\n    return; // Yield nothing for empty array\n  }\n\n  let startIndex = 0;\n  while (startIndex < items.length) {\n    const page = items.slice(startIndex, startIndex + pageSize);\n    yield page;\n    startIndex += pageSize;\n  }\n}\n\n// Example Usage:\nconsole.log('--- Pagination Test 1 (Basic) ---');\nconst data1 = Array.from({ length: 10 }, (_, i) => `Item ${i + 1}`);\nconst paginator1 = paginate(data1, 3);\nconsole.log(paginator1.next().value); // ['Item 1', 'Item 2', 'Item 3']\nconsole.log(paginator1.next().value); // ['Item 4', 'Item 5', 'Item 6']\nconsole.log(paginator1.next().value); // ['Item 7', 'Item 8', 'Item 9']\nconsole.log(paginator1.next().value); // ['Item 10']\nconsole.log(paginator1.next().done);  // true\n\nconsole.log('\\n--- Pagination Test 2 (Exact Fit) ---');\nconst data2 = [1, 2, 3, 4, 5, 6];\nconst paginator2 = paginate(data2, 2);\nconsole.log(paginator2.next().value); // [1, 2]\nconsole.log(paginator2.next().value); // [3, 4]\nconsole.log(paginator2.next().value); // [5, 6]\nconsole.log(paginator2.next().done);  // true\n\nconsole.log('\\n--- Pagination Test 3 (Single Page) ---');\nconst data3 = ['A', 'B'];\nconst paginator3 = paginate(data3, 5);\nconsole.log(paginator3.next().value); // ['A', 'B']\nconsole.log(paginator3.next().done);  // true\n\nconsole.log('\\n--- Pagination Test 4 (Empty Array) ---');\nconst data4 = [];\nconst paginator4 = paginate(data4, 3);\nconsole.log(paginator4.next().value); // undefined\nconsole.log(paginator4.next().done);  // true\n\nconsole.log('\\n--- Pagination Test 5 (Invalid PageSize) ---');\ntry {\n  const paginator5 = paginate(data1, 0);\n  paginator5.next();\n} catch (e) {\n  console.error(e.message); // Page size must be a positive integer.\n}\n\nconsole.log('\\n--- Pagination Test 6 (Invalid Items) ---');\ntry {\n  const paginator6 = paginate(null, 5);\n  paginator6.next();\n} catch (e) {\n  console.error(e.message); // Input items must be an array.\n}\n",
          "testCases": [
            "Test with `paginate([1,2,3,4,5], 2)`: Should yield `[1,2]`, then `[3,4]`, then `[5]`.",
            "Test with `paginate(['a','b','c'], 1)`: Should yield `['a']`, then `['b']`, then `['c']`.",
            "Test with `paginate([], 5)`: Should yield nothing, `done` should be `true` on first `next()`.",
            "Test with `paginate([1,2,3], 3)`: Should yield `[1,2,3]` then `done` true.",
            "Test with `paginate([1,2,3], 0)`: Should throw an error for invalid page size.",
            "Test with `paginate(null, 5)`: Should throw an error for invalid items type.",
            "Test with large array (e.g., 1000 items, page size 100) to ensure efficiency (though not strictly measurable in this setup, concept applies)."
          ],
          "hints": [
            "Use a `while` loop to continue yielding pages as long as there are items left.",
            "The `Array.prototype.slice()` method is useful for extracting portions of an array.",
            "Remember to increment your starting index after each `yield` to move to the next page.",
            "Consider edge cases like an empty input array or a `pageSize` larger than the total number of items."
          ],
          "tags": [
            "generators",
            "iteration",
            "pagination",
            "arrays",
            "lazy_evaluation"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "arrays",
            "loops",
            "basic_error_handling"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "iterators",
            "data_streaming",
            "memory_optimization"
          ]
        },
        {
          "id": "task_async_1",
          "title": "Fetch and Aggregate Data from Multiple APIs with `async/await`",
          "description": "\nYour task is to write an `async` function that fetches data from multiple simulated API endpoints concurrently and then aggregates the results. You need to handle potential errors from individual API calls gracefully.\n\n**Requirements:**\n1.  Create two mock asynchronous functions, `fetchProducts(category)` and `fetchReviews(productId)`.\n    *   `fetchProducts` should return a Promise that resolves with an array of product objects or rejects with an error.\n    *   `fetchReviews` should return a Promise that resolves with an array of review objects for a given product ID or rejects with an error.\n    *   Introduce artificial delays and potential failures for realism.\n2.  Implement an `async` function `getProductsWithReviews(category)`.\n    *   This function should first call `fetchProducts(category)`.\n    *   For each product fetched, it should then call `fetchReviews(productId)` to get its reviews.\n    *   Crucially, the `fetchReviews` calls for different products should happen **in parallel**.\n    *   Aggregate the results such that each product object includes a `reviews` array.\n3.  Implement robust error handling: If `fetchProducts` fails, `getProductsWithReviews` should catch and log the error and return an empty array or throw. If individual `fetchReviews` calls fail, they should not stop the entire process; instead, the corresponding product should simply have an empty `reviews` array or an `error` property indicating the failure.\n\n**Output Structure Example:**\n```json\n[\n  {\n    \"id\": \"p1\",\n    \"name\": \"Laptop\",\n    \"reviews\": [\n      { \"id\": \"r1\", \"text\": \"Great laptop\" },\n      { \"id\": \"r2\", \"text\": \"Fast shipping\" }\n    ]\n  },\n  {\n    \"id\": \"p2\",\n    \"name\": \"Mouse\",\n    \"reviews\": [] // If reviews fetch failed or no reviews\n  }\n]\n```\n",
          "difficulty": "hard",
          "startingCode": "async function fetchProducts(category) {\n  console.log(`Fetching products for category: ${category}...`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (category === 'electronics') {\n        resolve([\n          { id: 'p1', name: 'Laptop', price: 1200 },\n          { id: 'p2', name: 'Mouse', price: 25 }\n        ]);\n      } else if (category === 'books') {\n        resolve([\n          { id: 'b1', name: 'The Great Gatsby', price: 15 }\n        ]);\n      } else if (category === 'fail') {\n        throw new Error('Failed to fetch products for category: fail'); // This will reject the promise\n      } else {\n        resolve([]);\n      }\n    }, 500);\n  });\n}\n\nasync function fetchReviews(productId) {\n  console.log(`Fetching reviews for product: ${productId}...`);\n  return new Promise((resolve, reject) => {\n    const delay = Math.random() * 500 + 200; // Random delay between 200-700ms\n    setTimeout(() => {\n      if (productId === 'p1') {\n        resolve([\n          { id: 'r1', text: 'Great laptop' },\n          { id: 'r2', text: 'Fast shipping' }\n        ]);\n      } else if (productId === 'p2') {\n        // Simulate a failure for a specific product's reviews\n        reject(new Error(`Failed to fetch reviews for ${productId}`));\n      } else if (productId === 'b1') {\n        resolve([]); // No reviews for books\n      } else {\n        resolve([]);\n      }\n    }, delay);\n  });\n}\n\nasync function getProductsWithReviews(category) {\n  // TODO: Implement the logic here\n  // 1. Fetch products\n  // 2. For each product, initiate parallel review fetches\n  // 3. Handle errors gracefully for both product and review fetches\n  // 4. Aggregate results\n  console.log(`Starting aggregation for category: ${category}`);\n  try {\n    const products = await fetchProducts(category);\n    \n    // TODO: Map products to promises for reviews, then use Promise.allSettled\n    // or Promise.all with individual catches\n\n    // Placeholder return\n    return products;\n\n  } catch (error) {\n    console.error(`Error in getProductsWithReviews for category '${category}':`, error.message);\n    // TODO: Return empty array or re-throw, based on requirement\n    return [];\n  }\n}\n\n// Example Usage:\n// (async () => {\n//   console.log('\\n--- Electronics Category ---');\n//   const electronicsData = await getProductsWithReviews('electronics');\n//   console.log('Electronics Data:', JSON.stringify(electronicsData, null, 2));\n\n//   console.log('\\n--- Books Category ---');\n//   const booksData = await getProductsWithReviews('books');\n//   console.log('Books Data:', JSON.stringify(booksData, null, 2));\n\n//   console.log('\\n--- Fail Category (Product Fetch) ---');\n//   const failData = await getProductsWithReviews('fail'); // This should cause an error\n//   console.log('Fail Data:', JSON.stringify(failData, null, 2));\n\n//   console.log('\\n--- Unknown Category ---');\n//   const unknownData = await getProductsWithReviews('unknown');\n//   console.log('Unknown Data:', JSON.stringify(unknownData, null, 2));\n// })();\n",
          "solutionCode": "async function fetchProducts(category) {\n  console.log(`Fetching products for category: ${category}...`);\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (category === 'electronics') {\n        resolve([\n          { id: 'p1', name: 'Laptop', price: 1200 },\n          { id: 'p2', name: 'Mouse', price: 25 },\n          { id: 'p3', name: 'Keyboard', price: 75 }\n        ]);\n      } else if (category === 'books') {\n        resolve([\n          { id: 'b1', name: 'The Great Gatsby', price: 15 }\n        ]);\n      } else if (category === 'fail-products') {\n        reject(new Error('Simulated network error fetching products.'));\n      } else {\n        resolve([]); // Empty array for unknown categories\n      }\n    }, 500);\n  });\n}\n\nasync function fetchReviews(productId) {\n  console.log(`Fetching reviews for product: ${productId}...`);\n  return new Promise((resolve, reject) => {\n    const delay = Math.random() * 300 + 100; // Random delay between 100-400ms\n    setTimeout(() => {\n      if (productId === 'p1') {\n        resolve([\n          { id: 'r1', text: 'Great laptop' },\n          { id: 'r2', text: 'Fast shipping' }\n        ]);\n      } else if (productId === 'p2') {\n        // Simulate a failure for a specific product's reviews\n        reject(new Error(`Simulated error fetching reviews for ${productId}`));\n      } else if (productId === 'b1') {\n        resolve([]); // No reviews for books\n      } else if (productId === 'p3') {\n         resolve([{ id: 'r3', text: 'Nice keyboard' }]);\n      } else {\n        resolve([]); // No reviews for other products\n      }\n    }, delay);\n  });\n}\n\nasync function getProductsWithReviews(category) {\n  console.log(`\\n--- Starting aggregation for category: ${category} ---`);\n  let products = [];\n  try {\n    products = await fetchProducts(category);\n  } catch (error) {\n    console.error(`ERROR: Failed to fetch products for category '${category}':`, error.message);\n    return []; // If products fetch fails, return empty array\n  }\n\n  // If no products, no need to fetch reviews\n  if (products.length === 0) {\n    console.log(`No products found for category: ${category}. Returning empty.`);\n    return [];\n  }\n\n  // Map each product to a promise for its reviews\n  // Use .then().catch() on individual promises to prevent Promise.all from failing fast\n  const reviewPromises = products.map(async product => {\n    try {\n      const reviews = await fetchReviews(product.id);\n      return { ...product, reviews };\n    } catch (error) {\n      console.error(`WARNING: Failed to fetch reviews for product ${product.id}:`, error.message);\n      // If review fetch fails, include product but with empty reviews array and an error flag\n      return { ...product, reviews: [], reviewError: error.message }; \n    }\n  });\n\n  // Await all review promises concurrently\n  // Promise.all is used here because individual errors are caught and handled already\n  const productsWithReviews = await Promise.all(reviewPromises);\n\n  console.log(`--- Finished aggregation for category: ${category} ---`);\n  return productsWithReviews;\n}\n\n// Example Usage:\n(async () => {\n  const electronicsData = await getProductsWithReviews('electronics');\n  console.log('Result (Electronics):', JSON.stringify(electronicsData, null, 2));\n\n  const booksData = await getProductsWithReviews('books');\n  console.log('Result (Books):', JSON.stringify(booksData, null, 2));\n\n  const failProductData = await getProductsWithReviews('fail-products');\n  console.log('Result (Failed Product Fetch):', JSON.stringify(failProductData, null, 2));\n\n  const unknownCategoryData = await getProductsWithReviews('unknown-category');\n  console.log('Result (Unknown Category):', JSON.stringify(unknownCategoryData, null, 2));\n\n  // To demonstrate a review fetch failure for a product whose category fetch succeeded:\n  // 'p2' (Mouse) reviews are set to fail in fetchReviews mock.\n  const electronicsWithErrorReviews = await getProductsWithReviews('electronics');\n  console.log('Result (Electronics with Review Errors):', JSON.stringify(electronicsWithErrorReviews, null, 2));\n})();\n",
          "testCases": [
            "Call `getProductsWithReviews('electronics')`: Should return products with reviews for 'p1' and 'p3', and 'p2' should have an empty 'reviews' array due to its simulated failure, along with a `reviewError` property.",
            "Call `getProductsWithReviews('books')`: Should return product 'b1' with an empty 'reviews' array.",
            "Call `getProductsWithReviews('fail-products')`: Should log an error for products fetch and return an empty array.",
            "Call `getProductsWithReviews('nonexistent-category')`: Should return an empty array after `fetchProducts` resolves with an empty array.",
            "Verify all review fetches for successful products (e.g., 'p1', 'p3') happen concurrently (output order might not confirm this, but `Promise.all` ensures it)."
          ],
          "hints": [
            "For concurrent fetching of reviews for multiple products, `Promise.all` is the go-to method. Remember that `Promise.all` fails fast (rejects immediately if any of its input promises reject).",
            "To prevent `Promise.all` from failing the entire process if an individual review fetch fails, you'll need to wrap each `fetchReviews` call in its own `try...catch` block (or append `.catch()` to the Promise) *before* passing it to `Promise.all`. This way, the inner `catch` handles the error, and the promise passed to `Promise.all` always resolves (e.g., with an object indicating success/failure or with empty reviews).",
            "Structure your `async` function with a top-level `try...catch` for the initial `fetchProducts` call.",
            "Consider using `Array.prototype.map` to transform your products array into an array of Promises for reviews."
          ],
          "tags": [
            "async_await",
            "promises",
            "API_integration",
            "error_handling",
            "concurrency",
            "frontend"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "promises",
            "async_await",
            "array_methods",
            "error_handling"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Promise.all",
            "Promise.allSettled",
            "network_requests",
            "data_aggregation"
          ]
        },
        {
          "id": "task_arrow_regular_1",
          "title": "Refactor a Class with `setInterval` to Use Arrow Functions for Correct `this` Binding",
          "description": "\nYour task is to refactor a JavaScript class that uses `setInterval` to update its internal state, addressing a common `this` binding issue. The original code uses a regular function for the `setInterval` callback, leading to incorrect `this` context. You need to fix this using arrow functions.\n\n**Requirements:**\n1.  Take the provided `Counter` class with a `start` method that uses `setInterval`.\n2.  Modify the `setInterval` callback function within the `start` method to be an **arrow function**.\n3.  Ensure that `this.count` is correctly incremented and `this.display()` is correctly called, referring to the `Counter` instance.\n4.  Add a `stop` method to clear the interval.\n5.  Demonstrate the corrected behavior by creating an instance of the class and observing the console output.\n",
          "difficulty": "medium",
          "startingCode": "class Counter {\n  constructor(initialCount = 0) {\n    this.count = initialCount;\n    this.intervalId = null;\n  }\n\n  display() {\n    console.log(`Current count: ${this.count}`);\n  }\n\n  start() {\n    console.log('Starting counter...');\n    this.intervalId = setInterval(function() {\n      // Problem: 'this' here refers to the global object (window) or is undefined in strict mode,\n      // NOT the Counter instance.\n      this.count++; \n      this.display(); // Will cause error or try to call method on global object\n    }, 1000);\n  }\n\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      console.log('Counter stopped.');\n      this.intervalId = null;\n    }\n  }\n}\n\n// Example Usage (will fail as is):\n// const myCounter = new Counter();\n// myCounter.start();\n// setTimeout(() => myCounter.stop(), 5500);\n",
          "solutionCode": "class Counter {\n  constructor(initialCount = 0) {\n    this.count = initialCount;\n    this.intervalId = null;\n  }\n\n  display() {\n    console.log(`Current count: ${this.count}`);\n  }\n\n  start() {\n    console.log('Starting counter...');\n    // Fix: Use an arrow function for the setInterval callback.\n    // The arrow function lexically binds 'this' from the 'start' method's scope,\n    // which correctly refers to the Counter instance.\n    this.intervalId = setInterval(() => {\n      this.count++; \n      this.display(); \n    }, 1000);\n  }\n\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      console.log('Counter stopped.');\n      this.intervalId = null;\n    }\n  }\n}\n\n// Example Usage:\nconsole.log('Creating and starting Counter 1...');\nconst myCounter1 = new Counter();\nmyCounter1.start();\n// Stop after 5.5 seconds to observe multiple increments\nsetTimeout(() => myCounter1.stop(), 5500);\n\nconsole.log('\\nCreating and starting Counter 2...');\nconst myCounter2 = new Counter(100);\nmyCounter2.start();\n// Stop after 3.5 seconds\nsetTimeout(() => myCounter2.stop(), 3500);\n",
          "testCases": [
            "Create a `Counter` instance and call `start()`. Observe that `Current count:` logs increment correctly (e.g., 0, 1, 2, ...).",
            "Verify that `display()` method is called successfully, indicating `this` is correctly bound to the instance.",
            "Call `stop()` after some time and ensure the counter stops, and no more logs appear.",
            "Create multiple `Counter` instances and verify they run independently without interfering with each other's `this` context."
          ],
          "hints": [
            "Recall how arrow functions handle `this` binding compared to regular functions. Which `this` do they inherit?",
            "The problem lies specifically within the `setInterval` callback. The `this` outside that callback (in the `start` method) is already correct.",
            "Consider what `this` would be if the `setInterval` callback were a regular function and how that differs from what `this` refers to when it's an arrow function."
          ],
          "tags": [
            "arrow_functions",
            "this_binding",
            "classes",
            "timers",
            "frontend"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "classes_ES6",
            "this_keyword",
            "setinterval_clearinterval"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "closures",
            "event_handling",
            "object_oriented_programming"
          ]
        }
      ]
    }
  },
  {
    "id": "b759b889-bdef-436c-8e39-9fcae28ac9b8",
    "startLine": 800,
    "endLine": 899,
    "processedDate": "2025-06-17T07:24:38.770Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_this_context_es5",
          "title": "Managing 'this' Context in ES5",
          "content": "In JavaScript, the `this` keyword refers to the context in which a function is executed. Its value is determined dynamically by how the function is called, rather than where it is declared. This dynamic behavior can often lead to confusion, especially in asynchronous callbacks or event handlers where the execution context might differ from the expected context.\n\n### Challenges with `this` in ES5\nWhen a function is used as a callback, particularly with `setInterval` or `setTimeout`, or as an event handler, its `this` context often defaults to the global object (e.g., `window` in browsers, or `undefined` in strict mode), rather than the object that owns the method. This happens because the callback function is invoked directly by the `setInterval` (or event listener) mechanism, not as a method of your object.\n\n### Solutions for Maintaining `this` Context in ES5\nTo overcome this, ES5 offers several patterns to explicitly control or preserve the `this` context.\n\n1.  **Using a 'that' / 'self' Variable (Closure)**:\n    This common pattern involves saving a reference to the desired `this` context in a variable (commonly named `that` or `self`) outside the callback function, but within the scope of the method where `this` is correct. The callback function, being a closure, then captures and retains access to this `that` variable, allowing it to correctly reference the object's properties.\n\n2.  **Using `Function.prototype.bind()`**:\n    The `bind()` method creates a new function that, when called, has its `this` keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. It returns a *new function* with the `this` context permanently bound. This is particularly useful when you need to pass a method as a callback and ensure it always operates on a specific object instance.",
          "examples": [
            {
              "id": "example_this_es5_that_self",
              "title": "Solution 1: Using a 'that' / 'self' variable",
              "code": "function Person() {\n  var that = this; // 'this' here refers to the new Person instance\n  that.age = 0;\n  \n  setInterval(function growUp() {\n    // Inside growUp, 'this' would normally be the global object (window) or undefined (strict mode)\n    // But 'that' correctly references the Person instance due to closure\n    that.age++;\n    console.log(`Person's age (via that): ${that.age}`);\n  }, 1000);\n}\n\n// var p1 = new Person(); // Uncomment to see it in action",
              "explanation": "In this example, `var that = this;` captures the `this` context of the `Person` constructor (which is the newly created `Person` instance) into the `that` variable. The `growUp` function, being a closure, maintains access to `that`, allowing it to correctly increment the `age` property of the `Person` instance, even though `growUp` itself is called without a specific `this` context (i.e., by `setInterval`).",
              "language": "javascript"
            },
            {
              "id": "example_this_es5_bind",
              "title": "Solution 2: Using Function.prototype.bind()",
              "code": "function Person() {\n  this.age = 0;\n  \n  // setInterval expects a function. We use .bind(this) to create a new function\n  // where 'this' is permanently bound to the current Person instance.\n  setInterval(function growUp() {\n    // Inside growUp, 'this' now correctly refers to the Person instance\n    this.age++;\n    console.log(`Person's age (via bind): ${this.age}`);\n  }.bind(this), 1000); // 'this' here refers to the Person instance\n}\n\n// var p2 = new Person(); // Uncomment to see it in action",
              "explanation": "Here, `bind(this)` is called on the `growUp` function. The `this` passed to `bind` (which is the `Person` instance in this context) becomes the permanent `this` for the `growUp` function when it's eventually called by `setInterval`. This creates a new function that `setInterval` uses, ensuring `this.age++` correctly modifies the `age` of the `Person` instance.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_this_es5_1",
            "question_this_es5_2",
            "question_this_es5_3",
            "question_this_es5_4"
          ],
          "relatedTasks": [
            "task_this_context_timer"
          ],
          "tags": [
            "javascript",
            "this",
            "context",
            "es5",
            "bind",
            "closure",
            "scope",
            "function-prototype"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "theory_this_context_es6"
          ]
        },
        {
          "id": "theory_this_context_es6_arrow",
          "title": "Lexical 'this' with ES6 Arrow Functions",
          "content": "ES6 introduced arrow functions, a new syntax for writing functions that comes with a significant difference in how they handle the `this` keyword. Unlike traditional `function` expressions, arrow functions do not create their own `this` context. Instead, they inherit `this` from their parent (enclosing) scope at the time they are defined.\n\n### Lexical `this`\nThis behavior is known as 'lexical `this` binding'. It means that an arrow function's `this` is bound to the `this` of the code where the arrow function is *defined*, not where it is *called*. This makes them particularly useful for callbacks and event handlers where maintaining the `this` context of the surrounding object is important, as it eliminates the need for `var that = this;` or `.bind(this)`.\n\n### Advantages\n*   **Readability**: Simplifies code by removing explicit `this` binding workarounds.\n*   **Predictability**: `this` behaves more intuitively, always referring to the `this` of the lexical parent.\n*   **Conciseness**: Shorter syntax for functions.",
          "examples": [
            {
              "id": "example_this_es6_arrow",
              "title": "Arrow Function Solution for 'this' Context",
              "code": "// Arrow functions don't create their own 'this' context\nfunction Person() {\n  this.age = 0; // 'this' here refers to the new Person instance\n  \n  setInterval(() => {\n    // 'this' inside the arrow function lexically inherits 'this' from the Person constructor scope.\n    // Therefore, 'this' correctly refers to the Person instance.\n    this.age++; \n    console.log(`Person's age (via arrow function): ${this.age}`);\n  }, 1000);\n}\n\n// var p3 = new Person(); // Uncomment to see it in action",
              "explanation": "In this example, the `setInterval` callback is an arrow function. The `this` inside the arrow function automatically refers to the `this` of the `Person` constructor function (the `Person` instance), because that's its lexical parent. This eliminates the need for `.bind(this)` or `var that = this;`, leading to cleaner and more intuitive code for `this` context management in callbacks.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_this_es6_1",
            "question_this_es6_2",
            "question_this_es6_3"
          ],
          "relatedTasks": [
            "task_this_context_timer"
          ],
          "tags": [
            "javascript",
            "this",
            "context",
            "es6",
            "arrow-functions",
            "lexical-scope",
            "callbacks"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_this_context_es5"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_component_this",
            "event_handlers"
          ]
        },
        {
          "id": "theory_function_chaining",
          "title": "Function Chaining (Method Chaining)",
          "content": "Function chaining, also known as method chaining, is a programming technique that allows multiple methods to be called sequentially on the same object in a single statement. This is achieved by having each method return the object itself (`this`), enabling the next method in the chain to be called immediately.\n\n### Benefits of Function Chaining:\n*   **Readability**: Code becomes more concise and flows like a natural sentence, making it easier to read and understand.\n*   **Conciseness**: Reduces the need for intermediate variables.\n*   **Fluent Interface**: Creates a 'fluent' API, which is often seen in libraries like jQuery, D3.js, and modern JavaScript frameworks (e.g., in building DOM elements or promises).\n\n### Implementation:\nTo implement method chaining, each method that is part of the chain must return `this` (the current instance of the object) after performing its operation. Methods that are intended to retrieve a value (like `toString()` in the example) will typically break the chain by returning the value instead of `this`.",
          "examples": [
            {
              "id": "example_function_chaining_stringbuilder",
              "title": "StringBuilder with Method Chaining",
              "code": "class StringBuilder {\n  constructor(str = \"\") {\n    this.str = str;\n  }\n  \n  // append returns 'this' to allow chaining\n  append(s) {\n    this.str += s;\n    return this;\n  }\n  \n  // toString breaks the chain by returning the final string\n  toString() {\n    return this.str;\n  }\n}\n\nconst message = new StringBuilder().append(\"Hello\").append(\" \").append(\"World!\").toString();\nconsole.log(message); // \"Hello World!\"\n",
              "explanation": "In this `StringBuilder` class, the `append` method modifies the internal `str` property and then crucially returns `this`. This allows calls to `append` to be chained one after another on the same `StringBuilder` instance. The `toString` method then retrieves the final string, breaking the chain. This demonstrates a common pattern for building fluent APIs.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_chaining_1",
            "question_chaining_2",
            "question_chaining_3"
          ],
          "relatedTasks": [
            "task_chainable_calculator"
          ],
          "tags": [
            "javascript",
            "design-patterns",
            "method-chaining",
            "fluent-api",
            "classes",
            "oop"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "javascript_classes",
            "this"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "api_design",
            "library_development"
          ]
        },
        {
          "id": "theory_higher_order_functions",
          "title": "Higher-Order Functions (HOF)",
          "content": "Higher-Order Functions (HOFs) are a cornerstone of functional programming in JavaScript. A function is considered higher-order if it does at least one of the following:\n\n1.  **Takes one or more functions as arguments.** (e.g., `Array.prototype.map`, `setTimeout`)\n2.  **Returns a function as its result.** (e.g., a function factory, `Function.prototype.bind`)\n\nHOFs enable powerful abstractions, code reuse, and cleaner, more declarative code. They treat functions as 'first-class citizens', meaning functions can be assigned to variables, passed as arguments, and returned from other functions just like any other data type (numbers, strings, objects).\n\n### Common Use Cases:\n*   **Callbacks**: Functions executed after some operation completes (e.g., event handlers, asynchronous operations).\n*   **Decorators/Wrappers**: Functions that add behavior to other functions.\n*   **Currying/Partial Application**: Transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument.\n*   **Composition**: Combining simple functions to build more complex ones.",
          "examples": [
            {
              "id": "example_hof_pluckdeep",
              "title": "Higher-Order Function: `pluckDeep`",
              "code": "const pluckDeep = key => obj => {\n  // `key.split('.')` splits the string 'a.b.c' into ['a', 'b', 'c']\n  // `reduce` then iteratively accesses the nested properties\n  return key.split('.').reduce((accum, currentKey) => {\n    // Ensure accum is not null/undefined before accessing its property\n    return (accum && typeof accum === 'object' && accum.hasOwnProperty(currentKey)) ? accum[currentKey] : undefined;\n  }, obj);\n}\n\nconst user = { \n  id: 1, \n  profile: { \n    name: 'Alice', \n    address: { \n      street: '123 Main St' \n    }\n  }\n};\n\nconst getStreet = pluckDeep('profile.address.street');\nconsole.log(getStreet(user)); // '123 Main St'\n\nconst getName = pluckDeep('profile.name');\nconsole.log(getName(user)); // 'Alice'\n\nconst getNonExistent = pluckDeep('profile.address.city');\nconsole.log(getNonExistent(user)); // undefined",
              "explanation": "`pluckDeep` is a higher-order function because it takes `key` and returns *another function* (`obj => ...`). The returned function then takes an `obj` and uses `reduce` to safely navigate through nested properties specified by the `key` string (e.g., 'profile.address.street'). This allows creating specialized data accessors like `getStreet` or `getName` for reuse.",
              "language": "javascript"
            },
            {
              "id": "example_hof_compose",
              "title": "Higher-Order Function: `compose`",
              "code": "const compose = (...fns) => res => {\n  // `reduce` processes functions from right-to-left\n  // `reduceRight` would achieve left-to-right if preferred for pipelines\n  return fns.reduce((accum, nextFn) => nextFn(accum), res);\n}\n\nconst add5 = x => x + 5;\nconst multiplyBy2 = x => x * 2;\nconst subtract3 = x => x - 3;\n\n// Applying functions sequentially from left to right: subtract3(multiplyBy2(add5(initialValue)))\nconst operate = compose(add5, multiplyBy2, subtract3);\n\n// If initialValue = 10:\n// 1. add5(10) -> 15\n// 2. multiplyBy2(15) -> 30\n// 3. subtract3(30) -> 27\nconsole.log(operate(10)); // 27\n\nconst toUpperCase = str => str.toUpperCase();\nconst addExclamation = str => str + '!';\nconst reverseString = str => str.split('').reverse().join('');\n\nconst transformText = compose(reverseString, toUpperCase, addExclamation);\n// If initialValue = 'hello':\n// 1. reverseString('hello') -> 'olleh'\n// 2. toUpperCase('olleh') -> 'OLLEH'\n// 3. addExclamation('OLLEH') -> 'OLLEH!'\nconsole.log(transformText('hello')); // 'OLLEH!'",
              "explanation": "`compose` is a higher-order function because it takes an arbitrary number of functions (`...fns`) as arguments and returns a *single new function*. This new function then takes an initial `res` and applies each of the composed functions to it in a sequence. The `reduce` method iterates through the functions, applying each one to the result of the previous, effectively 'pipelining' the data through a series of transformations. This pattern is fundamental in functional programming for building complex operations from simpler, reusable functions.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_hof_1",
            "question_hof_2",
            "question_hof_3",
            "question_hof_4"
          ],
          "relatedTasks": [
            "task_hof_data_transformer",
            "task_hof_event_emitter"
          ],
          "tags": [
            "javascript",
            "functional-programming",
            "hof",
            "callbacks",
            "currying",
            "compose",
            "reduce",
            "first-class-functions"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "array_methods",
            "closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "redux_middleware",
            "react_hooks_patterns",
            "data_transformation"
          ]
        },
        {
          "id": "theory_oop_intro",
          "title": "Introduction to Object-Oriented Programming (OOP) in JavaScript",
          "content": "Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around 'objects' rather than functions and logic. An object is a self-contained unit that bundles data (attributes/properties) and the methods (functions/behaviors) that operate on that data. This approach aims to make software more modular, flexible, and understandable.\n\nJavaScript, while often described as a multi-paradigm language, supports OOP through various mechanisms. Historically, it used a unique 'prototypal inheritance' model. More recently, with ES6, `class` syntax was introduced, providing a more familiar syntactic sugar over the underlying prototypal inheritance, making OOP patterns more accessible to developers coming from class-based languages like Java or C++.",
          "examples": [],
          "relatedQuestions": [
            "question_oop_intro_1",
            "question_oop_intro_2"
          ],
          "relatedTasks": [],
          "tags": [
            "javascript",
            "oop",
            "paradigm",
            "objects",
            "classes",
            "prototypes"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "data_types_objects"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "theory_oop_principles",
            "theory_prototypal_inheritance"
          ]
        },
        {
          "id": "theory_oop_principles",
          "title": "Core Principles of Object-Oriented Programming",
          "content": "OOP is typically guided by four fundamental principles, often referred to as the four pillars of OOP. Understanding these principles is crucial for designing robust, maintainable, and scalable software systems.\n\n1.  **Encapsulation**: This principle involves bundling the data (attributes) and methods that operate on that data into a single unit or object. It also implies 'information hiding', where the internal state of an object is protected from direct external access, and access is typically provided only through public methods. This reduces complexity and helps in maintaining data integrity.\n    *   *In JavaScript*: Achieved through closures (for private variables) or ES6 classes with conventions (like prefixing private-like properties with `_`) or actual private class fields (with `#`).\n\n2.  **Inheritance**: Inheritance is a mechanism by which one class or object can acquire the properties and methods of another class or object. It promotes code reuse and establishes a hierarchical relationship between objects (parent/child, base/derived). Derived objects can extend or override the inherited behavior.\n    *   *In JavaScript*: Achieved via prototypal inheritance (ES5) or the `extends` keyword (ES6 classes) which builds upon prototypes.\n\n3.  **Polymorphism**: Meaning 'many forms', polymorphism allows objects of different classes to be treated as objects of a common type. It enables a single interface to represent different underlying forms or types. This often involves defining a common method signature in a base class that derived classes can implement in their own specific ways. When this method is called on an object, the specific implementation depends on the object's actual type.\n    *   *In JavaScript*: Achieved through method overriding in prototypal inheritance or classes, where different objects can respond to the same method call in different ways.\n\n4.  **Abstraction**: Abstraction focuses on hiding the complex implementation details and showing only the essential features of an object. It provides a simplified view of functionality, allowing users to interact with objects at a high level without needing to understand the intricate internal workings. It defines what an object does rather than how it does it.\n    *   *In JavaScript*: Achieved through interfaces (implicitly via duck typing), abstract classes (conceptually, not directly supported), or by simply designing public APIs that hide internal complexity.",
          "examples": [],
          "relatedQuestions": [
            "question_oop_principles_1",
            "question_oop_principles_2",
            "question_oop_principles_3",
            "question_oop_principles_4"
          ],
          "relatedTasks": [],
          "tags": [
            "oop",
            "principles",
            "encapsulation",
            "inheritance",
            "polymorphism",
            "abstraction",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_oop_intro"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "design_patterns",
            "framework_architecture"
          ]
        },
        {
          "id": "theory_prototypal_inheritance",
          "title": "Prototypal Inheritance in JavaScript",
          "content": "Unlike traditional class-based object-oriented languages (like Java or C++), JavaScript uses a prototypal inheritance model. In JavaScript, objects inherit properties and methods directly from other objects (their prototypes) rather than from classes. Every JavaScript object has an internal slot `[[Prototype]]`, which points to another object, or `null`. This object is called its prototype. When you try to access a property or method on an object, and it's not found directly on the object, JavaScript looks for it in the object's prototype, then in the prototype's prototype, and so on, forming a 'prototype chain'.\n\n### Key Concepts:\n*   **Prototype Chain**: The series of links from an object to its prototype, and that prototype's prototype, up to `null`. This chain is traversed when a property or method is looked up.\n*   **`__proto__`**: A non-standard, but widely implemented, property that references an object's prototype. It's often used for inspection, but `Object.getPrototypeOf()` and `Object.setPrototypeOf()` are the standard ways.\n*   **`prototype` property of Constructors**: Functions in JavaScript have a special `prototype` property. When a function is used as a constructor (with the `new` keyword), the newly created object's `[[Prototype]]` is set to the `prototype` property of the constructor function. This is how methods and properties defined on the constructor's `prototype` become available to all instances created by that constructor.\n*   **`Object.create()`**: Creates a new object with the specified prototype object and properties.\n*   **Constructor Borrowing (`.call()` or `.apply()`)**: To inherit properties defined in the parent's constructor, the child constructor can invoke the parent constructor using `ParentConstructor.call(this, ...args)`. This ensures that properties initialized in the parent constructor are set on the child instance's `this` context.\n\n### How Inheritance Works with Prototypes:\n1.  Define a 'parent' constructor function and add shared methods/properties to its `prototype` property.\n2.  Define a 'child' constructor function.\n3.  Inside the child constructor, 'borrow' the parent constructor using `Parent.call(this, ...args)` to initialize parent-specific properties on the child instance.\n4.  Set the child's `prototype` to an object that inherits from the parent's `prototype`. The common way is `Child.prototype = Object.create(Parent.prototype);`.\n5.  Crucially, reset the `constructor` property on the child's prototype: `Child.prototype.constructor = Child;` (because `Object.create` will set `constructor` to `Parent`). This ensures `instanceof` and `constructor` checks work correctly.\n6.  Add specific methods/properties for the child to its `prototype`.",
          "examples": [
            {
              "id": "example_prototypal_inheritance_basic",
              "title": "Basic Prototypal Inheritance with Constructor Functions",
              "code": "// Parent constructor function\nvar Person = function(firstName) {\n  this.firstName = firstName;\n};\n\n// Methods shared by all Person instances are added to Person.prototype\nPerson.prototype.sayHello = function() {\n  console.log(\"Hello, I'm \" + this.firstName);\n};\n\n// Child constructor function\nfunction Student(firstName, subject) {\n  // 1. Call parent constructor to inherit parent's properties on 'this' (the Student instance)\n  Person.call(this, firstName);\n  this.subject = subject;\n}\n\n// 2. Set Student's prototype to an object that inherits from Person's prototype\n// This establishes the prototype chain: studentInstance -> Student.prototype -> Person.prototype -> Object.prototype\nStudent.prototype = Object.create(Person.prototype);\n\n// 3. Reset the constructor property, as Object.create sets it to Person\nStudent.prototype.constructor = Student;\n\n// 4. Add methods specific to Student\nStudent.prototype.saySubject = function() {\n  console.log(\"I study \" + this.subject);\n};\n\n// Create instances\nvar person1 = new Person(\"Alice\");\nvar student1 = new Student(\"Bob\", \"Math\");\n\nperson1.sayHello(); // \"Hello, I'm Alice\"\nstudent1.sayHello(); // \"Hello, I'm Bob\" (inherited from Person.prototype)\nstudent1.saySubject(); // \"I study Math\" (specific to Student.prototype)\n\nconsole.log(student1 instanceof Student); // true\nconsole.log(student1 instanceof Person); // true\nconsole.log(student1.constructor === Student); // true\n",
              "explanation": "This example demonstrates how `Student` inherits from `Person` using prototypal inheritance in ES5. `Person.call(this, firstName)` ensures that the `firstName` property from `Person`'s constructor is set on the `Student` instance. `Student.prototype = Object.create(Person.prototype)` sets up the prototype chain, allowing `Student` instances to access methods defined on `Person.prototype`. Finally, `Student.prototype.constructor = Student` corrects the `constructor` reference. This complex setup is largely simplified by ES6 `class` syntax, which internally uses this prototypal mechanism.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_prototypal_1",
            "question_prototypal_2",
            "question_prototypal_3",
            "question_prototypal_4"
          ],
          "relatedTasks": [
            "task_prototypal_inheritance_hierarchy"
          ],
          "tags": [
            "javascript",
            "oop",
            "prototypes",
            "inheritance",
            "prototype-chain",
            "constructor-functions",
            "object-create",
            "this",
            "es5"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_oop_intro",
            "theory_oop_principles"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "javascript_classes_deep_dive",
            "custom_javascript_frameworks"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_this_es5_1",
          "topic": "ES5 'this' Context",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary issue with 'this' when using traditional functions as callbacks in ES5?",
          "answer": "The 'this' context inside the callback often defaults to the global object (window/undefined) instead of the desired object instance, losing the intended context.",
          "options": [],
          "analysisPoints": [
            "Understanding of dynamic 'this' binding in JavaScript.",
            "Recognition of common pitfalls in asynchronous callbacks."
          ],
          "keyConcepts": [
            "this-context",
            "callbacks",
            "scope",
            "global-object"
          ],
          "evaluationCriteria": [
            "Ability to identify the core problem.",
            "Conciseness of explanation."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es5",
            "callbacks"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_es5_2",
          "topic": "ES5 'this' Context Solutions",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following ES5 code. Which line correctly binds the `this` context of the `Person` instance to the `growUp` function?\n\n```javascript\nfunction Person() {\n  this.age = 0;\n  setInterval(function growUp() {\n    this.age++;\n  } /* LINE A */, 1000);\n}\n```",
          "answer": ".bind(this)",
          "options": [
            "var self = this;",
            ".bind(this)",
            "growUp.call(this);",
            "this.growUp()"
          ],
          "analysisPoints": [
            "Understanding of `Function.prototype.bind`.",
            "Distinguishing `bind` from `call` and `apply` in terms of function invocation vs. function creation.",
            "Knowing when to use `self`/`that` vs. `bind`."
          ],
          "keyConcepts": [
            "this-context",
            "bind",
            "setInterval",
            "es5"
          ],
          "evaluationCriteria": [
            "Correct application of `bind` for persistent context.",
            "Understanding of method `bind` behavior."
          ],
          "example": "The `bind()` method creates a *new* function that, when called, has its `this` keyword set to the provided value. This is perfect for callbacks like `setInterval` because it returns a function that will be executed later, with the `this` context already fixed. `var self = this;` would typically be placed before `setInterval` and then `self.age++` would be used inside `growUp`. `call(this)` executes the function immediately, which is not suitable for a `setInterval` callback. `this.growUp()` would try to call `growUp` as a method on `this` (the `Person` instance), which is not how `setInterval` works.",
          "tags": [
            "javascript",
            "this",
            "es5",
            "bind",
            "mcq"
          ],
          "prerequisites": [
            "theory_this_context_es5"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_es5_3",
          "topic": "ES5 'this' Context Solutions",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following `Game` object's `start` method to correctly increment `this.score` every second using an ES5 solution (either `that`/`self` or `bind`). Explain your chosen approach.\n\n```javascript\nvar Game = {\n  score: 0,\n  start: function() {\n    console.log('Game started! Initial score: ' + this.score);\n    setInterval(function() {\n      this.score++; // Problematic line\n      console.log('Score: ' + this.score);\n    }, 1000);\n  }\n};\n\n// Game.start(); // Uncomment to test\n```",
          "answer": "```javascript\nvar Game = {\n  score: 0,\n  start: function() {\n    console.log('Game started! Initial score: ' + this.score);\n    // Solution 1: Using 'that' variable\n    // var that = this; \n    // setInterval(function() {\n    //   that.score++;\n    //   console.log('Score: ' + that.score);\n    // }, 1000);\n\n    // Solution 2: Using .bind(this)\n    setInterval(function() {\n      this.score++;\n      console.log('Score: ' + this.score);\n    }.bind(this), 1000);\n  }\n};\n\n// Explanation for Solution 2 (.bind(this)):\n// The .bind(this) method is used to create a new function where the 'this' context is permanently bound to the 'Game' object (the 'this' value from the 'start' method's execution context). \n// When setInterval later invokes this new, bound function, 'this.score' correctly refers to the 'score' property of the 'Game' object, resolving the context issue.",
          "options": [],
          "analysisPoints": [
            "Ability to apply ES5 'this' context solutions in a practical scenario.",
            "Understanding the behavior of `setInterval` with respect to `this`.",
            "Clarity of explanation for the chosen solution."
          ],
          "keyConcepts": [
            "this-context",
            "bind",
            "closures",
            "es5",
            "setInterval",
            "refactoring"
          ],
          "evaluationCriteria": [
            "Correctness of the refactored code.",
            "Completeness and accuracy of the explanation.",
            "Identification of the problematic line."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es5",
            "code-challenge",
            "refactoring"
          ],
          "prerequisites": [
            "theory_this_context_es5"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_es5_4",
          "topic": "ES5 'this' Context",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the `that`/`self` variable approach and the `Function.prototype.bind()` method for preserving `this` context in ES5. Discuss their use cases, advantages, and disadvantages.",
          "answer": "### 'that'/'self' Variable Approach\n*   **How it works**: A common pattern where you save a reference to the desired `this` context in a variable (e.g., `that` or `self`) outside the callback function, usually at the beginning of the enclosing function/method. The callback function, being a closure, captures this `that` variable from its lexical scope, allowing it to correctly access the intended object's properties.\n*   **Advantages**: \n    *   Very explicit and easy to understand for beginners.\n    *   Does not create a new function (unlike `bind`), which can sometimes be marginally more performant if performance is critical and many functions are involved (though often negligible).\n    *   Works in environments where `bind` might not be natively available (very old browsers, though `bind` is widely supported now).\n*   **Disadvantages**: \n    *   Can lead to repetitive `var that = this;` lines in multiple methods.\n    *   Less declarative than `bind` for `this` context. The intent of binding is clearer with `bind`.\n\n### `Function.prototype.bind()` Method\n*   **How it works**: `bind()` is a method on all functions that creates a *new function* (a 'bound function'). When this new function is called, its `this` keyword is set to the provided value (the first argument to `bind`), and it also pre-sets any leading arguments provided to `bind`.\n*   **Advantages**: \n    *   More declarative and concise than the `that`/`self` pattern, explicitly stating the `this` context.\n    *   It's a standard JavaScript feature, making code more idiomatic.\n    *   Allows partial application of arguments, in addition to binding `this`.\n*   **Disadvantages**: \n    *   Creates a new function every time `bind` is called. While usually not a performance bottleneck, in highly performance-critical loops or for very frequent event handlers, this might be a minor consideration.\n    *   The `this` context is permanently bound, meaning it cannot be changed later with `call` or `apply` (though this is often the desired behavior).\n\n### Use Cases & Comparison:\n*   **`that`/`self`**: Often preferred for simple, self-contained closures where `this` only needs to be captured once. Useful when `bind` is not strictly necessary or for maximum backward compatibility.\n*   **`bind()`**: Generally preferred for clarity and conciseness, especially when passing methods as callbacks to external APIs (like `addEventListener`, `setTimeout`, array methods like `map` where the callback `thisArg` is often the second argument). It's the more modern ES5 solution.\n\nIn modern JavaScript (ES6+), arrow functions largely supersede both for `this` binding within callbacks due to their lexical `this` behavior, offering the cleanest solution.",
          "options": [],
          "analysisPoints": [
            "Detailed understanding of both ES5 `this` binding techniques.",
            "Ability to articulate advantages and disadvantages of each.",
            "Comparison of their underlying mechanisms (closure vs. new function).",
            "Discussion of practical use cases."
          ],
          "keyConcepts": [
            "this-context",
            "bind",
            "closure",
            "es5",
            "advantages-disadvantages",
            "function-prototype"
          ],
          "evaluationCriteria": [
            "Depth of technical explanation for each method.",
            "Effectiveness of comparison (pros/cons).",
            "Clarity and structure of the response."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es5",
            "open-ended",
            "comparison"
          ],
          "prerequisites": [
            "theory_this_context_es5"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_this_es6_1",
          "topic": "ES6 Arrow Functions 'this' Context",
          "level": "easy",
          "type": "flashcard",
          "question": "How do ES6 arrow functions handle the `this` keyword differently from traditional functions?",
          "answer": "Arrow functions do not create their own `this` context; they lexically inherit `this` from their parent scope at the time of definition.",
          "options": [],
          "analysisPoints": [
            "Understanding of lexical 'this' binding.",
            "Key differentiator of arrow functions."
          ],
          "keyConcepts": [
            "arrow-functions",
            "this-context",
            "lexical-scope",
            "es6"
          ],
          "evaluationCriteria": [
            "Accuracy of definition.",
            "Conciseness."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es6",
            "arrow-functions"
          ],
          "prerequisites": [
            "theory_this_context_es6_arrow"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_es6_2",
          "topic": "ES6 Arrow Functions 'this' Context",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is an advantage of using an arrow function for a callback that needs to access the `this` context of its enclosing lexical scope?\n\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n  start() {\n    setInterval(() => {\n      this.count++;\n      console.log(this.count);\n    }, 1000);\n  }\n}\n// new Counter().start();\n```",
          "answer": "It automatically binds `this` to the lexical scope, avoiding manual binding or `var self = this;`.",
          "options": [
            "It executes faster than traditional functions.",
            "It creates its own `this` context, ensuring isolation.",
            "It automatically binds `this` to the global object.",
            "It automatically binds `this` to the lexical scope, avoiding manual binding or `var self = this;`."
          ],
          "analysisPoints": [
            "Understanding the primary benefit of lexical `this`.",
            "Differentiating correct `this` binding from misconceptions."
          ],
          "keyConcepts": [
            "arrow-functions",
            "this-context",
            "lexical-scope",
            "es6",
            "callbacks"
          ],
          "evaluationCriteria": [
            "Correct identification of arrow function advantage.",
            "Rejection of incorrect statements."
          ],
          "example": "Arrow functions do not create their own `this` context. Instead, they capture the `this` value of their enclosing scope when they are defined. This is known as lexical `this` binding. This behavior makes them ideal for callbacks, as it means `this` inside the arrow function will always refer to the same `this` as the surrounding code, eliminating the need for `bind()` or `var self = this;` workarounds prevalent in ES5.",
          "tags": [
            "javascript",
            "this",
            "es6",
            "arrow-functions",
            "mcq"
          ],
          "prerequisites": [
            "theory_this_context_es6_arrow"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_es6_3",
          "topic": "ES6 Arrow Functions 'this' Context",
          "level": "hard",
          "type": "code",
          "question": "Given the following HTML and JavaScript, modify the `clickHandler` in the `App` class using an ES6 arrow function to correctly log the `message` property when the button is clicked. Explain why your solution works.\n\n```html\n<button id=\"myButton\">Click Me</button>\n```\n```javascript\nclass App {\n  constructor(message) {\n    this.message = message;\n    this.button = document.getElementById('myButton');\n    // Problematic line: this.button.addEventListener('click', this.clickHandler);\n    // How would you fix this line or the clickHandler?\n  }\n\n  clickHandler() {\n    console.log(this.message);\n  }\n}\n\n// const app = new App('Hello from App!');\n```",
          "answer": "```javascript\nclass App {\n  constructor(message) {\n    this.message = message;\n    this.button = document.getElementById('myButton');\n    \n    // Fix 1: Bind in constructor (ES5 way, still valid for non-arrow methods)\n    // this.button.addEventListener('click', this.clickHandler.bind(this));\n\n    // Fix 2: Define clickHandler as an arrow function property (preferred ES6 way)\n    this.button.addEventListener('click', this.clickHandler); // This now works because clickHandler is bound\n  }\n\n  // Using arrow function as a class property\n  clickHandler = () => {\n    console.log(this.message);\n  };\n}\n\n// const app = new App('Hello from App!');\n// app.button.click(); // Simulate click\n```\n\n**Explanation:**\n\nThe original `clickHandler` is a regular method. When `addEventListener` calls `this.clickHandler`, it invokes it as a standalone function, not as a method of the `App` instance. In such a scenario, `this` inside `clickHandler` would be the HTML button element itself (or `undefined` in strict mode if it were a direct function call), not the `App` instance.\n\nBy defining `clickHandler` as a **class property arrow function** (`clickHandler = () => { ... };`), we leverage the lexical `this` binding of arrow functions. This means `this` inside `clickHandler` is bound to the `this` of the `App` instance *at the time the `App` instance is created*. Consequently, when the event listener later invokes `clickHandler`, `this.message` correctly refers to the `message` property of the `App` instance, because the arrow function's `this` context was permanently captured from its enclosing `App` instance scope.",
          "options": [],
          "analysisPoints": [
            "Understanding of `this` context in event handlers.",
            "Correct application of arrow functions as class properties for binding.",
            "Ability to explain the 'why' behind the solution (lexical `this`)."
          ],
          "keyConcepts": [
            "this-context",
            "arrow-functions",
            "es6-classes",
            "event-listeners",
            "lexical-scope",
            "frontend-development"
          ],
          "evaluationCriteria": [
            "Correct refactoring of the class method.",
            "Clear and accurate explanation of the underlying `this` mechanism.",
            "Demonstrates knowledge of common frontend `this` pitfalls."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es6",
            "code-challenge",
            "frontend",
            "event-handling"
          ],
          "prerequisites": [
            "theory_this_context_es6_arrow"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_chaining_1",
          "topic": "Function Chaining",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary mechanism that allows methods to be chained together on an object?",
          "answer": "Each method in the chain must return the object itself (`this`) after performing its operation.",
          "options": [],
          "analysisPoints": [
            "Understanding the fundamental requirement for method chaining.",
            "Key role of `this` in chaining."
          ],
          "keyConcepts": [
            "method-chaining",
            "this",
            "fluent-api"
          ],
          "evaluationCriteria": [
            "Accuracy and conciseness."
          ],
          "example": null,
          "tags": [
            "javascript",
            "function-chaining",
            "design-patterns"
          ],
          "prerequisites": [
            "theory_function_chaining"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_chaining_2",
          "topic": "Function Chaining",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `StringBuilder` class from the theory. If `append` did not return `this`, what would be the result of the following?\n\n```javascript\nclass StringBuilder {\n  constructor(str = \"\") {\n    this.str = str;\n  }\n  append(s) {\n    this.str += s;\n    // return this; <-- REMOVED\n  }\n  toString() {\n    return this.str;\n  }\n}\nconst builder = new StringBuilder();\nconst result = builder.append(\"Hello\").append(\" \").append(\"World!\").toString();\n```",
          "answer": "An error, because `builder.append(\"Hello\")` would return `undefined`, and `undefined` does not have an `append` method.",
          "options": [
            "\"Hello World!\"",
            "\"Hello\"",
            "An error, because `builder.append(\"Hello\")` would return `undefined`, and `undefined` does not have an `append` method.",
            "An empty string \"\"."
          ],
          "analysisPoints": [
            "Understanding the consequences of breaking the chaining contract.",
            "Knowledge of what `undefined` is and its properties.",
            "Ability to trace execution flow."
          ],
          "keyConcepts": [
            "method-chaining",
            "this",
            "fluent-api",
            "return-value"
          ],
          "evaluationCriteria": [
            "Correctly identifying the runtime error.",
            "Accurate explanation of why the error occurs."
          ],
          "example": "If `append` does not explicitly return `this`, it will implicitly return `undefined` (the default return value for functions that don't specify one). When `builder.append(\"Hello\")` is called, it correctly updates `builder.str` to \"Hello\", but then it returns `undefined`. The next call in the chain, `.append(\" \")`, would then try to call `append` on `undefined`, leading to a `TypeError: Cannot read properties of undefined (reading 'append')`.",
          "tags": [
            "javascript",
            "function-chaining",
            "mcq",
            "error-handling"
          ],
          "prerequisites": [
            "theory_function_chaining"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_chaining_3",
          "topic": "Function Chaining",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple `Calculator` class that supports method chaining for arithmetic operations (add, subtract, multiply, divide). The `Calculator` should maintain a running total and include a `getResult()` method that breaks the chain.\n\nRequirements:\n1.  Initialize with a `value` of 0 (or a provided initial value).\n2.  `add(num)`: adds `num` to the current `value`.\n3.  `subtract(num)`: subtracts `num` from the current `value`.\n4.  `multiply(num)`: multiplies the current `value` by `num`.\n5.  `divide(num)`: divides the current `value` by `num`. Handle division by zero by throwing an error.\n6.  `getResult()`: returns the current `value`.",
          "answer": "```javascript\nclass Calculator {\n  constructor(initialValue = 0) {\n    this.value = initialValue;\n  }\n\n  add(num) {\n    this.value += num;\n    return this; // Enable chaining\n  }\n\n  subtract(num) {\n    this.value -= num;\n    return this; // Enable chaining\n  }\n\n  multiply(num) {\n    this.value *= num;\n    return this; // Enable chaining\n  }\n\n  divide(num) {\n    if (num === 0) {\n      throw new Error(\"Cannot divide by zero.\");\n    }\n    this.value /= num;\n    return this; // Enable chaining\n  }\n\n  getResult() {\n    return this.value; // Breaks the chain, returns the final result\n  }\n}\n\n// Example Usage:\nconst calc = new Calculator(10);\nconst result = calc.add(5).multiply(2).subtract(3).getResult(); // (10 + 5) * 2 - 3 = 15 * 2 - 3 = 30 - 3 = 27\nconsole.log(result); // 27\n\nconst anotherCalc = new Calculator();\ntry {\n  anotherCalc.add(10).divide(0);\n} catch (error) {\n  console.error(error.message); // Cannot divide by zero.\n}\n\nconst chainedResult = new Calculator(5).add(5).multiply(10).getResult(); // (5+5)*10 = 100\nconsole.log(chainedResult);\n```",
          "options": [],
          "analysisPoints": [
            "Correct implementation of method chaining by returning `this`.",
            "Appropriate handling of edge cases (division by zero).",
            "Demonstration of basic arithmetic operations within an OOP context."
          ],
          "keyConcepts": [
            "method-chaining",
            "classes",
            "oop",
            "error-handling",
            "fluent-api"
          ],
          "evaluationCriteria": [
            "Functional correctness of all methods.",
            "Proper chaining implementation.",
            "Robust error handling for division by zero.",
            "Clarity and readability of the code."
          ],
          "example": null,
          "tags": [
            "javascript",
            "function-chaining",
            "code-challenge",
            "oop"
          ],
          "prerequisites": [
            "theory_function_chaining"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hof_1",
          "topic": "Higher-Order Functions",
          "level": "easy",
          "type": "flashcard",
          "question": "What defines a function as a Higher-Order Function (HOF)?",
          "answer": "A function is a HOF if it either takes one or more functions as arguments, or returns a function as its result.",
          "options": [],
          "analysisPoints": [
            "Accurate definition of a HOF.",
            "Understanding functions as first-class citizens."
          ],
          "keyConcepts": [
            "hof",
            "functional-programming",
            "first-class-functions"
          ],
          "evaluationCriteria": [
            "Correctness and conciseness."
          ],
          "example": null,
          "tags": [
            "javascript",
            "hof",
            "functional-programming"
          ],
          "prerequisites": [
            "theory_higher_order_functions"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_hof_2",
          "topic": "Higher-Order Functions",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following built-in JavaScript array methods is an example of a Higher-Order Function?\n\n```javascript\nconst numbers = [1, 2, 3];\n// Which method below is a HOF?\nconst mapped = numbers.map(num => num * 2);\nconst filtered = numbers.filter(num => num % 2 === 0);\nconst reduced = numbers.reduce((acc, num) => acc + num, 0);\n```",
          "answer": "All of the above",
          "options": [
            "`map()`",
            "`filter()`",
            "`reduce()`",
            "All of the above"
          ],
          "analysisPoints": [
            "Identifying common HOFs in JavaScript's standard library.",
            "Understanding that array iteration methods accept functions as arguments."
          ],
          "keyConcepts": [
            "hof",
            "array-methods",
            "map",
            "filter",
            "reduce",
            "functional-programming"
          ],
          "evaluationCriteria": [
            "Correct identification.",
            "Demonstrates practical knowledge of HOFs."
          ],
          "example": "All three methods (`map`, `filter`, `reduce`) are Higher-Order Functions because they take a callback function as an argument. This callback function determines the transformation (`map`), the filtering logic (`filter`), or the aggregation logic (`reduce`).",
          "tags": [
            "javascript",
            "hof",
            "functional-programming",
            "mcq",
            "array-methods"
          ],
          "prerequisites": [
            "theory_higher_order_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hof_3",
          "topic": "Higher-Order Functions",
          "level": "hard",
          "type": "code",
          "question": "Implement a `debounce` higher-order function. This function should take another function (`func`) and a `delay` (in milliseconds) as arguments. It should return a new function that, when invoked, will execute `func` only after `delay` milliseconds have passed since the last invocation. If the debounced function is called again within the `delay` period, the timer should be reset.\n\n```javascript\nfunction debounce(func, delay) {\n  // Your implementation here\n}\n\n// Example Usage:\n// const debouncedLog = debounce((message) => console.log('Logging:', message), 500);\n// debouncedLog('First call'); // Timer starts\n// setTimeout(() => debouncedLog('Second call'), 200); // Timer reset, 'First call' is cancelled\n// setTimeout(() => debouncedLog('Third call'), 700); // Timer reset, 'Second call' is cancelled\n// // 'Logging: Third call' should appear ~1200ms after initial call (700 + 500)\n```",
          "answer": "```javascript\nfunction debounce(func, delay) {\n  let timeoutId; // This variable will persist across calls due to closure\n\n  return function(...args) {\n    const context = this; // Capture the 'this' context of the invocation\n\n    clearTimeout(timeoutId); // Clear any existing timer\n\n    timeoutId = setTimeout(() => {\n      func.apply(context, args); // Execute the original function with correct 'this' and arguments\n    }, delay);\n  };\n}\n\n// Example Usage:\nconst debouncedLog = debounce((message) => console.log('Logging:', message), 500);\n\nconsole.log('--- Debounce Test ---');\ndebouncedLog('First call'); \nsetTimeout(() => debouncedLog('Second call'), 200); \nsetTimeout(() => debouncedLog('Third call'), 700); \n// Expected output after ~1200ms (700 + 500): 'Logging: Third call'\n\n// Another example with 'this' context\nconst myObject = {\n  value: 0,\n  increment: function() {\n    this.value++;\n    console.log('Incremented value:', this.value);\n  }\n};\n\nconst debouncedIncrement = debounce(myObject.increment, 300);\n\ndebouncedIncrement.call(myObject); // Call with 'myObject' as 'this'\nsetTimeout(() => debouncedIncrement.call(myObject), 100); // Reset\nsetTimeout(() => debouncedIncrement.call(myObject), 200); // Reset\n// Expected output after ~500ms (200 + 300): 'Incremented value: 1'\n```",
          "options": [],
          "analysisPoints": [
            "Correct implementation of a `debounce` function using closures and `setTimeout`/`clearTimeout`.",
            "Proper handling of `this` context within the debounced function using `apply`.",
            "Understanding of timer management in JavaScript."
          ],
          "keyConcepts": [
            "hof",
            "closures",
            "debounce",
            "timers",
            "functional-programming",
            "this-context"
          ],
          "evaluationCriteria": [
            "Functional correctness of `debounce`.",
            "Ability to manage `setTimeout` and `clearTimeout` effectively.",
            "Correct preservation of `this` and arguments.",
            "Clarity and robustness of the solution."
          ],
          "example": null,
          "tags": [
            "javascript",
            "hof",
            "code-challenge",
            "functional-programming",
            "timers"
          ],
          "prerequisites": [
            "theory_higher_order_functions",
            "closures"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_hof_4",
          "topic": "Higher-Order Functions",
          "level": "hard",
          "type": "open",
          "question": "Explain the concept of 'Function Composition' and how it relates to Higher-Order Functions. Provide a scenario where `compose` (or a similar composition HOF) would be beneficial, contrasting it with a non-compositional approach.",
          "answer": "### Function Composition\nFunction composition is a mathematical and functional programming concept where you combine multiple simple functions to build a more complex function. The output of one function becomes the input of the next function in the sequence. If you have functions `f`, `g`, and `h`, composing them means creating a new function `C(x)` such that `C(x) = h(g(f(x)))`. The functions are applied from right-to-left (or left-to-right, depending on the `compose`/`pipe` implementation convention).\n\n### Relation to Higher-Order Functions\nFunction composition is inherently reliant on Higher-Order Functions. A `compose` (or `pipe`) utility itself is a HOF because:\n1.  It takes multiple functions as arguments (`f`, `g`, `h`).\n2.  It returns a single new function that encapsulates the combined logic.\n\nThis ability to treat functions as arguments and return values is precisely what defines a HOF, making `compose` a prime example of its utility.\n\n### Scenario: Data Transformation Pipeline\nImagine you have a list of user names, and you need to process them by:\n1.  Trimming whitespace from each name.\n2.  Converting each name to uppercase.\n3.  Adding a prefix \"USER-\" to each name.\n\n**Non-Compositional Approach:**\n```javascript\nconst names = ['  alice  ', 'bob ', '   charlie'];\n\nconst processedNames = names.map(name => {\n  const trimmed = name.trim();\n  const upper = trimmed.toUpperCase();\n  const prefixed = 'USER-' + upper;\n  return prefixed;\n});\nconsole.log(processedNames);\n// Output: [ 'USER-ALICE', 'USER-BOB', 'USER-CHARLIE' ]\n```\nThis approach works, but the callback function can become cluttered if more transformations are added. It mixes concerns (each step of the transformation within one function).\n\n**Compositional Approach:**\nFirst, define individual, single-purpose functions:\n```javascript\nconst trim = str => str.trim();\nconst toUpper = str => str.toUpperCase();\nconst addPrefix = str => 'USER-' + str;\n\n// A compose HOF (as provided in theory, simplified for example):\nconst compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res);\n\nconst transformName = compose(trim, toUpper, addPrefix);\n\nconst names = ['  alice  ', 'bob ', '   charlie'];\nconst processedNamesComposed = names.map(transformName);\nconsole.log(processedNamesComposed);\n// Output: [ 'USER-ALICE', 'USER-BOB', 'USER-CHARLIE' ]\n```\n\n**Benefits of Composition in this scenario:**\n*   **Readability & Maintainability**: Each small function (e.g., `trim`, `toUpper`) is focused on a single responsibility, making them easy to understand, test, and reuse. The `transformName` function clearly states the *sequence* of operations without revealing the internal step-by-step logic.\n*   **Reusability**: `trim`, `toUpper`, `addPrefix` can be reused independently or combined in different ways for other data processing tasks.\n*   **Declarative**: The code describes *what* is being done (compose these transformations) rather than *how* it's done (sequential assignments inside a single function).\n*   **Flexibility**: Easily add, remove, or reorder transformations by simply modifying the `compose` arguments, without changing the core mapping logic.",
          "options": [],
          "analysisPoints": [
            "Clear definition of function composition.",
            "Explanation of how HOFs facilitate composition.",
            "Detailed comparison of compositional vs. non-compositional approach for a practical scenario.",
            "Articulation of benefits (readability, reusability, maintainability)."
          ],
          "keyConcepts": [
            "function-composition",
            "hof",
            "functional-programming",
            "pipe",
            "declarative-programming",
            "code-reusability"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of composition.",
            "Ability to provide a compelling, practical example.",
            "Strong comparative analysis.",
            "Clarity and depth of explanation."
          ],
          "example": null,
          "tags": [
            "javascript",
            "hof",
            "open-ended",
            "functional-programming",
            "design-patterns"
          ],
          "prerequisites": [
            "theory_higher_order_functions"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_oop_intro_1",
          "topic": "Introduction to OOP",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary concept around which Object-Oriented Programming (OOP) is centered?",
          "answer": "OOP is centered around 'objects' that can contain both data (properties) and code (methods) that operate on that data.",
          "options": [],
          "analysisPoints": [
            "Fundamental definition of OOP.",
            "Understanding of an 'object' in OOP."
          ],
          "keyConcepts": [
            "oop",
            "objects",
            "paradigm"
          ],
          "evaluationCriteria": [
            "Accuracy and conciseness."
          ],
          "example": null,
          "tags": [
            "oop",
            "javascript"
          ],
          "prerequisites": [
            "theory_oop_intro"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_oop_intro_2",
          "topic": "Introduction to OOP",
          "level": "medium",
          "type": "mcq",
          "question": "How does JavaScript primarily support Object-Oriented Programming?",
          "answer": "Through prototypal inheritance and ES6 class syntax (which is syntactic sugar over prototypes).",
          "options": [
            "Solely through classical inheritance with strong type checking.",
            "By enforcing strict interfaces and abstract classes.",
            "Through prototypal inheritance and ES6 class syntax (which is syntactic sugar over prototypes).",
            "It is a purely functional programming language and does not support OOP."
          ],
          "analysisPoints": [
            "Correctly identifying JavaScript's OOP mechanisms.",
            "Dispelling misconceptions about JS as a purely functional language.",
            "Understanding the relationship between ES6 classes and prototypes."
          ],
          "keyConcepts": [
            "oop",
            "javascript",
            "prototypes",
            "classes",
            "inheritance"
          ],
          "evaluationCriteria": [
            "Accuracy of JS OOP support.",
            "Distinguishing correct from incorrect paradigms."
          ],
          "example": "JavaScript is a multi-paradigm language, supporting both functional and object-oriented styles. Its unique take on OOP is centered around prototypes, where objects directly inherit from other objects. ES6 introduced the `class` keyword, which provides a more familiar syntax for developers from class-based languages, but fundamentally, it still operates on the prototypal inheritance model under the hood.",
          "tags": [
            "oop",
            "javascript",
            "mcq",
            "prototypes",
            "classes"
          ],
          "prerequisites": [
            "theory_oop_intro"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_oop_principles_1",
          "topic": "Core OOP Principles",
          "level": "easy",
          "type": "flashcard",
          "question": "What OOP principle is defined as 'bundling data and methods that operate on that data within one unit'?",
          "answer": "Encapsulation.",
          "options": [],
          "analysisPoints": [
            "Recall core OOP definitions."
          ],
          "keyConcepts": [
            "oop",
            "encapsulation",
            "principles"
          ],
          "evaluationCriteria": [
            "Direct recall of definition."
          ],
          "example": null,
          "tags": [
            "oop",
            "principles"
          ],
          "prerequisites": [
            "theory_oop_principles"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_oop_principles_2",
          "topic": "Core OOP Principles",
          "level": "medium",
          "type": "mcq",
          "question": "Which OOP principle focuses on simplifying complex reality by modeling classes appropriate to the problem, hiding internal complexity?",
          "answer": "Abstraction",
          "options": [
            "Encapsulation",
            "Inheritance",
            "Polymorphism",
            "Abstraction"
          ],
          "analysisPoints": [
            "Distinguishing between the four OOP principles.",
            "Understanding the focus of Abstraction."
          ],
          "keyConcepts": [
            "oop",
            "abstraction",
            "principles"
          ],
          "evaluationCriteria": [
            "Correct identification of the principle.",
            "Understanding the nuance between principles."
          ],
          "example": "Abstraction focuses on showing only the necessary aspects of an object and hiding the complex implementation details. For example, when you use a `console.log()` function, you don't need to know how the browser's console actually renders the text; you just use the abstracted interface `console.log()` to achieve your goal.",
          "tags": [
            "oop",
            "principles",
            "mcq"
          ],
          "prerequisites": [
            "theory_oop_principles"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_oop_principles_3",
          "topic": "Core OOP Principles",
          "level": "medium",
          "type": "open",
          "question": "Explain how JavaScript, particularly with ES6 features, supports the principle of Encapsulation. Provide a brief code example.",
          "answer": "Encapsulation, in OOP, is the bundling of data with the methods that operate on that data, and restricting direct access to some of an object's components. In JavaScript, perfect encapsulation (true private members) has historically been challenging, but modern ES6+ features offer better support.\n\n### How JavaScript Supports Encapsulation:\n1.  **Closures (ES5/ES6)**:\n    This is the traditional way to achieve private variables in JavaScript. Variables declared inside a function are not accessible from outside that function, but they remain accessible to inner functions (closures) defined within it. This allows public methods to access and modify 'private' data.\n    ```javascript\n    function Counter() {\n      let count = 0; // 'count' is private via closure\n      \n      this.increment = function() {\n        count++;\n      };\n      \n      this.getCount = function() {\n        return count;\n      };\n    }\n    const counter = new Counter();\n    // console.log(counter.count); // undefined - direct access is prevented\n    counter.increment();\n    console.log(counter.getCount()); // 1\n    ```\n\n2.  **`class` syntax with conventions (ES6)**:\n    While `class` methods and properties are public by default, developers often use conventions like prefixing properties with an underscore (`_`) to indicate that they are intended for internal use only, signaling to other developers not to access them directly. This is a form of 'soft' encapsulation.\n    ```javascript\n    class BankAccount {\n      constructor(initialBalance) {\n        this._balance = initialBalance; // Convention for 'private' or protected\n      }\n      \n      deposit(amount) {\n        if (amount > 0) {\n          this._balance += amount;\n        }\n      }\n      \n      getBalance() {\n        return this._balance;\n      }\n    }\n    const account = new BankAccount(100);\n    // console.log(account._balance); // Accessible, but convention indicates private\n    ```\n\n3.  **Private Class Fields (ES2019+)**: \n    The `#` prefix for class fields provides true private encapsulation at the language level. Private fields are only accessible from within the class body itself, making them inaccessible from outside the class instance.\n    ```javascript\n    class SecureCounter {\n      #count = 0; // Truly private field\n      \n      increment() {\n        this.#count++;\n      }\n      \n      getCount() {\n        return this.#count;\n      }\n    }\n    const secureCounter = new SecureCounter();\n    secureCounter.increment();\n    // console.log(secureCounter.#count); // SyntaxError: Private field '#count' must be declared in an enclosing class\n    console.log(secureCounter.getCount()); // 1\n    ```\n\nThese mechanisms allow JavaScript developers to control visibility and access to an object's internal state, promoting better data integrity and easier maintenance, aligning with the principle of encapsulation.",
          "options": [],
          "analysisPoints": [
            "Comprehensive explanation of encapsulation in JS.",
            "Demonstration of different mechanisms (closures, conventions, private fields).",
            "Clear and concise code examples for each method.",
            "Understanding of the progression of encapsulation support in JS."
          ],
          "keyConcepts": [
            "oop",
            "encapsulation",
            "javascript",
            "closures",
            "private-fields",
            "es6-classes"
          ],
          "evaluationCriteria": [
            "Accuracy and depth of encapsulation explanation.",
            "Correctness and relevance of code examples.",
            "Understanding of JavaScript's evolving support for the principle."
          ],
          "example": null,
          "tags": [
            "oop",
            "principles",
            "open-ended",
            "javascript",
            "es6",
            "closures"
          ],
          "prerequisites": [
            "theory_oop_principles"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_oop_principles_4",
          "topic": "Core OOP Principles",
          "level": "medium",
          "type": "flashcard",
          "question": "What is Polymorphism in the context of OOP, and how is it typically achieved in JavaScript?",
          "answer": "Polymorphism means 'many forms'. It allows objects of different types to be treated as objects of a common type, often by implementing the same method signature in their own specific ways. In JavaScript, it's typically achieved through method overriding in prototypal inheritance or classes, where different objects can respond to the same method call (e.g., a `speak()` method) with their unique implementations.",
          "options": [],
          "analysisPoints": [
            "Definition of polymorphism.",
            "How polymorphism is manifested in JavaScript."
          ],
          "keyConcepts": [
            "oop",
            "polymorphism",
            "method-overriding",
            "prototypal-inheritance"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of explanation."
          ],
          "example": null,
          "tags": [
            "oop",
            "principles",
            "javascript"
          ],
          "prerequisites": [
            "theory_oop_principles"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prototypal_1",
          "topic": "Prototypal Inheritance",
          "level": "easy",
          "type": "flashcard",
          "question": "In JavaScript, from what do objects directly inherit properties and methods?",
          "answer": "Objects directly inherit from other objects, specifically their prototypes, forming a prototype chain.",
          "options": [],
          "analysisPoints": [
            "Understanding the fundamental concept of prototypal inheritance.",
            "Distinguishing it from classical inheritance."
          ],
          "keyConcepts": [
            "prototypal-inheritance",
            "prototype-chain",
            "objects"
          ],
          "evaluationCriteria": [
            "Accuracy and conciseness."
          ],
          "example": null,
          "tags": [
            "javascript",
            "oop",
            "prototypes"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_prototypal_2",
          "topic": "Prototypal Inheritance",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following code, what will be the output of `student1.constructor === Person`?\n\n```javascript\nvar Person = function(firstName) {\n  this.firstName = firstName;\n};\nPerson.prototype.sayHello = function() {};\n\nfunction Student(firstName, subject) {\n  Person.call(this, firstName);\n  this.subject = subject;\n}\nStudent.prototype = Object.create(Person.prototype);\n// Student.prototype.constructor = Student; <-- THIS LINE IS MISSING\n\nvar student1 = new Student(\"Alice\", \"Math\");\n\nconsole.log(student1.constructor === Person); // ?\nconsole.log(student1.constructor === Student); // ?\n```",
          "answer": "true",
          "options": [
            "true",
            "false",
            "undefined",
            "TypeError"
          ],
          "analysisPoints": [
            "Understanding the effect of `Object.create()` on the `constructor` property.",
            "Knowledge of how `constructor` property is inherited and its typical behavior.",
            "Ability to trace the prototype chain for property lookup."
          ],
          "keyConcepts": [
            "prototypal-inheritance",
            "prototype-chain",
            "constructor-property",
            "object-create"
          ],
          "evaluationCriteria": [
            "Correctly predicting the output.",
            "Understanding why the output is true (due to missing `constructor` reset).",
            "Knowledge of `constructor` property behavior."
          ],
          "example": "When `Student.prototype = Object.create(Person.prototype);` is executed, the newly created object (which becomes `Student.prototype`) inherits its properties from `Person.prototype`. One of the properties it inherits is `constructor`, which points to `Person`. Since the line `Student.prototype.constructor = Student;` is *missing*, the `constructor` property lookup on `student1` will traverse the prototype chain: `student1` -> `Student.prototype` -> `Person.prototype`, where it finds `constructor` pointing to `Person`. Thus, `student1.constructor` will evaluate to `Person`, making `student1.constructor === Person` true.",
          "tags": [
            "javascript",
            "oop",
            "prototypes",
            "mcq",
            "inheritance",
            "edge-case"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_prototypal_3",
          "topic": "Prototypal Inheritance",
          "level": "hard",
          "type": "code",
          "question": "Implement a `Vehicle` and `Car` hierarchy using ES5 constructor functions and prototypal inheritance. The `Vehicle` constructor should take `make` and `model`. It should have a `getInfo()` method on its prototype. The `Car` constructor should take `make`, `model`, and `numDoors`. It should inherit from `Vehicle` and have its own `getDoors()` method. Ensure `instanceof` and `constructor` checks work correctly for `Car` instances.\n\n```javascript\n// Implement Vehicle and Car here\n\n// Expected Usage:\n// var myCar = new Car('Toyota', 'Camry', 4);\n// console.log(myCar.getInfo());    // Expected: 'Make: Toyota, Model: Camry'\n// console.log(myCar.getDoors());   // Expected: 'Number of doors: 4'\n// console.log(myCar instanceof Car);     // Expected: true\n// console.log(myCar instanceof Vehicle); // Expected: true\n// console.log(myCar.constructor === Car); // Expected: true\n```",
          "answer": "```javascript\n// Vehicle Constructor\nvar Vehicle = function(make, model) {\n  this.make = make;\n  this.model = model;\n};\n\n// Vehicle Prototype Methods\nVehicle.prototype.getInfo = function() {\n  return 'Make: ' + this.make + ', Model: ' + this.model;\n};\n\n// Car Constructor\nfunction Car(make, model, numDoors) {\n  // 1. Constructor borrowing: Call the parent constructor to inherit properties\n  Vehicle.call(this, make, model);\n  this.numDoors = numDoors;\n}\n\n// 2. Set up the prototype chain: Car.prototype inherits from Vehicle.prototype\n// This allows Car instances to access methods defined on Vehicle.prototype\nCar.prototype = Object.create(Vehicle.prototype);\n\n// 3. Correct the constructor property for Car.prototype\n// Without this, Car.prototype.constructor would point to Vehicle\nCar.prototype.constructor = Car;\n\n// 4. Add methods specific to Car on its prototype\nCar.prototype.getDoors = function() {\n  return 'Number of doors: ' + this.numDoors;\n};\n\n// Expected Usage:\nvar myCar = new Car('Toyota', 'Camry', 4);\nconsole.log(myCar.getInfo());    // Expected: 'Make: Toyota, Model: Camry'\nconsole.log(myCar.getDoors());   // Expected: 'Number of doors: 4'\nconsole.log(myCar instanceof Car);     // Expected: true\nconsole.log(myCar instanceof Vehicle); // Expected: true\nconsole.log(myCar.constructor === Car); // Expected: true\nconsole.log(myCar.constructor === Vehicle); // Expected: false\n```",
          "options": [],
          "analysisPoints": [
            "Correct application of `Vehicle.call(this, ...)` for property inheritance.",
            "Proper use of `Object.create(Vehicle.prototype)` to establish the prototype chain.",
            "Crucial resetting of `Child.prototype.constructor`.",
            "Verification through `instanceof` and `constructor` checks."
          ],
          "keyConcepts": [
            "prototypal-inheritance",
            "constructor-functions",
            "prototype-chain",
            "object-create",
            "call",
            "instanceof"
          ],
          "evaluationCriteria": [
            "Complete and correct implementation of the hierarchy.",
            "Adherence to ES5 prototypal inheritance patterns.",
            "All expected test cases pass.",
            "Clear and readable code structure."
          ],
          "example": null,
          "tags": [
            "javascript",
            "oop",
            "prototypes",
            "code-challenge",
            "inheritance",
            "es5"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_prototypal_4",
          "topic": "Prototypal Inheritance",
          "level": "hard",
          "type": "open",
          "question": "Discuss the difference between `Object.getPrototypeOf()` and the `__proto__` property in JavaScript. When would you use one over the other, and what are the implications of directly manipulating `__proto__`?",
          "answer": "Both `Object.getPrototypeOf()` and the `__proto__` property are used to access an object's prototype. However, they differ significantly in their standardization, usage, and implications.\n\n### `Object.getPrototypeOf()`\n*   **Definition**: `Object.getPrototypeOf()` is a standard, built-in method in JavaScript, introduced in ES5. It returns the prototype (i.e., the internal `[[Prototype]]` slot) of the specified object.\n*   **Usage**: It is the **recommended and standard way** to get the prototype of an object.\n*   **Implications**: It's a read-only operation. It does not allow modification of an object's prototype directly. It's safe and predictable.\n\n### `__proto__` Property\n*   **Definition**: `__proto__` is a non-standard, legacy accessor property that was historically implemented by many JavaScript engines to expose the internal `[[Prototype]]` of an object. While it's widely supported in modern browsers and Node.js for historical reasons, it was never part of the ECMAScript standard until ES6 (as an optional feature, mainly for legacy code).\n*   **Usage**: Can be used to both get and *set* an object's prototype. \n    *   Getting: `myObject.__proto__`\n    *   Setting: `myObject.__proto__ = anotherObject` (This modifies the object's prototype chain *after* creation).\n*   **Implications**: \n    *   **Performance**: Directly manipulating `__proto__` to set an object's prototype can have significant negative performance implications, especially in older engines, as it can de-optimize the object and the code that interacts with it. Modern engines have improved, but it's still generally less efficient than setting the prototype at object creation.\n    *   **Standardization**: Although brought into ES6 for web compatibility, its use is generally discouraged for new code in favor of `Object.create()` for setting prototypes at creation and `Object.setPrototypeOf()` for changing them post-creation.\n    *   **Security/Integrity**: Modifying `__proto__` can lead to unexpected behavior and security vulnerabilities if not carefully managed, especially when dealing with untrusted input or objects.\n\n### When to use which:\n*   **`Object.getPrototypeOf()`**: **Always prefer this** when you need to simply *read* an object's prototype. It's clean, standard, and has no side effects or performance drawbacks related to prototype modification.\n*   **`__proto__`**: \n    *   **Avoid for setting prototypes in new code.** For setting prototypes at object creation, use `Object.create()`. For changing prototypes post-creation (which is rare), use `Object.setPrototypeOf()`, as it's the standard equivalent.\n    *   It might occasionally be seen in older codebases or specific niche scenarios where its direct mutability is exploited, but it's generally a red flag for modern JavaScript development.",
          "options": [],
          "analysisPoints": [
            "Clear definition and distinction between `Object.getPrototypeOf()` and `__proto__`.",
            "Discussion of standardization and historical context.",
            "Implications of direct `__proto__` manipulation (performance, security).",
            "Best practices for when to use each (or avoid `__proto__`)."
          ],
          "keyConcepts": [
            "prototypal-inheritance",
            "prototype",
            "object-getprototypeof",
            "__proto__",
            "object-setprototypeof",
            "performance",
            "standards"
          ],
          "evaluationCriteria": [
            "Comprehensive and accurate comparison.",
            "Demonstrates awareness of best practices and potential pitfalls.",
            "Depth of technical explanation.",
            "Clarity of recommendations."
          ],
          "example": null,
          "tags": [
            "javascript",
            "oop",
            "prototypes",
            "open-ended",
            "advanced"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_this_context_timer",
          "title": "Implement a Self-Updating Timer with Dynamic 'this' Context",
          "description": "\nCreate a `Timer` class (using ES6 `class` syntax) that displays a countdown or count-up. The timer should update its display element every second.\n\n**Requirements:**\n1.  **`Timer` Class**: It should have a `constructor` that takes an initial `count` and a DOM element `displayElement` (e.g., a `div` or `span`) where the count will be displayed.\n2.  **`start()` Method**: This method should initiate a `setInterval` that increments/decrements the internal `count` and updates the `textContent` of `displayElement` every second.\n3.  **Correct `this` Context**: Ensure that `this.count` and `this.displayElement` are correctly accessed within the `setInterval` callback.\n4.  **`stop()` Method**: This method should clear the `setInterval` to stop the timer.\n5.  **Bonus**: Make it configurable for countdown or count-up.",
          "difficulty": "medium",
          "startingCode": "<html>\n<body>\n  <div id=\"timer-display\"></div>\n  <button id=\"start-button\">Start Timer</button>\n  <button id=\"stop-button\">Stop Timer</button>\n  <script>\n    // Your Timer class implementation here\n    class Timer {\n      constructor(initialCount, displayElementId, isCountdown = false) {\n        this.count = initialCount;\n        this.displayElement = document.getElementById(displayElementId);\n        this.isCountdown = isCountdown;\n        this.intervalId = null;\n\n        // Bind event listeners (consider where 'this' refers to the Timer instance)\n        document.getElementById('start-button').addEventListener('click', () => this.start());\n        document.getElementById('stop-button').addEventListener('click', () => this.stop());\n\n        this.updateDisplay(); // Initial display\n      }\n\n      updateDisplay() {\n        this.displayElement.textContent = `Count: ${this.count}`;\n      }\n\n      start() {\n        if (this.intervalId) return; // Prevent multiple intervals\n\n        // TODO: Implement setInterval to update count and display\n        // Pay attention to 'this' context inside the callback!\n        this.intervalId = setInterval(() => {\n          // Your code here\n          // this.count = ...\n          // this.updateDisplay();\n        }, 1000);\n        console.log('Timer started.');\n      }\n\n      stop() {\n        if (this.intervalId) {\n          clearInterval(this.intervalId);\n          this.intervalId = null;\n          console.log('Timer stopped.');\n        }\n      }\n    }\n\n    // const myTimer = new Timer(0, 'timer-display');\n    // const countdownTimer = new Timer(10, 'timer-display', true); // For bonus\n  </script>\n</body>\n</html>\n",
          "solutionCode": "<html>\n<body>\n  <div id=\"timer-display\"></div>\n  <button id=\"start-button\">Start Timer</button>\n  <button id=\"stop-button\">Stop Timer</button>\n  <script>\n    class Timer {\n      constructor(initialCount, displayElementId, isCountdown = false) {\n        this.count = initialCount;\n        this.displayElement = document.getElementById(displayElementId);\n        this.isCountdown = isCountdown;\n        this.intervalId = null;\n\n        document.getElementById('start-button').addEventListener('click', () => this.start());\n        document.getElementById('stop-button').addEventListener('click', () => this.stop());\n\n        this.updateDisplay(); // Initial display\n      }\n\n      updateDisplay() {\n        this.displayElement.textContent = `Count: ${this.count}`;\n      }\n\n      start() {\n        if (this.intervalId) return; \n\n        this.intervalId = setInterval(() => {\n          if (this.isCountdown) {\n            this.count--;\n          } else {\n            this.count++;\n          }\n          this.updateDisplay();\n        }, 1000);\n        console.log('Timer started.');\n      }\n\n      stop() {\n        if (this.intervalId) {\n          clearInterval(this.intervalId);\n          this.intervalId = null;\n          console.log('Timer stopped.');\n        }\n      }\n    }\n\n    const myTimer = new Timer(0, 'timer-display');\n    // To test countdown, uncomment the line below and comment out myTimer:\n    // const countdownTimer = new Timer(10, 'timer-display', true);\n  </script>\n</body>\n</html>\n",
          "testCases": [
            "Initial display shows correct count.",
            "Clicking 'Start' starts incrementing/decrementing the count in the display.",
            "Count updates every second.",
            "Clicking 'Stop' halts the counter.",
            "Clicking 'Start' multiple times does not create multiple intervals.",
            "Verify `this` context within `setInterval` callback correctly refers to the `Timer` instance.",
            "Bonus: Verify countdown functionality if `isCountdown` is true."
          ],
          "hints": [
            "Recall how ES6 arrow functions handle `this` context. They are ideal for `setInterval` callbacks within classes.",
            "Remember to store the `setInterval` ID so you can `clearInterval` later.",
            "The `updateDisplay` helper method can simplify the logic inside `setInterval`.",
            "Make sure your event listeners for buttons also correctly bind `this` or use arrow functions."
          ],
          "tags": [
            "javascript",
            "this",
            "es6-classes",
            "setinterval",
            "frontend",
            "timers"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_this_context_es5",
            "theory_this_context_es6_arrow"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "lexical-this",
            "closures",
            "event-handling"
          ]
        },
        {
          "id": "task_chainable_calculator",
          "title": "Build a Chainable Mathematical Utility Object",
          "description": "\nCreate a JavaScript object or class, `MathUtil`, that provides several common mathematical operations. The methods should be chainable, allowing for fluent expression of calculations.\n\n**Requirements:**\n1.  **`MathUtil` Class/Object**: It should encapsulate a `currentValue` property, initialized to 0 or a given starting number.\n2.  **Chainable Methods**: Implement `add(num)`, `subtract(num)`, `multiply(num)`, `divide(num)`. Each of these methods should modify `currentValue` and return the `MathUtil` instance itself (`this`) to enable chaining.\n3.  **`equals()` Method**: This method should return the final `currentValue`, breaking the chain.\n4.  **`reset()` Method**: Resets `currentValue` to 0 and is also chainable.\n5.  **Error Handling**: For `divide(num)`, throw an error if `num` is 0.\n\n**Example Usage:**\n```javascript\nconst result = new MathUtil(10).add(5).multiply(2).subtract(3).equals(); // Should be 27\nconst anotherResult = new MathUtil().add(10).reset().add(20).equals(); // Should be 20\n```\n",
          "difficulty": "medium",
          "startingCode": "class MathUtil {\n  constructor(initialValue = 0) {\n    this.currentValue = initialValue;\n  }\n\n  add(num) {\n    // TODO: Implement addition and return 'this'\n  }\n\n  subtract(num) {\n    // TODO: Implement subtraction and return 'this'\n  }\n\n  multiply(num) {\n    // TODO: Implement multiplication and return 'this'\n  }\n\n  divide(num) {\n    // TODO: Implement division with error handling and return 'this'\n  }\n\n  reset() {\n    // TODO: Implement reset and return 'this'\n  }\n\n  equals() {\n    // TODO: Return the final value, breaking the chain\n  }\n}\n\n// Example Usage (uncomment to test):\n// const calc = new MathUtil(10);\n// const result = calc.add(5).multiply(2).subtract(3).equals();\n// console.log(result); \n\n// const anotherCalc = new MathUtil();\n// const anotherResult = anotherCalc.add(10).reset().add(20).equals();\n// console.log(anotherResult);\n\n// try {\n//   new MathUtil(5).divide(0).equals();\n// } catch (e) {\n//   console.error(e.message);\n// }\n",
          "solutionCode": "class MathUtil {\n  constructor(initialValue = 0) {\n    this.currentValue = initialValue;\n  }\n\n  add(num) {\n    this.currentValue += num;\n    return this;\n  }\n\n  subtract(num) {\n    this.currentValue -= num;\n    return this;\n  }\n\n  multiply(num) {\n    this.currentValue *= num;\n    return this;\n  }\n\n  divide(num) {\n    if (num === 0) {\n      throw new Error(\"Division by zero is not allowed.\");\n    }\n    this.currentValue /= num;\n    return this;\n  }\n\n  reset() {\n    this.currentValue = 0;\n    return this;\n  }\n\n  equals() {\n    return this.currentValue;\n  }\n}\n\n// Example Usage:\nconst calc = new MathUtil(10);\nconst result = calc.add(5).multiply(2).subtract(3).equals(); // (10 + 5) * 2 - 3 = 27\nconsole.log(result); // 27\n\nconst anotherCalc = new MathUtil();\nconst anotherResult = anotherCalc.add(10).reset().add(20).equals(); // 20\nconsole.log(anotherResult); // 20\n\ntry {\n  new MathUtil(5).divide(0).equals();\n} catch (e) {\n  console.error(e.message); // Division by zero is not allowed.\n}\n\nconst chainedReset = new MathUtil(100).reset().add(50).equals();\nconsole.log(chainedReset); // 50\n",
          "testCases": [
            "`new MathUtil(0).add(5).equals()` should return 5.",
            "`new MathUtil(10).subtract(3).equals()` should return 7.",
            "`new MathUtil(2).multiply(4).equals()` should return 8.",
            "`new MathUtil(10).divide(2).equals()` should return 5.",
            "`new MathUtil(10).add(5).multiply(2).subtract(3).equals()` should return 27.",
            "`new MathUtil().add(10).reset().add(20).equals()` should return 20.",
            "`new MathUtil(5).divide(0).equals()` should throw an error.",
            "`new MathUtil(0).add(0).equals()` should return 0."
          ],
          "hints": [
            "Remember the key to chaining: what should each chainable method return?",
            "Pay close attention to error handling for division.",
            "Consider the initial value for the calculator."
          ],
          "tags": [
            "javascript",
            "method-chaining",
            "oop",
            "classes",
            "design-patterns",
            "error-handling"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_function_chaining"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "fluent-api",
            "this-context"
          ]
        },
        {
          "id": "task_hof_data_transformer",
          "title": "Create a Configurable Data Transformer using HOFs",
          "description": "\nImplement a function `createDataTransformer` that acts as a Higher-Order Function. It should take an array of transformation functions and return a single function that applies all these transformations sequentially to an input value.\n\n**Requirements:**\n1.  **`createDataTransformer(...transforms)`**: This HOF should accept an arbitrary number of functions as arguments. Each argument `transform` will be a function that takes one input and returns one output.\n2.  **Returned Function**: The `createDataTransformer` should return a new function that accepts a single `data` argument. This new function should apply each `transform` from the `transforms` array to the `data` sequentially, passing the output of one transformation as the input to the next.\n3.  **Error Handling**: If any transformation in the pipeline returns `null` or `undefined`, subsequent transformations should not be applied, and the current `null`/`undefined` should be returned.\n\n**Example Usage:**\n```javascript\nconst capitalize = str => str ? str.charAt(0).toUpperCase() + str.slice(1) : str;\nconst addExclamation = str => str ? str + '!' : str;\nconst removeSpaces = str => str ? str.replace(/\\s/g, '') : str;\n\nconst transformString = createDataTransformer(capitalize, removeSpaces, addExclamation);\n\nconsole.log(transformString('hello world')); // Expected: 'HelloWorld!'\nconsole.log(transformString('  test  '));    // Expected: 'Test!'\nconsole.log(transformString(null));          // Expected: null\nconsole.log(transformString(undefined));     // Expected: undefined\n```\n",
          "difficulty": "hard",
          "startingCode": "function createDataTransformer(...transforms) {\n  // TODO: Implement this HOF\n  return function(data) {\n    // TODO: Apply transformations sequentially\n    // Handle null/undefined results from intermediate steps\n  };\n}\n\n// Example Transformations:\nconst capitalize = str => str ? str.charAt(0).toUpperCase() + str.slice(1) : str;\nconst addExclamation = str => str ? str + '!' : str;\nconst removeSpaces = str => str ? str.replace(/\\s/g, '') : str;\n\n// Example Usage (uncomment to test):\n// const transformString = createDataTransformer(capitalize, removeSpaces, addExclamation);\n// console.log(transformString('hello world')); \n// console.log(transformString('  test  '));    \n// console.log(transformString(null));          \n// console.log(transformString(undefined));     \n\n// const processNumber = createDataTransformer(\n//   num => num + 10, \n//   num => num * 2, \n//   num => num > 50 ? null : num \n// );\n// console.log(processNumber(10)); // (10+10)*2 = 40\n// console.log(processNumber(20)); // (20+10)*2 = 60 -> null\n",
          "solutionCode": "function createDataTransformer(...transforms) {\n  return function(data) {\n    let currentResult = data;\n\n    for (const transformFn of transforms) {\n      // If currentResult is null or undefined, stop applying further transformations\n      if (currentResult === null || typeof currentResult === 'undefined') {\n        return currentResult;\n      }\n      currentResult = transformFn(currentResult);\n    }\n    return currentResult;\n  };\n}\n\n// Example Transformations:\nconst capitalize = str => str ? str.charAt(0).toUpperCase() + str.slice(1) : str;\nconst addExclamation = str => str ? str + '!' : str;\nconst removeSpaces = str => str ? str.replace(/\\s/g, '') : str;\n\n// Main test cases\nconst transformString = createDataTransformer(capitalize, removeSpaces, addExclamation);\nconsole.log(transformString('hello world')); // Expected: 'HelloWorld!'\nconsole.log(transformString('  test  '));    // Expected: 'Test!'\nconsole.log(transformString(null));          // Expected: null\nconsole.log(transformString(undefined));     // Expected: undefined\n\n// Additional tests\nconst processNumber = createDataTransformer(\n  num => num + 10, \n  num => num * 2, \n  num => num > 50 ? null : num \n);\nconsole.log(processNumber(10)); // (10+10)*2 = 40. Expected: 40\nconsole.log(processNumber(20)); // (20+10)*2 = 60. Then 60 > 50 ? null : 60 => null. Expected: null\n\nconst identity = x => x;\nconst transformerNoOps = createDataTransformer(identity, identity);\nconsole.log(transformerNoOps('abc')); // Expected: 'abc'\n\nconst transformerEmpty = createDataTransformer();\nconsole.log(transformerEmpty('hello')); // Expected: 'hello'\n",
          "testCases": [
            "`transformString('hello world')` should return `'HelloWorld!'`.",
            "`transformString('  test  ')` should return `'Test!'`.",
            "`transformString(null)` should return `null`.",
            "`transformString(undefined)` should return `undefined`.",
            "`createDataTransformer(num => num + 1, num => num * 2)(5)` should return `12`.",
            "A transformation returning `null` in the middle of the chain should cause subsequent transformations to be skipped.",
            "An empty `transforms` array should return the original data.",
            "Test with numerical transformations including `null`/`undefined` early exit."
          ],
          "hints": [
            "This pattern is similar to functional `compose` or `pipe` functions.",
            "You can use a loop or `Array.prototype.reduce` to apply transformations sequentially.",
            "Remember to check for `null` or `undefined` after each `transformFn` application.",
            "The initial value for `reduce` would be the input `data`."
          ],
          "tags": [
            "javascript",
            "hof",
            "functional-programming",
            "data-transformation",
            "design-patterns",
            "closures"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_higher_order_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "function-composition",
            "pipe-operator",
            "array-reduce"
          ]
        },
        {
          "id": "task_prototypal_inheritance_hierarchy",
          "title": "Build a Shape Hierarchy with Prototypal Inheritance",
          "description": "\nImplement a simple inheritance hierarchy for geometric shapes using ES5 constructor functions and prototypal inheritance. Create a base `Shape` constructor and a derived `Circle` constructor.\n\n**Requirements:**\n1.  **`Shape` Constructor**: Takes `color` as an argument and stores it. Add a method `getColor()` to its prototype that returns the color.\n2.  **`Circle` Constructor**: Takes `color` and `radius` as arguments. It should inherit `color` from `Shape` and store `radius` locally. Add a method `getArea()` to its prototype that calculates the area of the circle (`π * radius^2`).\n3.  **Prototypal Linkage**: Ensure `Circle` correctly inherits methods from `Shape` via the prototype chain.\n4.  **`instanceof` and `constructor` Checks**: Verify that instances of `Circle` are correctly identified as `Circle` and `Shape` types, and their `constructor` property points to `Circle`.\n\n**Constants:** Use `Math.PI` for the area calculation.\n\n```javascript\n// Your implementation here for Shape and Circle\n\n// Example Usage:\n// var redCircle = new Circle('red', 5);\n// console.log(redCircle.getColor());  // Expected: 'red'\n// console.log(redCircle.getArea());   // Expected: 78.539...\n// console.log(redCircle instanceof Circle);  // Expected: true\n// console.log(redCircle instanceof Shape);   // Expected: true\n// console.log(redCircle.constructor === Circle); // Expected: true\n```",
          "difficulty": "hard",
          "startingCode": "// Shape Constructor\nvar Shape = function(color) {\n  // TODO: Initialize color\n};\n\n// Shape Prototype Method\nShape.prototype.getColor = function() {\n  // TODO: Return color\n};\n\n// Circle Constructor\nfunction Circle(color, radius) {\n  // TODO: Inherit from Shape and initialize radius\n}\n\n// TODO: Set up prototype chain and fix constructor for Circle\n\n// Circle Prototype Method\nCircle.prototype.getArea = function() {\n  // TODO: Calculate and return area\n};\n\n// Example Usage (uncomment to test):\n// var redCircle = new Circle('red', 5);\n// console.log(redCircle.getColor());\n// console.log(redCircle.getArea());\n// console.log(redCircle instanceof Circle);\n// console.log(redCircle instanceof Shape);\n// console.log(redCircle.constructor === Circle);\n// console.log(redCircle.constructor === Shape); // Should be false\n",
          "solutionCode": "// Shape Constructor\nvar Shape = function(color) {\n  this.color = color;\n};\n\n// Shape Prototype Method\nShape.prototype.getColor = function() {\n  return this.color;\n};\n\n// Circle Constructor\nfunction Circle(color, radius) {\n  // Constructor borrowing: call the parent constructor to set 'color' on this Circle instance\n  Shape.call(this, color);\n  this.radius = radius;\n}\n\n// Set up the prototype chain: Circle.prototype inherits from Shape.prototype\n// This allows Circle instances to access methods from Shape.prototype\nCircle.prototype = Object.create(Shape.prototype);\n\n// Crucial: Correct the constructor property for Circle.prototype\n// Without this, Circle instances would appear to be constructed by Shape\nCircle.prototype.constructor = Circle;\n\n// Circle Prototype Method\nCircle.prototype.getArea = function() {\n  return Math.PI * this.radius * this.radius;\n};\n\n// Example Usage:\nvar redCircle = new Circle('red', 5);\nconsole.log(redCircle.getColor());  // Expected: 'red'\nconsole.log(redCircle.getArea());   // Expected: 78.53981633974483\nconsole.log(redCircle instanceof Circle);  // Expected: true\nconsole.log(redCircle instanceof Shape);   // Expected: true\nconsole.log(redCircle.constructor === Circle); // Expected: true\n\nvar blueShape = new Shape('blue');\nconsole.log(blueShape.getColor()); // Expected: 'blue'\nconsole.log(blueShape instanceof Circle); // Expected: false\nconsole.log(blueShape instanceof Shape); // Expected: true\n",
          "testCases": [
            "`redCircle.getColor()` should return 'red'.",
            "`redCircle.getArea()` should return `Math.PI * 25`.",
            "`redCircle instanceof Circle` should be `true`.",
            "`redCircle instanceof Shape` should be `true`.",
            "`redCircle.constructor === Circle` should be `true`.",
            "`new Shape('green', 10) instanceof Circle` should be `false`.",
            "`new Shape('green')` should not have a `getArea` method."
          ],
          "hints": [
            "Remember to use `Shape.call(this, ...)` inside the `Circle` constructor for property inheritance.",
            "`Object.create()` is the key to setting up the prototype chain correctly without directly assigning `Shape.prototype`.",
            "Don't forget to explicitly set `Circle.prototype.constructor = Circle;` after `Object.create()`.",
            "`Math.PI` is your friend for area calculations."
          ],
          "tags": [
            "javascript",
            "oop",
            "prototypal-inheritance",
            "constructor-functions",
            "es5",
            "inheritance"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "prototype-chain",
            "this-context",
            "instanceof"
          ]
        }
      ]
    }
  },
  {
    "id": "afa36072-8a29-4ac1-a18c-d3345bf9e4f1",
    "startLine": 900,
    "endLine": 999,
    "processedDate": "2025-06-17T07:26:59.168Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_prototype_inheritance_es5",
          "title": "Prototype-Based Inheritance (ES5)",
          "content": "In JavaScript, before ES6 classes, inheritance was primarily achieved through prototypes. Every JavaScript object has a prototype, which is another object that it inherits properties and methods from. When you try to access a property or method on an object, if it's not found directly on the object, JavaScript will look up its prototype chain until it finds the property or reaches the end of the chain (null).\n\n## Key Concepts\n-   **Prototype Chain:** The mechanism by which JavaScript objects inherit features from one another. Each object has a `[[Prototype]]` (exposed as `__proto__` in some environments, but typically accessed via `Object.getPrototypeOf()`) link to another object, forming a chain.\n-   **`prototype` Property:** Functions in JavaScript have a special `prototype` property, which is an object. When you use a function as a constructor with the `new` keyword, the `[[Prototype]]` of the newly created instance points to the constructor function's `prototype` object.\n-   **`Object.create()`:** This method creates a new object, using an existing object as the prototype of the newly created object. It's the preferred way to set up prototype chains explicitly, as it avoids issues with direct assignment of `new Parent()` to `Child.prototype`.\n-   **`constructor` Property:** Every object created via a constructor function automatically gets a `constructor` property that points back to the constructor function. When manually setting `Child.prototype = Object.create(Parent.prototype)`, the `constructor` property of `Child.prototype` gets reset to `Parent`'s constructor. It's crucial to explicitly set `Child.prototype.constructor = Child;` to maintain correct constructor references, especially for `instanceof` checks or creating new instances from the prototype.\n-   **Method Overriding:** A child object (or prototype) can define a method with the same name as a method in its parent's prototype. When this happens, the child's method will be called, effectively 'overriding' the parent's method for instances of the child type.",
          "examples": [
            {
              "id": "example_prototype_inheritance_es5_1",
              "title": "Basic Prototype Inheritance (ES5)",
              "code": "function Person(firstName) {\n  this.firstName = firstName;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(\"Hello, I'm \" + this.firstName);\n};\n\nfunction Student(firstName, subject) {\n  Person.call(this, firstName); // Call parent constructor for inherited properties\n  this.subject = subject;\n}\n\n// Inherit methods from Person.prototype\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student; // Correct the constructor reference\n\n// Override a method\nStudent.prototype.sayHello = function() {\n  console.log(\"Hello, I'm \" + this.firstName + \". I'm studying \" + this.subject + \".\");\n};\n\nvar person = new Person(\"Alice\");\nperson.sayHello(); // \"Hello, I'm Alice\"\n\nvar student = new Student(\"John\", \"Computer Science\");\nstudent.sayHello(); // \"Hello, I'm John. I'm studying Computer Science.\"\n\nconsole.log(student instanceof Student); // true\nconsole.log(student instanceof Person);  // true\nconsole.log(student.constructor === Student); // true",
              "explanation": "This example demonstrates how to set up classical inheritance using JavaScript's prototype chain. `Person.call(this, firstName)` ensures that `firstName` is initialized by the `Person` constructor on the `Student` instance. `Object.create(Person.prototype)` links `Student.prototype` to `Person.prototype`, establishing the inheritance chain for methods. `Student.prototype.constructor = Student` is crucial to maintain the correct constructor reference. The `sayHello` method in `Student.prototype` overrides the one from `Person.prototype` for `Student` instances.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_inheritance_es5_1",
            "question_inheritance_es5_2"
          ],
          "relatedTasks": [
            "task_es5_prototype_inheritance",
            "task_es6_class_conversion"
          ],
          "tags": [
            "JavaScript",
            "Inheritance",
            "Prototypes",
            "ES5",
            "Object.create",
            "Constructor",
            "OOP"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript_Objects",
            "Functions_as_Constructors",
            "This_Keyword"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "ES6_Classes",
            "Design_Patterns",
            "React_Class_Components"
          ]
        },
        {
          "id": "theory_es6_class_syntax",
          "title": "ES6 Class Syntax for Inheritance",
          "content": "ES6 introduced the `class` keyword, which provides a more familiar and syntactically cleaner way to work with objects and inheritance in JavaScript. While it looks like traditional class-based inheritance found in languages like Java or C++, it's important to understand that ES6 classes are primarily syntactic sugar over JavaScript's existing prototype-based inheritance model. They do not introduce a new object model.\n\n## Key Concepts\n-   **`class` Keyword:** Defines a class. Class declarations are not hoisted, unlike function declarations.\n-   **`constructor` Method:** A special method for creating and initializing an object created with a class. There can only be one special method with the name 'constructor' in a class.\n-   **`extends` Keyword:** Used in class declarations or class expressions to create a class that is a child of another class. It sets up the prototype chain automatically.\n-   **`super` Keyword:** Used to call the constructor of the parent class (e.g., `super(args)`) or to access properties/methods of the parent object (e.g., `super.method()`). In a derived class constructor, `super()` must be called before `this` can be used. This ensures the parent class's constructor initializes the instance.\n-   **Method Overriding:** Similar to prototype-based inheritance, a method defined in a child class with the same name as a method in its parent class will override the parent's method for instances of the child class. You can call the parent's method using `super.methodName()` from within the child's overridden method.",
          "examples": [
            {
              "id": "example_es6_class_syntax_1",
              "title": "Inheritance with ES6 Classes",
              "code": "class Person {\n  constructor(firstName) {\n    this.firstName = firstName;\n  }\n  \n  sayHello() {\n    console.log(\"Hello, I'm \" + this.firstName);\n  }\n}\n\nclass Student extends Person {\n  constructor(firstName, subject) {\n    super(firstName); // Call parent constructor; essential before 'this' is used\n    this.subject = subject;\n  }\n  \n  sayHello() {\n    console.log(\"Hello, I'm \" + this.firstName + \". I'm studying \" + this.subject + \".\");\n  }\n}\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // \"Hello, I'm Alice\"\n\nconst student = new Student(\"John\", \"Computer Science\");\nstudent.sayHello(); // \"Hello, I'm John. I'm studying Computer Science.\"\n\nconsole.log(student instanceof Student); // true\nconsole.log(student instanceof Person);  // true",
              "explanation": "This example shows the same inheritance hierarchy as the ES5 version, but using the ES6 class syntax. The `extends` keyword handles the prototype chain setup, and `super(firstName)` in the `Student` constructor correctly calls the `Person` constructor, initializing `this.firstName`. The `sayHello` method in `Student` demonstrates method overriding, providing a specialized greeting.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_es6_classes_1",
            "question_es6_classes_2",
            "question_es6_classes_3"
          ],
          "relatedTasks": [
            "task_es6_class_conversion"
          ],
          "tags": [
            "JavaScript",
            "Inheritance",
            "ES6 Classes",
            "Syntactic Sugar",
            "extends",
            "super",
            "OOP"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Prototype_Based_Inheritance_ES5",
            "JavaScript_Functions",
            "Object_Oriented_Programming_Concepts"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "React_Components",
            "TypeScript_Classes",
            "Modern_JavaScript_Development"
          ]
        },
        {
          "id": "theory_functional_inheritance_and_encapsulation",
          "title": "Functional Inheritance and Encapsulation",
          "content": "Functional inheritance is a pattern where an object is created by a factory function, and properties and methods are added directly to the new object (or an existing object) using closures to manage private state. This approach focuses on composition over classical inheritance and is often praised for its flexibility and natural way of handling private data.\n\n## Key Concepts\n-   **Factory Functions:** Functions that create and return new objects. Unlike constructor functions, they don't require the `new` keyword.\n-   **Composition:** Instead of inheriting an entire class, functional inheritance often involves composing objects by combining functionalities from different functions.\n-   **Closure for Private State:** A core aspect of functional inheritance is the use of closures to create private variables. Variables declared within the factory function's scope (but not attached to `this`) are accessible only by the methods defined within that same scope, effectively creating private data that cannot be accessed or modified from outside.\n-   **`Function.prototype.call()` or `Function.prototype.apply()`:** These methods are often used to 'inherit' methods or properties from another function's context by invoking it with the current object as its `this` context. This allows the 'parent' function to set up properties on the 'child' object.\n\n## Encapsulation in JavaScript\nEncapsulation is one of the fundamental principles of Object-Oriented Programming (OOP). It refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit (an object), and restricting direct access to some of an object's components. This restriction prevents external code from directly manipulating an object's internal state, promoting data integrity and modularity.\n\n### How JavaScript Achieves Encapsulation:\n1.  **Closures (Functional Inheritance/Module Pattern):** As seen in functional inheritance, variables declared within a function's scope but not exposed externally act as private members. Methods defined within that same scope can access these private variables.\n    ```javascript\n    function createCounter() {\n      let count = 0; // Private variable\n      return {\n        increment: () => count++,\n        getCount: () => count\n      };\n    }\n    const counter = createCounter();\n    // console.log(counter.count); // undefined - 'count' is private\n    console.log(counter.getCount()); // 0\n    counter.increment();\n    console.log(counter.getCount()); // 1\n    ```\n2.  **WeakMap (ES6):** Can be used to associate private data with objects, where the data is stored in the WeakMap and keyed by the object instance. This isn't true private state in the sense of being inaccessible, but it's a common pattern for 'private' instance data.\n    ```javascript\n    const _privateData = new WeakMap();\n    class MyClass {\n      constructor(value) {\n        _privateData.set(this, { value: value });\n      }\n      getValue() {\n        return _privateData.get(this).value;\n      }\n    }\n    const instance = new MyClass(10);\n    // console.log(_privateData.get(instance).value); // Accessible, but by convention considered 'private'\n    ```\n3.  **Private Class Fields (ES2019+):** JavaScript now has a standard way to define truly private class fields using a `#` prefix. These fields are only accessible from inside the class itself.\n    ```javascript\n    class MyClassWithPrivateField {\n      #privateValue; // Truly private field\n      constructor(value) {\n        this.#privateValue = value;\n      }\n      getPrivateValue() {\n        return this.#privateValue;\n      }\n      setPrivateValue(newValue) {\n        this.#privateValue = newValue;\n      }\n    }\n    const instance = new MyClassWithPrivateField(20);\n    console.log(instance.getPrivateValue()); // 20\n    // console.log(instance.#privateValue); // Syntax Error: Private field '#privateValue' must be declared in an enclosing class\n    ```\n\nFunctional inheritance with closures is a powerful and flexible way to achieve encapsulation, especially for creating reusable modules and components without the strictures of class hierarchies.",
          "examples": [
            {
              "id": "example_functional_inheritance_1",
              "title": "Coffee Machine Example (Functional Inheritance)",
              "code": "function Machine() {\n  let enabled = false; // Private variable via closure\n  \n  this.enable = function() {\n    enabled = true;\n  };\n  \n  this.disable = function() {\n    enabled = false;\n  };\n  \n  this.isEnabled = function() {\n    return enabled;\n  };\n}\n\nfunction CoffeeMachine(power) {\n  // Inherit methods from Machine by calling its constructor\n  // This copies public methods/properties defined on 'this' from Machine to CoffeeMachine instance\n  Machine.call(this);\n  \n  let waterAmount = 0; // Private variable via closure specific to CoffeeMachine\n  \n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n        console.error(\"Water amount cannot be negative\");\n        return;\n    }\n    waterAmount = amount;\n  };\n  \n  this.getWaterAmount = function() {\n    return waterAmount;\n  };\n  \n  this.brew = function() {\n    if (this.isEnabled()) {\n      console.log(`Making coffee with ${waterAmount}ml of water using ${power}W power`);\n    } else {\n      console.log(\"Coffee machine is off\");\n    }\n  };\n}\n\nconst coffeeMachine = new CoffeeMachine(1000);\nconsole.log(\"Is enabled initially?\", coffeeMachine.isEnabled()); // false\ncoffeeMachine.enable();\nconsole.log(\"Is enabled after enable()?\", coffeeMachine.isEnabled()); // true\ncoffeeMachine.setWaterAmount(200);\nconsole.log(\"Current water amount:\", coffeeMachine.getWaterAmount()); // 200\ncoffeeMachine.brew(); // \"Making coffee with 200ml of water using 1000W power\"\ncoffeeMachine.disable();\ncoffeeMachine.brew(); // \"Coffee machine is off\"\n\n// Try to access private variables (will fail or return undefined)\nconsole.log(coffeeMachine.enabled);    // undefined\nconsole.log(coffeeMachine.waterAmount); // undefined",
              "explanation": "This example illustrates functional inheritance. `Machine.call(this)` executes the `Machine` constructor function with `this` bound to the `coffeeMachine` instance, adding `enable`, `disable`, and `isEnabled` methods directly to it. `enabled` and `waterAmount` are private variables because they are declared with `let` inside their respective function scopes and are only accessible via the public methods defined in those scopes. This setup effectively demonstrates encapsulation, where internal state is protected.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_functional_encapsulation_1",
            "question_encapsulation_flashcard_1"
          ],
          "relatedTasks": [
            "task_functional_logger_with_privacy"
          ],
          "tags": [
            "JavaScript",
            "Inheritance",
            "Functional Programming",
            "Encapsulation",
            "Closures",
            "Factory Functions",
            "ES6+",
            "Private Fields",
            "OOP",
            "Design Patterns"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript_Functions",
            "Scope_and_Closures",
            "This_Keyword",
            "Object_Literals",
            "Function_Call_Apply"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "Module_Design",
            "Advanced_Design_Patterns",
            "State_Management",
            "Composition_over_Inheritance"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_inheritance_es5_1",
          "topic": "Prototype-Based Inheritance (ES5)",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following ES5 prototype-based inheritance setup:\n\n```javascript\nfunction Animal(name) {\n  this.name = name;\n}\nAnimal.prototype.speak = function() {\n  return this.name + ' makes a sound.';\n};\n\nfunction Dog(name, breed) {\n  Animal.call(this, name);\n  this.breed = breed;\n}\nDog.prototype = Object.create(Animal.prototype);\n// Missing line here\nDog.prototype.bark = function() {\n  return this.name + ' the ' + this.breed + ' barks!';\n};\n\nconst myDog = new Dog('Buddy', 'Golden Retriever');\nconsole.log(myDog.constructor === Animal);\n```\n\nWhich line should be inserted at `// Missing line here` to ensure `myDog.constructor === Dog` evaluates to `true`?",
          "answer": "Dog.prototype.constructor = Dog;",
          "options": [
            "Dog.prototype = Dog;",
            "Dog.constructor = Dog;",
            "Dog.prototype.constructor = Dog;",
            "Object.setPrototypeOf(Dog.prototype, Dog);"
          ],
          "analysisPoints": [
            "Understanding of the `constructor` property in prototype chains.",
            "Knowing that `Object.create()` resets the `constructor` property of the new object.",
            "Correctly identifying how to restore the `constructor` reference for instances of the derived class."
          ],
          "keyConcepts": [
            "Prototype Chain",
            "Constructor Property",
            "Object.create()",
            "ES5 Inheritance"
          ],
          "evaluationCriteria": [
            "Ability to debug and fix prototype inheritance issues.",
            "Knowledge of `constructor` property's behavior."
          ],
          "example": "The `Object.create(Animal.prototype)` line correctly sets up the prototype chain so that `Dog.prototype` inherits from `Animal.prototype`. However, it also reassigns the `constructor` property of `Dog.prototype` to point to `Animal`. To ensure that instances of `Dog` correctly report `Dog` as their constructor, we must explicitly set `Dog.prototype.constructor = Dog;`. This is vital for `instanceof` checks and other reflection mechanisms.",
          "tags": [
            "JavaScript",
            "ES5",
            "Inheritance",
            "Prototypes",
            "Constructor",
            "MCQ"
          ],
          "prerequisites": [
            "theory_prototype_inheritance_es5"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_es6_classes_1",
          "topic": "ES6 Class Syntax",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `super()` call within a derived class's constructor in ES6?",
          "answer": "To call the constructor of the parent class and initialize the `this` context for the derived class. It must be called before `this` can be accessed in the derived class constructor.",
          "analysisPoints": [
            "Understanding the role of `super()` in ES6 class inheritance.",
            "Knowing the timing constraint (before `this` access)."
          ],
          "keyConcepts": [
            "ES6 Classes",
            "extends",
            "super()"
          ],
          "evaluationCriteria": [
            "Basic understanding of ES6 class mechanics."
          ],
          "example": "In ES6 classes, when a class `B` `extends` class `A`, the constructor of `B` must call `super()` to properly set up the instance. If `super()` is not called, `this` will not be initialized, leading to a `ReferenceError` when `this` is accessed.",
          "tags": [
            "JavaScript",
            "ES6 Classes",
            "super",
            "Flashcard",
            "Inheritance"
          ],
          "prerequisites": [
            "theory_es6_class_syntax"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_encapsulation_1",
          "topic": "Functional Inheritance and Encapsulation",
          "level": "medium",
          "type": "open",
          "question": "Explain how the 'functional inheritance' pattern, as demonstrated by the `Machine` and `CoffeeMachine` example, achieves encapsulation. How are private variables maintained, and what are the advantages and disadvantages of this approach compared to ES6 private class fields?",
          "answer": "In the `Machine` and `CoffeeMachine` example, encapsulation is achieved through closures. Variables like `enabled` within `Machine` and `waterAmount` within `CoffeeMachine` are declared using `let` (or `var`) inside their respective function scopes. They are not attached to `this`, making them inaccessible directly from outside the function. The methods (e.g., `enable`, `isEnabled`, `setWaterAmount`, `getWaterAmount`) are defined within the same function scope and thus form a closure over these private variables, allowing them to read and modify the private state. External code can only interact with these variables through the public methods.\n\n**Advantages of Functional Encapsulation (Closures):**\n-   **True Privacy (pre-ES2019):** Before private class fields, closures were the most robust way to achieve true private data in JavaScript, as variables are completely inaccessible from the outside.\n-   **Flexibility & Composition:** Easily combine functionalities from multiple factory functions (e.g., `Object.assign` or simply calling multiple functions on `this`).\n-   **Simpler Syntax (for some):** No `new` keyword, no prototype chain to explicitly manage.\n\n**Disadvantages of Functional Encapsulation (Closures):**\n-   **Method Duplication:** Each instance gets its own copy of the public methods. This can lead to higher memory consumption if many instances are created, compared to prototype-based methods which are shared.\n-   **No `instanceof` equivalent:** Without a `prototype` chain, `instanceof` doesn't work out-of-the-box (though custom checks can be added).\n\n**Comparison with ES6 Private Class Fields (`#`):**\n-   **Syntax:** Private class fields offer a dedicated, clearer syntax (`#fieldName`) directly within the class definition.\n-   **True Privacy:** Both provide true privacy, but private class fields are a language-level feature specifically designed for this purpose within the class context.\n-   **Performance/Memory:** Methods defined in ES6 classes are usually on the prototype, so they are shared across instances, generally leading to better memory efficiency for methods than functional inheritance where methods might be duplicated per instance (unless carefully structured).\n-   **Context:** Private class fields are tied to the class syntax, whereas closures offer a more general pattern applicable anywhere functions create scope.",
          "options": [],
          "analysisPoints": [
            "Ability to explain closures as a mechanism for private variables.",
            "Understanding how `Machine.call(this)` contributes to inheritance in this context.",
            "Comparing functional encapsulation (closures) with ES6 private class fields.",
            "Discussing pros (flexibility, composition, immediate privacy) and cons (memory usage for methods per instance, less 'class-like' syntax) of functional inheritance."
          ],
          "keyConcepts": [
            "Functional Inheritance",
            "Encapsulation",
            "Closures",
            "Private Variables",
            "ES6 Private Class Fields",
            "Function.prototype.call",
            "Composition vs Inheritance"
          ],
          "evaluationCriteria": [
            "Depth of understanding of JavaScript's scoping and closure mechanisms.",
            "Ability to compare and contrast different encapsulation patterns.",
            "Articulates advantages and disadvantages clearly."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Encapsulation",
            "Functional Inheritance",
            "Closures",
            "Private Fields",
            "OOP",
            "Open-Ended"
          ],
          "prerequisites": [
            "theory_functional_inheritance_and_encapsulation",
            "Scope_and_Closures"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_es6_classes_2",
          "topic": "ES6 Class Syntax",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following ES5 prototype-based code into ES6 class syntax. Ensure the `greet` method from `Employee` calls the `greet` method of `Person` and then adds its own specialization.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return 'Hello, my name is ' + this.name + '.';\n};\n\nfunction Employee(name, title) {\n  Person.call(this, name);\n  this.title = title;\n}\n\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\n\nEmployee.prototype.greet = function() {\n  // How to call parent's greet here and add 'I am a <title>.'?\n  return Person.prototype.greet.call(this) + ' I am a ' + this.title + '.';\n};\n\nconst employee = new Employee('Alice', 'Software Engineer');\nconsole.log(employee.greet());\n```",
          "answer": "```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    return 'Hello, my name is ' + this.name + '.';\n  }\n}\n\nclass Employee extends Person {\n  constructor(name, title) {\n    super(name);\n    this.title = title;\n  }\n\n  greet() {\n    return super.greet() + ' I am a ' + this.title + '.';\n  }\n}\n\nconst employee = new Employee('Alice', 'Software Engineer');\nconsole.log(employee.greet());\n```",
          "options": [],
          "analysisPoints": [
            "Correctly using `class`, `extends`, `constructor`, and `super()` for inheritance.",
            "Understanding how to call parent methods using `super.methodName()` in ES6.",
            "Translating prototype-based constructor calls (`.call(this)`) to `super()`."
          ],
          "keyConcepts": [
            "ES6 Classes",
            "extends",
            "super",
            "Method Overriding",
            "Refactoring"
          ],
          "evaluationCriteria": [
            "Ability to refactor code between different inheritance styles.",
            "Correct usage of `super` for both constructor and method calls.",
            "Syntactic correctness of ES6 classes."
          ],
          "example": "The key to this refactoring is using `super(name)` in the `Employee` constructor to call the `Person` constructor, and `super.greet()` in the `Employee`'s `greet` method to invoke the parent's `greet` logic, which is much cleaner than `Person.prototype.greet.call(this)`.",
          "tags": [
            "JavaScript",
            "ES6 Classes",
            "Refactoring",
            "Inheritance",
            "Code Challenge",
            "OOP"
          ],
          "prerequisites": [
            "theory_prototype_inheritance_es5",
            "theory_es6_class_syntax"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_inheritance_es5_2",
          "topic": "Prototype-Based Inheritance (ES5)",
          "level": "hard",
          "type": "code",
          "question": "Consider the following JavaScript code.\n\n```javascript\nfunction A() {\n  this.x = 1;\n}\nA.prototype.getX = function() {\n  return this.x;\n};\n\nfunction B() {\n  this.y = 2;\n}\nB.prototype = new A();\nB.prototype.constructor = B;\nB.prototype.getY = function() {\n  return this.y;\n};\n\nconst objB = new B();\nconst objA = new A();\n\nconsole.log(objB.getX());\nconsole.log(objA.getX());\nconsole.log(objB.y);\nconsole.log(objA.y);\nconsole.log(objB instanceof A);\nconsole.log(objB.hasOwnProperty('x'));\n```\n\nWhat will be the output of the `console.log` statements? Explain why `objB.hasOwnProperty('x')` returns the value it does.",
          "answer": "```\n1\n1\n2\nundefined\ntrue\nfalse\n```\n\n`objB.hasOwnProperty('x')` returns `false` because when `B.prototype = new A();` is executed, an instance of `A` is created, and `this.x = 1;` is set on *that instance* (`A`'s instance). `objB` (an instance of `B`) inherits `x` from `B.prototype` (which is an `A` instance), but `x` is not directly on `objB` itself. `hasOwnProperty` only checks properties directly on the object, not inherited ones.",
          "options": [],
          "analysisPoints": [
            "Deep understanding of how `new A()` works when assigned to a prototype.",
            "Distinguishing between own properties and inherited properties.",
            "Understanding the `hasOwnProperty` method.",
            "Tracing property lookups along the prototype chain.",
            "Identifying common pitfalls in ES5 prototype inheritance."
          ],
          "keyConcepts": [
            "Prototype Chain",
            "Constructor Function",
            "hasOwnProperty",
            "Inherited Properties",
            "ES5 Inheritance"
          ],
          "evaluationCriteria": [
            "Detailed knowledge of JavaScript's prototype inheritance mechanism.",
            "Ability to predict subtle behaviors related to property lookup and `hasOwnProperty`.",
            "Capacity for in-depth explanation of technical concepts."
          ],
          "example": "This question highlights a common pitfall when using `new Parent()` for prototype inheritance in ES5, where instance properties of the parent (like `x`) end up on the prototype itself rather than being properly initialized on each child instance. The preferred method, `Object.create(Animal.prototype)`, avoids this by creating an empty object whose `[[Prototype]]` points to `Animal.prototype`, ensuring `Animal.call(this, name)` correctly initializes `x` on each `Dog` instance.",
          "tags": [
            "JavaScript",
            "ES5",
            "Inheritance",
            "Prototypes",
            "hasOwnProperty",
            "Code Analysis",
            "Hard",
            "Debugging"
          ],
          "prerequisites": [
            "theory_prototype_inheritance_es5"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_encapsulation_flashcard_1",
          "topic": "Encapsulation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of encapsulation in object-oriented programming?",
          "answer": "Encapsulation bundles data and methods together and restricts direct access to an object's internal state, promoting data integrity, modularity, and easier maintenance by preventing external code from breaking internal invariants.",
          "analysisPoints": [
            "Definition of encapsulation.",
            "Understanding its benefits (data integrity, modularity, maintenance)."
          ],
          "keyConcepts": [
            "Encapsulation",
            "OOP Principles",
            "Information Hiding"
          ],
          "evaluationCriteria": [
            "Basic understanding of OOP principles."
          ],
          "example": "Encapsulation hides the complex internal workings of an object, exposing only a public interface. This allows developers to change the internal implementation without affecting external code that relies on the object's public methods.",
          "tags": [
            "OOP",
            "Encapsulation",
            "Flashcard",
            "Principles"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_es6_classes_3",
          "topic": "ES6 Class Syntax",
          "level": "medium",
          "type": "mcq",
          "question": "Which statement about ES6 classes in JavaScript is FALSE?\n\nA. ES6 classes are syntactic sugar over JavaScript's existing prototype-based inheritance.\nB. The `constructor` method is optional in an ES6 class. If omitted, a default empty constructor is provided.\nC. A class declared with `class MyClass { ... }` is hoisted to the top of its scope like `function MyFunction() { ... }`.\nD. The `super()` keyword must be called in a derived class's `constructor` before `this` can be accessed.",
          "answer": "C. A class declared with `class MyClass { ... }` is hoisted to the top of its scope like `function MyFunction() { ... }`.",
          "options": [
            "A. ES6 classes are syntactic sugar over JavaScript's existing prototype-based inheritance.",
            "B. The `constructor` method is optional in an ES6 class. If omitted, a default empty constructor is provided.",
            "C. A class declared with `class MyClass { ... }` is hoisted to the top of its scope like `function MyFunction() { ... }`.",
            "D. The `super()` keyword must be called in a derived class's `constructor` before `this` can be accessed."
          ],
          "analysisPoints": [
            "Understanding that ES6 classes are syntactic sugar.",
            "Knowing the behavior of default constructors.",
            "Correctly identifying that class declarations are not hoisted (temporal dead zone).",
            "Confirming the `super()` call requirement."
          ],
          "keyConcepts": [
            "ES6 Classes",
            "Hoisting",
            "Syntactic Sugar",
            "Constructor",
            "super()",
            "Temporal Dead Zone"
          ],
          "evaluationCriteria": [
            "Comprehensive knowledge of ES6 class features and quirks.",
            "Distinguishing between class and function hoisting behavior."
          ],
          "example": "Unlike `function` declarations, `class` declarations are not hoisted. They behave more like `let` or `const` declarations, existing in a 'temporal dead zone' until their declaration is encountered during execution. Attempting to access a class before its declaration will result in a `ReferenceError`.",
          "tags": [
            "JavaScript",
            "ES6 Classes",
            "Hoisting",
            "MCQ",
            "Inheritance"
          ],
          "prerequisites": [
            "theory_es6_class_syntax",
            "JavaScript_Hoisting"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_es5_prototype_inheritance",
          "title": "Build a Shape Hierarchy using ES5 Prototypes",
          "description": "\nImplement a simple inheritance hierarchy for geometric shapes using ES5 prototype-based inheritance.\n\n1.  **`Shape` Constructor:**\n    *   Takes `color` as an argument.\n    *   Has a method `getArea()` that returns `0` (default for a generic shape).\n    *   Has a method `describe()` that returns `\"This is a <color> shape.\" `.\n\n2.  **`Circle` Constructor:**\n    *   Inherits from `Shape`.\n    *   Takes `color` and `radius` as arguments.\n    *   Overrides `getArea()` to return the area of a circle (`π * radius * radius`).\n    *   Overrides `describe()` to return `\"This is a <color> circle with radius <radius>.\" `.\n\n3.  **`Rectangle` Constructor:**\n    *   Inherits from `Shape`.\n    *   Takes `color`, `width`, and `height` as arguments.\n    *   Overrides `getArea()` to return the area of a rectangle (`width * height`).\n    *   Overrides `describe()` to return `\"This is a <color> rectangle with width <width> and height <height>.\" `.\n\nEnsure proper prototype chain setup and `constructor` property assignment for all derived types.\n",
          "difficulty": "medium",
          "startingCode": "function Shape(color) {\n  // TODO: Implement Shape constructor\n}\n\nShape.prototype.getArea = function() {\n  // TODO: Implement getArea for Shape\n};\n\nShape.prototype.describe = function() {\n  // TODO: Implement describe for Shape\n};\n\nfunction Circle(color, radius) {\n  // TODO: Implement Circle constructor and inheritance\n}\n\n// TODO: Implement Circle.prototype methods (getArea, describe)\n\nfunction Rectangle(color, width, height) {\n  // TODO: Implement Rectangle constructor and inheritance\n}\n\n// TODO: Implement Rectangle.prototype methods (getArea, describe)\n\n// You can use Math.PI for circle area\n",
          "solutionCode": "function Shape(color) {\n  this.color = color;\n}\n\nShape.prototype.getArea = function() {\n  return 0; // Default for a generic shape\n};\n\nShape.prototype.describe = function() {\n  return `This is a ${this.color} shape.`;\n};\n\nfunction Circle(color, radius) {\n  Shape.call(this, color);\n  this.radius = radius;\n}\n\nCircle.prototype = Object.create(Shape.prototype);\nCircle.prototype.constructor = Circle;\n\nCircle.prototype.getArea = function() {\n  return Math.PI * this.radius * this.radius;\n};\n\nCircle.prototype.describe = function() {\n  return `This is a ${this.color} circle with radius ${this.radius}.`;\n};\n\nfunction Rectangle(color, width, height) {\n  Shape.call(this, color);\n  this.width = width;\n  this.height = height;\n}\n\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n\nRectangle.prototype.getArea = function() {\n  return this.width * this.height;\n};\n\nRectangle.prototype.describe = function() {\n  return `This is a ${this.color} rectangle with width ${this.width} and height ${this.height}.`;\n};\n",
          "testCases": [
            "const genericShape = new Shape('green');\nconsole.log(genericShape.getArea());\nconsole.log(genericShape.describe());\nconsole.log(genericShape instanceof Shape);\n",
            "const myCircle = new Circle('red', 5);\nconsole.log(myCircle.getArea());\nconsole.log(myCircle.describe());\nconsole.log(myCircle instanceof Circle);\nconsole.log(myCircle instanceof Shape);\nconsole.log(myCircle.constructor === Circle);\n",
            "const myRectangle = new Rectangle('blue', 4, 6);\nconsole.log(myRectangle.getArea());\nconsole.log(myRectangle.describe());\nconsole.log(myRectangle instanceof Rectangle);\nconsole.log(myRectangle instanceof Shape);\nconsole.log(myRectangle.constructor === Rectangle);\n"
          ],
          "hints": [
            "Remember to use `Parent.call(this, ...)` in the child constructor to initialize inherited properties.",
            "Use `Object.create(Parent.prototype)` for setting up the prototype chain.",
            "Don't forget to correct the `constructor` property on the child's prototype.",
            "For `getArea` in `Circle`, use `Math.PI`."
          ],
          "tags": [
            "JavaScript",
            "ES5",
            "Inheritance",
            "Prototypes",
            "OOP",
            "Geometry"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_prototype_inheritance_es5"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Polymorphism",
            "Method_Overriding",
            "Constructor_Function"
          ]
        },
        {
          "id": "task_es6_class_conversion",
          "title": "Convert Library System to ES6 Classes",
          "description": "\nConvert the following ES5 prototype-based library system into ES6 class syntax. Ensure all inheritance, method overriding, and constructor calls are correctly translated.\n\n**Original ES5 Code:**\n```javascript\nfunction LibraryItem(id, title) {\n  this.id = id;\n  this.title = title;\n  this.isBorrowed = false;\n}\n\nLibraryItem.prototype.borrow = function() {\n  if (!this.isBorrowed) {\n    this.isBorrowed = true;\n    return `Item ${this.title} (ID: ${this.id}) borrowed.`;\n  }\n  return `Item ${this.title} (ID: ${this.id}) is already borrowed.`;\n};\n\nLibraryItem.prototype.returnItem = function() {\n  if (this.isBorrowed) {\n    this.isBorrowed = false;\n    return `Item ${this.title} (ID: ${this.id}) returned.`;\n  }\n  return `Item ${this.title} (ID: ${this.id}) is not borrowed.`;\n};\n\nfunction Book(id, title, author, isbn) {\n  LibraryItem.call(this, id, title);\n  this.author = author;\n  this.isbn = isbn;\n}\nBook.prototype = Object.create(LibraryItem.prototype);\nBook.prototype.constructor = Book;\n\nBook.prototype.getInfo = function() {\n  return `${this.title} by ${this.author}, ISBN: ${this.isbn}.`;\n};\n\nfunction DVD(id, title, director, duration) {\n  LibraryItem.call(this, id, title);\n  this.director = director;\n  this.duration = duration;\n}\nDVD.prototype = Object.create(LibraryItem.prototype);\nDVD.prototype.constructor = DVD;\n\nDVD.prototype.getInfo = function() {\n  return `${this.title} directed by ${this.director}, Duration: ${this.duration} minutes.`;\n};\n\n// Example Usage (for testing):\n// const book1 = new Book('B001', 'The Hobbit', 'J.R.R. Tolkien', '978-0-345-33968-3');\n// console.log(book1.getInfo());\n// console.log(book1.borrow());\n// console.log(book1.borrow());\n// console.log(book1.returnItem());\n// console.log(book1.returnItem());\n\n// const dvd1 = new DVD('D001', 'Inception', 'Christopher Nolan', 148);\n// console.log(dvd1.getInfo());\n// console.log(dvd1.borrow());\n```\n\n**Requirements:**\n1.  Translate `LibraryItem`, `Book`, and `DVD` into ES6 classes.\n2.  Maintain the inheritance chain: `Book` and `DVD` should extend `LibraryItem`.\n3.  Ensure `borrow()`, `returnItem()`, and `getInfo()` methods function identically.\n4.  Confirm `constructor` calls (`super()`) are correctly implemented.\n",
          "difficulty": "medium",
          "startingCode": "// Your ES6 class implementation goes here\n\nclass LibraryItem {\n  // TODO: Implement constructor and methods\n}\n\nclass Book extends LibraryItem {\n  // TODO: Implement constructor and methods\n}\n\nclass DVD extends LibraryItem {\n  // TODO: Implement constructor and methods\n}\n\n",
          "solutionCode": "class LibraryItem {\n  constructor(id, title) {\n    this.id = id;\n    this.title = title;\n    this.isBorrowed = false;\n  }\n\n  borrow() {\n    if (!this.isBorrowed) {\n      this.isBorrowed = true;\n      return `Item ${this.title} (ID: ${this.id}) borrowed.`;\n    }\n    return `Item ${this.title} (ID: ${this.id}) is already borrowed.`;\n  }\n\n  returnItem() {\n    if (this.isBorrowed) {\n      this.isBorrowed = false;\n      return `Item ${this.title} (ID: ${this.id}) returned.`;\n    }\n    return `Item ${this.title} (ID: ${this.id}) is not borrowed.`;\n  }\n}\n\nclass Book extends LibraryItem {\n  constructor(id, title, author, isbn) {\n    super(id, title);\n    this.author = author;\n    this.isbn = isbn;\n  }\n\n  getInfo() {\n    return `${this.title} by ${this.author}, ISBN: ${this.isbn}.`;\n  }\n}\n\nclass DVD extends LibraryItem {\n  constructor(id, title, director, duration) {\n    super(id, title);\n    this.director = director;\n    this.duration = duration;\n  }\n\n  getInfo() {\n    return `${this.title} directed by ${this.director}, Duration: ${this.duration} minutes.`;\n  }\n}\n",
          "testCases": [
            "const book1 = new Book('B001', 'The Hobbit', 'J.R.R. Tolkien', '978-0-345-33968-3');\nconsole.log(book1.getInfo());\nconsole.log(book1.borrow());\nconsole.log(book1.borrow());\nconsole.log(book1.returnItem());\nconsole.log(book1.returnItem());\nconsole.log(book1 instanceof Book);\nconsole.log(book1 instanceof LibraryItem);\n",
            "const dvd1 = new DVD('D001', 'Inception', 'Christopher Nolan', 148);\nconsole.log(dvd1.getInfo());\nconsole.log(dvd1.borrow());\nconsole.log(dvd1 instanceof DVD);\nconsole.log(dvd1 instanceof LibraryItem);\n"
          ],
          "hints": [
            "Remember that `extends` handles the prototype chain automatically.",
            "In derived class constructors, `super()` must be called first to initialize the parent's properties.",
            "Methods defined directly in an ES6 class are automatically added to the class's prototype, similar to `MyClass.prototype.method = function() { ... }` in ES5."
          ],
          "tags": [
            "JavaScript",
            "ES6 Classes",
            "Inheritance",
            "Refactoring",
            "OOP",
            "Library"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_es6_class_syntax",
            "theory_prototype_inheritance_es5"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Polymorphism",
            "Class_Hierarchy",
            "Syntactic_Sugar"
          ]
        },
        {
          "id": "task_functional_logger_with_privacy",
          "title": "Implement a Functional Logger with Private State",
          "description": "\nCreate a logging utility using functional inheritance and closures to ensure private state.\n\n1.  **`createLogger` Factory Function:**\n    *   Takes an initial `logLevel` (e.g., 'INFO', 'WARN', 'ERROR') as a string. Default to 'INFO'.\n    *   Manages a private array `_logs` to store all messages, and a private `currentLevel`.\n    *   Returns an object with the following public methods:\n        *   `log(message, level)`: Adds a message to `_logs` if its `level` is greater than or equal to `currentLevel`. If `level` is omitted, default to 'INFO'.\n        *   `setLogLevel(newLevel)`: Updates `currentLevel`.\n        *   `getLogs()`: Returns a copy of the private `_logs` array.\n        *   `clearLogs()`: Clears the private `_logs` array.\n\n2.  **`createTimedLogger` Factory Function:**\n    *   Takes an initial `logLevel` as an argument.\n    *   Functionally inherits from `createLogger`.\n    *   Overrides the `log` method to automatically prepend a timestamp (`new Date().toISOString()`) to the message before logging it to the `_logs` array.\n\n**Logging Levels (for comparison):**\n*   'ERROR': 3\n*   'WARN': 2\n*   'INFO': 1\n*   'DEBUG': 0\n\nMessages with a lower level value than `currentLevel` should not be logged. For example, if `currentLevel` is 'INFO' (1), 'DEBUG' (0) messages should not be logged.\n",
          "difficulty": "hard",
          "startingCode": "const LOG_LEVELS = {\n  'DEBUG': 0,\n  'INFO': 1,\n  'WARN': 2,\n  'ERROR': 3\n};\n\nfunction createLogger(initialLevel = 'INFO') {\n  // TODO: Implement private state (_logs, currentLevel) and public methods\n  let _logs = [];\n  let currentLevel = LOG_LEVELS[initialLevel.toUpperCase()];\n\n  return {\n    log: function(message, level = 'INFO') {\n      // TODO: Implement logging logic with level comparison\n    },\n    setLogLevel: function(newLevel) {\n      // TODO: Implement level setter\n    },\n    getLogs: function() {\n      // TODO: Implement getLogs\n    },\n    clearLogs: function() {\n      // TODO: Implement clearLogs\n    }\n  };\n}\n\nfunction createTimedLogger(initialLevel = 'INFO') {\n  // TODO: Implement functional inheritance from createLogger and override log\n}\n",
          "solutionCode": "const LOG_LEVELS = {\n  'DEBUG': 0,\n  'INFO': 1,\n  'WARN': 2,\n  'ERROR': 3\n};\n\nfunction createLogger(initialLevel = 'INFO') {\n  let _logs = [];\n  let currentLevel = LOG_LEVELS[initialLevel.toUpperCase()] || LOG_LEVELS['INFO'];\n\n  return {\n    log: function(message, level = 'INFO') {\n      const messageLevel = LOG_LEVELS[level.toUpperCase()];\n      if (messageLevel !== undefined && messageLevel >= currentLevel) {\n        _logs.push(`[${level.toUpperCase()}] ${message}`);\n      }\n    },\n    setLogLevel: function(newLevel) {\n      const levelValue = LOG_LEVELS[newLevel.toUpperCase()];\n      if (levelValue !== undefined) {\n        currentLevel = levelValue;\n      } else {\n        console.warn(`Invalid log level: ${newLevel}`);\n      }\n    },\n    getLogs: function() {\n      return [..._logs]; // Return a copy to prevent external modification of private array\n    },\n    clearLogs: function() {\n      _logs = [];\n    }\n  };\n}\n\nfunction createTimedLogger(initialLevel = 'INFO') {\n  const logger = createLogger(initialLevel);\n\n  // Override the log method\n  const originalLog = logger.log;\n  logger.log = function(message, level = 'INFO') {\n    const timestamp = new Date().toISOString();\n    originalLog.call(this, `(${timestamp}) ${message}`, level);\n  };\n\n  return logger;\n}\n",
          "testCases": [
            "// Test Basic Logger\nconst myLogger = createLogger('INFO');\nmyLogger.log('This is an info message.');\nmyLogger.log('This is a debug message.', 'DEBUG');\nmyLogger.log('This is an error message.', 'ERROR');\nconsole.log(myLogger.getLogs().length);\nconsole.log(myLogger.getLogs()[0].includes('[INFO]'));\n\nmyLogger.setLogLevel('DEBUG');\nmyLogger.log('Another debug message.', 'DEBUG');\nconsole.log(myLogger.getLogs().length);\n\nmyLogger.clearLogs();\nconsole.log(myLogger.getLogs().length);\n",
            "// Test Timed Logger\nconst timedLogger = createTimedLogger('WARN');\ntimedLogger.log('Warning: Something happened.', 'WARN');\ntimedLogger.log('Error: Critical failure.', 'ERROR');\ntimedLogger.log('Info: App started.', 'INFO');\n\nconst timedLogs = timedLogger.getLogs();\nconsole.log(timedLogs.length);\nconsole.log(timedLogs[0].includes('(' + new Date().getFullYear()));\nconsole.log(timedLogs[0].includes('[WARN] Warning: Something happened.'));\n"
          ],
          "hints": [
            "For `createLogger`, declare `_logs` and `currentLevel` with `let` inside the factory function to make them private via closure.",
            "Ensure `getLogs()` returns a *copy* of the `_logs` array (e.g., `[..._logs]`) to prevent external direct modification.",
            "For `createTimedLogger`, call `createLogger` to get the base logger object. Then, override its `log` method.",
            "Inside the overridden `log` method in `createTimedLogger`, use `originalLog.call(this, ...)` to invoke the parent's `log` method with the correct `this` context and the new timestamped message."
          ],
          "tags": [
            "JavaScript",
            "Functional Programming",
            "Encapsulation",
            "Closures",
            "Factory Functions",
            "OOP",
            "Design Patterns",
            "Composition"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_functional_inheritance_and_encapsulation",
            "Scope_and_Closures",
            "Function_Call_Apply"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Composition_over_Inheritance",
            "Module_Pattern",
            "Private_State",
            "Factory_Pattern"
          ]
        }
      ]
    }
  },
  {
    "id": "b0abeb96-1032-4163-b37e-7ce0a9262e1f",
    "startLine": 1000,
    "endLine": 1099,
    "processedDate": "2025-06-17T07:28:50.930Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_private_members_js",
          "title": "Private Members in JavaScript: Closures vs. Symbols",
          "content": "In JavaScript, achieving true data privacy for object properties has historically been a challenge due to its dynamic nature and lack of built-in private modifiers until recent ES versions (with `#` private class fields). However, two common patterns for creating 'private' or encapsulated members are using closures and ES6 Symbols.\n\n## 1. Using Closures for Private Members\nClosures provide a robust way to create truly private variables and functions. When an inner function retains access to its outer (enclosing) function's scope even after the outer function has finished executing, it forms a closure. This allows variables declared within the outer function to be accessible only by the inner function(s), effectively making them private to the returned object's methods.\n\n### How it works:\n1.  A constructor function (or a factory function) declares variables using `let` or `const` within its scope.\n2.  It then returns an object containing public methods.\n3.  These public methods, being defined within the same scope, 'close over' the private variables, allowing them to read and modify them.\n4.  The private variables are not directly accessible from outside the returned object, ensuring encapsulation.\n\n**Advantages:**\n*   **True Privacy:** Variables are genuinely inaccessible from outside.\n*   **Simple for functional patterns:** Aligns well with factory functions.\n\n**Disadvantages:**\n*   **Memory Overhead:** Each instance created via this pattern will have its own set of private variables and method copies, potentially consuming more memory.\n*   **Method Duplication:** Methods are recreated for every instance, not shared via the prototype chain.\n\n## 2. Using ES6 Symbols for \"Pseudo-Private\" Members\nES6 introduced `Symbol` as a new primitive data type. Symbols are unique and immutable values that can be used as object property keys. While not truly private (as they can be discovered using `Object.getOwnPropertySymbols()` or `Reflect.ownKeys()`), they provide a way to create properties that are not easily discoverable or enumerable, making them suitable for internal use within a class without polluting the public interface.\n\n### How it works:\n1.  A `Symbol` is created and assigned to a `const` variable outside the class definition.\n2.  This `Symbol` is then used as a property key within the class constructor (`this[_symbolKey] = value;`) and accessed by class methods.\n3.  Since Symbols are not enumerable by `for...in` loops or `Object.keys()`, the property appears \"hidden\" from casual inspection.\n\n**Advantages:**\n*   **Prevents Name Collisions:** Symbols are unique, preventing accidental overwrites of properties.\n*   **Less Memory Overhead (compared to closures for classes):** Methods can be defined on the prototype, shared across instances.\n*   **Semantically clear:** Indicates an intended internal property.\n\n**Disadvantages:**\n*   **Not Truly Private:** `Object.getOwnPropertySymbols()` can reveal these properties.\n*   **Requires Convention:** Developers still need to know about the Symbol to access the property, often leading to using `_` prefix for clarity.\n\n```javascript\n// Using closures for private members\nfunction Counter() {\n  // Private variable\n  let count = 0;\n  \n  // Public interface\n  return {\n    increment: function() {\n      count++;\n    },\n    decrement: function() {\n      count--;\n    },\n    getCount: function() {\n      return count;\n    }\n  };\n}\n\n// Using ES6 classes with symbols\nconst _count = Symbol('count'); // Declare Symbol outside the class\n\nclass CounterClass {\n  constructor() {\n    this[_count] = 0; // Use Symbol as a property key\n  }\n  \n  increment() {\n    this[_count]++;\n  }\n  \n  decrement() {\n    this[_count]--;\n  }\n  \n  getCount() {\n    return this[_count];\n  }\n}\n```",
          "examples": [
            {
              "id": "example_private_members_closure_1",
              "title": "Closure-based Counter Example",
              "code": "function Counter() {\n  let count = 0; // Private variable\n  \n  return {\n    increment: function() {\n      count++;\n    },\n    decrement: function() {\n      count--;\n    },\n    getCount: function() {\n      return count;\n    }\n  };\n}\n\nconst counter = Counter();\ncounter.increment();\ncounter.increment();\nconsole.log(counter.getCount()); // Output: 2\nconsole.log(counter.count); // Output: undefined (count is private)",
              "explanation": "This example demonstrates how the `count` variable is truly private to the `Counter` instance. It can only be accessed or modified via the `increment`, `decrement`, and `getCount` methods returned by the `Counter` function. Direct access `counter.count` results in `undefined`.",
              "language": "javascript"
            },
            {
              "id": "example_private_members_symbol_1",
              "title": "Symbol-based Counter Example",
              "code": "const _count = Symbol('count'); // Unique symbol for internal use\n\nclass CounterClass {\n  constructor() {\n    this[_count] = 0; // Property key is a Symbol\n  }\n  \n  increment() {\n    this[_count]++;\n  }\n  \n  decrement() {\n    this[_count]--;\n  }\n  \n  getCount() {\n    return this[_count];\n  }\n}\n\nconst counterSym = new CounterClass();\ncounterSym.increment();\ncounterSym.increment();\nconsole.log(counterSym.getCount()); // Output: 2\n\n// Attempting to access directly will not work (unless you have the Symbol)\nconsole.log(counterSym._count); // Output: undefined (if _count is not a string literal)\n\n// How it's discoverable (demonstrating it's not truly private)\nconsole.log(Object.getOwnPropertySymbols(counterSym)); // Output: [Symbol(count)]\nconsole.log(counterSym[Object.getOwnPropertySymbols(counterSym)[0]]); // Output: 2",
              "explanation": "This example shows how `_count` (a Symbol) is used as a property key within `CounterClass`. While it's not directly accessible via dot notation (`.count`), it's also not truly private as `Object.getOwnPropertySymbols()` can reveal and allow access to it. It effectively hides the property from typical enumeration methods like `Object.keys()` or `for...in` loops.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_private_members_1",
            "question_private_members_2",
            "question_private_members_3",
            "question_private_members_4",
            "question_private_members_5",
            "question_private_members_6",
            "question_private_members_7"
          ],
          "relatedTasks": [
            "task_private_members_1",
            "task_private_members_2"
          ],
          "tags": [
            "JavaScript",
            "OOP",
            "Encapsulation",
            "Closures",
            "Symbols",
            "ES6"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "es6_classes",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "design_patterns",
            "complex_class_design"
          ]
        },
        {
          "id": "theory_polymorphism_js",
          "title": "Polymorphism in JavaScript",
          "content": "Polymorphism, one of the fundamental principles of Object-Oriented Programming (OOP), means \"many forms.\" In the context of JavaScript, it refers to the ability of different objects to respond to the same method call in their own specific ways. This allows for a common interface to be used across a hierarchy of related objects, leading to more flexible and extensible code.\n\n### Key Concepts of Polymorphism:\n1.  **Method Overriding:** This is the most common form of polymorphism in JavaScript. A subclass (derived class) provides a specific implementation of a method that is already defined in its superclass (base class). When that method is called on an object, the specific implementation of the object's class is executed.\n2.  **Common Interface:** Polymorphism allows you to treat objects of different classes uniformly through a common interface. For example, if multiple animal classes all have a `speak()` method, you can iterate over a collection of different animal types and call `speak()` on each, without needing to know the specific type of animal at runtime.\n\n### Benefits of Polymorphism:\n*   **Code Reusability:** Common logic can be defined in a base class and overridden where necessary.\n*   **Flexibility and Extensibility:** New classes can be added to the hierarchy without modifying existing code that uses the common interface.\n*   **Maintainability:** Code becomes easier to manage and understand because behavior is encapsulated within each class.\n*   **Decoupling:** Code that interacts with polymorphic objects is decoupled from the specific implementations of those objects.\n\nIn JavaScript, polymorphism is often demonstrated using ES6 classes and inheritance, where a child class extends a parent class and overrides one or more of its methods.\n\n```javascript\n// Polymorphism Examples\n\nclass Animal {\n  speak() {\n    return \"Animal makes a sound\";\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    return \"Dog barks\";\n  }\n}\n\nclass Cat extends Animal {\n  speak() {\n    return \"Cat meows\";\n  }\n}\n\nconst animals = [new Animal(), new Dog(), new Cat()];\n\nanimals.forEach(animal => {\n  console.log(animal.speak());\n});\n// Output:\n// \"Animal makes a sound\"\n// \"Dog barks\"\n// \"Cat meows\"\n```",
          "examples": [
            {
              "id": "example_polymorphism_1",
              "title": "Polymorphic `speak()` Method",
              "code": "class Animal {\n  speak() {\n    return \"Animal makes a sound\";\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    return \"Dog barks\";\n  }\n}\n\nclass Cat extends Animal {\n  speak() {\n    return \"Cat meows\";\n  }\n}\n\nconst genericAnimal = new Animal();\nconst myDog = new Dog();\nconst myCat = new Cat();\n\nconsole.log(genericAnimal.speak()); // Output: \"Animal makes a sound\"\nconsole.log(myDog.speak());       // Output: \"Dog barks\"\nconsole.log(myCat.speak());       // Output: \"Cat meows\"\n\n// Demonstrating the common interface\nconst pets = [myDog, myCat];\npets.forEach(pet => {\n  console.log(`A pet says: ${pet.speak()}`);\n});\n// Output:\n// A pet says: Dog barks\n// A pet says: Cat meows",
              "explanation": "This example clearly illustrates polymorphism. Each `Animal` subclass (`Dog`, `Cat`) overrides the `speak()` method from the base `Animal` class. When `speak()` is called on an instance, the specific implementation for that object's class is executed, even when iterating through a collection of mixed animal types using a common interface.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_polymorphism_1",
            "question_polymorphism_2",
            "question_polymorphism_3",
            "question_polymorphism_4",
            "question_polymorphism_5"
          ],
          "relatedTasks": [
            "task_polymorphism_1"
          ],
          "tags": [
            "JavaScript",
            "OOP",
            "Polymorphism",
            "Inheritance",
            "Classes",
            "Method Overriding"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "es6_classes",
            "javascript_inheritance"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "design_patterns",
            "framework_architecture"
          ]
        },
        {
          "id": "theory_composition_vs_inheritance",
          "title": "Object Composition vs. Inheritance for Code Reuse",
          "content": "In Object-Oriented Programming (OOP) and JavaScript, inheritance and composition are two primary techniques for achieving code reuse and organizing object behavior. While both aim to reduce duplication, they represent different philosophies for structuring relationships between objects.\n\n## 1. Inheritance (Is-A Relationship)\nInheritance is a mechanism where a new class (subclass or child class) derives properties and methods from an existing class (superclass or parent class). It establishes an \"is-a\" relationship: a Dog *is a* type of Animal.\n\n**Characteristics:**\n*   **Hierarchical:** Creates a tree-like structure of classes.\n*   **Tight Coupling:** Subclasses are tightly coupled to their superclasses. Changes in the superclass can break subclasses.\n*   **\"Fragile Base Class\" Problem:** Modifications to the base class can inadvertently alter the behavior of derived classes in unexpected ways.\n*   **\"Diamond Problem\":** In languages supporting multiple inheritance, a class inheriting from two classes that share a common ancestor can lead to ambiguity regarding method resolution (though JavaScript's single inheritance avoids this directly).\n\n**When to use:**\n*   When there is a clear \"is-a\" hierarchy.\n*   When you need to define a base behavior that can be specialized by subclasses.\n\n## 2. Object Composition (Has-A Relationship)\nComposition is a design principle where complex objects are built by combining simpler, more focused objects or functions. Instead of inheriting behavior, an object *has* other objects (or functions) and delegates responsibilities to them. It establishes a \"has-a\" relationship: a `Robot` *has a* `motor` and *has a* `sensor`.\n\n**Characteristics:**\n*   **Flexible:** Objects can be composed with different behaviors at runtime.\n*   **Loose Coupling:** Components are independent and can be reused in various contexts without affecting each other.\n*   **No \"Diamond Problem\":** Avoids the complexities of multiple inheritance.\n*   **Functional Mixins:** A common pattern in JavaScript to achieve composition by combining functions that add specific behaviors to an object. These functions are often referred to as \"mixins\" (though not true mixins in the classical sense, they achieve similar goals).\n\n**Functional Mixins Explained:**\nFunctional mixins are functions that take an object (or a state) as an argument, add new properties or methods to it, and then return the modified object. They promote a pattern where behavior is encapsulated in small, reusable functions that can be composed together.\n\n**When to use:**\n*   When objects need to exhibit multiple, orthogonal behaviors (e.g., an object can `eat` AND `sleep`).\n*   When you want to avoid deep, rigid class hierarchies.\n*   When you want to easily combine behaviors without complex inheritance chains.\n*   To achieve greater flexibility and reusability of smaller, single-responsibility units.\n\n**\"Favor Composition over Inheritance\" Principle:**\nThis widely recommended design principle suggests that you should try to use composition to achieve code reuse whenever possible, as it often leads to more flexible, less tightly coupled, and easier-to-maintain systems than deep inheritance hierarchies.\n\n```javascript\n// Functional mixins for composition\nconst canEat = (state) => ({\n  eat: food => {\n    console.log(`${state.name} is eating ${food}`);\n    state.energy += 10; // Modifies shared state\n  }\n});\n\nconst canSleep = (state) => ({\n  sleep: hours => {\n    console.log(`${state.name} is sleeping for ${hours} hours`);\n    state.energy += hours * 5; // Modifies shared state\n  }\n});\n```",
          "examples": [
            {
              "id": "example_composition_mixins_1",
              "title": "Composing an Entity with Functional Mixins",
              "code": "const canEat = (state) => ({\n  eat: food => {\n    console.log(`${state.name} is eating ${food}`);\n    state.energy += 10;\n  }\n});\n\nconst canSleep = (state) => ({\n  sleep: hours => {\n    console.log(`${state.name} is sleeping for ${hours} hours`);\n    state.energy += hours * 5;\n  }\n});\n\n// A factory function to create a character\nfunction createCharacter(name) {\n  let state = {\n    name,\n    energy: 100\n  };\n\n  // Combine behaviors using Object.assign\n  return Object.assign(\n    state,\n    canEat(state),\n    canSleep(state)\n  );\n}\n\nconst hero = createCharacter('Hero');\nconsole.log(`${hero.name}'s initial energy: ${hero.energy}`); // Output: Hero's initial energy: 100\nhero.eat('apple'); // Output: Hero is eating apple\nhero.sleep(8);     // Output: Hero is sleeping for 8 hours\nconsole.log(`${hero.name}'s final energy: ${hero.energy}`);   // Output: Hero's final energy: 150",
              "explanation": "This example demonstrates how `canEat` and `canSleep` are functional mixins. They take a `state` object and return an object containing behavior functions that operate on that `state`. The `createCharacter` factory function then uses `Object.assign` to compose these behaviors onto a single `hero` object. This allows `hero` to 'have' the ability to eat and sleep without inheriting from a common base class, promoting flexible and modular design.",
              "language": "javascript"
            },
            {
              "id": "example_composition_inheritance_comparison",
              "title": "Inheritance vs. Composition: A Structural Comparison",
              "code": "// Inheritance Example: \"Is-A\" relationship\nclass Vehicle {\n  drive() { console.log('Driving'); }\n}\n\nclass Car extends Vehicle {\n  openDoor() { console.log('Door opened'); }\n}\n\nconst myCar = new Car();\nmyCar.drive();\nmyCar.openDoor();\n\n// Composition Example: \"Has-A\" relationship\nconst Driver = (entity) => ({ \n  drive: () => console.log(`${entity.name} is driving`) \n});\n\nconst DoorOpener = (entity) => ({ \n  openDoor: () => console.log(`${entity.name}'s door opened`) \n});\n\nfunction createVehicle(name) {\n  const state = { name };\n  return Object.assign(state, Driver(state), DoorOpener(state));\n}\n\nconst myCustomCar = createVehicle('CustomCar');\nmyCustomCar.drive();\nmyCustomCar.openDoor();",
              "explanation": "This example starkly contrasts inheritance and composition. The `Car` *is a* `Vehicle` via inheritance. The `CustomCar` *has a* `Driver` behavior and *has a* `DoorOpener` behavior via composition using functional mixins. The composition approach offers more flexibility, as `DoorOpener` could be reused with a `House` object, which doesn't make sense in an `is-a` `Vehicle` hierarchy.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_composition_vs_inheritance_1",
            "question_composition_vs_inheritance_2",
            "question_composition_vs_inheritance_3",
            "question_composition_vs_inheritance_4",
            "question_composition_vs_inheritance_5",
            "question_composition_vs_inheritance_6"
          ],
          "relatedTasks": [
            "task_composition_inheritance_1"
          ],
          "tags": [
            "JavaScript",
            "OOP",
            "Composition",
            "Inheritance",
            "Code Reuse",
            "Design Patterns",
            "Functional Programming",
            "Mixins"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "es6_classes",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "architecture_design",
            "design_patterns",
            "library_development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_private_members_1",
          "topic": "Private Members with Closures",
          "level": "easy",
          "type": "mcq",
          "question": "Given the `Counter` function using closures, how can the `count` variable be directly accessed from outside the `Counter` instance?",
          "answer": "It cannot be directly accessed, only through its public methods.",
          "options": [
            "By `counter.count`",
            "By `counter._count`",
            "It cannot be directly accessed, only through its public methods.",
            "By `Object.getOwnPropertyNames(counter)[0]`"
          ],
          "analysisPoints": [
            "Tests understanding of closure's role in creating private scope.",
            "Differentiates between public interface and encapsulated variables.",
            "Highlights the true privacy provided by closures."
          ],
          "keyConcepts": [
            "Closures",
            "Encapsulation",
            "Private Variables"
          ],
          "evaluationCriteria": [
            "Ability to identify truly private members.",
            "Understanding of scope in JavaScript."
          ],
          "example": "```javascript\nfunction Counter() {\n  let count = 0; // Private variable\n  return {\n    increment: function() { count++; },\n    getCount: function() { return count; }\n  };\n}\nconst counter = Counter();\n// console.log(counter.count); // This will be undefined\n```\nThe `count` variable is scoped to the `Counter` function and only accessible via the `increment` and `getCount` methods, demonstrating true privacy.",
          "tags": [
            "JavaScript",
            "Closures",
            "Encapsulation"
          ],
          "prerequisites": [
            "javascript_scope"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_private_members_2",
          "topic": "Private Members with Symbols",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `CounterClass` using an ES6 Symbol for `_count`. Which statement correctly describes the privacy of `_count`?",
          "answer": "`_count` is not truly private but is non-enumerable, making it harder to access directly.",
          "options": [
            "`_count` is truly private and inaccessible from outside the class.",
            "`_count` can be accessed directly using `counterInstance._count`.",
            "`_count` is not truly private but is non-enumerable, making it harder to access directly.",
            "`_count` is only accessible if explicitly exposed via a getter method."
          ],
          "analysisPoints": [
            "Evaluates knowledge of Symbol behavior as property keys.",
            "Distinguishes between true privacy (closures) and pseudo-privacy (Symbols).",
            "Understands Symbol's enumerability characteristics."
          ],
          "keyConcepts": [
            "Symbols",
            "Encapsulation",
            "Non-enumerable Properties"
          ],
          "evaluationCriteria": [
            "Accuracy in describing Symbol behavior.",
            "Understanding of different levels of 'privacy' in JavaScript."
          ],
          "example": "```javascript\nconst _count = Symbol('count');\nclass CounterClass {\n  constructor() { this[_count] = 0; }\n  getCount() { return this[_count]; }\n}\nconst c = new CounterClass();\n// Object.getOwnPropertySymbols(c) will return [_count]\n// c[_count] will access the value.\n```\nWhile `_count` is not easily discoverable by `Object.keys()` or `for...in` loops, `Object.getOwnPropertySymbols()` can reveal it, demonstrating it's not truly private but rather hidden from common enumeration.",
          "tags": [
            "JavaScript",
            "Symbols",
            "ES6",
            "Encapsulation"
          ],
          "prerequisites": [
            "es6_classes",
            "javascript_objects"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_private_members_3",
          "topic": "Comparison of Privacy Mechanisms",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast using closures versus ES6 Symbols for creating 'private' members in JavaScript. Discuss their advantages, disadvantages, and typical use cases. Which approach provides true data privacy?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Ability to articulate the core differences between closure-based and Symbol-based privacy.",
            "Comprehensive understanding of the pros and cons of each method.",
            "Correct identification of which method offers true privacy and why.",
            "Knowledge of suitable contexts for each approach."
          ],
          "keyConcepts": [
            "Closures",
            "Symbols",
            "Encapsulation",
            "Privacy",
            "Design Patterns"
          ],
          "evaluationCriteria": [
            "Depth of comparative analysis.",
            "Clarity and accuracy of technical explanations.",
            "Insight into practical application scenarios.",
            "Correctness of conceptual understanding (e.g., 'true privacy')."
          ],
          "example": "This question requires a detailed explanation covering:\n*   **Closures:** How they create a lexical scope for private variables, making them inaccessible from outside. Advantages (true privacy, simple for factory functions) and disadvantages (memory per instance, method duplication).\n*   **Symbols:** How they create unique, non-enumerable property keys. Advantages (prevents name collision, shared prototype methods) and disadvantages (not truly private, discoverable via `getOwnPropertySymbols`).\n*   **Use Cases:** Closures often for factory functions or when true privacy is paramount. Symbols for internal properties of classes where complete privacy isn't strictly necessary, but hiding from general enumeration is desired.\n*   **True Privacy:** Closures provide true data privacy.",
          "tags": [
            "JavaScript",
            "Closures",
            "Symbols",
            "Encapsulation",
            "OOP",
            "Comparison"
          ],
          "prerequisites": [
            "theory_private_members_js"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_private_members_4",
          "topic": "Private Class Fields (ES2019+)",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the modern, official way to declare truly private class fields in JavaScript (ES2019+)?",
          "answer": "Using the `#` prefix for class fields (e.g., `#myPrivateField`).",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of modern JavaScript syntax for private class members.",
            "Quick recall of the `#` syntax."
          ],
          "keyConcepts": [
            "Private Class Fields",
            "ES2019",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Recall of specific syntax.",
            "Awareness of current language features."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "ES2019",
            "Private Class Fields",
            "Flashcard"
          ],
          "prerequisites": [
            "es6_classes"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_private_members_5",
          "topic": "Symbol Usage with `Object.keys()`",
          "level": "easy",
          "type": "mcq",
          "question": "If an object has properties defined using ES6 Symbols as keys, what will `Object.keys()` return when called on that object?",
          "answer": "An array of string-keyed property names, excluding Symbol-keyed properties.",
          "options": [
            "An array containing all property names, including Symbol-keyed ones.",
            "An array of string-keyed property names, excluding Symbol-keyed properties.",
            "An empty array, as Symbols are non-enumerable.",
            "An error, as Symbols cannot be enumerated."
          ],
          "analysisPoints": [
            "Confirms understanding of Symbol enumerability.",
            "Distinguishes `Object.keys()` from `Object.getOwnPropertySymbols()`."
          ],
          "keyConcepts": [
            "Symbols",
            "Object.keys",
            "Enumerability"
          ],
          "evaluationCriteria": [
            "Correctness regarding `Object.keys()` behavior.",
            "Understanding of Symbol's non-enumerable nature by default."
          ],
          "example": "```javascript\nconst sym1 = Symbol('foo');\nconst sym2 = Symbol('bar');\nconst obj = {\n  [sym1]: 'value1',\n  'name': 'John',\n  [sym2]: 'value2',\n  'age': 30\n};\n\nconsole.log(Object.keys(obj)); // Output: ['name', 'age']\n```\n`Object.keys()` only returns string-keyed enumerable properties. Symbol-keyed properties are not included.",
          "tags": [
            "JavaScript",
            "Symbols",
            "ES6",
            "Objects"
          ],
          "prerequisites": [
            "javascript_objects",
            "symbols"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_private_members_6",
          "topic": "Closure Scope",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of a closure in JavaScript and how it enables the creation of private variables, using a simple counter example.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Clear definition of closure.",
            "Accurate explanation of lexical scoping.",
            "Ability to trace variable access within the closure.",
            "Correctly link closures to encapsulation and private data."
          ],
          "keyConcepts": [
            "Closures",
            "Lexical Scope",
            "Encapsulation",
            "Private Variables"
          ],
          "evaluationCriteria": [
            "Clarity and precision of the explanation.",
            "Effectiveness of the example in demonstrating the concept.",
            "Understanding of how the outer function's scope is preserved."
          ],
          "example": "```javascript\nfunction createWallet(initialBalance) {\n  let balance = initialBalance; // This is the private variable\n\n  return {\n    deposit: function(amount) {\n      balance += amount;\n      console.log(`Deposited ${amount}. New balance: ${balance}`);\n    },\n    withdraw: function(amount) {\n      if (amount <= balance) {\n        balance -= amount;\n        console.log(`Withdrew ${amount}. New balance: ${balance}`);\n      } else {\n        console.log('Insufficient funds.');\n      }\n    },\n    getBalance: function() {\n      return balance;\n    }\n  };\n}\n\nconst myWallet = createWallet(100);\nmyWallet.deposit(50); // Accessible\nmyWallet.withdraw(30); // Accessible\n// console.log(myWallet.balance); // Undefined - 'balance' is private\n```\n**Explanation:** A closure is formed when `deposit`, `withdraw`, and `getBalance` functions are returned from `createWallet`. These inner functions 'close over' the `balance` variable from `createWallet`'s scope. Even after `createWallet` finishes executing, these inner functions retain access to `balance`, making it effectively private and only modifiable/readable through the returned public methods.",
          "tags": [
            "JavaScript",
            "Closures",
            "Scope",
            "Encapsulation"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_private_members_7",
          "topic": "Advantages of Private Members",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of having private members in an object or class?",
          "answer": "Encapsulation, which protects internal state from external, unauthorized modification and promotes a clear public interface.",
          "options": [],
          "analysisPoints": [
            "Tests recall of the purpose of encapsulation.",
            "Connects privacy to good software design principles."
          ],
          "keyConcepts": [
            "Encapsulation",
            "Private Members",
            "Data Hiding"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition of the benefit.",
            "Understanding of core OOP principles."
          ],
          "example": null,
          "tags": [
            "OOP",
            "Encapsulation",
            "Best Practices",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_polymorphism_1",
          "topic": "Definition of Polymorphism",
          "level": "easy",
          "type": "flashcard",
          "question": "What does 'Polymorphism' literally mean in the context of OOP?",
          "answer": "\"Many forms.\"",
          "options": [],
          "analysisPoints": [
            "Basic recall of the term's origin.",
            "Foundation for understanding the concept."
          ],
          "keyConcepts": [
            "Polymorphism",
            "OOP"
          ],
          "evaluationCriteria": [
            "Direct and correct answer.",
            "Understanding of fundamental OOP terms."
          ],
          "example": null,
          "tags": [
            "OOP",
            "Polymorphism",
            "Flashcard"
          ],
          "prerequisites": [
            "oop_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_polymorphism_2",
          "topic": "Polymorphism in Practice",
          "level": "medium",
          "type": "mcq",
          "question": "Given the `Animal`, `Dog`, and `Cat` classes provided, which of the following best demonstrates polymorphism?",
          "answer": "Iterating over an array containing instances of `Animal`, `Dog`, and `Cat`, and calling `speak()` on each.",
          "options": [
            "Defining `speak()` in `Animal` and then inheriting it in `Dog` and `Cat`.",
            "Iterating over an array containing instances of `Animal`, `Dog`, and `Cat`, and calling `speak()` on each.",
            "Creating a new `Animal` instance and calling `speak()` on it.",
            "Ensuring `Dog` and `Cat` have unique methods distinct from `Animal`."
          ],
          "analysisPoints": [
            "Identifies the practical application of polymorphism (common interface).",
            "Distinguishes between inheritance and the polymorphic use of inherited/overridden methods.",
            "Recognizes the uniform handling of diverse objects."
          ],
          "keyConcepts": [
            "Polymorphism",
            "Method Overriding",
            "Common Interface",
            "Inheritance"
          ],
          "evaluationCriteria": [
            "Correctly identifies the core polymorphic behavior.",
            "Understanding of how a common interface facilitates polymorphism."
          ],
          "example": "```javascript\nclass Animal { speak() { return 'sound'; } }\nclass Dog extends Animal { speak() { return 'bark'; } }\nclass Cat extends Animal { speak() { return 'meow'; } }\n\nconst animals = [new Animal(), new Dog(), new Cat()];\nanimals.forEach(animal => {\n  console.log(animal.speak()); // This line demonstrates polymorphism\n});\n```\nThe key is that even though `animal` could be an `Animal`, `Dog`, or `Cat` instance, the same `speak()` method call works differently for each, thanks to method overriding and the common `speak` interface.",
          "tags": [
            "JavaScript",
            "Polymorphism",
            "OOP",
            "Classes"
          ],
          "prerequisites": [
            "theory_polymorphism_js"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_polymorphism_3",
          "topic": "Benefits of Polymorphism",
          "level": "medium",
          "type": "open",
          "question": "Discuss two significant benefits of using polymorphism in object-oriented programming. Provide a simple JavaScript example to illustrate one of these benefits.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Ability to articulate key advantages of polymorphism.",
            "Provision of a relevant and clear example.",
            "Demonstrates understanding of how benefits are realized in code."
          ],
          "keyConcepts": [
            "Polymorphism",
            "Code Reusability",
            "Extensibility",
            "Maintainability"
          ],
          "evaluationCriteria": [
            "Clarity and correctness of stated benefits.",
            "Quality and relevance of the example.",
            "Logical connection between concept and example."
          ],
          "example": "```javascript\n// Benefit 1: Flexibility and Extensibility\nclass Shape {\n  getArea() { throw new Error('Method must be implemented by subclasses'); }\n}\n\nclass Circle extends Shape {\n  constructor(radius) { super(); this.radius = radius; }\n  getArea() { return Math.PI * this.radius * this.radius; }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) { super(); this.width = width; this.height = height; }\n  getArea() { return this.width * this.height; }\n}\n\nfunction calculateTotalArea(shapes) {\n  let total = 0;\n  for (const shape of shapes) {\n    total += shape.getArea(); // Polymorphic call\n  }\n  return total;\n}\n\nconst shapes = [new Circle(5), new Rectangle(4, 6)];\nconsole.log(calculateTotalArea(shapes)); // Calculates total area correctly\n\n// A new shape can be added without changing calculateTotalArea\nclass Triangle extends Shape {\n  constructor(base, height) { super(); this.base = base; this.height = height; }\n  getArea() { return 0.5 * this.base * this.height; }\n}\nshapes.push(new Triangle(3, 8));\nconsole.log(calculateTotalArea(shapes)); // Still works, demonstrating extensibility\n```\n**Benefits:**\n1.  **Flexibility and Extensibility:** Polymorphism allows new classes that adhere to a common interface (e.g., `Shape` with `getArea()`) to be added to a system without modifying existing code that processes those objects. The `calculateTotalArea` function doesn't need to know about `Circle`, `Rectangle`, or `Triangle` specifically; it just relies on the `getArea()` method.\n2.  **Code Reusability:** Common functionality can be defined at a higher level (e.g., `Animal.speak()`), and subclasses only need to override specific behaviors, avoiding redundant code.",
          "tags": [
            "JavaScript",
            "Polymorphism",
            "OOP",
            "Benefits",
            "Extensibility"
          ],
          "prerequisites": [
            "theory_polymorphism_js"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_polymorphism_4",
          "topic": "Method Overriding in JS",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the term for when a subclass provides its own specific implementation of a method that is already defined in its superclass?",
          "answer": "Method Overriding.",
          "options": [],
          "analysisPoints": [
            "Tests recall of key OOP terminology.",
            "Directly related to how polymorphism is achieved in class-based systems."
          ],
          "keyConcepts": [
            "Method Overriding",
            "Polymorphism",
            "Inheritance"
          ],
          "evaluationCriteria": [
            "Correctness of the term.",
            "Understanding of fundamental OOP concepts."
          ],
          "example": null,
          "tags": [
            "OOP",
            "Method Overriding",
            "Flashcard"
          ],
          "prerequisites": [
            "es6_classes",
            "javascript_inheritance"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_polymorphism_5",
          "topic": "Polymorphism vs. Overloading",
          "level": "hard",
          "type": "open",
          "question": "Distinguish between method overriding (a form of polymorphism) and method overloading. Can JavaScript natively support method overloading in the traditional sense? Explain.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Clear distinction between overriding and overloading.",
            "Correct assessment of JavaScript's native support for overloading.",
            "Explanation of JavaScript's behavior when multiple functions/methods have the same name."
          ],
          "keyConcepts": [
            "Polymorphism",
            "Method Overriding",
            "Method Overloading",
            "JavaScript Functions"
          ],
          "evaluationCriteria": [
            "Accuracy in defining both concepts.",
            "Correctly identifying JavaScript's limitations/behavior.",
            "Depth of explanation for JavaScript's function handling."
          ],
          "example": "```javascript\n// Method Overriding (Polymorphism)\nclass Parent { greet() { console.log('Hello from Parent'); } }\nclass Child extends Parent { greet() { console.log('Hello from Child'); } } // Overrides\nnew Child().greet(); // Outputs: Hello from Child\n\n// JavaScript's 'last function wins' for method overloading\nclass Calculator {\n  add(a, b) {\n    console.log(`Adding two numbers: ${a + b}`);\n  }\n  add(a, b, c) { // This will overwrite the previous add method\n    console.log(`Adding three numbers: ${a + b + c}`);\n  }\n}\nconst calc = new Calculator();\ncalc.add(1, 2, 3); // Outputs: Adding three numbers: 6\n// calc.add(1, 2); // This would result in NaN or unexpected behavior because the 2-arg version is gone.\n\n// How JavaScript typically handles 'overloading' using default parameters or rest parameters\nclass SmartCalculator {\n  add(a, b, c = 0) { // Using default parameter\n    console.log(`Sum: ${a + b + c}`);\n  }\n  // Or using rest parameters for flexible arguments\n  sum(...numbers) {\n    return numbers.reduce((acc, num) => acc + num, 0);\n  }\n}\nconst sc = new SmartCalculator();\nsc.add(1, 2);    // Sum: 3\nsc.add(1, 2, 3); // Sum: 6\nconsole.log(sc.sum(1, 2, 3, 4)); // 10\n```\n**Method Overriding:** A subclass provides a specialized implementation for a method already defined in its superclass. It's about changing behavior for the *same method signature* in a descendant class. This is a core aspect of polymorphism.\n\n**Method Overloading:** This is about having multiple methods with the *same name* but *different parameter lists* (different number or types of arguments) within the *same class*. The correct method is chosen at compile time based on the arguments provided.\n\n**JavaScript's Native Support:** JavaScript does *not* natively support method overloading in the traditional sense (based on signature). If you define multiple functions or methods with the same name, the last definition will overwrite any previous ones. You cannot have two `add` methods in the same class (or scope) that differ only by their parameter count or types. Developers typically achieve similar functionality by:\n1.  Using default parameters (`function(a, b, c = 0)`).\n2.  Using rest parameters (`function(...args)`).\n3.  Checking the number or types of arguments inside a single function (`if (arguments.length === 2)` or `typeof arg === 'string'`).",
          "tags": [
            "JavaScript",
            "Polymorphism",
            "Method Overriding",
            "Method Overloading",
            "Functions",
            "OOP"
          ],
          "prerequisites": [
            "theory_polymorphism_js"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_composition_vs_inheritance_1",
          "topic": "Composition vs. Inheritance",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the common relationship descriptor for Inheritance and Composition?",
          "answer": "Inheritance: \"Is-A\" relationship; Composition: \"Has-A\" relationship.",
          "options": [],
          "analysisPoints": [
            "Basic recall of core design principle terms.",
            "Fundamental distinction between the two approaches."
          ],
          "keyConcepts": [
            "Inheritance",
            "Composition",
            "Is-A",
            "Has-A"
          ],
          "evaluationCriteria": [
            "Correctness and conciseness of the definitions.",
            "Understanding of the core philosophical difference."
          ],
          "example": null,
          "tags": [
            "OOP",
            "Design Patterns",
            "Inheritance",
            "Composition",
            "Flashcard"
          ],
          "prerequisites": [
            "oop_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_composition_vs_inheritance_2",
          "topic": "Favor Composition",
          "level": "medium",
          "type": "open",
          "question": "Explain the phrase \"Favor Composition over Inheritance\" in object-oriented design. What are some problems inheritance can introduce that composition helps avoid?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Clear explanation of the design principle.",
            "Identification of common pitfalls of inheritance (e.g., fragile base class, tight coupling).",
            "Description of how composition mitigates these issues (e.g., flexibility, loose coupling, reusability of small units)."
          ],
          "keyConcepts": [
            "Composition",
            "Inheritance",
            "Design Principles",
            "Fragile Base Class",
            "Tight Coupling",
            "Code Reuse"
          ],
          "evaluationCriteria": [
            "Depth of explanation for the principle.",
            "Accuracy in identifying inheritance problems.",
            "Clarity on how composition provides solutions."
          ],
          "example": "```javascript\n// Problem with Inheritance: Fragile Base Class / Tight Coupling\nclass Bird {\n  fly() { console.log('I can fly'); }\n  layEggs() { console.log('Laying eggs'); }\n}\nclass Penguin extends Bird {\n  // Problem: Penguin inherits fly() but cannot fly.\n  // This breaks the Liskov Substitution Principle if not handled carefully.\n  fly() { console.log('Penguins cannot fly!'); } // Overrides, but original intent is flawed\n}\n\n// Solution with Composition: Behaviors are injected\nconst canFly = () => ({ fly: () => console.log('I can fly') });\nconst canLayEggs = () => ({ layEggs: () => console.log('Laying eggs') });\n\nfunction createBird() {\n  return { /* basic bird state */ };\n}\n\nfunction createFlyingBird() {\n  return Object.assign(createBird(), canFly(), canLayEggs());\n}\n\nfunction createPenguin() {\n  return Object.assign(createBird(), canLayEggs()); // Penguin just has layEggs, not fly\n}\n\nconst regularBird = createFlyingBird();\nregularBird.fly(); // I can fly\n\nconst penguin = createPenguin();\n// penguin.fly(); // This method doesn't exist on penguin, correctly representing its abilities\n```\n**Explanation:** \"Favor Composition over Inheritance\" is a design guideline suggesting that you achieve code reuse by composing smaller, independent objects or functions (`has-a` relationships) rather than relying heavily on inheritance hierarchies (`is-a` relationships). \n\n**Problems with Inheritance that Composition avoids:**\n1.  **Fragile Base Class Problem:** Changes to a base class can unexpectedly break or alter the behavior of its subclasses, even if the subclasses didn't directly use the changed part. Composition, by using independent components, makes objects less susceptible to changes in other components.\n2.  **Tight Coupling:** Inheritance creates a strong, compile-time coupling between parent and child classes. This makes systems less flexible and harder to refactor. Composition promotes looser coupling, as objects interact via well-defined interfaces without deep knowledge of each other's internal structures.\n3.  **The \"Diamond Problem\" (in languages with multiple inheritance):** While JS doesn't have multiple class inheritance, the problem illustrates the ambiguity of inheriting same-named methods from multiple parent branches. Composition easily handles multiple behaviors by just combining different mixins/components.\n4.  **Inflexibility:** Once an object inherits from a class, its behavior is fixed. Composition allows behaviors to be added or swapped dynamically at runtime.",
          "tags": [
            "OOP",
            "Composition",
            "Inheritance",
            "Design Patterns",
            "Best Practices",
            "Code Reuse"
          ],
          "prerequisites": [
            "theory_composition_vs_inheritance"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_composition_vs_inheritance_3",
          "topic": "Functional Mixins",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary role of functional mixins in the context of object composition in JavaScript?",
          "answer": "To add specific behaviors or capabilities to an object by combining functions.",
          "options": [
            "To enforce strict type checking for composed objects.",
            "To create private methods that are not accessible externally.",
            "To replace the need for classes entirely in object-oriented design.",
            "To add specific behaviors or capabilities to an object by combining functions."
          ],
          "analysisPoints": [
            "Identifies the purpose of functional mixins.",
            "Understands how mixins facilitate composition.",
            "Distinguishes mixins from other JS concepts (e.g., type checking, strict privacy)."
          ],
          "keyConcepts": [
            "Functional Mixins",
            "Composition",
            "Code Reuse",
            "Behavioral Delegation"
          ],
          "evaluationCriteria": [
            "Correctly identifies the function of mixins.",
            "Understanding how mixins contribute to composition."
          ],
          "example": "```javascript\nconst canWalk = (state) => ({ walk: () => console.log(`${state.name} is walking`) });\nconst canRun = (state) => ({ run: () => console.log(`${state.name} is running`) });\n\nfunction createPerson(name) {\n  const state = { name };\n  return Object.assign(state, canWalk(state), canRun(state));\n}\n\nconst person = createPerson('Alice');\nperson.walk();\nperson.run();\n```\nFunctional mixins like `canWalk` and `canRun` are functions that take an object (`state`) and return an object with new methods. These new methods are then merged onto the original object, effectively 'mixing in' new behaviors. This is a powerful way to compose objects with various functionalities.",
          "tags": [
            "JavaScript",
            "Composition",
            "Functional Programming",
            "Mixins"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_objects"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_composition_vs_inheritance_4",
          "topic": "Composition and Shared State",
          "level": "hard",
          "type": "code",
          "question": "Consider the `canEat` and `canSleep` functional mixins. Modify the `createCharacter` function to *also* include a `canAttack` mixin that depends on a `strength` property, and demonstrate its use. Ensure the `strength` property is part of the shared state.\n\n```javascript\nconst canEat = (state) => ({\n  eat: food => {\n    console.log(`${state.name} is eating ${food}`);\n    state.energy += 10;\n  }\n});\n\nconst canSleep = (state) => ({\n  sleep: hours => {\n    console.log(`${state.name} is sleeping for ${hours} hours`);\n    state.energy += hours * 5;\n  }\n});\n\n// Your code goes here\nfunction createCharacter(name, initialEnergy, initialStrength) {\n  // ... implement this ...\n}\n\n// Example usage (should work after your implementation):\n// const warrior = createCharacter('Warrior', 100, 20);\n// warrior.attack('goblin');\n// warrior.eat('steak');\n// console.log(warrior.energy);\n```",
          "answer": "```javascript\nconst canEat = (state) => ({\n  eat: food => {\n    console.log(`${state.name} is eating ${food}`);\n    state.energy += 10;\n  }\n});\n\nconst canSleep = (state) => ({\n  sleep: hours => {\n    console.log(`${state.name} is sleeping for ${hours} hours`);\n    state.energy += hours * 5;\n  }\n});\n\nconst canAttack = (state) => ({\n  attack: target => {\n    console.log(`${state.name} attacks ${target} with ${state.strength} strength!`);\n    // Maybe reduce energy or strength after attack, demonstrating state change\n    state.energy -= 5;\n  }\n});\n\nfunction createCharacter(name, initialEnergy, initialStrength) {\n  let state = {\n    name,\n    energy: initialEnergy,\n    strength: initialStrength\n  };\n\n  return Object.assign(\n    state,\n    canEat(state),\n    canSleep(state),\n    canAttack(state) // Add the new mixin\n  );\n}\n\nconst warrior = createCharacter('Warrior', 100, 20);\nconsole.log(`${warrior.name} initial energy: ${warrior.energy}`);\nwarrior.attack('goblin');\nwarrior.eat('steak');\nwarrior.sleep(2);\nconsole.log(`${warrior.name} final energy: ${warrior.energy}`);\n\nconst mage = createCharacter('Mage', 80, 5);\nmage.eat('berry');\nmage.attack('skeleton');\n```",
          "options": [],
          "analysisPoints": [
            "Ability to define a new functional mixin.",
            "Correctly integrating a new mixin into an existing composition pattern.",
            "Ensuring shared state (`strength`) is passed and utilized by the new mixin.",
            "Demonstrates understanding of `Object.assign` for composition."
          ],
          "keyConcepts": [
            "Composition",
            "Functional Mixins",
            "Shared State",
            "Object.assign"
          ],
          "evaluationCriteria": [
            "Correct implementation of the `canAttack` mixin.",
            "Successful integration into `createCharacter`.",
            "Demonstration of the composed object's functionality.",
            "Proper handling and utilization of shared state."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Composition",
            "Functional Programming",
            "Code Challenge",
            "OOP"
          ],
          "prerequisites": [
            "theory_composition_vs_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_composition_vs_inheritance_5",
          "topic": "When to Use Inheritance",
          "level": "medium",
          "type": "flashcard",
          "question": "When is inheritance generally a suitable design choice in OOP?",
          "answer": "When there is a clear \"is-a\" hierarchical relationship between objects and a desire for a common base behavior that can be specialized.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of the appropriate context for inheritance.",
            "Distinguishes inheritance from composition's use cases."
          ],
          "keyConcepts": [
            "Inheritance",
            "Is-A Relationship",
            "Design Patterns"
          ],
          "evaluationCriteria": [
            "Correct identification of suitable scenarios.",
            "Concise summary of inheritance's purpose."
          ],
          "example": null,
          "tags": [
            "OOP",
            "Inheritance",
            "Design Patterns",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_composition_vs_inheritance_6",
          "topic": "Composition Advantages",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is a primary advantage of using object composition over inheritance for code reuse?",
          "answer": "It promotes loose coupling and greater flexibility in combining behaviors.",
          "options": [
            "It inherently provides true data privacy for all properties.",
            "It ensures that methods are always shared on the prototype chain, saving memory.",
            "It eliminates the need for any form of object-oriented programming.",
            "It promotes loose coupling and greater flexibility in combining behaviors."
          ],
          "analysisPoints": [
            "Tests understanding of key benefits of composition.",
            "Distinguishes advantages from incorrect statements or unrelated concepts.",
            "Focuses on loose coupling and flexibility."
          ],
          "keyConcepts": [
            "Composition",
            "Loose Coupling",
            "Flexibility",
            "Code Reuse"
          ],
          "evaluationCriteria": [
            "Correct identification of a core advantage of composition.",
            "Understanding of design principles."
          ],
          "example": "Composition allows you to mix and match behaviors (like `canEat` and `canSleep`) without creating deep, rigid hierarchies. An object can `has-a` eating ability and `has-a` sleeping ability, which can be shared independently with other objects. This leads to more modular and flexible designs compared to a strict `is-a` inheritance chain.",
          "tags": [
            "OOP",
            "Composition",
            "Benefits",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_composition_vs_inheritance"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_private_members_1",
          "title": "Implement a Secure User Account with Closures",
          "description": "\nImplement a `UserAccount` factory function that uses closures to manage a user's `balance` and `transactionHistory` privately. The account should expose public methods for `deposit`, `withdraw`, and `getStatement`.\n\n**Requirements:**\n1.  The `UserAccount` function should return an object with `deposit`, `withdraw`, and `getStatement` methods.\n2.  `balance` and `transactionHistory` (an array of strings) must be private to the account instance, accessible only through the public methods.\n3.  `deposit(amount)`: Adds `amount` to `balance` and records a transaction string like \"Deposit: +$XX.XX\". `amount` must be positive.\n4.  `withdraw(amount)`: Subtracts `amount` from `balance` if sufficient funds exist. Records a transaction string like \"Withdraw: -$XX.XX\". `amount` must be positive and not exceed `balance`. If insufficient funds, record \"Withdrawal failed: Insufficient funds.\"\n5.  `getStatement()`: Returns a copy of the `transactionHistory` array. The original `transactionHistory` array should not be exposed directly.\n6.  Initialize `balance` to `0` and `transactionHistory` to an empty array.\n",
          "difficulty": "medium",
          "startingCode": "function UserAccount() {\n  // Private variables here\n  let balance = 0;\n  let transactionHistory = [];\n\n  // Helper for formatting transactions (optional but good practice)\n  const formatTransaction = (type, amount, success) => {\n    if (success) {\n      return `${type}: ${type === 'Deposit' ? '+' : '-'}$${amount.toFixed(2)}`;\n    } else {\n      return `Withdrawal failed: Insufficient funds. Attempted: $${amount.toFixed(2)}`;\n    }\n  };\n\n  return {\n    deposit: function(amount) {\n      // TODO: Implement deposit logic\n    },\n    withdraw: function(amount) {\n      // TODO: Implement withdraw logic\n    },\n    getStatement: function() {\n      // TODO: Implement getStatement logic\n    }\n  };\n}\n\n// Example Usage:\n// const account = UserAccount();\n// account.deposit(100);\n// account.withdraw(30);\n// account.withdraw(80); // Should fail\n// console.log(account.getStatement());\n// console.log(account.balance); // Should be undefined",
          "solutionCode": "function UserAccount() {\n  let balance = 0;\n  let transactionHistory = [];\n\n  const formatTransaction = (type, amount, success) => {\n    if (success) {\n      return `${type}: ${type === 'Deposit' ? '+' : '-'}$${amount.toFixed(2)}`;\n    } else {\n      return `Withdrawal failed: Insufficient funds. Attempted: $${amount.toFixed(2)}`;\n    }\n  };\n\n  return {\n    deposit: function(amount) {\n      if (amount <= 0) {\n        console.log('Deposit amount must be positive.');\n        return;\n      }\n      balance += amount;\n      transactionHistory.push(formatTransaction('Deposit', amount, true));\n      console.log(`Deposited $${amount.toFixed(2)}. New balance: $${balance.toFixed(2)}`);\n    },\n    withdraw: function(amount) {\n      if (amount <= 0) {\n        console.log('Withdrawal amount must be positive.');\n        return;\n      }\n      if (amount <= balance) {\n        balance -= amount;\n        transactionHistory.push(formatTransaction('Withdraw', amount, true));\n        console.log(`Withdrew $${amount.toFixed(2)}. New balance: $${balance.toFixed(2)}`);\n      } else {\n        transactionHistory.push(formatTransaction('Withdraw', amount, false));\n        console.log('Insufficient funds. Withdrawal failed.');\n      }\n    },\n    getStatement: function() {\n      // Return a copy to prevent external modification of the private array\n      return [...transactionHistory]; \n    },\n    // For testing purposes, though balance is conceptually private\n    _getCurrentBalance: function() {\n      return balance;\n    }\n  };\n}\n",
          "testCases": [
            "Initialize: `account = UserAccount(); account._getCurrentBalance()` should be 0.",
            "Deposit: `account.deposit(100); account._getCurrentBalance()` should be 100. `account.getStatement()` should contain \"Deposit: +$100.00\".",
            "Withdraw Success: `account.deposit(50); account.withdraw(20); account._getCurrentBalance()` should be 30. `account.getStatement()` should contain \"Withdraw: -$20.00\".",
            "Withdraw Failure (Insufficient Funds): `account.withdraw(100);` (when balance is 30) should not change balance. `account.getStatement()` should contain \"Withdrawal failed: Insufficient funds. Attempted: $100.00\".",
            "Negative/Zero Amounts: `account.deposit(-10);` or `account.withdraw(0);` should not change state and log error.",
            "Statement Immutability: `const statement = account.getStatement(); statement.pop();` should not affect `account.getStatement()` on subsequent calls."
          ],
          "hints": [
            "Remember that variables declared with `let` or `const` inside a function are part of its lexical scope.",
            "To prevent external modification of the `transactionHistory` array, ensure `getStatement` returns a shallow copy (e.g., using `...` spread operator or `.slice()`).",
            "Validate input `amount` to be positive for both deposit and withdrawal."
          ],
          "tags": [
            "JavaScript",
            "Closures",
            "Encapsulation",
            "State Management",
            "OOP"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "private_members_js",
            "closure_scope",
            "factory_functions"
          ]
        },
        {
          "id": "task_private_members_2",
          "title": "Build a Stopwatch Class with Pseudo-Private State",
          "description": "\nCreate an `ES6 Class` called `Stopwatch` that uses an ES6 Symbol to manage its internal `_startTime` and `_running` state. The class should provide methods to `start`, `stop`, `reset`, and `getElapsedTime`.\n\n**Requirements:**\n1.  The `Stopwatch` class must use two distinct `Symbol`s for its `_startTime` and `_running` internal properties. These symbols should be declared outside the class for best practice (or within a module scope if using modules).\n2.  `constructor()`: Initializes `_startTime` to `null` and `_running` to `false` using the Symbol-keyed properties.\n3.  `start()`: Sets `_startTime` to the current time (`Date.now()`) and `_running` to `true`. If already running, log a message and do nothing.\n4.  `stop()`: Sets `_running` to `false`. If not running, log a message and do nothing.\n5.  `reset()`: Resets `_startTime` to `null` and `_running` to `false`.\n6.  `getElapsedTime()`: Returns the elapsed time in milliseconds. If the stopwatch is running, it calculates time from `_startTime` to `Date.now()`. If stopped, it calculates time from `_startTime` to when it was last stopped (you'll need an additional Symbol for `_stopTime`). If not started, returns 0. *Self-correction: To calculate time correctly when stopped, you'll need a `_stopTime` Symbol too.* Let's simplify: `getElapsedTime` returns the total time from start to current or last stop. When `start()` is called, it should *add* to existing `_elapsedTime` if it was previously stopped, not just reset `_startTime`. This implies `_elapsedTime` should also be a Symbol-keyed property.\n\n**Revised `getElapsedTime` Logic:**\n*   `_startTime`: Timestamp when stopwatch started/resumed.\n*   `_totalTime`: Accumulates elapsed time across multiple start/stop cycles.\n*   `start()`: If not running, set `_startTime = Date.now()`, `_running = true`.\n*   `stop()`: If running, `_totalTime += Date.now() - _startTime`, `_running = false`, `_startTime = null`.\n*   `reset()`: `_totalTime = 0`, `_startTime = null`, `_running = false`.\n*   `getElapsedTime()`: Returns `_totalTime + (this[_running] ? Date.now() - this[_startTime] : 0)`.\n",
          "difficulty": "hard",
          "startingCode": "const _startTime = Symbol('startTime');\nconst _running = Symbol('running');\nconst _totalTime = Symbol('totalTime');\n\nclass Stopwatch {\n  constructor() {\n    this[_startTime] = null;\n    this[_running] = false;\n    this[_totalTime] = 0;\n  }\n\n  start() {\n    // TODO: Implement start logic\n  }\n\n  stop() {\n    // TODO: Implement stop logic\n  }\n\n  reset() {\n    // TODO: Implement reset logic\n  }\n\n  getElapsedTime() {\n    // TODO: Implement getElapsedTime logic\n  }\n}\n\n// Example Usage:\n// const sw = new Stopwatch();\n// sw.start();\n// setTimeout(() => {\n//   console.log('Elapsed after 1s:', sw.getElapsedTime()); // Approx 1000\n//   sw.stop();\n//   console.log('Elapsed after stop:', sw.getElapsedTime()); // Approx 1000\n//   sw.start(); // Resume\n//   setTimeout(() => {\n//     console.log('Elapsed after resume and 0.5s:', sw.getElapsedTime()); // Approx 1500\n//     sw.reset();\n//     console.log('Elapsed after reset:', sw.getElapsedTime()); // 0\n// }, 500);",
          "solutionCode": "const _startTime = Symbol('startTime');\nconst _running = Symbol('running');\nconst _totalTime = Symbol('totalTime');\n\nclass Stopwatch {\n  constructor() {\n    this[_startTime] = null;\n    this[_running] = false;\n    this[_totalTime] = 0; // Accumulates total elapsed time\n  }\n\n  start() {\n    if (this[_running]) {\n      console.log('Stopwatch is already running.');\n      return;\n    }\n    this[_startTime] = Date.now();\n    this[_running] = true;\n    console.log('Stopwatch started.');\n  }\n\n  stop() {\n    if (!this[_running]) {\n      console.log('Stopwatch is not running.');\n      return;\n    }\n    this[_totalTime] += Date.now() - this[_startTime];\n    this[_running] = false;\n    this[_startTime] = null; // Clear start time after stopping\n    console.log('Stopwatch stopped.');\n  }\n\n  reset() {\n    this[_totalTime] = 0;\n    this[_startTime] = null;\n    this[_running] = false;\n    console.log('Stopwatch reset.');\n  }\n\n  getElapsedTime() {\n    let currentElapsedTime = this[_totalTime];\n    if (this[_running]) {\n      currentElapsedTime += Date.now() - this[_startTime];\n    }\n    return currentElapsedTime;\n  }\n}\n",
          "testCases": [
            "Initial State: `sw = new Stopwatch(); sw.getElapsedTime()` should be 0. `Object.getOwnPropertySymbols(sw)` should contain the three Symbols.",
            "Start/Stop Basic: `sw.start(); setTimeout(() => { sw.stop(); console.assert(sw.getElapsedTime() >= 990 && sw.getElapsedTime() <= 1010, 'Expected approx 1000ms'); }, 1000);`",
            "Stopwatch Already Running: `sw.start(); sw.start();` should log 'already running' and not reset time.",
            "Stopwatch Not Running: `sw = new Stopwatch(); sw.stop();` should log 'not running'.",
            "Reset Functionality: `sw.start(); setTimeout(() => { sw.stop(); sw.reset(); console.assert(sw.getElapsedTime() === 0, 'Expected 0 after reset'); }, 500);`",
            "Resume Functionality: `sw.start(); setTimeout(() => { sw.stop(); setTimeout(() => { sw.start(); setTimeout(() => { console.assert(sw.getElapsedTime() >= 1490 && sw.getElapsedTime() <= 1510, 'Expected approx 1500ms after resume'); }, 500); }, 500); }, 1000);`",
            "Accessing Symbol properties directly: `sw[Symbol('startTime')]` should return undefined or incorrect value if a new Symbol is created, demonstrating pseudo-privacy. Only `Object.getOwnPropertySymbols(sw)[0]` can access the real value."
          ],
          "hints": [
            "Carefully manage the `_totalTime` property to accumulate elapsed time across multiple start/stop cycles.",
            "`Date.now()` is useful for getting current timestamps in milliseconds.",
            "Remember that `this[_symbol]` is the correct way to access Symbol-keyed properties within the class.",
            "Consider edge cases like calling `start()` when already running or `stop()` when not running."
          ],
          "tags": [
            "JavaScript",
            "ES6 Classes",
            "Symbols",
            "Encapsulation",
            "State Management",
            "OOP"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "es6_classes",
            "symbols",
            "javascript_dates"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "private_members_js",
            "object_state"
          ]
        },
        {
          "id": "task_polymorphism_1",
          "title": "Create a Polymorphic Notification System",
          "description": "\nDesign and implement a notification system using ES6 classes and polymorphism. You will create a base `Notifier` class and several specific notification types that inherit from it, demonstrating method overriding.\n\n**Requirements:**\n1.  **`Notifier` Base Class:**\n    *   A `constructor(message)` that initializes `this.message`.\n    *   A `send()` method that logs a generic message indicating it's a base notification and the message. (e.g., \"Generic Notification: [message]\").\n    *   An `abstract` method `getDeliveryMethod()` that throws an error, indicating it must be implemented by subclasses.\n\n2.  **`EmailNotifier` Class:**\n    *   Extends `Notifier`.\n    *   `constructor(message, recipientEmail)`: Calls parent constructor and initializes `this.recipientEmail`.\n    *   Overrides `send()` to log an email-specific message (e.g., \"Emailing to [recipientEmail]: [message]\").\n    *   Implements `getDeliveryMethod()` to return \"Email\".\n\n3.  **`SMSNotifier` Class:**\n    *   Extends `Notifier`.\n    *   `constructor(message, phoneNumber)`: Calls parent constructor and initializes `this.phoneNumber`.\n    *   Overrides `send()` to log an SMS-specific message (e.g., \"Sending SMS to [phoneNumber]: [message]\").\n    *   Implements `getDeliveryMethod()` to return \"SMS\".\n\n4.  **`PushNotifier` Class:**\n    *   Extends `Notifier`.\n    *   `constructor(message, userId)`: Calls parent constructor and initializes `this.userId`.\n    *   Overrides `send()` to log a push notification message (e.g., \"Pushing to user [userId]: [message]\").\n    *   Implements `getDeliveryMethod()` to return \"Push Notification\".\n\n5.  **Polymorphic Usage:** Create an array of different `Notifier` instances and iterate through them, calling `send()` on each to demonstrate polymorphism. Also, log their `getDeliveryMethod()` to show different implementations.\n",
          "difficulty": "medium",
          "startingCode": "class Notifier {\n  constructor(message) {\n    this.message = message;\n  }\n\n  send() {\n    console.log(`Generic Notification: ${this.message}`);\n  }\n\n  getDeliveryMethod() {\n    throw new Error('getDeliveryMethod() must be implemented by subclasses.');\n  }\n}\n\nclass EmailNotifier extends Notifier {\n  // TODO: Implement EmailNotifier\n}\n\nclass SMSNotifier extends Notifier {\n  // TODO: Implement SMSNotifier\n}\n\nclass PushNotifier extends Notifier {\n  // TODO: Implement PushNotifier\n}\n\n// TODO: Create an array of notifiers and demonstrate polymorphic behavior\n// const notifiers = [new EmailNotifier(...), new SMSNotifier(...), ...];\n// notifiers.forEach(notifier => {\n//   notifier.send();\n//   console.log(`Delivery method: ${notifier.getDeliveryMethod()}`);\n// });",
          "solutionCode": "class Notifier {\n  constructor(message) {\n    this.message = message;\n  }\n\n  send() {\n    console.log(`Generic Notification: ${this.message}`);\n  }\n\n  getDeliveryMethod() {\n    throw new Error('getDeliveryMethod() must be implemented by subclasses.');\n  }\n}\n\nclass EmailNotifier extends Notifier {\n  constructor(message, recipientEmail) {\n    super(message);\n    this.recipientEmail = recipientEmail;\n  }\n\n  send() {\n    console.log(`Emailing to ${this.recipientEmail}: ${this.message}`);\n  }\n\n  getDeliveryMethod() {\n    return \"Email\";\n  }\n}\n\nclass SMSNotifier extends Notifier {\n  constructor(message, phoneNumber) {\n    super(message);\n    this.phoneNumber = phoneNumber;\n  }\n\n  send() {\n    console.log(`Sending SMS to ${this.phoneNumber}: ${this.message}`);\n  }\n\n  getDeliveryMethod() {\n    return \"SMS\";\n  }\n}\n\nclass PushNotifier extends Notifier {\n  constructor(message, userId) {\n    super(message);\n    this.userId = userId;\n  }\n\n  send() {\n    console.log(`Pushing to user ${this.userId}: ${this.message}`);\n  }\n\n  getDeliveryMethod() {\n    return \"Push Notification\";\n  }\n}\n\n// Demonstrate polymorphic behavior\nconst notifiers = [\n  new EmailNotifier('Your order has shipped!', 'user@example.com'),\n  new SMSNotifier('New message from support.', '+1234567890'),\n  new PushNotifier('Special offer for you!', 'user123'),\n  new Notifier('General announcement.')\n];\n\nconsole.log('--- Sending Notifications ---');\nnotifiers.forEach(notifier => {\n  notifier.send();\n  console.log(`Delivery method: ${notifier.getDeliveryMethod()}`);\n  console.log('---');\n});\n\n// Test base class abstract method\ntry {\n  new Notifier('Test').getDeliveryMethod();\n} catch (error) {\n  console.log(`Caught expected error: ${error.message}`);\n}",
          "testCases": [
            "Base Notifier `send()`: `new Notifier('Hello').send()` should log \"Generic Notification: Hello\".",
            "Base Notifier `getDeliveryMethod()`: `new Notifier('Test').getDeliveryMethod()` should throw an error.",
            "EmailNotifier: `new EmailNotifier('Order', 'a@b.com').send()` should log specific email message. `getDeliveryMethod()` should return \"Email\".",
            "SMSNotifier: `new SMSNotifier('Alert', '123').send()` should log specific SMS message. `getDeliveryMethod()` should return \"SMS\".",
            "PushNotifier: `new PushNotifier('Update', 'abc').send()` should log specific push message. `getDeliveryMethod()` should return \"Push Notification\".",
            "Polymorphic Loop: An array `[email, sms, push]` should successfully call `send()` on each, outputting their specific messages.",
            "Mixed Array: Including `new Notifier()` in the polymorphic loop should still correctly call its generic `send()` and trigger the `getDeliveryMethod()` error if not handled."
          ],
          "hints": [
            "Remember to use `super()` in subclass constructors to call the parent class's constructor.",
            "The `send()` method in subclasses must `override` the parent's method.",
            "The `getDeliveryMethod()` method serves as an 'abstract' method, ensuring subclasses implement it.",
            "When calling `send()` in a loop over different notifier types, JavaScript's runtime polymorphism will ensure the correct overridden method is executed."
          ],
          "tags": [
            "JavaScript",
            "OOP",
            "Polymorphism",
            "Inheritance",
            "Classes",
            "Method Overriding"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "es6_classes",
            "javascript_inheritance"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_polymorphism_js",
            "method_overriding"
          ]
        },
        {
          "id": "task_composition_inheritance_1",
          "title": "Build a Game Character with Composable Behaviors",
          "description": "\nRefactor a simple game character implementation to favor object composition using functional mixins instead of a deep inheritance hierarchy. The character should have basic properties (name, health) and compose various abilities like `Attacker`, `Healer`, and `Mover`.\n\n**Requirements:**\n1.  **Base Character Creator:** A factory function `createCharacter(name, health)` that initializes a basic character state.\n2.  **`Attacker` Mixin:** A functional mixin `canAttack(state)` that adds an `attack(target)` method. This method should log `\"${state.name} attacks ${target}!\"` and decrease `state.health` by a fixed amount (e.g., 5) for the attacker, representing a self-penalty or exhaustion.\n3.  **`Healer` Mixin:** A functional mixin `canHeal(state)` that adds a `heal(target)` method. This method should log `\"${state.name} heals ${target}!\"` and increase `state.health` by a fixed amount (e.g., 10) for the healer.\n4.  **`Mover` Mixin:** A functional mixin `canMove(state)` that adds a `move(direction)` method. This method should log `\"${state.name} moves ${direction}.\"`.\n5.  **Compose Characters:**\n    *   Create a `Warrior` type: `name`, `health`, and capabilities of `Attacker` and `Mover`.\n    *   Create a `Cleric` type: `name`, `health`, and capabilities of `Healer` and `Mover`.\n    *   Create a `Paladin` type: `name`, `health`, and capabilities of `Attacker`, `Healer`, and `Mover`.\n6.  Demonstrate the capabilities of each composed character type.\n",
          "difficulty": "medium",
          "startingCode": "function createCharacter(name, health) {\n  return {\n    name,\n    health,\n  };\n}\n\n// TODO: Implement functional mixins: canAttack, canHeal, canMove\nconst canAttack = (state) => ({ /* ... */ });\nconst canHeal = (state) => ({ /* ... */ });\nconst canMove = (state) => ({ /* ... */ });\n\n// TODO: Create factory functions for Warrior, Cleric, Paladin using composition\n// function createWarrior(name, health) { /* ... */ }\n// function createCleric(name, health) { /* ... */ }\n// function createPaladin(name, health) { /* ... */ }\n\n// Example Usage:\n// const warrior = createWarrior('Arthur', 100);\n// warrior.attack('goblin');\n// warrior.move('north');\n// console.log(`${warrior.name}'s health: ${warrior.health}`);\n",
          "solutionCode": "function createCharacter(name, health) {\n  return {\n    name,\n    health,\n  };\n}\n\nconst canAttack = (state) => ({\n  attack: (target) => {\n    console.log(`${state.name} attacks ${target}!`);\n    state.health -= 5; // Self-penalty for attacking\n    console.log(`${state.name}'s health is now ${state.health}.`);\n  },\n});\n\nconst canHeal = (state) => ({\n  heal: (target) => {\n    console.log(`${state.name} heals ${target}!`);\n    state.health += 10; // Gain health from healing or for self\n    console.log(`${state.name}'s health is now ${state.health}.`);\n  },\n});\n\nconst canMove = (state) => ({\n  move: (direction) => {\n    console.log(`${state.name} moves ${direction}.`);\n  },\n});\n\nfunction createWarrior(name, health) {\n  const character = createCharacter(name, health);\n  return Object.assign(\n    character,\n    canAttack(character),\n    canMove(character)\n  );\n}\n\nfunction createCleric(name, health) {\n  const character = createCharacter(name, health);\n  return Object.assign(\n    character,\n    canHeal(character),\n    canMove(character)\n  );\n}\n\nfunction createPaladin(name, health) {\n  const character = createCharacter(name, health);\n  return Object.assign(\n    character,\n    canAttack(character),\n    canHeal(character),\n    canMove(character)\n  );\n}\n\n// Demonstrate Composed Characters\nconsole.log('--- Warrior Actions ---');\nconst warrior = createWarrior('Arthur', 100);\nconsole.log(`${warrior.name} initial health: ${warrior.health}`);\nwarrior.attack('goblin');\nwarrior.move('north');\nconsole.log(`${warrior.name} final health: ${warrior.health}`);\n\nconsole.log('\\n--- Cleric Actions ---');\nconst cleric = createCleric('Elara', 80);\nconsole.log(`${cleric.name} initial health: ${cleric.health}`);\ncleric.heal('herself');\ncleric.move('south');\nconsole.log(`${cleric.name} final health: ${cleric.health}`);\n\nconsole.log('\\n--- Paladin Actions ---');\nconst paladin = createPaladin('Sir Galahad', 120);\nconsole.log(`${paladin.name} initial health: ${paladin.health}`);\npaladin.attack('dragon');\npaladin.heal('Sir Galahad');\npaladin.move('east');\nconsole.log(`${paladin.name} final health: ${paladin.health}`);\n\n// Demonstrating flexibility: A non-moving character\nfunction createStaticDefender(name, health) {\n  const character = createCharacter(name, health);\n  return Object.assign(\n    character,\n    canAttack(character)\n  );\n}\nconst tower = createStaticDefender('Defense Tower', 200);\ntower.attack('siege engine');\n// tower.move('west'); // This would correctly throw an error or be undefined method",
          "testCases": [
            "Warrior Capabilities: `warrior.attack()`, `warrior.move()` should work. `warrior.heal()` should be undefined.",
            "Cleric Capabilities: `cleric.heal()`, `cleric.move()` should work. `cleric.attack()` should be undefined.",
            "Paladin Capabilities: `paladin.attack()`, `paladin.heal()`, `paladin.move()` should all work.",
            "Health Modification: `attack` should decrease health, `heal` should increase health.",
            "Initial State: All characters should start with correct `name` and `health`.",
            "Flexibility: Can easily create new types by combining mixins (e.g., a character that only attacks, but doesn't move or heal)."
          ],
          "hints": [
            "Each functional mixin (`canAttack`, `canHeal`, `canMove`) should take a `state` object as an argument and return an object with the new methods. The methods should operate on the passed `state` object.",
            "Use `Object.assign()` or the spread syntax (`{ ...obj1, ...obj2 }`) to combine the base character state with the behaviors returned by the mixins.",
            "Ensure the `state` object is mutable and passed by reference to the mixins so they can modify `health`."
          ],
          "tags": [
            "JavaScript",
            "Composition",
            "Functional Programming",
            "Design Patterns",
            "Code Reuse",
            "Factory Functions"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_composition_vs_inheritance",
            "functional_mixins"
          ]
        }
      ]
    }
  },
  {
    "id": "379b2724-4a0c-425e-8037-012d98906d04",
    "startLine": 1100,
    "endLine": 1199,
    "processedDate": "2025-06-17T07:32:45.844Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_object_composition",
          "title": "Object Composition in JavaScript",
          "content": "## Introduction to Object Composition\nObject composition is a programming paradigm where complex objects are created by combining simpler objects or functionalities. Unlike classical inheritance, which focuses on \"is-a\" relationships (e.g., a `Dog` *is-a* `Animal`), composition emphasizes \"has-a\" relationships (e.g., a `Bird` *has-a* `flying` ability, *has-a* `eating` ability).\n\nThis approach promotes flexibility, reusability, and avoids common pitfalls associated with deep inheritance hierarchies, such as the \"diamond problem\" (ambiguity arising from multiple inheritance) and tight coupling.\n\n## Core Concepts\n-   **Mixins/Composers:** Functions that return objects containing specific behaviors (methods and/or properties). These functions often take the object's `state` as an argument, allowing the behaviors to interact with and modify the internal state.\n-   **Factory Functions:** Functions that create and return new objects. They typically combine various mixins to assemble the desired object with all its capabilities.\n-   **State Management:** The internal data of an object is often managed in a `state` object, which is passed to the mixins, allowing them to operate on the same shared data.\n\n## Benefits of Composition\n-   **Flexibility:** Easily combine different behaviors in various ways to create diverse objects without a rigid hierarchy.\n-   **Reusability:** Individual behaviors (mixins) can be reused across multiple types of objects.\n-   **Maintainability:** Changes to one behavior are less likely to impact unrelated parts of the system.\n-   **Testability:** Smaller, focused mixins are easier to test in isolation.\n-   **Reduced Coupling:** Objects depend on behaviors rather than concrete classes, leading to looser coupling.\n-   **Avoids Inheritance Problems:** No more super constructor calls, `this` binding issues in inherited methods, or the fragile base class problem.\n\n## Implementation Pattern\nThe common pattern involves:\n1.  Defining `state` for the core properties of the object.\n2.  Creating small functions (mixins) that accept the `state` and return an object with methods that operate on that state.\n3.  Using the spread syntax (`...`) within a factory function to merge the `state` and all the returned behaviors into a single final object.\n\nIt's important to note that directly spreading `state` (`...state`) makes the internal state properties directly accessible and mutable from the outside. For better encapsulation, one might choose to only return methods from the factory function, with state being closed over by the mixins, or by providing getter/setter methods for controlled access.",
          "examples": [
            {
              "id": "example_object_composition_1",
              "title": "Basic Object Composition with State",
              "code": "const canEat = (state) => ({\n  eat: (food) => {\n    console.log(`${state.name} is eating ${food}`);\n    state.energy += 10; // Example: Eating increases energy\n  },\n});\n\nconst canSleep = (state) => ({\n  sleep: (hours) => {\n    console.log(`${state.name} is sleeping for ${hours} hours`);\n    state.energy += hours * 5; // Example: Sleeping increases energy\n  },\n});\n\nconst canFly = (state) => ({\n  fly: (distance) => {\n    if (state.energy >= distance * 2) {\n      console.log(`${state.name} is flying ${distance} meters`);\n      state.energy -= distance * 2;\n    } else {\n      console.log(`${state.name} is too tired to fly`);\n    }\n  },\n});\n\n// Creating objects using composition (Factory Functions)\nfunction createBird(name) {\n  const state = {\n    name,\n    energy: 100,\n  };\n  \n  return {\n    ...state, // Directly exposes name and energy. Alternative: use getters for state properties\n    ...canEat(state),\n    ...canSleep(state),\n    ...canFly(state),\n  };\n}\n\nfunction createDog(name) {\n  const state = {\n    name,\n    energy: 100,\n  };\n  \n  return {\n    ...state,\n    ...canEat(state),\n    ...canSleep(state),\n  };\n}\n\nconst bird = createBird(\"Sparrow\");\nbird.eat(\"seeds\"); \nbird.fly(20); \nconsole.log(`Sparrow's energy: ${bird.energy}`); // 100 + 10 - 40 = 70\n\nconst dog = createDog(\"Rex\");\ndog.eat(\"meat\"); \ndog.sleep(8); \nconsole.log(`Rex's energy: ${dog.energy}`); // 100 + 10 + 40 = 150\n// dog.fly(); // Error: dog.fly is not a function",
              "explanation": "This example demonstrates how `canEat`, `canSleep`, and `canFly` are functions that return objects with specific behaviors. These 'mixin' objects are then combined using the spread operator within `createBird` and `createDog` factory functions. Each mixin takes a `state` object, allowing it to modify or access shared properties like `name` and `energy`. This allows `Bird` to have `fly` ability, while `Dog` does not, showcasing how different combinations of behaviors can be created from the same set of building blocks.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_composition_1",
            "question_composition_2",
            "question_composition_3",
            "question_composition_4",
            "question_composition_5",
            "question_composition_6"
          ],
          "relatedTasks": [
            "task_character_creation_composition"
          ],
          "tags": [
            "object-oriented-programming",
            "composition",
            "javascript",
            "design-patterns",
            "functional-programming",
            "factories"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "javascript_functions",
            "spread_syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_js_patterns",
            "react_component_patterns"
          ]
        },
        {
          "id": "theory_immutable_object_patterns",
          "title": "Immutable Object Patterns in JavaScript",
          "content": "## What is Immutability?\nImmutability refers to the principle that once an object or data structure is created, it cannot be changed. Any operation that appears to modify the data actually creates a new instance of the data with the changes, leaving the original data intact.\n\n## Why Immutability is Important\nImmutability is a cornerstone of modern frontend development, particularly in state management libraries like Redux and React. Its benefits include:\n-   **Predictability:** Data flow becomes easier to understand as objects do not change unexpectedly. This makes debugging simpler and reduces side effects.\n-   **Easier Change Detection:** When an object is immutable, you can simply compare references to determine if it has changed (`oldObject !== newObject`). This is crucial for performance optimizations in UI frameworks (e.g., React's `shouldComponentUpdate` or `React.memo`).\n-   **Concurrency:** In multi-threaded environments (less common directly in frontend JS, but relevant for Web Workers), immutable data inherently avoids race conditions.\n-   **Undo/Redo Functionality:** Maintaining a history of immutable states makes implementing undo/redo features straightforward, as you can simply revert to a previous state.\n-   **Functional Programming:** Immutability is fundamental to functional programming paradigms, where functions aim to be pure (i.e., they produce the same output for the same input and have no side effects).\n\n## Immutable Object Creation Patterns\nJavaScript objects are mutable by default. To achieve immutability, new objects are created based on existing ones with the desired modifications.\n\n### 1. `Object.assign()`\n`Object.assign(target, ...sources)` copies all enumerable own properties from one or more source objects to a target object. To create an immutable update, an empty object `{}` is typically used as the target, and the original object is spread into it, followed by the new or updated properties.\n\n**Note:** `Object.assign()` performs a shallow copy. If the original object contains nested objects or arrays, those nested structures are still shared by reference and thus remain mutable. To achieve deep immutability, each nested level must also be immutably updated.\n\n### 2. Spread Syntax (`...`)\nThe spread syntax provides a more concise and readable way to achieve the same shallow cloning and merging as `Object.assign()`. It's widely used in modern JavaScript development.\n\n**Note:** Like `Object.assign()`, the spread syntax also performs a shallow copy. For deep immutability, recursive updates or libraries like Immer (for Redux) are often used.\n\n### 3. Structured Cloning (ES2021 `structuredClone()`)\nFor deep copies of objects and arrays that include complex types like `Date`, `RegExp`, `Map`, `Set`, `ArrayBuffer`, etc., the `structuredClone()` global function can be used. This provides a true deep copy without mutation, but it is a relatively newer feature.\n\n### 4. JSON Parsing Trick (for simple deep copies)\n`JSON.parse(JSON.stringify(obj))` can be used for a quick deep copy, but it has significant limitations: it cannot handle functions, `undefined`, `Symbol` values, `Date` objects (converts to string), `RegExp` objects, or circular references.",
          "examples": [
            {
              "id": "example_immutable_object_1",
              "title": "Updating Objects Immutably with Object.assign()",
              "code": "// Original mutable object\nconst person = {\n  name: 'John',\n  age: 28,\n  address: {\n    city: 'New York',\n    zip: '10001'\n  }\n};\n\n// Creating an updated object using Object.assign()\n// This creates a new object and copies properties from person, then applies { age: 29 }\nconst updatedPerson = Object.assign({}, person, {\n  age: 29\n});\n\nconsole.log(person);        // { name: 'John', age: 28, address: { city: 'New York', zip: '10001' } }\nconsole.log(updatedPerson); // { name: 'John', age: 29, address: { city: 'New York', zip: '10001' } }\n\n// Demonstrating shallow copy issue with Object.assign()\nupdatedPerson.address.city = 'Los Angeles';\nconsole.log(person.address.city); // Output: 'Los Angeles' (Original object was mutated!)",
              "explanation": "`Object.assign({}, person, { age: 29 })` creates a *new* object. Properties from `person` are copied into this new object. Then, the `age` property is overridden. Crucially, primitive values (like `name`, `age`) are copied by value, but nested objects (like `address`) are copied by *reference*. This means changing a property within a nested object in `updatedPerson` will also change it in `person`.",
              "language": "javascript"
            },
            {
              "id": "example_immutable_object_2",
              "title": "Updating Objects Immutably with Spread Operator",
              "code": "// Original mutable object\nconst product = {\n  id: 'abc',\n  price: 100,\n  details: {\n    weight: 500,\n    color: 'red'\n  }\n};\n\n// Creating an updated object using spread operator (ES6+)\nconst updatedProduct = {\n  ...product,\n  price: 120\n};\n\nconsole.log(product);       // { id: 'abc', price: 100, details: { weight: 500, color: 'red' } }\nconsole.log(updatedProduct); // { id: 'abc', price: 120, details: { weight: 500, color: 'red' } }\n\n// Demonstrating shallow copy issue with spread operator\nupdatedProduct.details.color = 'blue';\nconsole.log(product.details.color); // Output: 'blue' (Original object was mutated!)",
              "explanation": "The spread operator (`...product`) unpacks all enumerable properties from `product` into a new object. Then, `price: 120` overwrites the `price` property. Similar to `Object.assign()`, this is a shallow copy. Nested objects `details` are still references to the original object's nested `details` object.",
              "language": "javascript"
            },
            {
              "id": "example_immutable_object_3",
              "title": "Achieving Deep Immutability for Nested Objects",
              "code": "const user = {\n  id: 1,\n  profile: {\n    name: 'Alice',\n    preferences: {\n      theme: 'dark',\n      notifications: true\n    }\n  }\n};\n\n// To update notifications immutably, each nested level must be copied\nconst updatedUser = {\n  ...user,\n  profile: {\n    ...user.profile,\n    preferences: {\n      ...user.profile.preferences,\n      notifications: false\n    }\n  }\n};\n\nconsole.log(user.profile.preferences.notifications);        // true\nconsole.log(updatedUser.profile.preferences.notifications); // false\nconsole.log(user === updatedUser);                          // false\nconsole.log(user.profile === updatedUser.profile);          // false\nconsole.log(user.profile.preferences === updatedUser.profile.preferences); // false",
              "explanation": "To achieve true deep immutability when updating nested properties, you must immutably copy *each level* of the nested structure that is being modified. This involves spreading the outer object, then spreading the nested object, and so on, until you reach the property you want to change.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_immutability_1",
            "question_immutability_2",
            "question_immutability_3",
            "question_immutability_4",
            "question_immutability_5",
            "question_immutability_6"
          ],
          "relatedTasks": [
            "task_immutable_state_management"
          ],
          "tags": [
            "immutability",
            "javascript",
            "data-structures",
            "functional-programming",
            "react",
            "state-management"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "spread_syntax",
            "object_assign"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_redux",
            "frontend_architecture",
            "pure_functions"
          ]
        },
        {
          "id": "theory_array_creation_methods",
          "title": "JavaScript Array Creation Methods",
          "content": "## Introduction to Arrays\nArrays are list-like objects whose prototype has methods to perform traversal and mutation operations. In JavaScript, arrays are resizable and can contain a mix of different data types.\n\n## Methods for Array Creation\nJavaScript provides several ways to create arrays, each with its specific use cases and nuances.\n\n### 1. Array Literal\nThis is the most common and generally preferred way to create an array. It's concise and readable.\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst mixed = [1, 'hello', true, null];\nconst empty = [];\n```\n\n### 2. Array Constructor (`new Array()`)\nThe `Array` constructor behaves differently depending on the number and type of arguments passed to it:\n-   **With a single number argument (`new Array(length)`):** Creates a new array with the specified `length`. The elements are empty slots, not `undefined`. This creates a *sparse array*, which can sometimes lead to unexpected behavior with array methods.\n-   **With multiple arguments (`new Array(element0, element1, ..., elementN)`):** Creates a new array and initializes it with the provided arguments as elements.\n\n```javascript\nconst arrayWithLength = new Array(5); // Creates [empty x 5]\nconsole.log(arrayWithLength.length); // 5\nconsole.log(arrayWithLength[0]);   // undefined\n\nconst arrayWithElements = new Array(1, 2, 3, 4, 5); // Creates [1, 2, 3, 4, 5]\nconst singleElementArray = new Array(\"hello\"); // Creates [\"hello\"]\n```\n\n### 3. `Array.from()`\n`Array.from()` creates a new, shallow-copied `Array` instance from an array-like or iterable object. This method is incredibly versatile for transforming data sources into arrays.\n\n**Use Cases:**\n-   **From Array-like objects:** Objects with a `length` property and indexed elements (e.g., `arguments` object, `NodeList` from `document.querySelectorAll()`).\n-   **From Iterables:** Objects whose elements can be iterated over (e.g., `String`, `Set`, `Map`).\n-   **With a `mapFn`:** An optional second argument that allows you to map each element of the source to a new value in the new array, similar to `Array.prototype.map()`.\n-   **Creating a sequence:** Can be combined with `Array(length)` to create an array for numerical sequences.\n\n```javascript\nconst arrayFromString = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']\nconst arrayFromSet = Array.from(new Set([1, 2, 3, 2, 1])); // [1, 2, 3]\nconst arrayFromNodeList = Array.from(document.querySelectorAll('div')); // Converts NodeList to Array\n\n// With a map function\nconst arrayWithMap = Array.from([1, 2, 3], x => x * 2); // [2, 4, 6]\n\n// Creating a sequence of numbers from 0 to 4\nconst sequence = Array.from({length: 5}, (_, i) => i); // [0, 1, 2, 3, 4]\n```\n\n### 4. `Array.of()`\n`Array.of()` creates a new `Array` instance from a variable number of arguments, regardless of the number or type of the arguments. This method is primarily useful for overcoming the inconsistent behavior of the `Array` constructor when a single numeric argument is passed.\n\n```javascript\nconst arrayOf = Array.of(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\nconst singleItemArray = Array.of(5);     // [5] (consistent, unlike new Array(5))\nconst mixedItemsArray = Array.of('a', 1, true); // ['a', 1, true]\n```\n\n## Summary of Key Differences\n-   `new Array(length)` creates a sparse array with `length` empty slots.\n-   `Array.of(element)` creates an array containing `element`.\n-   `Array.from()` is best for converting array-like or iterable objects into true arrays, and for transforming elements during creation.",
          "examples": [
            {
              "id": "example_array_creation_1",
              "title": "Comparing Array Constructor Behaviors",
              "code": "const arr1 = new Array(3);       // Creates [empty x 3]\nconsole.log(arr1);               // [ <3 empty items> ]\nconsole.log(arr1.length);        // 3\nconsole.log(arr1[0]);            // undefined\n\nconst arr2 = new Array(1, 2, 3); // Creates [1, 2, 3]\nconsole.log(arr2);               // [1, 2, 3]\nconsole.log(arr2.length);        // 3\n\nconst arr3 = Array.of(3);        // Creates [3]\nconsole.log(arr3);               // [3]\nconsole.log(arr3.length);        // 1\n\nconst arr4 = Array.of(1, 2, 3);  // Creates [1, 2, 3]\nconsole.log(arr4);               // [1, 2, 3]",
              "explanation": "This example highlights the crucial difference between `new Array(singleNumber)` and `Array.of(singleNumber)`. The former creates an array with that many empty slots (a sparse array), while the latter creates an array containing that number as its single element. `Array.of` provides consistent behavior regardless of the number of arguments, making it safer for dynamic array creation than the `Array` constructor alone.",
              "language": "javascript"
            },
            {
              "id": "example_array_creation_2",
              "title": "Using Array.from() for Transformations and Iterables",
              "code": "// 1. Convert a string to an array of characters\nconst characters = Array.from('JavaScript');\nconsole.log(characters); // ['J', 'a', 'v', 'a', 'S', 'c', 'r', 'i', 'p', 't']\n\n// 2. Create an array from a Set (unique values)\nconst uniqueNumbers = Array.from(new Set([10, 20, 10, 30, 20]));\nconsole.log(uniqueNumbers); // [10, 20, 30]\n\n// 3. Generate a sequence of squares using a map function\nconst squares = Array.from({length: 5}, (_, index) => index * index);\nconsole.log(squares); // [0, 1, 4, 9, 16]\n\n// 4. Convert NodeList to Array (useful for DOM manipulation)\n// Assume some HTML: <div class=\"item\">1</div><div class=\"item\">2</div>\n// const divs = Array.from(document.querySelectorAll('.item'));\n// console.log(divs.map(div => div.textContent)); // ['1', '2']",
              "explanation": "`Array.from()` is highly flexible. It can convert any iterable (like strings or Sets) into a new array. The optional mapping function allows for immediate transformation of elements during the array creation process, which is very efficient for generating sequences or derived data.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_array_creation_1",
            "question_array_creation_2",
            "question_array_creation_3",
            "question_array_creation_4",
            "question_array_creation_5"
          ],
          "relatedTasks": [
            "task_array_utility_generator"
          ],
          "tags": [
            "arrays",
            "javascript",
            "es6",
            "data-structures",
            "array-methods"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "iterables",
            "array_literals"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_manipulation",
            "functional_programming_js"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_composition_1",
          "topic": "Object Composition Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between object composition and classical inheritance in terms of object relationships?",
          "answer": "Object composition emphasizes 'has-a' relationships, while classical inheritance emphasizes 'is-a' relationships.",
          "options": [],
          "analysisPoints": [
            "Distinguish between 'has-a' and 'is-a' relationships.",
            "Understand the fundamental principle of composition (building objects from parts) versus inheritance (deriving objects from a parent)."
          ],
          "keyConcepts": [
            "Object Composition",
            "Classical Inheritance",
            "Has-a relationship",
            "Is-a relationship"
          ],
          "evaluationCriteria": [
            "Ability to define core concepts",
            "Understanding of fundamental design principles"
          ],
          "example": "",
          "tags": [
            "composition",
            "inheritance",
            "oop",
            "design-patterns"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_composition_2",
          "topic": "Benefits of Object Composition",
          "level": "medium",
          "type": "open",
          "question": "List at least three benefits of using object composition over classical inheritance in JavaScript. Provide a brief explanation for each.",
          "answer": "1.  **Flexibility:** Composition allows objects to dynamically acquire or lose behaviors by combining different mixins, without being tied to a fixed inheritance hierarchy. This makes it easier to add new capabilities or modify existing ones.\n2.  **Reusability:** Individual behaviors (mixins) are self-contained and can be reused across diverse objects, regardless of their type or class, promoting modularity.\n3.  **Avoids the 'Diamond Problem' / Multiple Inheritance Issues:** JavaScript's single inheritance model inherently avoids the diamond problem, but composition provides a cleaner way to achieve similar functionality without the complexity and ambiguity that can arise in languages supporting multiple inheritance.\n4.  **Reduced Coupling:** Objects are composed of loosely coupled behaviors rather than being tightly bound to a parent class's implementation details, making systems easier to maintain and test.",
          "options": [],
          "analysisPoints": [
            "Ability to articulate core benefits of composition.",
            "Understanding of common pitfalls of inheritance.",
            "Capacity to explain concepts clearly and concisely."
          ],
          "keyConcepts": [
            "Object Composition",
            "Inheritance",
            "Design Patterns",
            "Modularity",
            "Reusability",
            "Flexibility"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of benefits",
            "Clarity and accuracy of reasoning"
          ],
          "example": "",
          "tags": [
            "composition",
            "oop",
            "design-patterns",
            "benefits"
          ],
          "prerequisites": [
            "object_composition_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_composition_3",
          "topic": "Object Composition Implementation",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following JavaScript code, what will be the output of `console.log(dog.energy);` after the `dog.eat('kibble');` and `dog.sleep(5);` calls?\n\n```javascript\nconst canEat = (state) => ({\n  eat: (food) => {\n    console.log(`${state.name} is eating ${food}`);\n    state.energy += 10;\n  },\n});\n\nconst canSleep = (state) => ({\n  sleep: (hours) => {\n    console.log(`${state.name} is sleeping for ${hours} hours`);\n    state.energy += hours * 5;\n  },\n});\n\nfunction createDog(name) {\n  const state = {\n    name,\n    energy: 100\n  };\n  return {\n    ...state,\n    ...canEat(state),\n    ...canSleep(state)\n  };\n}\n\nconst dog = createDog(\"Buddy\");\ndog.eat('kibble');\ndog.sleep(5);\n```",
          "answer": "135",
          "options": [
            "100",
            "110",
            "135",
            "160"
          ],
          "analysisPoints": [
            "Understand how state is shared and modified by mixins.",
            "Perform arithmetic calculations based on method calls.",
            "Trace the execution flow of composed objects."
          ],
          "keyConcepts": [
            "Object Composition",
            "State Management",
            "Side Effects",
            "Function Execution"
          ],
          "evaluationCriteria": [
            "Accuracy in tracing state changes",
            "Understanding of shared state in composition"
          ],
          "example": "Initial energy: 100\nAfter `dog.eat('kibble')`: `state.energy` becomes `100 + 10 = 110`.\nAfter `dog.sleep(5)`: `state.energy` becomes `110 + (5 * 5) = 110 + 25 = 135`.",
          "tags": [
            "composition",
            "javascript",
            "state",
            "mcq"
          ],
          "prerequisites": [
            "object_composition_implementation"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_composition_4",
          "topic": "Object Composition vs. Class Inheritance",
          "level": "hard",
          "type": "open",
          "question": "In the context of frontend development (e.g., React components or general utility libraries), discuss a scenario where object composition would be significantly more advantageous than class-based inheritance, and explain why. How might you implement a common behavior, like 'logging', using composition?",
          "answer": "A compelling scenario where object composition shines over class-based inheritance is when building reusable UI components or utility functions with varying combinations of features. Consider a component that needs to be 'draggable' and 'resizable'. If you used inheritance, you'd likely end up with complex hierarchies like `DraggableComponent extends BaseComponent` and `ResizableComponent extends BaseComponent`, and then struggle with a `DraggableAndResizableComponent` (the diamond problem or needing multiple inheritance, which JS classes don't support directly).\n\nWith composition, you can create simple 'mixin' functions:\n\n```javascript\nconst withDraggable = (component) => ({ ...component, drag: () => console.log('Dragging...') });\nconst withResizable = (component) => ({ ...component, resize: () => console.log('Resizing...') });\n\n// Create a component that's only draggable\nconst DraggableButton = withDraggable({ type: 'button', text: 'Click Me' });\nDraggableButton.drag();\n\n// Create a component that's draggable and resizable\nconst DraggableResizablePanel = withDraggable(withResizable({ type: 'panel', id: 'mainPanel' }));\nDraggableResizablePanel.drag();\nDraggableResizablePanel.resize();\n```\n\n**Why it's advantageous:**\n*   **Flexibility:** Easily mix and match behaviors without creating an explosion of classes or rigid hierarchies. A component can be draggable, or resizable, or both, or neither, by simply adding/omitting the appropriate composer functions.\n*   **No deep inheritance:** Avoids the 'fragile base class' problem where changes in a deeply inherited parent can unintentionally break child classes.\n*   **Clearer responsibilities:** Each mixin focuses on a single responsibility (e.g., `draggable`, `resizable`), leading to more modular and understandable code.\n\n**Implementing 'logging' using composition:**\n\n```javascript\nconst withLogging = (target) => ({ // target could be an object or a function\n  ...target,\n  log: (message) => console.log(`[LOG]: ${message}`),\n  logError: (message) => console.error(`[ERROR]: ${message}`)\n});\n\n// Example 1: Composing with an existing object\nconst myService = {\n  getData: () => 'some data'\n};\nconst loggedService = withLogging(myService);\nloggedService.log('Data fetched');\nconsole.log(loggedService.getData());\n\n// Example 2: Composing with a component (similar to the earlier UI example)\nconst MyComponent = { name: 'DashboardComponent' };\nconst LoggedComponent = withLogging(MyComponent);\nLoggedComponent.log(`Component ${LoggedComponent.name} mounted.`);\n```\nThis `withLogging` mixin can be easily added to any object or component, providing logging capabilities without modifying its original structure or forcing it into an inheritance hierarchy.",
          "options": [],
          "analysisPoints": [
            "Ability to identify appropriate use cases for composition.",
            "Understanding of the limitations of classical inheritance (e.g., diamond problem, fragile base class).",
            "Demonstrates practical application of composition with a concrete example.",
            "Explains the 'why' behind the advantage."
          ],
          "keyConcepts": [
            "Object Composition",
            "Design Patterns",
            "Frontend Architecture",
            "Reusability",
            "Modularity",
            "Inheritance Limitations"
          ],
          "evaluationCriteria": [
            "Depth of analysis",
            "Relevance of scenario",
            "Clarity of explanation and code example"
          ],
          "example": "",
          "tags": [
            "composition",
            "inheritance",
            "design-patterns",
            "frontend",
            "architecture"
          ],
          "prerequisites": [
            "object_composition_advanced",
            "design_patterns"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_composition_5",
          "topic": "Composition vs. Inheritance",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following class-based inheritance code to use object composition instead. Ensure the `superpower` and `greeting` methods work as expected.\n\n```javascript\nclass Character {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greeting() {\n    return `Hello, I'm ${this.name}.`;\n  }\n}\n\nclass Superhero extends Character {\n  constructor(name, power) {\n    super(name);\n    this.superpower = power;\n  }\n\n  activatePower() {\n    return `${this.name} activates ${this.superpower}!`;\n  }\n}\n\nconst superman = new Superhero('Superman', 'Flight');\nconsole.log(superman.greeting());\nconsole.log(superman.activatePower());\n```",
          "answer": "```javascript\nconst withName = (state) => ({\n  ...state,\n  greeting: () => `Hello, I'm ${state.name}.`\n});\n\nconst withSuperpower = (state) => ({\n  ...state,\n  activatePower: () => `${state.name} activates ${state.superpower}!`\n});\n\nfunction createCharacter(name) {\n  const state = { name };\n  return withName(state);\n}\n\nfunction createSuperhero(name, superpower) {\n  const state = { name, superpower };\n  return {\n    ...withName(state),\n    ...withSuperpower(state)\n  };\n}\n\nconst superman = createSuperhero('Superman', 'Flight');\nconsole.log(superman.greeting());\nconsole.log(superman.activatePower());\n```",
          "options": [],
          "analysisPoints": [
            "Ability to convert class-based inheritance to functional composition.",
            "Correctly identify and separate concerns into composable functions.",
            "Properly manage shared state (if any) between composed parts.",
            "Ensure equivalent functionality is maintained."
          ],
          "keyConcepts": [
            "Object Composition",
            "Inheritance",
            "Refactoring",
            "Factory Functions",
            "Mixins"
          ],
          "evaluationCriteria": [
            "Correct refactoring",
            "Adherence to composition principles",
            "Functional equivalence"
          ],
          "example": "",
          "tags": [
            "composition",
            "inheritance",
            "refactoring",
            "code-challenge"
          ],
          "prerequisites": [
            "object_composition_implementation"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_composition_6",
          "topic": "Object Composition and State Encapsulation",
          "level": "medium",
          "type": "flashcard",
          "question": "In the provided composition example (`createBird`), the `state` object is spread directly (`...state`). What is a potential drawback of this approach regarding encapsulation, and how could it be improved for better encapsulation?",
          "answer": "Potential drawback: Spreading `state` directly exposes all internal state properties (`name`, `energy`) to the outside world, making them directly accessible and mutable. This breaks encapsulation, as external code can directly change the object's internal state without going through defined methods.\n\nImprovement: Instead of spreading `state`, only expose methods and controlled getters/setters in the returned object. The `state` itself would be closed over within the factory function's scope, or accessed only via the mixin functions.",
          "options": [],
          "analysisPoints": [
            "Identify potential encapsulation issues in composition patterns.",
            "Suggest solutions for better encapsulation.",
            "Understand the difference between exposing raw state and controlled access via methods."
          ],
          "keyConcepts": [
            "Object Composition",
            "Encapsulation",
            "State Management",
            "Information Hiding"
          ],
          "evaluationCriteria": [
            "Identification of problem",
            "Provision of valid solution",
            "Understanding of encapsulation"
          ],
          "example": "```javascript\n// Improved createBird for better encapsulation\nfunction createBirdEncapsulated(name) {\n  let energy = 100; // State variable is now private (closed over)\n  const birdName = name; // Also private\n\n  const getEnergy = () => ({ getEnergy: () => energy });\n  const canEat = () => ({\n    eat: (food) => {\n      console.log(`${birdName} is eating ${food}`);\n      energy += 10; \n    },\n  });\n  const canFly = () => ({\n    fly: (distance) => {\n      if (energy >= distance * 2) {\n        console.log(`${birdName} is flying ${distance} meters`);\n        energy -= distance * 2;\n      } else {\n        console.log(`${birdName} is too tired to fly`);\n      }\n    },\n  });\n\n  return { // Only expose methods, not raw state\n    name: birdName, // A getter for name is okay, or make a getName() method\n    ...canEat(), // Mixins no longer need to take state as arg if state is closed over\n    ...canFly(),\n    ...getEnergy() // Expose a getter if energy needs to be read externally\n  };\n}\n\nconst sparrowEnc = createBirdEncapsulated(\"Sparrow\");\nsparrowEnc.eat(\"seeds\");\nsparrowEnc.fly(20);\n// console.log(sparrowEnc.energy); // undefined - 'energy' is not exposed directly\nconsole.log(sparrowEnc.getEnergy()); // Access energy via getter\n```",
          "tags": [
            "composition",
            "encapsulation",
            "state-management",
            "private-data"
          ],
          "prerequisites": [
            "object_composition_implementation",
            "closures"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutability_1",
          "topic": "Immutability Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What does it mean for an object or data structure to be 'immutable'?",
          "answer": "An immutable object/data structure cannot be modified after it is created. Any operation that appears to modify it will instead return a new object with the desired changes, leaving the original unchanged.",
          "options": [],
          "analysisPoints": [
            "Core definition of immutability.",
            "Understanding that 'modification' results in a new object."
          ],
          "keyConcepts": [
            "Immutability",
            "Data Structures",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Accuracy of definition"
          ],
          "example": "",
          "tags": [
            "immutability",
            "basics"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutability_2",
          "topic": "Benefits of Immutability",
          "level": "medium",
          "type": "open",
          "question": "Explain at least two key benefits of using immutable data structures in frontend development, especially in frameworks like React. Provide a brief example for one of them.",
          "answer": "1.  **Predictability and Easier Debugging:** Immutable data makes your application's state more predictable because data cannot change unexpectedly in different parts of your codebase. This significantly reduces side effects and makes debugging easier, as you can trust that a piece of data will remain the same unless you explicitly create a new version.\n\n2.  **Simplified Change Detection & Performance Optimization:** In UI frameworks like React, immutability greatly simplifies detecting when state has changed. Instead of performing deep comparisons (which can be expensive), you can simply compare references. If `oldObject !== newObject`, then a change has occurred, and the component might need to re-render. This is fundamental to optimizing renders using `React.memo` or `shouldComponentUpdate`.\n    \n    *Example for Change Detection:*\n    ```javascript\n    // With mutable state:\n    const arr1 = [1, 2, 3];\n    const arr2 = arr1;\n    arr2.push(4);\n    console.log(arr1 === arr2); // true (same reference, but content changed)\n    \n    // With immutable state:\n    const arr3 = [1, 2, 3];\n    const arr4 = [...arr3, 4]; // Creates a new array\n    console.log(arr3 === arr4); // false (different reference, reflects change)\n    // React can efficiently detect that arr3 and arr4 are different, triggering a re-render if needed.\n    ```\n\n3.  **Easier Undo/Redo Functionality:** Since each 'modification' creates a new version of the state, it's straightforward to keep a history of states. Implementing undo/redo simply involves navigating back and forth through this history of immutable state snapshots.",
          "options": [],
          "analysisPoints": [
            "Ability to articulate the practical advantages of immutability.",
            "Connection between immutability and performance/debugging.",
            "Provision of a clear, relevant example."
          ],
          "keyConcepts": [
            "Immutability",
            "State Management",
            "React",
            "Performance Optimization",
            "Debugging",
            "Change Detection"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation",
            "Accurate examples",
            "Understanding of practical applications"
          ],
          "example": "",
          "tags": [
            "immutability",
            "react",
            "state-management",
            "performance"
          ],
          "prerequisites": [
            "immutability_definition"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutability_3",
          "topic": "Immutable Object Patterns - Shallow vs. Deep Copy",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n\n```javascript\nconst userProfile = {\n  id: 1,\n  name: 'Jane Doe',\n  settings: {\n    theme: 'light',\n    notifications: true\n  }\n};\n\nconst updatedProfile = {\n  ...userProfile,\n  settings: {\n    ...userProfile.settings,\n    theme: 'dark' // This is the only change intended\n  }\n};\n\nupdatedProfile.settings.notifications = false; // A. What happens here?\n```\n\nAfter executing line A, what will be the value of `userProfile.settings.notifications`?",
          "answer": "true",
          "options": [
            "true",
            "false",
            "undefined",
            "It will throw an error"
          ],
          "analysisPoints": [
            "Understand deep immutability with spread operator.",
            "Recognize that nested objects must also be immutably copied.",
            "Trace the reference changes due to nested spreading."
          ],
          "keyConcepts": [
            "Immutability",
            "Spread Syntax",
            "Shallow Copy",
            "Deep Copy",
            "Nested Objects"
          ],
          "evaluationCriteria": [
            "Correctly identifies the state of the original object after a nested immutable update and subsequent mutable operation."
          ],
          "example": "In the provided code, `updatedProfile` is created by spreading `userProfile` and then creating a *new* `settings` object by spreading `userProfile.settings` and applying the `theme` change. This means `updatedProfile.settings` is a completely new object, distinct from `userProfile.settings`.\n\nTherefore, when `updatedProfile.settings.notifications = false;` is executed, it modifies the `notifications` property *on the new `updatedProfile.settings` object*, leaving the original `userProfile.settings.notifications` property untouched at `true`.",
          "tags": [
            "immutability",
            "spread-syntax",
            "shallow-copy",
            "deep-copy",
            "mcq"
          ],
          "prerequisites": [
            "immutable_object_patterns"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutability_4",
          "topic": "Immutable Object Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Name two common JavaScript methods or operators used to create new objects immutably from existing ones.",
          "answer": "1. `Object.assign()`\n2. The spread syntax (`...`)",
          "options": [],
          "analysisPoints": [
            "Recall common immutability patterns.",
            "Understand their basic usage."
          ],
          "keyConcepts": [
            "Immutability",
            "Object.assign",
            "Spread Syntax"
          ],
          "evaluationCriteria": [
            "Ability to recall common methods"
          ],
          "example": "",
          "tags": [
            "immutability",
            "javascript-methods"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutability_5",
          "topic": "Deep Cloning for Immutability",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where `Object.assign()` or the spread operator would be insufficient for achieving complete immutability, and suggest an alternative solution in modern JavaScript. What are the limitations of that alternative?",
          "answer": "Scenario: `Object.assign()` and the spread operator (`...`) both perform a *shallow copy*. This means that while the top-level properties are copied into a new object, any nested objects or arrays within the original object are still copied by reference. If a nested object or array is modified through the new copy, the original object's nested structure will also be mutated.\n\nExample:\n```javascript\nconst data = { a: 1, b: { c: 2 } };\nconst shallowCopy = { ...data };\nshallowCopy.b.c = 3; // Mutates original data.b.c as well\nconsole.log(data.b.c); // 3\n```\n\nAlternative Solution in Modern JavaScript: `structuredClone()` (ECMAScript 2021)\n\n`structuredClone()` performs a deep copy of a given value. It can handle various data types, including nested objects, arrays, `Map`, `Set`, `Date`, `RegExp`, `ArrayBuffer`, and more, without retaining references to the original objects.\n\n```javascript\nconst data = { a: 1, b: { c: 2 }, d: new Date() };\nconst deepCopy = structuredClone(data);\ndeepCopy.b.c = 3;\nconsole.log(data.b.c); // 2 (Original is preserved)\nconsole.log(data.d === deepCopy.d); // false (Date object also deeply copied)\n```\n\nLimitations of `structuredClone()`:\n1.  **Browser/Environment Support:** While widely supported, it's newer (ES2021) and might not be available in very old environments or specific Node.js versions without polyfills.\n2.  **Cannot clone functions:** Functions, `Error` objects, `DOM` nodes, and some other native types cannot be cloned by `structuredClone()`. It will throw an error if it encounters them.\n3.  **Circular References:** It can handle circular references, but for very complex data structures, it might still have performance implications.",
          "options": [],
          "analysisPoints": [
            "Identifies the shallow copy limitation of common immutability patterns.",
            "Proposes `structuredClone()` as a modern deep cloning solution.",
            "Discusses the limitations and use cases of `structuredClone()`.",
            "Demonstrates understanding of deep vs. shallow immutability."
          ],
          "keyConcepts": [
            "Immutability",
            "Shallow Copy",
            "Deep Copy",
            "structuredClone",
            "Object.assign",
            "Spread Syntax"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation for shallow copy limitations",
            "Correctness of alternative solution",
            "Thoroughness of limitations discussion"
          ],
          "example": "",
          "tags": [
            "immutability",
            "deep-copy",
            "structured-clone",
            "javascript"
          ],
          "prerequisites": [
            "immutable_object_patterns"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutability_6",
          "topic": "Immutability and Performance",
          "level": "hard",
          "type": "code",
          "question": "You are given a `userList` (an array of objects) and a function `updateUserStatus` that needs to change a user's `isActive` status. Implement `updateUserStatus` such that it updates the `userList` immutably, ensuring that no original objects (neither the array nor any user object within it) are mutated.\n\n```javascript\nconst userList = [\n  { id: 1, name: 'Alice', isActive: true },\n  { id: 2, name: 'Bob', isActive: false },\n  { id: 3, name: 'Charlie', isActive: true },\n];\n\n/**\n * Updates the 'isActive' status of a user in the userList immutably.\n * @param {Array<Object>} users - The original array of user objects.\n * @param {number} userId - The ID of the user to update.\n * @param {boolean} newStatus - The new isActive status.\n * @returns {Array<Object>} A new array with the updated user object, or the original array if user not found.\n */\nfunction updateUserStatus(users, userId, newStatus) {\n  // Your implementation here\n}\n\n// Test Cases:\n// const updatedList1 = updateUserStatus(userList, 2, true);\n// console.log(userList[1].isActive);       // Expected: false (original unchanged)\n// console.log(updatedList1[1].isActive);    // Expected: true (new list updated)\n// console.log(userList === updatedList1); // Expected: false (new array created)\n// console.log(userList[0] === updatedList1[0]); // Expected: true (unaffected objects same reference)\n\n// const updatedList2 = updateUserStatus(userList, 99, true); // User not found\n// console.log(updatedList2 === userList); // Expected: true (original array returned)\n```",
          "answer": "```javascript\nconst userList = [\n  { id: 1, name: 'Alice', isActive: true },\n  { id: 2, name: 'Bob', isActive: false },\n  { id: 3, name: 'Charlie', isActive: true },\n];\n\n/**\n * Updates the 'isActive' status of a user in the userList immutably.\n * @param {Array<Object>} users - The original array of user objects.\n * @param {number} userId - The ID of the user to update.\n * @param {boolean} newStatus - The new isActive status.\n * @returns {Array<Object>} A new array with the updated user object, or the original array if user not found.\n */\nfunction updateUserStatus(users, userId, newStatus) {\n  const userIndex = users.findIndex(user => user.id === userId);\n\n  if (userIndex === -1) {\n    return users; // User not found, return original array (immutably)\n  }\n\n  // Create a new user object with updated status (immutably)\n  const updatedUser = {\n    ...users[userIndex],\n    isActive: newStatus,\n  };\n\n  // Create a new array with the updated user at the correct index (immutably)\n  return [\n    ...users.slice(0, userIndex),\n    updatedUser,\n    ...users.slice(userIndex + 1),\n  ];\n}\n\n// Test Cases:\nconst updatedList1 = updateUserStatus(userList, 2, true);\nconsole.log(\"Original list user 2 active (should be false):\", userList[1].isActive);       // Expected: false (original unchanged)\nconsole.log(\"Updated list user 2 active (should be true):\", updatedList1[1].isActive);    // Expected: true (new list updated)\nconsole.log(\"Original array reference === new array reference (should be false):\", userList === updatedList1); // Expected: false (new array created)\nconsole.log(\"Unaffected user 1 object reference === new list user 1 object reference (should be true):\", userList[0] === updatedList1[0]); // Expected: true (unaffected objects share reference for performance)\nconsole.log(\"Unaffected user 3 object reference === new list user 3 object reference (should be true):\", userList[2] === updatedList1[2]); // Expected: true\n\nconst updatedList2 = updateUserStatus(userList, 99, true); // User not found\nconsole.log(\"User not found, array reference === original array reference (should be true):\", updatedList2 === userList); // Expected: true (original array returned)\n",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the user to update.",
            "Creates a new user object for the updated user using spread syntax to maintain immutability of individual objects.",
            "Creates a new array by slicing and spreading the original array segments and inserting the new user object, ensuring array immutability.",
            "Handles the edge case where the user is not found by returning the original array reference.",
            "Understands that unaffected objects can retain their original references for performance."
          ],
          "keyConcepts": [
            "Immutability",
            "Array Methods",
            "Spread Syntax",
            "Object Update",
            "Functional Programming"
          ],
          "evaluationCriteria": [
            "Correctly implements immutable array and object updates",
            "Handles edge cases gracefully",
            "Efficiency of solution (avoiding unnecessary deep copies of unchanged elements)"
          ],
          "example": "",
          "tags": [
            "immutability",
            "arrays",
            "javascript",
            "code-challenge",
            "state-management"
          ],
          "prerequisites": [
            "immutable_object_patterns",
            "array_methods",
            "spread_syntax"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_creation_1",
          "topic": "Array Creation Methods",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following JavaScript code snippets will create an array `[5]` (an array containing the single number 5) and NOT an array of 5 empty slots?",
          "answer": "Array.of(5)",
          "options": [
            "new Array(5)",
            "Array.of(5)",
            "Array.from({ length: 5 })",
            "const arr = []; arr.length = 5;"
          ],
          "analysisPoints": [
            "Distinguish between `new Array(length)` and `Array.of()`.",
            "Understand how different array creation methods handle single numeric arguments.",
            "Recognize sparse array creation."
          ],
          "keyConcepts": [
            "Array.of",
            "Array Constructor",
            "Sparse Arrays",
            "Array Creation"
          ],
          "evaluationCriteria": [
            "Correctly identifies array creation method for specific outcome."
          ],
          "example": "`new Array(5)` creates `[empty x 5]`. `Array.from({ length: 5 })` creates `[undefined, undefined, undefined, undefined, undefined]`. `const arr = []; arr.length = 5;` creates a sparse array `[empty x 5]`. Only `Array.of(5)` explicitly creates an array `[5]` containing the number 5 as its sole element.",
          "tags": [
            "arrays",
            "array-methods",
            "mcq"
          ],
          "prerequisites": [
            "array_creation_methods"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_creation_2",
          "topic": "Array.from() Use Cases",
          "level": "medium",
          "type": "open",
          "question": "Describe two distinct use cases for `Array.from()` in JavaScript, providing a concise code example for each.",
          "answer": "1.  **Converting Array-like Objects/Iterables to True Arrays:**\n    `Array.from()` is commonly used to convert objects that resemble arrays (like `NodeList` returned by `document.querySelectorAll()`, or the `arguments` object in functions) or other iterable objects (like `Set`, `Map`, `String`) into actual `Array` instances, allowing them to use `Array.prototype` methods (e.g., `map`, `filter`).\n    \n    *Example: Converting a string to an array of characters:*\n    ```javascript\n    const str = 'world';\n    const chars = Array.from(str); // ['w', 'o', 'r', 'l', 'd']\n    console.log(chars.map(char => char.toUpperCase())); // ['W', 'O', 'R', 'L', 'D']\n    ```\n\n2.  **Generating Arrays with Mapped Values (Sequences/Transformations):**\n    The second argument of `Array.from()` is an optional `mapFn` function, which allows you to transform each element of the new array during its creation. This is particularly useful for generating sequences of numbers or creating arrays based on a specific logic.\n    \n    *Example: Creating an array of squared numbers:*\n    ```javascript\n    const squaredNumbers = Array.from({ length: 5 }, (_, index) => index * index);\n    // The first argument { length: 5 } creates an array-like object with 5 empty slots.\n    // The map function then populates these slots with squares of their indices.\n    console.log(squaredNumbers); // [0, 1, 4, 9, 16]\n    ```",
          "options": [],
          "analysisPoints": [
            "Ability to articulate core use cases for `Array.from()`.",
            "Provide accurate and illustrative code examples.",
            "Explain the purpose and arguments of `Array.from()`."
          ],
          "keyConcepts": [
            "Array.from",
            "Iterables",
            "Array-like objects",
            "Map Function",
            "Array Generation"
          ],
          "evaluationCriteria": [
            "Correct identification of use cases",
            "Clear and accurate examples",
            "Concise explanations"
          ],
          "example": "",
          "tags": [
            "arrays",
            "array-methods",
            "javascript",
            "es6"
          ],
          "prerequisites": [
            "array_creation_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_creation_3",
          "topic": "Sparse Arrays",
          "level": "medium",
          "type": "flashcard",
          "question": "When might `new Array(length)` create a 'sparse array', and what is the characteristic behavior of a sparse array regarding its elements?",
          "answer": "`new Array(length)` creates a sparse array when a single numeric argument is passed (e.g., `new Array(5)`). A sparse array has 'empty slots' rather than actual `undefined` values for its elements. This means iteration methods like `forEach` or `map` might skip these empty slots, or they might be treated differently by various array methods compared to arrays explicitly filled with `undefined`.",
          "options": [],
          "analysisPoints": [
            "Understand the specific condition for creating a sparse array with `new Array()`.",
            "Know the nature of 'empty slots' versus `undefined` values.",
            "Recognize potential behavioral differences for sparse arrays."
          ],
          "keyConcepts": [
            "Sparse Arrays",
            "Array Constructor",
            "Array Behavior"
          ],
          "evaluationCriteria": [
            "Accuracy in defining sparse array creation",
            "Correctly describes sparse array characteristics"
          ],
          "example": "```javascript\nconst sparseArr = new Array(3); // [empty x 3]\nconsole.log(sparseArr); // Output depends on console, might show <3 empty items>\nconsole.log(sparseArr[0]); // undefined (accessing an empty slot yields undefined)\n\nsparseArr.forEach(item => console.log(item)); // This loop will not execute at all because there are no actual elements to iterate over.\n\nconst filledArr = Array.from({length: 3}, () => undefined); // [undefined, undefined, undefined]\nfilledArr.forEach(item => console.log(item)); // This loop will execute 3 times, logging 'undefined' each time.\n```",
          "tags": [
            "arrays",
            "sparse-arrays",
            "javascript-quirks"
          ],
          "prerequisites": [
            "array_creation_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_creation_4",
          "topic": "Converting Array-like to Array",
          "level": "medium",
          "type": "code",
          "question": "You have a `NodeList` obtained from `document.querySelectorAll('.item')`. Write a function `getDivContents` that takes this `NodeList` and returns an array of the `textContent` of each `div` element.\n\n```html\n<div class=\"item\">Apple</div>\n<div class=\"item\">Banana</div>\n<div class=\"item\">Cherry</div>\n```\n\n```javascript\n// Assume this NodeList is passed to your function\n// const nodeList = document.querySelectorAll('.item');\n\nfunction getDivContents(nodeList) {\n  // Implement this function\n}\n\n// Expected output: ['Apple', 'Banana', 'Cherry']\n// console.log(getDivContents(nodeList));\n```",
          "answer": "```javascript\nfunction getDivContents(nodeList) {\n  // Method 1: Using Array.from with a map function\n  return Array.from(nodeList, div => div.textContent);\n\n  // Method 2: Using Array.from without map, then Array.prototype.map\n  // return Array.from(nodeList).map(div => div.textContent);\n\n  // Method 3: Using spread syntax (most concise for simple cases)\n  // return [...nodeList].map(div => div.textContent);\n}\n\n// Example usage (mocking NodeList for demonstration without a browser DOM):\nconst mockNodeList = [\n  { textContent: 'Apple' },\n  { textContent: 'Banana' },\n  { textContent: 'Cherry' }\n];\n// Note: A real NodeList is iterable, so Array.from and spread work directly.\n// For a true NodeList, you'd execute: document.querySelectorAll('.item')\n\nconsole.log(getDivContents(mockNodeList)); // Expected: ['Apple', 'Banana', 'Cherry']\n```",
          "options": [],
          "analysisPoints": [
            "Ability to convert array-like objects (`NodeList`) to true arrays.",
            "Application of `Array.from()` or spread syntax for conversion.",
            "Correctly extracting `textContent` using `map`."
          ],
          "keyConcepts": [
            "Array.from",
            "NodeList",
            "DOM Manipulation",
            "Array Methods",
            "Spread Syntax"
          ],
          "evaluationCriteria": [
            "Correctly converts NodeList",
            "Extracts desired data",
            "Uses appropriate array creation/manipulation methods"
          ],
          "example": "",
          "tags": [
            "arrays",
            "dom",
            "array-methods",
            "code-challenge"
          ],
          "prerequisites": [
            "array_creation_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_creation_5",
          "topic": "Array.of() vs. new Array()",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main advantage of using `Array.of()` over `new Array()` for creating arrays, particularly when dealing with a single numeric argument?",
          "answer": "The main advantage of `Array.of()` is its consistent behavior: it always creates an array with its arguments as elements. `new Array()` has an inconsistent behavior when given a single numeric argument (it creates a sparse array of that length instead of an array containing that number as an element), which `Array.of()` avoids, making it safer and more predictable.",
          "options": [],
          "analysisPoints": [
            "Identify the primary difference in behavior.",
            "Understand the benefit of `Array.of()`'s consistency.",
            "Recognize the potential pitfalls of `new Array(number)`."
          ],
          "keyConcepts": [
            "Array.of",
            "Array Constructor",
            "Consistency",
            "Predictability"
          ],
          "evaluationCriteria": [
            "Clear articulation of the advantage",
            "Correctly identifies the behavioral difference"
          ],
          "example": "",
          "tags": [
            "arrays",
            "array-methods",
            "best-practices"
          ],
          "prerequisites": [
            "array_creation_methods"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_character_creation_composition",
          "title": "Build a Flexible RPG Character System with Object Composition",
          "description": "\nDesign and implement a system for creating RPG characters using **object composition**. Your system should allow for characters with varying sets of abilities without relying on class inheritance.\n\n**Requirements:**\n1.  **Core State:** Each character should have a `name`, `health` (starting at 100), and `attackPower` (starting at 10).\n2.  **Base Abilities (Mixins):**\n    *   `canAttack(state)`: Returns an object with an `attack` method. The `attack` method should take a `target` character and reduce their `health` by the attacker's `attackPower`.\n    *   `canTakeDamage(state)`: Returns an object with a `takeDamage` method that reduces the character's `health` by a given `amount`.\n    *   `canHeal(state)`: Returns an object with a `heal` method that increases the character's `health` by a given `amount`, up to a maximum of 100.\n3.  **Character Factories:**\n    *   `createWarrior(name)`: A character that `canAttack` and `canTakeDamage`.\n    *   `createHealer(name)`: A character that `canAttack` and `canHeal`.\n    *   `createTank(name)`: A character that `canAttack` and `canTakeDamage`. Tanks should have an initial `health` of 150 and `attackPower` of 5.\n4.  **Demonstrate Usage:** Create instances of each character type and simulate a small interaction (e.g., warrior attacks healer, healer heals self).\n5.  **Immutability (Optional but encouraged):** While the provided example mutates `state.energy`, for this task, consider how you might design mixins if you wanted to avoid direct state mutation (e.g., by returning new state objects, though for simplicity direct mutation of the internal state object is acceptable if clearly noted).\n",
          "difficulty": "medium",
          "startingCode": "const canAttack = (state) => ({\n  // Implement attack method\n});\n\nconst canTakeDamage = (state) => ({\n  // Implement takeDamage method\n});\n\nconst canHeal = (state) => ({\n  // Implement heal method\n});\n\nfunction createWarrior(name) {\n  const state = {\n    name,\n    health: 100,\n    attackPower: 10,\n  };\n  // Compose warrior abilities\n  return {}; // TODO: Implement composition\n}\n\nfunction createHealer(name) {\n  const state = {\n    name,\n    health: 100,\n    attackPower: 10,\n  };\n  // Compose healer abilities\n  return {}; // TODO: Implement composition\n}\n\nfunction createTank(name) {\n  const state = {\n    name,\n    health: 150, // Specific for Tank\n    attackPower: 5,  // Specific for Tank\n  };\n  // Compose tank abilities\n  return {}; // TODO: Implement composition\n}\n\n// Demonstrate usage:\n// const warrior = createWarrior(\"Arthur\");\n// const healer = createHealer(\"Elara\");\n// const tank = createTank(\"Grog\");\n\n// console.log(`${warrior.name} health: ${warrior.health}`);\n// console.log(`${healer.name} health: ${healer.health}`);\n// console.log(`${tank.name} health: ${tank.health}`);\n\n// warrior.attack(healer);\n// console.log(`${healer.name} health after attack: ${healer.health}`);\n\n// healer.heal(warrior);\n// console.log(`${warrior.name} health after heal: ${warrior.health}`);\n\n// tank.attack(warrior);\n// console.log(`${warrior.name} health after tank attack: ${warrior.health}`);\n",
          "solutionCode": "const canAttack = (state) => ({\n  attack: (target) => {\n    if (target && target.takeDamage) {\n      console.log(`${state.name} attacks ${target.name} for ${state.attackPower} damage.`);\n      target.takeDamage(state.attackPower);\n    } else {\n      console.log(`${state.name} cannot attack this target.`);\n    }\n  },\n});\n\nconst canTakeDamage = (state) => ({\n  takeDamage: (amount) => {\n    state.health = Math.max(0, state.health - amount);\n    console.log(`${state.name} takes ${amount} damage. Health: ${state.health}`);\n  },\n});\n\nconst canHeal = (state) => ({\n  heal: (target, amount) => {\n    if (target && target.health !== undefined) { \n      const oldHealth = target.health;\n      target.health = Math.min(100, target.health + amount);\n      console.log(`${state.name} heals ${target.name} for ${amount} health. Health: ${oldHealth} -> ${target.health}`);\n    } else {\n      console.log(`${state.name} cannot heal this target.`);\n    }\n  },\n});\n\nfunction createWarrior(name) {\n  const state = {\n    name,\n    health: 100,\n    attackPower: 10,\n  };\n  return {\n    ...state,\n    ...canAttack(state),\n    ...canTakeDamage(state),\n  };\n}\n\nfunction createHealer(name) {\n  const state = {\n    name,\n    health: 100,\n    attackPower: 10,\n  };\n  return {\n    ...state,\n    ...canAttack(state),\n    ...canHeal(state),\n  };\n}\n\nfunction createTank(name) {\n  const state = {\n    name,\n    health: 150, \n    attackPower: 5,  \n  };\n  return {\n    ...state,\n    ...canAttack(state),\n    ...canTakeDamage(state),\n  };\n}\n\n// Demonstrate usage:\nconst warrior = createWarrior(\"Arthur\");\nconst healer = createHealer(\"Elara\");\nconst tank = createTank(\"Grog\");\n\nconsole.log(`Initial healths: ${warrior.name}: ${warrior.health}, ${healer.name}: ${healer.health}, ${tank.name}: ${tank.health}`);\n\nwarrior.attack(healer); \nconsole.log(`${healer.name} health after attack: ${healer.health}`); \n\nhealer.heal(warrior, 15); \nconsole.log(`${warrior.name} health after heal: ${warrior.health}`); \n\nwarrior.attack(tank); \nconsole.log(`${tank.name} health after attack: ${tank.health}`); \n\ntank.attack(warrior); \nconsole.log(`${warrior.name} health after tank attack: ${warrior.health}`); \n\nhealer.heal(healer, 30); \nconsole.log(`${healer.name} health after self-heal: ${healer.health}`); \n",
          "testCases": [
            "Warrior attacks Healer: Healer's health should decrease by Warrior's attack power.",
            "Healer heals Warrior: Warrior's health should increase, capped at 100.",
            "Tank attacks Healer: Healer's health should decrease by Tank's attack power (5).",
            "Verify initial health and attack power for Tank.",
            "Test healing a character that does not have a 'health' property (should not error).",
            "Test healing beyond max health (should cap at 100)."
          ],
          "hints": [
            "Remember to pass the `state` object to each mixin function so they can access and modify `health`, `name`, and `attackPower`.",
            "Use `Math.max(0, ...)` for `takeDamage` to prevent health going below zero.",
            "Use `Math.min(100, ...)` for `heal` to cap health at 100.",
            "Ensure `attack` and `heal` methods check if the target has the necessary properties (e.g., `target.takeDamage` or `target.health`).",
            "For Tank, override the default `health` and `attackPower` in its `state` object before composing abilities."
          ],
          "tags": [
            "composition",
            "design-patterns",
            "oop",
            "javascript",
            "game-dev-basics"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "object_composition",
            "javascript_functions",
            "spread_syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "factory_functions",
            "mixins",
            "state_management"
          ]
        },
        {
          "id": "task_immutable_state_management",
          "title": "Implement an Immutable Configuration Manager",
          "description": "\nCreate a JavaScript `ConfigManager` that handles application settings immutably. The manager should allow reading, updating, and resetting configuration, always returning new state objects for modifications.\n\n**Requirements:**\n1.  **`createConfigManager(initialConfig)`:** A factory function that takes an `initialConfig` object and returns a config manager instance.\n2.  **`getConfig()`:** A method that returns the *current* configuration object. This should return a shallow copy to prevent external mutation.\n3.  **`updateConfig(newSettings)`:** A method that takes an object of new settings. It should return a **new `ConfigManager` instance** (or an object with the same methods) with the updated configuration. The original `ConfigManager` instance should remain unchanged. Use the spread operator or `Object.assign` for updates.\n4.  **`resetConfig()`:** A method that returns a **new `ConfigManager` instance** (or an object with the same methods) reset to its original `initialConfig`. The original `ConfigManager` instance should remain unchanged.\n5.  **Immutability Verification:** Ensure that after `updateConfig` or `resetConfig`:\n    *   The returned configuration object from the new manager is a *new object* (different reference from the previous one).\n    *   The original `ConfigManager`'s internal configuration remains untouched.\n    *   For nested objects within the config, ensure `updateConfig` handles them immutably as well (deep update only for the direct level of change, shallow for unchanged branches).\n",
          "difficulty": "medium",
          "startingCode": "function createConfigManager(initialConfig) {\n  let currentConfig = { ...initialConfig }; // Shallow copy of initial config\n\n  return {\n    getConfig() {\n      // TODO: Return current config immutably\n      return currentConfig;\n    },\n    updateConfig(newSettings) {\n      // TODO: Return a NEW ConfigManager instance with updated config\n      // Make sure to handle nested objects immutably if they are part of newSettings\n      return null; \n    },\n    resetConfig() {\n      // TODO: Return a NEW ConfigManager instance reset to initialConfig\n      return null; \n    },\n  };\n}\n\n// Example Usage & Tests:\n// const defaultSettings = {\n//   theme: 'dark',\n//   language: 'en',\n//   notifications: { email: true, sms: false }\n// };\n\n// let manager1 = createConfigManager(defaultSettings);\n// console.log('Manager 1 initial:', manager1.getConfig());\n\n// const config1 = manager1.getConfig();\n// config1.theme = 'light'; // Attempt to mutate directly\n// console.log('Manager 1 after direct mutation attempt:', manager1.getConfig().theme); // Should still be 'dark'\n\n// let manager2 = manager1.updateConfig({ theme: 'light', notifications: { email: false } });\n// console.log('Manager 2 theme:', manager2.getConfig().theme); // Expected: 'light'\n// console.log('Manager 2 email notifications:', manager2.getConfig().notifications.email); // Expected: false\n// console.log('Manager 1 theme (should be original):', manager1.getConfig().theme); // Expected: 'dark'\n// console.log('Manager 1 === Manager 2:', manager1 === manager2); // Expected: false\n// console.log('Manager 1 notifications === Manager 2 notifications (should be false due to update):', manager1.getConfig().notifications === manager2.getConfig().notifications);\n\n// let manager3 = manager2.resetConfig();\n// console.log('Manager 3 theme (should be default):', manager3.getConfig().theme); // Expected: 'dark'\n// console.log('Manager 3 === Manager 2:', manager3 === manager2); // Expected: false\n// console.log('Manager 3 === manager1:', manager3 === manager1); // Expected: false\n// console.log('Manager 3 notifications === defaultSettings notifications:', manager3.getConfig().notifications === defaultSettings.notifications); // Expected: false (new copy)\n",
          "solutionCode": "function createConfigManager(initialConfig) {\n  const deepClone = (obj) => {\n    try {\n      return structuredClone(obj);\n    } catch (e) {\n      return JSON.parse(JSON.stringify(obj)); \n    }\n  };\n\n  const privateInitialConfig = deepClone(initialConfig); \n  let currentConfig = deepClone(privateInitialConfig); \n\n  const createNewManager = (config) => createConfigManager(config);\n\n  return {\n    getConfig() {\n      return { ...currentConfig }; \n    },\n\n    updateConfig(newSettings) {\n      let updatedNotifications = currentConfig.notifications;\n      if (newSettings.notifications) {\n        updatedNotifications = { ...currentConfig.notifications, ...newSettings.notifications };\n      }\n      \n      const newMergedConfig = {\n        ...currentConfig,\n        ...newSettings,\n        ...(newSettings.notifications !== undefined ? { notifications: updatedNotifications } : {}),\n      };\n      \n      return createNewManager(newMergedConfig);\n    },\n\n    resetConfig() {\n      return createNewManager(privateInitialConfig);\n    },\n  };\n}\n\n// Example Usage & Tests:\nconst defaultSettings = {\n  theme: 'dark',\n  language: 'en',\n  notifications: { email: true, sms: false },\n  user: { id: 1, name: 'Guest' }\n};\n\nlet manager1 = createConfigManager(defaultSettings);\nconsole.log('Manager 1 initial:', manager1.getConfig());\n\nconst config1 = manager1.getConfig();\nconfig1.theme = 'light'; \nconsole.log('Manager 1 after direct mutation attempt (theme should be dark):', manager1.getConfig().theme); \n\nlet manager2 = manager1.updateConfig({ theme: 'light', language: 'fr' });\nconsole.log('Manager 2 theme:', manager2.getConfig().theme); \nconsole.log('Manager 2 language:', manager2.getConfig().language); \nconsole.log('Manager 1 theme (should be original):', manager1.getConfig().theme); \nconsole.log('Manager 1 === Manager 2 (should be false):', manager1 === manager2); \n\nlet manager3 = manager2.updateConfig({ notifications: { email: false, push: true } });\nconsole.log('Manager 3 email notifications:', manager3.getConfig().notifications.email); \nconsole.log('Manager 3 SMS notifications (should be original false):', manager3.getConfig().notifications.sms); \nconsole.log('Manager 3 Push notifications (new):', manager3.getConfig().notifications.push); \nconsole.log('Manager 2 notifications === Manager 3 notifications (should be false due to nested update):', manager2.getConfig().notifications === manager3.getConfig().notifications); \nconsole.log('Manager 2 user === Manager 3 user (should be true for unchanged nested object):', manager2.getConfig().user === manager3.getConfig().user); \n\nlet manager4 = manager3.resetConfig();\nconsole.log('Manager 4 theme (should be default):', manager4.getConfig().theme); \nconsole.log('Manager 4 === manager3 (should be false):', manager4 === manager3); \nconsole.log('Manager 4 notifications === defaultSettings notifications (should be false due to deep copy):', manager4.getConfig().notifications === defaultSettings.notifications); \nconsole.log('Manager 4 notifications email (should be default true):', manager4.getConfig().notifications.email); \n\nconsole.log('Manager 1 theme after all operations (should still be dark):', manager1.getConfig().theme); \nconsole.log('Manager 2 theme after all operations (should still be light):', manager2.getConfig().theme); \n",
          "testCases": [
            "`getConfig()` returns a shallow copy, preventing external mutation of internal state.",
            "`updateConfig()` returns a new manager instance and the original manager is unchanged.",
            "Updated config from `updateConfig()` reflects changes correctly.",
            "Nested objects within `updateConfig()` are handled immutably (new nested object reference if changed, old if not).",
            "`resetConfig()` returns a new manager instance with original default settings.",
            "After `resetConfig()`, the original `initialConfig` object is not mutated by any subsequent operations on the new manager.",
            "Test with complex nested objects to verify deep copy behavior for `initialConfig` reset."
          ],
          "hints": [
            "To ensure `initialConfig` is truly immutable and independent for `resetConfig`, consider performing a deep copy of it when the manager is first created.",
            "The `updateConfig` method should create a *new* configuration object by spreading the `currentConfig` and then applying `newSettings`. If `newSettings` contains nested objects, you'll need to spread those as well to achieve immutability at those levels.",
            "Remember that each operation (`updateConfig`, `resetConfig`) must return a *new* instance of the manager, not `this`, to maintain the immutable pattern for the manager itself.",
            "For deep cloning (especially for `initialConfig`), `structuredClone()` is the most robust modern JS solution. A simpler fallback for basic objects is `JSON.parse(JSON.stringify(obj))`.",
            "Ensure the `getConfig` method also returns a *copy* (at least shallow) of the current configuration to prevent external modification of the manager's internal state."
          ],
          "tags": [
            "immutability",
            "state-management",
            "javascript",
            "design-patterns",
            "factory-function",
            "deep-copy"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "immutable_object_patterns",
            "object_composition",
            "spread_syntax",
            "object_assign"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "redux",
            "react_hooks",
            "pure_functions",
            "functional_programming"
          ]
        },
        {
          "id": "task_array_utility_generator",
          "title": "Build a Flexible Array Utility Generator",
          "description": "\nImplement a JavaScript utility function `createArrayGenerator` that provides different methods for creating arrays based on common use cases, leveraging `Array.from()` and `Array.of()`.\n\n**Requirements:**\n1.  **`createArrayGenerator()` function:** This function should return an object containing the following array generation methods:\n    *   **`range(start, end, step = 1)`:** Generates an array of numbers from `start` (inclusive) to `end` (inclusive), with an optional `step`. If `start > end`, return an empty array. Handle `step` being 0 or negative.\n    *   **`fromIterable(iterable, mapFn = null)`:** Takes an iterable (e.g., string, Set, NodeList) and an optional mapping function. Returns a new array. This should be a wrapper around `Array.from()`.\n    *   **`ofValues(...values)`:** Takes a variable number of arguments and returns an array containing those arguments as elements. This should be a wrapper around `Array.of()`.\n    *   **`filled(length, fillValue)`:** Creates an array of a specified `length` where each element is `fillValue`. (e.g., `filled(3, 0)` -> `[0, 0, 0]`).\n\n2.  **Edge Cases & Validation:**\n    *   `range`: If `step` is 0, return an empty array. If `start` > `end` and `step` is positive, return empty. If `start` < `end` and `step` is negative, return empty.\n    *   `fromIterable`: Handle non-iterable inputs gracefully (e.g., return empty array or throw error appropriately).\n    *   `filled`: Handle `length` being non-positive (return empty array).\n\n3.  **Demonstrate Usage:** Show examples of creating arrays using each method.\n",
          "difficulty": "medium",
          "startingCode": "function createArrayGenerator() {\n  return {\n    /**\n     * Generates an array of numbers from start to end (inclusive) with a step.\n     * @param {number} start\n     * @param {number} end\n     * @param {number} [step=1]\n     * @returns {number[]}\n     */\n    range(start, end, step = 1) {\n      // TODO: Implement range\n      return [];\n    },\n\n    /**\n     * Creates a new array from an iterable object, with an optional map function.\n     * @param {Iterable<any>} iterable\n     * @param {Function} [mapFn=null]\n     * @returns {Array<any>}\n     */\n    fromIterable(iterable, mapFn = null) {\n      // TODO: Implement fromIterable using Array.from\n      return [];\n    },\n\n    /**\n     * Creates an array from a variable number of arguments.\n     * @param {...any} values\n     * @returns {Array<any>}\n     */\n    ofValues(...values) {\n      // TODO: Implement ofValues using Array.of\n      return [];\n    },\n\n    /**\n     * Creates an array of a specified length, filled with a given value.\n     * @param {number} length\n     * @param {any} fillValue\n     * @returns {Array<any>}\n     */\n    filled(length, fillValue) {\n      // TODO: Implement filled\n      return [];\n    },\n  };\n}\n\n// Example Usage (uncomment and test):\n// const generator = createArrayGenerator();\n\n// console.log('Range 1-5:', generator.range(1, 5));           // Expected: [1, 2, 3, 4, 5]\n// console.log('Range 5-1, step 1:', generator.range(5, 1)); // Expected: []\n// console.log('Range 0-10, step 2:', generator.range(0, 10, 2)); // Expected: [0, 2, 4, 6, 8, 10]\n// console.log('Range 5-5:', generator.range(5, 5));           // Expected: [5]\n// console.log('Range -2 to 2:', generator.range(-2, 2));   // Expected: [-2, -1, 0, 1, 2]\n// console.log('Range 1-5, step 0:', generator.range(1, 5, 0)); // Expected: []\n\n// console.log('From String:', generator.fromIterable('hello')); // Expected: ['h', 'e', 'l', 'l', 'o']\n// console.log('From Set:', generator.fromIterable(new Set([1, 2, 3]))); // Expected: [1, 2, 3]\n// console.log('From iterable with map:', generator.fromIterable([1, 2, 3], x => x * x)); // Expected: [1, 4, 9]\n\n// console.log('Of values:', generator.ofValues(1, 'a', true)); // Expected: [1, 'a', true]\n// console.log('Of single value:', generator.ofValues(5)); // Expected: [5]\n\n// console.log('Filled 3 with 0:', generator.filled(3, 0)); // Expected: [0, 0, 0]\n// console.log('Filled 5 with null:', generator.filled(5, null)); // Expected: [null, null, null, null, null]\n// console.log('Filled 0 length:', generator.filled(0, 'x')); // Expected: []\n// console.log('Filled -2 length:', generator.filled(-2, 'y')); // Expected: []\n",
          "solutionCode": "function createArrayGenerator() {\n  return {\n    /**\n     * Generates an array of numbers from start to end (inclusive) with a step.\n     * @param {number} start\n     * @param {number} end\n     * @param {number} [step=1]\n     * @returns {number[]}\n     */\n    range(start, end, step = 1) {\n      if (step === 0) return [];\n      if (start > end && step > 0) return [];\n      if (start < end && step < 0) return [];\n\n      const result = [];\n      if (step > 0) {\n        for (let i = start; i <= end; i += step) {\n          result.push(i);\n        }\n      } else { \n        for (let i = start; i >= end; i += step) {\n          result.push(i);\n        }\n      }\n      return result;\n    },\n\n    /**\n     * Creates a new array from an iterable object, with an optional map function.\n     * @param {Iterable<any>} iterable\n     * @param {Function} [mapFn=null]\n     * @returns {Array<any>}\n     */\n    fromIterable(iterable, mapFn = null) {\n      try {\n        if (iterable && typeof iterable[Symbol.iterator] === 'function') {\n          return Array.from(iterable, mapFn);\n        } else {\n          console.warn('Input is not iterable for fromIterable:', iterable);\n          return []; \n        }\n      } catch (e) {\n        console.error('Error creating array from iterable:', e);\n        return [];\n      }\n    },\n\n    /**\n     * Creates an array from a variable number of arguments.\n     * @param {...any} values\n     * @returns {Array<any>}\n     */\n    ofValues(...values) {\n      return Array.of(...values);\n    },\n\n    /**\n     * Creates an array of a specified length, filled with a given value.\n     * @param {number} length\n     * @param {any} fillValue\n     * @returns {Array<any>}\n     */\n    filled(length, fillValue) {\n      if (length <= 0) {\n        return [];\n      }\n      return Array.from({ length }, () => fillValue);\n    },\n  };\n}\n\n// Example Usage:\nconst generator = createArrayGenerator();\n\nconsole.log('--- Range Tests ---');\nconsole.log('Range 1-5:', generator.range(1, 5));           \nconsole.log('Range 5-1:', generator.range(5, 1));           \nconsole.log('Range 0-10, step 2:', generator.range(0, 10, 2)); \nconsole.log('Range 5-5:', generator.range(5, 5));           \nconsole.log('Range -2 to 2:', generator.range(-2, 2));   \nconsole.log('Range 1-5, step 0:', generator.range(1, 5, 0)); \nconsole.log('Range 10-0, step -2:', generator.range(10, 0, -2)); \n\nconsole.log('\\n--- FromIterable Tests ---');\nconsole.log('From String:', generator.fromIterable('hello')); \nconsole.log('From Set:', generator.fromIterable(new Set([1, 2, 3]))); \nconsole.log('From iterable with map:', generator.fromIterable([1, 2, 3], x => x * x)); \nconsole.log('From non-iterable:', generator.fromIterable(123)); \n\nconsole.log('\\n--- OfValues Tests ---');\nconsole.log('Of values:', generator.ofValues(1, 'a', true)); \nconsole.log('Of single value:', generator.ofValues(5)); \nconsole.log('Of no values:', generator.ofValues()); \n\nconsole.log('\\n--- Filled Tests ---');\nconsole.log('Filled 3 with 0:', generator.filled(3, 0)); \nconsole.log('Filled 5 with null:', generator.filled(5, null)); \nconsole.log('Filled 0 length:', generator.filled(0, 'x')); \nconsole.log('Filled -2 length:', generator.filled(-2, 'y')); \n",
          "testCases": [
            "`range(1, 5)`: Should return `[1, 2, 3, 4, 5]`.",
            "`range(0, 10, 2)`: Should return `[0, 2, 4, 6, 8, 10]`.",
            "`range(5, 1)`: Should return `[]` (start > end, positive step).",
            "`range(10, 0, -2)`: Should return `[10, 8, 6, 4, 2, 0]`.",
            "`range(1, 5, 0)`: Should return `[]` (zero step).",
            "`fromIterable('test')`: Should return `['t', 'e', 's', 't']`.",
            "`fromIterable(new Set([1, 2, 1]))`: Should return `[1, 2]`.",
            "`fromIterable([1, 2, 3], x => x * 10)`: Should return `[10, 20, 30]`.",
            "`fromIterable(null)`: Should return `[]` (or handle gracefully, no error).",
            "`ofValues(true, 'hello', 10)`: Should return `[true, 'hello', 10]`.",
            "`ofValues(7)`: Should return `[7]`.",
            "`filled(4, 'X')`: Should return `['X', 'X', 'X', 'X']`.",
            "`filled(0, 'Y')`: Should return `[]`.",
            "`filled(-5, 'Z')`: Should return `[]`."
          ],
          "hints": [
            "For `range`, consider using `Array.from({ length: ... }, (v, i) => ...)` to generate the sequence concisely, or a traditional `for` loop.",
            "For `fromIterable`, directly leverage `Array.from`'s capabilities. Remember to handle cases where the input might not be a valid iterable.",
            "`ofValues` is a direct wrapper, straightforward.",
            "For `filled`, `Array.from` combined with a `length` property in the first argument, and `() => fillValue` in the map function, is a clean approach. Alternatively, `new Array(length).fill(fillValue)` works.",
            "Always validate inputs for edge cases (e.g., `length <= 0`, invalid `step`)."
          ],
          "tags": [
            "arrays",
            "array-methods",
            "javascript",
            "utility-functions",
            "es6"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "array_creation_methods",
            "array_methods",
            "es6_features"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "functional_programming",
            "iterators",
            "generators"
          ]
        }
      ]
    }
  },
  {
    "id": "df8fca82-8fab-48c2-853c-a851712f7495",
    "startLine": 1200,
    "endLine": 1299,
    "processedDate": "2025-06-17T07:40:48.629Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_array_modification_methods",
          "title": "Array Modification Methods: Adding and Removing Elements",
          "content": "This section covers fundamental JavaScript array methods used for adding and removing elements. These methods allow for manipulation of array contents at the beginning, end, or specific positions.\n\n## Key Concepts\n- **`push(...items)`**: Adds one or more elements to the end of an array and returns the new length of the array. It modifies the original array.\n- **`pop()`**: Removes the last element from an array and returns that element. If the array is empty, it returns `undefined`. It modifies the original array.\n- **`shift()`**: Removes the first element from an array and returns that element. If the array is empty, it returns `undefined`. It modifies the original array.\n- **`unshift(...items)`**: Adds one or more elements to the beginning of an array and returns the new length of the array. It modifies the original array.\n- **`splice(pos, deleteCount, ...items)`**: A highly versatile method that changes the contents of an array by removing existing elements and/or adding new elements. It modifies the original array.\n  - `pos`: The index at which to start changing the array.\n  - `deleteCount`: An integer indicating the number of elements to remove from `pos`.\n  - `...items`: The elements to add to the array, starting at `pos`.\n  - Returns an array containing the deleted elements.\n- **`slice(start, end)`**: Returns a shallow copy of a portion of an array into a new array object selected from `start` to `end` (end not included). The original array will not be modified.\n  - `start`: Zero-based index at which to begin extraction. If negative, it specifies an offset from the end of the sequence.\n  - `end`: Zero-based index before which to end extraction. `slice` extracts up to (but not including) `end`. If `end` is omitted, `slice` extracts to the end of the sequence.\n- **`concat(...items)`**: Used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array. It can take an arbitrary number of array arguments or non-array values.",
          "examples": [
            {
              "id": "example_array_modification_1",
              "title": "Basic Push, Pop, Shift, Unshift Operations",
              "code": "const animals = ['cat', 'dog'];\n\n// push(): Adds to the end, returns new length\nconst newLengthPush = animals.push('elephant'); // animals is now ['cat', 'dog', 'elephant'], newLengthPush is 3\nconsole.log('After push:', animals, 'Length:', newLengthPush);\n\n// pop(): Removes from the end, returns removed element\nconst removedPop = animals.pop(); // animals is now ['cat', 'dog'], removedPop is 'elephant'\nconsole.log('After pop:', animals, 'Removed:', removedPop);\n\n// unshift(): Adds to the beginning, returns new length\nconst newLengthUnshift = animals.unshift('horse'); // animals is now ['horse', 'cat', 'dog'], newLengthUnshift is 3\nconsole.log('After unshift:', animals, 'Length:', newLengthUnshift);\n\n// shift(): Removes from the beginning, returns removed element\nconst removedShift = animals.shift(); // animals is now ['cat', 'dog'], removedShift is 'horse'\nconsole.log('After shift:', animals, 'Removed:', removedShift);",
              "explanation": "This example demonstrates the basic usage of `push`, `pop`, `unshift`, and `shift`. Note how these methods directly modify the `animals` array in place and return either the new length or the removed element.",
              "language": "typescript"
            },
            {
              "id": "example_array_modification_2",
              "title": "Splice, Slice, and Concat Operations",
              "code": "const animals = ['cat', 'dog', 'elephant', 'fox'];\n\n// splice() examples:\n// 1. Insert without removing: add 'bird' at index 1\nconst noRemovedSplice = animals.splice(1, 0, 'bird'); // animals is ['cat', 'bird', 'dog', 'elephant', 'fox'], noRemovedSplice is []\nconsole.log('Splice (insert only):', animals, 'Removed:', noRemovedSplice);\n\n// 2. Remove without inserting: remove 2 elements starting at index 2\nconst removedSplice = animals.splice(2, 2); // animals is ['cat', 'bird', 'fox'], removedSplice is ['dog', 'elephant']\nconsole.log('Splice (remove only):', animals, 'Removed:', removedSplice);\n\n// 3. Insert and remove simultaneously (replace): replace 1 element at index 0\nconst replacedSplice = animals.splice(0, 1, 'lion', 'tiger'); // animals is ['lion', 'tiger', 'bird', 'fox'], replacedSplice is ['cat']\nconsole.log('Splice (replace):', animals, 'Removed:', replacedSplice);\n\nconst originalNumbers = [10, 20, 30, 40, 50];\n\n// slice() example: creates a new array\nconst slicedNumbers = originalNumbers.slice(1, 4); // slicedNumbers is [20, 30, 40]\nconsole.log('Original after slice:', originalNumbers); // [10, 20, 30, 40, 50] - remains unchanged\nconsole.log('Sliced array:', slicedNumbers);\n\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst arr3 = [5, 6];\n\n// concat() example: creates a new array\nconst combinedArray = arr1.concat(arr2, arr3, 7, 8); // [1, 2, 3, 4, 5, 6, 7, 8]\nconsole.log('Combined array:', combinedArray);\nconsole.log('Original arr1 after concat:', arr1); // [1, 2] - remains unchanged",
              "explanation": "This example showcases `splice`'s flexibility for insertion, deletion, and replacement, all of which modify the original array. It also demonstrates `slice` creating a new array without affecting the original and `concat` merging arrays into a new one.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_array_modification_1",
            "question_array_modification_2",
            "question_array_modification_3",
            "question_array_modification_4",
            "question_array_modification_5",
            "question_array_modification_6",
            "question_array_modification_7"
          ],
          "relatedTasks": [
            "task_array_modification_1",
            "task_array_modification_2"
          ],
          "tags": [
            "Array Methods",
            "Mutation",
            "Non-Mutation",
            "Data Manipulation",
            "JavaScript Basics"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "data_structures",
            "algorithm_implementation",
            "frontend_data_handling"
          ]
        },
        {
          "id": "theory_array_searching_methods",
          "title": "Array Searching Methods: Finding Elements",
          "content": "This section details array methods primarily used for searching and filtering elements based on specific criteria or values. These methods provide efficient ways to locate data within an array.\n\n## Key Concepts\n- **`indexOf(item, pos)`**: Returns the first index at which a given `item` can be found in the array, or -1 if it is not present. The search starts from `pos` (optional, default 0).\n- **`lastIndexOf(item, pos)`**: Returns the last index at which a given `item` can be found in the array, or -1 if it is not present. The array is searched backwards, starting from `pos` (optional, default `array.length - 1`).\n- **`includes(value)`**: Determines whether an array includes a certain `value` among its entries, returning `true` or `false` as appropriate. This method handles `NaN` correctly, unlike `indexOf`.\n- **`find(func)`**: Returns the **first** element in the array that satisfies the provided testing `func`. If no elements satisfy the testing function, `undefined` is returned.\n  - The callback `func` is executed for each element in the array until it returns a `truthy` value.\n- **`filter(func)`**: Creates a **new array** with all elements that pass the test implemented by the provided testing `func`. It iterates over the entire array.\n- **`findIndex(func)`**: Returns the **index** of the first element in the array that satisfies the provided testing `func`. Otherwise, it returns -1. It is similar to `find`, but returns the index instead of the value.",
          "examples": [
            {
              "id": "example_array_searching_1",
              "title": "Basic Searching with indexOf, lastIndexOf, includes",
              "code": "const fruits = ['apple', 'banana', 'orange', 'apple', 'grape', NaN];\n\n// indexOf()\nconsole.log('Index of first apple:', fruits.indexOf('apple')); // 0\nconsole.log('Index of first orange from index 2:', fruits.indexOf('orange', 2)); // 2\nconsole.log('Index of non-existent item:', fruits.indexOf('kiwi')); // -1\nconsole.log('indexOf NaN (issue):', fruits.indexOf(NaN)); // -1 (does not find NaN)\n\n// lastIndexOf()\nconsole.log('Last index of apple:', fruits.lastIndexOf('apple')); // 3\nconsole.log('Last index of apple before index 2:', fruits.lastIndexOf('apple', 2)); // 0\n\n// includes()\nconsole.log('Includes banana:', fruits.includes('banana')); // true\nconsole.log('Includes mango:', fruits.includes('mango')); // false\nconsole.log('Includes NaN (correctly):', fruits.includes(NaN)); // true (handles NaN)",
              "explanation": "This example illustrates how `indexOf` and `lastIndexOf` find element positions, with `pos` allowing for specific starting points. It highlights `includes` as a simpler way to check for presence, especially useful for `NaN`.",
              "language": "typescript"
            },
            {
              "id": "example_array_searching_2",
              "title": "Advanced Searching with find, filter, findIndex",
              "code": "const products = [\n  { id: 1, name: 'Laptop', price: 1200 },\n  { id: 2, name: 'Mouse', price: 25 },\n  { id: 3, name: 'Keyboard', price: 75 },\n  { id: 4, name: 'Monitor', price: 300 },\n  { id: 5, name: 'Webcam', price: 75 }\n];\n\n// find(): Returns the first matching object\nconst expensiveProduct = products.find(product => product.price > 100); // { id: 1, name: 'Laptop', price: 1200 }\nconsole.log('First expensive product:', expensiveProduct);\n\nconst nonExistentProduct = products.find(product => product.price > 2000);\nconsole.log('Non-existent product:', nonExistentProduct); // undefined\n\n// filter(): Returns a new array with all matching objects\nconst affordableProducts = products.filter(product => product.price <= 100);\n/*\n[\n  { id: 2, name: 'Mouse', price: 25 },\n  { id: 3, name: 'Keyboard', price: 75 },\n  { id: 5, name: 'Webcam', price: 75 }\n]\n*/\nconsole.log('Affordable products:', affordableProducts);\n\n// findIndex(): Returns the index of the first matching object\nconst keyboardIndex = products.findIndex(product => product.name === 'Keyboard'); // 2\nconsole.log('Index of Keyboard:', keyboardIndex);\n\nconst tabletIndex = products.findIndex(product => product.name === 'Tablet');\nconsole.log('Index of Tablet:', tabletIndex); // -1",
              "explanation": "`find` is useful when you need the first element that meets a condition. `filter` is used when you need a new array containing all elements that meet the condition. `findIndex` is similar to `find` but provides the index instead of the element itself, useful for modifying elements or understanding their position.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_array_searching_1",
            "question_array_searching_2",
            "question_array_searching_3",
            "question_array_searching_4",
            "question_array_searching_5",
            "question_array_searching_6"
          ],
          "relatedTasks": [
            "task_array_searching_1",
            "task_array_searching_2"
          ],
          "tags": [
            "Array Methods",
            "Searching",
            "Filtering",
            "Higher-Order Functions",
            "Data Retrieval"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "callback_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_manipulation",
            "api_response_processing",
            "ui_filtering"
          ]
        },
        {
          "id": "theory_array_iteration_transformation_methods",
          "title": "Array Iteration and Transformation Methods",
          "content": "This section delves into array methods that facilitate iteration over elements and transformation of arrays into new ones or a single value.\n\n## Key Concepts\n- **`forEach(func)`**: Executes a provided `func` once for each array element. It does not return a new array and returns `undefined`. It's primarily used for side effects (e.g., logging, updating DOM).\n  - The callback `func` typically takes `(element, index, array)` as arguments.\n- **`map(func)`**: Creates a **new array** populated with the results of calling a provided `func` on every element in the calling array. It does not modify the original array.\n  - Ideal for transforming each element in an array into a new form.\n- **`sort(func)`**: Sorts the elements of an array **in-place** and returns the reference to the same array. The default sort order is ascending, built upon converting elements into strings, then comparing their sequences of UTF-16 code units.\n  - For numeric or custom sorting, a comparison `func` must be provided: `(a, b) => a - b` for ascending numbers, `(a, b) => b - a` for descending numbers.\n- **`reverse()`**: Reverses the order of the elements in an array **in-place** and returns the reference to the same array.\n- **`split(separator)` (String method)**: Splits a `String` object into an array of strings by separating the string into substrings, using a specified `separator` string to determine where to make each split. Returns a new array.\n- **`join(separator)` (Array method)**: Creates and returns a new string by concatenating all of the elements in an array (or an array-like object), separated by commas or a specified `separator` string.\n- **`reduce(func, initial)`**: Executes a `reducer` callback `func` on each element of the array, `accumulating` a single `value` from left to right. It is often used to sum, flatten, or transform data into a single result.\n  - `func`: A callback function that takes four arguments: `accumulator`, `currentValue`, `currentIndex`, `array`.\n  - `initial`: An optional value to use as the first argument to the first call of the `func`.\n  - If `initial` is not provided, the first element of the array is used as the initial `accumulator` value and `currentValue` starts from the second element. If the array is empty and no initial value is provided, a `TypeError` is thrown.",
          "examples": [
            {
              "id": "example_array_iteration_transformation_1",
              "title": "forEach, map, sort, reverse",
              "code": "const numbers = [10, 5, 20, 15];\n\n// forEach(): Iterates, no return value\nlet sum = 0;\nnumbers.forEach(num => {\n  sum += num;\n});\nconsole.log('Sum using forEach:', sum); // 50\n\n// map(): Transforms into a new array\nconst doubledNumbers = numbers.map(num => num * 2); // [20, 10, 40, 30]\nconsole.log('Original array after map (unchanged):', numbers);\nconsole.log('Doubled numbers:', doubledNumbers);\n\n// sort(): Sorts in-place\nconst words = ['banana', 'apple', 'cherry'];\nwords.sort(); // ['apple', 'banana', 'cherry']\nconsole.log('Sorted words (in-place):', words);\n\nconst unsortedNumbers = [10, 2, 8, 1, 15];\n// Default sort converts to string: [1, 10, 15, 2, 8]\nunsortedNumbers.sort();\nconsole.log('Default string sort:', unsortedNumbers);\n\n// Numeric sort:\nunsortedNumbers.sort((a, b) => a - b); // [1, 2, 8, 10, 15]\nconsole.log('Numeric sort (ascending):', unsortedNumbers);\n\n// reverse(): Reverses in-place\nunsortedNumbers.reverse(); // [15, 10, 8, 2, 1]\nconsole.log('Reversed numbers (in-place):', unsortedNumbers);",
              "explanation": "`forEach` is for iteration without modifying or creating a new array. `map` is for creating a new array where each element is transformed. `sort` and `reverse` modify the array in place; `sort` requires a custom comparison function for correct numeric sorting.",
              "language": "typescript"
            },
            {
              "id": "example_array_iteration_transformation_2",
              "title": "split, join, reduce",
              "code": "const sentence = \"Hello world, how are you?\";\n\n// split(): String to Array\nconst wordsArray = sentence.split(' '); // ['Hello', 'world,', 'how', 'are', 'you?']\nconsole.log('Words array:', wordsArray);\n\nconst charsArray = sentence.split(''); // ['H', 'e', 'l', 'l', 'o', ..., '?']\nconsole.log('Characters array (first 5):', charsArray.slice(0,5));\n\nconst commaSeparated = \"apple,banana,orange\";\nconst fruits = commaSeparated.split(','); // ['apple', 'banana', 'orange']\nconsole.log('Fruits array:', fruits);\n\n// join(): Array to String\nconst rejoinedSentence = wordsArray.join('-'); // 'Hello-world,-how-are-you?'\nconsole.log('Rejoined sentence:', rejoinedSentence);\n\nconst csvString = fruits.join(';'); // 'apple;banana;orange'\nconsole.log('CSV string:', csvString);\n\nconst numbersToReduce = [1, 2, 3, 4, 5];\n\n// reduce(): Summing elements\nconst sumOfNumbers = numbersToReduce.reduce((accumulator, currentValue) => accumulator + currentValue, 0); // 15\nconsole.log('Sum using reduce:', sumOfNumbers);\n\n// reduce(): Flattening an array of arrays\nconst arrayOfArrays = [[1, 2], [3, 4], [5]];\nconst flattenedArray = arrayOfArrays.reduce((acc, curr) => acc.concat(curr), []); // [1, 2, 3, 4, 5]\nconsole.log('Flattened array:', flattenedArray);\n\n// reduce(): Counting occurrences\nconst fruitBasket = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];\nconst fruitCount = fruitBasket.reduce((count, fruit) => {\n  count[fruit] = (count[fruit] || 0) + 1;\n  return count;\n}, {}); // { apple: 3, banana: 2, orange: 1 }\nconsole.log('Fruit counts:', fruitCount);",
              "explanation": "`split` and `join` are essential for string-array conversions. `reduce` is a powerful method for aggregating array elements into a single value or object. It's highly versatile, capable of performing sums, transforming arrays into objects, or flattening arrays.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_array_iteration_transformation_1",
            "question_array_iteration_transformation_2",
            "question_array_iteration_transformation_3",
            "question_array_iteration_transformation_4",
            "question_array_iteration_transformation_5",
            "question_array_iteration_transformation_6",
            "question_array_iteration_transformation_7",
            "question_array_iteration_transformation_8"
          ],
          "relatedTasks": [
            "task_array_iteration_transformation_1",
            "task_array_iteration_transformation_2"
          ],
          "tags": [
            "Array Methods",
            "Iteration",
            "Transformation",
            "Higher-Order Functions",
            "String Conversion"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "callback_functions",
            "javascript_strings"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_aggregation",
            "complex_data_processing",
            "functional_programming"
          ]
        },
        {
          "id": "theory_additional_array_methods",
          "title": "Additional Array Utility Methods",
          "content": "This section covers several utility methods that provide additional functionalities for working with arrays, including type checking, conditional checks, and in-place content manipulation.\n\n## Key Concepts\n- **`Array.isArray(arr)`**: A static method of the `Array` object that determines whether the passed value is an `Array`. It returns `true` if the value is an array, `false` otherwise. This is the most reliable way to check if a variable is an array, especially when dealing with multiple frames or contexts.\n- **`arr.some(fn)`**: Tests whether at least one element in the array passes the test implemented by the provided `fn` (callback function). It returns `true` if it finds an element for which the callback returns `truthy` value; otherwise, it returns `false`. It stops iterating as soon as the callback returns `true`.\n- **`arr.every(fn)`**: Tests whether all elements in the array pass the test implemented by the provided `fn` (callback function). It returns `true` if the callback returns `truthy` for all elements; otherwise, it returns `false`. It stops iterating as soon as the callback returns `false`.\n- **`arr.fill(value, start, end)`**: Fills all the elements of an array from a `start` index to an `end` index with a static `value`. It modifies the original array.\n  - `value`: Value to fill the array with.\n  - `start`: Start index (inclusive). Default is 0.\n  - `end`: End index (exclusive). Default is `array.length`.\n- **`arr.copyWithin(target, start, end)`**: Copies part of an array to another location in the same array and returns it, without modifying its length. It modifies the original array.\n  - `target`: Zero-based index at which to copy the sequence to.\n  - `start`: Zero-based index at which to start copying elements from (inclusive).\n  - `end`: Zero-based index at which to end copying elements from (exclusive).",
          "examples": [
            {
              "id": "example_additional_array_1",
              "title": "Array.isArray, some, every",
              "code": "const numbers = [1, 2, 3, 4, 5];\nconst mixed = [1, 'two', 3];\nconst notAnArray = {};\n\n// Array.isArray()\nconsole.log('Is numbers an Array?', Array.isArray(numbers)); // true\nconsole.log('Is notAnArray an Array?', Array.isArray(notAnArray)); // false\nconsole.log('Is a string an Array?', Array.isArray('hello')); // false\n\n// some()\nconst hasEven = numbers.some(num => num % 2 === 0); // true (because 2, 4 are even)\nconsole.log('Does numbers have an even number?', hasEven);\n\nconst hasNegative = numbers.some(num => num < 0); // false\nconsole.log('Does numbers have a negative number?', hasNegative);\n\n// every()\nconst allEven = numbers.every(num => num % 2 === 0); // false (because 1, 3, 5 are odd)\nconsole.log('Are all numbers even?', allEven);\n\nconst allPositive = numbers.every(num => num > 0); // true\nconsole.log('Are all numbers positive?', allPositive);",
              "explanation": "`Array.isArray` is the robust way to check for array types. `some` is useful for checking if at least one element meets a condition, while `every` checks if all elements meet it. Both are short-circuiting.",
              "language": "typescript"
            },
            {
              "id": "example_additional_array_2",
              "title": "fill, copyWithin",
              "code": "const arrayToFill = [1, 2, 3, 4, 5];\n\n// fill(value, start, end)\narrayToFill.fill(0, 2, 4); // Fills with 0 from index 2 (inclusive) to 4 (exclusive)\n// arrayToFill is now [1, 2, 0, 0, 5]\nconsole.log('After fill(0, 2, 4):', arrayToFill);\n\nconst arrayToFillFull = [1, 2, 3];\narrayToFillFull.fill(7); // Fills the entire array with 7\n// arrayToFillFull is now [7, 7, 7]\nconsole.log('After fill(7):', arrayToFillFull);\n\nconst arrCopy = ['a', 'b', 'c', 'd', 'e'];\n\n// copyWithin(target, start, end)\narrCopy.copyWithin(0, 3, 5); // Copies elements from index 3 (inclusive) to 5 (exclusive) to index 0\n// Elements 'd', 'e' are copied to index 0, 1 respectively.\n// arrCopy is now ['d', 'e', 'c', 'd', 'e']\nconsole.log('After copyWithin(0, 3, 5):', arrCopy);\n\nconst anotherArr = [1, 2, 3, 4, 5, 6, 7];\nanotherArr.copyWithin(3, 0, 3); // Copies [1, 2, 3] to index 3\n// anotherArr is now [1, 2, 3, 1, 2, 3, 7]\nconsole.log('After copyWithin(3, 0, 3):', anotherArr);",
              "explanation": "`fill` is used for mass assignment of a static value to a portion or the entirety of an array. `copyWithin` is a more niche method for in-place internal copying of array segments, useful for specific memory-efficient operations or buffer management scenarios. Both mutate the original array.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_additional_array_1",
            "question_additional_array_2",
            "question_additional_array_3",
            "question_additional_array_4",
            "question_additional_array_5",
            "question_additional_array_6"
          ],
          "relatedTasks": [
            "task_additional_array_1",
            "task_additional_array_2"
          ],
          "tags": [
            "Array Methods",
            "Type Checking",
            "Conditional Logic",
            "In-place Modification"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_booleans",
            "callback_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "validation",
            "data_integrity",
            "array_optimization"
          ]
        },
        {
          "id": "theory_mutating_vs_non_mutating_methods",
          "title": "Mutating vs. Non-Mutating Array Methods",
          "content": "A crucial distinction in JavaScript array methods is whether they modify (mutate) the original array or return a new array, leaving the original untouched. Understanding this difference is vital for writing predictable and bug-free code, especially in functional programming contexts or when working with immutable state (e.g., in React).\n\n## Key Concepts\n- **Mutating Methods (Modify in-place)**: These methods directly alter the original array. Changes are visible on the original array reference.\n  - `push()`: Adds to the end.\n  - `pop()`: Removes from the end.\n  - `shift()`: Removes from the beginning.\n  - `unshift()`: Adds to the beginning.\n  - `splice()`: Adds/removes elements at any position.\n  - `sort()`: Sorts the array.\n  - `reverse()`: Reverses the array.\n  - `fill()`: Fills elements with a static value.\n  - `copyWithin()`: Copies elements within the array.\n\n- **Non-Mutating Methods (Return new array)**: These methods do not modify the original array. Instead, they create and return a brand new array with the results of the operation.\n  - `slice()`: Creates a shallow copy of a portion of an array.\n  - `concat()`: Merges arrays into a new array.\n  - `map()`: Creates a new array with the results of a function call on every element.\n  - `filter()`: Creates a new array with all elements that pass a test.\n  - `reduce()`: Reduces the array to a single value (or object/array), not directly mutating the array it operates on (though the accumulator can be modified).\n  - `indexOf()`, `lastIndexOf()`, `includes()`, `find()`, `findIndex()`, `forEach()`, `some()`, `every()`: These methods generally do not modify the array; they either return a value (index, boolean, element) or perform a side effect without altering the array's structure.",
          "examples": [
            {
              "id": "example_mutating_vs_non_mutating_1",
              "title": "Demonstrating Mutation",
              "code": "let originalArray = [1, 2, 3];\n\n// Mutating method: push()\nconst pushedResult = originalArray.push(4);\nconsole.log('After push():', originalArray); // [1, 2, 3, 4]\nconsole.log('Returned from push():', pushedResult); // 4 (new length)\n\nlet anotherArray = ['a', 'b', 'c'];\n\n// Mutating method: sort()\nanotherArray.sort();\nconsole.log('After sort():', anotherArray); // ['a', 'b', 'c'] (already sorted)\n\nlet numbersToSort = [3, 1, 2];\nnumbersToSort.sort((a, b) => a - b);\nconsole.log('After numeric sort():', numbersToSort); // [1, 2, 3]\n\nlet yetAnotherArray = [10, 20, 30];\nconst removedElement = yetAnotherArray.pop();\nconsole.log('After pop():', yetAnotherArray); // [10, 20]\nconsole.log('Removed element:', removedElement); // 30",
              "explanation": "This example clearly shows that after calling `push()`, `sort()`, or `pop()`, the `originalArray`, `anotherArray`, `numbersToSort`, and `yetAnotherArray` variables now refer to the modified arrays. The changes are applied directly to the array instance.",
              "language": "typescript"
            },
            {
              "id": "example_mutating_vs_non_mutating_2",
              "title": "Demonstrating Non-Mutation",
              "code": "const initialArray = [1, 2, 3, 4, 5];\n\n// Non-mutating method: slice()\nconst slicedArray = initialArray.slice(1, 4);\nconsole.log('Initial array after slice():', initialArray); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log('New sliced array:', slicedArray); // [2, 3, 4]\n\n// Non-mutating method: map()\nconst mappedArray = initialArray.map(num => num * 2);\nconsole.log('Initial array after map():', initialArray); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log('New mapped array:', mappedArray); // [2, 4, 6, 8, 10]\n\n// Non-mutating method: concat()\nconst newCombinedArray = initialArray.concat([6, 7]);\nconsole.log('Initial array after concat():', initialArray); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log('New combined array:', newCombinedArray); // [1, 2, 3, 4, 5, 6, 7]\n\n// Non-mutating (returns a value, doesn't modify array): find()\nconst foundElement = initialArray.find(num => num === 3);\nconsole.log('Initial array after find():', initialArray); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log('Found element:', foundElement); // 3",
              "explanation": "This example illustrates that `slice()`, `map()`, and `concat()` create new arrays and return them, leaving the `initialArray` completely unmodified. `find()` also does not modify the array; it simply returns a value based on its contents.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_mutating_vs_non_mutating_1",
            "question_mutating_vs_non_mutating_2",
            "question_mutating_vs_non_mutating_3",
            "question_mutating_vs_non_mutating_4",
            "question_mutating_vs_non_mutating_5"
          ],
          "relatedTasks": [
            "task_mutating_vs_non_mutating_1"
          ],
          "tags": [
            "Array Methods",
            "Mutation",
            "Immutability",
            "Side Effects",
            "Functional Programming"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_variables",
            "javascript_references"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "redux_fundamentals",
            "predictable_code"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_array_modification_1",
          "topic": "Array Modification: push/pop/shift/unshift",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference in behavior between `push()` and `unshift()` array methods?",
          "answer": "`push()` adds elements to the end of an array, while `unshift()` adds elements to the beginning of an array. Both methods modify the original array.",
          "analysisPoints": [
            "Understanding of array endpoints.",
            "Recall of specific method names and their actions.",
            "Recognition that both mutate the original array."
          ],
          "keyConcepts": [
            "push",
            "unshift",
            "array mutation",
            "array elements"
          ],
          "evaluationCriteria": [
            "Correctly identifies insertion point.",
            "Mentions array modification."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Mutation",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_modification_2",
          "topic": "Array Modification: splice() vs slice()",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements accurately describes the difference between `Array.prototype.splice()` and `Array.prototype.slice()` in JavaScript?",
          "answer": "`splice()` modifies the original array by adding, removing, or replacing elements, while `slice()` returns a new array containing a portion of the original array without modifying it.",
          "options": [
            "`splice()` returns a new array with elements removed, while `slice()` modifies the original array by inserting elements.",
            "`splice()` is used to merge multiple arrays, while `slice()` extracts a single element.",
            "`splice()` modifies the original array by adding, removing, or replacing elements, while `slice()` returns a new array containing a portion of the original array without modifying it.",
            "Both `splice()` and `slice()` modify the original array, but `splice()` only removes elements while `slice()` only adds them."
          ],
          "analysisPoints": [
            "Distinguishing between mutating and non-mutating methods.",
            "Understanding the primary purpose of each method.",
            "Correctly identifying parameters and return values (implicit in behavior)."
          ],
          "keyConcepts": [
            "splice",
            "slice",
            "array mutation",
            "new array",
            "shallow copy"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to distinguish between similar concepts",
            "Recognition of edge cases",
            "Application of best practices"
          ],
          "example": "```typescript\nconst originalArr = [1, 2, 3, 4, 5];\n\n// Using splice()\nconst removed = originalArr.splice(2, 1, 6, 7); // Removes 3, inserts 6, 7\nconsole.log(originalArr); // [1, 2, 6, 7, 4, 5] (original array modified)\nconsole.log(removed);     // [3] (returns removed elements)\n\n// Using slice()\nconst newArr = originalArr.slice(1, 3); // Copies elements from index 1 up to (but not including) 3\nconsole.log(originalArr); // [1, 2, 6, 7, 4, 5] (original array unchanged)\nconsole.log(newArr);      // [2, 6] (returns a new array)\n```\nThe example illustrates that `splice` directly changes `originalArr` and returns the removed items, whereas `slice` creates `newArr` leaving `originalArr` intact.",
          "tags": [
            "Array Methods",
            "Mutation",
            "Non-Mutation",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_modification_3",
          "topic": "Array Modification: splice() parameters",
          "level": "medium",
          "type": "open",
          "question": "Explain the three main parameters of the `splice()` method: `start`, `deleteCount`, and `items`. Provide an example for each of the following scenarios using `splice()`:\n1. Removing elements only.\n2. Inserting elements only.\n3. Replacing existing elements.",
          "answer": null,
          "analysisPoints": [
            "Correctly defines each parameter of `splice`.",
            "Provides accurate code examples for removal, insertion, and replacement.",
            "Demonstrates understanding of how `splice` mutates the array."
          ],
          "keyConcepts": [
            "splice",
            "array mutation",
            "deleteCount",
            "start index",
            "insert items"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation",
            "Accurate code examples",
            "Correct application of parameters"
          ],
          "example": "```typescript\n// Initial array\nlet fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry'];\n\n// 1. Removing elements only: Remove 2 elements starting from index 2 ('cherry', 'date')\nlet removedFruits = fruits.splice(2, 2);\nconsole.log('After removing:', fruits);        // Output: ['apple', 'banana', 'elderberry']\nconsole.log('Removed elements:', removedFruits); // Output: ['cherry', 'date']\n\n// 2. Inserting elements only: Insert 'grape' and 'fig' at index 1\nlet originalFruits = ['apple', 'banana', 'cherry'];\nlet insertedFruits = originalFruits.splice(1, 0, 'grape', 'fig');\nconsole.log('After inserting:', originalFruits); // Output: ['apple', 'grape', 'fig', 'banana', 'cherry']\nconsole.log('Removed elements (none):', insertedFruits); // Output: []\n\n// 3. Replacing existing elements: Replace 1 element at index 0 ('apple') with 'avocado'\nlet replaceFruits = ['apple', 'banana', 'cherry'];\nlet replacedElement = replaceFruits.splice(0, 1, 'avocado');\nconsole.log('After replacing:', replaceFruits);  // Output: ['avocado', 'banana', 'cherry']\nconsole.log('Replaced element:', replacedElement); // Output: ['apple']\n```",
          "tags": [
            "Array Methods",
            "Splice",
            "Mutation",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_modification_4",
          "topic": "Array Modification: concat()",
          "level": "easy",
          "type": "flashcard",
          "question": "Does `concat()` modify the original array, and what does it return?",
          "answer": "No, `concat()` does not modify the original array. It returns a *new* array containing the combined elements of the original array and any arrays/values passed as arguments.",
          "analysisPoints": [
            "Understanding `concat`'s non-mutating nature.",
            "Recall of `concat`'s return value."
          ],
          "keyConcepts": [
            "concat",
            "non-mutation",
            "new array"
          ],
          "evaluationCriteria": [
            "Correctly identifies non-mutating behavior.",
            "Correctly identifies return type."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Non-Mutation",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_modification_5",
          "topic": "Array Modification: Array length property",
          "level": "easy",
          "type": "mcq",
          "question": "After executing the following code, what will be the value of `arr` and `result`?\n```javascript\nconst arr = [1, 2, 3];\nconst result = arr.push(4, 5);\n```",
          "answer": "`arr` will be `[1, 2, 3, 4, 5]` and `result` will be `5`.",
          "options": [
            "`arr` will be `[1, 2, 3]` and `result` will be `[4, 5]`.",
            "`arr` will be `[1, 2, 3, 4, 5]` and `result` will be `5`.",
            "`arr` will be `[1, 2, 3, 4, 5]` and `result` will be `undefined`.",
            "`arr` will be `[1, 2, 3]` and `result` will be `[1, 2, 3, 4, 5]`."
          ],
          "analysisPoints": [
            "Understanding that `push()` modifies the array in-place.",
            "Knowing that `push()` returns the new length of the array."
          ],
          "keyConcepts": [
            "push",
            "array mutation",
            "return value"
          ],
          "evaluationCriteria": [
            "Correctly predicts array state",
            "Correctly identifies return value",
            "Understanding of `push` side effects"
          ],
          "example": "The `push()` method adds one or more elements to the end of an array and returns the new length of the array. Therefore, `arr` is modified to include `4` and `5`, and its new length is `5`, which is assigned to `result`.",
          "tags": [
            "Array Methods",
            "Mutation",
            "MCQ",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_modification_6",
          "topic": "Array Modification: Chaining non-mutating methods",
          "level": "medium",
          "type": "code",
          "question": "Given an array of numbers, use chaining of non-mutating array methods (`slice`, `concat`, etc.) to create a new array that contains:\n1. The first three elements of the original array.\n2. Followed by the number `100`.\n3. Followed by the last two elements of the original array.\n\nYour solution should *not* modify the original array.",
          "answer": "```typescript\nfunction processArray(arr) {\n  if (!Array.isArray(arr) || arr.length < 5) {\n    // Handle cases where array is too short for slice(0,3) and slice(-2)\n    // Or simply define expected behavior for short arrays.\n    return arr.slice(0, Math.min(arr.length, 3)).concat(100, arr.slice(Math.max(0, arr.length - 2)));\n  }\n  return arr.slice(0, 3).concat(100, arr.slice(-2));\n}\n\nconst originalArray = [1, 2, 3, 4, 5, 6, 7];\nconst newArray = processArray(originalArray);\n\nconsole.log('Original array:', originalArray); // Expected: [1, 2, 3, 4, 5, 6, 7]\nconsole.log('New array:', newArray);         // Expected: [1, 2, 3, 100, 6, 7]\n\nconst shortArray = [1, 2, 3];\nconst newShortArray = processArray(shortArray);\nconsole.log('Short original array:', shortArray); // Expected: [1, 2, 3]\nconsole.log('New short array:', newShortArray);   // Expected: [1, 2, 3, 100] (since slice(-2) returns [] if too short)\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `slice()` to extract parts of the array.",
            "Correctly uses `concat()` to combine segments and new elements.",
            "Ensures the original array is not mutated.",
            "Handles edge cases like arrays shorter than expected segments."
          ],
          "keyConcepts": [
            "slice",
            "concat",
            "non-mutation",
            "array chaining"
          ],
          "evaluationCriteria": [
            "Correct functionality",
            "Adherence to non-mutating constraint",
            "Efficiency (method chaining)",
            "Edge case handling"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Non-Mutation",
            "Chaining",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_modification_7",
          "topic": "Array Modification: Performance Considerations",
          "level": "hard",
          "type": "open",
          "question": "When frequently adding or removing elements from the beginning of a large array, `shift()` or `unshift()` can be inefficient. Why is this the case, and what alternative data structure or approach might be more suitable in JavaScript for such operations?",
          "answer": null,
          "analysisPoints": [
            "Explains the underlying reason for `shift`/`unshift` inefficiency (re-indexing).",
            "Suggests alternative data structures (e.g., linked list, `Deque` if available/simulated) or approaches (e.g., using `push`/`pop` with `reverse`, or maintaining two arrays for front/back).",
            "Demonstrates awareness of performance implications of array operations."
          ],
          "keyConcepts": [
            "shift",
            "unshift",
            "performance",
            "array re-indexing",
            "data structures"
          ],
          "evaluationCriteria": [
            "Depth of explanation",
            "Creativity and relevance of alternative solutions",
            "Understanding of performance trade-offs"
          ],
          "example": "When `shift()` or `unshift()` are used, JavaScript needs to re-index all subsequent elements in the array. For example, if you `shift()` an element from an array of 10,000 items, all 9,999 remaining elements need their indices updated, which is an O(N) operation. Similarly, `unshift()` requires shifting all existing elements to make space at the beginning.\n\nFor frequent operations at both ends, a **doubly linked list** would be more efficient, as adding/removing from ends would be O(1). In JavaScript, you'd typically implement a linked list yourself using objects. Alternatively, for queue-like behavior (FIFO), one might consider a fixed-size buffer or a system where `push` and `pop` are favored, perhaps by reversing the array conceptually or splitting it into two arrays (one for the head, one for the tail) and managing them, though this adds complexity. For many common frontend tasks, array sizes are small enough that the performance impact is negligible, but it's a critical consideration for large datasets or high-frequency operations.",
          "tags": [
            "Array Methods",
            "Performance",
            "Data Structures",
            "Open-Ended",
            "Hard"
          ],
          "prerequisites": [
            "javascript_arrays",
            "data_structures_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_searching_1",
          "topic": "Array Searching: indexOf vs includes vs find",
          "level": "medium",
          "type": "open",
          "question": "Describe the main use case for `indexOf()`, `includes()`, and `find()` methods. When would you choose one over the others, especially considering strict equality and custom comparison logic?",
          "answer": null,
          "analysisPoints": [
            "Explains `indexOf()` for finding the first index of a primitive value (strict equality, no custom logic).",
            "Explains `includes()` for simply checking existence of a primitive value (strict equality, handles NaN).",
            "Explains `find()` for finding the first element (object or primitive) that satisfies a custom condition (callback function).",
            "Provides scenarios where each method is most appropriate."
          ],
          "keyConcepts": [
            "indexOf",
            "includes",
            "find",
            "strict equality",
            "callback function",
            "primitive vs object"
          ],
          "evaluationCriteria": [
            "Clear differentiation of use cases",
            "Accuracy regarding comparison logic",
            "Practical applicability"
          ],
          "example": "1. **`indexOf(item, pos)`**: Use when you need the *index* of a specific primitive value. It uses strict equality (`===`) but doesn't handle `NaN` correctly (returns -1 for `NaN`).\n   *Example*: Finding the position of a specific string in an array of strings: `const idx = colors.indexOf('blue');`\n\n2. **`includes(value)`**: Use when you simply need to check if an array *contains* a specific primitive value. It's concise and handles `NaN` correctly. It also uses strict equality (`===`).\n   *Example*: Checking if a user's permissions array includes 'admin': `if (permissions.includes('admin')) { ... }`\n\n3. **`find(func)`**: Use when you need to find the *first element* that satisfies a *custom condition* defined by a callback function. This is essential for searching arrays of objects or when the search logic is more complex than simple equality.\n   *Example*: Finding the first product in an array of product objects that costs more than $100: `const expensiveProduct = products.find(p => p.price > 100);`\n\nChoose `find()` when you need complex logic or are dealing with objects. Choose `includes()` for simple existence checks of primitive values, especially if `NaN` might be involved. Choose `indexOf()` when you need the specific index of a primitive value and `NaN` is not a concern.",
          "tags": [
            "Array Methods",
            "Searching",
            "Higher-Order Functions",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions",
            "callback_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_searching_2",
          "topic": "Array Searching: find vs filter",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following array of users:\n```javascript\nconst users = [\n  { id: 1, name: 'Alice', active: true },\n  { id: 2, name: 'Bob', active: false },\n  { id: 3, name: 'Charlie', active: true }\n];\n```\nWhich method would you use if you want to get *all* active users, and what would be the expected output?",
          "answer": "`filter()`: `[{ id: 1, name: 'Alice', active: true }, { id: 3, name: 'Charlie', active: true }]`",
          "options": [
            "`find()`: `{ id: 1, name: 'Alice', active: true }`",
            "`map()`: `[true, false, true]`",
            "`filter()`: `[{ id: 1, name: 'Alice', active: true }, { id: 3, name: 'Charlie', active: true }]`",
            "`forEach()`: `undefined`"
          ],
          "analysisPoints": [
            "Understanding `filter()`'s purpose to return a new array of *all* matching elements.",
            "Distinguishing `filter()` from `find()` (which returns only the first).",
            "Understanding `map()`'s role in transformation, not filtering.",
            "Understanding `forEach()`'s role in iteration without returning a new array."
          ],
          "keyConcepts": [
            "filter",
            "find",
            "map",
            "forEach",
            "higher-order functions"
          ],
          "evaluationCriteria": [
            "Correct method selection",
            "Accurate prediction of output",
            "Understanding of method return values"
          ],
          "example": "The `filter()` method creates a new array with all elements that pass the test implemented by the provided function. Since the question asks for *all* active users, `filter()` is the appropriate method. `find()` would only return the *first* active user. `map()` transforms each element but doesn't filter them, and `forEach()` doesn't return a new array.",
          "tags": [
            "Array Methods",
            "Filtering",
            "Higher-Order Functions",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions",
            "callback_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_searching_3",
          "topic": "Array Searching: findIndex",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary use of `findIndex()` and what does it return if no element satisfies the condition?",
          "answer": "`findIndex()` is used to find the *index* of the first element in an array that satisfies a provided testing function. If no elements satisfy the condition, it returns `-1`.",
          "analysisPoints": [
            "Recall of `findIndex` purpose.",
            "Knowledge of its return value for non-matching elements."
          ],
          "keyConcepts": [
            "findIndex",
            "index",
            "callback function",
            "-1 return"
          ],
          "evaluationCriteria": [
            "Correctly identifies purpose.",
            "Correctly identifies return value on failure."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Searching",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_searching_4",
          "topic": "Array Searching: indexOf vs includes for NaN",
          "level": "medium",
          "type": "code",
          "question": "Demonstrate the behavior of `indexOf()` versus `includes()` when searching for `NaN` in an array. Explain why their behaviors differ.",
          "answer": "```typescript\nconst values = [1, 2, NaN, 4, 5];\n\nconsole.log('indexOf(NaN):', values.indexOf(NaN));   // Output: -1\nconsole.log('includes(NaN):', values.includes(NaN)); // Output: true\n\n/*\nExplanation:\n\n`indexOf()` uses strict equality (===) for comparison. In JavaScript, NaN is the only value that is not equal to itself (NaN !== NaN). Therefore, `indexOf()` cannot find NaN using strict equality, resulting in -1.\n\n`includes()` uses a different comparison algorithm, specifically the SameValueZero algorithm. This algorithm treats NaN as equal to NaN. Hence, `includes()` can correctly find NaN in an array and returns true if it exists.\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Correctly demonstrates `indexOf(NaN)` returning -1.",
            "Correctly demonstrates `includes(NaN)` returning true.",
            "Explains the underlying comparison mechanisms (`===` vs. SameValueZero)."
          ],
          "keyConcepts": [
            "indexOf",
            "includes",
            "NaN",
            "strict equality",
            "SameValueZero",
            "comparison"
          ],
          "evaluationCriteria": [
            "Accurate code demonstration",
            "Clear and correct explanation of underlying principles",
            "Understanding of JavaScript's `NaN` behavior"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Searching",
            "NaN",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_data_types",
            "javascript_equality"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_searching_5",
          "topic": "Array Searching: find vs filter return types",
          "level": "easy",
          "type": "mcq",
          "question": "What is the return type of `Array.prototype.find()` and `Array.prototype.filter()` respectively?",
          "answer": "`find()` returns the first matching element or `undefined`; `filter()` returns a new array of all matching elements.",
          "options": [
            "`find()` returns a new array; `filter()` returns a single element.",
            "`find()` returns the first matching element or `undefined`; `filter()` returns a new array of all matching elements.",
            "Both `find()` and `filter()` return a new array.",
            "Both `find()` and `filter()` return the first matching element."
          ],
          "analysisPoints": [
            "Knowledge of `find()`'s return value (element or undefined).",
            "Knowledge of `filter()`'s return value (new array).",
            "Understanding that `filter()` always returns an array, even if empty."
          ],
          "keyConcepts": [
            "find",
            "filter",
            "return type",
            "array vs element"
          ],
          "evaluationCriteria": [
            "Accurate return type identification",
            "Distinction between single element and array return"
          ],
          "example": "```typescript\nconst numbers = [10, 20, 30];\nconst found = numbers.find(n => n > 15); // found is 20 (a number)\nconst filtered = numbers.filter(n => n > 15); // filtered is [20, 30] (an array)\nconst notFound = numbers.find(n => n > 50); // notFound is undefined\nconst notFiltered = numbers.filter(n => n > 50); // notFiltered is [] (an empty array)\n```",
          "tags": [
            "Array Methods",
            "Searching",
            "Filtering",
            "MCQ",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_searching_6",
          "topic": "Array Searching: Using callback functions",
          "level": "medium",
          "type": "code",
          "question": "Given an array of objects representing books, write a JavaScript function that uses a suitable array method to find the first book published after the year 2000. If no such book exists, it should return `null`.\n\n```typescript\nconst books = [\n  { title: 'The Lord of the Rings', author: 'J.R.R. Tolkien', year: 1954 },\n  { title: 'Sapiens', author: 'Yuval Noah Harari', year: 2011 },\n  { title: 'Dune', author: 'Frank Herbert', year: 1965 },\n  { title: 'Educated', author: 'Tara Westover', year: 2018 }\n];\n```",
          "answer": "```typescript\nfunction findFirstModernBook(books) {\n  const modernBook = books.find(book => book.year > 2000);\n  return modernBook !== undefined ? modernBook : null;\n}\n\nconst books = [\n  { title: 'The Lord of the Rings', author: 'J.R.R. Tolkien', year: 1954 },\n  { title: 'Sapiens', author: 'Yuval Noah Harari', year: 2011 },\n  { title: 'Dune', author: 'Frank Herbert', year: 1965 },\n  { title: 'Educated', author: 'Tara Westover', year: 2018 }\n];\n\nconst firstModernBook = findFirstModernBook(books);\nconsole.log(firstModernBook); // Expected: { title: 'Sapiens', author: 'Yuval Noah Harari', year: 2011 }\n\nconst oldBooks = [\n  { title: '1984', author: 'George Orwell', year: 1949 },\n  { title: 'Brave New World', author: 'Aldous Huxley', year: 1932 }\n];\nconst noModernBook = findFirstModernBook(oldBooks);\nconsole.log(noModernBook); // Expected: null\n```",
          "options": [],
          "analysisPoints": [
            "Correct selection of `find()` for finding a single matching element.",
            "Proper implementation of the callback function with the condition.",
            "Correct handling of the `undefined` return from `find()` when no match is found, converting it to `null` as per requirements."
          ],
          "keyConcepts": [
            "find",
            "callback function",
            "object property access",
            "conditional logic"
          ],
          "evaluationCriteria": [
            "Correct array method usage",
            "Accurate conditional logic",
            "Correct return value for all cases"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Searching",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_iteration_transformation_1",
          "topic": "Array Iteration: forEach()",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the return value of `forEach()`, and when is it typically used?",
          "answer": "`forEach()` returns `undefined`. It's typically used when you need to iterate over an array and perform side effects (e.g., logging, DOM manipulation) for each element, without creating a new array or returning a value from the iteration itself.",
          "analysisPoints": [
            "Knowledge of `forEach`'s `undefined` return.",
            "Understanding of its primary use case (side effects)."
          ],
          "keyConcepts": [
            "forEach",
            "undefined",
            "side effects",
            "iteration"
          ],
          "evaluationCriteria": [
            "Accurate return value",
            "Correct use case explanation."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Iteration",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_transformation_2",
          "topic": "Array Transformation: map()",
          "level": "medium",
          "type": "mcq",
          "question": "Given the array `const numbers = [1, 2, 3];`, what will be the output of `numbers.map(num => num * 2);` and what will `numbers` itself be after this operation?",
          "answer": "Output: `[2, 4, 6]`; `numbers` will be `[1, 2, 3]`",
          "options": [
            "Output: `[1, 2, 3, 2, 4, 6]`; `numbers` will be `[1, 2, 3, 2, 4, 6]`",
            "Output: `[2, 4, 6]`; `numbers` will be `[2, 4, 6]`",
            "Output: `[2, 4, 6]`; `numbers` will be `[1, 2, 3]`",
            "Output: `undefined`; `numbers` will be `[1, 2, 3]`"
          ],
          "analysisPoints": [
            "Understanding that `map()` returns a *new* array.",
            "Knowing that `map()` does *not* mutate the original array.",
            "Correctly applying the transformation function to each element."
          ],
          "keyConcepts": [
            "map",
            "non-mutation",
            "new array",
            "transformation"
          ],
          "evaluationCriteria": [
            "Correctly identifies transformation result",
            "Accurately assesses original array state",
            "Understands non-mutating behavior"
          ],
          "example": "The `map()` method creates a *new array* populated with the results of calling a provided function on every element in the calling array. It does not modify the original array. So, `numbers` remains `[1, 2, 3]`, and a new array `[2, 4, 6]` is returned.",
          "tags": [
            "Array Methods",
            "Transformation",
            "Non-Mutation",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_iteration_transformation_3",
          "topic": "Array Transformation: sort()",
          "level": "medium",
          "type": "open",
          "question": "Explain how `sort()` works by default on an array of numbers (e.g., `[10, 2, 1, 20]`). Then, provide the correct way to numerically sort this array in ascending order.",
          "answer": null,
          "analysisPoints": [
            "Explains default `sort()` behavior (string conversion, UTF-16 comparison).",
            "Provides the correct comparison function `(a, b) => a - b` for numeric ascending sort.",
            "Demonstrates the correct code example and expected output."
          ],
          "keyConcepts": [
            "sort",
            "in-place mutation",
            "comparison function",
            "string comparison",
            "numeric sort"
          ],
          "evaluationCriteria": [
            "Accurate explanation of default sort",
            "Correct comparison function for numeric sort",
            "Clear code example"
          ],
          "example": "By default, the `sort()` method sorts elements as strings in ascending order. This means that numbers are converted to strings and then compared based on their Unicode code points. For example, `[10, 2, 1, 20]` would be sorted as `[1, 10, 2, 20]` because '1' comes before '2' and '10' comes before '20' lexicographically.\n\nTo sort numerically in ascending order, you must provide a comparison function. This function takes two arguments (`a` and `b`) and should return:\n- A negative value if `a` should come before `b`\n- A positive value if `b` should come before `a`\n- `0` if `a` and `b` are considered equal.\n\nFor ascending numeric sort, `(a, b) => a - b` is used:\n```typescript\nconst numbers = [10, 2, 1, 20];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers); // Output: [1, 2, 10, 20]\n```",
          "tags": [
            "Array Methods",
            "Sorting",
            "Mutation",
            "Comparison Function",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_iteration_transformation_4",
          "topic": "String-Array Conversion: split() and join()",
          "level": "easy",
          "type": "flashcard",
          "question": "How do `split()` and `join()` methods facilitate conversion between strings and arrays?",
          "answer": "`split()` (a String method) converts a string into an array of substrings based on a specified separator. `join()` (an Array method) converts an array of elements into a string, using a specified separator to concatenate them.",
          "analysisPoints": [
            "Understanding of `split` (string to array).",
            "Understanding of `join` (array to string).",
            "Recognition of the role of the separator argument."
          ],
          "keyConcepts": [
            "split",
            "join",
            "string to array",
            "array to string",
            "separator"
          ],
          "evaluationCriteria": [
            "Correctly describes conversion direction",
            "Mentions separator use"
          ],
          "example": null,
          "tags": [
            "String Methods",
            "Array Methods",
            "Conversion",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_strings"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_transformation_5",
          "topic": "Array Transformation: reduce()",
          "level": "hard",
          "type": "code",
          "question": "Using the `reduce()` method, write a function `groupObjectsByProperty(arr, propName)` that takes an array of objects and a property name (string), and returns an object where keys are unique values of `propName` and values are arrays of objects that share that `propName` value.\n\nExample Input:\n```typescript\nconst products = [\n  { id: 1, category: 'Electronics', name: 'Laptop' },\n  { id: 2, category: 'Books', name: 'Sapiens' },\n  { id: 3, category: 'Electronics', name: 'Mouse' },\n  { id: 4, category: 'Books', name: 'Dune' },\n  { id: 5, category: 'Home', name: 'Lamp' }\n];\n```\nExpected Output for `groupObjectsByProperty(products, 'category')`:\n```json\n{\n  \"Electronics\": [\n    { \"id\": 1, \"category\": \"Electronics\", \"name\": \"Laptop\" },\n    { \"id\": 3, \"category\": \"Electronics\", \"name\": \"Mouse\" }\n  ],\n  \"Books\": [\n    { \"id\": 2, \"category\": \"Books\", \"name\": \"Sapiens\" },\n    { \"id\": 4, \"category\": \"Books\", \"name\": \"Dune\" }\n  ],\n  \"Home\": [\n    { \"id\": 5, \"category\": \"Home\", \"name\": \"Lamp\" }\n  ]\n}\n```",
          "answer": "```typescript\nfunction groupObjectsByProperty(arr, propName) {\n  if (!Array.isArray(arr) || typeof propName !== 'string') {\n    throw new Error('Invalid input: arr must be an array, propName a string.');\n  }\n\n  return arr.reduce((accumulator, currentObject) => {\n    const key = currentObject[propName];\n    if (key === undefined) {\n      // Handle objects missing the property or null/undefined values\n      // For this problem, we'll just skip them or group under a special key\n      // For simplicity, let's just skip for now, or you could group them under 'other' or similar\n      return accumulator; \n    }\n\n    if (!accumulator[key]) {\n      accumulator[key] = []; // Initialize array for this category if it doesn't exist\n    }\n    accumulator[key].push(currentObject); // Add the current object to its category's array\n    return accumulator;\n  }, {}); // Initial accumulator is an empty object\n}\n\nconst products = [\n  { id: 1, category: 'Electronics', name: 'Laptop' },\n  { id: 2, category: 'Books', name: 'Sapiens' },\n  { id: 3, category: 'Electronics', name: 'Mouse' },\n  { id: 4, category: 'Books', name: 'Dune' },\n  { id: 5, category: 'Home', name: 'Lamp' }\n];\n\nconst groupedByCategory = groupObjectsByProperty(products, 'category');\nconsole.log(JSON.stringify(groupedByCategory, null, 2));\n\nconst groupedById = groupObjectsByProperty(products, 'id');\nconsole.log(JSON.stringify(groupedById, null, 2));\n\nconst invalidProducts = [\n  { id: 1, category: 'Electronics', name: 'Laptop' },\n  { id: 2, name: 'Sapiens' } // Missing category\n];\n// console.log(groupObjectsByProperty(invalidProducts, 'category')); // This would skip the second item due to 'undefined' key handling\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `reduce()` to build an object.",
            "Initializes the accumulator as an empty object (`{}`).",
            "Accesses object properties dynamically using bracket notation (`currentObject[propName]`).",
            "Checks if the category array exists (`!accumulator[key]`) before pushing, creating it if necessary.",
            "Adds the `currentObject` to the correct category array.",
            "Returns the `accumulator` in each iteration."
          ],
          "keyConcepts": [
            "reduce",
            "object grouping",
            "dynamic property access",
            "accumulator",
            "callback function"
          ],
          "evaluationCriteria": [
            "Correct algorithm for grouping",
            "Effective use of `reduce`",
            "Handling of object properties",
            "Robustness (e.g., input validation/missing property handling)"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Reduce",
            "Object Transformation",
            "Code Challenge",
            "Hard",
            "Data Structures"
          ],
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_iteration_transformation_6",
          "topic": "Array Transformation: Chaining methods",
          "level": "hard",
          "type": "code",
          "question": "Given an array of numbers, write a JavaScript function `processNumbers(numbers)` that uses chaining of `filter()`, `map()`, and `reduce()` to perform the following operations:\n1. Filter out all numbers less than or equal to `50`.\n2. Double the remaining numbers.\n3. Calculate the sum of the doubled numbers.",
          "answer": "```typescript\nfunction processNumbers(numbers) {\n  if (!Array.isArray(numbers)) {\n    throw new Error('Input must be an array of numbers.');\n  }\n\n  return numbers\n    .filter(num => num > 50)  // Step 1: Filter numbers > 50\n    .map(num => num * 2)     // Step 2: Double the remaining numbers\n    .reduce((sum, num) => sum + num, 0); // Step 3: Sum the doubled numbers\n}\n\nconst inputNumbers = [10, 60, 30, 80, 40, 90, 50, 70];\nconst result = processNumbers(inputNumbers);\nconsole.log('Processed sum:', result); // Expected: (60*2 + 80*2 + 90*2 + 70*2) = (120 + 160 + 180 + 140) = 600\n\nconst emptyArray = [];\nconsole.log('Empty array sum:', processNumbers(emptyArray)); // Expected: 0\n\nconst allSmallNumbers = [1, 2, 3];\nconsole.log('All small numbers sum:', processNumbers(allSmallNumbers)); // Expected: 0\n```",
          "options": [],
          "analysisPoints": [
            "Correctly chains `filter`, `map`, and `reduce` in the specified order.",
            "Implements the correct callback for each method (`num > 50`, `num * 2`, `sum + num`).",
            "Provides an initial value for `reduce` to handle empty arrays correctly.",
            "Ensures input validation."
          ],
          "keyConcepts": [
            "filter",
            "map",
            "reduce",
            "chaining",
            "higher-order functions",
            "functional programming"
          ],
          "evaluationCriteria": [
            "Correct method chaining",
            "Accurate implementation of steps",
            "Robustness (empty/edge cases)",
            "Functional approach"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Chaining",
            "Filter",
            "Map",
            "Reduce",
            "Code Challenge",
            "Hard"
          ],
          "prerequisites": [
            "javascript_functions",
            "callback_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_iteration_transformation_7",
          "topic": "Array Transformation: reverse() behavior",
          "level": "easy",
          "type": "mcq",
          "question": "What is the result of the following code snippet?\n```javascript\nconst arr = ['a', 'b', 'c'];\nconst reversedArr = arr.reverse();\nconsole.log(arr);\nconsole.log(reversedArr);\n```",
          "answer": "Both `arr` and `reversedArr` will be `['c', 'b', 'a']`.",
          "options": [
            "`arr` will be `['a', 'b', 'c']` and `reversedArr` will be `['c', 'b', 'a']`.",
            "`arr` will be `['c', 'b', 'a']` and `reversedArr` will be `['a', 'b', 'c']`.",
            "Both `arr` and `reversedArr` will be `['c', 'b', 'a']`.",
            "An error will occur because `reverse()` cannot be assigned to a new variable."
          ],
          "analysisPoints": [
            "Understanding that `reverse()` mutates the original array.",
            "Knowing that `reverse()` returns a reference to the *same* mutated array."
          ],
          "keyConcepts": [
            "reverse",
            "array mutation",
            "return value",
            "reference"
          ],
          "evaluationCriteria": [
            "Correctly identifies mutation",
            "Correctly identifies return value as reference"
          ],
          "example": "The `reverse()` method reverses the array in-place, meaning it modifies the original array directly. It also returns a reference to the *same* array that was reversed. Therefore, both `arr` and `reversedArr` will point to the same array object, which has been modified to `['c', 'b', 'a']`.",
          "tags": [
            "Array Methods",
            "Mutation",
            "MCQ",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_transformation_8",
          "topic": "Array Transformation: Difference between map and forEach",
          "level": "medium",
          "type": "open",
          "question": "When would you prefer to use `map()` over `forEach()` for iterating over an array, and vice versa? Provide examples.",
          "answer": null,
          "analysisPoints": [
            "Clearly distinguishes `map` for transformation (returning new array) vs. `forEach` for side effects (no return value).",
            "Provides suitable examples for each scenario.",
            "Discusses impact on immutability/functional programming paradigms."
          ],
          "keyConcepts": [
            "map",
            "forEach",
            "transformation",
            "side effects",
            "immutability",
            "return value"
          ],
          "evaluationCriteria": [
            "Clear explanation of distinction",
            "Appropriate examples for each method",
            "Understanding of functional programming implications"
          ],
          "example": "**Use `map()` when you need to transform each element in an array and get a *new array* containing the transformed elements.** It's ideal for scenarios where you want to produce a new array based on the existing one without altering the original.\n\n*Example for `map()`: Doubling numbers*\n```typescript\nconst numbers = [1, 2, 3];\nconst doubledNumbers = numbers.map(num => num * 2);\nconsole.log(doubledNumbers); // [2, 4, 6]\nconsole.log(numbers);       // [1, 2, 3] (original remains unchanged)\n```\n\n**Use `forEach()` when you need to iterate over an array and perform a *side effect* for each element, and you don't need a new array as a result.** It returns `undefined`, so it's not suitable for chaining transformations.\n\n*Example for `forEach()`: Logging elements or updating UI*\n```typescript\nconst names = ['Alice', 'Bob', 'Charlie'];\nnames.forEach(name => {\n  console.log(`Hello, ${name}!`); // Side effect: logs to console\n});\n// No return value, names array is not modified\n```",
          "tags": [
            "Array Methods",
            "Map",
            "ForEach",
            "Transformation",
            "Iteration",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_additional_array_1",
          "topic": "Array Utilities: Array.isArray()",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is `Array.isArray()` generally preferred over `typeof arr === 'object' && arr !== null` or `arr instanceof Array` for checking if a variable is an array?",
          "answer": "`Array.isArray()` is preferred because `typeof []` returns 'object', and `instanceof Array` might fail across different JavaScript realms (e.g., iframes) where arrays are created in different global contexts. `Array.isArray()` provides a robust and reliable check.",
          "analysisPoints": [
            "Understanding limitations of `typeof` for arrays.",
            "Understanding limitations of `instanceof` across realms.",
            "Knowing `Array.isArray`'s reliability."
          ],
          "keyConcepts": [
            "Array.isArray",
            "typeof",
            "instanceof",
            "array type checking",
            "javascript realms"
          ],
          "evaluationCriteria": [
            "Correctly identifies `typeof` and `instanceof` issues",
            "Explains `Array.isArray` robustness"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Type Checking",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_operators",
            "javascript_context"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_additional_array_2",
          "topic": "Array Utilities: some() vs every()",
          "level": "medium",
          "type": "mcq",
          "question": "Given the array `const temperatures = [22, 25, 18, 20, 23];` which of the following expressions would return `true`?\n\nI. `temperatures.some(temp => temp > 25)`\nII. `temperatures.every(temp => temp >= 18)`\nIII. `temperatures.every(temp => temp < 20)`\nIV. `temperatures.some(temp => temp === 18)`",
          "answer": "II and IV",
          "options": [
            "I and III",
            "II and IV",
            "I, II and IV",
            "All of them"
          ],
          "analysisPoints": [
            "Understanding `some()`'s 'at least one' condition.",
            "Understanding `every()`'s 'all' condition.",
            "Applying the conditions correctly to the given array elements."
          ],
          "keyConcepts": [
            "some",
            "every",
            "callback function",
            "conditional logic"
          ],
          "evaluationCriteria": [
            "Correctly applies boolean logic of `some` and `every`",
            "Accurate evaluation of expressions"
          ],
          "example": "I. `temperatures.some(temp => temp > 25)`: `false` (no temperature is strictly greater than 25)\nII. `temperatures.every(temp => temp >= 18)`: `true` (all temperatures are greater than or equal to 18)\nIII. `temperatures.every(temp => temp < 20)`: `false` (22, 25, 20, 23 are not less than 20)\nIV. `temperatures.some(temp => temp === 18)`: `true` (18 exists in the array)\n\nTherefore, II and IV are the correct expressions that return `true`.",
          "tags": [
            "Array Methods",
            "Conditional Logic",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "javascript_booleans",
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_additional_array_3",
          "topic": "Array Utilities: fill()",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `fill()` method, and does it modify the original array?",
          "answer": "The `fill()` method fills all the elements of an array from a start index to an end index with a static value. Yes, it modifies the original array in-place.",
          "analysisPoints": [
            "Knowledge of `fill`'s purpose (mass assignment).",
            "Recognition of its mutating behavior."
          ],
          "keyConcepts": [
            "fill",
            "array mutation",
            "in-place",
            "range"
          ],
          "evaluationCriteria": [
            "Correctly states purpose",
            "Correctly identifies mutation"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Mutation",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_additional_array_4",
          "topic": "Array Utilities: copyWithin()",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where `copyWithin()` might be a useful method. Explain its parameters (`target`, `start`, `end`) and provide a code example that demonstrates its use in your scenario.",
          "answer": null,
          "analysisPoints": [
            "Provides a realistic use case for `copyWithin` (e.g., circular buffers, shifting elements efficiently).",
            "Clearly explains each parameter.",
            "Demonstrates a functional code example for the described scenario."
          ],
          "keyConcepts": [
            "copyWithin",
            "in-place mutation",
            "target index",
            "start index",
            "end index",
            "array segments"
          ],
          "evaluationCriteria": [
            "Plausible scenario",
            "Accurate parameter explanation",
            "Correct and illustrative code example"
          ],
          "example": "Scenario: Implementing a simple circular buffer or a fixed-size queue where old elements are overwritten by new ones in a cyclical manner, or efficiently shifting a segment of an array without creating a new one.\n\nLet's say you have an array representing slots in a game, and you want to 'shift' elements to the left, effectively removing the first few elements and filling their space with subsequent elements, much like a memory compacting operation for a fixed-size buffer.\n\nParameters:\n- **`target`**: The zero-based index at which to copy the sequence to. This is where the copied elements will start being placed.\n- **`start`**: The zero-based index at which to start copying elements from (inclusive). This marks the beginning of the segment you want to copy.\n- **`end`**: The zero-based index at which to end copying elements from (exclusive). This marks the end of the segment you want to copy. If omitted, it copies to the end of the array.\n\nCode Example: Simulating a shift of elements to the left within a fixed-size array.\n```typescript\nlet buffer = ['A', 'B', 'C', 'D', 'E', 'F'];\n\n// Imagine 'A' and 'B' are processed and we want to shift 'C', 'D', 'E', 'F' to the beginning\n// and mark the last two positions as empty.\n\n// We want to copy elements from index 2 ('C') to index 6 (end of array, 'F')\n// and place them starting at index 0.\nbuffer.copyWithin(0, 2, 6); // copies ['C', 'D', 'E', 'F'] to indices 0, 1, 2, 3\n\nconsole.log(buffer); // Output: ['C', 'D', 'E', 'F', 'E', 'F']\n\n// Now, to truly 'remove' the last elements (make them empty or null), we could fill them:\nbuffer.fill(null, 4); // Fills from index 4 to end with null\nconsole.log(buffer); // Output: ['C', 'D', 'E', 'F', null, null]\n```\nThis demonstrates how `copyWithin` efficiently shifts data blocks in-place.",
          "tags": [
            "Array Methods",
            "copyWithin",
            "Mutation",
            "In-place",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 7,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_additional_array_5",
          "topic": "Array Utilities: Chaining some() and every()",
          "level": "hard",
          "type": "code",
          "question": "Write a function `validateFormFields(fields)` that takes an array of objects, where each object represents a form field and has `name` (string) and `value` (string) properties. The function should return `true` if *all* fields have a non-empty `name` AND *at least one* field has a non-empty `value`. Otherwise, it should return `false`.\n\n```typescript\nconst validFields = [\n  { name: 'username', value: 'john_doe' },\n  { name: 'email', value: '' },\n  { name: 'password', value: 'secure123' }\n];\n\nconst invalidName = [\n  { name: '', value: 'test' }\n];\n\nconst noValue = [\n  { name: 'username', value: '' },\n  { name: 'email', value: '' }\n];\n```",
          "answer": "```typescript\nfunction validateFormFields(fields) {\n  if (!Array.isArray(fields) || fields.length === 0) {\n    return false; // An empty array or non-array input is invalid\n  }\n\n  // Check if all fields have a non-empty name\n  const allNamesValid = fields.every(field => \n    typeof field.name === 'string' && field.name.trim() !== ''\n  );\n\n  // Check if at least one field has a non-empty value\n  const atLeastOneValueValid = fields.some(field => \n    typeof field.value === 'string' && field.value.trim() !== ''\n  );\n\n  return allNamesValid && atLeastOneValueValid;\n}\n\nconst validFields = [\n  { name: 'username', value: 'john_doe' },\n  { name: 'email', value: '' },\n  { name: 'password', value: 'secure123' }\n];\nconsole.log('Valid fields (expected true):', validateFormFields(validFields)); // true\n\nconst invalidName = [\n  { name: '', value: 'test' }\n];\nconsole.log('Invalid name (expected false):', validateFormFields(invalidName)); // false\n\nconst noValue = [\n  { name: 'username', value: '' },\n  { name: 'email', value: '' }\n];\nconsole.log('No value (expected false):', validateFormFields(noValue)); // false\n\nconst emptyInput = [];\nconsole.log('Empty input (expected false):', validateFormFields(emptyInput)); // false\n\nconst allValid = [\n  { name: 'name1', value: 'val1' },\n  { name: 'name2', value: 'val2' }\n];\nconsole.log('All valid (expected true):', validateFormFields(allValid)); // true\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies and uses `every()` for the 'all fields have a non-empty name' condition.",
            "Correctly identifies and uses `some()` for the 'at least one field has a non-empty value' condition.",
            "Combines the two boolean results with a logical AND (`&&`).",
            "Handles edge cases like empty arrays and checks for string type and `trim()` for empty strings.",
            "Demonstrates understanding of higher-order function composition."
          ],
          "keyConcepts": [
            "some",
            "every",
            "callback function",
            "logical operators",
            "string methods",
            "validation"
          ],
          "evaluationCriteria": [
            "Correct logical implementation",
            "Appropriate use of `some` and `every`",
            "Robustness with edge cases",
            "Clarity of code"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Conditional Logic",
            "Code Challenge",
            "Hard",
            "Validation"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_strings"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_additional_array_6",
          "topic": "Array Utilities: Mutating methods summary",
          "level": "medium",
          "type": "flashcard",
          "question": "List at least five common array methods that modify the original array (mutate it) in JavaScript.",
          "answer": "Common array methods that mutate the original array include: `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `sort()`, `reverse()`, `fill()`, `copyWithin()`.",
          "analysisPoints": [
            "Recall of mutating methods.",
            "Distinction between mutating and non-mutating methods."
          ],
          "keyConcepts": [
            "mutation",
            "in-place",
            "array methods"
          ],
          "evaluationCriteria": [
            "Correctly identifies at least five mutating methods."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Mutation",
            "Flashcard",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_mutating_vs_non_mutating_1",
          "topic": "Mutating vs. Non-Mutating Methods: Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the fundamental difference between a 'mutating' and a 'non-mutating' array method?",
          "answer": "A 'mutating' method directly changes the original array on which it is called, while a 'non-mutating' method does not change the original array; instead, it returns a new array with the results of the operation.",
          "analysisPoints": [
            "Definition of mutation.",
            "Definition of non-mutation (immutability).",
            "Impact on the original array."
          ],
          "keyConcepts": [
            "mutation",
            "non-mutation",
            "immutability",
            "side effects"
          ],
          "evaluationCriteria": [
            "Clear and concise definition of both types."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Mutation",
            "Immutability",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_variables",
            "javascript_references"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_mutating_vs_non_mutating_2",
          "topic": "Mutating vs. Non-Mutating Methods: Practical Impact",
          "level": "medium",
          "type": "open",
          "question": "Why is it important for a frontend developer to understand the distinction between mutating and non-mutating array methods, especially in the context of state management in libraries like React?",
          "answer": null,
          "analysisPoints": [
            "Connects mutation to unexpected side effects and debugging difficulties.",
            "Explains how immutable updates are crucial for React's reconciliation process (shallow comparison).",
            "Discusses how direct mutation can prevent components from re-rendering when state changes, leading to UI bugs.",
            "Mentions the concept of predictable state changes."
          ],
          "keyConcepts": [
            "mutation",
            "immutability",
            "react state",
            "reconciliation",
            "side effects",
            "debugging",
            "predictable state"
          ],
          "evaluationCriteria": [
            "Demonstrates understanding of React's state update mechanism",
            "Explains the impact on component re-renders",
            "Connects to broader software engineering principles (predictability)"
          ],
          "example": "In libraries like React, state updates are often managed with the expectation that state objects and arrays are treated immutably. When you mutate an array directly (e.g., using `push` or `splice`) instead of creating a new one (e.g., using `map` or `slice` with spread syntax), React's shallow comparison in its reconciliation process might not detect a change because the reference to the array object remains the same. This can lead to:\n\n1.  **Missed Rerenders**: Components depending on that array state won't re-render, leading to a stale UI.\n2.  **Unpredictable Bugs**: It becomes harder to track when and where state was modified, leading to harder-to-debug issues.\n3.  **Performance Issues**: If manual re-renders are forced, it bypasses React's optimized update flow.\n\nBy consistently using non-mutating methods, developers ensure that a new reference is created whenever the array data changes, allowing React to efficiently detect the change and trigger necessary re-renders. This promotes predictable state management and easier debugging.",
          "tags": [
            "Array Methods",
            "Mutation",
            "Immutability",
            "React",
            "State Management",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "react_basics",
            "state_management_concepts"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_mutating_vs_non_mutating_3",
          "topic": "Mutating vs. Non-Mutating Methods: Identifying Mutating Methods",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following array methods modifies the original array directly?",
          "answer": "`splice()`",
          "options": [
            "`map()`",
            "`filter()`",
            "`slice()`",
            "`splice()`"
          ],
          "analysisPoints": [
            "Identifies `splice()` as a mutating method.",
            "Differentiates it from non-mutating methods like `map`, `filter`, and `slice`."
          ],
          "keyConcepts": [
            "mutation",
            "non-mutation",
            "splice",
            "map",
            "filter",
            "slice"
          ],
          "evaluationCriteria": [
            "Correctly identifies the mutating method."
          ],
          "example": "The `splice()` method is designed to change the contents of an array by removing or replacing existing elements and/or adding new elements *in place*. `map()`, `filter()`, and `slice()` all return new arrays, leaving the original array unchanged.",
          "tags": [
            "Array Methods",
            "Mutation",
            "MCQ",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_mutating_vs_non_mutating_4",
          "topic": "Mutating vs. Non-Mutating Methods: Safe Array Update",
          "level": "medium",
          "type": "code",
          "question": "You have an array of user objects. You need to update the `age` of a user with a specific `id` without mutating the original `users` array. Write a function `updateUserAge(users, userId, newAge)` that returns a *new* array with the updated user, or the original array if the user is not found. Use non-mutating methods.\n\n```typescript\nconst users = [\n  { id: 1, name: 'Alice', age: 30 },\n  { id: 2, name: 'Bob', age: 25 },\n  { id: 3, name: 'Charlie', age: 35 }\n];\n```",
          "answer": "```typescript\nfunction updateUserAge(users, userId, newAge) {\n  const userIndex = users.findIndex(user => user.id === userId);\n\n  if (userIndex === -1) {\n    return users; // User not found, return original array\n  }\n\n  // Create a new array and update the specific user object immutably\n  return users.map((user, index) => {\n    if (index === userIndex) {\n      return { ...user, age: newAge }; // Create new user object with updated age\n    } else {\n      return user; // Return original user object for others\n    }\n  });\n}\n\nconst users = [\n  { id: 1, name: 'Alice', age: 30 },\n  { id: 2, name: 'Bob', age: 25 },\n  { id: 3, name: 'Charlie', age: 35 }\n];\n\nconst updatedUsers1 = updateUserAge(users, 2, 26);\nconsole.log('Original users:', users); // Expected: [{ id: 1, name: 'Alice', age: 30 }, { id: 2, name: 'Bob', age: 25 }, { id: 3, name: 'Charlie', age: 35 }]\nconsole.log('Updated users 1:', updatedUsers1); // Expected: [{ id: 1, name: 'Alice', age: 30 }, { id: 2, name: 'Bob', age: 26 }, { id: 3, name: 'Charlie', age: 35 }]\nconsole.log('Are arrays same reference?', users === updatedUsers1); // Expected: false\n\nconst updatedUsers2 = updateUserAge(users, 99, 40); // User not found\nconsole.log('Updated users 2 (user not found):', updatedUsers2); // Expected: original users array\nconsole.log('Are arrays same reference (user not found)?', users === updatedUsers2); // Expected: true\n```",
          "options": [],
          "analysisPoints": [
            "Uses `findIndex` to locate the user's index.",
            "Uses `map` to create a *new* array, ensuring non-mutation.",
            "Uses object spread syntax (`...user`) to create a *new* user object for the updated item, ensuring that individual objects within the array are also updated immutably.",
            "Handles the case where the user is not found by returning the original array reference.",
            "Demonstrates understanding of both array and object immutability."
          ],
          "keyConcepts": [
            "map",
            "findIndex",
            "immutability",
            "object spread",
            "array iteration",
            "functional programming"
          ],
          "evaluationCriteria": [
            "Adherence to non-mutation",
            "Correct functional implementation",
            "Handling of found/not-found scenarios",
            "Efficiency of chosen methods"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Immutability",
            "State Management",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_mutating_vs_non_mutating_5",
          "topic": "Mutating vs. Non-Mutating Methods: Identify Non-Mutating Methods",
          "level": "medium",
          "type": "flashcard",
          "question": "List at least five common array methods that do *not* modify the original array (are non-mutating) in JavaScript.",
          "answer": "Common non-mutating array methods include: `slice()`, `concat()`, `map()`, `filter()`, `reduce()`, `indexOf()`, `lastIndexOf()`, `includes()`, `find()`, `findIndex()`, `forEach()`, `some()`, `every()`.",
          "analysisPoints": [
            "Recall of non-mutating methods.",
            "Distinction between mutating and non-mutating methods."
          ],
          "keyConcepts": [
            "non-mutation",
            "new array",
            "array methods"
          ],
          "evaluationCriteria": [
            "Correctly identifies at least five non-mutating methods."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Non-Mutation",
            "Immutability",
            "Flashcard",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_array_modification_1",
          "title": "Implement a Basic Todo List Manager",
          "description": "\nImplement a `TodoList` class with methods to manage tasks. You must use appropriate array modification methods for adding and removing tasks. The tasks are simple strings.\n\n**Requirements:**\n1.  `constructor()`: Initializes an empty array for tasks.\n2.  `addTask(task)`: Adds a new task to the end of the list. Returns the new total number of tasks.\n3.  `removeTask(task)`: Removes the first occurrence of a specific task from the list. Returns `true` if the task was found and removed, `false` otherwise.\n4.  `getTasks()`: Returns a *copy* of the current task list to prevent external modification.\n5.  `clearTasks()`: Removes all tasks from the list.\n",
          "difficulty": "medium",
          "startingCode": "class TodoList {\n  constructor() {\n    // TODO: Initialize tasks array\n  }\n\n  addTask(task) {\n    // TODO: Add task to the end, return new length\n  }\n\n  removeTask(task) {\n    // TODO: Find and remove the first occurrence of the task\n    // Hint: Consider indexOf and splice\n  }\n\n  getTasks() {\n    // TODO: Return a copy of the tasks array\n  }\n\n  clearTasks() {\n    // TODO: Remove all tasks\n  }\n}\n",
          "solutionCode": "class TodoList {\n  constructor() {\n    this.tasks = [];\n  }\n\n  addTask(task) {\n    return this.tasks.push(task);\n  }\n\n  removeTask(task) {\n    const index = this.tasks.indexOf(task);\n    if (index > -1) {\n      this.tasks.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  getTasks() {\n    // Return a shallow copy to prevent direct mutation of the internal array\n    return this.tasks.slice(); \n  }\n\n  clearTasks() {\n    // Option 1: Reassigning an empty array (common, effectively non-mutating for the *reference* but clears contents)\n    // this.tasks = []; \n    \n    // Option 2: Mutating the array to empty it in-place (if the reference must remain the same)\n    this.tasks.splice(0, this.tasks.length); \n  }\n}\n\n// Example Usage:\nconst myTodoList = new TodoList();\nconsole.log(\"Add task 'Buy groceries':\", myTodoList.addTask('Buy groceries')); // 1\nconsole.log(\"Add task 'Do laundry':\", myTodoList.addTask('Do laundry'));   // 2\nconsole.log(\"Current tasks:\", myTodoList.getTasks()); // ['Buy groceries', 'Do laundry']\n\nconsole.log(\"Remove 'Buy groceries':\", myTodoList.removeTask('Buy groceries')); // true\nconsole.log(\"Current tasks:\", myTodoList.getTasks()); // ['Do laundry']\n\nconsole.log(\"Remove non-existent task 'Walk dog':\", myTodoList.removeTask('Walk dog')); // false\nconsole.log(\"Current tasks:\", myTodoList.getTasks()); // ['Do laundry']\n\nmyTodoList.addTask('Pay bills');\nconsole.log(\"Tasks before clear:\", myTodoList.getTasks());\nmyTodoList.clearTasks();\nconsole.log(\"Tasks after clear:\", myTodoList.getTasks()); // []\n\nmyTodoList.addTask('Study Arrays');\nconsole.log(\"After re-add:\", myTodoList.getTasks());\n",
          "testCases": [
            "TodoList should initialize with an empty tasks array.",
            "addTask should correctly add tasks and return the new length.",
            "removeTask should remove the first occurrence and return true, and false for non-existent tasks.",
            "getTasks should return a new array (copy) and not the internal reference.",
            "clearTasks should empty the tasks array.",
            "Adding and removing tasks multiple times should maintain correct state."
          ],
          "hints": [
            "For `addTask`, `push()` is the most straightforward method.",
            "For `removeTask`, you'll likely need `indexOf()` to find the task's position and `splice()` to remove it.",
            "Remember that `slice()` without arguments creates a shallow copy of an array.",
            "To clear an array, `splice(0, array.length)` is one effective in-place method."
          ],
          "tags": [
            "Array Methods",
            "Classes",
            "Data Structure",
            "Mutation",
            "Frontend Interview",
            "Basic"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_classes",
            "javascript_arrays"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "push",
            "pop",
            "splice",
            "slice",
            "indexOf"
          ]
        },
        {
          "id": "task_array_modification_2",
          "title": "Implement an Immutable Array Manipulator",
          "description": "\nCreate a set of utility functions to perform common array manipulations, ensuring that all functions return *new arrays* and never modify the original input array. This is crucial for applications that rely on immutability.\n\n**Requirements:**\n1.  `prepend(arr, element)`: Returns a new array with `element` added to the beginning of `arr`.\n2.  `append(arr, element)`: Returns a new array with `element` added to the end of `arr`.\n3.  `removeAtIndex(arr, index)`: Returns a new array with the element at `index` removed. Should handle invalid indices gracefully (e.g., return original array).\n4.  `insertAtIndex(arr, index, element)`: Returns a new array with `element` inserted at `index`. Should handle invalid indices gracefully (e.g., insert at end if index too large, beginning if index too small).\n",
          "difficulty": "medium",
          "startingCode": "function prepend(arr, element) {\n  // TODO: Implement using non-mutating methods\n}\n\nfunction append(arr, element) {\n  // TODO: Implement using non-mutating methods\n}\n\nfunction removeAtIndex(arr, index) {\n  // TODO: Implement using non-mutating methods\n}\n\nfunction insertAtIndex(arr, index, element) {\n  // TODO: Implement using non-mutating methods\n}\n",
          "solutionCode": "function prepend(arr, element) {\n  // Use concat or spread syntax\n  return [element].concat(arr);\n  // return [element, ...arr];\n}\n\nfunction append(arr, element) {\n  // Use concat or spread syntax\n  return arr.concat(element);\n  // return [...arr, element];\n}\n\nfunction removeAtIndex(arr, index) {\n  if (!Array.isArray(arr) || index < 0 || index >= arr.length) {\n    return arr; // Return original array if index is out of bounds or invalid input\n  }\n  // Use slice to get parts before and after the removed element, then concat\n  return arr.slice(0, index).concat(arr.slice(index + 1));\n}\n\nfunction insertAtIndex(arr, index, element) {\n  if (!Array.isArray(arr)) {\n    return arr; // Return original array if invalid input\n  }\n  // Normalize index for inserting at beginning or end if out of bounds\n  const normalizedIndex = Math.max(0, Math.min(index, arr.length));\n  \n  // Use slice to get parts, then concat with the new element in between\n  return arr.slice(0, normalizedIndex).concat(element, arr.slice(normalizedIndex));\n}\n\n// Test Cases:\nconst original = [1, 2, 3, 4, 5];\n\nconsole.log('Original:', original); // [1, 2, 3, 4, 5]\n\nconst prepended = prepend(original, 0);\nconsole.log('Prepended:', prepended); // [0, 1, 2, 3, 4, 5]\nconsole.log('Original still:', original); // [1, 2, 3, 4, 5]\n\nconst appended = append(original, 6);\nconsole.log('Appended:', appended);   // [1, 2, 3, 4, 5, 6]\nconsole.log('Original still:', original); // [1, 2, 3, 4, 5]\n\nconst removed = removeAtIndex(original, 2); // Remove 3\nconsole.log('Removed at index 2:', removed); // [1, 2, 4, 5]\nconsole.log('Original still:', original); // [1, 2, 3, 4, 5]\n\nconst removedInvalid = removeAtIndex(original, 10);\nconsole.log('Removed invalid index:', removedInvalid === original); // true\n\nconst inserted = insertAtIndex(original, 2, 99);\nconsole.log('Inserted at index 2:', inserted); // [1, 2, 99, 3, 4, 5]\nconsole.log('Original still:', original); // [1, 2, 3, 4, 5]\n\nconst insertedAtEnd = insertAtIndex(original, 10, 100);\nconsole.log('Inserted at end:', insertedAtEnd); // [1, 2, 3, 4, 5, 100]\n\nconst insertedAtBeginning = insertAtIndex(original, -5, -1);\nconsole.log('Inserted at beginning:', insertedAtBeginning); // [-1, 1, 2, 3, 4, 5]\n",
          "testCases": [
            "All functions must return a *new* array, not modify the original.",
            "`prepend` should correctly add an element to the beginning.",
            "`append` should correctly add an element to the end.",
            "`removeAtIndex` should correctly remove an element at a given index and handle out-of-bounds indices by returning the original array.",
            "`insertAtIndex` should correctly insert an element at a given index and handle out-of-bounds indices (inserting at the closest valid boundary).",
            "Test with empty arrays.",
            "Test with single-element arrays."
          ],
          "hints": [
            "For `prepend` and `append`, consider using `concat()` or the spread syntax (`...`).",
            "For `removeAtIndex` and `insertAtIndex`, `slice()` will be essential to break the array into parts, and `concat()` to reassemble it with modifications.",
            "Remember `Math.max(0, ...)` and `Math.min(index, arr.length)` can help normalize indices."
          ],
          "tags": [
            "Array Methods",
            "Immutability",
            "Functional Programming",
            "Higher-Order Functions",
            "Frontend Interview",
            "Medium"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions",
            "object_spread_syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "slice",
            "concat",
            "spread syntax",
            "immutability"
          ]
        },
        {
          "id": "task_array_searching_1",
          "title": "Implement a Flexible Search and Filter API",
          "description": "\nCreate a set of functions that provide flexible search and filter capabilities for an array of product objects. Each function should be implemented using the most appropriate array searching method.\n\n**Product Object Structure:**\n```typescript\ninterface Product {\n  id: number;\n  name: string;\n  category: string;\n  price: number;\n  inStock: boolean;\n}\n```\n\n**Requirements:**\n1.  `findProductById(products, id)`: Returns the product object with the matching `id`, or `undefined` if not found.\n2.  `filterProductsByCategory(products, category)`: Returns a *new array* of all products belonging to the specified `category`.\n3.  `checkProductAvailability(products, productName)`: Returns `true` if a product with the given `productName` exists and is `inStock`, otherwise `false`. (Case-insensitive name comparison).\n4.  `getIndexOfExpensiveProduct(products, minPrice)`: Returns the index of the *first* product found whose `price` is greater than or equal to `minPrice`. Returns -1 if no such product exists.\n",
          "difficulty": "medium",
          "startingCode": "interface Product {\n  id: number;\n  name: string;\n  category: string;\n  price: number;\n  inStock: boolean;\n}\n\nfunction findProductById(products: Product[], id: number): Product | undefined {\n  // TODO: Implement using an appropriate searching method\n}\n\nfunction filterProductsByCategory(products: Product[], category: string): Product[] {\n  // TODO: Implement using an appropriate filtering method\n}\n\nfunction checkProductAvailability(products: Product[], productName: string): boolean {\n  // TODO: Implement, considering case-insensitivity and inStock status\n}\n\nfunction getIndexOfExpensiveProduct(products: Product[], minPrice: number): number {\n  // TODO: Implement using an appropriate searching method for index\n}\n",
          "solutionCode": "interface Product {\n  id: number;\n  name: string;\n  category: string;\n  price: number;\n  inStock: boolean;\n}\n\nfunction findProductById(products: Product[], id: number): Product | undefined {\n  return products.find(product => product.id === id);\n}\n\nfunction filterProductsByCategory(products: Product[], category: string): Product[] {\n  return products.filter(product => product.category === category);\n}\n\nfunction checkProductAvailability(products: Product[], productName: string): boolean {\n  const lowerCaseProductName = productName.toLowerCase();\n  return products.some(product => \n    product.name.toLowerCase() === lowerCaseProductName && product.inStock\n  );\n}\n\nfunction getIndexOfExpensiveProduct(products: Product[], minPrice: number): number {\n  return products.findIndex(product => product.price >= minPrice);\n}\n\n// Test Data:\nconst sampleProducts: Product[] = [\n  { id: 1, name: 'Laptop', category: 'Electronics', price: 1200, inStock: true },\n  { id: 2, name: 'Mouse', category: 'Electronics', price: 25, inStock: false },\n  { id: 3, name: 'Keyboard', category: 'Electronics', price: 75, inStock: true },\n  { id: 4, name: 'Novel', category: 'Books', price: 15, inStock: true },\n  { id: 5, name: 'Headphones', category: 'Audio', price: 150, inStock: true },\n  { id: 6, name: 'Charger', category: 'Electronics', price: 30, inStock: true },\n  { id: 7, name: 'Book', category: 'Books', price: 20, inStock: false }\n];\n\n// Test findProductById\nconsole.log('Find Product by ID 3:', findProductById(sampleProducts, 3)); // Keyboard\nconsole.log('Find Product by ID 99:', findProductById(sampleProducts, 99)); // undefined\n\n// Test filterProductsByCategory\nconsole.log('Filter by Electronics:', filterProductsByCategory(sampleProducts, 'Electronics')); // Laptop, Mouse, Keyboard, Charger\nconsole.log('Filter by Clothes:', filterProductsByCategory(sampleProducts, 'Clothes')); // []\n\n// Test checkProductAvailability\nconsole.log('Check Laptop availability:', checkProductAvailability(sampleProducts, 'laptop')); // true\nconsole.log('Check Mouse availability:', checkProductAvailability(sampleProducts, 'Mouse')); // false (not in stock)\nconsole.log('Check nonexistent product availability:', checkProductAvailability(sampleProducts, 'Monitor')); // false\nconsole.log('Check Book (id 7) availability:', checkProductAvailability(sampleProducts, 'Book')); // false (not in stock)\nconsole.log('Check Novel (id 4) availability:', checkProductAvailability(sampleProducts, 'Novel')); // true (in stock)\n\n// Test getIndexOfExpensiveProduct\nconsole.log('Index of first product >= 100:', getIndexOfExpensiveProduct(sampleProducts, 100)); // 0 (Laptop)\nconsole.log('Index of first product >= 500:', getIndexOfExpensiveProduct(sampleProducts, 500)); // 0 (Laptop) still the first one > 50\nconsole.log('Index of first product >= 2000:', getIndexOfExpensiveProduct(sampleProducts, 2000)); // -1\n",
          "testCases": [
            "`findProductById` should return the correct object or `undefined` for non-existent IDs.",
            "`filterProductsByCategory` should return a new array with only matching categories, or an empty array if no matches.",
            "`checkProductAvailability` should return `true` only if both name matches (case-insensitively) AND `inStock` is `true`. It should return `false` otherwise.",
            "`getIndexOfExpensiveProduct` should return the correct index or `-1` for no matches.",
            "Ensure no functions mutate the original `products` array.",
            "Test with empty input arrays."
          ],
          "hints": [
            "Think about whether you need a single item, an index, or multiple items.",
            "`find()` is great for single object searches.",
            "`filter()` is perfect for subsets.",
            "`some()` can efficiently check for existence based on multiple conditions.",
            "`findIndex()` is for getting the index based on a condition."
          ],
          "tags": [
            "Array Methods",
            "Searching",
            "Filtering",
            "Higher-Order Functions",
            "Data Retrieval",
            "Frontend Interview"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "callback_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "find",
            "filter",
            "some",
            "findIndex",
            "case-insensitivity"
          ]
        },
        {
          "id": "task_array_searching_2",
          "title": "Validate User Input with Array Methods",
          "description": "\nWrite a function `validateOrderItems(availableItems, orderItems)` that validates an array of `orderItems` against a list of `availableItems`. Both `availableItems` and `orderItems` are arrays of strings (item names).\n\n**Requirements:**\n1.  Return `true` if *all* `orderItems` are present in `availableItems`.\n2.  Return `false` if *any* `orderItems` are not found in `availableItems`.\n3.  The comparison should be case-insensitive (e.g., 'Apple' should match 'apple').\n4.  Consider performance for potentially large lists.\n",
          "difficulty": "medium",
          "startingCode": "function validateOrderItems(availableItems: string[], orderItems: string[]): boolean {\n  // TODO: Implement validation logic using array methods\n}\n",
          "solutionCode": "function validateOrderItems(availableItems: string[], orderItems: string[]): boolean {\n  if (!Array.isArray(availableItems) || !Array.isArray(orderItems)) {\n    throw new Error('Inputs must be arrays.');\n  }\n\n  // Convert availableItems to a Set of lowercase names for efficient lookup\n  // Using a Set provides O(1) average time complexity for lookups, better than O(N) for indexOf/includes on arrays\n  const availableItemsLowerCaseSet = new Set(availableItems.map(item => item.toLowerCase()));\n\n  // Check if every ordered item is present in the available items (case-insensitive)\n  return orderItems.every(orderItem => \n    availableItemsLowerCaseSet.has(orderItem.toLowerCase())\n  );\n}\n\n// Test Cases:\nconst available = ['Apple', 'Banana', 'Orange', 'Grape'];\n\nconsole.log('Valid order:', validateOrderItems(available, ['apple', 'Orange'])); // true\nconsole.log('Invalid order (Pear not available):', validateOrderItems(available, ['apple', 'Pear'])); // false\nconsole.log('Empty order:', validateOrderItems(available, [])); // true (all 0 items are available)\nconsole.log('Empty available:', validateOrderItems([], ['apple'])); // false\nconsole.log('Case-insensitive match:', validateOrderItems(available, ['APPLE', 'Grape'])); // true\nconsole.log('Order with duplicate:', validateOrderItems(available, ['Apple', 'Apple'])); // true\n",
          "testCases": [
            "Should return `true` for valid orders (all items available, case-insensitive).",
            "Should return `false` for invalid orders (at least one item not available).",
            "Should handle empty `orderItems` array gracefully (return `true`).",
            "Should handle empty `availableItems` array gracefully (return `false` for non-empty `orderItems`).",
            "Should be case-insensitive.",
            "Should handle duplicate items in `orderItems` correctly."
          ],
          "hints": [
            "To check if *all* items satisfy a condition, consider `every()`.",
            "For case-insensitive comparison, convert both items to the same case (e.g., lowercase) before comparing.",
            "For efficient lookups in a large `availableItems` list, converting it to a `Set` or an object for `O(1)` average time complexity lookups might be beneficial, especially within a loop or `every()` callback."
          ],
          "tags": [
            "Array Methods",
            "Validation",
            "Searching",
            "Performance",
            "Frontend Interview",
            "Medium"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_functions",
            "javascript_strings",
            "javascript_sets"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "every",
            "includes",
            "toLowerCase",
            "Set Data Structure",
            "performance optimization"
          ]
        },
        {
          "id": "task_array_iteration_transformation_1",
          "title": "Process and Summarize Sales Data",
          "description": "\nYou are given an array of sales records. Each record is an object with `product` (string), `quantity` (number), and `price` (number).\n\n**Requirements:**\n1.  **`calculateTotalSales(sales)`**: Calculate the total revenue from all sales. (Use `reduce()`)\n2.  **`getExpensiveProducts(sales, minPrice)`**: Return a *new array* of products (just their names) that have a price greater than or equal to `minPrice`. (Use `filter()` and `map()`)\n3.  **`summarizeSalesByCategory(sales)`**: Return an object where keys are product categories (from `sales.product` - for simplicity, assume 'Electronics' if product name contains 'Laptop' or 'Mouse', 'Books' if 'Book' or 'Novel', otherwise 'Other'), and values are the total revenue for that category. (Use `reduce()`)\n\nExample Sales Record:\n```typescript\ninterface Sale {\n  product: string;\n  quantity: number;\n  price: number;\n}\n```",
          "difficulty": "hard",
          "startingCode": "interface Sale {\n  product: string;\n  quantity: number;\n  price: number;\n}\n\nfunction calculateTotalSales(sales: Sale[]): number {\n  // TODO: Implement using reduce\n}\n\nfunction getExpensiveProducts(sales: Sale[], minPrice: number): string[] {\n  // TODO: Implement using filter and map\n}\n\nfunction summarizeSalesByCategory(sales: Sale[]): { [category: string]: number } {\n  // TODO: Implement using reduce. Assume simple categorization logic.\n  // 'Laptop' or 'Mouse' -> 'Electronics'\n  // 'Book' or 'Novel' -> 'Books'\n  // Else -> 'Other'\n}\n",
          "solutionCode": "interface Sale {\n  product: string;\n  quantity: number;\n  price: number;\n}\n\nfunction calculateTotalSales(sales: Sale[]): number {\n  if (!Array.isArray(sales)) {\n    return 0;\n  }\n  return sales.reduce((total, sale) => total + (sale.quantity * sale.price), 0);\n}\n\nfunction getExpensiveProducts(sales: Sale[], minPrice: number): string[] {\n  if (!Array.isArray(sales)) {\n    return [];\n  }\n  return sales\n    .filter(sale => sale.price * sale.quantity >= minPrice) // Filter by total sale value\n    .map(sale => sale.product); // Map to just product names\n}\n\nfunction summarizeSalesByCategory(sales: Sale[]): { [category: string]: number } {\n  if (!Array.isArray(sales)) {\n    return {};\n  }\n  return sales.reduce((acc, sale) => {\n    let category = 'Other';\n    const productNameLower = sale.product.toLowerCase();\n    if (productNameLower.includes('laptop') || productNameLower.includes('mouse')) {\n      category = 'Electronics';\n    } else if (productNameLower.includes('book') || productNameLower.includes('novel')) {\n      category = 'Books';\n    }\n\n    const revenue = sale.quantity * sale.price;\n    acc[category] = (acc[category] || 0) + revenue;\n    return acc;\n  }, {});\n}\n\n// Test Data:\nconst dailySales: Sale[] = [\n  { product: 'Laptop Pro', quantity: 1, price: 1500 },\n  { product: 'Wireless Mouse', quantity: 3, price: 25 },\n  { product: 'The Great Novel', quantity: 2, price: 20 },\n  { product: 'USB Hub', quantity: 5, price: 10 },\n  { product: 'Gaming Keyboard', quantity: 1, price: 80 },\n  { product: 'Science Book', quantity: 1, price: 30 }\n];\n\n// Test calculateTotalSales\nconsole.log('Total Sales:', calculateTotalSales(dailySales)); // Expected: 1500 + 75 + 40 + 50 + 80 + 30 = 1775\n\n// Test getExpensiveProducts\nconsole.log('Expensive Products (>= $100):', getExpensiveProducts(dailySales, 100)); // ['Laptop Pro']\nconsole.log('Expensive Products (>= $50):', getExpensiveProducts(dailySales, 50));   // ['Laptop Pro', 'Wireless Mouse', 'USB Hub', 'Gaming Keyboard']\n\n// Test summarizeSalesByCategory\nconsole.log('Sales Summary by Category:', summarizeSalesByCategory(dailySales));\n/* Expected:\n{\n  'Electronics': 1500 + 75 + 80 = 1655,\n  'Books': 40 + 30 = 70,\n  'Other': 50\n}\n*/\n",
          "testCases": [
            "`calculateTotalSales` should correctly sum up total revenue for various sales arrays, including empty ones.",
            "`getExpensiveProducts` should filter and map correctly, returning only names of products meeting price criteria.",
            "`summarizeSalesByCategory` should correctly group sales by calculated category and sum their revenues.",
            "All functions should handle empty input arrays gracefully (return 0, empty array, or empty object respectively).",
            "Ensure no functions mutate the original `sales` array.",
            "Test `summarizeSalesByCategory` with products fitting different categories, including 'Other'."
          ],
          "hints": [
            "For total sum, `reduce()` is the ideal choice.",
            "For filtering and then transforming, `filter().map()` is a common chain.",
            "For `summarizeSalesByCategory`, `reduce()` can build an object (the accumulator) where keys are categories and values are sums. Remember to initialize `acc[category]` if it doesn't exist (`acc[category] = (acc[category] || 0) + value`).",
            "Make sure to handle string comparisons for categories (e.g., `toLowerCase()`)."
          ],
          "tags": [
            "Array Methods",
            "Reduce",
            "Map",
            "Filter",
            "Data Aggregation",
            "Object Transformation",
            "Frontend Interview",
            "Complex"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "callback_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "reduce",
            "map",
            "filter",
            "chaining",
            "data aggregation",
            "object grouping"
          ]
        },
        {
          "id": "task_array_iteration_transformation_2",
          "title": "Implement Custom Array Sort and Reverse",
          "description": "\nWrite a function `sortAndReverseUsers(users)` that takes an array of user objects and performs a specific sorting and then reverses the result. Importantly, the function must *not* mutate the original `users` array.\n\n**User Object Structure:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n}\n```\n\n**Requirements:**\n1.  Sort the users by `age` in ascending order.\n2.  If two users have the same `age`, sort them by `name` alphabetically (ascending).\n3.  After sorting, reverse the entire array.\n4.  Return a *new array* at each step, ensuring the original `users` array remains untouched.\n",
          "difficulty": "hard",
          "startingCode": "interface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\nfunction sortAndReverseUsers(users: User[]): User[] {\n  // TODO: Implement sorting and reversing without mutating the original array\n  // Hint: Consider slice() before sort() to create a copy.\n}\n",
          "solutionCode": "interface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\nfunction sortAndReverseUsers(users: User[]): User[] {\n  if (!Array.isArray(users)) {\n    return [];\n  }\n\n  // 1. Create a shallow copy of the array BEFORE sorting to avoid mutation\n  const sortedUsers = users.slice().sort((a, b) => {\n    // Sort by age ascending\n    if (a.age !== b.age) {\n      return a.age - b.age;\n    }\n    // If ages are the same, sort by name alphabetically ascending\n    return a.name.localeCompare(b.name);\n  });\n\n  // 2. Reverse the *sorted copy* to avoid mutating the original array or the freshly sorted one\n  const reversedSortedUsers = sortedUsers.reverse();\n\n  return reversedSortedUsers;\n}\n\n// Test Data:\nconst originalUsers: User[] = [\n  { id: 1, name: 'Charlie', age: 30 },\n  { id: 2, name: 'Alice', age: 25 },\n  { id: 3, name: 'Bob', age: 30 },\n  { id: 4, name: 'David', age: 25 }\n];\n\nconst processedUsers = sortAndReverseUsers(originalUsers);\n\nconsole.log('Original Users:', originalUsers); // Should be untouched\n/* Expected Original:\n[\n  { id: 1, name: 'Charlie', age: 30 },\n  { id: 2, name: 'Alice', age: 25 },\n  { id: 3, name: 'Bob', age: 30 },\n  { id: 4, name: 'David', age: 25 }\n]\n*/\n\nconsole.log('Processed Users:', processedUsers);\n/* Expected Processed:\n   Initial sort (age asc, then name asc):\n   [ { id: 2, name: 'Alice', age: 25 },\n     { id: 4, name: 'David', age: 25 },\n     { id: 3, name: 'Bob', age: 30 },\n     { id: 1, name: 'Charlie', age: 30 } ]\n\n   Then reverse:\n   [ { id: 1, name: 'Charlie', age: 30 },\n     { id: 3, name: 'Bob', age: 30 },\n     { id: 4, name: 'David', age: 25 },\n     { id: 2, name: 'Alice', age: 25 } ]\n*/\n\nconst emptyUsers: User[] = [];\nconsole.log('Empty users processed:', sortAndReverseUsers(emptyUsers)); // []\n\nconst singleUser: User[] = [{ id: 5, name: 'Solo', age: 40 }];\nconsole.log('Single user processed:', sortAndReverseUsers(singleUser)); // [{ id: 5, name: 'Solo', age: 40 }]\n",
          "testCases": [
            "The original `users` array must remain unchanged.",
            "The returned array should be a new array.",
            "Sorting by age ascending must be correct.",
            "Secondary sort by name ascending for same ages must be correct.",
            "The final array must be the reverse of the fully sorted array.",
            "Test with empty array and single-element array."
          ],
          "hints": [
            "To ensure non-mutation, always start by creating a shallow copy of the array using `slice()` or the spread operator (`...arr`) before applying mutating methods like `sort()` or `reverse()`.",
            "The `sort()` method's comparison function can handle multiple sorting criteria by chaining `if` statements or using logical operators.",
            "`String.prototype.localeCompare()` is useful for string comparison."
          ],
          "tags": [
            "Array Methods",
            "Sorting",
            "Reversing",
            "Immutability",
            "Functional Programming",
            "Frontend Interview",
            "Complex"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "callback_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "sort",
            "reverse",
            "slice",
            "immutability",
            "comparison function",
            "localeCompare"
          ]
        },
        {
          "id": "task_additional_array_1",
          "title": "Data Integrity Check for User Profiles",
          "description": "\nImplement a function `checkUserProfileIntegrity(profiles)` that performs several integrity checks on an array of user profile objects.\n\n**Profile Object Structure:**\n```typescript\ninterface Profile {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n  permissions: string[];\n}\n```\n\n**Requirements:**\n1.  Return `true` if *all* profiles have a non-empty `username`.\n2.  Return `true` if *at least one* profile is `isActive`.\n3.  Return `true` if *all* profiles have the 'user' permission in their `permissions` array.\n4.  The function should return `true` only if **ALL THREE** conditions above are met, otherwise `false`.\n",
          "difficulty": "hard",
          "startingCode": "interface Profile {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n  permissions: string[];\n}\n\nfunction checkUserProfileIntegrity(profiles: Profile[]): boolean {\n  // TODO: Implement all three checks using array methods\n  // and combine their results.\n}\n",
          "solutionCode": "interface Profile {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n  permissions: string[];\n}\n\nfunction checkUserProfileIntegrity(profiles: Profile[]): boolean {\n  if (!Array.isArray(profiles) || profiles.length === 0) {\n    return false; // No profiles to check, or invalid input\n  }\n\n  // Condition 1: All profiles have a non-empty username\n  const allUsernamesValid = profiles.every(profile => \n    typeof profile.username === 'string' && profile.username.trim() !== ''\n  );\n\n  // Condition 2: At least one profile is isActive\n  const atLeastOneActive = profiles.some(profile => profile.isActive);\n\n  // Condition 3: All profiles have 'user' permission\n  const allHaveUserPermission = profiles.every(profile => \n    Array.isArray(profile.permissions) && profile.permissions.includes('user')\n  );\n\n  // Return true only if all three conditions are met\n  return allUsernamesValid && atLeastOneActive && allHaveUserPermission;\n}\n\n// Test Cases:\nconst profiles1: Profile[] = [\n  { id: 1, username: 'user1', email: 'u1@example.com', isActive: true, permissions: ['user', 'editor'] },\n  { id: 2, username: 'user2', email: 'u2@example.com', isActive: false, permissions: ['user'] },\n  { id: 3, username: 'user3', email: 'u3@example.com', isActive: true, permissions: ['user', 'admin'] }\n];\nconsole.log('Profiles 1 (Expected: true):', checkUserProfileIntegrity(profiles1)); // true\n\nconst profiles2: Profile[] = [\n  { id: 1, username: '', email: 'u1@example.com', isActive: true, permissions: ['user'] }, // Invalid username\n  { id: 2, username: 'user2', email: 'u2@example.com', isActive: false, permissions: ['user'] }\n];\nconsole.log('Profiles 2 (Invalid username - Expected: false):', checkUserProfileIntegrity(profiles2)); // false\n\nconst profiles3: Profile[] = [\n  { id: 1, username: 'user1', email: 'u1@example.com', isActive: false, permissions: ['user'] },\n  { id: 2, username: 'user2', email: 'u2@example.com', isActive: false, permissions: ['user'] } // No active user\n];\nconsole.log('Profiles 3 (No active user - Expected: false):', checkUserProfileIntegrity(profiles3)); // false\n\nconst profiles4: Profile[] = [\n  { id: 1, username: 'user1', email: 'u1@example.com', isActive: true, permissions: ['guest'] }, // Missing 'user' permission\n  { id: 2, username: 'user2', email: 'u2@example.com', isActive: true, permissions: ['user'] }\n];\nconsole.log('Profiles 4 (Missing user permission - Expected: false):', checkUserProfileIntegrity(profiles4)); // false\n\nconst emptyProfiles: Profile[] = [];\nconsole.log('Empty profiles (Expected: false):', checkUserProfileIntegrity(emptyProfiles)); // false\n",
          "testCases": [
            "Returns `true` when all conditions are met.",
            "Returns `false` if `allUsernamesValid` fails (empty string or non-string username).",
            "Returns `false` if `atLeastOneActive` fails (no active profiles).",
            "Returns `false` if `allHaveUserPermission` fails (at least one profile lacks 'user' permission).",
            "Handles an empty input array (should return `false`).",
            "Handles profiles with `permissions` array missing or not an array."
          ],
          "hints": [
            "For 'all' conditions, `every()` is suitable.",
            "For 'at least one' conditions, `some()` is suitable.",
            "Remember to use `trim()` when checking for non-empty strings to account for whitespace.",
            "Combine the results of the individual checks using logical AND (`&&`).",
            "For the permissions check, ensure `profile.permissions` is an array before calling `includes()`."
          ],
          "tags": [
            "Array Methods",
            "Validation",
            "Conditional Logic",
            "Higher-Order Functions",
            "Frontend Interview",
            "Complex"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "callback_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "every",
            "some",
            "includes",
            "string methods",
            "boolean logic",
            "data validation"
          ]
        },
        {
          "id": "task_additional_array_2",
          "title": "Circular Buffer Implementation",
          "description": "\nImplement a basic `CircularBuffer` class of a fixed size. A circular buffer (or ring buffer) is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. When the buffer is full and a new element is added, it overwrites the oldest element.\n\n**Requirements:**\n1.  `constructor(capacity)`: Initializes the buffer with a given `capacity`, an empty array, and internal pointers/indices.\n2.  `add(element)`: Adds an `element` to the buffer. If the buffer is full, it overwrites the oldest element. Use `push()` and `shift()` *conceptually* for adding/removing, but for efficiency or direct indexing, consider `fill()` or `copyWithin()` for managing the internal array if elements are strictly overwritten.\n3.  `getElements()`: Returns a *new array* containing the elements currently in the buffer, in the correct order (from oldest to newest without nulls/undefined if it hasn't filled yet).\n4.  `isFull()`: Returns `true` if the buffer is at its capacity, `false` otherwise.\n5.  `isEmpty()`: Returns `true` if the buffer contains no elements, `false` otherwise.\n\n**Constraint:** Use `Array.prototype.fill()` and/or `Array.prototype.copyWithin()` where appropriate to manage the internal array, especially for the `add` operation if you are avoiding `shift()` for performance reasons in a fixed-size array.",
          "difficulty": "hard",
          "startingCode": "class CircularBuffer<T> {\n  private buffer: T[];\n  private capacity: number;\n  private head: number;\n  private tail: number;\n  private currentSize: number;\n\n  constructor(capacity: number) {\n    // TODO: Initialize buffer, capacity, pointers\n  }\n\n  add(element: T): void {\n    // TODO: Add element, handle overflow (overwrite oldest)\n  }\n\n  getElements(): T[] {\n    // TODO: Return elements in correct order (oldest to newest)\n  }\n\n  isFull(): boolean {\n    // TODO: Check if buffer is full\n  }\n\n  isEmpty(): boolean {\n    // TODO: Check if buffer is empty\n  }\n}\n",
          "solutionCode": "class CircularBuffer<T> {\n  private buffer: T[];\n  private capacity: number;\n  private head: number; // Points to the first (oldest) element\n  private tail: number; // Points to the next available slot for a new element\n  private currentSize: number;\n\n  constructor(capacity: number) {\n    if (capacity <= 0) {\n      throw new Error('Capacity must be a positive integer.');\n    }\n    this.capacity = capacity;\n    this.buffer = new Array<T>(capacity);\n    this.head = 0;\n    this.tail = 0;\n    this.currentSize = 0;\n  }\n\n  add(element: T): void {\n    this.buffer[this.tail] = element; // Place new element at tail\n    this.tail = (this.tail + 1) % this.capacity; // Move tail pointer\n\n    if (this.isFull()) {\n      // If buffer was full before adding, the head pointer also moves\n      // because the new element overwrote the old head.\n      this.head = this.tail; \n    } else {\n      // If buffer was not full, increment size\n      this.currentSize++;\n    }\n  }\n\n  getElements(): T[] {\n    if (this.isEmpty()) {\n      return [];\n    }\n\n    const result: T[] = [];\n    if (this.tail > this.head) {\n      // No wrap-around yet: elements are head to tail-1\n      for (let i = this.head; i < this.tail; i++) {\n        result.push(this.buffer[i]);\n      }\n    } else if (this.currentSize > 0) {\n      // Wrapped around: elements are from head to end, then from start to tail-1\n      for (let i = this.head; i < this.capacity; i++) {\n        result.push(this.buffer[i]);\n      }\n      for (let i = 0; i < this.tail; i++) {\n        result.push(this.buffer[i]);\n      }\n    }\n    return result;\n    \n    // Alternative for getElements using slice and concat (more functional, potentially less efficient for very large buffers):\n    // if (this.isEmpty()) return [];\n    // if (this.tail > this.head) {\n    //   return this.buffer.slice(this.head, this.tail);\n    // } else if (this.currentSize > 0) {\n    //   return this.buffer.slice(this.head).concat(this.buffer.slice(0, this.tail));\n    // } \n    // return [];\n  }\n\n  isFull(): boolean {\n    return this.currentSize === this.capacity;\n  }\n\n  isEmpty(): boolean {\n    return this.currentSize === 0;\n  }\n}\n\n// Test Cases:\nconsole.log('--- Test CircularBuffer of capacity 3 ---');\nconst buffer3 = new CircularBuffer<string>(3);\nconsole.log('Initial empty:', buffer3.getElements(), 'Size:', buffer3.currentSize, 'Full:', buffer3.isFull(), 'Empty:', buffer3.isEmpty());\n\nbuffer3.add('A'); // [A, _, _]\nconsole.log('Add A:', buffer3.getElements(), 'Size:', buffer3.currentSize);\nbuffer3.add('B'); // [A, B, _]\nconsole.log('Add B:', buffer3.getElements(), 'Size:', buffer3.currentSize);\nbuffer3.add('C'); // [A, B, C] -> Full\nconsole.log('Add C:', buffer3.getElements(), 'Size:', buffer3.currentSize, 'Full:', buffer3.isFull());\n\nbuffer3.add('D'); // [D, B, C] -> Overwrites A, head moves to B's position conceptually (tail is D's next slot)\nconsole.log('Add D (overwrite A):', buffer3.getElements(), 'Size:', buffer3.currentSize);\n\nbuffer3.add('E'); // [D, E, C] -> Overwrites B\nconsole.log('Add E (overwrite B):', buffer3.getElements(), 'Size:', buffer3.currentSize);\n\nconsole.log('Is Full:', buffer3.isFull()); // true\nconsole.log('Is Empty:', buffer3.isEmpty()); // false\n\nconsole.log('\\n--- Test CircularBuffer of capacity 1 ---');\nconst buffer1 = new CircularBuffer<number>(1);\nconsole.log('Initial empty:', buffer1.getElements());\nbuffer1.add(10);\nconsole.log('Add 10:', buffer1.getElements()); // [10]\nbuffer1.add(20);\nconsole.log('Add 20 (overwrite 10):', buffer1.getElements()); // [20]\n\nconsole.log('\\n--- Test Edge Case: Capacity 0/Negative ---');\ntry {\n  new CircularBuffer<any>(0);\n} catch (e) {\n  console.error(e.message); // Should throw error\n}\n",
          "testCases": [
            "Constructor should initialize correctly with given capacity.",
            "`add` should add elements sequentially until full.",
            "`add` should overwrite the oldest element when full.",
            "`getElements` should return elements in correct order, handling wrap-around.",
            "`isFull` should correctly reflect buffer fullness.",
            "`isEmpty` should correctly reflect buffer emptiness.",
            "Test with capacity 1 (edge case).",
            "Test with adding more elements than capacity.",
            "Test `getElements` when not full.",
            "Test `getElements` when full and after overwrites.",
            "Ensure `getElements` returns a copy, not the internal array reference."
          ],
          "hints": [
            "You'll need `head`, `tail` (or `writePointer`), and `size` (or `currentLength`) pointers/variables to manage the buffer.",
            "Use the modulo operator (`%`) for circular indexing: `(pointer + 1) % capacity`.",
            "When the buffer is full and you add a new element, the `head` pointer conceptually advances (or gets overwritten directly by `tail` if `head` was `tail`).",
            "`getElements` might require combining two `slice` operations if the buffer has wrapped around (i.e., `tail` is less than `head`). Or, a manual loop from `head` to `tail` (with modulo arithmetic) can build the array.",
            "Directly using `this.buffer[this.tail] = element;` and `this.tail = (this.tail + 1) % this.capacity;` is the most common and efficient approach for `add()`, along with managing `head` and `currentSize`."
          ],
          "tags": [
            "Data Structure",
            "Array Methods",
            "Circular Buffer",
            "Algorithm",
            "Frontend Interview",
            "Complex"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "javascript_classes",
            "javascript_arrays",
            "modulo_operator",
            "data_structures_basics"
          ],
          "complexity": 9,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "fill",
            "copyWithin",
            "queue",
            "data structures",
            "memory management"
          ]
        },
        {
          "id": "task_mutating_vs_non_mutating_1",
          "title": "Migrate Mutating Operations to Immutable Ones",
          "description": "\nYou are given a JavaScript component that directly modifies arrays, leading to unpredictable behavior in a UI framework (e.g., React) that relies on immutable state. Your task is to refactor the provided functions to be **fully immutable**, meaning they must always return new arrays/objects and never modify the original inputs.\n\n**Requirements:**\n1.  `addTag(items, newTag)`: Adds a `newTag` to an array of `items`.\n2.  `removeFirstItem(items)`: Removes the first item from an array.\n3.  `updateItemAtIndex(items, index, newItem)`: Replaces an item at a specific `index` with `newItem`.\n\n**Constraint:** For each function, the original `items` array must remain unchanged. Each function must return a new array reflecting the change.\n",
          "difficulty": "medium",
          "startingCode": "function addTag(items, newTag) {\n  // CURRENTLY MUTATING! Needs refactoring.\n  items.push(newTag);\n  return items; \n}\n\nfunction removeFirstItem(items) {\n  // CURRENTLY MUTATING! Needs refactoring.\n  items.shift();\n  return items;\n}\n\nfunction updateItemAtIndex(items, index, newItem) {\n  // CURRENTLY MUTATING! Needs refactoring.\n  if (index >= 0 && index < items.length) {\n    items[index] = newItem;\n  }\n  return items;\n}\n",
          "solutionCode": "function addTag(items, newTag) {\n  // Immutable alternative using concat() or spread syntax\n  return items.concat(newTag);\n  // return [...items, newTag];\n}\n\nfunction removeFirstItem(items) {\n  // Immutable alternative using slice()\n  if (!Array.isArray(items) || items.length === 0) {\n    return []; // Return an empty array for empty or invalid input\n  }\n  return items.slice(1);\n}\n\nfunction updateItemAtIndex(items, index, newItem) {\n  // Immutable alternative using map() or slice() with spread syntax\n  if (!Array.isArray(items) || index < 0 || index >= items.length) {\n    return [...items]; // Return a shallow copy if index is out of bounds or invalid, or original if immutable return is desired for no change\n  }\n\n  // Option 1: Using map() for clarity for item-by-item transformation\n  return items.map((item, idx) => (idx === index ? newItem : item));\n\n  // Option 2: Using slice() and spread syntax for direct construction\n  // return [...items.slice(0, index), newItem, ...items.slice(index + 1)];\n}\n\n// Test Cases:\nconst initialItems = ['apple', 'banana', 'cherry'];\n\n// Test addTag\nconst newItemsAdd = addTag(initialItems, 'grape');\nconsole.log('Original after addTag:', initialItems); // Expected: ['apple', 'banana', 'cherry']\nconsole.log('New array after addTag:', newItemsAdd);   // Expected: ['apple', 'banana', 'cherry', 'grape']\n\n// Test removeFirstItem\nconst newItemsRemove = removeFirstItem(initialItems);\nconsole.log('Original after removeFirstItem:', initialItems); // Expected: ['apple', 'banana', 'cherry']\nconsole.log('New array after removeFirstItem:', newItemsRemove); // Expected: ['banana', 'cherry']\n\nconst emptyArray = [];\nconsole.log('Remove from empty:', removeFirstItem(emptyArray)); // Expected: []\n\n// Test updateItemAtIndex\nconst newItemsUpdate = updateItemAtIndex(initialItems, 1, 'blueberry');\nconsole.log('Original after updateItemAtIndex:', initialItems); // Expected: ['apple', 'banana', 'cherry']\nconsole.log('New array after updateItemAtIndex:', newItemsUpdate); // Expected: ['apple', 'blueberry', 'cherry']\n\nconst newItemsUpdateInvalid = updateItemAtIndex(initialItems, 99, 'invalid');\nconsole.log('Update invalid index (should be a copy of original):', newItemsUpdateInvalid); // Expected: ['apple', 'banana', 'cherry'] (copy)\nconsole.log('Are references same for invalid update?', initialItems === newItemsUpdateInvalid); // Expected: false (if using map/slice method which always makes a copy)\n\n// Another test case for update with object elements (important for immutability)\nconst users = [{id: 1, name: 'A'}, {id: 2, name: 'B'}];\nconst updatedUsers = updateItemAtIndex(users, 0, {id: 1, name: 'Z'});\nconsole.log('Original users:', users);\nconsole.log('Updated users:', updatedUsers);\nconsole.log('User references:', users[0] === updatedUsers[0]); // false (for updated item)\nconsole.log('User references:', users[1] === updatedUsers[1]); // true (for unchanged item)\n",
          "testCases": [
            "All refactored functions must return a *new* array.",
            "The original `items` array must remain unchanged after each function call.",
            "`addTag` should correctly add an element to the end of the new array.",
            "`removeFirstItem` should correctly remove the first element from the new array and handle empty arrays.",
            "`updateItemAtIndex` should correctly replace an element at a given index in the new array, and handle out-of-bounds indices by returning a copy of the original array (or original array itself if no change is desired and reference parity is key).",
            "Test with empty arrays.",
            "Test with single-element arrays.",
            "Test with arrays containing objects, ensuring nested immutability (if updating an object, return a *new* object, not just a new array)."
          ],
          "hints": [
            "For adding elements immutably, `concat()` or the spread syntax (`...`) are your best friends.",
            "For removing from the beginning or updating at an index, `slice()` combined with the spread syntax, or `map()` with conditional logic, are good choices.",
            "Remember that `map()` always returns a new array, making it ideal for transformations that preserve immutability.",
            "For `updateItemAtIndex`, ensure that if the element itself is an object, you also create a *new object* for the updated element, using object spread (`{ ...oldObject, newProperty: value }`)."
          ],
          "tags": [
            "Array Methods",
            "Immutability",
            "Refactoring",
            "Functional Programming",
            "Frontend Interview",
            "Medium"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions",
            "object_spread_syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "concat",
            "slice",
            "map",
            "spread syntax",
            "immutability",
            "state management"
          ]
        }
      ]
    }
  },
  {
    "id": "3cec5d31-0f91-45c6-9896-a858df622bf6",
    "startLine": 1300,
    "endLine": 1399,
    "processedDate": "2025-06-17T07:46:48.065Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_array_mutating_methods",
          "title": "Mutating Array Methods",
          "content": "Mutating array methods are functions that modify the original array directly (in-place) when they are called. Understanding which methods mutate and which do not is crucial for preventing unexpected side effects in your code, especially when working with references to arrays.\n\n## Key Mutating Methods\n\n### `splice()`\nThe `splice()` method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place. It returns an array containing the deleted elements (if any).\n\n**Syntax:** `array.splice(start, deleteCount, item1, item2, ...)`\n*   `start`: Index at which to start changing the array.\n*   `deleteCount`: An integer indicating the number of elements to remove.\n*   `item1, item2, ...`: The elements to add to the array, starting at the `start` position. If no elements are specified, `splice()` only removes elements.\n\n### `sort()`\nThe `sort()` method sorts the elements of an array in place and returns the reference to the same array, now sorted. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units. For numeric sorting, a compare function is necessary.\n\n**Syntax:** `array.sort([compareFunction])`\n*   `compareFunction`: A function that defines the sort order. It takes two arguments, `a` and `b`. If `compareFunction(a, b)` returns a value:\n    *   Less than 0: `a` comes before `b`.\n    *   Greater than 0: `b` comes before `a`.\n    *   Equal to 0: `a` and `b` remain unchanged with respect to each other, but are sorted with respect to all other elements.\n\n### `reverse()`\nThe `reverse()` method reverses the order of the elements in an array in place. The first array element becomes the last, and the last array element becomes the first. It returns a reference to the same array.\n\n**Syntax:** `array.reverse()`\n\n### `fill()`\nThe `fill()` method changes all elements in an array to a static value, from a start index (default 0) to an end index (default `array.length`). It modifies the original array and returns it.\n\n**Syntax:** `array.fill(value, [start], [end])`\n*   `value`: Value to fill the array with.\n*   `start` (optional): Start index, default 0.\n*   `end` (optional): End index (exclusive), default `array.length`.\n\n### `copyWithin()`\nThe `copyWithin()` method shallow copies part of an array to another location in the same array and returns it without modifying its length. It's useful for shifting elements within an array.\n\n**Syntax:** `array.copyWithin(target, start, [end])`\n*   `target`: Zero-based index at which to copy the sequence to.\n*   `start`: Zero-based index at which to start copying elements from.\n*   `end` (optional): Zero-based index at which to end copying elements from (exclusive). Defaults to `array.length`.\n",
          "examples": [
            {
              "id": "example_splice_1",
              "title": "Using `splice()` to Remove and Add Elements",
              "code": "const myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];\nconst removed = myFish.splice(2, 1, 'trumpet');\n// myFish is now ['angel', 'clown', 'trumpet', 'sturgeon']\n// removed contains ['mandarin'] - the element that was removed",
              "explanation": "This example demonstrates how `splice()` can remove 'mandarin' at index 2 and insert 'trumpet' in its place. The original `myFish` array is modified, and the removed element is returned.",
              "language": "javascript"
            },
            {
              "id": "example_sort_1",
              "title": "Basic `sort()` and Custom Numeric `sort()`",
              "code": "const fruits = ['banana', 'apple', 'orange'];\nfruits.sort(); // ['apple', 'banana', 'orange']\n\nconst numbers = [10, 5, 8, 1, 7];\nnumbers.sort((a, b) => a - b); // [1, 5, 7, 8, 10] (ascending)\nnumbers.sort((a, b) => b - a); // [10, 8, 7, 5, 1] (descending)",
              "explanation": "The first part shows default lexicographical string sorting. The second part illustrates how to sort numbers correctly using a compare function: `a - b` for ascending and `b - a` for descending order.",
              "language": "javascript"
            },
            {
              "id": "example_reverse_1",
              "title": "Using `reverse()`",
              "code": "const numbers = [1, 5, 7, 8, 10];\nnumbers.reverse(); // numbers is now [10, 8, 7, 5, 1]",
              "explanation": "This shows `reverse()` modifying the array `numbers` in place, changing the order of its elements.",
              "language": "javascript"
            },
            {
              "id": "example_fill_1",
              "title": "Using `fill()`",
              "code": "const filledFull = [1, 2, 3, 4, 5].fill(0); // [0, 0, 0, 0, 0]\nconst partiallyFilled = [1, 2, 3, 4, 5].fill(0, 2, 4); // [1, 2, 0, 0, 5]",
              "explanation": "The first example fills the entire array with zeros. The second example fills elements from index 2 (inclusive) up to index 4 (exclusive) with zeros, leaving other elements untouched.",
              "language": "javascript"
            },
            {
              "id": "example_copywithin_1",
              "title": "Using `copyWithin()`",
              "code": "const originalArray = [1, 2, 3, 4, 5];\noriginalArray.copyWithin(0, 3); // originalArray is now [4, 5, 3, 4, 5]",
              "explanation": "This demonstrates copying elements starting from index 3 (which are 4 and 5) to the beginning of the array, effectively overwriting elements at index 0 and 1. The length of the array remains unchanged.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "array methods",
            "mutation",
            "in-place",
            "splice",
            "sort",
            "reverse",
            "fill",
            "copyWithin"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data manipulation",
            "algorithm implementation"
          ]
        },
        {
          "id": "theory_array_non_mutating_methods",
          "title": "Non-Mutating Array Methods (Return New Arrays)",
          "content": "Non-mutating array methods do not modify the original array. Instead, they return a new array containing the results of the operation. This characteristic makes them safer for functional programming paradigms and when you need to preserve the original data integrity.\n\n## Key Non-Mutating Methods\n\n### `concat()`\nThe `concat()` method is used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array.\n\n**Syntax:** `array1.concat(array2, array3, ...)`\n\n### `slice()`\nThe `slice()` method returns a shallow copy of a portion of an array into a new array object selected from `start` to `end` (end not included). The original array will not be modified.\n\n**Syntax:** `array.slice([start], [end])`\n*   `start` (optional): Zero-based index at which to begin extraction. Default is 0.\n*   `end` (optional): Zero-based index before which to end extraction. `slice` extracts up to (but not including) `end`. Default is `array.length`.\n\n### `map()`\nThe `map()` method creates a new array populated with the results of calling a provided function on every element in the calling array. It's excellent for transforming data.\n\n**Syntax:** `array.map(callback(currentValue, index, array), [thisArg])`\n*   `callback`: Function that is called for every element of `array`. It takes `currentValue`, `index`, and the `array` itself as arguments.\n\n### `filter()`\nThe `filter()` method creates a new array with all elements that pass the test implemented by the provided function. It's used for selective inclusion of elements.\n\n**Syntax:** `array.filter(callback(currentValue, index, array), [thisArg])`\n*   `callback`: Function that is called for every element of `array`. It should return a truthy value to keep the element, or a falsy value otherwise.\n\n### `reduce()`\nThe `reduce()` method executes a user-supplied 'reducer' callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements is a single value. This method is incredibly versatile for accumulating data.\n\n**Syntax:** `array.reduce(callback(accumulator, currentValue, index, array), [initialValue])`\n*   `callback`: A function that is called for each element. It takes `accumulator` (the value accumulated so far), `currentValue`, `index`, and `array` as arguments.\n*   `initialValue` (optional): A value to use as the first argument to the first call of the `callback`. If `initialValue` is not provided, the first element of the array is used as the `initialValue` and `currentValue` starts from the second element. If `initialValue` is not provided and the array is empty, `reduce` will throw a `TypeError`.\n\n### `flatMap()`\nThe `flatMap()` method returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level. It is identical to `map()` followed by `flat(1)`.\n\n**Syntax:** `array.flatMap(callback(currentValue, index, array), [thisArg])`\n\n### `flat()`\nThe `flat()` method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth. It's useful for flattening nested array structures.\n\n**Syntax:** `array.flat([depth])`\n*   `depth` (optional): The depth level specifying how deep a nested array structure should be flattened. Defaults to 1. `Infinity` can be used to flatten all nested arrays.",
          "examples": [
            {
              "id": "example_concat_1",
              "title": "Merging Arrays with `concat()`",
              "code": "const array1 = [1, 2];\nconst array2 = [3, 4];\nconst array3 = array1.concat(array2); // [1, 2, 3, 4]\n// array1 and array2 remain unchanged",
              "explanation": "This demonstrates how `concat()` creates a new array `array3` by joining `array1` and `array2` without altering the originals.",
              "language": "javascript"
            },
            {
              "id": "example_slice_1",
              "title": "Extracting a Portion with `slice()`",
              "code": "const original = [1, 2, 3, 4, 5];\nconst slice = original.slice(1, 4); // [2, 3, 4]\n// original remains [1, 2, 3, 4, 5]",
              "explanation": "`slice(1, 4)` extracts elements from index 1 (inclusive) up to index 4 (exclusive), resulting in a new array `[2, 3, 4]`. The `original` array is not modified.",
              "language": "javascript"
            },
            {
              "id": "example_map_1",
              "title": "Transforming Elements with `map()`",
              "code": "const numbers = [1, 2, 3];\nconst doubled = numbers.map(x => x * 2); // [2, 4, 6]\n// numbers remains [1, 2, 3]",
              "explanation": "Each element in `numbers` is multiplied by 2, and the results form a new array `doubled`. The `numbers` array is unaffected.",
              "language": "javascript"
            },
            {
              "id": "example_filter_1",
              "title": "Filtering Elements with `filter()`",
              "code": "const numbers = [1, 2, 3, 4, 5];\nconst filtered = numbers.filter(x => x > 3); // [4, 5]\n// numbers remains [1, 2, 3, 4, 5]",
              "explanation": "Only elements greater than 3 pass the test and are included in the new `filtered` array. The original `numbers` array is not changed.",
              "language": "javascript"
            },
            {
              "id": "example_reduce_1",
              "title": "Aggregating Data with `reduce()`",
              "code": "// Sum with initial value of 0\nconst sumWithInitial = [1, 2, 3, 4, 5].reduce((acc, current) => acc + current, 0); // 15\n\n// Sum without initial value (first element becomes initial accumulator)\nconst array1 = [1, 2, 3, 4];\nconst sumNoInitial = array1.reduce((accumulator, currentValue) => accumulator + currentValue); // 10\n\n// Type coercion in reduce (be careful!)\nconst concatenatedString = ['1', 2, 3, 4].reduce((accumulator, currentValue) => accumulator + currentValue); // '1234'",
              "explanation": "These examples showcase `reduce()`'s power. The first calculates a sum starting from 0. The second sums an array where the first element initializes the accumulator. The third demonstrates a common pitfall: type coercion. If the initial accumulator or first element is a string, subsequent additions might result in string concatenation instead of numeric sum.",
              "language": "javascript"
            },
            {
              "id": "example_flatmap_1",
              "title": "Mapping and Flattening with `flatMap()`",
              "code": "const nestedArrays = [[1], [2], [3]];\nconst flatMapped = nestedArrays.flatMap(x => x); // [1, 2, 3]\n\nconst sentences = ['hello world', 'goodbye moon'];\nconst words = sentences.flatMap(s => s.split(' ')); // ['hello', 'world', 'goodbye', 'moon']",
              "explanation": "The first example demonstrates `flatMap` applying the identity function (`x => x`) to each element, which are arrays, and then flattening them by one level. The second example shows a practical use case: splitting sentences into words and getting a single flat array of all words.",
              "language": "javascript"
            },
            {
              "id": "example_flat_1",
              "title": "Flattening Nested Arrays with `flat()`",
              "code": "const arrayToFlat = [[1, 2], [3, 4]];\nconst flattened = arrayToFlat.flat(); // [1, 2, 3, 4]\n\nconst deeplyNested = [1, [2, [3, [4]]]];\nconst flattenedDeep = deeplyNested.flat(Infinity); // [1, 2, 3, 4]",
              "explanation": "The first example flattens a simple 2-level nested array by one level (default). The second example uses `Infinity` to flatten a deeply nested array completely, extracting all elements into a single-level array.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "array methods",
            "non-mutating",
            "functional programming",
            "concat",
            "slice",
            "map",
            "filter",
            "reduce",
            "flatMap",
            "flat"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_callbacks"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "data transformation",
            "immutable data patterns"
          ]
        },
        {
          "id": "theory_array_search_inspection_methods",
          "title": "Array Search and Inspection Methods",
          "content": "These methods are used to search for elements within an array, check for their existence, or test if elements meet certain conditions. They typically return a boolean, an index, or the element itself, without modifying the original array.\n\n## Key Search and Inspection Methods\n\n### `includes()`\nThe `includes()` method determines whether an array includes a certain value among its entries, returning `true` or `false` as appropriate. It performs a strict equality comparison (like `===`).\n\n**Syntax:** `array.includes(valueToFind, [fromIndex])`\n*   `valueToFind`: The value to search for.\n*   `fromIndex` (optional): The position in this array at which to begin searching for `valueToFind`. Defaults to 0.\n\n### `indexOf()`\nThe `indexOf()` method returns the first index at which a given element can be found in the array, or -1 if it is not present. It uses strict equality comparison.\n\n**Syntax:** `array.indexOf(searchElement, [fromIndex])`\n*   `searchElement`: Element to locate in the array.\n*   `fromIndex` (optional): The index to start the search from. Defaults to 0.\n\n### `lastIndexOf()`\nThe `lastIndexOf()` method returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting from `fromIndex`.\n\n**Syntax:** `array.lastIndexOf(searchElement, [fromIndex])`\n*   `searchElement`: Element to locate in the array.\n*   `fromIndex` (optional): The index to start the search from. Defaults to `array.length - 1`.\n\n### `find()`\nThe `find()` method returns the first element in the provided array that satisfies the provided testing function. If no elements satisfy the testing function, `undefined` is returned.\n\n**Syntax:** `array.find(callback(element, index, array), [thisArg])`\n*   `callback`: A function that is executed for each element. It should return a truthy value to indicate a match.\n\n### `findIndex()`\nThe `findIndex()` method returns the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns -1.\n\n**Syntax:** `array.findIndex(callback(element, index, array), [thisArg])`\n*   `callback`: A function that is executed for each element. It should return a truthy value to indicate a match.\n\n### `some()`\nThe `some()` method tests whether at least one element in the array passes the test implemented by the provided function. It returns `true` if, in the array, it finds an element for which the provided function returns `true`; otherwise it returns `false`. It stops iterating as soon as the callback returns a truthy value.\n\n**Syntax:** `array.some(callback(element, index, array), [thisArg])`\n\n### `every()`\nThe `every()` method tests whether all elements in the array pass the test implemented by the provided function. It returns `true` if the callback function returns a truthy value for every array element; otherwise, `false`. It stops iterating as soon as the callback returns a falsy value.\n\n**Syntax:** `array.every(callback(element, index, array), [thisArg])`\n",
          "examples": [
            {
              "id": "example_includes_1",
              "title": "Checking for Value Existence with `includes()`",
              "code": "[1, 2, 3].includes(2); // true\n[1, 2, 3].includes(4); // false",
              "explanation": "Demonstrates simple checks for element existence within an array.",
              "language": "javascript"
            },
            {
              "id": "example_indexOf_1",
              "title": "Finding Element Index with `indexOf()`",
              "code": "['apple', 'banana', 'orange'].indexOf('banana'); // 1\n['apple', 'banana', 'orange'].indexOf('grape'); // -1",
              "explanation": "Shows how `indexOf()` returns the index of the first occurrence of an element, or -1 if not found.",
              "language": "javascript"
            },
            {
              "id": "example_lastIndexOf_1",
              "title": "Finding Last Element Index with `lastIndexOf()`",
              "code": "['apple', 'banana', 'apple'].lastIndexOf('apple'); // 2",
              "explanation": "Illustrates finding the index of the last occurrence of an element.",
              "language": "javascript"
            },
            {
              "id": "example_find_1",
              "title": "Finding First Matching Element with `find()`",
              "code": "[5, 12, 8, 130, 44].find(x => x > 10); // 12",
              "explanation": "Returns the first number in the array that is greater than 10.",
              "language": "javascript"
            },
            {
              "id": "example_findIndex_1",
              "title": "Finding Index of First Matching Element with `findIndex()`",
              "code": "[5, 12, 8, 130, 44].findIndex(x => x > 10); // 1",
              "explanation": "Returns the index of the first number in the array that is greater than 10.",
              "language": "javascript"
            },
            {
              "id": "example_some_1",
              "title": "Checking if Any Element Passes Test with `some()`",
              "code": "[5, 12, 8, 130, 44].some(x => x > 10); // true",
              "explanation": "Checks if at least one element is greater than 10. Since 12, 130, and 44 are, it returns true.",
              "language": "javascript"
            },
            {
              "id": "example_every_1",
              "title": "Checking if All Elements Pass Test with `every()`",
              "code": "[12, 54, 18, 130, 44].every(x => x > 10); // true\n[10, 54, 18].every(x => x > 10); // false (because 10 is not > 10)",
              "explanation": "The first example returns true because all elements are greater than 10. The second example returns false because 10 is not strictly greater than 10, failing the test.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "array methods",
            "search",
            "inspection",
            "includes",
            "indexOf",
            "lastIndexOf",
            "find",
            "findIndex",
            "some",
            "every"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_callbacks"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data validation",
            "conditional logic"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_mutating_non_mutating_diff_1",
          "topic": "Mutating vs. Non-Mutating Array Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between mutating and non-mutating array methods in JavaScript?",
          "answer": "Mutating methods modify the original array in place, while non-mutating methods return a new array without altering the original.",
          "options": [],
          "analysisPoints": [
            "Understanding of side effects in programming.",
            "Importance of immutability in certain programming paradigms."
          ],
          "keyConcepts": [
            "mutability",
            "immutability",
            "side effects",
            "array methods"
          ],
          "evaluationCriteria": [
            "Ability to define key difference",
            "Understanding of implications"
          ],
          "example": "",
          "tags": [
            "array methods",
            "mutability",
            "immutability"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_splice_output_1",
          "topic": "`splice()` Method",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n```javascript\nconst animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];\nconst removedAnimals = animals.splice(2, 2, 'cat', 'dog');\n\nconsole.log(animals);\nconsole.log(removedAnimals);\n```\nWhat will be the output for `animals` and `removedAnimals`?",
          "answer": "animals: ['ant', 'bison', 'cat', 'dog', 'elephant'], removedAnimals: ['camel', 'duck']",
          "options": [
            "animals: ['ant', 'bison', 'camel', 'duck', 'elephant'], removedAnimals: ['cat', 'dog']",
            "animals: ['ant', 'bison', 'cat', 'dog', 'elephant'], removedAnimals: ['camel', 'duck']",
            "animals: ['ant', 'bison', 'camel', 'duck'], removedAnimals: ['cat', 'dog', 'elephant']",
            "animals: ['ant', 'bison', 'cat', 'dog'], removedAnimals: ['camel', 'duck', 'elephant']"
          ],
          "analysisPoints": [
            "Understanding `splice()`'s ability to remove and add elements simultaneously.",
            "Knowing that `splice()` returns the *removed* elements.",
            "Recognizing that `splice()` modifies the original array in place."
          ],
          "keyConcepts": [
            "splice",
            "mutating methods",
            "return value"
          ],
          "evaluationCriteria": [
            "Correctly identifying modified array state",
            "Correctly identifying returned array content"
          ],
          "example": "The `splice(2, 2, 'cat', 'dog')` call starts at index 2 ('camel'), removes 2 elements ('camel', 'duck'), and inserts 'cat' and 'dog'. The removed elements ('camel', 'duck') are returned in a new array.",
          "tags": [
            "splice",
            "array methods",
            "mutating",
            "mcq"
          ],
          "prerequisites": [
            "theory_array_mutating_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_sort_numeric_1",
          "topic": "`sort()` Method",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you sort an array of numbers `[20, 1, 100, 5]` in ascending order using JavaScript's `sort()` method?",
          "answer": "You must provide a custom compare function: `numbers.sort((a, b) => a - b);`",
          "options": [],
          "analysisPoints": [
            "Understanding the default string-based sorting of `sort()`.",
            "Knowledge of providing a custom compare function for numeric sorting."
          ],
          "keyConcepts": [
            "sort",
            "compare function",
            "numeric sort",
            "mutating methods"
          ],
          "evaluationCriteria": [
            "Providing correct syntax for numeric sort",
            "Understanding the necessity of custom comparator"
          ],
          "example": "```javascript\nconst numbers = [20, 1, 100, 5];\nnumbers.sort((a, b) => a - b); // [1, 5, 20, 100]\n```",
          "tags": [
            "sort",
            "array methods",
            "mutating",
            "numeric sort"
          ],
          "prerequisites": [
            "theory_array_mutating_methods"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_fill_copywithin_1",
          "topic": "`fill()` and `copyWithin()` Methods",
          "level": "medium",
          "type": "mcq",
          "question": "What will be the value of `arr` after the following operations?\n```javascript\nlet arr = [1, 2, 3, 4, 5, 6, 7];\narr.fill(0, 3, 5);\narr.copyWithin(0, 5);\n```",
          "answer": "[6, 7, 3, 0, 0, 6, 7]",
          "options": [
            "[6, 7, 3, 4, 5, 6, 7]",
            "[1, 2, 3, 0, 0, 6, 7]",
            "[6, 7, 3, 4, 0, 0, 7]",
            "[6, 7, 3, 0, 0, 6, 7]"
          ],
          "analysisPoints": [
            "Understanding the `fill()` method's parameters (value, start, end).",
            "Understanding the `copyWithin()` method's parameters (target, start, end).",
            "Tracking in-place modifications for consecutive mutating operations."
          ],
          "keyConcepts": [
            "fill",
            "copyWithin",
            "mutating methods"
          ],
          "evaluationCriteria": [
            "Accurate tracking of array state changes",
            "Correct application of method parameters"
          ],
          "example": "1. `arr = [1, 2, 3, 4, 5, 6, 7]`\n2. `arr.fill(0, 3, 5);`\n   - Fills from index 3 (inclusive) up to (but not including) 5 with 0.\n   - `arr` becomes `[1, 2, 3, 0, 0, 6, 7]`\n3. `arr.copyWithin(0, 5);`\n   - Copies elements starting from index 5 (which are 6, 7) to index 0.\n   - `arr` becomes `[6, 7, 3, 0, 0, 6, 7]` (The original elements at indices 5 and 6 remain if not overwritten by the copy operation's target range.)",
          "tags": [
            "fill",
            "copyWithin",
            "array methods",
            "mutating"
          ],
          "prerequisites": [
            "theory_array_mutating_methods"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_map_filter_diff_1",
          "topic": "`map()` vs. `filter()`",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary difference between `Array.prototype.map()` and `Array.prototype.filter()` methods. Provide a scenario where each would be more appropriate.",
          "answer": "Both `map()` and `filter()` are non-mutating array methods that return new arrays. However, their primary purposes differ:\n\n*   **`map()`**: Used for **transformation**. It creates a new array by applying a callback function to each element of the original array. The new array will always have the same length as the original array, but its elements will be the results of the callback function.\n    *   **Scenario**: Doubling all numbers in an array: `const numbers = [1, 2, 3]; const doubled = numbers.map(n => n * 2); // [2, 4, 6]`\n\n*   **`filter()`**: Used for **selection/subsetting**. It creates a new array containing only the elements from the original array for which the provided callback function returns `true` (or a truthy value). The new array's length can be less than or equal to the original array's length.\n    *   **Scenario**: Getting all even numbers from an array: `const numbers = [1, 2, 3, 4, 5]; const evens = numbers.filter(n => n % 2 === 0); // [2, 4]`",
          "options": [],
          "analysisPoints": [
            "Clarity in defining the purpose of each method.",
            "Accuracy in describing their return values and impact on array length.",
            "Ability to provide relevant and distinct use cases for each."
          ],
          "keyConcepts": [
            "map",
            "filter",
            "non-mutating methods",
            "transformation",
            "selection"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions",
            "Quality of examples",
            "Completeness of explanation"
          ],
          "example": "",
          "tags": [
            "map",
            "filter",
            "array methods",
            "non-mutating",
            "open-ended"
          ],
          "prerequisites": [
            "theory_array_non_mutating_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reduce_initial_value_1",
          "topic": "`reduce()` Method",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of the following JavaScript code?\n```javascript\nconst data = [10, 20, 30];\nconst result1 = data.reduce((acc, val) => acc + val);\nconst result2 = data.reduce((acc, val) => acc + val, 5);\nconst result3 = [].reduce((acc, val) => acc + val, 0);\nconst result4 = [].reduce((acc, val) => acc + val);\n\nconsole.log(result1);\nconsole.log(result2);\nconsole.log(result3);\nconsole.log(result4);\n```",
          "answer": "60, 65, 0, TypeError",
          "options": [
            "60, 65, 0, 0",
            "60, 65, 0, TypeError",
            "60, 60, 0, undefined",
            "10, 15, 0, TypeError"
          ],
          "analysisPoints": [
            "Understanding the behavior of `reduce()` with and without `initialValue`.",
            "Knowing how `initialValue` affects the starting point of the accumulation.",
            "Recognizing the `TypeError` when `reduce()` is called on an empty array without an `initialValue`."
          ],
          "keyConcepts": [
            "reduce",
            "initialValue",
            "accumulator",
            "type coercion",
            "error handling"
          ],
          "evaluationCriteria": [
            "Correctly predicting `reduce` behavior",
            "Identifying edge cases (empty array)"
          ],
          "example": "1. `result1`: `reduce` without `initialValue`. `acc` starts at `10`, `val` at `20`. `10+20=30`, then `30+30=60`. Output: `60`.\n2. `result2`: `reduce` with `initialValue` of `5`. `acc` starts at `5`, `val` at `10`. `5+10=15`, then `15+20=35`, then `35+30=65`. Output: `65`.\n3. `result3`: `reduce` on empty array with `initialValue` of `0`. The callback is never executed. `initialValue` is returned. Output: `0`.\n4. `result4`: `reduce` on empty array without `initialValue`. This throws a `TypeError` because there's no initial value for the accumulator and no first element to use as one.",
          "tags": [
            "reduce",
            "array methods",
            "non-mutating",
            "initialValue",
            "error handling",
            "mcq"
          ],
          "prerequisites": [
            "theory_array_non_mutating_methods"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flat_flatMap_1",
          "topic": "`flat()` and `flatMap()` Methods",
          "level": "medium",
          "type": "open",
          "question": "Describe the main difference between `Array.prototype.flat()` and `Array.prototype.flatMap()`. When would you choose one over the other?",
          "answer": "`flat()` and `flatMap()` both deal with flattening nested arrays, but `flatMap()` combines flattening with mapping.\n\n*   **`flat()`**: Its primary purpose is to **flatten a multi-dimensional array** into a single-dimensional array (or fewer dimensions). It takes an optional `depth` argument, which specifies how many levels of nested arrays should be flattened. It's useful when you already have nested arrays and just need to reduce their dimensionality.\n    *   **Example**: `[[1, 2], [3, [4, 5]]].flat(1)` results in `[1, 2, 3, [4, 5]]`. `flat(Infinity)` would flatten all levels.\n\n*   **`flatMap()`**: This method is conceptually equivalent to calling `map()` followed by `flat()` with a depth of 1. It first **maps each element** of the array using a provided callback function, and then **flattens the result by one level**. It's ideal when your mapping operation itself returns an array (or iterable) and you want to consolidate those results into a single flat array.\n    *   **Example**: `['a b', 'c d'].flatMap(s => s.split(' '))` results in `['a', 'b', 'c', 'd']`. Here, `split(' ')` returns an array, and `flatMap` flattens these into a single array.\n\n**When to choose:**\n*   Choose `flat()` when you *already have* a nested array and you just need to reduce its nesting depth.\n*   Choose `flatMap()` when you want to *transform* each element into an array (or iterable) and then immediately flatten those resulting arrays into a single, combined array. It's a convenient shorthand for `map().flat(1)`.",
          "options": [],
          "analysisPoints": [
            "Understanding the `map` and `flat` combination in `flatMap`.",
            "Ability to differentiate their core functionalities (flattening vs. mapping + flattening).",
            "Providing clear examples for each and a practical comparison."
          ],
          "keyConcepts": [
            "flat",
            "flatMap",
            "array methods",
            "non-mutating",
            "nesting"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions",
            "Clarity of explanation",
            "Relevance of examples"
          ],
          "example": "",
          "tags": [
            "flat",
            "flatMap",
            "array methods",
            "non-mutating",
            "open-ended"
          ],
          "prerequisites": [
            "theory_array_non_mutating_methods"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_search_methods_selection_1",
          "topic": "Array Search and Inspection Methods",
          "level": "medium",
          "type": "mcq",
          "question": "You have an array of objects representing users: `[{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, name: 'Alice' }]`.\nWhich method would you use to find the *first* user object with `name: 'Alice'`?",
          "answer": "`find()`",
          "options": [
            "`filter()`",
            "`includes()`",
            "`indexOf()`",
            "`find()`"
          ],
          "analysisPoints": [
            "Understanding that `find()` returns the *element* itself (or `undefined`).",
            "Differentiating `find()` from `filter()` (which returns an array of all matches).",
            "Recognizing that `includes()` and `indexOf()` are for primitive values or direct object references, not properties of objects."
          ],
          "keyConcepts": [
            "find",
            "filter",
            "includes",
            "indexOf",
            "array search",
            "object comparison"
          ],
          "evaluationCriteria": [
            "Correct selection of method for object search",
            "Understanding method return types"
          ],
          "example": "```javascript\nconst users = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, name: 'Alice' }];\nconst alice = users.find(user => user.name === 'Alice');\nconsole.log(alice); // { id: 1, name: 'Alice' }\n```",
          "tags": [
            "find",
            "array methods",
            "search",
            "mcq"
          ],
          "prerequisites": [
            "theory_array_search_inspection_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_some_every_diff_1",
          "topic": "`some()` vs. `every()`",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between `Array.prototype.some()` and `Array.prototype.every()`. Provide an example for each.",
          "answer": "Both `some()` and `every()` are iteration methods that test elements of an array against a provided condition, returning a boolean value. They are both short-circuiting.\n\n*   **`some()`**: Tests whether **at least one** element in the array passes the provided test. It returns `true` as soon as the callback function returns a truthy value for *any* element; otherwise, it returns `false` if no element passes the test or the array is empty.\n    *   **Example**: `const numbers = [1, 5, 8, 10]; numbers.some(num => num > 7); // true (because 8 and 10 are > 7)`\n\n*   **`every()`**: Tests whether **all** elements in the array pass the provided test. It returns `true` only if the callback function returns a truthy value for *every single* element; otherwise, it returns `false` as soon as the callback returns a falsy value for any element. If the array is empty, `every()` returns `true` (vacuously true).\n    *   **Example**: `const numbers = [2, 4, 6, 8]; numbers.every(num => num % 2 === 0); // true (all are even)`\n    *   `[2, 3, 4].every(num => num % 2 === 0); // false (because 3 is not even)`",
          "options": [],
          "analysisPoints": [
            "Clearly defining the 'at least one' vs. 'all' distinction.",
            "Explaining the short-circuiting behavior.",
            "Addressing the empty array case for `every()`.",
            "Providing clear, distinct examples."
          ],
          "keyConcepts": [
            "some",
            "every",
            "array iteration",
            "boolean return",
            "short-circuiting"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions",
            "Clarity of examples",
            "Completeness of explanation"
          ],
          "example": "",
          "tags": [
            "some",
            "every",
            "array methods",
            "search",
            "open-ended"
          ],
          "prerequisites": [
            "theory_array_search_inspection_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_chaining_methods_1",
          "topic": "Chaining Array Methods",
          "level": "hard",
          "type": "code",
          "question": "Given an array of objects representing sales transactions:\n`const transactions = [\n  { id: 1, item: 'Laptop', price: 1200, quantity: 1, category: 'Electronics' },\n  { id: 2, item: 'Mouse', price: 25, quantity: 2, category: 'Electronics' },\n  { id: 3, item: 'Keyboard', price: 75, quantity: 1, category: 'Electronics' },\n  { id: 4, item: 'T-Shirt', price: 20, quantity: 3, category: 'Apparel' },\n  { id: 5, item: 'Jeans', price: 60, quantity: 1, category: 'Apparel' },\n  { id: 6, item: 'Monitor', price: 300, quantity: 1, category: 'Electronics' }\n];`\n\nWrite JavaScript code using a chain of non-mutating array methods (`filter`, `map`, `reduce`) to calculate the total revenue generated *only from 'Electronics'* category items that have a total item value (price * quantity) *greater than $100*.\n\nThe final result should be a single number.",
          "answer": "```javascript\nconst transactions = [\n  { id: 1, item: 'Laptop', price: 1200, quantity: 1, category: 'Electronics' },\n  { id: 2, item: 'Mouse', price: 25, quantity: 2, category: 'Electronics' },\n  { id: 3, item: 'Keyboard', price: 75, quantity: 1, category: 'Electronics' },\n  { id: 4, item: 'T-Shirt', price: 20, quantity: 3, category: 'Apparel' },\n  { id: 5, item: 'Jeans', price: 60, quantity: 1, category: 'Apparel' },\n  { id: 6, item: 'Monitor', price: 300, quantity: 1, category: 'Electronics' }\n];\n\nconst totalRevenue = transactions\n  .filter(transaction => transaction.category === 'Electronics') // Filter for Electronics\n  .filter(transaction => (transaction.price * transaction.quantity) > 100) // Filter for value > $100\n  .reduce((total, transaction) => total + (transaction.price * transaction.quantity), 0); // Sum up total values\n\nconsole.log(totalRevenue); // Expected: 1200 + 300 = 1500\n```",
          "options": [],
          "analysisPoints": [
            "Ability to combine multiple array methods (`filter`, `map`, `reduce`) in a chain.",
            "Correct application of filtering conditions.",
            "Accurate calculation of intermediate values (`price * quantity`).",
            "Proper use of `reduce()` for aggregation with an `initialValue`."
          ],
          "keyConcepts": [
            "filter",
            "map",
            "reduce",
            "chaining methods",
            "non-mutating",
            "data aggregation"
          ],
          "evaluationCriteria": [
            "Correctness of the final output",
            "Efficiency of the chain",
            "Adherence to non-mutating requirement"
          ],
          "example": "",
          "tags": [
            "filter",
            "map",
            "reduce",
            "array methods",
            "chaining",
            "code challenge"
          ],
          "prerequisites": [
            "theory_array_non_mutating_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_method_return_types_1",
          "topic": "Array Method Return Types",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following array methods *modifies the original array and returns the modified array itself*?",
          "answer": "`reverse()`",
          "options": [
            "`slice()`",
            "`map()`",
            "`concat()`",
            "`reverse()`"
          ],
          "analysisPoints": [
            "Distinguishing between methods that return a new array vs. modifying in place.",
            "Knowledge of the specific return values of various array methods."
          ],
          "keyConcepts": [
            "mutating methods",
            "non-mutating methods",
            "return values"
          ],
          "evaluationCriteria": [
            "Correctly identifying a mutating method",
            "Understanding method side effects"
          ],
          "example": "```javascript\nconst arr1 = [1, 2, 3];\nconst sliced = arr1.slice(1); // [2, 3], arr1 is still [1, 2, 3]\n\nconst arr2 = [1, 2, 3];\nconst mapped = arr2.map(x => x * 2); // [2, 4, 6], arr2 is still [1, 2, 3]\n\nconst arr3 = [1, 2];\nconst concated = arr3.concat([3]); // [1, 2, 3], arr3 is still [1, 2]\n\nconst arr4 = [1, 2, 3];\nconst reversed = arr4.reverse(); // [3, 2, 1], arr4 is now [3, 2, 1] AND reversed is also [3, 2, 1]\n```",
          "tags": [
            "mutating",
            "non-mutating",
            "array methods",
            "mcq"
          ],
          "prerequisites": [
            "theory_array_mutating_methods",
            "theory_array_non_mutating_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_find_findIndex_diff_1",
          "topic": "`find()` vs `findIndex()`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference in the return value of `find()` versus `findIndex()`?",
          "answer": "`find()` returns the first element that satisfies the condition (or `undefined`), while `findIndex()` returns the index of the first element that satisfies the condition (or -1).",
          "options": [],
          "analysisPoints": [
            "Understanding return types for search methods.",
            "Knowing the difference between an element and its index."
          ],
          "keyConcepts": [
            "find",
            "findIndex",
            "return value",
            "search methods"
          ],
          "evaluationCriteria": [
            "Accuracy of comparison",
            "Clarity of definition"
          ],
          "example": "",
          "tags": [
            "find",
            "findIndex",
            "array methods",
            "search",
            "flashcard"
          ],
          "prerequisites": [
            "theory_array_search_inspection_methods"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_manage_inventory_mutating",
          "title": "Inventory Management with Mutating Methods",
          "description": "\nImplement a JavaScript function `manageInventory` that simulates inventory operations on an array of product IDs. The function should perform the following operations in sequence using *mutating* array methods:\n\n1.  **Restock**: Add new product IDs to a specific position in the inventory.\n    *   If `newProducts` is provided, insert them starting at `startIndex`.\n2.  **Discontinue**: Remove a certain number of products from a given index.\n    *   If `discontinueCount` is greater than 0, remove that many items starting at `discontinueIndex`.\n3.  **Sort Inventory**: Sort the remaining product IDs numerically in ascending order.\n4.  **Fill Placeholders**: Replace the first `n` elements (where `n` is `fillCount`) of the array with a placeholder value (e.g., `null`), representing unavailable items, without changing the array length.\n\nYour function should return the final modified inventory array.\n",
          "difficulty": "medium",
          "startingCode": "function manageInventory(inventory, newProducts, startIndex, discontinueIndex, discontinueCount, fillCount) {\n  // 1. Restock (using splice)\n  if (newProducts && newProducts.length > 0) {\n    // TODO: Implement restock\n  }\n\n  // 2. Discontinue (using splice)\n  if (discontinueCount > 0) {\n    // TODO: Implement discontinue\n  }\n\n  // 3. Sort Inventory (using sort)\n  // TODO: Implement sort\n\n  // 4. Fill Placeholders (using fill)\n  if (fillCount > 0) {\n    // TODO: Implement fill\n  }\n\n  return inventory;\n}",
          "solutionCode": "function manageInventory(inventory, newProducts, startIndex, discontinueIndex, discontinueCount, fillCount) {\n  // Ensure inventory is an array\n  if (!Array.isArray(inventory)) {\n    throw new Error('Inventory must be an array.');\n  }\n\n  // 1. Restock (using splice)\n  if (newProducts && newProducts.length > 0) {\n    inventory.splice(startIndex, 0, ...newProducts);\n  }\n\n  // 2. Discontinue (using splice)\n  if (discontinueCount > 0) {\n    inventory.splice(discontinueIndex, discontinueCount);\n  }\n\n  // 3. Sort Inventory (using sort)\n  inventory.sort((a, b) => a - b);\n\n  // 4. Fill Placeholders (using fill)\n  if (fillCount > 0) {\n    inventory.fill(null, 0, fillCount);\n  }\n\n  return inventory;\n}",
          "testCases": [
            "manageInventory([10, 20, 30], [5, 15], 1, 0, 0, 0) should return [5, 10, 15, 20, 30]",
            "manageInventory([10, 20, 30, 40, 50], null, 0, 1, 2, 0) should return [10, 40, 50]",
            "manageInventory([1, 20, 5, 15, 10], null, 0, 0, 0, 0) should return [1, 5, 10, 15, 20]",
            "manageInventory([10, 20, 30, 40, 50], null, 0, 0, 0, 2) should return [null, null, 30, 40, 50]",
            "manageInventory([1, 2, 3, 4, 5], [100, 200], 2, 0, 1, 1) should return [null, 2, 100, 200, 3, 4, 5] (Sequence: initial [1,2,3,4,5] -> splice(2,0,100,200): [1,2,100,200,3,4,5] -> splice(0,1): [2,100,200,3,4,5] -> sort: [2,3,4,5,100,200] -> fill(null,0,1): [null,3,4,5,100,200])",
            "manageInventory([], [1, 2], 0, 0, 0, 0) should return [1, 2]"
          ],
          "hints": [
            "Remember that `splice()` can be used to insert elements by setting `deleteCount` to 0.",
            "For numeric sorting, `sort()` requires a compare function.",
            "Pay close attention to the `start` and `end` parameters for `fill()` to target the correct range."
          ],
          "tags": [
            "splice",
            "sort",
            "fill",
            "mutating methods",
            "array manipulation",
            "inventory"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_array_mutating_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "side effects",
            "data integrity"
          ]
        },
        {
          "id": "task_analyze_sales_data_non_mutating",
          "title": "Analyze Sales Data with Non-Mutating Methods",
          "description": "\nImplement a JavaScript function `analyzeSales` that takes an array of sales records and returns a new object containing aggregated data. The function should utilize *non-mutating* array methods to achieve the following:\n\n1.  **Filter High-Value Sales**: Select only sales records where the `amount` is greater than or equal to `$500`.\n2.  **Transform Data**: For each selected sale, create a new object containing only `transactionId`, `itemName`, and `totalPrice` (calculated as `amount * quantity`).\n3.  **Calculate Total Revenue**: Compute the sum of `totalPrice` for all the transformed high-value sales.\n4.  **List Unique Items**: Create an array of unique `itemName`s from the high-value sales.\n5.  **Output Structure**: The function should return an object like `{ totalRevenue: number, uniqueItemsSold: string[] }`.\n\nUse chaining where appropriate for efficiency and readability.\n",
          "difficulty": "hard",
          "startingCode": "function analyzeSales(salesRecords) {\n  // Sample salesRecords format:\n  // [{ transactionId: 'T101', itemName: 'Laptop', amount: 1200, quantity: 1 }, ...]\n\n  // TODO: Implement filtering, mapping, reducing, and identifying unique items\n\n  return {\n    totalRevenue: 0, // Placeholder\n    uniqueItemsSold: [] // Placeholder\n  };\n}",
          "solutionCode": "function analyzeSales(salesRecords) {\n  if (!Array.isArray(salesRecords)) {\n    throw new Error('Input must be an array of sales records.');\n  }\n\n  const highValueSales = salesRecords.filter(sale => sale.amount * sale.quantity >= 500);\n\n  const transformedSales = highValueSales.map(sale => ({\n    transactionId: sale.transactionId,\n    itemName: sale.itemName,\n    totalPrice: sale.amount * sale.quantity\n  }));\n\n  const totalRevenue = transformedSales.reduce((acc, sale) => acc + sale.totalPrice, 0);\n\n  // To get unique items, map to item names and then use Set to filter duplicates\n  const uniqueItemsSold = [...new Set(highValueSales.map(sale => sale.itemName))];\n\n  return {\n    totalRevenue,\n    uniqueItemsSold\n  };\n}",
          "testCases": [
            "analyzeSales([\n  { transactionId: 'T001', itemName: 'Keyboard', amount: 75, quantity: 2 },\n  { transactionId: 'T002', itemName: 'Monitor', amount: 500, quantity: 1 },\n  { transactionId: 'T003', itemName: 'Laptop', amount: 1200, quantity: 1 },\n  { transactionId: 'T004', itemName: 'Mouse', amount: 20, quantity: 5 },\n  { transactionId: 'T005', itemName: 'Monitor', amount: 600, quantity: 1 }\n]) should return { totalRevenue: 2300, uniqueItemsSold: ['Monitor', 'Laptop'] }",
            "analyzeSales([]) should return { totalRevenue: 0, uniqueItemsSold: [] }",
            "analyzeSales([\n  { transactionId: 'T001', itemName: 'Keyboard', amount: 75, quantity: 2 },\n  { transactionId: 'T002', itemName: 'Mouse', amount: 20, quantity: 5 }\n]) should return { totalRevenue: 0, uniqueItemsSold: [] } (no high-value sales)",
            "analyzeSales([\n  { transactionId: 'T001', itemName: 'Laptop', amount: 1000, quantity: 1 },\n  { transactionId: 'T002', itemName: 'Laptop', amount: 1500, quantity: 1 }\n]) should return { totalRevenue: 2500, uniqueItemsSold: ['Laptop'] }"
          ],
          "hints": [
            "Chain `filter()` first to narrow down the data.",
            "Use `map()` to transform the filtered data into the desired structure.",
            "Employ `reduce()` for summing the calculated `totalPrice`.",
            "For unique items, consider mapping to the item names first, then using a `Set` to get unique values, and finally spreading the Set back into an array."
          ],
          "tags": [
            "filter",
            "map",
            "reduce",
            "chaining",
            "non-mutating",
            "data aggregation",
            "object manipulation"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_array_non_mutating_methods",
            "javascript_objects"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "functional programming",
            "immutability",
            "data processing"
          ]
        },
        {
          "id": "task_validate_and_search_users",
          "title": "User Validation and Search System",
          "description": "\nImplement a JavaScript function `processUsers` that takes an array of user objects and performs validation and search operations using *search and inspection* array methods.\n\nEach user object has `id` (number), `username` (string), and `isActive` (boolean).\n\nYour function should return an object with the following properties:\n\n1.  **`hasAdmins`**: A boolean indicating if *any* user in the array has the `username` 'admin'.\n2.  **`allActive`**: A boolean indicating if *all* users in the array are `isActive`.\n3.  **`firstInactiveUser`**: The first user object found that is `isActive: false`. If no inactive user is found, this should be `null`.\n4.  **`indexOfSpecificUser`**: The index of the user with `username: 'guest'` and `id: 99`. If not found, it should be `-1`.\n5.  **`isGuestPresent`**: A boolean indicating if *any* user has the `username` 'guest'.\n",
          "difficulty": "medium",
          "startingCode": "function processUsers(users) {\n  // Sample user object format:\n  // [{ id: 1, username: 'user1', isActive: true }, ...]\n\n  return {\n    hasAdmins: false,           // Use `some()`\n    allActive: false,           // Use `every()`\n    firstInactiveUser: null,    // Use `find()`\n    indexOfSpecificUser: -1,    // Use `findIndex()` or `indexOf()` with helper\n    isGuestPresent: false       // Use `includes()` or `some()`\n  };\n}",
          "solutionCode": "function processUsers(users) {\n  if (!Array.isArray(users)) {\n    throw new Error('Input must be an array of user objects.');\n  }\n\n  const hasAdmins = users.some(user => user.username === 'admin');\n\n  const allActive = users.every(user => user.isActive);\n\n  const firstInactiveUser = users.find(user => !user.isActive) || null;\n\n  // For indexOfSpecificUser, we need to find an object matching two criteria.\n  // findIndex is suitable here.\n  const indexOfSpecificUser = users.findIndex(user => user.username === 'guest' && user.id === 99);\n\n  // isGuestPresent can be done with some() as well, for consistency with hasAdmins\n  const isGuestPresent = users.some(user => user.username === 'guest');\n\n  return {\n    hasAdmins,\n    allActive,\n    firstInactiveUser,\n    indexOfSpecificUser,\n    isGuestPresent\n  };\n}",
          "testCases": [
            "processUsers([]) should return { hasAdmins: false, allActive: true, firstInactiveUser: null, indexOfSpecificUser: -1, isGuestPresent: false } (Note: `every()` on empty array is `true`)",
            "processUsers([\n  { id: 1, username: 'user1', isActive: true },\n  { id: 2, username: 'admin', isActive: true },\n  { id: 3, username: 'user3', isActive: false }\n]) should return { hasAdmins: true, allActive: false, firstInactiveUser: { id: 3, username: 'user3', isActive: false }, indexOfSpecificUser: -1, isGuestPresent: false }",
            "processUsers([\n  { id: 10, username: 'guest', isActive: true },\n  { id: 99, username: 'guest', isActive: false },\n  { id: 3, username: 'user3', isActive: true }\n]) should return { hasAdmins: false, allActive: false, firstInactiveUser: { id: 99, username: 'guest', isActive: false }, indexOfSpecificUser: 1, isGuestPresent: true }",
            "processUsers([\n  { id: 1, username: 'user1', isActive: true },\n  { id: 2, username: 'user2', isActive: true }\n]) should return { hasAdmins: false, allActive: true, firstInactiveUser: null, indexOfSpecificUser: -1, isGuestPresent: false }"
          ],
          "hints": [
            "Remember `some()` returns true if *any* element passes, and `every()` returns true only if *all* elements pass.",
            "`find()` returns the element itself, while `findIndex()` returns its its index.",
            "Be careful with default values for `find()` (it returns `undefined` if no match, so you might need `|| null`)."
          ],
          "tags": [
            "some",
            "every",
            "find",
            "findIndex",
            "includes",
            "search methods",
            "validation"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_array_search_inspection_methods",
            "javascript_objects",
            "boolean logic"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "data lookup",
            "conditional logic",
            "short-circuiting"
          ]
        }
      ]
    }
  },
  {
    "id": "0ce2b077-a4ec-48ad-a2b6-9188b8c4f2de",
    "startLine": 1400,
    "endLine": 1499,
    "processedDate": "2025-06-17T07:53:41.754Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_array_iteration",
          "title": "Array Iteration Methods",
          "content": "JavaScript provides several ways to iterate over array elements, each with its own use cases and benefits. Understanding these methods is crucial for efficient data processing.\n\n## `Array.prototype.forEach()`\n`forEach` executes a provided function once for each array element. It's a high-order array method, meaning it takes a callback function as an argument. The callback function can access the current `item`, its `index`, and the `array` itself.\n\n**Characteristics:**\n-   Does not return a new array (unlike `map`, `filter`).\n-   Does not modify the original array unless the callback explicitly does so.\n-   Cannot be stopped or broken out of using `break` or `return` (it iterates over all elements).\n-   It's generally preferred for simple iteration where you just need to perform an action on each element.\n\n## `for...of` Loop\nThe `for...of` loop iterates over iterable objects (like Arrays, Strings, Maps, Sets, etc.), allowing you to access the *values* of properties. It provides a more modern and concise way to loop through elements compared to traditional `for` loops when you only need the value.\n\n**Characteristics:**\n-   Iterates directly over values, not indices.\n-   Supports `break`, `continue`, and `return` to control loop flow.\n-   Works with any iterable object, making it versatile.\n-   Generally preferred for simple iteration where the index is not needed, or when working with other iterable collections.\n\n## Traditional `for` Loop for Reverse Iteration\nThe traditional `for` loop offers the most control over the iteration process, including the ability to iterate in reverse or skip elements. It's particularly useful when you need to iterate backwards through an array, which can be important for algorithms that modify the array in place or when processing elements from the end.\n\n**Characteristics:**\n-   Provides full control over iteration start, end, and step.\n-   Allows direct access to elements by index.\n-   Can be used for forward, reverse, or stepped iteration.\n-   Useful when modifying an array while iterating (e.g., removing elements from the end to avoid index issues).\n\n",
          "examples": [
            {
              "id": "example_array_iteration_forEach",
              "title": "Using forEach",
              "code": "const array = ['apple', 'banana', 'cherry'];\n\narray.forEach((item, index) => {\n  console.log(`Element at index ${index}: ${item}`);\n});\n// Expected Output:\n// Element at index 0: apple\n// Element at index 1: banana\n// Element at index 2: cherry",
              "explanation": "This example demonstrates how `forEach` iterates over each item in the `array`, providing both the `item` and its `index` to the callback function. It's a clean way to perform an action for every element.",
              "language": "javascript"
            },
            {
              "id": "example_array_iteration_forOf",
              "title": "Using for...of",
              "code": "const array = ['red', 'green', 'blue'];\n\nfor (const item of array) {\n  console.log(`Color: ${item}`);\n}\n// Expected Output:\n// Color: red\n// Color: green\n// Color: blue",
              "explanation": "The `for...of` loop directly provides the value of each element in `array` without needing to access it via an index. This is simpler and more readable when only the value is required.",
              "language": "javascript"
            },
            {
              "id": "example_array_iteration_reverseForLoop",
              "title": "Reverse Array Iteration with for loop",
              "code": "const array = [10, 20, 30, 40];\n\nfor (let i = array.length - 1; i >= 0; i--) {\n  console.log(`Element from end: ${array[i]}`);\n}\n// Expected Output:\n// Element from end: 40\n// Element from end: 30\n// Element from end: 20\n// Element from end: 10",
              "explanation": "This traditional `for` loop iterates from the last element (length - 1) down to the first (index 0). It's crucial for scenarios where processing elements from end to start is necessary, for instance, when removing items from an array to avoid shifting indices.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_array_iteration_mcq_1",
            "question_array_iteration_code_1",
            "question_array_iteration_open_1",
            "question_array_iteration_flashcard_1"
          ],
          "relatedTasks": [
            "task_implement_array_reverse_log"
          ],
          "tags": [
            "Array Methods",
            "Iteration",
            "JavaScript Fundamentals",
            "ES6"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "functions"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_processing",
            "algorithm_design"
          ]
        },
        {
          "id": "theory_array_reordering",
          "title": "Array Manipulation and Reordering",
          "content": "Manipulating the order of elements within an array is a common task in programming. JavaScript provides built-in methods and patterns to achieve various reordering operations, from moving single items to completely randomizing the array or sorting it based on specific criteria.\n\n## Reordering a Single Item\nMoving an item from one position to another in an array often involves removing it from its current spot and inserting it into the new one. The `splice()` method is highly versatile for this purpose, as it can remove elements, insert elements, or both simultaneously.\n\n**`Array.prototype.splice(start, deleteCount, item1, item2, ...)`**\n-   `start`: Index at which to start changing the array.\n-   `deleteCount`: An integer indicating the number of elements to remove from `start`.\n-   `item1, item2, ...`: The elements to add to the array, starting at the `start` position.\n\nTo reorder an item: first, `splice(oldIndex, 1)` removes the item. Then, `splice(newIndex, 0, item)` inserts it at the desired position.\n\n## Shuffling an Array (Fisher-Yates Algorithm)\nShuffling an array means randomizing the order of its elements. The Fisher-Yates (also known as Knuth shuffle) algorithm is a widely accepted and efficient method for doing this, ensuring that all permutations are equally likely.\n\n**Algorithm Steps:**\n1.  Iterate backwards from the last element down to the second element (index 1).\n2.  In each iteration, generate a random index `j` such that `0 <= j <= i`.\n3.  Swap the element at the current index `i` with the element at the random index `j`.\n\nThis process ensures that each element has an equal chance of ending up in any position.\n\n## Sorting Array Elements\nSorting an array arranges its elements in a specific order (ascending, descending, alphabetical, numerical, etc.). JavaScript's `Array.prototype.sort()` method is used for this, but it requires careful handling, especially for non-string types.\n\n**`Array.prototype.sort(compareFunction)`**\n-   By default, `sort()` converts elements to strings and sorts them alphabetically (lexicographically).\n-   To sort numerically or by custom logic, you must provide a `compareFunction`.\n\n**`compareFunction(a, b)` rules:**\n-   If `compareFunction(a, b)` returns a value **less than 0**, `a` will come before `b`.\n-   If `compareFunction(a, b)` returns a value **greater than 0**, `b` will come before `a`.\n-   If `compareFunction(a, b)` returns **0**, the order of `a` and `b` remains unchanged.\n\n**Sorting Objects by Property:**\nWhen sorting an array of objects, the `compareFunction` is essential. You access the specific property of `a` and `b` (e.g., `a.age`, `b.name`) and then compare them. For strings, `localeCompare()` is recommended for accurate alphabetical sorting across different languages, as it handles Unicode characters and case sensitivity better than simple `<` or `>` comparisons.",
          "examples": [
            {
              "id": "example_array_reordering_item",
              "title": "Reordering an Array Item",
              "code": "function reorderItem(arr, oldIndex, newIndex) {\n  const item = arr.splice(oldIndex, 1)[0]; // Remove item\n  arr.splice(newIndex, 0, item);           // Insert item\n  return arr;\n}\n\nlet myArray = [10, 20, 30, 40, 50];\nconsole.log(reorderItem(myArray, 1, 3)); // Move 20 (index 1) to index 3\n// Expected Output: [10, 30, 40, 20, 50]\n\nmyArray = ['A', 'B', 'C', 'D'];\nconsole.log(reorderItem(myArray, 0, 2)); // Move 'A' (index 0) to index 2\n// Expected Output: ['B', 'C', 'A', 'D']",
              "explanation": "This function `reorderItem` demonstrates how to move an element within an array using two `splice` calls. The first `splice` removes the element, returning it as an array (hence `[0]` to get the element itself). The second `splice` then inserts that element at the specified new position without removing any existing elements.",
              "language": "javascript"
            },
            {
              "id": "example_array_reordering_shuffle",
              "title": "Shuffling an Array (Fisher-Yates)",
              "code": "function shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1)); // Random index from 0 to i\n    [array[i], array[j]] = [array[j], array[i]];   // Swap elements\n  }\n  return array;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nconsole.log(shuffle(numbers)); // Example Output: [3, 5, 1, 2, 4] (will vary)",
              "explanation": "The `shuffle` function implements the Fisher-Yates algorithm. It iterates from the end of the array. In each step, it picks a random element from the un-shuffled portion (from index 0 to `i`) and swaps it with the current element at `i`. This ensures a truly random permutation. Array destructuring `[array[i], array[j]] = [array[j], array[i]]` is used for an elegant swap.",
              "language": "javascript"
            },
            {
              "id": "example_array_reordering_sort",
              "title": "Sorting Objects by Property",
              "code": "const users = [\n  { name: 'John', age: 25, city: 'New York' },\n  { name: 'Jane', age: 30, city: 'London' },\n  { name: 'Jim', age: 20, city: 'Paris' },\n  { name: 'Alice', age: 25, city: 'Berlin' }\n];\n\n// Sort by age ascending\nconst sortedByAge = [...users].sort((a, b) => a.age - b.age);\nconsole.log('Sorted by age:', sortedByAge);\n/* Output:\n[ { name: 'Jim', age: 20, city: 'Paris' },\n  { name: 'John', age: 25, city: 'New York' },\n  { name: 'Alice', age: 25, city: 'Berlin' },\n  { name: 'Jane', age: 30, city: 'London' } ]\n*/\n\n// Sort by name alphabetically (case-insensitive)\nconst sortedByName = [...users].sort((a, b) => a.name.localeCompare(b.name));\nconsole.log('Sorted by name:', sortedByName);\n/* Output:\n[ { name: 'Alice', age: 25, city: 'Berlin' },\n  { name: 'Jane', age: 30, city: 'London' },\n  { name: 'Jim', age: 20, city: 'Paris' },\n  { name: 'John', age: 25, city: 'New York' } ]\n*/\n\n// Sort by age descending, then by name ascending for ties\nconst sortedByAgeName = [...users].sort((a, b) => {\n  if (a.age !== b.age) {\n    return b.age - a.age; // Descending age\n  }\n  return a.name.localeCompare(b.name); // Ascending name for ties\n});\nconsole.log('Sorted by age desc, then name asc:', sortedByAgeName);\n/* Output:\n[ { name: 'Jane', age: 30, city: 'London' },\n  { name: 'Alice', age: 25, city: 'Berlin' },\n  { name: 'John', age: 25, city: 'New York' },\n  { name: 'Jim', age: 20, city: 'Paris' } ]\n*/",
              "explanation": "This example shows various sorting scenarios with `Array.prototype.sort()` and a `compareFunction`. For numerical sorting (`age`), simple subtraction `a.age - b.age` works (positive for `b` before `a`, negative for `a` before `b`). For string sorting (`name`), `localeCompare()` is used for robust alphabetical comparison. The last example demonstrates multi-level sorting, handling ties by introducing a secondary comparison criterion.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_array_reordering_mcq_1",
            "question_array_reordering_code_1",
            "question_array_reordering_open_1",
            "question_array_reordering_flashcard_1",
            "question_array_reordering_mcq_2"
          ],
          "relatedTasks": [
            "task_implement_array_reorder",
            "task_implement_custom_sort_utility"
          ],
          "tags": [
            "Array Methods",
            "Sorting",
            "Shuffling",
            "Algorithms",
            "Fisher-Yates",
            "splice"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "functions",
            "math_random"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_manipulation",
            "ui_interactions",
            "game_development"
          ]
        },
        {
          "id": "theory_array_destructuring",
          "title": "Array Destructuring",
          "content": "Array destructuring is an ES6 feature that allows you to extract values from arrays into distinct variables using a syntax that mirrors array literals. It provides a more concise and readable way to unpack values from arrays, making code cleaner and more expressive.\n\n## Basic Destructuring\nIn its simplest form, array destructuring assigns elements from an array to variables declared on the left side of the assignment operator. The order of variables matters, as they are matched by index.\n\n## Skipping Elements\nSometimes you don't need all elements from an array. You can skip elements during destructuring by leaving empty commas for the positions you want to ignore.\n\n## Rest Pattern\nThe rest pattern (`...`) allows you to collect the remaining elements of an array into a new array. It must be the last variable in the destructuring assignment.\n\n## Default Values\nYou can assign default values to variables during destructuring. If the corresponding element in the array is `undefined` (or missing), the default value will be used instead. This is useful for providing fallbacks.\n\n## Swapping Variables\nOne of the most elegant uses of array destructuring is swapping the values of two variables without needing a temporary variable. This is achieved by creating a new array literal on the right-hand side with the swapped values and then destructuring it back into the original variables.\n\n## Nested Destructuring\nDestructuring can also be applied to nested arrays. You can match the structure of the nested array on the left-hand side to extract values from within it.\n\n## Functions Returning Multiple Values\nFunctions in JavaScript can only return a single value. However, by returning an array, you can use destructuring to easily unpack these 'multiple' values into distinct variables, improving the readability and usability of function return values.",
          "examples": [
            {
              "id": "example_array_destructuring_basic",
              "title": "Basic Destructuring and Skipping Elements",
              "code": "// Basic destructuring\nconst [a, b, c] = [1, 2, 3];\nconsole.log(a, b, c); // Output: 1 2 3\n\n// Skip elements\nconst [first, , third] = ['apple', 'banana', 'cherry'];\nconsole.log(first, third); // Output: apple cherry",
              "explanation": "The first part shows basic destructuring where variables `a`, `b`, and `c` are assigned values based on their position in the array. The second part demonstrates skipping elements by using empty commas, assigning only `first` and `third` values.",
              "language": "javascript"
            },
            {
              "id": "example_array_destructuring_rest_default",
              "title": "Rest Pattern and Default Values",
              "code": "// Rest pattern\nconst [head, ...tail] = [10, 20, 30, 40, 50];\nconsole.log(head, tail); // Output: 10 [20, 30, 40, 50]\n\n// Default values\nconst [x = 100, y = 200, z = 300] = [1, undefined, 5];\nconsole.log(x, y, z); // Output: 1 200 5\n\nconst [p = 1, q = 2] = [];\nconsole.log(p, q); // Output: 1 2",
              "explanation": "The rest pattern collects all remaining elements into a new array (`tail`). Default values provide a fallback if an element is `undefined` or missing from the array during assignment. Note that `null` would not trigger the default value, only `undefined`.",
              "language": "javascript"
            },
            {
              "id": "example_array_destructuring_swap_nested_function",
              "title": "Swapping Variables, Nested Destructuring, and Function Returns",
              "code": "// Swapping variables\nlet val1 = 'Hello';\nlet val2 = 'World';\n[val1, val2] = [val2, val1];\nconsole.log(val1, val2); // Output: World Hello\n\n// Nested destructuring\nconst [itemA, [itemB, itemC]] = [1, [2, 3]];\nconsole.log(itemA, itemB, itemC); // Output: 1 2 3\n\n// Functions that return multiple values\nfunction getCoordinates() {\n  return [100, 200, 'px'];\n}\nconst [coordX, coordY, unit] = getCoordinates();\nconsole.log(`X: ${coordX}, Y: ${coordY}, Unit: ${unit}`); // Output: X: 100, Y: 200, Unit: px",
              "explanation": "This example illustrates three advanced uses. Swapping variables becomes concise and elegant. Nested destructuring allows drilling into complex array structures. Finally, destructuring enables functions to effectively return multiple logical values by packaging them in an array, which can then be easily unpacked by the caller.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_array_destructuring_mcq_1",
            "question_array_destructuring_code_1",
            "question_array_destructuring_open_1",
            "question_array_destructuring_flashcard_1"
          ],
          "relatedTasks": [
            "task_implement_config_parser"
          ],
          "tags": [
            "Array Methods",
            "ES6",
            "Destructuring",
            "Syntax",
            "JavaScript Fundamentals"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_variables",
            "javascript_arrays"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_hooks",
            "api_response_handling",
            "modern_javascript"
          ]
        },
        {
          "id": "theory_common_array_operations",
          "title": "Common Array Utility Operations",
          "content": "Beyond basic manipulation, several common operations are frequently performed on arrays to transform, filter, or analyze their content. JavaScript provides powerful built-in features to achieve these tasks efficiently.\n\n## Creating a Range of Numbers\nGenerating a sequence of numbers (a range) is a common requirement. `Array.from()` combined with a mapping function is an elegant way to achieve this. `Array.from()` can create a new `Array` instance from an array-like or iterable object. When provided with an object having a `length` property and a mapping function, it effectively generates an array with transformed elements.\n\n**`Array.from(arrayLike, mapFn)`**\n-   `arrayLike`: An array-like object or iterable object.\n-   `mapFn`: A function to call on every element of the array-like object. It receives `(element, index)`.\n\nBy passing `{ length: N }` as `arrayLike`, you create an array of `N` `undefined` values, which the `mapFn` then transforms into the desired sequence.\n\n## Removing Duplicates using Set\nRemoving duplicate elements from an array is a classic problem. The `Set` object, introduced in ES6, provides a straightforward and efficient solution. A `Set` is a collection of unique values; it automatically discards any duplicate values added to it.\n\n**Process:**\n1.  Create a new `Set` from the array. This automatically removes duplicates.\n2.  Convert the `Set` back into an array using the spread syntax (`...`).\n\n## Finding Maximum Value\nDetermining the maximum value in a numeric array can be done using `Math.max()`. This function takes a variable number of arguments. By combining it with the spread syntax (`...`), you can pass all elements of an array as individual arguments to `Math.max()`.\n\n**`Math.max(...array)`**\n-   The spread syntax unpacks the array elements into a comma-separated list of arguments.\n\n## Checking for Common Elements\nTo determine if two arrays share any common elements, you can use a combination of array iteration methods. `Array.prototype.some()` tests whether at least one element in the array passes the test implemented by the provided function. `Array.prototype.includes()` determines whether an array includes a certain value among its entries, returning `true` or `false`.\n\n**`Array.prototype.some(callbackFn)`**\n-   `callbackFn`: A function to execute on each element, taking `(element, index, array)`.\n\n**`Array.prototype.includes(valueToFind)`**\n-   Returns `true` if `valueToFind` is found in the array, `false` otherwise.\n\nBy iterating through one array with `some()` and checking if each element is `included()` in the second array, you can efficiently detect common elements.",
          "examples": [
            {
              "id": "example_common_array_operations_range",
              "title": "Creating a Range of Numbers",
              "code": "// Create a range from 1 to 5\nconst range1to5 = Array.from({ length: 5 }, (_, i) => i + 1);\nconsole.log(range1to5); // Output: [1, 2, 3, 4, 5]\n\n// Create a range of even numbers\nconst evenNumbers = Array.from({ length: 3 }, (_, i) => (i + 1) * 2);\nconsole.log(evenNumbers); // Output: [2, 4, 6]",
              "explanation": "This example uses `Array.from()` with an object `{ length: N }` to create an array of `N` elements. The second argument is a map function that transforms each (initially undefined) element. `i` represents the index, allowing for flexible number generation.",
              "language": "javascript"
            },
            {
              "id": "example_common_array_operations_duplicates_max",
              "title": "Removing Duplicates and Finding Maximum Value",
              "code": "// Remove duplicates using Set\nconst arrWithDuplicates = [1, 2, 2, 3, 4, 4, 5, 1];\nconst uniqueArr = [...new Set(arrWithDuplicates)];\nconsole.log(uniqueArr); // Output: [1, 2, 3, 4, 5]\n\n// Find maximum value\nconst numbers = [10, 5, 8, 20, 15];\nconst maxValue = Math.max(...numbers);\nconsole.log(maxValue); // Output: 20\n\nconst emptyArray = [];\nconsole.log(Math.max(...emptyArray)); // Output: -Infinity (edge case for Math.max on empty array)",
              "explanation": "The `Set` object inherently stores only unique values, making it ideal for duplicate removal. Spreading an array into a `Set` removes duplicates, and then spreading the `Set` back into an array converts it to an array. `Math.max` used with the spread operator (`...`) is the concise way to find the largest number in a numeric array.",
              "language": "javascript"
            },
            {
              "id": "example_common_array_operations_common_elements",
              "title": "Checking for Common Elements",
              "code": "function hasCommonElement(arr1, arr2) {\n  return arr1.some(item => arr2.includes(item));\n}\n\nconst arrayA = [1, 2, 3, 4];\nconst arrayB = [3, 5, 6, 7];\nconst arrayC = [8, 9, 10];\n\nconsole.log(hasCommonElement(arrayA, arrayB)); // Output: true (because of 3)\nconsole.log(hasCommonElement(arrayA, arrayC)); // Output: false\nconsole.log(hasCommonElement([], arrayB));     // Output: false (edge case: empty array)",
              "explanation": "The `hasCommonElement` function efficiently checks for shared elements. `arr1.some(...)` iterates over `arrayA`. For each `item` from `arrayA`, `arr2.includes(item)` checks if that `item` exists in `arrayB`. If `includes` returns `true` for any `item`, `some` immediately returns `true`, indicating a common element. This avoids iterating through the entire arrays unnecessarily once a common element is found.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_common_array_operations_mcq_1",
            "question_common_array_operations_code_1",
            "question_common_array_operations_open_1",
            "question_common_array_operations_flashcard_1",
            "question_common_array_operations_mcq_2"
          ],
          "relatedTasks": [
            "task_implement_array_utilities"
          ],
          "tags": [
            "Array Methods",
            "Set",
            "Math",
            "ES6",
            "Utility Functions",
            "Data Manipulation"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "es6_features",
            "higher_order_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_transformation",
            "form_validation",
            "frontend_utilities"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_array_iteration_mcq_1",
          "topic": "Array Iteration Methods",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following array iteration methods does NOT allow you to easily stop or break out of the loop using `break` or `return`?",
          "answer": "forEach",
          "options": [
            "for...of",
            "for loop",
            "while loop",
            "forEach"
          ],
          "analysisPoints": [
            "Understanding of control flow within different loop types.",
            "Specific characteristics of `forEach` as a higher-order function."
          ],
          "keyConcepts": [
            "Array.prototype.forEach()",
            "for...of loop",
            "Traditional for loop",
            "Loop control statements"
          ],
          "evaluationCriteria": [
            "Recall of `forEach` limitations.",
            "Ability to differentiate loop types based on control flow."
          ],
          "example": "```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Using forEach (cannot break)\nlet sumForEach = 0;\nnumbers.forEach(num => {\n  sumForEach += num;\n  if (sumForEach > 6) { /* Cannot 'break' here */ }\n});\nconsole.log('ForEach sum:', sumForEach); // Will sum all numbers\n\n// Using for...of (can break)\nlet sumForOf = 0;\nfor (const num of numbers) {\n  sumForOf += num;\n  if (sumForOf > 6) {\n    break; // Loop stops here\n  }\n}\nconsole.log('For...of sum:', sumForOf); // Will sum up to 3 (1+2+3=6, next is 4 so 10 > 6, then breaks)\n\n// Using for loop (can break)\nlet sumFor = 0;\nfor (let i = 0; i < numbers.length; i++) {\n  sumFor += numbers[i];\n  if (sumFor > 6) {\n    break; // Loop stops here\n  }\n}\nconsole.log('For loop sum:', sumFor); // Will sum up to 3 (1+2+3=6, next is 4 so 10 > 6, then breaks)\n```\nThe `forEach` method is designed to iterate over all elements. While a `return` statement inside its callback will exit the *current* callback invocation, it will not stop the `forEach` loop from continuing to the next element. `break` is not allowed in `forEach` callbacks. In contrast, `for...of` and traditional `for` loops fully support `break` and `continue`.",
          "tags": [
            "Array Methods",
            "forEach",
            "for...of",
            "Loop Control"
          ],
          "prerequisites": [
            "javascript_arrays",
            "control_flow"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_code_1",
          "topic": "Array Iteration Methods",
          "level": "medium",
          "type": "code",
          "question": "Write a JavaScript function `logElementsInReverse` that takes an array as input and logs each element to the console, starting from the last element and ending with the first. You must use a traditional `for` loop for this task.",
          "answer": "```javascript\nfunction logElementsInReverse(arr) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    console.log(arr[i]);\n  }\n}\n\n// Test cases:\nlogElementsInReverse([1, 2, 3]);    // Expected: 3, 2, 1\nlogElementsInReverse(['a', 'b']);   // Expected: 'b', 'a'\nlogElementsInReverse([]);           // Expected: (no output)\nlogElementsInReverse([null, 'test']); // Expected: 'test', null\n```",
          "options": [],
          "analysisPoints": [
            "Correct initialization of loop counter (`arr.length - 1`).",
            "Correct loop condition (`i >= 0`).",
            "Correct decrement of loop counter (`i--`).",
            "Accessing array elements by index.",
            "Handling edge cases like empty arrays."
          ],
          "keyConcepts": [
            "Traditional for loop",
            "Reverse iteration",
            "Array indexing",
            "Edge case handling"
          ],
          "evaluationCriteria": [
            "Correctness of loop logic.",
            "Efficiency of the solution.",
            "Handling of boundary conditions."
          ],
          "example": "The solution correctly initializes the loop counter `i` to the last valid index (`arr.length - 1`). The loop continues as long as `i` is greater than or equal to `0`, covering all elements down to the first. `i--` ensures iteration in reverse order. Accessing `arr[i]` retrieves the element at the current index. For an empty array, `arr.length - 1` will be -1, causing the loop condition `i >= 0` to be immediately false, and thus no elements are logged, which is the correct behavior.",
          "tags": [
            "Array Iteration",
            "for loop",
            "Reverse",
            "Basic Algorithm"
          ],
          "prerequisites": [
            "javascript_arrays",
            "control_flow"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_open_1",
          "topic": "Array Iteration Methods",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast `Array.prototype.forEach()` and the `for...of` loop for iterating over arrays. Discuss their primary use cases, advantages, and disadvantages.",
          "answer": "### `Array.prototype.forEach()`\n**Use Cases:**\n-   When you need to execute a function for each element and potentially access the index or the original array.\n-   Performing side effects (e.g., logging, updating DOM elements) for each item.\n\n**Advantages:**\n-   **Concise and readable** for simple iterations where a function needs to be applied to each element.\n-   Provides access to `item`, `index`, and the `array` itself in the callback.\n-   Part of the Array prototype, aligning with functional programming paradigms.\n\n**Disadvantages:**\n-   **Cannot break or continue** the loop: `return` only exits the current callback, not the `forEach` iteration.\n-   **Synchronous**: It doesn't handle asynchronous operations well within the loop itself (e.g., `await` inside `forEach` callback won't wait for each promise to resolve before moving to the next iteration).\n-   Less control over iteration start, end, or step.\n\n### `for...of` Loop\n**Use Cases:**\n-   When you need to iterate directly over the *values* of an iterable (arrays, strings, Maps, Sets, NodeLists, etc.).\n-   When you need to use `break`, `continue`, or `return` to control the loop's flow.\n-   When working with asynchronous operations (e.g., `await` works correctly inside `for...of`).\n\n**Advantages:**\n-   **Direct access to values**: More semantic if you only need the element value.\n-   **Supports `break`, `continue`, and `return`**: Offers full control over loop execution.\n-   **Works with any iterable**: More general-purpose than `forEach`.\n-   **Handles asynchronous operations naturally**: `await` pauses the loop until the promise resolves.\n\n**Disadvantages:**\n-   **No direct index access**: You need a counter variable (`let i = 0; i++`) if you also need the index.\n-   Can be slightly more verbose than `forEach` for simple transformations if an index is explicitly added.\n\n**Comparison Summary:**\n-   `forEach` is a higher-order function, good for applying a function to each element. `for...of` is a loop construct, good for iterating over values of any iterable.\n-   `forEach` is synchronous and does not allow premature termination. `for...of` allows full control over loop flow with `break`/`continue` and supports `await`.\n-   `forEach` provides the index automatically; `for...of` requires manual index tracking if needed.\n\nChoose `forEach` for simple, complete iterations or side effects where control flow is not an issue. Choose `for...of` when you need loop control, asynchronous handling, or are iterating over non-array iterables or only need values.",
          "options": [],
          "analysisPoints": [
            "Ability to list advantages and disadvantages for both methods.",
            "Understanding of their respective control flow mechanisms.",
            "Knowledge of suitable use cases for each.",
            "Awareness of `forEach`'s limitations with `break`/`continue` and `async/await`.",
            "Understanding of `for...of`'s generality for iterables."
          ],
          "keyConcepts": [
            "Array.prototype.forEach()",
            "for...of loop",
            "Loop control statements",
            "Synchronous vs. Asynchronous iteration",
            "Higher-order functions",
            "Iterables"
          ],
          "evaluationCriteria": [
            "Depth of comparison.",
            "Accuracy of technical details.",
            "Clarity and structure of explanation.",
            "Demonstration of practical understanding."
          ],
          "example": "",
          "tags": [
            "Array Methods",
            "Iteration",
            "Comparison",
            "JavaScript Fundamentals",
            "ES6"
          ],
          "prerequisites": [
            "javascript_arrays",
            "control_flow",
            "functions",
            "async_javascript"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_iteration_flashcard_1",
          "topic": "Array Iteration Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between `array.forEach()` and `for...of` regarding element access?",
          "answer": "`array.forEach()` provides access to both the element `item` and its `index` (and the `array` itself) in its callback, whereas `for...of` directly provides only the element `value`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "forEach",
            "for...of",
            "Array iteration",
            "Index access",
            "Value access"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "Array Methods",
            "Iteration",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_reordering_mcq_1",
          "topic": "Array Manipulation and Reordering",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following JavaScript code, what will be the output after executing `reorderItem(myArray, 2, 0)`?\n\n```javascript\nfunction reorderItem(arr, oldIndex, newIndex) {\n  const item = arr.splice(oldIndex, 1)[0];\n  arr.splice(newIndex, 0, item);\n  return arr;\n}\n\nlet myArray = ['A', 'B', 'C', 'D', 'E'];\n// console.log(reorderItem(myArray, 2, 0));\n```",
          "answer": "['C', 'A', 'B', 'D', 'E']",
          "options": [
            "['C', 'A', 'B', 'D', 'E']",
            "['A', 'B', 'D', 'C', 'E']",
            "['A', 'C', 'B', 'D', 'E']",
            "['A', 'B', 'C', 'D', 'E']"
          ],
          "analysisPoints": [
            "Understanding of `Array.prototype.splice()` behavior for removal.",
            "Understanding of `Array.prototype.splice()` behavior for insertion.",
            "Tracing the array state after each `splice` operation."
          ],
          "keyConcepts": [
            "Array.prototype.splice()",
            "Array reordering",
            "In-place modification"
          ],
          "evaluationCriteria": [
            "Ability to mentally trace array operations.",
            "Correct application of `splice` method arguments."
          ],
          "example": "Initial `myArray`: `['A', 'B', 'C', 'D', 'E']`\n\n1.  `const item = arr.splice(oldIndex, 1)[0];`\n    -   `oldIndex` is 2, so `arr.splice(2, 1)` removes `C`.\n    -   `item` becomes `'C'`.\n    -   `arr` becomes `['A', 'B', 'D', 'E']`.\n\n2.  `arr.splice(newIndex, 0, item);`\n    -   `newIndex` is 0, so `arr.splice(0, 0, 'C')` inserts `C` at index 0.\n    -   `arr` becomes `['C', 'A', 'B', 'D', 'E']`.\n\nTherefore, the final output is `['C', 'A', 'B', 'D', 'E']`.",
          "tags": [
            "Array Methods",
            "splice",
            "Reordering"
          ],
          "prerequisites": [
            "javascript_arrays",
            "array_splice"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_reordering_code_1",
          "topic": "Array Manipulation and Reordering",
          "level": "hard",
          "type": "code",
          "question": "Implement a function `sortUsersByMultipleCriteria(users)` that sorts an array of user objects. Each user object has `name` (string) and `score` (number) properties. The sorting should follow these rules:\n1.  Primary sort: Descending order by `score`.\n2.  Secondary sort (for ties in score): Ascending alphabetical order by `name`.\n\nYour function should return a *new* sorted array, leaving the original array unchanged.",
          "answer": "```javascript\nfunction sortUsersByMultipleCriteria(users) {\n  // Create a shallow copy to avoid modifying the original array\n  return [...users].sort((a, b) => {\n    // Primary sort: by score (descending)\n    if (a.score !== b.score) {\n      return b.score - a.score; // b - a for descending numerical sort\n    }\n    // Secondary sort: by name (ascending) for ties in score\n    return a.name.localeCompare(b.name); // a.localeCompare(b) for ascending alphabetical sort\n  });\n}\n\n// Test Cases:\nconst testUsers1 = [\n  { name: 'John', score: 85 },\n  { name: 'Jane', score: 90 },\n  { name: 'Jim', score: 85 },\n  { name: 'Alice', score: 90 },\n  { name: 'Bob', score: 70 }\n];\n\nconst sortedUsers1 = sortUsersByMultipleCriteria(testUsers1);\nconsole.log('Test Case 1 Sorted:', sortedUsers1);\n/* Expected Output:\n[\n  { name: 'Alice', score: 90 },\n  { name: 'Jane', score: 90 },\n  { name: 'Jim', score: 85 },\n  { name: 'John', score: 85 },\n  { name: 'Bob', score: 70 }\n]\n*/\n\nconsole.log('Original Array Unchanged:', testUsers1); // Should be the original order\n\nconst testUsers2 = [\n  { name: 'Zoe', score: 100 },\n  { name: 'Aaron', score: 100 }\n];\nconst sortedUsers2 = sortUsersByMultipleCriteria(testUsers2);\nconsole.log('Test Case 2 Sorted:', sortedUsers2);\n/* Expected Output:\n[\n  { name: 'Aaron', score: 100 },\n  { name: 'Zoe', score: 100 }\n]\n*/\n\nconst testUsers3 = [];\nconsole.log('Test Case 3 (Empty Array):', sortUsersByMultipleCriteria(testUsers3)); // Expected: []\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `Array.prototype.sort()` with a custom comparison function.",
            "Implementing multi-criteria sorting logic (if-else or similar structure).",
            "Correctly handling numerical descending sort (`b.score - a.score`).",
            "Correctly handling string ascending sort (`a.name.localeCompare(b.name)`).",
            "Ensuring the original array is not mutated (using spread syntax for shallow copy)."
          ],
          "keyConcepts": [
            "Array.prototype.sort()",
            "Comparison function",
            "Multi-criteria sorting",
            "Immutability",
            "localeCompare()"
          ],
          "evaluationCriteria": [
            "Correctness of sorting logic.",
            "Adherence to immutability.",
            "Efficiency of the comparison function.",
            "Handling of edge cases (e.g., empty array, all scores tied)."
          ],
          "example": "The solution utilizes `[...users].sort()` to create a shallow copy of the array before sorting, thus preserving the original array's immutability. The `compareFunction` first checks if scores are different; if so, it sorts in descending order (`b.score - a.score`). If scores are equal, it proceeds to the secondary sort, using `a.name.localeCompare(b.name)` for ascending alphabetical order of names. This logic correctly implements the requested sorting rules.",
          "tags": [
            "Array Methods",
            "Sorting",
            "Algorithms",
            "Immutability",
            "Objects"
          ],
          "prerequisites": [
            "javascript_arrays",
            "functions",
            "object_properties"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_reordering_open_1",
          "topic": "Array Manipulation and Reordering",
          "level": "medium",
          "type": "open",
          "question": "Explain the Fisher-Yates shuffle algorithm. Why is it considered a good method for shuffling an array, and what are its key advantages over simpler approaches like `array.sort(() => Math.random() - 0.5)`?",
          "answer": "The Fisher-Yates shuffle (also known as the Knuth shuffle) is an algorithm for generating a random permutation of a finite sequence. The basic idea is to iterate the array from the last element down to the second (index 1). In each iteration, a random element from the *unshuffled* portion of the array (from index 0 up to the current index `i` inclusive) is selected and swapped with the element at the current index `i`.\n\n**Algorithm Steps (Backward Iteration):**\n1.  Start from the last element, `i = array.length - 1`.\n2.  Loop while `i > 0` (down to the second element).\n3.  Generate a random index `j` such that `0 <= j <= i`.\n4.  Swap `array[i]` and `array[j]`.\n5.  Decrement `i` and repeat.\n\n**Why it's good (Advantages):**\n1.  **Uniform Distribution**: The Fisher-Yates shuffle guarantees a perfectly uniform distribution, meaning every possible permutation of the array has an exactly equal probability of occurring. This is crucial for applications requiring true randomness, like card games.\n2.  **In-place**: It shuffles the array in-place, meaning it doesn't require creating a new array, thus being memory efficient (O(1) auxiliary space).\n3.  **Efficiency**: It has a time complexity of O(n), where n is the number of elements in the array, as it performs a constant number of operations for each element.\n\n**Disadvantages of `array.sort(() => Math.random() - 0.5)`:**\nThis simpler approach, while seemingly effective, is **flawed** because:\n1.  **Non-Uniform Distribution**: It does *not* produce a uniformly random permutation. The `sort` method's stability and how comparison functions are implemented can lead to certain elements having a higher or lower probability of ending up in specific positions. For small arrays, the bias might be less noticeable, but it becomes significant with larger arrays.\n2.  **Implementation-Dependent**: The exact behavior can vary across JavaScript engines because the `sort` algorithm itself is not strictly defined in the ECMAScript standard (though most modern engines use Timsort or similar, which are stable). This makes the randomness unpredictable and unreliable.\n3.  **Less Efficient**: `sort` typically has a time complexity of O(N log N), which is less efficient than the O(N) of Fisher-Yates, especially for large arrays.",
          "options": [],
          "analysisPoints": [
            "Detailed explanation of the Fisher-Yates algorithm steps.",
            "Discussion of uniform distribution as a key advantage.",
            "Comparison of Fisher-Yates vs. `sort(() => Math.random())` in terms of randomness and efficiency.",
            "Understanding the `sort` method's internal workings and why it's not suitable for shuffling."
          ],
          "keyConcepts": [
            "Fisher-Yates Shuffle",
            "Randomization",
            "Uniform Distribution",
            "In-place Algorithm",
            "Time Complexity",
            "Array.prototype.sort()",
            "Math.random()"
          ],
          "evaluationCriteria": [
            "Accuracy of algorithm description.",
            "Clarity of explanation regarding randomness and bias.",
            "Depth of comparative analysis.",
            "Understanding of algorithmic efficiency."
          ],
          "example": "",
          "tags": [
            "Algorithms",
            "Shuffling",
            "Randomness",
            "Array Methods",
            "Fisher-Yates",
            "Best Practices"
          ],
          "prerequisites": [
            "javascript_arrays",
            "math_random",
            "algorithms_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_reordering_flashcard_1",
          "topic": "Array Manipulation and Reordering",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `localeCompare()` when sorting an array of strings or objects by a string property?",
          "answer": "`localeCompare()` is used for reliable alphabetical string comparison, especially for strings containing non-ASCII characters or needing case-insensitive sorting. It accounts for different language conventions, providing a more robust and accurate sort order compared to simple `<` or `>` operators.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "localeCompare",
            "String sorting",
            "Array.prototype.sort()",
            "Unicode",
            "Internationalization"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "Array Methods",
            "Sorting",
            "String",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_reordering_mcq_2",
          "topic": "Array Manipulation and Reordering",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following `Array.prototype.sort()` comparison functions would correctly sort an array of numbers `[3, 1, 4, 1, 5, 9]` in ascending order?",
          "answer": "`numbers.sort((a, b) => a - b);`",
          "options": [
            "`numbers.sort((a, b) => b - a);`",
            "`numbers.sort();`",
            "`numbers.sort((a, b) => a - b);`",
            "`numbers.sort((a, b) => (a > b ? 1 : -1));`"
          ],
          "analysisPoints": [
            "Understanding of `Array.prototype.sort()` default behavior (string comparison).",
            "Correct logic for numerical ascending sort (`a - b`).",
            "Correct logic for numerical descending sort (`b - a`).",
            "Recognition of the strict `1` or `-1` return values vs. numerical subtraction."
          ],
          "keyConcepts": [
            "Array.prototype.sort()",
            "Comparison function",
            "Numerical sorting",
            "Ascending order"
          ],
          "evaluationCriteria": [
            "Correct application of sort comparison rules.",
            "Ability to distinguish between default and custom sorting."
          ],
          "example": "The default `numbers.sort()` would convert numbers to strings and sort lexicographically (e.g., `[1, 1, 3, 4, 5, 9]` would become `[1, 1, 3, 4, 5, 9]` for this specific set, but for `[10, 2]` it would be `[10, 2]` because '10' comes before '2').\n\n-   `numbers.sort((a, b) => b - a);` would sort in descending order.\n-   `numbers.sort((a, b) => (a > b ? 1 : -1));` is an equivalent, but more verbose, way to sort in ascending order for primitive types, similar to `a - b`. However, `a - b` is the idiomatic and most concise way for numerical sorting.\n\nTherefore, `numbers.sort((a, b) => a - b);` is the correct and most common way to achieve ascending numerical sort.",
          "tags": [
            "Array Methods",
            "Sorting",
            "Numerical Sort"
          ],
          "prerequisites": [
            "javascript_arrays",
            "array_sort"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_destructuring_mcq_1",
          "topic": "Array Destructuring",
          "level": "easy",
          "type": "mcq",
          "question": "What will be the output of the following JavaScript code snippet?\n\n```javascript\nconst [x, y, ...z] = [10, 20, 30, 40, 50];\nconsole.log(x, y, z);\n```",
          "answer": "10 20 [30, 40, 50]",
          "options": [
            "10 20 30 40 50",
            "10 20 [30, 40, 50]",
            "10 20 30",
            "Error"
          ],
          "analysisPoints": [
            "Understanding of basic array destructuring.",
            "Correct application of the rest pattern (`...`)."
          ],
          "keyConcepts": [
            "Array Destructuring",
            "Rest Pattern",
            "ES6"
          ],
          "evaluationCriteria": [
            "Recall of destructuring syntax.",
            "Ability to predict output based on rest pattern."
          ],
          "example": "The code uses array destructuring with the rest pattern. `x` gets the first element (10), `y` gets the second (20), and `...z` collects all *remaining* elements into a new array `z`. Therefore, `z` will be `[30, 40, 50]`.",
          "tags": [
            "Destructuring",
            "ES6",
            "Rest Pattern"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_destructuring_code_1",
          "topic": "Array Destructuring",
          "level": "medium",
          "type": "code",
          "question": "Write a function `processUserProfile` that accepts an array representing a user profile `[id, username, email, optionalRole = 'user']`. Use array destructuring to extract `id`, `username`, `email`, and `role` (with a default value of 'user' if not provided). The function should return an object with these properties. Handle cases where `optionalRole` might be missing.",
          "answer": "```javascript\nfunction processUserProfile(profileArray) {\n  const [id, username, email, role = 'user'] = profileArray;\n  return {\n    id,\n    username,\n    email,\n    role\n  };\n}\n\n// Test cases:\nconsole.log(processUserProfile([1, 'john_doe', 'john@example.com', 'admin']));\n// Expected: { id: 1, username: 'john_doe', email: 'john@example.com', role: 'admin' }\n\nconsole.log(processUserProfile([2, 'jane_smith', 'jane@example.com']));\n// Expected: { id: 2, username: 'jane_smith', email: 'jane@example.com', role: 'user' }\n\nconsole.log(processUserProfile([3, 'guest_user', 'guest@example.com', undefined]));\n// Expected: { id: 3, username: 'guest_user', email: 'guest@example.com', role: 'user' }\n\nconsole.log(processUserProfile([4, 'dev_user', 'dev@example.com', null]));\n// Expected: { id: 4, username: 'dev_user', email: 'dev@example.com', role: null } (Important: null is not undefined)\n```",
          "options": [],
          "analysisPoints": [
            "Correct application of array destructuring syntax.",
            "Proper use of default values in destructuring.",
            "Understanding that `null` is not `undefined` for default values.",
            "Creating and returning an object from destructured values."
          ],
          "keyConcepts": [
            "Array Destructuring",
            "Default Values",
            "ES6",
            "Function Parameters"
          ],
          "evaluationCriteria": [
            "Correctness of destructuring.",
            "Accuracy of default value handling.",
            "Clarity and conciseness of code."
          ],
          "example": "The solution uses array destructuring `[id, username, email, role = 'user'] = profileArray` directly within the function. The `role = 'user'` part ensures that if `profileArray[3]` is `undefined` (either omitted or explicitly passed as `undefined`), `role` will default to `'user'`. If `profileArray[3]` is `null`, `role` will be `null` because `null` is a distinct value and not `undefined`.",
          "tags": [
            "Destructuring",
            "ES6",
            "Functions",
            "Objects"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features",
            "javascript_objects"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_destructuring_open_1",
          "topic": "Array Destructuring",
          "level": "medium",
          "type": "open",
          "question": "Describe the benefits of using array destructuring in JavaScript code. Provide at least three distinct scenarios where it significantly improves code readability or functionality.",
          "answer": "Array destructuring in JavaScript provides a powerful and concise way to extract values from arrays. Its primary benefits revolve around improving code readability, reducing boilerplate, and enabling more expressive patterns.\n\n**Benefits:**\n1.  **Readability and Conciseness**: It allows developers to declare multiple variables and assign values from an array in a single, clear line of code, mirroring the structure of the array. This reduces the need for repetitive index-based access (`arr[0]`, `arr[1]`).\n2.  **Cleaner Variable Assignment**: It streamlines the process of extracting specific elements, making code easier to understand at a glance.\n3.  **Default Values**: The ability to set default values for variables extracted from the array simplifies handling optional or potentially missing elements, reducing verbose `if` statements or logical OR operators.\n4.  **Swapping Variables Elegantly**: It provides a remarkably clean syntax for swapping the values of two variables without needing a temporary variable.\n5.  **Improved Function Return Values**: Functions can return arrays of multiple related values, and destructuring makes consuming these values much cleaner and more explicit than relying on object properties or manual indexing.\n\n**Scenarios for Improvement:**\n1.  **Swapping Two Variables**: Instead of `let temp = a; a = b; b = temp;`, you can simply write `[a, b] = [b, a];`. This is highly intuitive and reduces a common boilerplate pattern.\n    ```javascript\n    let x = 5;\n    let y = 10;\n    [x, y] = [y, x]; // x is now 10, y is now 5\n    ```\n2.  **Extracting Specific Values from an API Response or Data Row**: When an API returns data as a fixed-length array (e.g., `[id, name, status, createdDate]`), destructuring allows for direct naming of these values, improving clarity compared to `response[0]`, `response[1]`, etc.\n    ```javascript\n    const userProfile = [101, 'Alice', 'active', '2023-01-15'];\n    const [userId, userName, userStatus, createdAt] = userProfile;\n    console.log(`User ${userName} (ID: ${userId}) is ${userStatus}.`);\n    ```\n3.  **Handling Multiple Return Values from a Function**: Functions often need to return more than one piece of information (e.g., coordinates, success status and error message). Returning an array and then destructuring it makes the intent clear and usage straightforward.\n    ```javascript\n    function parseCoordinates(input) {\n      // ... parsing logic\n      if (isValid) return [true, x, y];\n      return [false, 'Invalid format'];\n    }\n\n    const [success, ...data] = parseCoordinates('10,20');\n    if (success) {\n      const [x, y] = data; // Nested destructuring for returned array\n      console.log(`Parsed X: ${x}, Y: ${y}`);\n    } else {\n      const [errorMessage] = data;\n      console.log(`Error: ${errorMessage}`);\n    }\n    ```\n    This avoids returning an object when the order is clear or when a simple tuple-like structure is desired.",
          "options": [],
          "analysisPoints": [
            "Clear articulation of array destructuring's core benefits.",
            "Providing concrete, distinct examples for each scenario.",
            "Demonstrating improved code readability/functionality in examples.",
            "Understanding common pitfalls destructuring helps avoid (e.g., temporary variables, magic numbers for array indices)."
          ],
          "keyConcepts": [
            "Array Destructuring",
            "ES6",
            "Readability",
            "Conciseness",
            "Variable Swapping",
            "Function Return Values",
            "Default Values"
          ],
          "evaluationCriteria": [
            "Comprehensiveness of benefits listed.",
            "Relevance and clarity of examples.",
            "Depth of understanding demonstrated.",
            "Structure and coherence of the explanation."
          ],
          "example": "",
          "tags": [
            "Destructuring",
            "ES6",
            "Best Practices",
            "Code Quality",
            "Functions"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_destructuring_flashcard_1",
          "topic": "Array Destructuring",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you skip elements when using array destructuring?",
          "answer": "You can skip elements by leaving empty commas for the positions you want to ignore in the destructuring pattern. For example, `const [first, , third] = [1, 2, 3];` would assign `1` to `first` and `3` to `third`, skipping `2`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Array Destructuring",
            "Skipping Elements",
            "Syntax"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "Destructuring",
            "ES6",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_common_array_operations_mcq_1",
          "topic": "Common Array Utility Operations",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following methods is the most concise and idiomatic way to create an array of numbers from 0 up to (but not including) N, for example `[0, 1, 2]` for N=3?",
          "answer": "`Array.from({ length: N }, (_, i) => i);`",
          "options": [
            "`Array.from({ length: N }, (_, i) => i);`",
            "`new Array(N).fill(0).map((_, i) => i);`",
            "`[...Array(N).keys()];`",
            "`for (let i = 0; i < N; i++) { arr.push(i); }`"
          ],
          "analysisPoints": [
            "Understanding of `Array.from()` with a `length` property.",
            "Understanding of `Array.prototype.keys()`.",
            "Comparison of conciseness and common idioms."
          ],
          "keyConcepts": [
            "Array.from()",
            "Array.prototype.keys()",
            "Array generation",
            "Conciseness"
          ],
          "evaluationCriteria": [
            "Recognition of modern JavaScript array creation patterns.",
            "Ability to select the most idiomatic solution.",
            "Understanding of various approaches."
          ],
          "example": "While all options can achieve the result, `Array.from({ length: N }, (_, i) => i);` is widely considered the most modern, readable, and flexible way to create arrays with a sequence of values in JavaScript.\n\n-   `new Array(N).fill(0).map((_, i) => i);` also works, but `fill(0)` is an unnecessary step if the elements are immediately mapped.\n-   `[...Array(N).keys()];` is very concise and also correct, relying on `Array.prototype.keys()` which returns an iterator of keys (indices). This is also a strong candidate.\n-   The `for` loop is a traditional but more verbose imperative approach.\n\nBoth `Array.from({ length: N }, (_, i) => i);` and `[...Array(N).keys()];` are excellent. The first option is often slightly more versatile as it allows more complex mapping functions easily.",
          "tags": [
            "Array Creation",
            "Array.from",
            "ES6",
            "Utility"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_common_array_operations_code_1",
          "topic": "Common Array Utility Operations",
          "level": "medium",
          "type": "code",
          "question": "Implement a function `getUniqueNumbers(numbers)` that takes an array of numbers (which may contain duplicates) and returns a new array containing only the unique numbers, maintaining their original order of appearance as much as possible. Do not use an additional loop beyond what's necessary for the primary operation.",
          "answer": "```javascript\nfunction getUniqueNumbers(numbers) {\n  // Using Set to remove duplicates while preserving order via Map\n  // A Map can store elements and maintain insertion order.\n  // Alternatively, LinkedHashSet in Java, but JS Set preserves insertion order for primitives.\n  return [...new Set(numbers)];\n}\n\n// Test cases:\nconsole.log(getUniqueNumbers([1, 2, 2, 3, 4, 4, 5, 1])); // Expected: [1, 2, 3, 4, 5]\nconsole.log(getUniqueNumbers([5, 4, 3, 2, 1, 5, 4])); // Expected: [5, 4, 3, 2, 1]\nconsole.log(getUniqueNumbers([]));                   // Expected: []\nconsole.log(getUniqueNumbers([10]));                  // Expected: [10]\nconsole.log(getUniqueNumbers([null, 1, null, 2]));    // Expected: [null, 1, 2]\n\n// Note on preserving order: For primitive types, Set guarantees insertion order.\n// For objects, this method removes duplicate references, not duplicate object values.\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `Set` for duplicate removal.",
            "Using the spread operator to convert `Set` back to an array.",
            "Understanding that `Set` preserves insertion order for primitives.",
            "Efficiency (O(N) time complexity).",
            "Handling edge cases like empty arrays."
          ],
          "keyConcepts": [
            "Set Object",
            "Spread Syntax",
            "Duplicate Removal",
            "ES6"
          ],
          "evaluationCriteria": [
            "Correctness and conciseness of the solution.",
            "Efficiency (avoiding nested loops).",
            "Understanding of `Set` behavior."
          ],
          "example": "The most straightforward and efficient way to get unique numbers while preserving their first-seen order is to leverage the `Set` object. A `Set` stores only unique values and maintains their insertion order. By creating a `new Set(numbers)` and then spreading it into a new array (`[...new Set(numbers)]`), we effectively remove duplicates and get the unique elements in their original relative order.",
          "tags": [
            "Array Methods",
            "Set",
            "Duplicates",
            "ES6",
            "Data Transformation"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_common_array_operations_open_1",
          "topic": "Common Array Utility Operations",
          "level": "hard",
          "type": "open",
          "question": "You need to find the union of two arrays (all unique elements from both arrays) and the intersection of two arrays (only common elements found in both). Explain how you would implement both functions (`arrayUnion` and `arrayIntersection`) efficiently in JavaScript, focusing on modern approaches. Consider the performance implications.",
          "answer": "### `arrayUnion(arr1, arr2)`\nThe union of two arrays consists of all unique elements that are present in either array.\n\n**Implementation Strategy:**\n1.  Combine both arrays into a single array using the spread operator (`...`).\n2.  Use a `Set` to automatically filter out duplicate elements, as `Set` only stores unique values.\n3.  Convert the `Set` back into an array using the spread operator.\n\n**Code:**\n```javascript\nfunction arrayUnion(arr1, arr2) {\n  return [...new Set([...arr1, ...arr2])];\n}\n```\n\n**Performance Implications:**\n-   Time Complexity: O(M + N), where M and N are the lengths of `arr1` and `arr2`. This is because iterating through both arrays to build the combined array is O(M+N), and then adding elements to a `Set` (on average) takes O(1) time per element, making the `Set` creation O(M+N).\n-   Space Complexity: O(M + N) in the worst case (if all elements are unique and distinct across both arrays), as a new array and a `Set` are created.\n\n### `arrayIntersection(arr1, arr2)`\nThe intersection of two arrays consists of elements that are common to both arrays.\n\n**Implementation Strategy (using Set for efficiency):**\n1.  Convert one of the arrays (preferably the smaller one, if sizes vary significantly) into a `Set` for efficient lookups (average O(1) time complexity).\n2.  Filter the second array, keeping only elements that are present in the `Set` created from the first array.\n\n**Code:**\n```javascript\nfunction arrayIntersection(arr1, arr2) {\n  const set1 = new Set(arr1); // Create a Set from arr1 for O(1) average lookup\n  const intersection = arr2.filter(item => set1.has(item));\n  return [...new Set(intersection)]; // Optional: ensure uniqueness in result if arr2 had duplicates\n  // If arr1 and arr2 are guaranteed unique inputs, simply: \n  // return arr2.filter(item => set1.has(item));\n}\n\n// A slightly more robust version that ensures union/intersection uniqueness if source arrays aren't already unique\n// function arrayIntersection(arr1, arr2) {\n//   const uniqueArr1 = new Set(arr1);\n//   const uniqueArr2 = new Set(arr2);\n//   return [...uniqueArr2].filter(item => uniqueArr1.has(item));\n// }\n```\n\n**Performance Implications:**\n-   Time Complexity: O(M + N) on average. Creating the `Set` from `arr1` is O(M). Filtering `arr2` involves iterating through `N` elements and performing `has()` lookups, which are O(1) on average. Total: O(M + N).\n-   Space Complexity: O(M) for the `Set` (worst case, all unique elements from `arr1`) plus O(K) for the result array (K being the size of intersection).\n\n**Alternative for Intersection (Nested Loop - less efficient):**\nA naive approach would be nested loops, iterating through `arr1` and for each element, iterating through `arr2` using `includes()`. This would result in O(M*N) time complexity, which is significantly less efficient for large arrays compared to the Set-based approach.",
          "options": [],
          "analysisPoints": [
            "Clear definition of union and intersection.",
            "Demonstration of modern JavaScript `Set` for efficiency.",
            "Correct implementation of both functions.",
            "Accurate analysis of time and space complexity for both solutions.",
            "Comparison with less efficient methods (e.g., nested loops for intersection)."
          ],
          "keyConcepts": [
            "Set Object",
            "Spread Syntax",
            "Array.prototype.filter()",
            "Array.prototype.includes()",
            "Union",
            "Intersection",
            "Time Complexity",
            "Space Complexity",
            "ES6"
          ],
          "evaluationCriteria": [
            "Correctness of logic.",
            "Efficiency of chosen algorithms.",
            "Clarity of explanation.",
            "Depth of performance analysis."
          ],
          "example": "```javascript\nconst arr1 = [1, 2, 3, 4, 5];\nconst arr2 = [4, 5, 6, 7, 8];\nconst arr3 = [2, 3, 9, 10];\n\n// Union Examples\nconsole.log('Union of arr1 and arr2:', arrayUnion(arr1, arr2)); \n// Expected: [1, 2, 3, 4, 5, 6, 7, 8]\n\nconsole.log('Union of arr1 and arr3:', arrayUnion(arr1, arr3));\n// Expected: [1, 2, 3, 4, 5, 9, 10]\n\n// Intersection Examples\nconsole.log('Intersection of arr1 and arr2:', arrayIntersection(arr1, arr2));\n// Expected: [4, 5]\n\nconsole.log('Intersection of arr1 and arr3:', arrayIntersection(arr1, arr3));\n// Expected: [2, 3]\n\nconsole.log('Intersection of [1,2,2] and [2,3,3]:', arrayIntersection([1,2,2], [2,3,3]));\n// Expected: [2]\n```",
          "tags": [
            "Array Methods",
            "Set",
            "Algorithms",
            "Data Structures",
            "Performance",
            "ES6"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features",
            "data_structures_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_common_array_operations_flashcard_1",
          "topic": "Common Array Utility Operations",
          "level": "easy",
          "type": "flashcard",
          "question": "How can you concisely remove duplicate primitive values from an array in JavaScript using a modern ES6 feature?",
          "answer": "You can convert the array to a `Set` (which automatically stores only unique values) and then convert the `Set` back into an array using the spread syntax. Example: `const unique = [...new Set(myArray)];`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Set Object",
            "Spread Syntax",
            "Duplicate Removal",
            "ES6"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "Array Methods",
            "Set",
            "Duplicates",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_common_array_operations_mcq_2",
          "topic": "Common Array Utility Operations",
          "level": "medium",
          "type": "mcq",
          "question": "Given two arrays, `arr1 = [1, 2, 3]` and `arr2 = [3, 4, 5]`, what will be the result of `arr1.some(item => arr2.includes(item))`?",
          "answer": "true",
          "options": [
            "true",
            "false",
            "undefined",
            "Error"
          ],
          "analysisPoints": [
            "Understanding of `Array.prototype.some()`: checks if *any* element satisfies the condition.",
            "Understanding of `Array.prototype.includes()`: checks for element existence.",
            "Tracing the execution: `some` stops on the first `true`."
          ],
          "keyConcepts": [
            "Array.prototype.some()",
            "Array.prototype.includes()",
            "Boolean logic",
            "Common elements"
          ],
          "evaluationCriteria": [
            "Correctly applying the logic of `some` and `includes`.",
            "Ability to predict the output of combined array methods."
          ],
          "example": "```javascript\nconst arr1 = [1, 2, 3];\nconst arr2 = [3, 4, 5];\n\nconst result = arr1.some(item => arr2.includes(item));\n// Step-by-step:\n// 1. item = 1: arr2.includes(1) -> false\n// 2. item = 2: arr2.includes(2) -> false\n// 3. item = 3: arr2.includes(3) -> true\n//    Since `true` is returned for `item = 3`, `some()` immediately stops and returns `true`.\n\nconsole.log(result); // true\n```\n`arr1.some()` iterates through `arr1`. For the element `3` in `arr1`, `arr2.includes(3)` returns `true` because `3` is present in `arr2`. Since `some()` returns `true` as soon as its callback returns a truthy value, the overall result is `true`.",
          "tags": [
            "Array Methods",
            "some",
            "includes",
            "Boolean Logic"
          ],
          "prerequisites": [
            "javascript_arrays",
            "higher_order_functions"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_array_reverse_log",
          "title": "Reverse Array Logging with Specific Method",
          "description": "\nImplement a JavaScript function `logInReverseExceptMiddle` that takes an array of any type. The function should log each element to the console, starting from the last element and ending with the first, **excluding the middle element** if the array has an odd number of elements. If the array is empty or has only one element, it should log nothing.\n\n**Requirements:**\n1.  Must use a traditional `for` loop for iteration.\n2.  Log elements in reverse order.\n3.  Skip the exact middle element if `array.length` is odd.\n4.  Handle empty arrays and single-element arrays gracefully (no output).\n\n",
          "difficulty": "medium",
          "startingCode": "function logInReverseExceptMiddle(arr) {\n  // TODO: Implement the required functionality\n  // Consider edge cases:\n  // 1. Empty array\n  // 2. Single element array\n  // 3. Even length array\n  // 4. Odd length array (skip middle)\n\n  // Example usage:\n  // logInReverseExceptMiddle([1, 2, 3, 4, 5]); // Should log: 5, 4, 2, 1\n  // logInReverseExceptMiddle(['a', 'b', 'c', 'd']); // Should log: 'd', 'c', 'b', 'a'\n  // logInReverseExceptMiddle([]); // Should log nothing\n  // logInReverseExceptMiddle([7]); // Should log nothing\n}\n",
          "solutionCode": "function logInReverseExceptMiddle(arr) {\n  if (!arr || arr.length <= 1) {\n    return; // Handle empty or single-element arrays\n  }\n\n  const isOddLength = arr.length % 2 !== 0;\n  const middleIndex = isOddLength ? Math.floor(arr.length / 2) : -1; // Calculate middle index only if odd\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (isOddLength && i === middleIndex) {\n      continue; // Skip the middle element for odd length arrays\n    }\n    console.log(arr[i]);\n  }\n}\n",
          "testCases": [
            "logInReverseExceptMiddle([1, 2, 3, 4, 5]); // Expected: 5, 4, 2, 1 (3 is skipped)",
            "logInReverseExceptMiddle(['a', 'b', 'c', 'd']); // Expected: 'd', 'c', 'b', 'a' (no middle skip)",
            "logInReverseExceptMiddle([]); // Expected: No output",
            "logInReverseExceptMiddle([7]); // Expected: No output",
            "logInReverseExceptMiddle([10, 20, 30]); // Expected: 30, 10 (20 is skipped)",
            "logInReverseExceptMiddle(['hello']); // Expected: No output",
            "logInReverseExceptMiddle(['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig']); // Expected: fig, elderberry, date, cherry, banana, apple (no skip)"
          ],
          "hints": [
            "Start your loop counter `i` from `arr.length - 1`.",
            "The loop condition should be `i >= 0`.",
            "Use the modulo operator (`%`) to determine if the array length is odd.",
            "For odd length arrays, the middle index is `Math.floor(arr.length / 2)`.",
            "Use `continue` inside the loop to skip an iteration."
          ],
          "tags": [
            "Array Iteration",
            "for loop",
            "Algorithm",
            "Edge Cases"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "javascript_arrays",
            "control_flow",
            "math_floor"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Array.prototype.forEach()",
            "for...of loop",
            "Conditional Logic"
          ]
        },
        {
          "id": "task_implement_array_reorder",
          "title": "Dynamic Array Element Reorder and Remove",
          "description": "\nImplement a JavaScript class `DynamicList` that manages a list of items (strings). The class should have the following methods:\n\n1.  `constructor(initialItems)`: Initializes the list with an optional array of items.\n2.  `addItem(item)`: Adds an item to the end of the list.\n3.  `removeItem(item)`: Removes the first occurrence of an item from the list. Returns `true` if removed, `false` otherwise.\n4.  `moveItem(item, newIndex)`: Moves the *first occurrence* of a given `item` to a `newIndex`. If the item is not found, or `newIndex` is out of bounds, the list should remain unchanged. The `newIndex` can be negative, which should count from the end of the array (-1 is last, -2 is second to last, etc.). Return `true` if moved, `false` otherwise.\n5.  `getList()`: Returns a *copy* of the current list array to prevent external mutation.\n6.  `shuffle()`: Randomly shuffles the list using the Fisher-Yates algorithm.\n\n",
          "difficulty": "hard",
          "startingCode": "class DynamicList {\n  constructor(initialItems = []) {\n    this.items = [...initialItems]; // Ensure a copy to avoid external mutation\n  }\n\n  addItem(item) {\n    // TODO: Implement\n  }\n\n  removeItem(item) {\n    // TODO: Implement\n    // Hint: Find index, then splice.\n  }\n\n  moveItem(item, newIndex) {\n    // TODO: Implement\n    // Hint: Use splice twice. Handle negative newIndex.\n  }\n\n  getList() {\n    // TODO: Implement\n  }\n\n  shuffle() {\n    // TODO: Implement Fisher-Yates shuffle\n  }\n}\n\n// Example Usage (for testing):\n// const myList = new DynamicList(['apple', 'banana', 'cherry']);\n// console.log(myList.getList()); // ['apple', 'banana', 'cherry']\n// myList.moveItem('banana', 0);\n// console.log(myList.getList()); // ['banana', 'apple', 'cherry']\n// myList.removeItem('apple');\n// console.log(myList.getList()); // ['banana', 'cherry']\n// myList.shuffle();\n// console.log(myList.getList()); // Shuffled version\n",
          "solutionCode": "class DynamicList {\n  constructor(initialItems = []) {\n    this.items = [...initialItems];\n  }\n\n  addItem(item) {\n    this.items.push(item);\n  }\n\n  removeItem(item) {\n    const index = this.items.indexOf(item);\n    if (index > -1) {\n      this.items.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  moveItem(item, newIndex) {\n    const oldIndex = this.items.indexOf(item);\n    if (oldIndex === -1) {\n      return false; // Item not found\n    }\n\n    let normalizedNewIndex = newIndex;\n    if (newIndex < 0) {\n      normalizedNewIndex = this.items.length + newIndex; // Calculate index from end\n    }\n\n    // Clamp newIndex to valid bounds: [0, this.items.length - 1]\n    normalizedNewIndex = Math.max(0, Math.min(normalizedNewIndex, this.items.length - 1));\n\n    const [movedItem] = this.items.splice(oldIndex, 1); // Remove item\n    this.items.splice(normalizedNewIndex, 0, movedItem); // Insert at new position\n    return true;\n  }\n\n  getList() {\n    return [...this.items]; // Return a copy\n  }\n\n  shuffle() {\n    for (let i = this.items.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [this.items[i], this.items[j]] = [this.items[j], this.items[i]]; // Swap elements\n    }\n  }\n}\n",
          "testCases": [
            "const list1 = new DynamicList(['A', 'B', 'C', 'D']);",
            "list1.moveItem('B', 0); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"A\",\"C\",\"D\"]', 'Test 1 Failed: move B to 0');",
            "list1.moveItem('D', 1); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"A\",\"C\"]', 'Test 2 Failed: move D to 1');",
            "list1.moveItem('C', 10); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"A\",\"C\"]', 'Test 3 Failed: move C to out of bounds end');",
            "list1.moveItem('X', 1); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"A\",\"C\"]', 'Test 4 Failed: move non-existent item');",
            "list1.moveItem('A', -1); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"C\",\"A\"]', 'Test 5 Failed: move A to -1 (last)');",
            "list1.moveItem('B', -10); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"C\",\"A\"]', 'Test 6 Failed: move B to out of bounds start');",
            "list1.removeItem('D'); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"C\",\"A\"]', 'Test 7 Failed: remove D');",
            "list1.removeItem('Z'); console.assert(list1.removeItem('Z') === false, 'Test 8 Failed: remove non-existent item return');",
            "list1.addItem('E'); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"C\",\"A\",\"E\"]', 'Test 9 Failed: add E');",
            "const list2 = new DynamicList(['X', 'Y', 'Z']); list2.shuffle(); console.assert(list2.getList().length === 3, 'Test 10 Failed: Shuffle preserves length'); console.log('Shuffled list2:', list2.getList());",
            "const list3 = new DynamicList(); console.assert(JSON.stringify(list3.getList()) === '[]', 'Test 11 Failed: Empty constructor'); list3.addItem('first'); console.assert(JSON.stringify(list3.getList()) === '[\"first\"]', 'Test 12 Failed: Add to empty list');",
            "const list4 = new DynamicList([1, 2, 3, 4, 5, 6, 7]); list4.moveItem(4, 2); console.assert(JSON.stringify(list4.getList()) === '[1,2,4,3,5,6,7]', 'Test 13 Failed: move item in longer array');"
          ],
          "hints": [
            "For `removeItem`, `indexOf()` can find the item's position, then `splice()` removes it.",
            "For `moveItem`, first find the `oldIndex` using `indexOf()`. Then, use two `splice()` calls: one to remove the item, and another to insert it. Remember to handle negative `newIndex` by converting it to a positive index relative to the end of the array, e.g., `length + newIndex`.",
            "Ensure `newIndex` is clamped within valid array bounds (between 0 and `length - 1`) to prevent errors if `newIndex` is too large or too small after conversion.",
            "For `shuffle`, accurately implement the Fisher-Yates algorithm using a `for` loop and array destructuring for swapping elements.",
            "Always return a *copy* of the array for `getList()` to maintain encapsulation and immutability from external changes.",
            "Think about edge cases for `moveItem` and `removeItem`: item not found, empty list, `newIndex` outside bounds."
          ],
          "tags": [
            "OOP",
            "Classes",
            "Array Methods",
            "splice",
            "indexOf",
            "Fisher-Yates",
            "Immutability",
            "Data Structures"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_arrays",
            "es6_classes",
            "array_splice",
            "array_indexOf",
            "math_random"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Array Manipulation and Reordering",
            "Encapsulation",
            "Data Structures"
          ]
        },
        {
          "id": "task_implement_config_parser",
          "title": "Configuration Parser with Destructuring",
          "description": "\nImplement a function `parseConfigString(configString)` that takes a string representing a configuration line. Each line has a fixed format but might have optional or variable parts. Your function should parse this string and return an object with specific properties.\n\n**Config String Format:**\n`'[ID]:[NAME]:[TYPE]:[STATUS?]:[...TAGS]'`\n\n-   `ID`: (Number) Always present, e.g., `101`.\n-   `NAME`: (String) Always present, e.g., `Service_A`.\n-   `TYPE`: (String) Always present, e.g., `API`.\n-   `STATUS`: (String, Optional) Can be `active`, `inactive`, or missing. If missing, default to `unknown`.\n-   `...TAGS`: (String Array, Optional) Zero or more additional tags separated by colons. If no tags, this part is empty.\n\nYour function must use **array destructuring** to parse the string parts. Return an object with `id`, `name`, `type`, `status`, and `tags` properties, with correct data types. Assume input strings are well-formed according to the basic format (i.e., will have at least ID, NAME, TYPE).\n\n",
          "difficulty": "hard",
          "startingCode": "function parseConfigString(configString) {\n  // TODO: Implement parsing using array destructuring\n  // Hint: Use String.prototype.split(':') to get an array of parts.\n  // Remember to convert ID to a Number.\n  // Handle optional STATUS with default values.\n  // Handle optional TAGS with the rest pattern.\n\n  // Example usage:\n  // parseConfigString('101:Service_A:API:active:tag1:tag2');\n  // parseConfigString('202:Database_B:DB');\n  // parseConfigString('303:Logging_C:Utility::debug:verbose'); // Empty status, then tags\n}\n",
          "solutionCode": "function parseConfigString(configString) {\n  const parts = configString.split(':');\n\n  // Use array destructuring with default values and rest pattern\n  const [\n    idStr,\n    name,\n    type,\n    status = 'unknown', // Default value for status if undefined/missing\n    ...tags               // Rest pattern collects remaining elements into an array\n  ] = parts;\n\n  return {\n    id: Number(idStr), // Convert ID to a number\n    name: name,\n    type: type,\n    status: status,\n    tags: tags\n  };\n}\n",
          "testCases": [
            "// Test Case 1: All fields present, multiple tags\nconsole.assert(JSON.stringify(parseConfigString('101:Service_A:API:active:tag1:tag2')) === '{\"id\":101,\"name\":\"Service_A\",\"type\":\"API\",\"status\":\"active\",\"tags\":[\"tag1\",\"tag2\"]}', 'Test Case 1 Failed');",
            "// Test Case 2: No status, no tags\nconsole.assert(JSON.stringify(parseConfigString('202:Database_B:DB')) === '{\"id\":202,\"name\":\"Database_B\",\"type\":\"DB\",\"status\":\"unknown\",\"tags\":[]}', 'Test Case 2 Failed');",
            "// Test Case 3: Explicitly empty status (becomes undefined, so default applies), with tags\nconsole.assert(JSON.stringify(parseConfigString('303:Logging_C:Utility::debug:verbose')) === '{\"id\":303,\"name\":\"Logging_C\",\"type\":\"Utility\",\"status\":\"unknown\",\"tags\":[\"debug\",\"verbose\"]}', 'Test Case 3 Failed');",
            "// Test Case 4: No tags, but status present\nconsole.assert(JSON.stringify(parseConfigString('404:Auth_Service:Security:inactive')) === '{\"id\":404,\"name\":\"Auth_Service\",\"type\":\"Security\",\"status\":\"inactive\",\"tags\":[]}', 'Test Case 4 Failed');",
            "// Test Case 5: Single tag\nconsole.assert(JSON.stringify(parseConfigString('505:Data_Processor:Job:active:process')) === '{\"id\":505,\"name\":\"Data_Processor\",\"type\":\"Job\",\"status\":\"active\",\"tags\":[\"process\"]}', 'Test Case 5 Failed');",
            "// Test Case 6: ID conversion check\nconsole.assert(typeof parseConfigString('606:Test:Type').id === 'number', 'Test Case 6 Failed: ID not a number');",
            "// Test Case 7: Only mandatory fields\nconsole.assert(JSON.stringify(parseConfigString('707:Minimal:App')) === '{\"id\":707,\"name\":\"Minimal\",\"type\":\"App\",\"status\":\"unknown\",\"tags\":[]}', 'Test Case 7 Failed');"
          ],
          "hints": [
            "Use `String.prototype.split(':')` to convert the input string into an array of parts.",
            "Remember that `split()` on a trailing delimiter (e.g., `'a:b:'`) can result in an empty string at the end of the array, which needs careful handling with destructuring.",
            "The rest pattern `...tags` must be the *last* element in your destructuring assignment.",
            "The `status` default value will only apply if the corresponding element in `parts` array is `undefined` or not present. An empty string (`''`) is not `undefined`."
          ],
          "tags": [
            "Destructuring",
            "String Manipulation",
            "Parsing",
            "ES6",
            "Configuration"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_strings",
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Array Destructuring",
            "Rest Parameters",
            "Default Parameters"
          ]
        },
        {
          "id": "task_implement_array_utilities",
          "title": "Essential Array Utility Functions",
          "description": "\nImplement a utility object `ArrayUtils` that encapsulates several common array manipulation functions.\n\n**`ArrayUtils` should have the following methods:**\n\n1.  `createRange(start, end, step = 1)`: Returns a new array of numbers from `start` to `end` (inclusive), with an optional `step`. If `start > end`, return an empty array. Assume `step` is always positive.\n    *   Example: `createRange(1, 5)` returns `[1, 2, 3, 4, 5]`\n    *   Example: `createRange(0, 10, 2)` returns `[0, 2, 4, 6, 8, 10]`\n\n2.  `getUniqueElements(arr)`: Returns a new array containing only the unique primitive elements from `arr`, preserving their original insertion order.\n    *   Example: `getUniqueElements([1, 2, 2, 3, 1])` returns `[1, 2, 3]`\n\n3.  `findMax(arr)`: Returns the maximum numeric value in `arr`. If `arr` is empty or non-numeric, return `null`.\n    *   Example: `findMax([10, 2, 8])` returns `10`\n    *   Example: `findMax([])` returns `null`\n    *   Example: `findMax(['a', 'b'])` returns `null`\n\n4.  `hasAnyCommonElement(arr1, arr2)`: Returns `true` if `arr1` and `arr2` share at least one common element, `false` otherwise. Both arrays contain primitive values.\n    *   Example: `hasAnyCommonElement([1, 2], [2, 3])` returns `true`\n    *   Example: `hasAnyCommonElement([1, 2], [3, 4])` returns `false`\n\n",
          "difficulty": "medium",
          "startingCode": "const ArrayUtils = {\n  createRange(start, end, step = 1) {\n    // TODO: Implement\n  },\n\n  getUniqueElements(arr) {\n    // TODO: Implement\n  },\n\n  findMax(arr) {\n    // TODO: Implement\n  },\n\n  hasAnyCommonElement(arr1, arr2) {\n    // TODO: Implement\n  }\n};\n\n// Example usage:\n// console.log(ArrayUtils.createRange(1, 5));\n// console.log(ArrayUtils.getUniqueElements([1, 2, 2, 3]));\n// console.log(ArrayUtils.findMax([10, 5, 20]));\n// console.log(ArrayUtils.hasAnyCommonElement([1, 2], [2, 4]));\n",
          "solutionCode": "const ArrayUtils = {\n  createRange(start, end, step = 1) {\n    if (start > end) {\n      return [];\n    }\n    const result = [];\n    for (let i = start; i <= end; i += step) {\n      result.push(i);\n    }\n    return result;\n    /* Alternative with Array.from:\n    const length = Math.floor((end - start) / step) + 1;\n    if (length <= 0) return [];\n    return Array.from({ length }, (_, i) => start + (i * step));\n    */\n  },\n\n  getUniqueElements(arr) {\n    // Handles non-array inputs or ensures it's an array for Set constructor\n    if (!Array.isArray(arr)) {\n      return [];\n    }\n    return [...new Set(arr)];\n  },\n\n  findMax(arr) {\n    if (!Array.isArray(arr) || arr.length === 0) {\n      return null;\n    }\n    // Check if all elements are numbers. If not, return null.\n    if (arr.some(isNaN) || arr.some(item => typeof item !== 'number')) {\n      return null; \n    }\n    return Math.max(...arr);\n  },\n\n  hasAnyCommonElement(arr1, arr2) {\n    if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length === 0 || arr2.length === 0) {\n      return false; // No common elements if either array is empty or not an array\n    }\n    const set1 = new Set(arr1);\n    return arr2.some(item => set1.has(item));\n  }\n};\n",
          "testCases": [
            "// createRange tests",
            "console.assert(JSON.stringify(ArrayUtils.createRange(1, 5)) === '[1,2,3,4,5]', 'createRange Test 1 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.createRange(0, 10, 2)) === '[0,2,4,6,8,10]', 'createRange Test 2 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.createRange(5, 1)) === '[]', 'createRange Test 3 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.createRange(7, 7)) === '[7]', 'createRange Test 4 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.createRange(1, 2, 0.5)) === '[1,1.5,2]', 'createRange Test 5 Failed (decimal step)');",
            "// getUniqueElements tests",
            "console.assert(JSON.stringify(ArrayUtils.getUniqueElements([1, 2, 2, 3, 1])) === '[1,2,3]', 'getUniqueElements Test 1 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.getUniqueElements(['a', 'b', 'a', 'c'])) === '[\"a\",\"b\",\"c\"]', 'getUniqueElements Test 2 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.getUniqueElements([])) === '[]', 'getUniqueElements Test 3 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.getUniqueElements([1, null, 2, null])) === '[1,null,2]', 'getUniqueElements Test 4 Failed (null)');",
            "// findMax tests",
            "console.assert(ArrayUtils.findMax([10, 2, 8]) === 10, 'findMax Test 1 Failed');",
            "console.assert(ArrayUtils.findMax([-5, -1, -10]) === -1, 'findMax Test 2 Failed');",
            "console.assert(ArrayUtils.findMax([7]) === 7, 'findMax Test 3 Failed');",
            "console.assert(ArrayUtils.findMax([]) === null, 'findMax Test 4 Failed (empty)');",
            "console.assert(ArrayUtils.findMax([1, 'a', 3]) === null, 'findMax Test 5 Failed (non-numeric)');",
            "console.assert(ArrayUtils.findMax(null) === null, 'findMax Test 6 Failed (null input)');",
            "// hasAnyCommonElement tests",
            "console.assert(ArrayUtils.hasAnyCommonElement([1, 2], [2, 3]) === true, 'hasAnyCommonElement Test 1 Failed');",
            "console.assert(ArrayUtils.hasAnyCommonElement([1, 2], [3, 4]) === false, 'hasAnyCommonElement Test 2 Failed');",
            "console.assert(ArrayUtils.hasAnyCommonElement([], [1, 2]) === false, 'hasAnyCommonElement Test 3 Failed (empty arr1)');",
            "console.assert(ArrayUtils.hasAnyCommonElement([1, 2], []) === false, 'hasAnyCommonElement Test 4 Failed (empty arr2)');",
            "console.assert(ArrayUtils.hasAnyCommonElement(['a', 'b'], ['b', 'c']) === true, 'hasAnyCommonElement Test 5 Failed (strings)');",
            "console.assert(ArrayUtils.hasAnyCommonElement([null, 1], [1, 2]) === true, 'hasAnyCommonElement Test 6 Failed (null)');",
            "console.assert(ArrayUtils.hasAnyCommonElement([1, 2, 3], null) === false, 'hasAnyCommonElement Test 7 Failed (null input)');"
          ],
          "hints": [
            "For `createRange`, a simple `for` loop works, or `Array.from()` with a `length` property and a mapping function is an elegant alternative.",
            "For `getUniqueElements`, remember that `Set` objects automatically store only unique values and preserve insertion order for primitive types. Combine with the spread operator.",
            "For `findMax`, consider `Math.max()` with the spread operator. Don't forget edge cases like empty arrays or arrays containing non-numeric values. `isNaN()` and `typeof` checks might be useful.",
            "For `hasAnyCommonElement`, converting one array to a `Set` greatly improves performance for lookups (`Set.prototype.has()`). Then `Array.prototype.some()` can check for existence in the other array.",
            "Ensure all functions handle `null` or non-array inputs gracefully if they are expected to work with potentially invalid inputs."
          ],
          "tags": [
            "Array Methods",
            "Set",
            "Math",
            "Utility Functions",
            "ES6",
            "Data Transformation"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_arrays",
            "es6_features",
            "higher_order_functions",
            "math_object"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Common Array Utility Operations",
            "Functional Programming",
            "Data Validation"
          ]
        }
      ]
    }
  },
  {
    "id": "db25c3e5-24ef-4958-be3e-e589f32cd20e",
    "startLine": 1500,
    "endLine": 1599,
    "processedDate": "2025-06-17T07:55:50.581Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_array_group_by_reduce",
          "title": "Array Grouping with `reduce`",
          "content": "The `Array.prototype.reduce()` method is a powerful higher-order function in JavaScript that executes a user-supplied 'reducer' callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.\n\n### `reduce` Parameters:\n- **`callback`**: A function to execute on each element in the array. It takes four arguments:\n    - **`accumulator`**: The accumulated value previously returned in the last invocation of the callback, or `initialValue`, if supplied.\n    - **`currentValue`**: The current element being processed in the array.\n    - **`currentIndex`** (Optional): The index of the current element being processed in the array. Starts from index 0 if an `initialValue` is provided. Otherwise, it starts from index 1.\n    - **`array`** (Optional): The array `reduce()` was called upon.\n- **`initialValue`** (Optional): A value to use as the first argument to the first call of the `callback`. If no `initialValue` is supplied, the first element in the array will be used as the `accumulator`'s initial value and `currentValue` will start from the second element.\n\n### Grouping Logic:\nThe provided `groupBy` function leverages `reduce` to categorize objects within an array based on a specified property (`key`). For each `item` in the `array`:\n1.  It checks if the `result` (the accumulator, which will become the grouped object) already has a property corresponding to `item[key]` (e.g., `item.age`).\n2.  If not, it initializes `result[item[key]]` as an empty array `[]`.\n3.  It then pushes the current `item` into this array.\n4.  Finally, it returns the `result` accumulator for the next iteration.\n\nThis pattern efficiently builds an object where keys are the unique values of the specified property, and values are arrays of objects sharing that property value.",
          "examples": [
            {
              "id": "example_group_by_1",
              "title": "Basic `groupBy` Implementation",
              "code": "function groupBy(array, key) {\n  return array.reduce((result, item) => {\n    // If the key doesn't exist in result, initialize it as an empty array\n    (result[item[key]] = result[item[key]] || []).push(item);\n    return result;\n  }, {}); // Initial accumulator is an empty object\n}\n\n// Grouped people by age\nconst peopleData = [\n  { name: 'Alice', age: 30 },\n  { name: 'Bob', age: 25 },\n  { name: 'Charlie', age: 30 },\n  { name: 'David', age: 25 }\n];\n\nconst groupedPeople = groupBy(peopleData, 'age');\nconsole.log(groupedPeople);\n// Expected Output:\n// {\n//   25: [{ name: 'Bob', age: 25 }, { name: 'David', age: 25 }],\n//   30: [{ name: 'Alice', age: 30 }, { name: 'Charlie', age: 30 }]\n// }",
              "explanation": "This example demonstrates the `groupBy` function in action, using `age` as the key to group the `peopleData` array. The `reduce` method iterates through each person, and if a group for their age doesn't exist in the `result` object, it creates an empty array for that age group before pushing the current person into it. The `{}` as the initial value ensures `result` starts as an empty object.",
              "language": "javascript"
            },
            {
              "id": "example_group_by_2",
              "title": "Grouping by Multiple Properties",
              "code": "function groupByMultipleKeys(array, keys) {\n  return array.reduce((result, item) => {\n    let currentGroup = result;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = item[key];\n      if (!currentGroup[value]) {\n        currentGroup[value] = (i === keys.length - 1) ? [] : {};\n      }\n      currentGroup = currentGroup[value];\n    }\n    currentGroup.push(item);\n    return result;\n  }, {});\n}\n\nconst products = [\n  { id: 1, category: 'Electronics', brand: 'Sony' },\n  { id: 2, category: 'Electronics', brand: 'Samsung' },\n  { id: 3, category: 'Clothes', brand: 'Nike' },\n  { id: 4, category: 'Electronics', brand: 'Sony' },\n];\n\nconst groupedProducts = groupByMultipleKeys(products, ['category', 'brand']);\nconsole.log(JSON.stringify(groupedProducts, null, 2));\n// Expected Output:\n// {\n//   \"Electronics\": {\n//     \"Sony\": [\n//       { \"id\": 1, \"category\": \"Electronics\", \"brand\": \"Sony\" },\n//       { \"id\": 4, \"category\": \"Electronics\", \"brand\": \"Sony\" }\n//     ],\n//     \"Samsung\": [\n//       { \"id\": 2, \"category\": \"Electronics\", \"brand\": \"Samsung\" }\n//     ]\n//   },\n//   \"Clothes\": {\n//     \"Nike\": [\n//       { \"id\": 3, \"category\": \"Clothes\", \"brand\": \"Nike\" }\n//     ]\n//   }\n// }",
              "explanation": "This advanced example extends the grouping concept to support multiple nested keys. The `groupByMultipleKeys` function iterates through an array of keys, dynamically building a nested object structure. For each key, it creates a new level in the `result` object, ultimately pushing the original `item` into the innermost array. This demonstrates the versatility of `reduce` for complex data transformations.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_reduce_mcq_1",
            "question_group_by_open_1",
            "question_reduce_flashcard_1",
            "question_group_by_code_1",
            "question_reduce_mcq_2"
          ],
          "relatedTasks": [
            "task_implement_advanced_groupby"
          ],
          "tags": [
            "Array.prototype.reduce",
            "functional programming",
            "data transformation",
            "JavaScript",
            "array methods"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_objects",
            "higher_order_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_aggregation",
            "utility_functions",
            "functional_patterns"
          ]
        },
        {
          "id": "theory_asynchronous_javascript_callbacks",
          "title": "Asynchronous JavaScript: Callbacks",
          "content": "JavaScript is single-threaded, meaning it executes code sequentially. However, many operations, like fetching data from a server, reading files, or setting timers, are time-consuming and cannot block the main thread. Asynchronous JavaScript allows these operations to run in the background without freezing the user interface, and callbacks are a fundamental pattern for handling their results.\n\n### Callbacks Explained:\nA callback function is a function passed as an argument to another function, which is then invoked inside the outer function to complete some kind of routine or action. In asynchronous programming, the outer function starts an operation, and the callback function is executed only after that operation completes (or fails) at some later point in time.\n\n### Characteristics:\n-   **Non-blocking**: The main thread can continue executing other code while the asynchronous operation is pending.\n-   **Event-driven**: Often used with events (e.g., `setTimeout`, `addEventListener`, network requests).\n\n### The Problem: Callback Hell (Pyramid of Doom):\nWhile callbacks are effective for simple asynchronous operations, they can quickly lead to deeply nested, unreadable, and unmaintainable code when multiple asynchronous operations depend on the results of previous ones. This phenomenon is commonly known as 'callback hell' or 'pyramid of doom'.\n\n**Issues with Callback Hell:**\n1.  **Readability**: Code becomes difficult to follow due to excessive indentation and nesting.\n2.  **Error Handling**: Centralized error handling is challenging; errors need to be passed down or handled at each level.\n3.  **Maintainability**: Modifying or extending functionality becomes cumbersome.\n4.  **Inversion of Control**: The outer function takes control of when and how the callback is executed, which can lead to unpredictable behavior if not carefully managed.",
          "examples": [
            {
              "id": "example_callbacks_basic_1",
              "title": "Basic Callback Pattern",
              "code": "function fetchData(callback) {\n  console.log('Fetching data...');\n  setTimeout(() => {\n    const data = { name: 'John Doe', age: 30 };\n    console.log('Data fetched.');\n    callback(data); // Invoke the callback with the fetched data\n  }, 1000);\n}\n\nfunction displayData(data) {\n  console.log('Displaying data:', data);\n}\n\n// Call fetchData and pass displayData as the callback\nfetchData(displayData);\n// Expected output (after ~1 second):\n// Fetching data...\n// Data fetched.\n// Displaying data: { name: 'John Doe', age: 30 }",
              "explanation": "This example shows a simple asynchronous function `fetchData` that simulates an API call using `setTimeout`. After a delay, it calls the `callback` function (`displayData` in this case) and passes the fetched `data` to it. This demonstrates the non-blocking nature: `fetchData` returns immediately, and `displayData` is called later when the data is ready.",
              "language": "javascript"
            },
            {
              "id": "example_callbacks_hell_1",
              "title": "Callback Hell Demonstration",
              "code": "function fetchUser(userId, callback) {\n  setTimeout(() => {\n    console.log(`Fetched user ${userId}`);\n    callback({ id: userId, name: `User ${userId}` });\n  }, 500);\n}\n\nfunction fetchPosts(userId, callback) {\n  setTimeout(() => {\n    console.log(`Fetched posts for user ${userId}`);\n    callback([{ id: 101, title: 'Post 1' }, { id: 102, title: 'Post 2' }]);\n  }, 700);\n}\n\nfunction fetchComments(postId, callback) {\n  setTimeout(() => {\n    console.log(`Fetched comments for post ${postId}`);\n    callback([{ id: 201, text: 'Comment A' }, { id: 202, text: 'Comment B' }]);\n  }, 600);\n}\n\n// Callback hell in action:\nfetchUser(1, (user) => {\n  fetchPosts(user.id, (posts) => {\n    if (posts.length > 0) {\n      fetchComments(posts[0].id, (comments) => {\n        console.log('Final data received:');\n        console.log('User:', user);\n        console.log('First Post:', posts[0]);\n        console.log('Comments:', comments);\n        // More nested callbacks could follow...\n      });\n    } else {\n      console.log('No posts found for user.');\n    }\n  });\n});",
              "explanation": "This example illustrates 'callback hell'. To fetch a user, then their posts, then comments for the first post, functions are deeply nested. This creates a pyramid-like structure that is hard to read, debug, and manage, especially when error handling or more sequential operations are added. It highlights the primary motivation for introducing Promises and async/await.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_callbacks_mcq_1",
            "question_callbacks_open_1",
            "question_callbacks_flashcard_1",
            "question_callbacks_code_1",
            "question_callbacks_mcq_2"
          ],
          "relatedTasks": [
            "task_callback_to_promise"
          ],
          "tags": [
            "asynchronous JavaScript",
            "callbacks",
            "callback hell",
            "event loop",
            "non-blocking"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "setTimeout"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "understanding_async_history",
            "legacy_codebases",
            "event_listeners"
          ]
        },
        {
          "id": "theory_asynchronous_javascript_promises",
          "title": "Asynchronous JavaScript: Promises",
          "content": "Promises are a fundamental concept in modern asynchronous JavaScript, offering a cleaner and more robust way to handle asynchronous operations compared to traditional callbacks. A Promise is an object representing the eventual completion (or failure) of an asynchronous operation and its resulting value.\n\n### Promise States:\nA Promise can be in one of three states:\n1.  **Pending**: The initial state; neither fulfilled nor rejected.\n2.  **Fulfilled** (or Resolved): The operation completed successfully, and the promise has a resulting value.\n3.  **Rejected**: The operation failed, and the promise has a reason for the failure (an error object).\n\nA Promise is said to be *settled* when it is either fulfilled or rejected. Once a promise is settled, it cannot change its state.\n\n### Using Promises:\n-   **`new Promise(executor)`**: The `Promise` constructor takes an `executor` function with two arguments: `resolve` and `reject`. You call `resolve(value)` when the async operation succeeds and `reject(error)` when it fails.\n-   **`.then(onFulfilled, onRejected)`**: Used to register callbacks to be invoked when the promise is fulfilled (`onFulfilled`) or rejected (`onRejected`). It always returns a *new* promise, enabling chaining.\n-   **`.catch(onRejected)`**: A shorthand for `.then(null, onRejected)`. Primarily used for error handling at any point in a promise chain.\n-   **`.finally(onFinally)`**: Introduced in ES2018. Registers a callback to be invoked when the promise is settled (either fulfilled or rejected). The callback doesn't receive any arguments and is useful for cleanup operations regardless of the outcome.\n\n### Solving Callback Hell:\nPromises address callback hell by allowing you to chain asynchronous operations sequentially, making the code much more readable and manageable. Each `.then()` returns a new promise, allowing subsequent `.then()` calls to be attached to the result of the previous one, creating a flat structure instead of nested callbacks.\n\n### Static Promise Methods:\n-   **`Promise.all(iterable)`**: Takes an iterable (e.g., an array) of promises as input. It returns a single Promise that resolves when all of the input promises have resolved, or rejects immediately upon the first promise that rejects. The resolved value is an array of the resolved values of the input promises, in the same order.\n-   **`Promise.race(iterable)`**: Also takes an iterable of promises. It returns a single Promise that resolves or rejects as soon as one of the input promises resolves or rejects, with the value or reason from that promise.\n-   **`Promise.allSettled(iterable)`** (ES2020): Returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects describing the outcome of each promise.\n-   **`Promise.any(iterable)`** (ES2021): Takes an iterable of promises and returns a single promise that resolves with the value of the first promise in the iterable to fulfill. If all of the input promises reject, then the returned promise rejects with an `AggregateError` containing an array of rejection reasons.",
          "examples": [
            {
              "id": "example_promises_basic_1",
              "title": "Creating and Using a Promise",
              "code": "const myPromise = new Promise((resolve, reject) => {\n  const success = Math.random() > 0.5; // Simulate async operation success/failure\n  setTimeout(() => {\n    if (success) {\n      resolve('Data successfully loaded!');\n    } else {\n      reject(new Error('Failed to load data.'));\n    }\n  }, 1500);\n});\n\nconsole.log('Promise pending...');\n\nmyPromise\n  .then(message => {\n    console.log('Success:', message); // Executed if promise is fulfilled\n    return 'Further processing: ' + message;\n  })\n  .then(nextMessage => {\n    console.log(nextMessage); // Chained .then() receives value from previous .then()\n  })\n  .catch(error => {\n    console.error('Error:', error.message); // Executed if any promise in chain is rejected\n  })\n  .finally(() => {\n    console.log('Promise operation finished.'); // Always executed, regardless of outcome\n  });\n\nconsole.log('Other synchronous code continues...');",
              "explanation": "This example illustrates the full lifecycle of a Promise. It shows how to create a promise using `new Promise` with `resolve` and `reject` functions. It then demonstrates promise chaining with `.then()` for success handling, `.catch()` for error handling, and `.finally()` for cleanup. Notice how `console.log('Other synchronous code continues...');` runs immediately, highlighting the non-blocking nature.",
              "language": "javascript"
            },
            {
              "id": "example_promises_all_race",
              "title": "Promise.all and Promise.race",
              "code": "// --- Example for Promise.all ---\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.all([promise1, promise2, promise3])\n  .then((values) => {\n    console.log('Promise.all results:', values); // [3, 42, 'foo']\n  })\n  .catch(error => {\n    console.error('Promise.all failed:', error);\n  });\n\n// --- Example for Promise.race ---\nconst fetchUserData = new Promise(resolve => setTimeout(() => resolve('User Data'), 200));\nconst fetchProductData = new Promise(resolve => setTimeout(() => resolve('Product Data'), 100));\nconst fetchTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout!')), 50));\n\nPromise.race([fetchUserData, fetchProductData, fetchTimeout])\n  .then((value) => {\n    console.log('Promise.race winner:', value); // Error: Timeout! (because fetchTimeout resolves/rejects first)\n  })\n  .catch(error => {\n    console.error('Promise.race rejected:', error.message); // Output: Promise.race rejected: Timeout!\n  });",
              "explanation": "`Promise.all` is used when you need all asynchronous operations to complete successfully before proceeding. It resolves with an array of results or rejects if any single promise fails. `Promise.race` is useful when you only care about the result of the first promise to settle (either fulfill or reject). In the example, `fetchTimeout` is designed to reject quickly, demonstrating how `Promise.race` immediately adopts its state.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_promises_mcq_1",
            "question_promises_open_1",
            "question_promises_flashcard_1",
            "question_promises_code_1",
            "question_promises_mcq_2",
            "question_promises_all_race_mcq_1",
            "question_promises_then_catch_flashcard",
            "question_promises_static_methods_mcq"
          ],
          "relatedTasks": [
            "task_callback_to_promise",
            "task_concurrent_api_calls"
          ],
          "tags": [
            "asynchronous JavaScript",
            "Promises",
            "Promise.all",
            "Promise.race",
            "promise chaining",
            "error handling",
            "async/await prerequisites"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "callbacks",
            "event_loop"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_async_programming",
            "async_await",
            "fetch_api",
            "complex_data_flows"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_reduce_mcq_1",
          "topic": "Array.prototype.reduce",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the `reduce()` method in JavaScript arrays?",
          "answer": "To condense an array's elements into a single value.",
          "options": [
            "To filter elements based on a condition.",
            "To transform each element into a new array.",
            "To condense an array's elements into a single value.",
            "To sort array elements in a specific order."
          ],
          "analysisPoints": [
            "`reduce()` is designed for aggregation, where you process each element to build up a single result (e.g., sum, object, flattened array).",
            "Filtering is done with `filter()`, transforming with `map()`, and sorting with `sort()`."
          ],
          "keyConcepts": [
            "Array.prototype.reduce",
            "Aggregation",
            "Higher-order functions"
          ],
          "evaluationCriteria": [
            "Understanding of `reduce`'s core functionality",
            "Ability to differentiate `reduce` from other array methods"
          ],
          "example": "The `reduce` method is incredibly versatile. For instance, to sum all numbers in an array: `[1, 2, 3].reduce((sum, num) => sum + num, 0);` returns `6`. It processes each element (`num`) and accumulates the `sum` from the `initialValue` (0).",
          "tags": [
            "array methods",
            "reduce",
            "JavaScript basics",
            "functional programming"
          ],
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_group_by_open_1",
          "topic": "Array Grouping",
          "level": "medium",
          "type": "open",
          "question": "Explain how the `reduce` method in the provided `groupBy` function works to create the grouped object, focusing on the role of the `accumulator` and the `initialValue`.",
          "answer": "The `reduce` method iterates over each `item` in the input `array`. The `accumulator` (`result` in the code) starts as an empty object (`{}`), which is provided as the `initialValue`. In each iteration, `item[key]` (e.g., `item.age`) is used as a key to access a property on the `result` object. If `result[item[key]]` is falsy (meaning this group hasn't been created yet), it's initialized to an empty array `[]`. Then, the current `item` is `push`ed into `result[item[key]]`. The `result` object is returned from the callback, becoming the `accumulator` for the next iteration. This process continues until all items are processed, resulting in a single object where keys are the grouping values and values are arrays of corresponding items.",
          "analysisPoints": [
            "Clear explanation of `accumulator`'s role as the `result` object.",
            "Correct identification of `{}` as the `initialValue` and its importance.",
            "Detailed breakdown of `(result[item[key]] = result[item[key]] || []).push(item);` statement.",
            "Understanding of how the `result` object is built up incrementally.",
            "Ability to explain the flow of `reduce` with a specific use case."
          ],
          "keyConcepts": [
            "Array.prototype.reduce",
            "Accumulator",
            "Initial Value",
            "Object manipulation",
            "Conditional assignment"
          ],
          "evaluationCriteria": [
            "Depth of understanding of `reduce` parameters and execution flow",
            "Clarity and accuracy of explanation",
            "Ability to relate concepts to the specific code provided"
          ],
          "example": null,
          "tags": [
            "array methods",
            "reduce",
            "grouping",
            "JavaScript",
            "functional programming"
          ],
          "prerequisites": [
            "theory_array_group_by_reduce"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reduce_flashcard_1",
          "topic": "Array.prototype.reduce",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the role of the `initialValue` argument in the `Array.prototype.reduce()` method?",
          "answer": "The `initialValue` serves as the initial value of the `accumulator` for the first call to the `callback` function. If not provided, the first element of the array is used as the initial accumulator, and iteration starts from the second element.",
          "analysisPoints": [],
          "keyConcepts": [
            "Array.prototype.reduce",
            "accumulator",
            "initialValue"
          ],
          "evaluationCriteria": [
            "Recall of `reduce` signature",
            "Understanding of `initialValue` impact"
          ],
          "example": null,
          "tags": [
            "array methods",
            "reduce",
            "JavaScript basics"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_group_by_code_1",
          "topic": "Array Grouping",
          "level": "medium",
          "type": "code",
          "question": "Write a JavaScript function called `countOccurrences` that takes an array and a `key` (string) as input. The function should return an object where keys are the unique values of the specified `key` from the array elements, and values are the count of how many times each unique value appears. Use the `reduce` method.",
          "answer": "```javascript\nfunction countOccurrences(array, key) {\n  return array.reduce((acc, item) => {\n    const value = item[key];\n    acc[value] = (acc[value] || 0) + 1;\n    return acc;\n  }, {});\n}\n\n// Example usage:\nconst fruits = [\n  { name: 'Apple', color: 'Red' },\n  { name: 'Banana', color: 'Yellow' },\n  { name: 'Cherry', color: 'Red' },\n  { name: 'Orange', color: 'Orange' }\n];\n\nconsole.log(countOccurrences(fruits, 'color'));\n// Expected output: { Red: 2, Yellow: 1, Orange: 1 }\n\nconst numbers = [1, 2, 2, 3, 3, 3];\nconsole.log(countOccurrences(numbers.map(num => ({value: num})), 'value'));\n// Expected output: { '1': 1, '2': 2, '3': 3 }\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `reduce` to iterate and aggregate.",
            "Proper initialization of the `accumulator` (empty object).",
            "Correctly handling the increment logic (`acc[value] = (acc[value] || 0) + 1;`).",
            "Handling edge cases like empty arrays or non-existent keys gracefully (inherent in `|| 0`)."
          ],
          "keyConcepts": [
            "Array.prototype.reduce",
            "Object property access",
            "Counting occurrences",
            "Default values"
          ],
          "evaluationCriteria": [
            "Correct implementation of `reduce` for counting",
            "Code efficiency and readability",
            "Handling of potential undefined values gracefully"
          ],
          "example": null,
          "tags": [
            "array methods",
            "reduce",
            "coding challenge",
            "data aggregation"
          ],
          "prerequisites": [
            "theory_array_group_by_reduce"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reduce_mcq_2",
          "topic": "Array.prototype.reduce",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code snippet:\n```javascript\nconst data = ['a', 'b', 'c', 'a', 'd', 'b'];\nconst result = data.reduce((acc, char) => {\n  acc[char] = (acc[char] || 0) + 1;\n  return acc;\n}, {});\nconsole.log(result);\n```\nWhat will be the output of `console.log(result)`?",
          "answer": "{ a: 2, b: 2, c: 1, d: 1 }",
          "options": [
            "['a', 'b', 'c', 'd']",
            "{ '0': 'a', '1': 'b', '2': 'c', '3': 'a', '4': 'd', '5': 'b' }",
            "{ a: 2, b: 2, c: 1, d: 1 }",
            "Error: Cannot read property of undefined"
          ],
          "analysisPoints": [
            "Tests understanding of `reduce`'s accumulator behavior.",
            "Confirms knowledge of how to count occurrences using an object as accumulator.",
            "Ensures the candidate understands the `(acc[char] || 0) + 1` pattern."
          ],
          "keyConcepts": [
            "Array.prototype.reduce",
            "Object as accumulator",
            "Counting occurrences",
            "Conditional (OR) assignment"
          ],
          "evaluationCriteria": [
            "Accurate prediction of `reduce` output",
            "Knowledge of common `reduce` patterns"
          ],
          "example": "The code iterates through the `data` array. The `acc` starts as `{}`. When 'a' is encountered the first time, `acc['a']` is `undefined`, so `(undefined || 0)` evaluates to `0`, and `acc['a']` becomes `1`. When 'a' is encountered again, `acc['a']` is `1`, so `(1 || 0)` evaluates to `1`, and `acc['a']` becomes `2`. This process correctly counts all unique characters.",
          "tags": [
            "array methods",
            "reduce",
            "MCQ",
            "JavaScript"
          ],
          "prerequisites": [
            "theory_array_group_by_reduce"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_callbacks_mcq_1",
          "topic": "Callbacks",
          "level": "easy",
          "type": "mcq",
          "question": "What is a callback function in JavaScript?",
          "answer": "A function passed as an argument to another function, to be executed later.",
          "options": [
            "A function that returns another function.",
            "A function passed as an argument to another function, to be executed later.",
            "A function that is immediately invoked after its definition.",
            "A function that only operates on synchronous code."
          ],
          "analysisPoints": [
            "Correctly defines a callback function.",
            "Distinguishes it from immediately invoked function expressions (IIFE) or higher-order functions that *return* functions."
          ],
          "keyConcepts": [
            "Callbacks",
            "Higher-order functions",
            "Asynchronous programming"
          ],
          "evaluationCriteria": [
            "Basic understanding of callback definition",
            "Ability to distinguish core concept"
          ],
          "example": "In `setTimeout(() => console.log('Hello'), 1000);`, the arrow function `() => console.log('Hello')` is a callback. It is passed to `setTimeout` and executed after a 1000ms delay.",
          "tags": [
            "callbacks",
            "JavaScript basics",
            "asynchronous"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_callbacks_open_1",
          "topic": "Callback Hell",
          "level": "medium",
          "type": "open",
          "question": "Describe 'callback hell' and explain at least two problems it creates in JavaScript code. How do Promises help mitigate these issues?",
          "answer": "'Callback hell' (or 'pyramid of doom') refers to the situation where multiple asynchronous operations are deeply nested using callbacks, leading to excessively indented, hard-to-read, and difficult-to-maintain code.\n\n**Problems it creates:**\n1.  **Readability/Maintainability**: The deep nesting makes the code very hard to follow, understand, and debug. Modifying or adding new steps to the sequence becomes a complex task.\n2.  **Error Handling**: Propagating errors through multiple layers of nested callbacks is cumbersome. Each callback typically needs its own error handling logic, or errors need to be explicitly passed down, leading to duplicated code and potential missed errors.\n3.  **Inversion of Control**: When you pass a callback to an asynchronous function, you lose direct control over when and how that callback is executed. The outer function decides when to invoke it, which can make debugging and reasoning about the flow challenging.\n\n**How Promises help:**\nPromises mitigate these issues by introducing a sequential, chainable mechanism (`.then()`, `.catch()`, `.finally()`). Instead of nesting functions, each asynchronous step returns a new Promise, allowing subsequent operations to be attached in a flat structure. This improves readability, provides a centralized and standard way to handle errors (using `.catch()` at any point in the chain), and restores some control to the developer as the chain explicitly defines the flow.",
          "analysisPoints": [
            "Accurate definition of callback hell.",
            "Clear explanation of at least two problems (readability, error handling, inversion of control).",
            "Concise explanation of how Promises (chaining, `.catch()`) solve these specific problems.",
            "Demonstrates understanding of the historical context and evolution of async JS."
          ],
          "keyConcepts": [
            "Callback hell",
            "Asynchronous programming",
            "Promises",
            "Promise chaining",
            "Error handling"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of callback hell's problems",
            "Ability to articulate Promise solutions effectively",
            "Clarity and structure of the explanation"
          ],
          "example": null,
          "tags": [
            "callbacks",
            "callback hell",
            "promises",
            "asynchronous",
            "architecture"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks",
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_callbacks_flashcard_1",
          "topic": "Asynchronous JavaScript",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main advantage of asynchronous operations using callbacks over synchronous operations?",
          "answer": "Asynchronous operations allow the main thread to remain unblocked, preventing the application from freezing and improving user experience, especially for long-running tasks like network requests.",
          "analysisPoints": [],
          "keyConcepts": [
            "asynchronous",
            "synchronous",
            "callbacks",
            "non-blocking",
            "event loop"
          ],
          "evaluationCriteria": [
            "Recall of fundamental async benefits"
          ],
          "example": null,
          "tags": [
            "callbacks",
            "asynchronous",
            "performance"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_callbacks_code_1",
          "topic": "Callbacks",
          "level": "easy",
          "type": "code",
          "question": "Implement a function `simulateLogin` that takes a `username`, `password`, and a `callback` function. Inside `simulateLogin`, use `setTimeout` to simulate an asynchronous login process. If `username` is 'admin' and `password` is 'password123', call the callback with `true` (success). Otherwise, call the callback with `false` (failure).",
          "answer": "```javascript\nfunction simulateLogin(username, password, callback) {\n  console.log(`Attempting login for user: ${username}...`);\n  setTimeout(() => {\n    if (username === 'admin' && password === 'password123') {\n      console.log('Login successful!');\n      callback(true);\n    } else {\n      console.log('Login failed: Invalid credentials.');\n      callback(false);\n    }\n  }, 1500); // Simulate network delay\n}\n\n// Usage example:\nsimulateLogin('admin', 'password123', (success) => {\n  if (success) {\n    console.log('User redirected to dashboard.');\n  } else {\n    console.log('Displaying login error message.');\n  }\n});\n\nsimulateLogin('guest', 'wrongpass', (success) => {\n  if (success) {\n    console.log('This should not happen for guest.');\n  } else {\n    console.log('Guest login attempt failed, as expected.');\n  }\n});\n```",
          "options": [],
          "analysisPoints": [
            "Correctly defines a function that accepts a callback.",
            "Uses `setTimeout` to simulate asynchronous behavior.",
            "Passes the result of the async operation (true/false) to the callback.",
            "Demonstrates basic conditional logic within the async function."
          ],
          "keyConcepts": [
            "Callbacks",
            "Asynchronous simulation",
            "setTimeout",
            "Conditional logic"
          ],
          "evaluationCriteria": [
            "Correct implementation of callback pattern",
            "Adherence to asynchronous behavior simulation",
            "Handling of success/failure conditions"
          ],
          "example": null,
          "tags": [
            "callbacks",
            "asynchronous",
            "coding challenge",
            "setTimeout"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_callbacks_mcq_2",
          "topic": "Callbacks and Asynchronicity",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following code:\n```javascript\nconsole.log('Start');\n\nfunction processData(data, callback) {\n  setTimeout(() => {\n    console.log('Processing:', data);\n    callback('Processed ' + data);\n  }, 0);\n}\n\nprocessData('input', (result) => {\n  console.log('Result:', result);\n});\n\nconsole.log('End');\n```\nWhat is the exact order of the console outputs?",
          "answer": "Start, End, Processing: input, Result: Processed input",
          "options": [
            "Start, Processing: input, Result: Processed input, End",
            "Start, End, Processing: input, Result: Processed input",
            "Processing: input, Start, End, Result: Processed input",
            "Start, Result: Processed input, Processing: input, End"
          ],
          "analysisPoints": [
            "Tests understanding of the JavaScript event loop and `setTimeout(..., 0)`.",
            "Confirms that `setTimeout` always defers execution to the next tick of the event loop, even with a 0ms delay.",
            "Distinguishes between synchronous and asynchronous execution order."
          ],
          "keyConcepts": [
            "Event Loop",
            "setTimeout",
            "Callbacks",
            "Synchronous vs. Asynchronous"
          ],
          "evaluationCriteria": [
            "Accurate prediction of execution order",
            "Understanding of microtasks/macrotasks (implicitly `setTimeout` is a macrotask)"
          ],
          "example": "Even though `setTimeout` has a 0ms delay, it's still an asynchronous operation. This means `console.log('Start')` executes first, then `processData` is called and registers its callback to be run *after* the current synchronous execution stack is empty. Therefore, `console.log('End')` executes immediately after `processData` is *called* (not after its callback runs). Only then, the event loop picks up the `setTimeout` callback.",
          "tags": [
            "callbacks",
            "asynchronous",
            "event loop",
            "setTimeout",
            "MCQ"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promises_mcq_1",
          "topic": "Promises",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following are the three states a Promise can be in?",
          "answer": "Pending, Fulfilled, Rejected",
          "options": [
            "Running, Paused, Stopped",
            "Pending, Fulfilled, Rejected",
            "Active, Inactive, Completed",
            "Created, Resolved, Failed"
          ],
          "analysisPoints": [
            "Tests basic knowledge of Promise states.",
            "Ensures correct terminology is used."
          ],
          "keyConcepts": [
            "Promises",
            "Promise states"
          ],
          "evaluationCriteria": [
            "Recall of fundamental Promise concepts"
          ],
          "example": "When you create a new Promise, it starts in the `pending` state. If the asynchronous operation succeeds, you `resolve` it, and it moves to the `fulfilled` state. If it fails, you `reject` it, and it moves to the `rejected` state. Once `fulfilled` or `rejected`, the promise is `settled` and its state cannot change.",
          "tags": [
            "promises",
            "asynchronous",
            "JavaScript basics"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_promises_open_1",
          "topic": "Promises and Error Handling",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of `.catch()` in a Promise chain and why it is generally preferred over passing a second argument to `.then()` for error handling. Provide a code example demonstrating a common anti-pattern with `.then()` for error handling and its `.catch()` alternative.",
          "answer": "The `.catch()` method in a Promise chain is used to register a callback that will be invoked only if the Promise chain encounters a rejection (an error). It's essentially a shorthand for `.then(null, onRejected)`.\n\n**Why `.catch()` is preferred over `then(success, error)`:**\n1.  **Readability**: Using `.catch()` explicitly separates error handling logic from success handling, making the code clearer and easier to read. A `.catch()` block visually signals that it's dealing with errors.\n2.  **Centralized Error Handling**: A single `.catch()` at the end of a Promise chain can catch errors from *any* preceding promise in that chain, including errors thrown within any `.then()` block. If you use `then(success, error)` for each step, you would have to duplicate error handling logic or manually re-throw errors to be caught by the next `onRejected`.\n3.  **Catches Errors in `.then()` callbacks**: Crucially, `.catch()` will also catch synchronous errors (exceptions) thrown within any `onFulfilled` callback of a preceding `.then()` in the chain. Passing `onRejected` to `then()` as a second argument would *not* catch errors thrown in the *first* argument's callback (the `onFulfilled` handler) of the *same* `.then()` call; it would only catch rejections from the *preceding* promise.\n\n**Anti-pattern with `.then()` for error handling:**\n```javascript\nfunction fetchData() {\n  return new Promise((resolve, reject) => {\n    // Simulate success/failure\n    const success = Math.random() > 0.5;\n    setTimeout(() => {\n      if (success) {\n        resolve('Data fetched');\n      } else {\n        reject(new Error('Network error'));\n      }\n    }, 500);\n  });\n}\n\nfetchData()\n  .then(data => {\n    console.log(data);\n    throw new Error('Error in processing data'); // This error will NOT be caught by the second arg of this .then()\n    return 'Processed ' + data;\n  }, error => { // Anti-pattern: error handler here\n    console.error('Caught error in first .then() (anti-pattern):', error.message);\n    // This handler only catches errors from fetchData(), not from the .then() callback itself\n  })\n  .then(processedData => {\n    console.log(processedData);\n  })\n  .catch(finalError => {\n    console.error('Caught by final .catch():', finalError.message); // This will catch 'Error in processing data'\n  });\n```\n\n**Preferred `.catch()` alternative:**\n```javascript\nfetchData()\n  .then(data => {\n    console.log(data);\n    throw new Error('Error in processing data'); // This error WILL be caught by the .catch() below\n    return 'Processed ' + data;\n  })\n  .then(processedData => {\n    console.log(processedData);\n  })\n  .catch(error => { // Preferred: Centralized error handling\n    console.error('Caught by .catch():', error.message);\n  })\n  .finally(() => {\n    console.log('Cleanup finished.');\n  });\n```",
          "analysisPoints": [
            "Correctly defines `.catch()` as a specialized `.then()` for errors.",
            "Clearly explains readability benefits.",
            "Highlights the key advantage: catching errors from any *previous* promise in the chain, including synchronous errors thrown in `.then()` callbacks.",
            "Provides a relevant and clear code example demonstrating the anti-pattern and the preferred solution."
          ],
          "keyConcepts": [
            "Promises",
            "Promise chaining",
            ".then()",
            ".catch()",
            "Error handling",
            "Synchronous errors in async chains"
          ],
          "evaluationCriteria": [
            "Thorough understanding of Promise error handling mechanisms",
            "Ability to articulate best practices with justification",
            "Provision of accurate and illustrative code examples"
          ],
          "example": null,
          "tags": [
            "promises",
            "error handling",
            "best practices",
            "asynchronous"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_promises_flashcard_1",
          "topic": "Promises",
          "level": "easy",
          "type": "flashcard",
          "question": "When does a Promise transition from 'pending' to 'settled'?",
          "answer": "A Promise transitions from 'pending' to 'settled' when it either moves to the 'fulfilled' state (due to `resolve()`) or the 'rejected' state (due to `reject()`).",
          "analysisPoints": [],
          "keyConcepts": [
            "promises",
            "promise states",
            "resolve",
            "reject",
            "settled"
          ],
          "evaluationCriteria": [
            "Recall of Promise state transitions"
          ],
          "example": null,
          "tags": [
            "promises",
            "asynchronous",
            "JavaScript"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_promises_code_1",
          "topic": "Promises",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following callback-based function `getUserData` into a Promise-based version called `getUserDataPromise`. The new function should return a Promise that resolves with the user data or rejects with an error message.",
          "answer": "```javascript\n// Original callback-based function:\nfunction getUserDataCallback(userId, successCallback, errorCallback) {\n  console.log(`Fetching user ${userId} via callback...`);\n  setTimeout(() => {\n    if (userId === 123) {\n      successCallback({ id: 123, name: 'Alice', email: 'alice@example.com' });\n    } else {\n      errorCallback('User not found');\n    }\n  }, 1000);\n}\n\n// Refactored Promise-based function:\nfunction getUserDataPromise(userId) {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching user ${userId} via Promise...`);\n    setTimeout(() => {\n      if (userId === 123) {\n        resolve({ id: 123, name: 'Alice', email: 'alice@example.com' });\n      } else {\n        reject(new Error('User not found: ' + userId));\n      }\n    }, 1000);\n  });\n}\n\n// Usage of Promise-based version:\ngetUserDataPromise(123)\n  .then(user => {\n    console.log('Promise Success:', user);\n  })\n  .catch(error => {\n    console.error('Promise Error:', error.message);\n  });\n\ngetUserDataPromise(456)\n  .then(user => {\n    console.log('Promise Success (should not happen):', user);\n  })\n  .catch(error => {\n    console.error('Promise Error:', error.message);\n  });\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses the `new Promise()` constructor.",
            "Maps `successCallback` to `resolve` and `errorCallback` to `reject`.",
            "Ensures the Promise resolves with the correct data and rejects with an appropriate error object.",
            "Demonstrates the cleaner syntax of Promise consumption (`.then().catch()`)."
          ],
          "keyConcepts": [
            "Promises",
            "Callback to Promise conversion",
            "Asynchronous operations",
            "resolve/reject"
          ],
          "evaluationCriteria": [
            "Accurate conversion from callback to Promise pattern",
            "Proper use of `resolve` and `reject`",
            "Code adheres to Promise best practices"
          ],
          "example": null,
          "tags": [
            "promises",
            "callbacks",
            "refactoring",
            "coding challenge",
            "asynchronous"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks",
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promises_mcq_2",
          "topic": "Promises Chaining",
          "level": "medium",
          "type": "mcq",
          "question": "What is the key benefit of chaining `.then()` calls when working with Promises, compared to nested callbacks?",
          "answer": "It flattens the code structure, improving readability and making error handling more centralized.",
          "options": [
            "It allows synchronous code to run faster.",
            "It flattens the code structure, improving readability and making error handling more centralized.",
            "It automatically retries failed operations without explicit code.",
            "It directly converts synchronous code into asynchronous."
          ],
          "analysisPoints": [
            "Highlights the solution to 'callback hell' (flattened structure).",
            "Emphasizes the improved readability and centralized error handling (`.catch()` at the end of chain).",
            "Incorrect options refer to unrelated or false benefits."
          ],
          "keyConcepts": [
            "Promises",
            "Promise chaining",
            "Callback hell",
            "Readability",
            "Error handling"
          ],
          "evaluationCriteria": [
            "Understanding of Promise chaining advantages",
            "Ability to compare Promises vs. Callbacks"
          ],
          "example": "Instead of `fetchUser(cb => fetchPosts(cb => fetchComments(cb => ...)))`, promise chaining looks like `fetchUser().then(user => fetchPosts(user.id)).then(posts => fetchComments(posts[0].id)).then(comments => ...)`. This flatter structure is much easier to read and manage.",
          "tags": [
            "promises",
            "promise chaining",
            "asynchronous",
            "best practices"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promises_all_race_mcq_1",
          "topic": "Promise.all vs. Promise.race",
          "level": "hard",
          "type": "mcq",
          "question": "You need to fetch data from three different API endpoints concurrently. If *all* requests must succeed to proceed, which `Promise` static method should you use? If you only need the result from the *fastest* successful or failed request, which method should you use?",
          "answer": "`Promise.all` for all requests to succeed; `Promise.race` for the fastest request.",
          "options": [
            "`Promise.any` for all requests; `Promise.allSettled` for the fastest.",
            "`Promise.resolve` for all requests; `Promise.reject` for the fastest.",
            "`Promise.all` for all requests to succeed; `Promise.race` for the fastest request.",
            "`Promise.race` for all requests to succeed; `Promise.all` for the fastest request."
          ],
          "analysisPoints": [
            "Accurate distinction between `Promise.all` and `Promise.race` use cases.",
            "`Promise.all` waits for all to fulfill, or one to reject.",
            "`Promise.race` settles as soon as *any* promise settles (fulfills or rejects).",
            "Avoids confusion with `Promise.any` (first *fulfilled*) or `Promise.allSettled` (all settle, return status for each)."
          ],
          "keyConcepts": [
            "Promise.all",
            "Promise.race",
            "Concurrent operations",
            "Asynchronous patterns"
          ],
          "evaluationCriteria": [
            "Deep understanding of `Promise.all` and `Promise.race` behavior",
            "Ability to select appropriate Promise method for specific scenarios"
          ],
          "example": "If fetching user data, posts, and comments are all essential for displaying a profile, use `Promise.all`. If you have multiple image sources and just want to display the first one that loads, use `Promise.race`.",
          "tags": [
            "promises",
            "Promise.all",
            "Promise.race",
            "asynchronous patterns",
            "concurrency"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_promises_then_catch_flashcard",
          "topic": "Promises",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the return value of a `.then()` call in a Promise chain, and how does it enable chaining?",
          "answer": "A `.then()` call always returns a *new* Promise. This new Promise is resolved with the value returned by the callback passed to `.then()`, or rejected if an error is thrown within the callback or if the value returned is a rejected Promise. This consistent return of a new Promise is what allows subsequent `.then()` or `.catch()` calls to be chained.",
          "analysisPoints": [],
          "keyConcepts": [
            "promises",
            "promise chaining",
            ".then()",
            "return value"
          ],
          "evaluationCriteria": [
            "Recall of Promise chaining mechanism",
            "Understanding of return types"
          ],
          "example": null,
          "tags": [
            "promises",
            "asynchronous",
            "chaining"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promises_static_methods_mcq",
          "topic": "Promise Static Methods",
          "level": "hard",
          "type": "mcq",
          "question": "Consider a scenario where you have multiple asynchronous operations, and you want to wait for all of them to complete, regardless of whether they succeed or fail. You then need to inspect the individual outcome (fulfilled or rejected) of each operation. Which `Promise` static method is best suited for this task?",
          "answer": "`Promise.allSettled`",
          "options": [
            "`Promise.all`",
            "`Promise.race`",
            "`Promise.any`",
            "`Promise.allSettled`"
          ],
          "analysisPoints": [
            "Tests knowledge of `Promise.allSettled`'s unique use case.",
            "Distinguishes `allSettled` from `all` (which rejects on first failure) and `race`/`any` (which resolve/reject on first settlement/fulfillment).",
            "Emphasizes the requirement to inspect *all* outcomes, regardless of success or failure."
          ],
          "keyConcepts": [
            "Promise.allSettled",
            "Promise.all",
            "Promise.race",
            "Promise.any",
            "Asynchronous patterns",
            "Error handling"
          ],
          "evaluationCriteria": [
            "Advanced understanding of Promise static methods",
            "Ability to choose the most appropriate method for a complex scenario"
          ],
          "example": "If you're making multiple API calls for different widgets on a dashboard, and you want to display all results (even if some widgets fail to load), `Promise.allSettled` is perfect. It will return an array like `[{status: 'fulfilled', value: data}, {status: 'rejected', reason: error}]`, allowing you to handle each outcome individually.",
          "tags": [
            "promises",
            "Promise.allSettled",
            "asynchronous patterns",
            "error handling",
            "advanced JavaScript"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_advanced_groupby",
          "title": "Implement a Generic `groupBy` Function with Custom Key Extraction",
          "description": "\nImplement a JavaScript function `advancedGroupBy(array, keyExtractor)` that groups elements of an array based on a custom key. Instead of a simple string `key`, the function should accept a `keyExtractor` argument which can be:\n\n1.  **A string**: In this case, `advancedGroupBy` should behave like the original `groupBy` function, using the string as the property name to group by.\n2.  **A function**: If `keyExtractor` is a function, it should be called for each item in the array, and its return value should be used as the grouping key.\n\nYour implementation must use `Array.prototype.reduce()`.\n\n**Requirements:**\n*   The function signature should be `advancedGroupBy(array, keyExtractor)`.\n*   Handle both string and function `keyExtractor` types.\n*   Return an object where keys are the extracted group values and values are arrays of items belonging to that group.\n*   Ensure the function is robust and handles edge cases like empty arrays or `null`/`undefined` items.\n",
          "difficulty": "medium",
          "startingCode": "function advancedGroupBy(array, keyExtractor) {\n  // TODO: Implement the required functionality\n  // Consider keyExtractor being a string or a function.\n  // Use Array.prototype.reduce()\n\n  return array.reduce((acc, item) => {\n    // Your grouping logic here\n    return acc;\n  }, {});\n}\n\n// Example usage (for testing):\n// const users = [\n//   { id: 1, name: 'Alice', role: 'admin', lastLogin: new Date('2023-01-15') },\n//   { id: 2, name: 'Bob', role: 'user', lastLogin: new Date('2023-01-10') },\n//   { id: 3, name: 'Charlie', role: 'admin', lastLogin: new Date('2023-02-01') },\n//   { id: 4, name: 'David', role: 'user', lastLogin: new Date('2023-01-20') },\n// ];\n//\n// // Group by string key 'role'\n// console.log('Grouped by role:', advancedGroupBy(users, 'role'));\n//\n// // Group by function (e.g., login month)\n// console.log('Grouped by login month:', advancedGroupBy(users, user => user.lastLogin.getMonth() + 1));\n",
          "solutionCode": "function advancedGroupBy(array, keyExtractor) {\n  if (!Array.isArray(array)) {\n    throw new Error('Input must be an array.');\n  }\n\n  return array.reduce((acc, item) => {\n    if (item === null || typeof item === 'undefined') {\n      // Optionally handle null/undefined items, e.g., skip them or group under a special key\n      return acc;\n    }\n\n    let key;\n    if (typeof keyExtractor === 'string') {\n      key = item[keyExtractor];\n    } else if (typeof keyExtractor === 'function') {\n      key = keyExtractor(item);\n    } else {\n      throw new Error('keyExtractor must be a string or a function.');\n    }\n\n    // Handle cases where the extracted key itself might be null or undefined\n    const groupKey = (key === null || typeof key === 'undefined') ? 'null_undefined_group' : key;\n\n    (acc[groupKey] = acc[groupKey] || []).push(item);\n    return acc;\n  }, {});\n}\n",
          "testCases": [
            "Test with string key: `advancedGroupBy([{id: 1, type: 'A'}, {id: 2, type: 'B'}, {id: 3, type: 'A'}], 'type')` should return `{ A: [{id: 1, type: 'A'}, {id: 3, type: 'A'}], B: [{id: 2, type: 'B'}] }`",
            "Test with function key: `advancedGroupBy([{val: 1}, {val: 2}, {val: 3}], item => item.val % 2 === 0 ? 'even' : 'odd')` should return `{ odd: [{val: 1}, {val: 3}], even: [{val: 2}] }`",
            "Test with empty array: `advancedGroupBy([], 'type')` should return `{}`",
            "Test with mixed types for key: `advancedGroupBy([{value: 1}, {value: '2'}, {value: true}], item => typeof item.value)` should group by 'number', 'string', 'boolean'.",
            "Test with null/undefined values for grouping key: `advancedGroupBy([{val:1}, {val:null}, {val:2}], 'val')` should group `null` into a specific key or handle as required.",
            "Test with `keyExtractor` returning `null`/`undefined`: `advancedGroupBy([{a:1}, {a:null}], item => item.a)` should correctly handle null as a key.",
            "Test with invalid `keyExtractor` type: `advancedGroupBy([{a:1}], 123)` should throw an error."
          ],
          "hints": [
            "Check the `typeof` `keyExtractor` inside the `reduce` callback to determine how to extract the key.",
            "Remember the `(result[key] = result[key] || []).push(item)` pattern from the initial example.",
            "Consider how to handle cases where `item[keyExtractor]` or `keyExtractor(item)` might return `null` or `undefined`."
          ],
          "tags": [
            "Array.prototype.reduce",
            "functional programming",
            "data transformation",
            "utility functions",
            "higher-order functions"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_array_group_by_reduce"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "hof",
            "polymorphism",
            "data_structures"
          ]
        },
        {
          "id": "task_callback_to_promise",
          "title": "Refactor Callback-based API to Promise-based with Chaining",
          "description": "\nYou are given a set of callback-based asynchronous functions that simulate API calls. Your task is to refactor them into Promise-based functions and then chain them together to perform a sequence of operations.\n\n**Given Callback Functions (DO NOT MODIFY THESE):**\n```javascript\nfunction fetchUserData(userId, callback) {\n  console.log(`[CB] Fetching user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, { id: 1, name: 'Alice', email: 'alice@example.com' });\n    } else {\n      callback(new Error('User not found'), null);\n    }\n  }, 500);\n}\n\nfunction fetchUserPosts(userId, callback) {\n  console.log(`[CB] Fetching posts for user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, [{ postId: 101, title: 'My First Post' }, { postId: 102, title: 'My Second Post' }]);\n    } else {\n      callback(new Error('No posts found for user'), null);\n    }\n  }, 700);\n}\n\nfunction fetchPostComments(postId, callback) {\n  console.log(`[CB] Fetching comments for post ${postId}...`);\n  setTimeout(() => {\n    if (postId === 101) {\n      callback(null, [{ commentId: 201, text: 'Great post!' }, { commentId: 202, text: 'Awesome!' }]);\n    } else {\n      callback(new Error('No comments found for post'), null);\n    }\n  }, 600);\n}\n```\n\n**Requirements:**\n1.  **Create Promise-based equivalents**: For each `fetch*` function above, create a new function (e.g., `fetchUserDataPromise`, `fetchUserPostsPromise`, `fetchPostCommentsPromise`) that returns a Promise. The Promise should `resolve` with the data on success and `reject` with an `Error` object on failure.\n2.  **Chain Operations**: Use your new Promise-based functions to fetch the following sequence for `userId = 1`:\n    *   User Data\n    *   Then, Posts for that user\n    *   Then, Comments for the *first* post of that user.\n3.  **Error Handling**: Implement proper error handling using `.catch()` to log any errors that occur at any stage of the chain.\n4.  **Final Cleanup**: Use `.finally()` to log a message indicating the entire process has finished, regardless of success or failure.\n",
          "difficulty": "medium",
          "startingCode": "// Given Callback Functions (DO NOT MODIFY THESE):\nfunction fetchUserData(userId, callback) {\n  console.log(`[CB] Fetching user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, { id: 1, name: 'Alice', email: 'alice@example.com' });\n    } else {\n      callback(new Error('User not found'), null);\n    }\n  }, 500);\n}\n\nfunction fetchUserPosts(userId, callback) {\n  console.log(`[CB] Fetching posts for user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, [{ postId: 101, title: 'My First Post' }, { postId: 102, title: 'My Second Post' }]);\n    } else {\n      callback(new Error('No posts found for user'), null);\n    }\n  }, 700);\n}\n\nfunction fetchPostComments(postId, callback) {\n  console.log(`[CB] Fetching comments for post ${postId}...`);\n  setTimeout(() => {\n    if (postId === 101) {\n      callback(null, [{ commentId: 201, text: 'Great post!' }, { commentId: 202, text: 'Awesome!' }]);\n    } else {\n      callback(new Error('No comments found for post'), null);\n    }\n  }, 600);\n}\n\n// TODO: Implement Promise-based equivalents and chain them\n// function fetchUserDataPromise(userId) { /* ... */ }\n// function fetchUserPostsPromise(userId) { /* ... */ }\n// function fetchPostCommentsPromise(postId) { /* ... */ }\n\n// Your Promise chain for userId = 1 here:\n",
          "solutionCode": "// Given Callback Functions (DO NOT MODIFY THESE):\nfunction fetchUserData(userId, callback) {\n  console.log(`[CB] Fetching user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, { id: 1, name: 'Alice', email: 'alice@example.com' });\n    } else {\n      callback(new Error('User not found'), null);\n    }\n  }, 500);\n}\n\nfunction fetchUserPosts(userId, callback) {\n  console.log(`[CB] Fetching posts for user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, [{ postId: 101, title: 'My First Post' }, { postId: 102, title: 'My Second Post' }]);\n    } else {\n      callback(new Error('No posts found for user'), null);\n    }\n  }, 700);\n}\n\nfunction fetchPostComments(postId, callback) {\n  console.log(`[CB] Fetching comments for post ${postId}...`);\n  setTimeout(() => {\n    if (postId === 101) {\n      callback(null, [{ commentId: 201, text: 'Great post!' }, { commentId: 202, text: 'Awesome!' }]);\n    } else {\n      callback(new Error('No comments found for post'), null);\n    }\n  }, 600);\n}\n\n// 1. Create Promise-based equivalents\nfunction fetchUserDataPromise(userId) {\n  return new Promise((resolve, reject) => {\n    fetchUserData(userId, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nfunction fetchUserPostsPromise(userId) {\n  return new Promise((resolve, reject) => {\n    fetchUserPosts(userId, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nfunction fetchPostCommentsPromise(postId) {\n  return new Promise((resolve, reject) => {\n    fetchPostComments(postId, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\n// 2. Chain Operations, 3. Error Handling, 4. Final Cleanup\nconst TARGET_USER_ID = 1;\n\nconsole.log('--- Starting Promise Chain ---');\nfetchUserDataPromise(TARGET_USER_ID)\n  .then(user => {\n    console.log('[P] User Data:', user);\n    return fetchUserPostsPromise(user.id);\n  })\n  .then(posts => {\n    console.log('[P] User Posts:', posts);\n    if (posts.length > 0) {\n      return fetchPostCommentsPromise(posts[0].postId);\n    } else {\n      throw new Error('No posts available to fetch comments for.');\n    }\n  })\n  .then(comments => {\n    console.log('[P] First Post Comments:', comments);\n    console.log('--- All operations succeeded! ---');\n  })\n  .catch(error => {\n    console.error('[P] An error occurred in the chain:', error.message);\n  })\n  .finally(() => {\n    console.log('--- Promise chain process finished. ---');\n  });\n\n// Test case for a user not found to demonstrate error handling\nconst NON_EXISTENT_USER_ID = 999;\nconsole.log('\\n--- Starting Promise Chain for non-existent user ---');\nfetchUserDataPromise(NON_EXISTENT_USER_ID)\n  .then(user => {\n    console.log('[P] User Data (should not happen):', user);\n  })\n  .catch(error => {\n    console.error('[P] Error for non-existent user:', error.message);\n  })\n  .finally(() => {\n    console.log('--- Promise chain for non-existent user finished. ---');\n  });\n\n// Test case for no posts found\nconst USER_ID_NO_POSTS = 2; // Assuming userId 2 would yield no posts from CB function logic\n// (Note: The given CB functions only have logic for userId 1)\n// For a proper test, fetchUserPosts or fetchUserData would need to be modified\n// to return specific errors or empty arrays for userId 2.\n// As per the original problem statement, we stick to the provided CBs.\n// Let's simulate a case where fetchUserPosts would return an empty array if userId != 1\n// This specific test case might not work with the given CBs as they only handle userId === 1 for success.\n// To test 'no posts found', the `fetchUserPosts` callback logic would need modification.\n// For now, the non-existent user test covers the rejection path.\n\n",
          "testCases": [
            "Successful chain for `userId = 1`: User data, posts, and comments for post 101 should be logged.",
            "Error handling for non-existent user: `fetchUserDataPromise(999)` should trigger the `.catch()` block.",
            "Error handling for no posts: (Requires modification to `fetchUserPosts` to return `null` or empty array based on user ID). If `fetchUserPostsPromise` rejects, the `.catch()` should be hit.",
            "Error handling for no comments: (Requires modification to `fetchPostComments` to reject for specific `postId`). If `fetchPostCommentsPromise` rejects, the `.catch()` should be hit.",
            "Verify `.finally()` is always executed, whether success or failure.",
            "Ensure no callback hell is present in the solution."
          ],
          "hints": [
            "Remember that the `Promise` constructor takes a function with `resolve` and `reject` arguments.",
            "The `error` argument in the original callback functions should map to `reject(new Error(error_message))`, and the `data` argument should map to `resolve(data)`.",
            "When chaining, remember that a `.then()` callback should return a *new* promise if the next operation is asynchronous, or a value if it's synchronous.",
            "Use `if (posts.length > 0)` before attempting to access `posts[0]` to prevent errors if no posts are returned."
          ],
          "tags": [
            "promises",
            "refactoring",
            "asynchronous",
            "promise chaining",
            "error handling",
            "callback hell solution"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks",
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "async_await",
            "fetch_api"
          ]
        },
        {
          "id": "task_concurrent_api_calls",
          "title": "Perform Concurrent API Calls with Success/Failure Aggregation",
          "description": "\nYou need to fetch data from multiple independent API endpoints concurrently. Your application requires knowing the outcome of *all* requests (whether they succeeded or failed) and then processing their results.\n\n**Given Mock API Functions (DO NOT MODIFY THESE):**\n```javascript\nfunction mockFetch(url, delay, success = true) {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching from ${url} (simulating ${success ? 'success' : 'failure'})...`);\n    setTimeout(() => {\n      if (success) {\n        resolve(`Data from ${url}`);\n      } else {\n        reject(new Error(`Failed to fetch from ${url}`));\n      }\n    }, delay);\n  });\n}\n```\n\n**Requirements:**\n1.  **Concurrent Execution**: Make three concurrent calls using `mockFetch`:\n    *   `mockFetch('/api/users', 800, true)`\n    *   `mockFetch('/api/products', 1200, false)` (simulate failure)\n    *   `mockFetch('/api/orders', 600, true)`\n2.  **Aggregate All Outcomes**: Use the appropriate `Promise` static method to wait for *all* these promises to settle (either fulfill or reject).\n3.  **Process Results**: After all promises have settled, iterate through their outcomes and log whether each operation was `fulfilled` or `rejected`, along with its value or reason. Format the output clearly.\n4.  **No Early Exit**: Ensure that even if one promise rejects, the entire operation continues until all promises have completed.\n",
          "difficulty": "hard",
          "startingCode": "function mockFetch(url, delay, success = true) {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching from ${url} (simulating ${success ? 'success' : 'failure'})...`);\n    setTimeout(() => {\n      if (success) {\n        resolve(`Data from ${url}`);\n      } else {\n        reject(new Error(`Failed to fetch from ${url}`));\n      }\n    }, delay);\n  });\n}\n\n// TODO: Implement the concurrent calls and process results\n// const promise1 = mockFetch('/api/users', 800, true);\n// const promise2 = mockFetch('/api/products', 1200, false);\n// const promise3 = mockFetch('/api/orders', 600, true);\n\n// Use the appropriate Promise static method here...\n",
          "solutionCode": "function mockFetch(url, delay, success = true) {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching from ${url} (simulating ${success ? 'success' : 'failure'})...`);\n    setTimeout(() => {\n      if (success) {\n        resolve(`Data from ${url}`);\n      } else {\n        reject(new Error(`Failed to fetch from ${url}`));\n      }\n    }, delay);\n  });\n}\n\n// 1. Concurrent Execution\nconst promise1 = mockFetch('/api/users', 800, true);\nconst promise2 = mockFetch('/api/products', 1200, false); // Simulate failure\nconst promise3 = mockFetch('/api/orders', 600, true);\n\n// 2. Aggregate All Outcomes using Promise.allSettled\nconsole.log('--- Starting Concurrent Fetches ---');\nPromise.allSettled([promise1, promise2, promise3])\n  .then(results => {\n    console.log('\\n--- All Promises Settled ---');\n    results.forEach((result, index) => {\n      console.log(`Promise ${index + 1} (${result.status}):`);\n      if (result.status === 'fulfilled') {\n        console.log(`  Value: ${result.value}`);\n      } else {\n        console.error(`  Reason: ${result.reason.message}`);\n      }\n    });\n    console.log('--- Processing complete ---');\n  })\n  .catch(error => {\n    // This catch block will typically not be hit by Promise.allSettled\n    // unless there's an error in the .then() callback itself, or if the input isn't iterable.\n    console.error('Unexpected error during allSettled:', error.message);\n  });\n",
          "testCases": [
            "All three `mockFetch` calls should initiate concurrently.",
            "`Promise.allSettled` should resolve only after the longest-running promise (`/api/products` at 1200ms) has settled.",
            "The `results` array should contain three objects, each with a `status` property (`fulfilled` or `rejected`).",
            "The object for `/api/users` should have `status: 'fulfilled'` and `value: 'Data from /api/users'`.",
            "The object for `/api/products` should have `status: 'rejected'` and `reason: Error('Failed to fetch from /api/products')`.",
            "The object for `/api/orders` should have `status: 'fulfilled'` and `value: 'Data from /api/orders'`.",
            "The output should clearly indicate the status and result/reason for each individual promise.",
            "The `.catch()` block should *not* be triggered by the rejection of `promise2` (as `Promise.allSettled` doesn't reject)."
          ],
          "hints": [
            "Consider which `Promise` static method resolves *after all promises settle*, regardless of individual success or failure.",
            "The result of this specific static method is an array of objects, where each object describes the outcome of a promise (e.g., `{ status: 'fulfilled', value: data }` or `{ status: 'rejected', reason: error }`).",
            "Iterate through the results array and use conditional logic to log based on `status`."
          ],
          "tags": [
            "promises",
            "Promise.allSettled",
            "asynchronous",
            "concurrent programming",
            "error handling",
            "API calls"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "async_await",
            "fetch_api",
            "concurrency"
          ]
        }
      ]
    }
  },
  {
    "id": "8ed9b91d-cd21-49e3-ab49-c93d7f748a64",
    "startLine": 1600,
    "endLine": 1699,
    "processedDate": "2025-06-17T07:57:33.630Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_promise_combinators",
          "title": "Promise Combinators: allSettled and any",
          "content": "Promise combinators are static methods on the `Promise` object that take an iterable (like an array) of Promises as input and return a single Promise. They are useful for orchestrating multiple asynchronous operations.\n\n### Promise.allSettled()\n\n`Promise.allSettled()` waits for all given promises to settle, regardless of whether they are fulfilled or rejected. It returns a promise that resolves with an array of objects, each describing the outcome of a promise.\n\nEach outcome object has a `status` string (`'fulfilled'` or `'rejected'`) and either a `value` (if fulfilled) or a `reason` (if rejected). This is particularly useful when you need to know the result of every promise, even if some of them fail, without the entire operation short-circuiting on the first rejection.\n\n### Promise.any()\n\n`Promise.any()` takes an iterable of Promises and returns a single Promise that resolves as soon as any of the input Promises resolves (fulfills). If no Promise in the iterable fulfills (i.e., all of them reject), then the Promise returned by `Promise.any()` rejects with an `AggregateError`, a subclass of `Error` that groups individual errors.\n\nThis combinator is useful when you need to get the fastest successful result from multiple competing asynchronous operations. It's conceptually the opposite of `Promise.all` in its error handling: `Promise.all` rejects on the first rejection, `Promise.any` resolves on the first fulfillment.\n\n| Combinator | Behavior (Success)                                   | Behavior (Failure)                                     | Use Case                                                                                                   |\n|------------|------------------------------------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------|\n| `allSettled` | Resolves with an array of outcome objects (value/reason) once all promises have settled. | Never rejects if all promises settle. The outcome array will contain rejected statuses. | When you need results from all promises, regardless of success or failure.                                |\n| `any`      | Resolves with the value of the first promise that fulfills. | Rejects with an `AggregateError` if all promises reject. | When you need the first successful result from multiple options.                                          |",
          "examples": [
            {
              "id": "example_promise_allsettled_1",
              "title": "Using Promise.allSettled",
              "code": "Promise.allSettled([\n  fetch('/api/users').then(res => res.json()),\n  fetch('/endpoint-that-might-fail').then(res => res.json())\n])\n  .then(results => {\n    console.log('All settled results:', results);\n    results.forEach(result => {\n      if (result.status === 'fulfilled') {\n        console.log('Fulfilled:', result.value);\n      } else {\n        console.log('Rejected:', result.reason);\n      }\n    });\n  })\n  .catch(err => {\n    // This catch block will typically not be hit unless Promise.allSettled itself fails,\n    // not because of individual promise rejections.\n    console.error('Promise.allSettled failed:', err);\n  });\n\n// Example of results array structure:\n/*\n[\n  { status: 'fulfilled', value: [...] },\n  { status: 'rejected', reason: Error('Network Error') }\n]\n*/",
              "explanation": "This example demonstrates how `Promise.allSettled` collects the results (either `fulfilled` with `value` or `rejected` with `reason`) from all promises, allowing the application to continue processing even if some operations fail. The `.then()` block always executes once all input promises have completed.",
              "language": "typescript"
            },
            {
              "id": "example_promise_any_1",
              "title": "Using Promise.any",
              "code": "Promise.any([\n  fetch('/api/endpoint1').then(res => res.json()),\n  fetch('/api/endpoint2').then(res => res.json()),\n  fetch('/api/endpoint3').then(res => res.json())\n])\n  .then(firstSuccess => console.log('First successful result:', firstSuccess))\n  .catch(errors => {\n    console.log('All promises rejected, errors:', errors);\n    // errors will be an AggregateError instance\n    errors.errors.forEach(err => console.error('Individual rejection:', err));\n  });",
              "explanation": "`Promise.any` is used here to resolve with the data from the first successful `fetch` call. If all three `fetch` calls fail (e.g., network errors, server errors), the `.catch()` block will execute, receiving an `AggregateError` containing all the individual rejection reasons.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Promises",
            "Asynchronous JavaScript",
            "Promise Combinators",
            "ES2020"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Promises",
            "Fetch API",
            "Error Handling"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced Asynchronous Patterns",
            "Robust API Integration"
          ]
        },
        {
          "id": "theory_async_await",
          "title": "Async/Await: Simplifying Asynchronous Code",
          "content": "Async/await is a modern JavaScript syntax introduced in ES2017 that makes asynchronous code look and behave more like synchronous code, making it easier to read and write. It's built on top of Promises, acting as syntactic sugar.\n\n### `async` Functions\n\nA function declared with the `async` keyword automatically returns a Promise. If the function returns a value, the Promise will resolve with that value. If the function throws an error, the Promise will reject with that error.\n\n```typescript\nasync function myFunction() {\n  return 'hello'; // Equivalent to return Promise.resolve('hello');\n}\n\nasync function myErrorFunction() {\n  throw new Error('Oops'); // Equivalent to return Promise.reject(new Error('Oops'));\n}\n```\n\n### `await` Operator\n\nThe `await` keyword can only be used inside an `async` function. It pauses the execution of the `async` function until the Promise it's waiting on settles (either fulfills or rejects). Once the Promise settles:\n\n*   If the Promise fulfills, `await` returns the fulfilled value.\n*   If the Promise rejects, `await` throws the rejected value as an error. This behavior allows `try...catch` blocks to handle errors in asynchronous code in a familiar synchronous manner.\n\n### Error Handling with `try...catch`\n\nOne of the significant advantages of `async/await` is the ability to use standard `try...catch` blocks for error handling, making the code more readable and robust compared to chaining `.catch()` calls.\n\n### Sequential vs. Parallel Execution\n\nWhen dealing with multiple `await` calls, it's crucial to understand the difference between sequential and parallel execution:\n\n*   **Sequential Execution**: If you `await` each Promise one after another, each operation will complete before the next one starts. This is useful when operations depend on the results of previous ones but can be slower if operations are independent.\n\n    ```typescript\n    async function sequentialFetch() {\n      const data1 = await fetchData1(); // Waits for data1\n      const data2 = await fetchData2(); // Waits for data2 after data1 is done\n      return [data1, data2];\n    }\n    ```\n\n*   **Parallel Execution**: For independent asynchronous operations, you can start all promises concurrently and then `await` them together using `Promise.all()` (or `Promise.allSettled()`, `Promise.any()`, `Promise.race()`). This significantly improves performance by running operations in parallel.\n\n    ```typescript\n    async function parallelFetch() {\n      const promise1 = fetchData1(); // Start fetching data1\n      const promise2 = fetchData2(); // Start fetching data2 concurrently\n\n      const [data1, data2] = await Promise.all([promise1, promise2]); // Wait for both to complete\n      return [data1, data2];\n    }\n    ```\n\nChoosing between sequential and parallel execution depends on whether the operations have dependencies on each other or can run independently.",
          "examples": [
            {
              "id": "example_async_await_basic_1",
              "title": "Basic Async/Await with Error Handling",
              "code": "async function fetchUserData() {\n  try {\n    const response = await fetch('/api/user');\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const userData = await response.json();\n    return userData;\n  } catch (error) {\n    console.error('Error fetching user data:', error);\n    // Re-throw or return default value for further handling\n    return { error: true, message: error.message };\n  }\n}\n\n// Example usage:\nfetchUserData().then(data => console.log('User Data:', data));",
              "explanation": "This function `fetchUserData` demonstrates the basic use of `async/await` to perform an API call. The `await` keyword pauses execution until the `fetch` promise resolves. Error handling is managed using a standard `try...catch` block, which catches both network errors and errors thrown manually if the HTTP response is not OK.",
              "language": "typescript"
            },
            {
              "id": "example_async_await_promise_all_1",
              "title": "Using Async/Await with Promise.all for Parallel Execution",
              "code": "async function fetchAllData() {\n  try {\n    // Start all fetch operations concurrently\n    const usersPromise = fetch('/api/users').then(res => res.json());\n    const postsPromise = fetch('/api/posts').then(res => res.json());\n    const commentsPromise = fetch('/api/comments').then(res => res.json());\n\n    // Wait for all promises to resolve in parallel\n    const [users, posts, comments] = await Promise.all([\n      usersPromise, \n      postsPromise, \n      commentsPromise\n    ]);\n    \n    console.log('All data fetched successfully:');\n    console.log('Users:', users);\n    console.log('Posts:', posts);\n    console.log('Comments:', comments);\n\n    return { users, posts, comments };\n  } catch (error) {\n    console.error('Error fetching data:', error);\n    throw error; // Re-throw the error for the caller to handle\n  }\n}\n\n// Example usage:\nfetchAllData().catch(err => console.error('Failed to fetch all data:', err));",
              "explanation": "This example shows how to perform multiple independent asynchronous operations in parallel using `async/await` combined with `Promise.all`. All `fetch` calls are initiated almost simultaneously. The `await Promise.all([...])` then waits for all of them to complete. If any of the promises passed to `Promise.all` reject, the `Promise.all` itself rejects, and the `try...catch` block handles it.",
              "language": "typescript"
            },
            {
              "id": "example_async_await_sequential_vs_parallel",
              "title": "Sequential vs Parallel Execution Comparison",
              "code": "const fetchData = (name, delay) => new Promise(resolve => {\n  setTimeout(() => {\n    console.log(`Fetched ${name} after ${delay}ms`);\n    resolve(`${name} Data`);\n  }, delay);\n});\n\nasync function sequential() {\n  console.log('\\n--- Starting Sequential Fetch ---');\n  const start = Date.now();\n  \n  const result1 = await fetchData('Data1', 1000); // 1s\n  const result2 = await fetchData('Data2', 500);  // 0.5s\n  const result3 = await fetchData('Data3', 800);  // 0.8s\n  \n  console.log(`Sequential Time taken: ${Date.now() - start}ms`); // Approx 1000 + 500 + 800 = 2300ms\n  return [result1, result2, result3];\n}\n\nasync function parallel() {\n  console.log('\\n--- Starting Parallel Fetch ---');\n  const start = Date.now();\n  \n  const promise1 = fetchData('Data1', 1000);\n  const promise2 = fetchData('Data2', 500);\n  const promise3 = fetchData('Data3', 800);\n  \n  const [result1, result2, result3] = await Promise.all([promise1, promise2, promise3]);\n  \n  console.log(`Parallel Time taken: ${Date.now() - start}ms`); // Approx max(1000, 500, 800) = 1000ms\n  return [result1, result2, result3];\n}\n\n// Run both to see the difference\nsequential().then(() => parallel());",
              "explanation": "This example vividly illustrates the performance difference between sequential and parallel execution using `async/await`. In `sequential()`, each `await` pauses the function until the current `fetchData` Promise resolves, leading to a total time that's the sum of individual delays. In `parallel()`, all `fetchData` Promises are initiated at once. `Promise.all` then waits for the *longest* running promise to complete, resulting in significantly faster overall execution time.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Async/Await",
            "Asynchronous JavaScript",
            "Promises",
            "Error Handling",
            "Performance"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Promises",
            "Callbacks",
            "Error Handling"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Modern JavaScript Development",
            "React/Vue/Angular Best Practices"
          ]
        },
        {
          "id": "theory_event_loop",
          "title": "The JavaScript Event Loop",
          "content": "The JavaScript Event Loop is a crucial concept for understanding how JavaScript handles asynchronous operations despite being single-threaded. JavaScript executes code line by line in a single call stack. When it encounters asynchronous operations (like `setTimeout`, `fetch`, `Promise`), it offloads them to Web APIs (or Node.js APIs in a Node environment).\n\n### Key Components:\n\n1.  **Call Stack**: Where synchronous code is executed. Functions are pushed onto the stack when called and popped off when they return.\n2.  **Web APIs**: Provided by the browser (or C++ APIs in Node.js) to handle asynchronous tasks like DOM events, HTTP requests (`fetch`), and timers (`setTimeout`, `setInterval`). When a Web API completes its task, it places a corresponding callback function into a queue.\n3.  **Callback Queue (Task Queue / Macrotask Queue)**: This queue holds callback functions for macrotasks (e.g., `setTimeout`, `setInterval`, I/O, UI rendering). When the Call Stack is empty, the Event Loop picks one callback from this queue and pushes it to the Call Stack for execution.\n4.  **Microtask Queue**: This queue holds callback functions for microtasks (e.g., Promise callbacks (`.then()`, `.catch()`, `.finally()`), `queueMicrotask`, `MutationObserver`). The Event Loop prioritizes the Microtask Queue. It processes *all* microtasks in the Microtask Queue *before* picking any macrotask from the Callback Queue, as long as the Call Stack is empty.\n\n### How it Works (The Loop):\n\nThe Event Loop continuously monitors the Call Stack and the various task queues. Its job is to:\n\n*   When the Call Stack is empty, it checks the Microtask Queue. If there are microtasks, it moves *all* of them (one by one) to the Call Stack for execution, emptying the Microtask Queue.\n*   After the Microtask Queue is empty (or if it was empty to begin with), if the Call Stack is still empty, the Event Loop checks the Callback Queue (Macrotask Queue). It picks *one* macrotask from the Callback Queue and moves it to the Call Stack for execution.\n*   This cycle repeats indefinitely.\n\nThis prioritization means that Promises will often execute their `.then()` callbacks before `setTimeout` callbacks, even if the `setTimeout` has a delay of 0ms.\n\n### Example Flow Trace:\n\nConsider the following code snippet:\n\n```javascript\nconsole.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise resolved');\n});\n\nconsole.log('Script end');\n```\n\n1.  `console.log('Script start')` is executed immediately. Output: `Script start`.\n2.  `setTimeout(() => { console.log('setTimeout'); }, 0)` is encountered. The callback `() => { console.log('setTimeout'); }` is sent to the Web API for timers. After 0ms (or minimum browser delay, usually 4ms for HTML5 spec), the Web API places this callback into the **Callback Queue**.\n3.  `Promise.resolve().then(() => { console.log('Promise resolved'); })` is encountered. `Promise.resolve()` immediately resolves a Promise. Its `.then()` callback `() => { console.log('Promise resolved'); }` is placed into the **Microtask Queue**.\n4.  `console.log('Script end')` is executed immediately. Output: `Script end`.\n5.  The global script execution finishes. The Call Stack is now empty.\n6.  The Event Loop checks the **Microtask Queue**. It finds `() => { console.log('Promise resolved'); }` and moves it to the Call Stack.\n7.  `console.log('Promise resolved')` executes. Output: `Promise resolved`.\n8.  The Microtask Queue is now empty. The Call Stack is empty.\n9.  The Event Loop checks the **Callback Queue**. It finds `() => { console.log('setTimeout'); }` and moves it to the Call Stack.\n10. `console.log('setTimeout')` executes. Output: `setTimeout`.\n11. The Callback Queue is now empty. The Call Stack is empty. The Event Loop continues its cycle.\n\n**Final Output Order:**\n```\nScript start\nScript end\nPromise resolved\nsetTimeout\n```\nThis order highlights the microtask queue's priority over the macrotask queue.",
          "examples": [
            {
              "id": "example_event_loop_basic_flow",
              "title": "Event Loop Basic Flow Demonstration",
              "code": "console.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout 1');\n  Promise.resolve().then(() => {\n    console.log('Promise resolved 2 (inside setTimeout)');\n  });\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise resolved 1');\n  setTimeout(() => {\n    console.log('setTimeout 2 (inside Promise)');\n  }, 0);\n});\n\nconsole.log('Script end');\n\n// Expected Output:\n// Script start\n// Script end\n// Promise resolved 1\n// Promise resolved 2 (inside setTimeout)\n// setTimeout 1\n// setTimeout 2 (inside Promise)",
              "explanation": "This example demonstrates a more complex interaction. `Script start` and `Script end` execute first. Then, `Promise resolved 1` (microtask) executes before `setTimeout 1` (macrotask). Inside `Promise resolved 1`, a new `setTimeout 2` is queued as a macrotask. Inside `setTimeout 1`, a new `Promise resolved 2` is queued as a microtask. When `setTimeout 1` executes, `Promise resolved 2` goes to the microtask queue, which is processed *before* any new macrotasks (like `setTimeout 2` or the *next* macrotask in general). Thus, `Promise resolved 2` executes before `setTimeout 1` *finishes* its execution (in the context of the next loop iteration of macrotasks), and `setTimeout 2` gets picked up even later.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Event Loop",
            "Asynchronous JavaScript",
            "Concurrency Model",
            "Promises",
            "setTimeout",
            "Microtasks",
            "Macrotasks"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Callbacks",
            "Promises"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "requiredFor": [
            "Deep JavaScript Understanding",
            "Debugging Asynchronous Issues",
            "Node.js Event Loop"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_promise_combinators_1",
          "topic": "Promise.allSettled",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `Promise.allSettled()`?",
          "answer": "To wait for all promises in an iterable to settle (either fulfill or reject) and get the outcome of each.",
          "analysisPoints": [
            "Focuses on 'all promises settling'.",
            "Highlights receiving 'outcome of each' regardless of success/failure."
          ],
          "keyConcepts": [
            "Promise.allSettled",
            "Promise states",
            "Asynchronous operations"
          ],
          "evaluationCriteria": [
            "Understanding of `allSettled`'s core functionality"
          ],
          "example": "",
          "tags": [
            "Promises",
            "allSettled",
            "Basic"
          ],
          "prerequisites": [
            "Promises"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_promise_combinators_2",
          "topic": "Promise.any",
          "level": "easy",
          "type": "flashcard",
          "question": "When does `Promise.any()` resolve?",
          "answer": "It resolves as soon as any of the input promises fulfills.",
          "analysisPoints": [
            "Emphasis on 'any' promise fulfilling.",
            "Contrast with `Promise.all` (all must fulfill)."
          ],
          "keyConcepts": [
            "Promise.any",
            "Promise fulfillment"
          ],
          "evaluationCriteria": [
            "Understanding of `any`'s success condition"
          ],
          "example": "",
          "tags": [
            "Promises",
            "any",
            "Basic"
          ],
          "prerequisites": [
            "Promises"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_promise_combinators_3",
          "topic": "Promise.allSettled vs Promise.all",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code snippet:\n\n```javascript\nconst p1 = Promise.resolve('Success 1');\nconst p2 = Promise.reject('Failure 2');\nconst p3 = new Promise(resolve => setTimeout(() => resolve('Success 3'), 100));\n\nPromise.allSettled([p1, p2, p3])\n  .then(results => {\n    // What will 'results' contain?\n    console.log(results);\n  })\n  .catch(err => console.log('Caught:', err));\n```\n\nWhich of the following best describes the `results` array logged to the console?",
          "answer": "[{status: 'fulfilled', value: 'Success 1'}, {status: 'rejected', reason: 'Failure 2'}, {status: 'fulfilled', value: 'Success 3'}]",
          "options": [
            "['Success 1', 'Failure 2', 'Success 3']",
            "['Success 1', undefined, 'Success 3']",
            "[{status: 'fulfilled', value: 'Success 1'}, {status: 'rejected', reason: 'Failure 2'}, {status: 'fulfilled', value: 'Success 3'}]",
            "The `.catch` block will be executed with 'Failure 2'."
          ],
          "analysisPoints": [
            "Tests understanding of `Promise.allSettled`'s return format (array of objects).",
            "Verifies knowledge that `allSettled` waits for all promises, even rejections.",
            "Distinguishes `allSettled` from `Promise.all`'s short-circuiting behavior.",
            "Checks understanding of 'status', 'value', and 'reason' properties."
          ],
          "keyConcepts": [
            "Promise.allSettled",
            "Promise states",
            "Error handling",
            "Promise combinators"
          ],
          "evaluationCriteria": [
            "Ability to predict `Promise.allSettled` output structure",
            "Understanding of promise resolution and rejection outcomes"
          ],
          "example": "The key here is that `Promise.allSettled` does not short-circuit on rejection like `Promise.all` does. It waits for every promise to finish, whether successfully or with an error, and provides a structured object for each result. So, `p2` will appear as `status: 'rejected'` with its `reason`, and `p1` and `p3` as `status: 'fulfilled'` with their `value`.",
          "tags": [
            "Promises",
            "allSettled",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "Promises",
            "Promise.all"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promise_combinators_4",
          "topic": "Promise.any vs Promise.race",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following promises:\n\n```javascript\nconst pA = new Promise((resolve) => setTimeout(() => resolve('A'), 100));\nconst pB = new Promise((_, reject) => setTimeout(() => reject('B'), 50));\nconst pC = new Promise((resolve) => setTimeout(() => resolve('C'), 200));\n\nPromise.any([pA, pB, pC])\n  .then(result => console.log('Any:', result))\n  .catch(err => console.log('Any Error:', err));\n```\n\nWhat will be logged to the console, and why?",
          "answer": "Any: A",
          "options": [
            "Any: A",
            "Any: B",
            "Any Error: AggregateError",
            "Any: C"
          ],
          "analysisPoints": [
            "Tests understanding that `Promise.any` resolves with the *first fulfilled* promise.",
            "Highlights that rejected promises are ignored by `Promise.any` unless *all* reject.",
            "Distinguishes `Promise.any` from `Promise.race` (which resolves/rejects with the first *settled* promise)."
          ],
          "keyConcepts": [
            "Promise.any",
            "Promise.race",
            "Promise fulfillment",
            "Promise rejection"
          ],
          "evaluationCriteria": [
            "Ability to differentiate `Promise.any` and `Promise.race` behavior.",
            "Correctly identifying the resolving promise based on timing and type."
          ],
          "example": "Although `pB` settles first (rejects after 50ms), `Promise.any` only cares about fulfillments. `pA` fulfills after 100ms, making it the first promise to fulfill among `pA` and `pC`. Therefore, `Promise.any` will resolve with the value from `pA`, which is 'A'.",
          "tags": [
            "Promises",
            "any",
            "race",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "Promises"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promise_combinators_5",
          "topic": "Promise.any Error Handling",
          "level": "hard",
          "type": "open",
          "question": "Describe the specific error handling mechanism of `Promise.any()`. What is the type of error it rejects with, and when does this rejection occur? How would you typically access the individual errors?",
          "answer": "If all promises in the iterable passed to `Promise.any()` reject, then `Promise.any()` rejects with an `AggregateError`. This special error class is a subclass of `Error` and contains an `errors` property, which is an array containing all the individual rejection reasons from the input promises. This rejection occurs only when every single promise in the input array has rejected. You would typically access the individual errors by catching the `AggregateError` and then iterating over its `errors` property.",
          "analysisPoints": [
            "Definition of `AggregateError`.",
            "Condition for `Promise.any` rejection (all promises reject).",
            "Accessing individual errors via the `errors` property.",
            "Comparison to other combinators' error handling."
          ],
          "keyConcepts": [
            "Promise.any",
            "AggregateError",
            "Error handling",
            "Promise rejection"
          ],
          "evaluationCriteria": [
            "Thorough understanding of `Promise.any`'s rejection behavior.",
            "Knowledge of `AggregateError` structure and usage.",
            "Ability to explain error handling implications."
          ],
          "example": "```javascript\nPromise.any([\n  Promise.reject('Error 1'),\n  Promise.reject(new Error('Error 2')),\n  Promise.reject('Error 3')\n])\n.then(val => console.log('Resolved:', val))\n.catch(err => {\n  console.error('All rejected:', err); // err will be an AggregateError\n  if (err instanceof AggregateError) {\n    err.errors.forEach((e, i) => {\n      console.error(`Individual Error ${i + 1}:`, e);\n    });\n  }\n});\n```",
          "tags": [
            "Promises",
            "any",
            "Error Handling",
            "Hard"
          ],
          "prerequisites": [
            "Promises",
            "Error Handling"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_await_1",
          "topic": "Async/Await Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What kind of value does an `async` function always return?",
          "answer": "An `async` function always returns a Promise.",
          "analysisPoints": [
            "Understanding the fundamental return type of async functions.",
            "Connecting `async/await` to Promises."
          ],
          "keyConcepts": [
            "async function",
            "Promise"
          ],
          "evaluationCriteria": [
            "Basic knowledge of async function return value"
          ],
          "example": "",
          "tags": [
            "Async/Await",
            "Promises",
            "Basic"
          ],
          "prerequisites": [
            "Promises"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_await_2",
          "topic": "Await Keyword",
          "level": "easy",
          "type": "flashcard",
          "question": "Where can the `await` keyword be used?",
          "answer": "The `await` keyword can only be used inside an `async` function.",
          "analysisPoints": [
            "Understanding the contextual restriction of `await`.",
            "Preventing common syntax errors."
          ],
          "keyConcepts": [
            "await keyword",
            "async function scope"
          ],
          "evaluationCriteria": [
            "Basic knowledge of `await` usage rules"
          ],
          "example": "",
          "tags": [
            "Async/Await",
            "Syntax",
            "Basic"
          ],
          "prerequisites": [
            "Async/Await"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_await_3",
          "topic": "Async/Await Error Handling",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `async` function:\n\n```javascript\nasync function getData() {\n  try {\n    const response = await fetch('https://invalid.url/api/data');\n    if (!response.ok) {\n      throw new Error('Network response was not ok.');\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error in getData:', error.message);\n    return null;\n  }\n}\n\n// What will be the output if the fetch fails (e.g., network error or 404 response)?\ndata.getData().then(result => console.log('Result:', result));\n```",
          "answer": "Error in getData: Network response was not ok. (or similar network error message)\nResult: null",
          "options": [
            "An unhandled promise rejection error.",
            "Error in getData: Network response was not ok. (or similar network error message)\nResult: null",
            "Result: undefined",
            "The `catch` block will not be executed for network errors."
          ],
          "analysisPoints": [
            "Tests understanding of `try...catch` within `async` functions for error handling.",
            "Covers both `fetch` network errors and explicit `throw new Error` for non-OK responses.",
            "Checks the function's return value in case of error (returning `null`)."
          ],
          "keyConcepts": [
            "Async/Await",
            "Error Handling",
            "try...catch",
            "Fetch API"
          ],
          "evaluationCriteria": [
            "Correct prediction of error flow in `async/await`.",
            "Understanding of how `await` propagates rejections as thrown errors.",
            "Handling of network and HTTP errors."
          ],
          "example": "The `try...catch` block effectively handles both network errors (which `fetch` itself will reject for) and errors explicitly thrown when `response.ok` is false. In either case, the `catch` block executes, logs the error message, and the function returns `null`, leading to 'Result: null' being logged.",
          "tags": [
            "Async/Await",
            "Error Handling",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "Promises",
            "Fetch API"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_await_4",
          "topic": "Sequential vs Parallel Async Execution",
          "level": "hard",
          "type": "code",
          "question": "You need to fetch data from three independent API endpoints: `/users`, `/products`, and `/orders`. Each API call takes a variable amount of time. You want to retrieve all data as quickly as possible. \n\nWrite an `async` function `fetchAllIndependentData` that performs these fetches in parallel and returns an object `{ users, products, orders }`. Include proper error handling for individual API failures, ensuring that if one API fails, the others still attempt to complete, but the main function eventually reflects the failure.\n\nUse mock `fetch` functions for `fetchUsers`, `fetchProducts`, and `fetchOrders` that return Promises resolving after a delay or rejecting randomly.\n\n```javascript\n// Mock API functions\nconst fetchUsers = () => new Promise(resolve => setTimeout(() => resolve(['User1', 'User2']), 500));\nconst fetchProducts = () => new Promise((_, reject) => setTimeout(() => reject(new Error('Product API failed')), 200)); // Simulates failure\nconst fetchOrders = () => new Promise(resolve => setTimeout(() => resolve(['OrderA', 'OrderB']), 800));\n\n// Your task: Implement this function\nasync function fetchAllIndependentData() {\n  // TODO: Implement parallel fetching with error handling\n  // Return { users, products, orders } or throw an AggregateError if all fail\n}\n\n// Expected usage:\nfetchAllIndependentData()\n  .then(data => console.log('All data fetched:', data))\n  .catch(error => {\n    console.error('Failed to fetch all data:', error);\n    if (error instanceof AggregateError) {\n      console.error('Individual errors:', error.errors);\n    }\n  });\n```",
          "answer": "```javascript\n// Mock API functions\nconst fetchUsers = () => new Promise(resolve => setTimeout(() => resolve(['User1', 'User2']), 500));\nconst fetchProducts = () => new Promise((_, reject) => setTimeout(() => reject(new Error('Product API failed')), 200)); // Simulates failure\nconst fetchOrders = () => new Promise(resolve => setTimeout(() => resolve(['OrderA', 'OrderB']), 800));\n\nasync function fetchAllIndependentData() {\n  try {\n    // Initiate all promises concurrently without awaiting immediately\n    const usersPromise = fetchUsers();\n    const productsPromise = fetchProducts();\n    const ordersPromise = fetchOrders();\n\n    // Use Promise.allSettled to wait for all to complete regardless of individual success/failure\n    const results = await Promise.allSettled([usersPromise, productsPromise, ordersPromise]);\n\n    const data = {};\n    const errors = [];\n\n    results.forEach((result, index) => {\n      if (result.status === 'fulfilled') {\n        if (index === 0) data.users = result.value;\n        else if (index === 1) data.products = result.value;\n        else if (index === 2) data.orders = result.value;\n      } else {\n        errors.push(result.reason);\n        // Optionally, assign default/null for failed categories\n        if (index === 0) data.users = null; \n        else if (index === 1) data.products = null;\n        else if (index === 2) data.orders = null;\n      }\n    });\n\n    if (errors.length > 0) {\n      // If there are any errors, we can throw an AggregateError to indicate partial failure\n      // or handle them gracefully based on specific requirements.\n      // For this problem, we'll throw to reflect failure.\n      throw new AggregateError(errors, 'One or more API calls failed');\n    }\n\n    return data;\n\n  } catch (error) {\n    // This catch block would primarily catch errors from Promise.allSettled itself (rare)\n    // or re-thrown errors like the AggregateError above.\n    console.error('Critical error in fetchAllIndependentData:', error);\n    throw error; // Re-throw for external handling\n  }\n}\n\n// Expected usage:\nfetchAllIndependentData()\n  .then(data => console.log('All data fetched:', data))\n  .catch(error => {\n    console.error('Failed to fetch all data:', error);\n    if (error instanceof AggregateError) {\n      console.error('Individual errors:', error.errors.map(e => e.message));\n    } else {\n      console.error('Unexpected error type:', error);\n    }\n  });\n\n/* Expected Output based on mocks:\nFailed to fetch all data: AggregateError: One or more API calls failed\nIndividual errors: [ 'Product API failed' ]\n*/\n```",
          "analysisPoints": [
            "Correctly uses `Promise.allSettled` for parallel execution and collection of all outcomes.",
            "Demonstrates handling of individual `fulfilled` and `rejected` statuses.",
            "Constructs a result object from successful fetches.",
            "Collects and potentially re-throws errors using `AggregateError` for comprehensive failure reporting.",
            "Distinguishes between starting promises concurrently and awaiting them."
          ],
          "keyConcepts": [
            "Async/Await",
            "Promise.allSettled",
            "Parallel Execution",
            "Error Handling",
            "AggregateError"
          ],
          "evaluationCriteria": [
            "Ability to implement parallel async operations.",
            "Proficiency in `Promise.allSettled` for robust error handling.",
            "Correctly aggregating and reporting individual errors.",
            "Adherence to desired output structure."
          ],
          "example": "",
          "tags": [
            "Async/Await",
            "Promise.allSettled",
            "Coding",
            "Hard",
            "Error Handling"
          ],
          "prerequisites": [
            "Promises",
            "Async/Await",
            "Promise.allSettled",
            "Error Handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_await_5",
          "topic": "Refactoring to Async/Await",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following Promise-based `fetchPostAndAuthor` function to use `async/await` syntax. Ensure the error handling logic remains the same (i.e., if either fetch fails, the main function should catch the error).",
          "answer": "```javascript\n// Original Promise-based function\nfunction fetchPostAndAuthorPromise(postId) {\n  let postData;\n  return fetch(`/api/posts/${postId}`)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return response.json();\n    })\n    .then(post => {\n      postData = post;\n      return fetch(`/api/authors/${post.authorId}`);\n    })\n    .then(response => {\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return response.json();\n    })\n    .then(author => {\n      return { ...postData, author };\n    })\n    .catch(error => {\n      console.error('Failed to fetch post or author:', error);\n      throw error; // Re-throw to propagate\n    });\n}\n\n// Refactored async/await function\nasync function fetchPostAndAuthorAsync(postId) {\n  try {\n    // Fetch post data\n    const postResponse = await fetch(`/api/posts/${postId}`);\n    if (!postResponse.ok) {\n      throw new Error(`HTTP error! status: ${postResponse.status}`);\n    }\n    const postData = await postResponse.json();\n\n    // Fetch author data using authorId from postData\n    const authorResponse = await fetch(`/api/authors/${postData.authorId}`);\n    if (!authorResponse.ok) {\n      throw new Error(`HTTP error! status: ${authorResponse.status}`);\n    }\n    const author = await authorResponse.json();\n\n    // Combine and return results\n    return { ...postData, author };\n  } catch (error) {\n    console.error('Failed to fetch post or author:', error);\n    throw error; // Re-throw to propagate\n  }\n}\n\n// Example Usage (assuming mock API endpoints)\nasync function runExamples() {\n  // Successful case\n  // Mock fetch responses for success\n  window.fetch = async (url) => {\n    if (url.includes('/api/posts/1')) {\n      return new Response(JSON.stringify({ id: 1, title: 'My Post', authorId: 101 }), { status: 200 });\n    } else if (url.includes('/api/authors/101')) {\n      return new Response(JSON.stringify({ id: 101, name: 'John Doe' }), { status: 200 });\n    }\n    return new Response('', { status: 404 });\n  };\n  \n  console.log('\\n--- Successful Fetch ---');\n  try {\n    const data = await fetchPostAndAuthorAsync(1);\n    console.log('Fetched data (success):', data);\n  } catch (e) {\n    console.error('Error during successful fetch:', e);\n  }\n\n  // Error case (post not found)\n  // Mock fetch responses for post not found\n  window.fetch = async (url) => {\n    if (url.includes('/api/posts/999')) {\n      return new Response('Not Found', { status: 404 });\n    } else if (url.includes('/api/authors/')) {\n      return new Response(JSON.stringify({ id: 101, name: 'John Doe' }), { status: 200 });\n    }\n    return new Response('', { status: 404 });\n  };\n\n  console.log('\\n--- Error Fetch (Post Not Found) ---');\n  try {\n    const data = await fetchPostAndAuthorAsync(999);\n    console.log('Fetched data (error):', data);\n  } catch (e) {\n    console.error('Error during failed fetch:', e.message);\n  }\n\n  // Error case (author not found)\n  // Mock fetch responses for author not found\n  window.fetch = async (url) => {\n    if (url.includes('/api/posts/2')) {\n      return new Response(JSON.stringify({ id: 2, title: 'Another Post', authorId: 999 }), { status: 200 });\n    } else if (url.includes('/api/authors/999')) {\n      return new Response('Not Found', { status: 404 });\n    }\n    return new Response('', { status: 404 });\n  };\n\n  console.log('\\n--- Error Fetch (Author Not Found) ---');\n  try {\n    const data = await fetchPostAndAuthorAsync(2);\n    console.log('Fetched data (error):', data);\n  } catch (e) {\n    console.error('Error during failed fetch:', e.message);\n  }\n}\n\n// Call the example runner\nrunExamples();\n```",
          "analysisPoints": [
            "Correctly wraps the function in `async`.",
            "Replaces `.then()` chains with `await` for sequential operations.",
            "Uses a single `try...catch` block to handle errors from any `await` call.",
            "Maintains the original error logging and re-throwing behavior.",
            "Demonstrates improved readability compared to chained promises."
          ],
          "keyConcepts": [
            "Async/Await",
            "Promises",
            "Refactoring",
            "Error Handling",
            "Sequential execution"
          ],
          "evaluationCriteria": [
            "Ability to convert Promise chains to `async/await`.",
            "Correct application of `try...catch` for error flow.",
            "Maintaining functional equivalence after refactoring."
          ],
          "example": "",
          "tags": [
            "Async/Await",
            "Refactoring",
            "Coding",
            "Medium"
          ],
          "prerequisites": [
            "Promises",
            "Async/Await"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_1",
          "topic": "Event Loop Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of the JavaScript Event Loop?",
          "answer": "To continuously monitor the Call Stack and task queues, and push functions from queues to the Call Stack when it's empty, allowing JavaScript to handle asynchronous operations.",
          "analysisPoints": [
            "Highlights the core function of the Event Loop.",
            "Mentions its role in managing async operations.",
            "Implies the single-threaded nature of JS execution."
          ],
          "keyConcepts": [
            "Event Loop",
            "Asynchronous JavaScript",
            "Call Stack",
            "Task Queue"
          ],
          "evaluationCriteria": [
            "Understanding of the Event Loop's fundamental purpose"
          ],
          "example": "",
          "tags": [
            "Event Loop",
            "Basic",
            "Concurrency"
          ],
          "prerequisites": [
            "Callbacks"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_loop_2",
          "topic": "Microtask vs Macrotask",
          "level": "medium",
          "type": "flashcard",
          "question": "Which queue (Microtask or Macrotask) does the Event Loop prioritize, and what are typical examples of each type of task?",
          "answer": "The Event Loop prioritizes the **Microtask Queue**. It processes all microtasks before moving to macrotasks in the next loop iteration. \n\n*   **Microtasks Examples**: Promise callbacks (`.then()`, `.catch()`, `.finally()`), `queueMicrotask`, `MutationObserver` callbacks.\n*   **Macrotasks Examples**: `setTimeout`, `setInterval`, I/O operations, UI rendering, `requestAnimationFrame`, `setImmediate` (Node.js specific).",
          "analysisPoints": [
            "Correctly identifies microtask queue priority.",
            "Provides accurate examples for both microtasks and macrotasks.",
            "Implies the 'run to completion' of microtasks before macrotasks."
          ],
          "keyConcepts": [
            "Microtask Queue",
            "Macrotask Queue",
            "Event Loop Priority",
            "Promises",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Knowledge of queue prioritization.",
            "Ability to categorize common async operations."
          ],
          "example": "",
          "tags": [
            "Event Loop",
            "Microtasks",
            "Macrotasks",
            "Medium"
          ],
          "prerequisites": [
            "Promises",
            "setTimeout"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_3",
          "topic": "Event Loop Output Prediction",
          "level": "hard",
          "type": "code",
          "question": "Predict the exact order of console outputs for the following JavaScript code snippet. Explain your reasoning based on the Event Loop mechanism, including the Call Stack, Web APIs, Microtask Queue, and Callback Queue.",
          "answer": "```javascript\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n  Promise.resolve().then(() => console.log('C'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('D');\n  setTimeout(() => console.log('E'), 0);\n});\n\nconsole.log('F');\n\n// Predicted Output:\n// A\n// F\n// D\n// C\n// B\n// E\n```\n\n**Reasoning:**\n\n1.  **Initial Execution (Synchronous)**:\n    *   `console.log('A')` runs immediately. Output: `A`.\n    *   `setTimeout` callback for 'B' is sent to Web APIs. After ~0ms, it's moved to the **Callback Queue**.\n    *   `Promise.resolve().then()` callback for 'D' is created. It's immediately moved to the **Microtask Queue**.\n    *   `console.log('F')` runs immediately. Output: `F`.\n    *   The Call Stack becomes empty.\n\n2.  **First Event Loop Turn - Microtask Phase**:\n    *   The Event Loop checks the Microtask Queue. It finds the callback for 'D'.\n    *   This callback is moved to the Call Stack.\n    *   `console.log('D')` executes. Output: `D`.\n    *   Inside this callback, `setTimeout` for 'E' is encountered. It's sent to Web APIs, then moved to the **Callback Queue** (at this point, the Callback Queue contains 'B', then 'E').\n    *   The callback for 'D' finishes. Call Stack is empty.\n\n3.  **First Event Loop Turn - Macrotask Phase**:\n    *   The Event Loop checks the Microtask Queue again (it's empty).\n    *   The Event Loop checks the Callback Queue. It takes the first item: the callback for 'B'.\n    *   This callback is moved to the Call Stack.\n    *   `console.log('B')` executes. Output: `B`.\n    *   Inside this callback, `Promise.resolve().then()` callback for 'C' is created. It's immediately moved to the **Microtask Queue**.\n    *   The callback for 'B' finishes. Call Stack is empty.\n\n4.  **Second Event Loop Turn - Microtask Phase**:\n    *   The Event Loop checks the Microtask Queue. It finds the callback for 'C'.\n    *   This callback is moved to the Call Stack.\n    *   `console.log('C')` executes. Output: `C`.\n    *   The callback for 'C' finishes. Call Stack is empty.\n\n5.  **Second Event Loop Turn - Macrotask Phase**:\n    *   The Event Loop checks the Microtask Queue again (it's empty).\n    *   The Event Loop checks the Callback Queue. It takes the next item: the callback for 'E'.\n    *   This callback is moved to the Call Stack.\n    *   `console.log('E')` executes. Output: `E`.\n    *   The callback for 'E' finishes. Call Stack is empty.\n\nThe Event Loop continues to run, but no more tasks are pending.",
          "options": [],
          "analysisPoints": [
            "Accurate identification of synchronous vs. asynchronous code execution.",
            "Correct understanding of `setTimeout` (macrotask) and `Promise.then` (microtask) queuing.",
            "Application of microtask queue priority (all microtasks before any macrotask).",
            "Ability to trace nested asynchronous operations and their impact on queue order.",
            "Detailed explanation of each step in the Event Loop cycle."
          ],
          "keyConcepts": [
            "Event Loop",
            "Microtask Queue",
            "Macrotask Queue",
            "Call Stack",
            "setTimeout",
            "Promises",
            "Execution Order"
          ],
          "evaluationCriteria": [
            "Precise prediction of output.",
            "Clear and comprehensive explanation of Event Loop mechanics.",
            "Demonstration of deep understanding of task prioritization.",
            "Ability to reason about complex asynchronous flows."
          ],
          "example": "",
          "tags": [
            "Event Loop",
            "Concurrency",
            "Coding",
            "Hard",
            "Debugging"
          ],
          "prerequisites": [
            "Promises",
            "setTimeout",
            "Event Loop Basics"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_promise_combinators_1",
          "title": "Robust Multi-Source Data Fetching (allSettled)",
          "description": "\nImplement an `async` function `fetchDataFromMultipleSources(urls)` that takes an array of URLs. This function should:\n\n1.  Initiate a `fetch` request for each URL in parallel.\n2.  Wait for all `fetch` requests to complete, regardless of whether they succeed or fail.\n3.  Return an array of objects, where each object represents the outcome of a single fetch. For successful fetches, include `status: 'fulfilled'` and the parsed JSON data (`value`). For failed fetches, include `status: 'rejected'` and the error object (`reason`).\n4.  Ensure that network errors (e.g., unreachable server) and HTTP errors (e.g., 404, 500) are correctly captured as `rejected` outcomes with their respective reasons.\n\nUse `Promise.allSettled` for this task. You can use a mock `fetch` function for testing.\n",
          "difficulty": "medium",
          "startingCode": "async function fetchDataFromMultipleSources(urls) {\n  // Mock fetch for testing purposes\n  const mockFetch = async (url) => {\n    console.log(`Attempting to fetch: ${url}`);\n    if (url.includes('success')) {\n      return new Response(JSON.stringify({ data: `${url}-data` }), { status: 200 });\n    } else if (url.includes('error')) {\n      return new Response('Not Found', { status: 404 });\n    } else if (url.includes('network-fail')) {\n      return Promise.reject(new TypeError('Failed to fetch (mock network error)'));\n    }\n    return new Response(JSON.stringify({ data: `${url}-default` }), { status: 200 });\n  };\n\n  // TODO: Implement the required functionality using Promise.allSettled\n\n  // Example structure for fetch calls:\n  // const promises = urls.map(url => mockFetch(url).then(res => {\n  //   if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);\n  //   return res.json();\n  // }));\n  // return await Promise.allSettled(promises);\n}\n\n// Example usage (for testing):\n// fetchDataFromMultipleSources([\n//   '/api/data/success1',\n//   '/api/data/error1',\n//   '/api/data/success2',\n//   '/api/data/network-fail1'\n// ]).then(results => {\n//   console.log('Final Results:', results);\n// });",
          "solutionCode": "async function fetchDataFromMultipleSources(urls) {\n  // Mock fetch for testing purposes\n  const mockFetch = async (url) => {\n    console.log(`Attempting to fetch: ${url}`);\n    return new Promise((resolve, reject) => {\n      if (url.includes('success')) {\n        setTimeout(() => resolve(new Response(JSON.stringify({ data: `${url}-data` }), { status: 200 })), Math.random() * 100 + 50);\n      } else if (url.includes('error')) {\n        setTimeout(() => resolve(new Response('Not Found', { status: 404 })), Math.random() * 100 + 50);\n      } else if (url.includes('network-fail')) {\n        setTimeout(() => reject(new TypeError('Failed to fetch (mock network error)')), Math.random() * 100 + 50);\n      } else {\n        setTimeout(() => resolve(new Response(JSON.stringify({ data: `${url}-default` }), { status: 200 })), Math.random() * 100 + 50);\n      }\n    });\n  };\n\n  const fetchPromises = urls.map(url => \n    mockFetch(url)\n      .then(response => {\n        if (!response.ok) {\n          // For HTTP errors (e.g., 404, 500), explicitly throw an Error\n          // so it gets caught by Promise.allSettled as a rejection.\n          return Promise.reject(new Error(`HTTP Error: ${response.status} ${response.statusText || response.url}`));\n        }\n        return response.json();\n      })\n      .catch(error => {\n        // Catch network errors or errors from .then() block, then re-throw\n        // or return a specific rejection reason for allSettled.\n        return Promise.reject(error);\n      })\n  );\n\n  return await Promise.allSettled(fetchPromises);\n}\n\n// Test Cases:\nasync function runTests() {\n  console.log('\\n--- Test Case 1: All Success ---');\n  let results1 = await fetchDataFromMultipleSources([\n    '/api/data/success1',\n    '/api/data/success2'\n  ]);\n  console.log('Results 1:', JSON.stringify(results1, null, 2));\n  /* Expected:\n  [\n    { status: 'fulfilled', value: { data: '/api/data/success1-data' } },\n    { status: 'fulfilled', value: { data: '/api/data/success2-data' } }\n  ]\n  */\n\n  console.log('\\n--- Test Case 2: Mixed Success and HTTP Error ---');\n  let results2 = await fetchDataFromMultipleSources([\n    '/api/data/success1',\n    '/api/data/error1' // Simulates 404\n  ]);\n  console.log('Results 2:', JSON.stringify(results2, null, 2));\n  /* Expected:\n  [\n    { status: 'fulfilled', value: { data: '/api/data/success1-data' } },\n    { status: 'rejected', reason: { message: 'HTTP Error: 404 ' } } // message property might vary based on mock\n  ]\n  */\n\n  console.log('\\n--- Test Case 3: Mixed Success and Network Error ---');\n  let results3 = await fetchDataFromMultipleSources([\n    '/api/data/success1',\n    '/api/data/network-fail1' // Simulates network error\n  ]);\n  console.log('Results 3:', JSON.stringify(results3, null, 2));\n  /* Expected:\n  [\n    { status: 'fulfilled', value: { data: '/api/data/success1-data' } },\n    { status: 'rejected', reason: { message: 'Failed to fetch (mock network error)' } } \n  ]\n  */\n\n  console.log('\\n--- Test Case 4: All Failures ---');\n  let results4 = await fetchDataFromMultipleSources([\n    '/api/data/error1',\n    '/api/data/network-fail1'\n  ]);\n  console.log('Results 4:', JSON.stringify(results4, null, 2));\n  /* Expected:\n  [\n    { status: 'rejected', reason: { message: 'HTTP Error: 404 ' } },\n    { status: 'rejected', reason: { message: 'Failed to fetch (mock network error)' } }\n  ]\n  */\n\n  console.log('\\n--- Test Case 5: Empty Array ---');\n  let results5 = await fetchDataFromMultipleSources([]);\n  console.log('Results 5:', JSON.stringify(results5, null, 2));\n  /* Expected:\n  []\n  */\n}\n\nrunTests();",
          "testCases": [
            "Test with all successful URLs.",
            "Test with a mix of successful and HTTP error (e.g., 404) URLs.",
            "Test with a mix of successful and network error URLs.",
            "Test with all failing URLs (both HTTP and network errors).",
            "Test with an empty array of URLs."
          ],
          "hints": [
            "Remember that `fetch` itself only rejects for network errors. For HTTP errors (like 404 or 500), `response.ok` will be `false`, and you'll need to explicitly `throw new Error()` inside the `.then()` block to trigger a rejection that `allSettled` can capture.",
            "`Promise.allSettled`'s return value directly provides the `status`, `value`, or `reason`.",
            "Map each URL to a promise that includes `.then()` for parsing JSON and handling `response.ok`, and a `.catch()` if needed to propagate network errors cleanly."
          ],
          "tags": [
            "Promises",
            "Promise.allSettled",
            "Fetch API",
            "Asynchronous Programming",
            "Error Handling",
            "Frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Promises",
            "Fetch API",
            "Promise.allSettled"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Promise Combinators",
            "Error Handling in Async",
            "Robust API Integration"
          ]
        },
        {
          "id": "task_promise_combinators_2",
          "title": "Fetch Fastest Data Source (any)",
          "description": "\nImplement an `async` function `fetchFirstSuccessfulData(urls)` that takes an array of URLs. This function should:\n\n1.  Initiate a `fetch` request for each URL in parallel.\n2.  Return the JSON data from the *first* `fetch` request that successfully resolves (HTTP status 200-299).\n3.  If all `fetch` requests fail (either network error or non-OK HTTP status), the function should throw an `AggregateError` containing all the individual rejection reasons.\n\nUse `Promise.any` for this task. You can use a mock `fetch` function for testing.\n",
          "difficulty": "medium",
          "startingCode": "async function fetchFirstSuccessfulData(urls) {\n  // Mock fetch for testing purposes\n  const mockFetch = async (url) => {\n    console.log(`Attempting to fetch: ${url}`);\n    return new Promise((resolve, reject) => {\n      if (url.includes('fast-success')) {\n        setTimeout(() => resolve(new Response(JSON.stringify({ data: `${url}-data` }), { status: 200 })), 50);\n      } else if (url.includes('slow-success')) {\n        setTimeout(() => resolve(new Response(JSON.stringify({ data: `${url}-data` }), { status: 200 })), 500);\n      } else if (url.includes('http-error')) {\n        setTimeout(() => resolve(new Response('Forbidden', { status: 403 })), 100);\n      } else if (url.includes('network-fail')) {\n        setTimeout(() => reject(new TypeError('Failed to fetch (mock network error)')), 20);\n      }\n    });\n  };\n\n  // TODO: Implement the required functionality using Promise.any\n\n  // Example structure for fetch calls:\n  // const promises = urls.map(url => mockFetch(url).then(res => {\n  //   if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);\n  //   return res.json();\n  // }));\n  // return await Promise.any(promises);\n}\n\n// Example usage (for testing):\n// fetchFirstSuccessfulData([\n//   '/api/data/slow-success',\n//   '/api/data/fast-success',\n//   '/api/data/http-error'\n// ]).then(result => {\n//   console.log('First successful data:', result);\n// }).catch(error => {\n//   console.error('All sources failed:', error.errors.map(e => e.message));\n// });",
          "solutionCode": "async function fetchFirstSuccessfulData(urls) {\n  // Mock fetch for testing purposes\n  const mockFetch = async (url) => {\n    console.log(`Attempting to fetch: ${url}`);\n    return new Promise((resolve, reject) => {\n      if (url.includes('fast-success')) {\n        setTimeout(() => resolve(new Response(JSON.stringify({ data: `${url}-data` }), { status: 200 })), 50);\n      } else if (url.includes('slow-success')) {\n        setTimeout(() => resolve(new Response(JSON.stringify({ data: `${url}-data` }), { status: 200 })), 500);\n      } else if (url.includes('http-error')) {\n        setTimeout(() => resolve(new Response('Forbidden', { status: 403 })), 100); // Resolves, but not .ok\n      } else if (url.includes('network-fail')) {\n        setTimeout(() => reject(new TypeError('Failed to fetch (mock network error)')), 20);\n      } else {\n        setTimeout(() => resolve(new Response(JSON.stringify({ data: `${url}-default` }), { status: 200 })), 150);\n      }\n    });\n  };\n\n  const fetchPromises = urls.map(url => \n    mockFetch(url)\n      .then(response => {\n        if (!response.ok) {\n          // For HTTP errors, make sure it rejects so Promise.any considers it a failure\n          return Promise.reject(new Error(`HTTP Error: ${response.status} ${response.statusText || response.url}`));\n        }\n        return response.json();\n      })\n      .catch(error => {\n        // Catch network errors and re-throw to ensure Promise.any sees it as a rejection\n        return Promise.reject(error);\n      })\n  );\n\n  try {\n    return await Promise.any(fetchPromises);\n  } catch (error) {\n    // Promise.any rejects with AggregateError if all input promises reject\n    throw error; // Re-throw the AggregateError for the caller to handle\n  }\n}\n\n// Test Cases:\nasync function runTests() {\n  console.log('\\n--- Test Case 1: First is Fast Success ---');\n  try {\n    let result1 = await fetchFirstSuccessfulData([\n      '/api/data/slow-success',\n      '/api/data/fast-success',\n      '/api/data/http-error'\n    ]);\n    console.log('Result 1:', result1);\n  } catch (e) { console.error('Error 1:', e); }\n  /* Expected: Result 1: { data: '/api/data/fast-success-data' } */\n\n  console.log('\\n--- Test Case 2: All Failures ---');\n  try {\n    let result2 = await fetchFirstSuccessfulData([\n      '/api/data/http-error-1',\n      '/api/data/network-fail-1',\n      '/api/data/http-error-2'\n    ]);\n    console.log('Result 2:', result2);\n  } catch (e) {\n    console.error('Error 2 (All Failed):', e.errors.map(err => err.message));\n  }\n  /* Expected: Error 2 (All Failed): [ 'HTTP Error: 403 ', 'Failed to fetch (mock network error)', 'HTTP Error: 403 ' ] */\n\n  console.log('\\n--- Test Case 3: Empty Array ---');\n  try {\n    let result3 = await fetchFirstSuccessfulData([]);\n    console.log('Result 3:', result3);\n  } catch (e) { \n    console.error('Error 3 (Empty Array):', e.message); \n  }\n  /* Expected: Error 3 (Empty Array): No promises in Promise.any */\n\n  console.log('\\n--- Test Case 4: One Success, others fail slowly ---');\n  try {\n    let result4 = await fetchFirstSuccessfulData([\n      '/api/data/network-fail-20ms',\n      '/api/data/slow-success-500ms',\n      '/api/data/http-error-100ms'\n    ]);\n    console.log('Result 4:', result4);\n  } catch (e) { console.error('Error 4:', e); }\n  /* Expected: Result 4: { data: '/api/data/slow-success-500ms-data' } */\n}\n\nrunTests();\n",
          "testCases": [
            "Test where the fastest promise is a success.",
            "Test where all promises fail (mix of HTTP errors and network errors).",
            "Test with an empty array of URLs.",
            "Test where a fast-rejecting promise exists, but a slower-resolving promise eventually succeeds.",
            "Test where the first promise to settle is a rejection, but a later promise succeeds."
          ],
          "hints": [
            "`Promise.any` only considers 'fulfilled' promises for resolution. If `fetch` returns a non-`ok` response (like 404 or 500), that's technically a 'resolved' promise for `fetch` itself, but you need to explicitly `throw` an error for `Promise.any` to treat it as a rejection.",
            "Remember to transform the `Response` object into actual JSON data.",
            "The `.catch` block of `Promise.any` will receive an `AggregateError` when all promises reject. You'll need to unpack its `errors` property."
          ],
          "tags": [
            "Promises",
            "Promise.any",
            "Fetch API",
            "Asynchronous Programming",
            "Error Handling",
            "Frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Promises",
            "Fetch API",
            "Promise.any"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Promise Combinators",
            "Race Conditions",
            "Error Handling in Async"
          ]
        },
        {
          "id": "task_async_await_1",
          "title": "Sequential API Calls with Chained Dependencies",
          "description": "\nImplement an `async` function `fetchUserProfileAndDetails(userId)` that fetches user profile information and then uses data from the profile (specifically, a `detailsId`) to fetch additional user details. Both API calls are dependent on each other, meaning the second call cannot start until the first one successfully completes.\n\nYour function should:\n\n1.  Fetch user profile data from `/api/users/:userId`.\n2.  Extract `detailsId` from the fetched profile.\n3.  Fetch user details from `/api/user-details/:detailsId`.\n4.  Combine the profile and details into a single object `{ ...profileData, details: detailsData }` and return it.\n5.  Implement robust error handling using `try...catch`. If any `fetch` call fails (network error or non-OK HTTP status), log the error and re-throw it to the caller.\n\nUse the provided mock `fetch` helper for testing.\n",
          "difficulty": "medium",
          "startingCode": "const mockFetch = async (url) => {\n  console.log(`Mock Fetching: ${url}`);\n  return new Promise((resolve, reject) => {\n    if (url.includes('/api/users/1')) {\n      setTimeout(() => resolve(new Response(JSON.stringify({ id: 1, name: 'Alice', detailsId: 'abc' }), { status: 200 })), 100);\n    } else if (url.includes('/api/user-details/abc')) {\n      setTimeout(() => resolve(new Response(JSON.stringify({ age: 30, city: 'New York' }), { status: 200 })), 150);\n    } else if (url.includes('/api/users/invalid')) {\n      setTimeout(() => resolve(new Response('User Not Found', { status: 404 })), 50);\n    } else if (url.includes('/api/user-details/invalid')) {\n      setTimeout(() => resolve(new Response('Details Not Found', { status: 404 })), 50);\n    } else if (url.includes('network-fail')) {\n      setTimeout(() => reject(new TypeError('Mock network error')), 20);\n    }\n    else {\n      setTimeout(() => reject(new Error('Unknown URL')), 10);\n    }\n  });\n};\n\nasync function fetchUserProfileAndDetails(userId) {\n  // TODO: Implement sequential fetches with error handling\n}\n\n// Example usage (for testing):\n// fetchUserProfileAndDetails(1)\n//   .then(data => console.log('Successfully fetched:', data))\n//   .catch(error => console.error('Failed to fetch user data:', error.message));\n",
          "solutionCode": "const mockFetch = async (url) => {\n  console.log(`Mock Fetching: ${url}`);\n  return new Promise((resolve, reject) => {\n    if (url.includes('/api/users/1')) {\n      setTimeout(() => resolve(new Response(JSON.stringify({ id: 1, name: 'Alice', detailsId: 'abc' }), { status: 200 })), 100);\n    } else if (url.includes('/api/user-details/abc')) {\n      setTimeout(() => resolve(new Response(JSON.stringify({ age: 30, city: 'New York' }), { status: 200 })), 150);\n    } else if (url.includes('/api/users/invalid')) {\n      setTimeout(() => resolve(new Response('User Not Found', { status: 404 })), 50);\n    } else if (url.includes('/api/user-details/invalid')) {\n      setTimeout(() => resolve(new Response('Details Not Found', { status: 404 })), 50);\n    } else if (url.includes('network-fail')) {\n      setTimeout(() => reject(new TypeError('Mock network error')), 20);\n    }\n    else {\n      setTimeout(() => reject(new Error('Unknown URL')), 10);\n    }\n  });\n};\n\nasync function fetchUserProfileAndDetails(userId) {\n  try {\n    // 1. Fetch user profile\n    const userProfileResponse = await mockFetch(`/api/users/${userId}`);\n    if (!userProfileResponse.ok) {\n      throw new Error(`HTTP Error fetching profile: ${userProfileResponse.status} ${userProfileResponse.statusText || userProfileResponse.url}`);\n    }\n    const userProfile = await userProfileResponse.json();\n\n    // Check if detailsId exists before attempting to fetch details\n    if (!userProfile.detailsId) {\n      // Handle case where user might not have details (e.g., return profile only or throw specific error)\n      console.warn(`User ${userId} has no detailsId.`);\n      return { ...userProfile, details: null }; \n    }\n\n    // 2. Fetch user details using detailsId\n    const userDetailsResponse = await mockFetch(`/api/user-details/${userProfile.detailsId}`);\n    if (!userDetailsResponse.ok) {\n      throw new Error(`HTTP Error fetching details: ${userDetailsResponse.status} ${userDetailsResponse.statusText || userDetailsResponse.url}`);\n    }\n    const userDetails = await userDetailsResponse.json();\n\n    // 3. Combine and return\n    return { ...userProfile, details: userDetails };\n\n  } catch (error) {\n    console.error(`Failed to fetch user profile or details for userId ${userId}:`, error.message);\n    throw error; // Re-throw to propagate the error to the caller\n  }\n}\n\n// Test Cases:\nasync function runTests() {\n  console.log('\\n--- Test Case 1: Successful Fetch ---');\n  try {\n    const data = await fetchUserProfileAndDetails(1);\n    console.log('Test 1 Result (Success):', data);\n  } catch (e) {\n    console.error('Test 1 Error:', e.message);\n  }\n  /* Expected:\n  Test 1 Result (Success): { id: 1, name: 'Alice', detailsId: 'abc', details: { age: 30, city: 'New York' } }\n  */\n\n  console.log('\\n--- Test Case 2: Profile Not Found (404) ---');\n  try {\n    const data = await fetchUserProfileAndDetails('invalid');\n    console.log('Test 2 Result (Should not be here):', data);\n  } catch (e) {\n    console.error('Test 2 Error (Profile Not Found):', e.message);\n  }\n  /* Expected: Test 2 Error (Profile Not Found): HTTP Error fetching profile: 404 User Not Found */\n\n  console.log('\\n--- Test Case 3: Details Not Found (404) ---');\n  // To simulate this, we need a profile that returns a valid detailsId but the details endpoint fails\n  // Temporarily adjust mock fetch for this specific test\n  const originalMockFetch = global.mockFetch;\n  global.mockFetch = async (url) => {\n    if (url.includes('/api/users/2')) {\n      return new Response(JSON.stringify({ id: 2, name: 'Bob', detailsId: 'invalid-details' }), { status: 200 });\n    } else if (url.includes('/api/user-details/invalid-details')) {\n      return new Response('Details Not Found', { status: 404 });\n    } else {\n      return originalMockFetch(url); // Fallback to original mock for other calls\n    }\n  };\n  try {\n    const data = await fetchUserProfileAndDetails(2);\n    console.log('Test 3 Result (Should not be here):', data);\n  } catch (e) {\n    console.error('Test 3 Error (Details Not Found):', e.message);\n  } finally {\n    global.mockFetch = originalMockFetch; // Restore original mock\n  }\n  /* Expected: Test 3 Error (Details Not Found): HTTP Error fetching details: 404 Details Not Found */\n\n  console.log('\\n--- Test Case 4: Network Error during Profile Fetch ---');\n  try {\n    const data = await fetchUserProfileAndDetails('network-fail');\n    console.log('Test 4 Result (Should not be here):', data);\n  } catch (e) {\n    console.error('Test 4 Error (Network Failure):', e.message);\n  }\n  /* Expected: Test 4 Error (Network Failure): Mock network error */\n\n  console.log('\\n--- Test Case 5: User with no detailsId ---');\n  // Mock fetch responses for user with no detailsId\n  const originalMockFetch2 = global.mockFetch;\n  global.mockFetch = async (url) => {\n    if (url.includes('/api/users/no-details')) {\n      return new Response(JSON.stringify({ id: 'no-details', name: 'Charlie', detailsId: null }), { status: 200 });\n    }\n    return originalMockFetch2(url); \n  };\n  try {\n    const data = await fetchUserProfileAndDetails('no-details');\n    console.log('Test 5 Result (No Details):', data);\n  } catch (e) {\n    console.error('Test 5 Error:', e.message);\n  } finally {\n    global.mockFetch = originalMockFetch2;\n  }\n  /* Expected: Test 5 Result (No Details): { id: 'no-details', name: 'Charlie', detailsId: null, details: null } */\n}\n\n// Make mockFetch globally available for testing context\nglobal.mockFetch = mockFetch;\n\nrunTests();",
          "testCases": [
            "Successful fetch of both profile and details.",
            "Profile fetch fails with a 404 (or other HTTP error).",
            "Profile fetch succeeds, but details fetch fails with a 404.",
            "Network error during the initial profile fetch.",
            "Network error during the details fetch.",
            "Edge case: User profile is found but has no `detailsId` (should gracefully handle this)."
          ],
          "hints": [
            "Remember that `await` pauses execution until the promise resolves or rejects. Use it sequentially for dependent calls.",
            "Error handling with `try...catch` works for any `await` operation that results in a rejected promise (either by network error or explicit `throw`).",
            "Make sure to check `response.ok` after each `await fetch` call and `throw` an `Error` if it's `false`."
          ],
          "tags": [
            "Async/Await",
            "Sequential Fetch",
            "API Integration",
            "Error Handling",
            "Frontend"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Async/Await",
            "Promises",
            "Fetch API",
            "Error Handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Asynchronous Programming Patterns",
            "API Chaining",
            "Data Transformation"
          ]
        },
        {
          "id": "task_event_loop_1",
          "title": "Event Loop Puzzle: Predict Output and Explain",
          "description": "\nGiven the JavaScript code snippet below, predict the exact order of outputs to the console. After predicting, provide a step-by-step explanation of how the JavaScript Event Loop processes this code, detailing the roles of the Call Stack, Web APIs, Microtask Queue, and Callback Queue at each stage.\n\n```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n  Promise.resolve().then(() => console.log('Promise 2'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n  setTimeout(() => console.log('Timeout 2'), 0);\n});\n\nconsole.log('End');\n```\n\nYour explanation should clearly justify the predicted order based on Event Loop rules.\n",
          "difficulty": "hard",
          "startingCode": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n  Promise.resolve().then(() => console.log('Promise 2'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n  setTimeout(() => console.log('Timeout 2'), 0);\n});\n\nconsole.log('End');\n\n// TODO: Predict the output order and write your explanation below.\n// Predicted Output:\n// Your Explanation:\n",
          "solutionCode": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n  Promise.resolve().then(() => console.log('Promise 2'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n  setTimeout(() => console.log('Timeout 2'), 0);\n});\n\nconsole.log('End');\n\n// Predicted Output:\n// Start\n// End\n// Promise 1\n// Promise 2\n// Timeout 1\n// Timeout 2\n\n/*\nExplanation:\n\n1.  **Initial Synchronous Execution (Call Stack)**:\n    *   `console.log('Start')` is executed. Output: `Start`.\n    *   `setTimeout` callback (`() => { console.log('Timeout 1'); ... }`) is passed to Web APIs. After 0ms, it's moved to the **Callback Queue**.\n    *   `Promise.resolve().then()` callback (`() => { console.log('Promise 1'); ... }`) is created. It's immediately moved to the **Microtask Queue**.\n    *   `console.log('End')` is executed. Output: `End`.\n    *   The Call Stack becomes empty.\n\n    *Current State:* \n    *   Call Stack: Empty\n    *   Microtask Queue: `[Promise 1's callback]`\n    *   Callback Queue: `[Timeout 1's callback]`\n\n2.  **First Event Loop Turn - Microtask Phase**:\n    *   The Event Loop sees the Call Stack is empty. It checks the Microtask Queue. It finds 'Promise 1's callback'.\n    *   'Promise 1's callback' is moved to the Call Stack.\n    *   `console.log('Promise 1')` executes. Output: `Promise 1`.\n    *   Inside 'Promise 1's callback', `setTimeout` for 'Timeout 2' is encountered. It's passed to Web APIs, then moved to the **Callback Queue**.\n    *   'Promise 1's callback' finishes. Call Stack is empty.\n\n    *Current State:* \n    *   Call Stack: Empty\n    *   Microtask Queue: `[]`\n    *   Callback Queue: `[Timeout 1's callback, Timeout 2's callback]`\n\n3.  **First Event Loop Turn - Macrotask Phase**:\n    *   The Event Loop sees the Call Stack is empty. It checks the Microtask Queue (it's empty).\n    *   It checks the Callback Queue. It takes the first item: 'Timeout 1's callback'.\n    *   'Timeout 1's callback' is moved to the Call Stack.\n    *   `console.log('Timeout 1')` executes. Output: `Timeout 1`.\n    *   Inside 'Timeout 1's callback', `Promise.resolve().then()` callback for 'Promise 2' is created. It's immediately moved to the **Microtask Queue**.\n    *   'Timeout 1's callback' finishes. Call Stack is empty.\n\n    *Current State:* \n    *   Call Stack: Empty\n    *   Microtask Queue: `[Promise 2's callback]`\n    *   Callback Queue: `[Timeout 2's callback]`\n\n4.  **Second Event Loop Turn - Microtask Phase**:\n    *   The Event Loop sees the Call Stack is empty. It checks the Microtask Queue. It finds 'Promise 2's callback'.\n    *   'Promise 2's callback' is moved to the Call Stack.\n    *   `console.log('Promise 2')` executes. Output: `Promise 2`.\n    *   'Promise 2's callback' finishes. Call Stack is empty.\n\n    *Current State:* \n    *   Call Stack: Empty\n    *   Microtask Queue: `[]`\n    *   Callback Queue: `[Timeout 2's callback]`\n\n5.  **Second Event Loop Turn - Macrotask Phase**:\n    *   The Event Loop sees the Call Stack is empty. It checks the Microtask Queue (it's empty).\n    *   It checks the Callback Queue. It takes the next item: 'Timeout 2's callback'.\n    *   'Timeout 2's callback' is moved to the Call Stack.\n    *   `console.log('Timeout 2')` executes. Output: `Timeout 2`.\n    *   'Timeout 2's callback' finishes. Call Stack is empty.\n\n    *Current State:* \n    *   Call Stack: Empty\n    *   Microtask Queue: `[]`\n    *   Callback Queue: `[]`\n\nThe Event Loop continues its cycle, but there are no more tasks.\n*/\n",
          "testCases": [
            "Predict output and provide step-by-step Event Loop explanation."
          ],
          "hints": [
            "Start by identifying all synchronous operations.",
            "Then, identify all `setTimeout` calls (macrotasks) and `Promise.then` calls (microtasks).",
            "Trace how each task is placed into its respective queue (Web APIs -> Queue).",
            "Remember the Event Loop's priority: complete all microtasks from the current cycle before moving to the next macrotask."
          ],
          "tags": [
            "Event Loop",
            "Concurrency",
            "Execution Order",
            "Debugging",
            "JavaScript Fundamentals"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Event Loop Basics",
            "Promises",
            "setTimeout"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Call Stack",
            "Microtask Queue",
            "Macrotask Queue",
            "Asynchronous Programming"
          ]
        }
      ]
    }
  },
  {
    "id": "fac2bbd6-07b6-4fa0-8d23-f952c04b99e8",
    "startLine": 1700,
    "endLine": 1799,
    "processedDate": "2025-06-17T07:59:23.607Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_event_loop_async",
          "title": "Asynchronous JavaScript and the Event Loop",
          "content": "JavaScript is a single-threaded, non-blocking, asynchronous, concurrent language. This means it has one call stack and executes one thing at a time. To handle operations that take time (like network requests, timers, or user interactions) without blocking the main thread, JavaScript uses the Event Loop.\n\n### Call Stack\nThis is where synchronous code is executed. Functions are pushed onto the stack when called and popped off when they return.\n\n### Web APIs\nBrowser provides Web APIs (e.g., `setTimeout`, `DOM events`, `fetch`) that JavaScript can interact with. When these APIs are called, they move the operation out of the call stack and handle it asynchronously.\n\n### Callback Queue (Macrotask Queue)\nAfter a Web API completes its operation (e.g., `setTimeout` timer expires, `fetch` request resolves), its callback function is moved to the Callback Queue. Examples of macrotasks include `setTimeout`, `setInterval`, `setImmediate` (Node.js), I/O operations.\n\n### Microtask Queue\nThis queue has higher priority than the Callback Queue. Callbacks for Promises (`.then()`, `.catch()`, `.finally()`) and `MutationObserver` are placed in the Microtask Queue. The Event Loop checks and empties the Microtask Queue *before* checking the Macrotask Queue after each tick of the call stack.\n\n### Event Loop\nThe Event Loop constantly monitors the Call Stack and the queues. If the Call Stack is empty, it first checks the Microtask Queue and pushes any tasks from it to the Call Stack. Once the Microtask Queue is empty, it then checks the Callback Queue (Macrotask Queue) and pushes the first task from it to the Call Stack. This process repeats, allowing asynchronous operations to be handled without blocking the main thread.\n\n**Execution Order Summary:**\n1.  All synchronous code in the Call Stack runs to completion.\n2.  The Event Loop checks and executes all tasks in the Microtask Queue.\n3.  The Event Loop checks and executes one task from the Macrotask Queue.\n4.  Steps 2 and 3 repeat.",
          "examples": [
            {
              "id": "example_event_loop_1",
              "title": "Promise and setTimeout Execution Order",
              "code": "console.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n}).then(() => {\n  console.log('Promise 2');\n});\n\nconsole.log('Script end');\n\n// Output:\n// Script start\n// Script end\n// Promise 1\n// Promise 2\n// setTimeout",
              "explanation": "1.  `console.log('Script start')` runs immediately (synchronous).\n2.  `setTimeout` callback is sent to Web APIs, then pushed to the Macrotask Queue after 0ms.\n3.  `Promise.resolve().then()` callback is sent to Web APIs, then pushed to the Microtask Queue.\n4.  `console.log('Script end')` runs immediately (synchronous).\n5.  Synchronous code finishes. The Call Stack is empty.\n6.  The Event Loop checks the Microtask Queue: `Promise 1` callback is found and executed.\n7.  The second `.then()` (for `Promise 2`) is then pushed to the Microtask Queue.\n8.  The Event Loop checks the Microtask Queue again: `Promise 2` callback is found and executed.\n9.  Microtask Queue is empty. The Event Loop checks the Macrotask Queue: `setTimeout` callback is found and executed.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_event_loop_1",
            "question_event_loop_2",
            "question_event_loop_3",
            "question_event_loop_4",
            "question_event_loop_5"
          ],
          "relatedTasks": [
            "task_event_loop_1"
          ],
          "tags": [
            "JavaScript",
            "Asynchronous",
            "Event Loop",
            "Promises",
            "setTimeout",
            "Microtasks",
            "Macrotasks"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Basic JavaScript Syntax",
            "Functions",
            "Callbacks"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced Asynchronous Patterns",
            "Node.js Concurrency",
            "Frontend Performance Optimization"
          ]
        },
        {
          "id": "theory_event_propagation",
          "title": "Event Bubbling and Capturing",
          "content": "Event propagation describes the order in which events are handled on elements nested within each other in the DOM tree. When an event occurs on an element, it doesn't just trigger handlers on that element; it also propagates through its ancestors.\n\nThere are three distinct phases in the event flow:\n\n1.  **Capturing Phase (Trickle Down)**: The event starts from the `window` object, then travels down through the document root (`document`) and its descendants, reaching the target element's parent before finally reaching the target element itself. During this phase, listeners registered with `useCapture: true` (or the third parameter set to `true`) will be triggered.\n\n2.  **Target Phase**: The event reaches the actual element on which the event occurred (the `e.target`). Listeners on this element are executed.\n\n3.  **Bubbling Phase (Bubble Up)**: After the event reaches the target, it then bubbles up from the target element back up to the `window` object, traversing through its ancestors. During this phase, listeners registered with `useCapture: false` (or the third parameter omitted, as `false` is the default) will be triggered.\n\n### `addEventListener` Third Parameter\n\nThe `addEventListener(type, listener, options)` method's third parameter (`options` or `useCapture`) determines which phase the listener will be active in:\n\n*   `false` (default): The event listener is triggered during the **bubbling phase**.\n*   `true`: The event listener is triggered during the **capturing phase**.\n\nIt's important to understand this flow, especially when dealing with nested elements and event delegation.",
          "examples": [
            {
              "id": "example_event_propagation_1",
              "title": "Demonstrating Bubbling and Capturing",
              "code": "<!-- HTML Structure for example -->\n<div id=\"parent\" style=\"border: 1px solid blue; padding: 20px;\">\n  Parent\n  <button id=\"child\" style=\"margin: 10px; padding: 10px;\">Child Button</button>\n</div>\n\n// JavaScript\ndocument.getElementById('parent').addEventListener('click', function(e) {\n  console.log('Parent clicked - bubbling phase');\n}, false); // Bubbling\n\ndocument.getElementById('child').addEventListener('click', function(e) {\n  console.log('Child clicked - bubbling phase');\n}, false); // Bubbling\n\ndocument.getElementById('parent').addEventListener('click', function(e) {\n  console.log('Parent clicked - capturing phase');\n}, true); // Capturing\n\ndocument.getElementById('child').addEventListener('click', function(e) {\n  console.log('Child clicked - capturing phase');\n}, true); // Capturing\n\n// If 'Child Button' is clicked, the output will be:\n// Parent clicked - capturing phase (due to event traveling down to child)\n// Child clicked - capturing phase (due to event reaching child in capturing phase)\n// Child clicked - bubbling phase (due to event reaching child in bubbling phase)\n// Parent clicked - bubbling phase (due to event bubbling up from child to parent)",
              "explanation": "When the 'Child Button' is clicked, the event first travels down the DOM tree (capturing phase). The `parent` element's capturing listener triggers. Then, the event reaches the `child` element, and its capturing listener triggers. After the target phase (where any non-phase-specific listeners on the child would run), the event bubbles up. The `child` element's bubbling listener triggers, and finally, the `parent` element's bubbling listener triggers.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_event_propagation_1",
            "question_event_propagation_2",
            "question_event_propagation_3",
            "question_event_propagation_4",
            "question_event_propagation_5"
          ],
          "relatedTasks": [
            "task_event_propagation_1"
          ],
          "tags": [
            "DOM Events",
            "Event Propagation",
            "Bubbling",
            "Capturing",
            "addEventListener"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "HTML DOM Structure",
            "JavaScript Functions",
            "Event Handling Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Event Delegation",
            "Custom Event Systems",
            "Understanding Browser Behavior"
          ]
        },
        {
          "id": "theory_event_control",
          "title": "Controlling Event Propagation",
          "content": "While event bubbling and capturing provide a powerful mechanism for event handling, sometimes you need to halt or modify the default event flow. JavaScript provides methods on the `Event` object for this purpose.\n\n### `event.stopPropagation()`\n\nThis method prevents the event from propagating further up or down the DOM tree. If called during the capturing phase, it stops further capturing listeners from being triggered on ancestor elements. If called during the bubbling phase, it prevents the event from bubbling up to parent elements.\n\n**Important**: `stopPropagation()` *does not* prevent other event listeners attached to the *same element* from firing. It only stops the event from moving to the next element in the propagation path.\n\n### `event.stopImmediatePropagation()`\n\nThis method is more aggressive than `stopPropagation()`. It not only prevents the event from propagating further up or down the DOM tree but also prevents any other event listeners attached to the *same element* from being executed. If multiple listeners are attached to a single element for the same event type, and one of them calls `stopImmediatePropagation()`, subsequent listeners on that element will not run.\n\n### `event.preventDefault()`\n\nThis method prevents the default action that the browser would normally take in response to an event. For example:\n\n*   Clicking an `<a>` tag normally navigates to the `href` URL.\n*   Submitting a `<form>` normally reloads the page.\n*   Clicking a checkbox normally toggles its checked state.\n\n`preventDefault()` will stop these default actions. Crucially, `preventDefault()` *does not* stop the event from bubbling or capturing. The event will continue its propagation through the DOM tree, and other listeners will still fire, but the browser's default behavior for that specific event type will be suppressed.",
          "examples": [
            {
              "id": "example_event_control_1",
              "title": "Using stopPropagation()",
              "code": "<!-- HTML Structure -->\n<div id=\"parent\" style=\"border: 1px solid blue; padding: 20px;\">\n  Parent\n  <button id=\"child\" style=\"margin: 10px; padding: 10px;\">Child Button</button>\n</div>\n\n// JavaScript\ndocument.getElementById('parent').addEventListener('click', function(e) {\n  console.log('Parent clicked - bubbling phase');\n}, false);\n\ndocument.getElementById('child').addEventListener('click', function(e) {\n  e.stopPropagation();\n  console.log('Child clicked - event will not bubble to parent');\n});\n\n// If 'Child Button' is clicked, output:\n// Child clicked - event will not bubble to parent\n// (Parent's bubbling listener will NOT fire)",
              "explanation": "When the child button is clicked, its listener executes and calls `e.stopPropagation()`. This prevents the click event from bubbling up to the parent element, so the parent's click listener for the bubbling phase is never triggered.",
              "language": "typescript"
            },
            {
              "id": "example_event_control_2",
              "title": "Using stopImmediatePropagation()",
              "code": "<!-- HTML Structure (same as above) -->\n<div id=\"child\" style=\"border: 1px solid green; padding: 20px;\">Child</div>\n\n// JavaScript\ndocument.getElementById('child').addEventListener('click', function(e) {\n  console.log('First handler on child');\n});\n\ndocument.getElementById('child').addEventListener('click', function(e) {\n  e.stopImmediatePropagation();\n  console.log('Second handler on child - no subsequent handlers will run');\n});\n\ndocument.getElementById('child').addEventListener('click', function(e) {\n  console.log('This handler will never run if the event is clicked');\n});\n\n// If 'Child' is clicked, output:\n// First handler on child\n// Second handler on child - no subsequent handlers will run\n// (The third handler on child will NOT fire)",
              "explanation": "When the child element is clicked, the first two handlers execute. When the second handler calls `e.stopImmediatePropagation()`, it not only stops the event from bubbling up but also prevents any other handlers attached to the *same* child element (the third one in this case) from executing.",
              "language": "typescript"
            },
            {
              "id": "example_event_control_3",
              "title": "Using preventDefault()",
              "code": "<!-- HTML Structure -->\n<a id=\"link\" href=\"https://www.example.com\">Visit Example.com</a>\n<div id=\"parent\" style=\"border: 1px solid blue; padding: 20px;\">Parent</div>\n\n// JavaScript\ndocument.getElementById('link').addEventListener('click', function(e) {\n  e.preventDefault(); // Link won't navigate\n  console.log('Link clicked but default behavior prevented');\n});\n\ndocument.getElementById('parent').addEventListener('click', function(e) {\n  console.log('Parent clicked - event still bubbled up');\n}, false);\n\n// If 'Visit Example.com' is clicked, output:\n// Link clicked but default behavior prevented\n// Parent clicked - event still bubbled up\n// (Browser navigation to example.com is prevented)",
              "explanation": "When the link is clicked, `e.preventDefault()` stops the browser from navigating to the URL. However, the event continues to bubble up the DOM, and thus the parent's click listener is still triggered.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_event_control_1",
            "question_event_control_2",
            "question_event_control_3",
            "question_event_control_4",
            "question_event_control_5"
          ],
          "relatedTasks": [
            "task_event_control_1"
          ],
          "tags": [
            "DOM Events",
            "Event Propagation",
            "stopPropagation",
            "stopImmediatePropagation",
            "preventDefault",
            "Event Handling"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Event Bubbling and Capturing",
            "HTML DOM Structure"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Building Interactive UIs",
            "Form Validation",
            "Custom Controls"
          ]
        },
        {
          "id": "theory_event_delegation",
          "title": "Event Delegation",
          "content": "Event delegation is a powerful technique in JavaScript where you attach a single event listener to a common ancestor element, rather than attaching individual listeners to multiple descendant elements. This technique relies on event bubbling.\n\nWhen an event occurs on a child element, it bubbles up the DOM tree. The single listener on the ancestor element can then 'catch' the event. Inside this single listener, you can determine which specific descendant element triggered the event using the `Event.target` property. You can then apply specific logic based on `e.target` or its closest ancestor using `e.target.closest()`.\n\n### Benefits of Event Delegation:\n\n1.  **Performance Optimization**: Reduces the number of event listeners attached to the DOM, which can significantly improve performance, especially for large lists or tables. Fewer listeners mean less memory consumption and faster DOM updates.\n2.  **Dynamic Elements**: It simplifies handling events on elements that are added to the DOM dynamically (after the initial page load). Since the listener is on a static ancestor, it automatically applies to new children without needing to re-attach listeners every time an element is added or removed.\n3.  **Simpler Code**: Can lead to cleaner and more maintainable code, as event handling logic is centralized.",
          "examples": [
            {
              "id": "example_event_delegation_1",
              "title": "Basic Event Delegation for a List",
              "code": "<!-- HTML Structure -->\n<ul id=\"task-list\" style=\"border: 1px solid gray; padding: 15px;\">\n  <li>Task 1 <button class=\"delete-btn\">Delete</button> <button class=\"edit-btn\">Edit</button></li>\n  <li>Task 2 <button class=\"delete-btn\">Delete</button> <button class=\"edit-btn\">Edit</button></li>\n  <li>Task 3 <button class=\"delete-btn\">Delete</button> <button class=\"edit-btn\">Edit</button></li>\n</ul>\n<button id=\"add-task\">Add New Task</button>\n\n// JavaScript\ndocument.getElementById('task-list').addEventListener('click', function(e) {\n  // Check if the clicked element is a list item or a child within a list item\n  const listItem = e.target.closest('li');\n  \n  if (listItem) {\n    console.log('List item clicked:', listItem.textContent.trim());\n    \n    // You can also check for specific child elements within the list item\n    if (e.target.classList.contains('delete-btn')) {\n      console.log('Delete button clicked for:', listItem.textContent.trim());\n      listItem.remove(); // Remove the item\n    } else if (e.target.classList.contains('edit-btn')) {\n      console.log('Edit button clicked for:', listItem.textContent.trim());\n      // Logic to edit the item\n    }\n  }\n});\n\n// Example of dynamically adding an item\ndocument.getElementById('add-task').addEventListener('click', function() {\n  const ul = document.getElementById('task-list');\n  const newTaskNumber = ul.children.length + 1;\n  const newLi = document.createElement('li');\n  newLi.innerHTML = `New Task ${newTaskNumber} <button class=\"delete-btn\">Delete</button> <button class=\"edit-btn\">Edit</button>`;\n  ul.appendChild(newLi);\n  console.log(`Added New Task ${newTaskNumber}. Listener still works.`);\n});",
              "explanation": "Instead of attaching a click listener to each `<li>` or each button within the `<li>`, a single listener is attached to the parent `<ul>` (`task-list`). When a click occurs anywhere inside the `<ul>`, the event bubbles up to it. The listener then uses `e.target.closest('li')` to identify if a list item was involved in the click and `e.target.classList.contains()` to determine which specific button (delete/edit) was clicked. This works seamlessly even when new list items are added dynamically, as demonstrated by the 'Add New Task' button, because the listener is on the static parent.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_event_delegation_1",
            "question_event_delegation_2",
            "question_event_delegation_3",
            "question_event_delegation_4"
          ],
          "relatedTasks": [
            "task_event_delegation_1"
          ],
          "tags": [
            "DOM Events",
            "Event Delegation",
            "Performance",
            "Dynamic Content",
            "e.target",
            "closest()"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Event Bubbling",
            "DOM Manipulation",
            "e.target"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex UI Interactions",
            "Building Component Libraries",
            "Optimizing Large Applications"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_event_loop_1",
          "topic": "Event Loop and Asynchronous Execution",
          "level": "medium",
          "type": "mcq",
          "question": "What will be the correct order of console logs when the following JavaScript code is executed?\n\n```javascript\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('C');\n});\n\nconsole.log('D');\n```",
          "answer": "A, D, C, B",
          "options": [
            "A, B, C, D",
            "A, D, B, C",
            "A, C, D, B",
            "A, D, C, B"
          ],
          "analysisPoints": [
            "Understanding synchronous execution first.",
            "Differentiating between microtask queue (Promises) and macrotask queue (setTimeout).",
            "Knowing the priority of microtasks over macrotasks in the event loop."
          ],
          "keyConcepts": [
            "Call Stack",
            "Microtask Queue",
            "Macrotask Queue",
            "Event Loop Priority"
          ],
          "evaluationCriteria": [
            "Correctly identifies synchronous code execution order.",
            "Correctly prioritizes Promise callbacks (microtasks).",
            "Correctly places setTimeout callbacks (macrotasks) last."
          ],
          "example": "Explanation: 'A' and 'D' are synchronous and execute immediately. `Promise.resolve().then()` adds 'C' to the microtask queue. `setTimeout` adds 'B' to the macrotask queue. The event loop prioritizes microtasks over macrotasks, so 'C' runs before 'B'.",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Promises",
            "setTimeout",
            "Asynchronous"
          ],
          "prerequisites": [
            "Basic JavaScript",
            "Functions"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_2",
          "topic": "Event Loop and Call Stack",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of the Call Stack in JavaScript's execution model?",
          "answer": "The Call Stack executes synchronous JavaScript code one function at a time. When a function is called, it's pushed onto the stack, and when it returns, it's popped off.",
          "analysisPoints": [],
          "keyConcepts": [
            "Call Stack",
            "Synchronous Execution"
          ],
          "evaluationCriteria": [
            "Defines Call Stack's purpose."
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Call Stack"
          ],
          "prerequisites": [
            "Basic JavaScript"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_loop_3",
          "topic": "Microtask vs. Macrotask",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between the microtask queue and the macrotask queue in the context of the JavaScript Event Loop. Provide examples of operations that go into each queue.",
          "answer": "",
          "analysisPoints": [
            "Definition of microtask queue (e.g., higher priority, promises, mutation observers).",
            "Definition of macrotask queue (e.g., lower priority, setTimeout, setInterval, I/O).",
            "Explanation of how the Event Loop processes them (microtasks emptied before one macrotask).",
            "Correct examples for both queues."
          ],
          "keyConcepts": [
            "Microtask Queue",
            "Macrotask Queue",
            "Event Loop Priority",
            "Promises",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of definitions.",
            "Completeness of examples.",
            "Demonstrates understanding of processing order."
          ],
          "example": "A microtask queue (e.g., Promise callbacks, MutationObserver) has higher priority. All microtasks are processed completely before the event loop moves to the macrotask queue. The macrotask queue (e.g., `setTimeout`, `setInterval`, I/O operations) is processed one task at a time per event loop cycle. After a macrotask finishes, the event loop checks for and empties the microtask queue again before picking another macrotask.",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Microtasks",
            "Macrotasks",
            "Asynchronous"
          ],
          "prerequisites": [
            "Event Loop Basics",
            "Promises"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_4",
          "topic": "Event Loop Practical Application",
          "level": "hard",
          "type": "code",
          "question": "Predict the output of the following code snippet and explain your reasoning step-by-step, relating it to the event loop phases:\n\n```javascript\nconsole.log('Start');\n\nnew Promise(resolve => {\n  console.log('Promise constructor');\n  resolve();\n}).then(() => {\n  console.log('Promise then 1');\n  setTimeout(() => console.log('Timeout inside Promise'), 0);\n}).then(() => {\n  console.log('Promise then 2');\n});\n\nsetTimeout(() => console.log('Timeout outside Promise'), 0);\n\nconsole.log('End');\n```",
          "answer": "Start\nPromise constructor\nEnd\nPromise then 1\nPromise then 2\nTimeout outside Promise\nTimeout inside Promise",
          "options": [],
          "analysisPoints": [
            "Identifies synchronous code first.",
            "Understands Promise constructor runs synchronously.",
            "Correctly places initial Promise .then() callbacks in microtask queue.",
            "Correctly places setTimeout callbacks in macrotask queue.",
            "Understands that new setTimeouts within microtasks are still macrotasks.",
            "Applies microtask priority over macrotasks repeatedly."
          ],
          "keyConcepts": [
            "Call Stack",
            "Microtask Queue",
            "Macrotask Queue",
            "Promise Constructor Execution",
            "Nested Asynchronous Operations"
          ],
          "evaluationCriteria": [
            "Accurate prediction of output.",
            "Detailed, correct step-by-step explanation.",
            "Proper use of event loop terminology (call stack, microtasks, macrotasks)."
          ],
          "example": "```javascript\n// Execution Steps:\n// 1. console.log('Start') -> 'Start' printed (Synchronous)\n// 2. new Promise(resolve => { console.log('Promise constructor'); resolve(); }) -> 'Promise constructor' printed. resolve() schedules the first .then() callback to microtask queue. (Synchronous for constructor)\n// 3. setTimeout(() => console.log('Timeout outside Promise'), 0); -> Schedules 'Timeout outside Promise' callback to macrotask queue. (Web API, then Macrotask Queue)\n// 4. console.log('End') -> 'End' printed (Synchronous)\n// 5. Synchronous code finished. Call stack empty.\n// 6. Event Loop checks Microtask Queue. 'Promise then 1' callback is executed. -> 'Promise then 1' printed. Inside this, another setTimeout is scheduled for 'Timeout inside Promise' to the macrotask queue. The second .then() (for 'Promise then 2') is scheduled to the microtask queue.\n// 7. Event Loop checks Microtask Queue again. 'Promise then 2' callback is executed. -> 'Promise then 2' printed. (Microtask Queue is now empty).\n// 8. Event Loop checks Macrotask Queue. 'Timeout outside Promise' is executed. -> 'Timeout outside Promise' printed.\n// 9. Event Loop checks Macrotask Queue again. 'Timeout inside Promise' is executed. -> 'Timeout inside Promise' printed.\n```",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Promises",
            "setTimeout",
            "Asynchronous",
            "Advanced"
          ],
          "prerequisites": [
            "theory_event_loop_async"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_loop_5",
          "topic": "Event Loop Flow",
          "level": "easy",
          "type": "flashcard",
          "question": "In what order does the Event Loop prioritize executing tasks from different queues?",
          "answer": "Synchronous code first, then all microtasks (e.g., Promises) from the microtask queue, and finally one macrotask (e.g., setTimeout) from the macrotask queue per cycle. This cycle repeats.",
          "analysisPoints": [],
          "keyConcepts": [
            "Event Loop",
            "Microtask Queue",
            "Macrotask Queue"
          ],
          "evaluationCriteria": [
            "Correctly states the priority order."
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_event_loop_async"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_propagation_1",
          "topic": "Event Bubbling vs. Capturing",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following HTML and JavaScript. If you click on the `div#child` element, what will be the order of console logs?\n\nHTML:\n```html\n<div id=\"parent\">\n  Parent\n  <div id=\"child\">Child</div>\n</div>\n```\n\nJavaScript:\n```javascript\ndocument.getElementById('parent').addEventListener('click', function() {\n  console.log('Parent - Bubbling');\n}, false);\n\ndocument.getElementById('child').addEventListener('click', function() {\n  console.log('Child - Bubbling');\n}, false);\n\ndocument.getElementById('parent').addEventListener('click', function() {\n  console.log('Parent - Capturing');\n}, true);\n\ndocument.getElementById('child').addEventListener('click', function() {\n  console.log('Child - Capturing');\n}, true);\n```",
          "answer": "Parent - Capturing, Child - Capturing, Child - Bubbling, Parent - Bubbling",
          "options": [
            "Child - Bubbling, Parent - Bubbling, Child - Capturing, Parent - Capturing",
            "Parent - Bubbling, Child - Bubbling, Parent - Capturing, Child - Capturing",
            "Parent - Capturing, Child - Capturing, Child - Bubbling, Parent - Bubbling",
            "Child - Capturing, Parent - Capturing, Parent - Bubbling, Child - Bubbling"
          ],
          "analysisPoints": [
            "Understanding that capturing phase occurs before bubbling phase.",
            "Understanding that listeners on the target element are triggered in both phases if registered for them.",
            "Correctly identifying the default behavior of `addEventListener` (bubbling) vs. `useCapture: true` (capturing)."
          ],
          "keyConcepts": [
            "Event Bubbling",
            "Event Capturing",
            "addEventListener",
            "Event Flow"
          ],
          "evaluationCriteria": [
            "Correctly orders event phases.",
            "Identifies which listeners fire in each phase.",
            "Demonstrates understanding of event propagation."
          ],
          "example": "When `child` is clicked:\n1.  **Capturing Phase**: Event travels down from `document` -> `parent` -> `child`. `parent`'s capturing listener fires first. Then `child`'s capturing listener fires.\n2.  **Target Phase**: Event reaches the target element (`child`).\n3.  **Bubbling Phase**: Event bubbles up from `child` -> `parent` -> `document`. `child`'s bubbling listener fires. Then `parent`'s bubbling listener fires.",
          "tags": [
            "DOM Events",
            "Event Propagation",
            "Bubbling",
            "Capturing"
          ],
          "prerequisites": [
            "HTML DOM Structure",
            "addEventListener"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_propagation_2",
          "topic": "Event Propagation Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two main phases of event propagation in the DOM?",
          "answer": "Capturing Phase and Bubbling Phase.",
          "analysisPoints": [],
          "keyConcepts": [
            "Event Propagation",
            "Capturing Phase",
            "Bubbling Phase"
          ],
          "evaluationCriteria": [
            "Recalls the two main phases."
          ],
          "example": "",
          "tags": [
            "DOM Events",
            "Flashcard",
            "Event Propagation"
          ],
          "prerequisites": [
            "Basic Event Handling"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_propagation_3",
          "topic": "addEventListener useCapture",
          "level": "medium",
          "type": "open",
          "question": "How does the third parameter of `addEventListener` affect the event listener's behavior regarding event propagation? Provide a use case where setting this parameter to `true` would be beneficial.",
          "answer": "",
          "analysisPoints": [
            "Explains that `true` means capturing phase, `false` (default) means bubbling phase.",
            "Provides a relevant example use case for capturing (e.g., global click handler for dropdowns, stopping propagation early, analytics).",
            "Discusses why capturing might be preferred in that use case (e.g., to intercept before target or other bubbling listeners)."
          ],
          "keyConcepts": [
            "addEventListener",
            "useCapture",
            "Capturing Phase",
            "Bubbling Phase"
          ],
          "evaluationCriteria": [
            "Accurate explanation of the parameter's effect.",
            "Realistic and well-justified use case."
          ],
          "example": "The third parameter of `addEventListener` (often `useCapture` or an `options` object with `capture` property) determines whether the listener is invoked during the capturing phase (`true`) or the bubbling phase (`false`, which is the default). If `true`, the listener fires as the event travels down from the root to the target. If `false`, it fires as the event bubbles up from the target to the root. A beneficial use case for `true` (capturing) could be a global click handler for a dropdown menu. You could attach a capturing listener to the `document` that closes any open dropdowns if the click target is *not* inside a dropdown. This allows you to intercept the click *before* it reaches the dropdown's own elements (which might have their own bubbling listeners), ensuring the dropdown closes effectively when clicking outside.",
          "tags": [
            "DOM Events",
            "Event Propagation",
            "addEventListener",
            "Capturing"
          ],
          "prerequisites": [
            "Event Propagation"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_propagation_4",
          "topic": "Event Propagation Behavior",
          "level": "easy",
          "type": "code",
          "question": "Given the following HTML structure and JavaScript, if `item 2` is clicked, what will be logged to the console? (Assume default `useCapture: false` for all listeners)\n\nHTML:\n```html\n<div id=\"container\">\n  <ul id=\"myList\">\n    <li>item 1</li>\n    <li>item 2</li>\n    <li>item 3</li>\n  </ul>\n</div>\n```\n\nJavaScript:\n```javascript\ndocument.getElementById('container').addEventListener('click', function(e) {\n  console.log('Container clicked');\n});\n\ndocument.getElementById('myList').addEventListener('click', function(e) {\n  console.log('List clicked');\n});\n\nconst items = document.querySelectorAll('#myList li');\nitems.forEach(item => {\n  item.addEventListener('click', function(e) {\n    console.log(`Item clicked: ${e.target.textContent.trim()}`);\n  });\n});\n```",
          "answer": "Item clicked: item 2\nList clicked\nContainer clicked",
          "options": [],
          "analysisPoints": [
            "Recognizes default bubbling behavior.",
            "Understands that the event originates at the clicked `li` and bubbles up.",
            "Correctly orders the execution of listeners from target upwards."
          ],
          "keyConcepts": [
            "Event Bubbling",
            "e.target",
            "addEventListener"
          ],
          "evaluationCriteria": [
            "Accurate prediction of console output.",
            "Implicit understanding of bubbling order."
          ],
          "example": "When 'item 2' is clicked, the event originates on the `<li>` element. The listener on that specific `<li>` is triggered first. Then, the event bubbles up to its parent `<ul>` (`myList`), triggering its listener. Finally, it bubbles up to the `<div>` (`container`), triggering its listener. All listeners are set for the bubbling phase by default.",
          "tags": [
            "DOM Events",
            "Event Bubbling",
            "Event Propagation"
          ],
          "prerequisites": [
            "theory_event_propagation"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_propagation_5",
          "topic": "Event Flow Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "Which phase of event propagation occurs first: bubbling or capturing?",
          "answer": "Capturing phase.",
          "analysisPoints": [],
          "keyConcepts": [
            "Capturing Phase",
            "Bubbling Phase",
            "Event Propagation"
          ],
          "evaluationCriteria": [
            "Recalls the correct order of phases."
          ],
          "example": "",
          "tags": [
            "DOM Events",
            "Flashcard",
            "Event Propagation"
          ],
          "prerequisites": [
            "theory_event_propagation"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_control_1",
          "topic": "stopPropagation vs. preventDefault",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements accurately describes the difference between `event.stopPropagation()` and `event.preventDefault()`?",
          "answer": "`stopPropagation()` prevents the event from reaching parent/child elements, while `preventDefault()` stops the browser's default action for the event.",
          "options": [
            "`stopPropagation()` prevents the browser's default action, while `preventDefault()` stops event propagation.",
            "Both `stopPropagation()` and `preventDefault()` stop event propagation up the DOM tree.",
            "`stopPropagation()` stops all event handlers on the same element, while `preventDefault()` stops bubbling.",
            "`stopPropagation()` prevents the event from reaching parent/child elements, while `preventDefault()` stops the browser's default action for the event."
          ],
          "analysisPoints": [
            "Distinguishes between stopping propagation (event flow) and stopping default actions (browser behavior).",
            "Correctly identifies the effect of each method.",
            "Avoids common misconceptions (e.g., `preventDefault` stopping bubbling)."
          ],
          "keyConcepts": [
            "stopPropagation",
            "preventDefault",
            "Event Propagation",
            "Default Browser Action"
          ],
          "evaluationCriteria": [
            "Accurate understanding of each method's purpose.",
            "Clear distinction between event flow and default behavior."
          ],
          "example": "`stopPropagation()` influences how the event travels through the DOM (up/down). If a `child` element calls `stopPropagation()` on a click, its `parent`'s click listeners (in the bubbling phase) will not be triggered. `preventDefault()` influences what the browser does by default. For an `<a>` tag, `preventDefault()` stops navigation, but the click event will still bubble up to its parents.",
          "tags": [
            "DOM Events",
            "Event Control",
            "stopPropagation",
            "preventDefault"
          ],
          "prerequisites": [
            "Event Propagation"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_control_2",
          "topic": "stopImmediatePropagation() usage",
          "level": "medium",
          "type": "open",
          "question": "In what scenario would `event.stopImmediatePropagation()` be more appropriate than `event.stopPropagation()`? Provide a concise example.",
          "answer": "",
          "analysisPoints": [
            "Explains that `stopImmediatePropagation()` stops propagation AND subsequent listeners on the *same element*.",
            "Explains that `stopPropagation()` only stops propagation to other elements, but not other listeners on the same element.",
            "Provides a scenario where preventing *all* further handlers on the current element is crucial (e.g., error handling, mutually exclusive actions, A/B testing).",
            "Provides a clear, simple code example demonstrating the difference in output.",
            "```javascript\n// Scenario: You have multiple click handlers on a button, and one of them is a 'guard' or 'cleanup' handler that should prevent any subsequent handlers from running if a certain condition is met.\n\nconst button = document.getElementById('myButton');\n\nbutton.addEventListener('click', function(e) {\n  console.log('Handler 1: Logging analytics');\n});\n\nbutton.addEventListener('click', function(e) {\n  // Imagine this handler checks a condition, and if met, should stop further processing\n  if (Math.random() < 0.5) { // 50% chance to stop\n    e.stopImmediatePropagation();\n    console.log('Handler 2: Condition met, stopping further handlers on this button and bubbling.');\n  } else {\n    console.log('Handler 2: Condition not met, proceeding.');\n  }\n});\n\nbutton.addEventListener('click', function(e) {\n  console.log('Handler 3: Performing main action'); // This might not run\n});\n\n// If Handler 2 calls stopImmediatePropagation(), Handler 3 will NOT run.\n// If Handler 2 only called stopPropagation(), Handler 3 *would* still run.\n```"
          ],
          "keyConcepts": [
            "stopImmediatePropagation",
            "stopPropagation",
            "Event Handler Order",
            "DOM Events"
          ],
          "evaluationCriteria": [
            "Accurate comparison of the two methods.",
            "Identifies a specific and valid use case.",
            "Provides a correct and illustrative code example."
          ],
          "example": "Use `event.stopImmediatePropagation()` when you have multiple event listeners attached to the *same element* for the same event type, and you need to ensure that after a certain listener executes, no other listeners on that specific element (or any parent/child elements) will run for that event. For instance, if you have a button with several click handlers, and one handler performs a critical validation or a 'once-only' action that should prevent any subsequent handlers on that button from executing, then `stopImmediatePropagation()` is appropriate. `stopPropagation()` would only prevent the event from bubbling/capturing further in the DOM tree, but all other handlers on the *current* element would still execute.",
          "tags": [
            "DOM Events",
            "Event Control",
            "stopImmediatePropagation",
            "stopPropagation",
            "Advanced"
          ],
          "prerequisites": [
            "Event Propagation",
            "Multiple Event Listeners"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_control_3",
          "topic": "preventDefault()",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `event.preventDefault()`?",
          "answer": "To stop the default action associated with an event (e.g., a link navigating, a form submitting, a checkbox toggling).",
          "analysisPoints": [],
          "keyConcepts": [
            "preventDefault",
            "Default Browser Action"
          ],
          "evaluationCriteria": [
            "Correctly defines the method's purpose."
          ],
          "example": "",
          "tags": [
            "DOM Events",
            "Flashcard",
            "Event Control"
          ],
          "prerequisites": [
            "Basic Event Handling"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_control_4",
          "topic": "Event Control Methods",
          "level": "medium",
          "type": "code",
          "question": "Consider an `<a>` tag nested inside a `div`. Write JavaScript code to prevent the link from navigating and also prevent the click event from bubbling up to the parent `div`.\n\nHTML:\n```html\n<div id=\"parent-container\">\n  <a id=\"myLink\" href=\"https://example.com\">Click Me</a>\n</div>\n```",
          "answer": "```javascript\ndocument.getElementById('myLink').addEventListener('click', function(e) {\n  e.preventDefault(); // Prevents navigation\n  e.stopPropagation(); // Prevents bubbling to parent-container\n  console.log('Link clicked, default prevented and propagation stopped.');\n});\n\ndocument.getElementById('parent-container').addEventListener('click', function() {\n  console.log('Parent container clicked'); // This should not log if link is clicked\n});\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `e.preventDefault()` to stop default action.",
            "Correctly uses `e.stopPropagation()` to stop bubbling.",
            "Demonstrates understanding that both methods are required for the given requirements."
          ],
          "keyConcepts": [
            "preventDefault",
            "stopPropagation",
            "Event Propagation",
            "Default Browser Action"
          ],
          "evaluationCriteria": [
            "Provides correct and complete code.",
            "Shows understanding of combining event control methods."
          ],
          "example": "The code uses `e.preventDefault()` to stop the browser's default navigation behavior for the `<a>` tag. It then uses `e.stopPropagation()` to prevent the click event from continuing its journey up the DOM tree, thus ensuring the `parent-container`'s click listener is not triggered.",
          "tags": [
            "DOM Events",
            "Event Control",
            "stopPropagation",
            "preventDefault",
            "Coding"
          ],
          "prerequisites": [
            "theory_event_control"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_control_5",
          "topic": "stopImmediatePropagation",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the key distinction between `stopPropagation()` and `stopImmediatePropagation()`?",
          "answer": "`stopPropagation()` prevents the event from propagating to *ancestor/descendant elements*, but *other handlers on the same element* still run. `stopImmediatePropagation()` prevents propagation to other elements *AND* prevents any *subsequent handlers on the same element* from running.",
          "analysisPoints": [],
          "keyConcepts": [
            "stopImmediatePropagation",
            "stopPropagation",
            "Event Listeners"
          ],
          "evaluationCriteria": [
            "Clearly articulates the difference in scope."
          ],
          "example": "",
          "tags": [
            "DOM Events",
            "Flashcard",
            "Event Control"
          ],
          "prerequisites": [
            "theory_event_control"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_delegation_1",
          "topic": "Event Delegation Benefits",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a primary benefit of using event delegation?",
          "answer": "It automatically prevents default browser actions for delegated events.",
          "options": [
            "Reduced memory footprint by using fewer event listeners.",
            "Simplified handling of dynamically added elements.",
            "Improved performance for large lists of interactive elements.",
            "It automatically prevents default browser actions for delegated events."
          ],
          "analysisPoints": [
            "Identifies the core benefits of event delegation (performance, dynamic elements, cleaner code).",
            "Recognizes that event delegation does not inherently prevent default actions; `preventDefault()` must still be explicitly called."
          ],
          "keyConcepts": [
            "Event Delegation",
            "Performance Optimization",
            "Dynamic Content",
            "preventDefault"
          ],
          "evaluationCriteria": [
            "Understands the advantages of event delegation.",
            "Correctly identifies a false claim about its capabilities."
          ],
          "example": "Event delegation provides benefits like better performance due to fewer listeners and easier management of elements added to the DOM after initial load. However, it does not automatically call `preventDefault()`; you still need to explicitly use `e.preventDefault()` within your delegated handler if you wish to stop a default browser action (e.g., clicking an `<a>` tag or submitting a form).",
          "tags": [
            "DOM Events",
            "Event Delegation",
            "Performance"
          ],
          "prerequisites": [
            "Event Bubbling"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_delegation_2",
          "topic": "Event Delegation Implementation",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of event delegation and how it works, including how you would identify the actual clicked element within a delegated event handler. Provide an example scenario where event delegation is particularly useful.",
          "answer": "",
          "analysisPoints": [
            "Defines event delegation (single listener on ancestor).",
            "Explains its reliance on event bubbling.",
            "Describes using `e.target` to identify the origin of the event.",
            "Mentions `e.target.closest()` as a robust way to find a specific ancestor.",
            "Provides a clear and common use case (e.g., dynamic lists, tables with many interactive cells).",
            "Highlights the benefits in the chosen scenario (performance, dynamic elements)."
          ],
          "keyConcepts": [
            "Event Delegation",
            "Event Bubbling",
            "e.target",
            "closest()",
            "Dynamic Elements"
          ],
          "evaluationCriteria": [
            "Clear and accurate explanation.",
            "Correctly identifies methods for target detection.",
            "Relevant and well-explained scenario."
          ],
          "example": "Event delegation is a technique where you attach a single event listener to a common parent element, rather than attaching separate listeners to many child elements. It works because of event bubbling: when an event occurs on a child element, it bubbles up to its ancestors. The single listener on the parent 'catches' the event. Inside this handler, you can identify the element that *originally* triggered the event using `e.target`. For example, if you click a button inside a list item, `e.target` would be the button. You can then use `e.target.closest('selector')` to find the nearest ancestor matching a selector (e.g., `e.target.closest('li')` to find the list item containing the button).\n\n**Example Scenario**: A dynamic to-do list where users can add or delete tasks. Each task `<li>` might contain 'delete' and 'edit' buttons. Instead of attaching a click listener to every 'delete' and 'edit' button (which would be inefficient for a long list and require re-attaching for new tasks), you can attach one click listener to the parent `<ul>`. When a click happens, you check `e.target` to see if it's a delete or edit button, and `e.target.closest('li')` to identify which task it belongs to. This makes the code more efficient and handles new tasks automatically.",
          "tags": [
            "DOM Events",
            "Event Delegation",
            "Performance",
            "Dynamic Content"
          ],
          "prerequisites": [
            "theory_event_delegation"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_delegation_3",
          "topic": "Event Delegation vs. Direct Event Handling",
          "level": "hard",
          "type": "code",
          "question": "You are building a chat application where new messages are continuously appended to a `div` with `id=\"messages\"`. Each message `div` contains a `span` with `class=\"timestamp\"` which should display an alert when clicked. Implement this using both direct event handling and event delegation. Discuss which approach is better and why.\n\nHTML (initial):\n```html\n<div id=\"messages\" style=\"border: 1px solid black; height: 200px; overflow-y: scroll;\">\n  <!-- Messages will be added here -->\n</div>\n<button id=\"addMessage\">Add New Message</button>\n```",
          "answer": "```javascript\n// Direct Event Handling (Less Ideal for dynamic content)\nlet messageCounterDirect = 0;\ndocument.getElementById('addMessage').addEventListener('click', () => {\n  const messagesDiv = document.getElementById('messages');\n  const newMessage = document.createElement('div');\n  newMessage.className = 'message-item';\n  newMessage.innerHTML = `<span>Message ${++messageCounterDirect}</span> <span class=\"timestamp\">${new Date().toLocaleTimeString()}</span>`;\n  messagesDiv.appendChild(newMessage);\n\n  // Attach listener directly to the new timestamp span\n  const newTimestampSpan = newMessage.querySelector('.timestamp');\n  if (newTimestampSpan) {\n    newTimestampSpan.addEventListener('click', function() {\n      alert(`Timestamp clicked (Direct): ${this.textContent}`);\n    });\n  }\n});\n\nconsole.log('--- Direct Event Handling setup ---\\n');\n\n\n// Event Delegation (More Ideal for dynamic content)\nlet messageCounterDelegated = 0;\nconst messagesContainerDelegated = document.createElement('div');\nmessagesContainerDelegated.id = 'messages-delegated';\nmessagesContainerDelegated.style = \"border: 1px solid green; height: 200px; overflow-y: scroll; margin-top: 20px;\";\nmessagesContainerDelegated.innerHTML = \"<h3>Delegated Messages</h3>\";\ndocument.body.appendChild(messagesContainerDelegated);\n\nconst addMessageDelegatedBtn = document.createElement('button');\naddMessageDelegatedBtn.id = 'addMessageDelegated';\naddMessageDelegatedBtn.textContent = 'Add New Delegated Message';\ndocument.body.appendChild(addMessageDelegatedBtn);\n\nmessagesContainerDelegated.addEventListener('click', function(e) {\n  if (e.target.classList.contains('timestamp')) {\n    alert(`Timestamp clicked (Delegated): ${e.target.textContent}`);\n  }\n});\n\naddMessageDelegatedBtn.addEventListener('click', () => {\n  const newMessage = document.createElement('div');\n  newMessage.className = 'message-item';\n  newMessage.innerHTML = `<span>Message ${++messageCounterDelegated}</span> <span class=\"timestamp\">${new Date().toLocaleTimeString()}</span>`;\n  messagesContainerDelegated.appendChild(newMessage);\n});\n\nconsole.log('\\n--- Event Delegation setup ---');\n\n/*\nDiscussion:\nDirect event handling requires attaching a new listener every time a new message is added. This can lead to:\n1. Performance issues: Many listeners consume more memory and CPU.\n2. Code complexity: More lines of code and logic to manage individual listeners.\n3. Error prone: Easy to forget to attach a listener to new elements.\n\nEvent delegation is better for this scenario because:\n1. Efficiency: Only one listener is attached to the parent `div#messages-delegated`.\n2. Handles dynamic content automatically: New messages added to the DOM automatically work with the existing listener, as the event will bubble up to the parent.\n3. Cleaner code: Centralized event handling logic.\n\nThe choice depends on whether elements are static or dynamic, and the scale of interactive elements. For dynamically growing lists, delegation is almost always preferred.\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Provides correct implementation for direct event handling.",
            "Provides correct implementation for event delegation.",
            "Correctly uses `e.target` and `classList.contains` for delegation.",
            "Articulates the performance and maintenance advantages of delegation for dynamic content.",
            "Compares the two approaches effectively."
          ],
          "keyConcepts": [
            "Event Delegation",
            "Direct Event Handling",
            "Dynamic DOM Manipulation",
            "Performance",
            "e.target"
          ],
          "evaluationCriteria": [
            "Correct and functional code for both approaches.",
            "Comprehensive comparison and justification for delegation's superiority.",
            "Demonstrates advanced understanding of event handling strategies."
          ],
          "example": "This task demonstrates how direct event handling can become cumbersome with dynamic content, requiring a new listener for each added element. Event delegation provides a more scalable and efficient solution by using a single listener on a static ancestor, which automatically handles events on dynamically added children through event bubbling.",
          "tags": [
            "DOM Events",
            "Event Delegation",
            "Performance",
            "Dynamic Content",
            "Coding"
          ],
          "prerequisites": [
            "theory_event_delegation",
            "DOM Manipulation"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_delegation_4",
          "topic": "Event Delegation Key Properties",
          "level": "easy",
          "type": "flashcard",
          "question": "Which `Event` object property is crucial for identifying the element that originally triggered an event when using event delegation?",
          "answer": "`event.target`",
          "analysisPoints": [],
          "keyConcepts": [
            "Event Delegation",
            "e.target"
          ],
          "evaluationCriteria": [
            "Recalls the correct property."
          ],
          "example": "",
          "tags": [
            "DOM Events",
            "Flashcard",
            "Event Delegation"
          ],
          "prerequisites": [
            "theory_event_delegation"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_event_loop_1",
          "title": "Predicting Event Loop Output with Complex Asynchronicity",
          "description": "\nAnalyze the provided JavaScript code snippet and predict the exact order of console logs. Your solution should explain step-by-step how the JavaScript Event Loop processes the different asynchronous operations (Promises, setTimeout, synchronous code).\n\n```javascript\nconsole.log('Synchronous 1');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n  Promise.resolve().then(() => console.log('Promise inside Timeout'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n});\n\nsetTimeout(() => {\n  console.log('Timeout 2');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 2');\n});\n\nconsole.log('Synchronous 2');\n```\n\nYour response should be the predicted output and a detailed explanation of why it happens in that order, referencing the Call Stack, Microtask Queue, and Macrotask Queue.",
          "difficulty": "hard",
          "startingCode": "console.log('Synchronous 1');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n  Promise.resolve().then(() => console.log('Promise inside Timeout'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n});\n\nsetTimeout(() => {\n  console.log('Timeout 2');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 2');\n});\n\nconsole.log('Synchronous 2');\n\n// TODO: Predict output and explain steps.\n",
          "solutionCode": "// Predicted Output:\n// Synchronous 1\n// Synchronous 2\n// Promise 1\n// Promise 2\n// Timeout 1\n// Promise inside Timeout\n// Timeout 2\n\n/*\nDetailed Explanation:\n\n1.  **Initial Synchronous Execution (Call Stack)**:\n    *   `console.log('Synchronous 1')` is executed. Output: `Synchronous 1`\n    *   `setTimeout` callback for 'Timeout 1' is sent to Web APIs, then added to the **Macrotask Queue**.\n    *   `Promise.resolve().then()` callback for 'Promise 1' is added to the **Microtask Queue**.\n    *   `setTimeout` callback for 'Timeout 2' is sent to Web APIs, then added to the **Macrotask Queue**.\n    *   `Promise.resolve().then()` callback for 'Promise 2' is added to the **Microtask Queue**.\n    *   `console.log('Synchronous 2')` is executed. Output: `Synchronous 2`\n    *   The Call Stack becomes empty.\n\n2.  **First Event Loop Cycle (Call Stack empty)**:\n    *   **Microtask Queue processing**: The Event Loop checks the Microtask Queue first and processes all tasks in it before moving to macrotasks.\n        *   'Promise 1' callback is moved to Call Stack and executed. Output: `Promise 1`\n        *   'Promise 2' callback is moved to Call Stack and executed. Output: `Promise 2`\n    *   The Microtask Queue is now empty.\n\n3.  **Second Event Loop Cycle (Call Stack empty, Microtask Queue empty)**:\n    *   **Macrotask Queue processing**: The Event Loop picks **one** task from the Macrotask Queue. The first one added was 'Timeout 1'.\n        *   'Timeout 1' callback is moved to Call Stack and executed. Output: `Timeout 1`\n        *   Inside 'Timeout 1', `Promise.resolve().then(() => console.log('Promise inside Timeout'))` is encountered. Its callback is immediately added to the **Microtask Queue**.\n        *   The Call Stack becomes empty again.\n\n4.  **Third Event Loop Cycle (Call Stack empty)**:\n    *   **Microtask Queue processing**: The Event Loop checks the Microtask Queue again. It finds 'Promise inside Timeout'.\n        *   'Promise inside Timeout' callback is moved to Call Stack and executed. Output: `Promise inside Timeout`\n    *   The Microtask Queue is now empty.\n\n5.  **Fourth Event Loop Cycle (Call Stack empty, Microtask Queue empty)**:\n    *   **Macrotask Queue processing**: The Event Loop picks the next task from the Macrotask Queue. The next one is 'Timeout 2'.\n        *   'Timeout 2' callback is moved to Call Stack and executed. Output: `Timeout 2`\n    *   The Macrotask Queue is now empty. All tasks are processed.\n*/\n",
          "testCases": [],
          "hints": [
            "Remember the strict priority: synchronous > microtasks > macrotasks.",
            "A new Promise's `.then()` callback is always a microtask.",
            "A `setTimeout` callback is always a macrotask.",
            "Microtasks are emptied completely before the event loop processes even one macrotask.",
            "If a macrotask or another microtask schedules a new microtask, that new microtask will run before any *further* macrotasks."
          ],
          "tags": [
            "JavaScript",
            "Event Loop",
            "Asynchronous",
            "Promises",
            "setTimeout",
            "Microtasks",
            "Macrotasks"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_event_loop_async"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Call Stack",
            "Web APIs",
            "Concurrency Model"
          ]
        },
        {
          "id": "task_event_propagation_1",
          "title": "Interactive Event Propagation Visualizer",
          "description": "\nCreate a simple HTML structure with nested `div` elements and apply click listeners to them, demonstrating both the capturing and bubbling phases.\n\n**Requirements:**\n1.  Create at least three nested `div` elements (e.g., Grandparent > Parent > Child).\n2.  Add a unique background color and padding to each `div` to make them visually distinct.\n3.  Attach two `click` event listeners to *each* `div`:\n    *   One for the **capturing phase** (using `true` as the third parameter).\n    *   One for the **bubbling phase** (using `false` or omitting the third parameter).\n4.  When any `div` is clicked, log to the console the `id` of the clicked element, and indicate whether the event listener fired during the 'Capturing' or 'Bubbling' phase.\n5.  Add a `p` tag inside the innermost `div` as a target. When this `p` tag is clicked, it should clearly show the full propagation path through all its ancestors, first capturing then bubbling.\n\n**Example Output (if 'Child' is clicked):**\n```\nGrandparent clicked - Capturing\nParent clicked - Capturing\nChild clicked - Capturing\nChild clicked - Bubbling\nParent clicked - Bubbling\nGrandparent clicked - Bubbling\n```\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Propagation</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    div {\n      padding: 30px;\n      border: 2px solid #ccc;\n      margin: 10px;\n      text-align: center;\n      font-weight: bold;\n    }\n    #grandparent { background-color: #e0f7fa; border-color: #00bcd4; }\n    #parent { background-color: #e8f5e9; border-color: #4caf50; }\n    #child { background-color: #fce4ec; border-color: #e91e63; }\n    p { cursor: pointer; background-color: #fff; padding: 10px; margin: 10px auto; border: 1px dashed #333; }\n  </style>\n</head>\n<body>\n  <div id=\"grandparent\">\n    Grandparent\n    <div id=\"parent\">\n      Parent\n      <div id=\"child\">\n        Child\n        <p>Click me</p>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // TODO: Implement event listeners here\n\n  </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Propagation</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    div {\n      padding: 30px;\n      border: 2px solid #ccc;\n      margin: 10px;\n      text-align: center;\n      font-weight: bold;\n    }\n    #grandparent { background-color: #e0f7fa; border-color: #00bcd4; }\n    #parent { background-color: #e8f5e9; border-color: #4caf50; }\n    #child { background-color: #fce4ec; border-color: #e91e63; }\n    p {\n      cursor: pointer;\n      background-color: #fff;\n      padding: 10px;\n      margin: 10px auto;\n      border: 1px dashed #333;\n      width: fit-content;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"grandparent\">\n    Grandparent\n    <div id=\"parent\">\n      Parent\n      <div id=\"child\">\n        Child\n        <p>Click me</p>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    const grandparent = document.getElementById('grandparent');\n    const parent = document.getElementById('parent');\n    const child = document.getElementById('child');\n    const clickableP = child.querySelector('p');\n\n    const elements = [grandparent, parent, child];\n\n    elements.forEach(element => {\n      // Capturing Phase Listener\n      element.addEventListener('click', function(e) {\n        console.log(`${element.id} clicked - Capturing`);\n        // Optionally, prevent default browser behavior for text selection or other default actions if needed\n        // e.preventDefault(); \n      }, true); // true for capturing phase\n\n      // Bubbling Phase Listener\n      element.addEventListener('click', function(e) {\n        console.log(`${element.id} clicked - Bubbling`);\n      }, false); // false or omit for bubbling phase\n    });\n    \n    // Add listener to the actual <p> tag as well for clarity on target\n    clickableP.addEventListener('click', function(e) {\n        console.log(`P tag clicked - (Target phase)`);\n        // For extra clarity, you could add this also for capturing/bubbling specific to P\n        // e.stopPropagation(); // Try uncommenting to see its effect\n        // e.preventDefault(); // Try uncommenting to see its effect\n    }, false); // Default bubbling\n\n    clickableP.addEventListener('click', function(e) {\n        console.log(`P tag clicked - Capturing (Target)`);\n    }, true); // Capturing\n  </script>\n</body>\n</html>\n",
          "testCases": [
            "Click on the 'Grandparent' div: Only 'Grandparent clicked - Bubbling' should appear.",
            "Click on the 'Parent' div: 'Parent clicked - Capturing', 'Parent clicked - Bubbling' should appear (assuming event propagates from document to parent then stops if it's the target).",
            "Click on the 'Child' div: 'Grandparent clicked - Capturing', 'Parent clicked - Capturing', 'Child clicked - Capturing', 'Child clicked - Bubbling', 'Parent clicked - Bubbling', 'Grandparent clicked - Bubbling' should appear.",
            "Click on the 'Click me' paragraph inside the Child div: 'Grandparent clicked - Capturing', 'Parent clicked - Capturing', 'Child clicked - Capturing', 'P tag clicked - Capturing (Target)', 'P tag clicked - (Target phase)', 'Child clicked - Bubbling', 'Parent clicked - Bubbling', 'Grandparent clicked - Bubbling' should appear (order depends on whether target phase listeners are before/after target phase capturing/bubbling ones, but generally target phase is between capturing and bubbling for the target element). The key is capturing first, then target, then bubbling.",
            "Verify that if `e.stopPropagation()` is added to the Child's capturing listener, Parent and Grandparent bubbling listeners are not triggered when Child is clicked.",
            "Verify that if `e.stopImmediatePropagation()` is added to the Child's first capturing listener, its second (bubbling) listener is not triggered when Child is clicked."
          ],
          "hints": [
            "Remember that `addEventListener`'s third parameter, when `true`, means the listener will fire during the capturing phase.",
            "When `false` (or omitted), it fires during the bubbling phase.",
            "The event always goes down during capturing and up during bubbling.",
            "The target element itself can have listeners for both phases."
          ],
          "tags": [
            "DOM Events",
            "Event Propagation",
            "Bubbling",
            "Capturing",
            "addEventListener",
            "Frontend Basics"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_event_propagation"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "e.target",
            "e.currentTarget"
          ]
        },
        {
          "id": "task_event_control_1",
          "title": "Build a Preventable Interactive Form with Propagation Control",
          "description": "\nCreate an HTML form with multiple interactive elements (a link, a checkbox, and a submit button). Implement JavaScript to demonstrate `preventDefault()`, `stopPropagation()`, and `stopImmediatePropagation()` in a practical scenario.\n\n**Requirements:**\n1.  **HTML Structure:**\n    *   A `div` with `id=\"overlay-container\"` (acting as a clickable overlay).\n    *   Inside, a `form` with `id=\"myForm\"`.\n    *   Inside the form:\n        *   An `<a>` tag (`id=\"external-link\"`) with a `href` attribute (e.g., to example.com).\n        *   A `label` with a `checkbox` input (`id=\"myCheckbox\"`).\n        *   A `button` with `type=\"submit\"` (`id=\"submitBtn\"`).\n2.  **JavaScript Functionality:**\n    *   **External Link (`#external-link`)**: Add a click listener that `preventDefault()` to stop navigation. `console.log` a message indicating prevention.\n    *   **Checkbox (`#myCheckbox`)**: Add a click listener. If the checkbox is checked, it should `stopPropagation()` to prevent the event from reaching the form or `overlay-container`. `console.log` its state and propagation status.\n    *   **Submit Button (`#submitBtn`)**: Add a click listener.\n        *   The *first* listener should `console.log` 'Submit Button: Processing request...'.\n        *   The *second* listener on the *same button* should `console.log` 'Submit Button: Validation successful.' and then `stopImmediatePropagation()` if a random condition (e.g., `Math.random() > 0.5`) is met. This listener should `preventDefault()` to stop form submission regardless.\n        *   The *third* listener on the *same button* should `console.log` 'Submit Button: Final cleanup' (this should only run if `stopImmediatePropagation()` wasn't called).\n    *   **Form (`#myForm`)**: Add a `submit` listener that `preventDefault()` (as a fallback) and `console.log` 'Form submitted (prevented)'. Add a `click` listener that `console.log` 'Form clicked'.\n    *   **Overlay Container (`#overlay-container`)**: Add a click listener that `console.log` 'Overlay clicked'.\n\n**Testing Scenarios:**\n*   Click the link.\n*   Click the checkbox (both checked and unchecked state).\n*   Click the submit button (multiple times to test random condition for `stopImmediatePropagation`).\n*   Click the form background (not a control).\n*   Click the overlay background (not inside form).\n",
          "difficulty": "hard",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Control Demo</title>\n  <style>\n    body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f0f0f0; }\n    #overlay-container {\n      border: 3px solid #f0ad4e;\n      padding: 40px;\n      background-color: #fdf5e6;\n      box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n      cursor: pointer; /* To show click detection */\n    }\n    #myForm {\n      border: 2px solid #5cb85c;\n      padding: 30px;\n      background-color: #e6ffe6;\n      display: flex;\n      flex-direction: column;\n      gap: 15px;\n      align-items: flex-start;\n    }\n    button, a, label { margin-top: 10px; }\n  </style>\n</head>\n<body>\n  <div id=\"overlay-container\">\n    <h2>Overlay Container</h2>\n    <form id=\"myForm\">\n      <h3>My Form</h3>\n      <a id=\"external-link\" href=\"https://www.example.com\">Visit Example.com</a>\n      \n      <div>\n        <input type=\"checkbox\" id=\"myCheckbox\">\n        <label for=\"myCheckbox\">Check to Stop Propagation</label>\n      </div>\n      \n      <button type=\"submit\" id=\"submitBtn\">Submit Form</button>\n    </form>\n  </div>\n\n  <script>\n    // Get elements\n    const overlayContainer = document.getElementById('overlay-container');\n    const myForm = document.getElementById('myForm');\n    const externalLink = document.getElementById('external-link');\n    const myCheckbox = document.getElementById('myCheckbox');\n    const submitBtn = document.getElementById('submitBtn');\n\n    // TODO: Implement event listeners as per requirements\n    \n  </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Control Demo</title>\n  <style>\n    body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f0f0f0; }\n    #overlay-container {\n      border: 3px solid #f0ad4e;\n      padding: 40px;\n      background-color: #fdf5e6;\n      box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n      cursor: pointer; /* To show click detection */\n    }\n    #myForm {\n      border: 2px solid #5cb85c;\n      padding: 30px;\n      background-color: #e6ffe6;\n      display: flex;\n      flex-direction: column;\n      gap: 15px;\n      align-items: flex-start;\n    }\n    button, a, label { margin-top: 10px; }\n  </style>\n</head>\n<body>\n  <div id=\"overlay-container\">\n    <h2>Overlay Container</h2>\n    <form id=\"myForm\">\n      <h3>My Form</h3>\n      <a id=\"external-link\" href=\"https://www.example.com\">Visit Example.com</a>\n      \n      <div>\n        <input type=\"checkbox\" id=\"myCheckbox\">\n        <label for=\"myCheckbox\">Check to Stop Propagation</label>\n      </div>\n      \n      <button type=\"submit\" id=\"submitBtn\">Submit Form</button>\n    </form>\n  </div>\n\n  <script>\n    // Get elements\n    const overlayContainer = document.getElementById('overlay-container');\n    const myForm = document.getElementById('myForm');\n    const externalLink = document.getElementById('external-link');\n    const myCheckbox = document.getElementById('myCheckbox');\n    const submitBtn = document.getElementById('submitBtn');\n\n    // 1. External Link (#external-link): preventDefault()\n    externalLink.addEventListener('click', function(e) {\n      e.preventDefault(); \n      console.log('Link: Default navigation prevented.');\n    });\n\n    // 2. Checkbox (#myCheckbox): stopPropagation() conditionally\n    myCheckbox.addEventListener('click', function(e) {\n      if (this.checked) {\n        e.stopPropagation();\n        console.log('Checkbox: Is CHECKED. Click event propagation STOPPED to parent elements (form, overlay).');\n      } else {\n        console.log('Checkbox: Is UNCHECKED. Click event will bubble normally.');\n      }\n    });\n\n    // 3. Submit Button (#submitBtn): stopImmediatePropagation() conditionally, preventDefault()\n    submitBtn.addEventListener('click', function(e) {\n      console.log('Submit Button: Handler 1 - Processing request...');\n    });\n\n    submitBtn.addEventListener('click', function(e) {\n      e.preventDefault(); // Always prevent form submission default behavior\n      console.log('Submit Button: Handler 2 - Validation successful.');\n\n      if (Math.random() > 0.5) { // 50% chance to stop immediate propagation\n        e.stopImmediatePropagation();\n        console.log('Submit Button: Handler 2 - Condition met, stopping ALL further handlers on this button and propagation.');\n      }\n    });\n\n    submitBtn.addEventListener('click', function(e) {\n      console.log('Submit Button: Handler 3 - Final cleanup (only runs if not stopped immediately).');\n    });\n\n    // 4. Form (#myForm): submit listener (fallback preventDefault) and click listener\n    myForm.addEventListener('submit', function(e) {\n      e.preventDefault(); // Fallback prevent default form submission\n      console.log('Form: Submit event triggered and prevented.');\n    });\n\n    myForm.addEventListener('click', function(e) {\n      console.log('Form: Click event occurred.');\n    });\n\n    // 5. Overlay Container (#overlay-container): click listener\n    overlayContainer.addEventListener('click', function(e) {\n      console.log('Overlay Container: Click event occurred.');\n    });\n  </script>\n</body>\n</html>\n",
          "testCases": [
            "**Scenario 1: Click the 'Visit Example.com' link.**\n  *   Expected output: `Link: Default navigation prevented.` followed by `Form: Click event occurred.`, `Overlay Container: Click event occurred.`\n  *   Verification: Browser should not navigate away.",
            "**Scenario 2: Click the 'Check to Stop Propagation' checkbox (unchecked to checked).**\n  *   Expected output: `Checkbox: Is CHECKED. Click event propagation STOPPED to parent elements (form, overlay).`\n  *   Verification: No `Form: Click event occurred.` or `Overlay Container: Click event occurred.` should appear.",
            "**Scenario 3: Click the 'Check to Stop Propagation' checkbox (checked to unchecked).**\n  *   Expected output: `Checkbox: Is UNCHECKED. Click event will bubble normally.` followed by `Form: Click event occurred.`, `Overlay Container: Click event occurred.`\n  *   Verification: All console logs should appear.",
            "**Scenario 4: Click the 'Submit Form' button (multiple times).**\n  *   Expected output (varied due to random condition):\n    *   Always: `Submit Button: Handler 1 - Processing request...` and `Submit Button: Handler 2 - Validation successful.`\n    *   Sometimes: `Submit Button: Handler 2 - Condition met, stopping ALL further handlers on this button and propagation.` (followed by no Handler 3, and no form/overlay clicks).\n    *   Sometimes: `Submit Button: Handler 3 - Final cleanup (only runs if not stopped immediately).` (followed by `Form: Click event occurred.`, `Overlay Container: Click event occurred.`)\n  *   Verification: Form should never submit (page reload). Console logs should reflect conditional `stopImmediatePropagation` and `preventDefault`.",
            "**Scenario 5: Click on the form background (not directly on a control).**\n  *   Expected output: `Form: Click event occurred.`, `Overlay Container: Click event occurred.`",
            "**Scenario 6: Click on the overlay container background (outside the form).**\n  *   Expected output: `Overlay Container: Click event occurred.`"
          ],
          "hints": [
            "Remember that `preventDefault()` stops the *browser's default action*, while `stopPropagation()` affects *event propagation* through the DOM tree.",
            "`stopImmediatePropagation()` is stronger than `stopPropagation()` because it also stops other listeners on the *same element*.",
            "A `submit` event on a form can be triggered by clicking a button with `type=\"submit\"` or by pressing Enter inside an input field. Always `preventDefault()` on the `submit` event if you want to handle it with JavaScript.",
            "Test each interaction separately to clearly see the effect of each control method."
          ],
          "tags": [
            "DOM Events",
            "Event Control",
            "preventDefault",
            "stopPropagation",
            "stopImmediatePropagation",
            "Form Handling",
            "Frontend Interview"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_event_propagation",
            "theory_event_control"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Event Object",
            "Event Target",
            "Event Bubbling"
          ]
        },
        {
          "id": "task_event_delegation_1",
          "title": "Build a Dynamic Item List with Event Delegation",
          "description": "\nCreate a dynamic list of items where each item can be marked as 'completed' or 'deleted'. The list should be able to add new items without manually attaching new event listeners to them.\n\n**Requirements:**\n1.  **HTML Structure:**\n    *   A `div` acting as a container (`id=\"app\"`).\n    *   Inside `app`, a heading (e.g., `<h2>My To-Do List</h2>`).\n    *   An input field (`id=\"new-task-input\"`) and a button (`id=\"add-task-btn\"`) to add new tasks.\n    *   An empty `ul` element (`id=\"task-list\"`) where tasks will be displayed.\n2.  **JavaScript Functionality:**\n    *   **Add Task:** When the 'Add Task' button is clicked (or Enter is pressed in the input field):\n        *   Get the value from the input field.\n        *   If the input is not empty, create a new `li` element.\n        *   Each `li` should contain the task text, a 'Complete' button, and a 'Delete' button.\n        *   Append the new `li` to the `ul#task-list`.\n        *   Clear the input field.\n    *   **Event Delegation:** Implement a single `click` event listener on the `ul#task-list`.\n        *   When a 'Complete' button is clicked, toggle a `completed` CSS class on its parent `li` element (e.g., `text-decoration: line-through; color: gray;`).\n        *   When a 'Delete' button is clicked, remove its parent `li` element from the DOM.\n        *   Ensure that clicking anywhere else in the `li` (but not the buttons) also logs the task content to the console.\n\n**CSS (minimal for visual feedback):**\n```css\n.completed { text-decoration: line-through; color: #888; }\n#task-list button { margin-left: 10px; cursor: pointer; }\n#task-list li { padding: 8px 0; border-bottom: 1px dashed #eee; display: flex; align-items: center; }\n#task-list li span { flex-grow: 1; cursor: pointer; }\n```\n\n**Test Cases:**\n*   Add several new tasks.\n*   Click the 'Complete' button on different tasks to toggle their completed state.\n*   Click the 'Delete' button on tasks to remove them.\n*   Verify that newly added tasks respond correctly to 'Complete' and 'Delete' clicks without new listeners being attached.\n*   Click on the task text (not the buttons) and observe console logs.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Dynamic To-Do List</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    #app { max-width: 600px; margin: 20px auto; padding: 20px; border: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    #new-task-input { width: 70%; padding: 8px; margin-right: 10px; }\n    #add-task-btn { padding: 8px 15px; cursor: pointer; }\n    #task-list { list-style: none; padding: 0; margin-top: 20px; }\n    .completed { text-decoration: line-through; color: #888; }\n    #task-list button { margin-left: 10px; cursor: pointer; padding: 5px 10px; }\n    #task-list li { padding: 8px 0; border-bottom: 1px dashed #eee; display: flex; align-items: center; }\n    #task-list li:last-child { border-bottom: none; }\n    #task-list li span { flex-grow: 1; cursor: pointer; }\n  </style>\n</head>\n<body>\n  <div id=\"app\">\n    <h2>My To-Do List</h2>\n    <div>\n      <input type=\"text\" id=\"new-task-input\" placeholder=\"Add a new task\">\n      <button id=\"add-task-btn\">Add Task</button>\n    </div>\n    <ul id=\"task-list\">\n      <!-- Tasks will be added here -->\n    </ul>\n  </div>\n\n  <script>\n    const newTaskInput = document.getElementById('new-task-input');\n    const addTaskBtn = document.getElementById('add-task-btn');\n    const taskList = document.getElementById('task-list');\n\n    // TODO: Implement add task logic and event delegation\n\n  </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Dynamic To-Do List</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    #app { max-width: 600px; margin: 20px auto; padding: 20px; border: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    #new-task-input { width: 70%; padding: 8px; margin-right: 10px; }\n    #add-task-btn { padding: 8px 15px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 4px; }\n    #add-task-btn:hover { background-color: #45a049; }\n    #task-list { list-style: none; padding: 0; margin-top: 20px; }\n    .completed { text-decoration: line-through; color: #888; }\n    #task-list button { margin-left: 10px; cursor: pointer; padding: 5px 10px; border: none; border-radius: 3px; }\n    #task-list .complete-btn { background-color: #008CBA; color: white; }\n    #task-list .complete-btn:hover { background-color: #007bb5; }\n    #task-list .delete-btn { background-color: #f44336; color: white; }\n    #task-list .delete-btn:hover { background-color: #da190b; }\n    #task-list li { padding: 8px 0; border-bottom: 1px dashed #eee; display: flex; align-items: center; }\n    #task-list li:last-child { border-bottom: none; }\n    #task-list li span { flex-grow: 1; cursor: pointer; }\n  </style>\n</head>\n<body>\n  <div id=\"app\">\n    <h2>My To-Do List</h2>\n    <div>\n      <input type=\"text\" id=\"new-task-input\" placeholder=\"Add a new task\">\n      <button id=\"add-task-btn\">Add Task</button>\n    </div>\n    <ul id=\"task-list\">\n      <!-- Tasks will be added here -->\n    </ul>\n  </div>\n\n  <script>\n    const newTaskInput = document.getElementById('new-task-input');\n    const addTaskBtn = document.getElementById('add-task-btn');\n    const taskList = document.getElementById('task-list');\n\n    function addTask() {\n      const taskText = newTaskInput.value.trim();\n      if (taskText === '') {\n        alert('Task cannot be empty!');\n        return;\n      }\n\n      const li = document.createElement('li');\n      li.innerHTML = `\n        <span>${taskText}</span>\n        <button class=\"complete-btn\">Complete</button>\n        <button class=\"delete-btn\">Delete</button>\n      `;\n      taskList.appendChild(li);\n      newTaskInput.value = ''; // Clear input\n      newTaskInput.focus(); // Keep focus for quick adding\n    }\n\n    addTaskBtn.addEventListener('click', addTask);\n    newTaskInput.addEventListener('keypress', function(e) {\n      if (e.key === 'Enter') {\n        addTask();\n      }\n    });\n\n    // Event Delegation for task-list\n    taskList.addEventListener('click', function(e) {\n      const target = e.target;\n\n      // Check if a 'Complete' button was clicked\n      if (target.classList.contains('complete-btn')) {\n        const listItem = target.closest('li');\n        if (listItem) {\n          listItem.classList.toggle('completed');\n          console.log(`Task '${listItem.querySelector('span').textContent}' completion toggled.`);\n        }\n      }\n      // Check if a 'Delete' button was clicked\n      else if (target.classList.contains('delete-btn')) {\n        const listItem = target.closest('li');\n        if (listItem) {\n          console.log(`Task '${listItem.querySelector('span').textContent}' deleted.`);\n          listItem.remove();\n        }\n      }\n      // Check if the task text (span inside li) was clicked\n      else if (target.tagName === 'SPAN' && target.closest('li')) {\n        console.log(`Task text clicked: '${target.textContent}'`);\n      }\n    });\n  </script>\n</body>\n</html>\n",
          "testCases": [
            "**Test Case 1: Add Multiple Tasks**\n  *   **Steps:** Type 'Buy groceries' and click 'Add Task'. Type 'Walk the dog' and press Enter. Type 'Read book' and click 'Add Task'.\n  *   **Expected:** Three list items appear in the `ul`.",
            "**Test Case 2: Toggle Completion**\n  *   **Steps:** Click the 'Complete' button next to 'Buy groceries'. Click it again.\n  *   **Expected:** The 'Buy groceries' task should toggle `line-through` text decoration and gray color. Console should log completion status changes.",
            "**Test Case 3: Delete Task**\n  *   **Steps:** Click the 'Delete' button next to 'Walk the dog'.\n  *   **Expected:** The 'Walk the dog' list item should be removed from the DOM. Console should log deletion.",
            "**Test Case 4: Click Task Text**\n  *   **Steps:** Click on the text 'Read book' (not the buttons).\n  *   **Expected:** Console should log `Task text clicked: 'Read book'`. The item's appearance should not change.",
            "**Test Case 5: Dynamic Item Handling**\n  *   **Steps:** After adding, completing, and deleting some tasks, add a new task 'New dynamic task'. Then try to 'Complete' and 'Delete' this newly added task.\n  *   **Expected:** The new task should respond correctly to 'Complete' and 'Delete' actions, proving that event delegation works for dynamically added elements.",
            "**Test Case 6: Empty Input**\n  *   **Steps:** Click 'Add Task' button with an empty input field.\n  *   **Expected:** An alert 'Task cannot be empty!' should appear, and no new list item should be added."
          ],
          "hints": [
            "Attach only *one* event listener to the `ul#task-list` for clicks.",
            "Use `e.target` inside the listener to identify the specific element that was clicked (e.g., a button or the text itself).",
            "Use `e.target.classList.contains('className')` to check if the clicked element is a 'complete-btn' or 'delete-btn'.",
            "Use `e.target.closest('li')` to find the nearest `li` ancestor of the clicked button, which represents the task item.",
            "Remember to handle both button clicks and clicks on the task text itself (the `span`).",
            "The `keypress` event listener on the input should check for `e.key === 'Enter'` to trigger adding a task."
          ],
          "tags": [
            "DOM Events",
            "Event Delegation",
            "Dynamic Content",
            "CRUD",
            "Frontend Development",
            "JavaScript"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_event_delegation",
            "DOM Manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "e.target",
            "closest()",
            "classList",
            "appendChild",
            "remove()"
          ]
        }
      ]
    }
  },
  {
    "id": "550b85bd-efb1-47df-a9c0-14c1601a1cc3",
    "startLine": 1800,
    "endLine": 1899,
    "processedDate": "2025-06-17T08:03:18.115Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_event_propagation",
          "title": "Event Propagation: Capturing and Bubbling",
          "content": "Event propagation is the order in which event listeners are triggered when an event occurs on an element. It involves two phases:\n\n### 1. Capturing Phase\nThis phase starts from the `Window` object, goes down through the DOM tree, visiting all ancestors of the target element, until it reaches the target itself. During this phase, listeners registered with `useCapture: true` (or `true` as the third argument in `addEventListener`) are triggered.\n\n### 2. Bubbling Phase\nThis phase starts from the target element itself and bubbles up through the DOM tree, visiting all ancestors, up to the `Window` object. Most event listeners are registered to run in this phase by default (i.e., `useCapture: false` or omitting the third argument in `addEventListener`).\n\n### Order of Event Firing\nWhen a click event, for instance, occurs on a child element, the sequence of event listener execution is:\n1.  **Parent (capturing phase)**\n2.  **Child (capturing phase)**\n3.  **Child (bubbling phase)**\n4.  **Parent (bubbling phase)**\n\nThis ordered execution allows for fine-grained control over how events are handled at different levels of the DOM tree.",
          "examples": [
            {
              "id": "example_event_propagation_1",
              "title": "Basic Event Propagation Example",
              "code": "<html>\n<head>\n  <title>Event Propagation</title>\n</head>\n<body>\n  <div id=\"parent\" style=\"padding: 20px; background-color: lightblue;\">\n    Parent\n    <button id=\"child\" style=\"padding: 10px; background-color: lightcoral;\">\n      Child Button\n    </button>\n  </div>\n\n  <script>\n    const parent = document.getElementById('parent');\n    const child = document.getElementById('child');\n\n    parent.addEventListener('click', function(e) {\n      console.log('Parent - Capturing Phase (default: bubbling phase, but showing conceptual order)');\n    }, true); // True for capturing\n\n    child.addEventListener('click', function(e) {\n      console.log('Child - Capturing Phase (default: bubbling phase, but showing conceptual order)');\n    }, true); // True for capturing\n\n    child.addEventListener('click', function(e) {\n      console.log('Child - Bubbling Phase');\n    }, false); // False for bubbling (default)\n\n    parent.addEventListener('click', function(e) {\n      console.log('Parent - Bubbling Phase');\n    }, false); // False for bubbling (default)\n  </script>\n</body>\n</html>",
              "explanation": "This HTML and JavaScript demonstrates the order of event propagation. When the 'Child Button' is clicked, the console logs will show the event traversing down the DOM in the capturing phase and then bubbling up in the bubbling phase, hitting the child's bubbling listener, and finally the parent's bubbling listener. Note that 'Child - Capturing Phase' will log before 'Child - Bubbling Phase' if you have both.",
              "language": "html"
            }
          ],
          "relatedQuestions": [
            "question_event_propagation_1",
            "question_event_propagation_2",
            "question_event_propagation_3",
            "question_event_propagation_flashcard_1"
          ],
          "relatedTasks": [
            "task_event_propagation_visualizer"
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Handling",
            "JavaScript Fundamentals"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "dom_manipulation",
            "event_listeners"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "event_delegation",
            "advanced_dom_manipulation"
          ]
        },
        {
          "id": "theory_stopping_event_propagation_default",
          "title": "Stopping Event Propagation and Preventing Default Behavior",
          "content": "While event propagation (capturing and bubbling) is crucial for event delegation, there are scenarios where you need to stop the propagation of an event or prevent the browser's default action for an event.\n\n### `e.stopPropagation()`\nThis method prevents the event from bubbling up (or capturing down, if in the capturing phase) to parent (or child) elements. It stops the propagation chain at the current element, meaning no more listeners further up (or down) the DOM tree will be triggered for this specific event.\n\n### `e.stopImmediatePropagation()`\nThis method does two things:\n1.  It stops the event from propagating further up (or down) the DOM tree, similar to `stopPropagation()`.\n2.  Crucially, it also prevents any other event handlers attached to the *same element* for the *same event type* from being executed. If an element has multiple click listeners, `stopImmediatePropagation()` will ensure only handlers registered *before* it are run.\n\n### `e.preventDefault()`\nThis method prevents the browser's default action associated with an event. For example, clicking on a link (`<a>`) normally navigates to the `href` URL; calling `e.preventDefault()` stops this navigation. Submitting a form normally reloads the page; `e.preventDefault()` stops this. It *does not* stop event propagation; the event will still bubble up (or capture down) and trigger other listeners.\n\n**Key Point**: `stopPropagation()` stops all bubbling through the DOM tree, while `preventDefault()` only prevents the default action of the element but allows event propagation to continue.",
          "examples": [
            {
              "id": "example_stop_propagation",
              "title": "Stopping Event Bubbling with stopPropagation()",
              "code": "document.getElementById('child').addEventListener('click', function(e) {\n  e.stopPropagation();\n  console.log('This event will not bubble up to parent elements.');\n});",
              "explanation": "This example demonstrates `stopPropagation()`. When the element with ID 'child' is clicked, this handler will execute, but the event will not reach any click listeners on its parent elements.",
              "language": "javascript"
            },
            {
              "id": "example_stop_immediate_propagation",
              "title": "Stopping Immediate Propagation with stopImmediatePropagation()",
              "code": "document.getElementById('child').addEventListener('click', function(e) {\n  e.stopImmediatePropagation();\n  console.log('This handler will run.');\n});\n\ndocument.getElementById('child').addEventListener('click', function(e) {\n  console.log('This handler will NOT run due to stopImmediatePropagation.');\n});",
              "explanation": "Here, `stopImmediatePropagation()` is used. The first handler attached to 'child' will execute, but because `e.stopImmediatePropagation()` is called, the second handler attached to 'child' for the same event type will *not* execute, nor will the event propagate to parent elements.",
              "language": "javascript"
            },
            {
              "id": "example_prevent_default",
              "title": "Preventing Default Behavior with preventDefault()",
              "code": "document.getElementById('link').addEventListener('click', function(e) {\n  e.preventDefault(); // Prevents the link from navigating\n  console.log('Link clicked but default behavior prevented. Event still bubbles.');\n  // Event still bubbles up to parents\n});",
              "explanation": "This example shows `preventDefault()`. A click on the 'link' element will trigger this handler, preventing the default navigation action, but the click event will still continue to bubble up to its parent elements.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_stopping_propagation_1",
            "question_stopping_propagation_2",
            "question_stopping_propagation_3",
            "question_stopping_propagation_flashcard_1"
          ],
          "relatedTasks": [
            "task_form_validation_and_propagation"
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Handling",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "event_listeners",
            "event_propagation"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "event_delegation",
            "custom_components"
          ]
        },
        {
          "id": "theory_event_delegation",
          "title": "Event Delegation",
          "content": "Event delegation is a powerful technique that leverages event bubbling to handle events efficiently. Instead of attaching individual event listeners to multiple child elements, a single event listener is attached to a common ancestor element. When an event occurs on a child, it bubbles up to the ancestor, where the delegated listener can then identify the actual target element that originated the event.\n\n### Benefits of Event Delegation:\n1.  **Memory efficiency**: Fewer event listeners are attached to the DOM, regardless of how many child elements there are. This reduces memory footprint and improves performance, especially in applications with many interactive elements.\n2.  **Dynamic elements**: It works seamlessly for elements added to the DOM *after* the listener was initially attached. Since the listener is on an ancestor, new children will automatically participate in event propagation and be handled.\n3.  **Less code**: No need to explicitly attach or detach listeners when elements are added or removed, simplifying code maintenance.\n4.  **Smaller DOM footprint**: Directly contributes to improved performance in large-scale applications by keeping the number of active listeners low.\n\n### How it Works:\n1.  Attach a single event listener to a stable parent element (e.g., a container `div` or `ul`).\n2.  Inside the event handler, use `event.target` (the element that originally triggered the event) to determine which specific child element was clicked.\n3.  Apply logic based on `event.target`'s `tagName`, `id`, `className`, or other attributes to perform the desired action.",
          "examples": [
            {
              "id": "example_event_delegation_basic",
              "title": "Basic Event Delegation Example",
              "code": "<!-- HTML Structure -->\n<div id=\"button-container\">\n  <button id=\"btn1\">Button 1</button>\n  <button id=\"btn2\">Button 2</button>\n  <button id=\"btn3\">Button 3</button>\n</div>\n\n<script>\n  // Instead of adding event listeners to multiple buttons\n  document.getElementById('button-container').addEventListener('click', function(e) {\n    // Check if the clicked element is a button\n    if (e.target.tagName === 'BUTTON') {\n      console.log('Button ' + e.target.id + ' was clicked');\n    }\n  });\n</script>",
              "explanation": "This example shows basic event delegation. A single click listener is placed on `button-container`. When any of the buttons inside it are clicked, the event bubbles up. The handler then checks `e.target.tagName` to ensure it was a button that was clicked and logs its ID.",
              "language": "html"
            },
            {
              "id": "example_event_delegation_dynamic",
              "title": "Event Delegation with Dynamic Elements",
              "code": "<!-- HTML Structure -->\n<ul id=\"myList\">\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>\n<button id=\"addItemBtn\">Add New Item</button>\n\n<script>\n  const myList = document.getElementById('myList');\n  const addItemBtn = document.getElementById('addItemBtn');\n\n  // Delegate the click listener to the ul\n  myList.addEventListener('click', function(e) {\n    if (e.target.tagName === 'LI') {\n      console.log('Clicked on list item:', e.target.textContent);\n    }\n  });\n\n  // Function to add new items dynamically\n  addItemBtn.addEventListener('click', function() {\n    const newItem = document.createElement('li');\n    newItem.textContent = 'New Item ' + (myList.children.length + 1);\n    myList.appendChild(newItem);\n    console.log('Added new item.');\n  });\n</script>",
              "explanation": "This advanced example illustrates how event delegation handles dynamically added elements. Even after new `<li>` elements are added to `myList`, the single listener on `myList` will correctly detect clicks on these new items without needing to attach new listeners.",
              "language": "html"
            }
          ],
          "relatedQuestions": [
            "question_event_delegation_1",
            "question_event_delegation_2",
            "question_event_delegation_3",
            "question_event_delegation_flashcard_1"
          ],
          "relatedTasks": [
            "task_dynamic_list_management"
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Handling",
            "Performance",
            "Dynamic Content",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "event_propagation",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "large_scale_applications",
            "frameworks_libraries"
          ]
        },
        {
          "id": "theory_async_await_basics",
          "title": "Async/Await Patterns and Best Practices: Core Concepts",
          "content": "Async/await is a modern JavaScript syntax that simplifies working with asynchronous code, making it appear and behave more like synchronous code, while still maintaining its non-blocking nature. It builds on Promises and provides a more readable and maintainable alternative to chaining `.then()` and `.catch()`.\n\n### `async` Keyword\n*   An `async` function is a function declared with the `async` keyword.\n*   It always implicitly returns a Promise. If the function returns a non-Promise value, JavaScript automatically wraps it in a resolved Promise. If it throws an error, it returns a rejected Promise.\n\n### `await` Keyword\n*   The `await` keyword can only be used inside an `async` function.\n*   It pauses the execution of the `async` function until the Promise it's waiting for settles (either resolves or rejects).\n*   If the Promise resolves, `await` returns the resolved value. If the Promise rejects, `await` throws the rejected value as an error, which can then be caught using a `try...catch` block.\n\n### Benefits:\n*   **Readability**: Makes complex asynchronous flows much easier to follow.\n*   **Error Handling**: Allows using standard `try...catch` blocks for asynchronous errors.\n*   **Debugging**: Easier to debug as the execution flow resembles synchronous code.",
          "examples": [
            {
              "id": "example_async_await_basic",
              "title": "Basic Async/Await Pattern",
              "code": "async function resolveAfterDelay(value, delay) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(value), delay);\n  });\n}\n\nasync function processData() {\n  try {\n    console.log('Starting data processing...');\n    const data = await resolveAfterDelay('Success Data', 2000); // Pauses for 2 seconds\n    console.log(data);  // Logs 'Success Data' after 2 seconds\n    return data;\n  } catch (error) {\n    console.error('An error occurred:', error);\n    throw error; // Re-throw to propagate error further if needed\n  }\n}\n\nprocessData();\nconsole.log('Function call initiated, but this logs immediately (non-blocking)');",
              "explanation": "This example demonstrates the core async/await pattern. `resolveAfterDelay` returns a Promise that resolves after a specified delay. `processData` is an `async` function that uses `await` to pause its execution until `resolveAfterDelay`'s Promise resolves. The `console.log` outside `processData` shows that the `processData` call itself is non-blocking.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_async_await_1",
            "question_async_await_2",
            "question_async_await_3",
            "question_async_await_flashcard_1"
          ],
          "relatedTasks": [
            "task_fetch_and_display_data"
          ],
          "tags": [
            "Asynchronous JavaScript",
            "Promises",
            "Error Handling",
            "JavaScript ES2017+"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "callbacks",
            "event_loop"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_web_development",
            "api_integration"
          ]
        },
        {
          "id": "theory_async_await_error_handling_timeout",
          "title": "Async/Await: Advanced Error Handling and Timeout Patterns",
          "content": "Robust asynchronous code requires proper error handling and mechanisms to deal with potentially long-running or unresponsive operations, such as network requests. Async/await facilitates these patterns with `try...catch` blocks and the `AbortController` API.\n\n### Error Handling Patterns\nJust like synchronous code, `async`/`await` functions can use `try...catch` blocks to handle errors (rejected Promises). If an `await`ed Promise rejects, the execution jumps to the `catch` block.\n\n```javascript\nasync function getProcessedData(url) {\n  let data;\n  try {\n    data = await fetchData(url); // fetchData might throw an error (reject a promise)\n  } catch (error) {\n    console.error('Fetch error:', error.message);\n    // Handle fetch error, e.g., retry, use cached data, or fetch fallback data\n    data = await fetchFallbackData(url); // Attempt to get fallback data\n  }\n  return processDataInWorker(data); // Process whatever data was successfully obtained\n}\n```\n\n### Timeout Pattern with `AbortController`\nNetwork requests might hang indefinitely. The `AbortController` API provides a way to abort a DOM request (like `fetch()`) and signal an ongoing asynchronous operation to cancel itself. This is crucial for implementing timeouts.\n\nHere's how `AbortController` works for timeouts:\n1.  Create an `AbortController` instance.\n2.  Pass its `signal` property to the `fetch` (or other abortable) API.\n3.  Set a `setTimeout` to call `controller.abort()` after a specified duration.\n4.  The `fetch` Promise will then reject with an `AbortError`, which can be caught.\n\nThis pattern ensures that a network request doesn't block resources indefinitely and provides a better user experience by allowing you to handle requests that take too long.",
          "examples": [
            {
              "id": "example_async_await_error_handling",
              "title": "Async/Await Error Handling with Fallback",
              "code": "async function fetchData(url) {\n  // Simulate an API call that might fail\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (Math.random() > 0.5) {\n        resolve(`Data from ${url}`);\n      } else {\n        reject(new Error(`Failed to fetch data from ${url}`));\n      }\n    }, 500);\n  });\n}\n\nasync function fetchFallbackData(url) {\n  // Simulate fetching from a fallback source\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`Using fallback data for ${url}`);\n      resolve(`Fallback data for ${url}`);\n    }, 200);\n  });\n}\n\nasync function getProcessedData(url) {\n  let data;\n  try {\n    console.log(`Attempting to fetch from ${url}`);\n    data = await fetchData(url); // This might fail\n  } catch (error) {\n    console.error('Caught error during primary fetch:', error.message);\n    data = await fetchFallbackData(url); // Fetch fallback if primary fails\n  }\n  console.log('Processed Data:', data);\n  return data;\n}\n\ngetProcessedData('https://api.example.com/data');",
              "explanation": "This example shows how `try...catch` works with `async`/`await` for error handling. If `fetchData` simulates a failure, the `catch` block executes, and `fetchFallbackData` is called to provide an alternative. The `processDataInWorker` is replaced with a simple log for demonstration.",
              "language": "javascript"
            },
            {
              "id": "example_async_await_timeout",
              "title": "Fetch with Timeout using AbortController",
              "code": "async function fetchWithTimeout(url, timeout = 5000) {\n  const controller = new AbortController();\n  const { signal } = controller;\n\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  try {\n    const response = await fetch(url, { signal });\n    clearTimeout(timeoutId);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    clearTimeout(timeoutId); // Ensure timeout is cleared even on other errors\n    if (error.name === 'AbortError') {\n      console.error('Fetch timed out for:', url);\n      throw new Error('Request timed out');\n    } else {\n      console.error('Fetch error:', error);\n      throw error;\n    }\n  }\n}\n\n// Example Usage (assuming a local test server or a reliable public API that might be slow)\nasync function getPosts() {\n  try {\n    console.log('Fetching posts with a 2-second timeout...');\n    const posts = await fetchWithTimeout('https://jsonplaceholder.typicode.com/posts?_delay=3000', 2000);\n    console.log('Posts fetched:', posts.slice(0, 2));\n  } catch (err) {\n    console.error('Failed to get posts:', err.message);\n  }\n}\n\nasync function getFastData() {\n    try {\n        console.log('Fetching fast data with a 5-second timeout...');\n        const data = await fetchWithTimeout('https://jsonplaceholder.typicode.com/todos/1', 5000);\n        console.log('Fast data fetched:', data);\n    } catch (err) {\n        console.error('Failed to get fast data:', err.message);\n    }\n}\n\ngetPosts();\ngetFastData();",
              "explanation": "This example provides a complete `fetchWithTimeout` function. It creates an `AbortController` and a `setTimeout` to call `controller.abort()`. If `fetch` takes longer than the `timeout`, the `AbortController` will cancel the request, causing the `fetch` Promise to reject with an `AbortError`. This error is then caught and handled. `clearTimeout` is used to prevent the timeout from firing if the fetch completes successfully or fails for other reasons.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_async_await_error_1",
            "question_async_await_error_2",
            "question_async_await_error_3",
            "question_async_await_error_flashcard_1"
          ],
          "relatedTasks": [
            "task_robust_api_client"
          ],
          "tags": [
            "Asynchronous JavaScript",
            "Promises",
            "Error Handling",
            "Network Requests",
            "AbortController",
            "JavaScript ES2017+"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "async_await_basics",
            "error_handling"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "robust_api_clients",
            "real_time_applications"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_event_propagation_1",
          "topic": "Event Propagation Order",
          "level": "easy",
          "type": "mcq",
          "question": "When a click event occurs on a child element within a parent element, which of the following describes the correct order of phases in which event listeners are triggered by default?",
          "answer": "Capturing phase (parent) -> Capturing phase (child) -> Bubbling phase (child) -> Bubbling phase (parent)",
          "options": [
            "Capturing phase (parent) -> Bubbling phase (parent) -> Capturing phase (child) -> Bubbling phase (child)",
            "Bubbling phase (child) -> Bubbling phase (parent) -> Capturing phase (child) -> Capturing phase (parent)",
            "Capturing phase (parent) -> Capturing phase (child) -> Bubbling phase (child) -> Bubbling phase (parent)",
            "Bubbling phase (parent) -> Capturing phase (parent) -> Bubbling phase (child) -> Capturing phase (child)"
          ],
          "analysisPoints": [
            "Understanding that event propagation starts with the capturing phase.",
            "Recognizing the flow from ancestor to target in capturing.",
            "Recognizing the flow from target to ancestor in bubbling.",
            "Knowing that event listeners on the target itself will trigger capturing first, then bubbling."
          ],
          "keyConcepts": [
            "Event Capturing",
            "Event Bubbling",
            "Event Flow"
          ],
          "evaluationCriteria": [
            "Correct recall of event propagation phases.",
            "Ability to sequence event listener execution."
          ],
          "example": "The browser first performs the capturing phase, moving from the document root down to the target element. Then, it performs the bubbling phase, moving from the target element back up to the document root. Listeners on the element itself fire during both phases, with capturing listeners firing first.",
          "tags": [
            "DOM",
            "Events",
            "Event Propagation"
          ],
          "prerequisites": [
            "event_listeners"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_propagation_2",
          "topic": "addEventListener useCapture Parameter",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of the third argument (or options object with `capture` property) in `addEventListener`. Provide a scenario where setting it to `true` would be beneficial.",
          "answer": "The third argument in `addEventListener` (or the `capture` property in the options object) determines whether the listener is registered for the capturing phase (`true`) or the bubbling phase (`false`, which is the default). When set to `true`, the listener will be triggered during the capturing phase as the event propagates down to the target element.\n\n**Scenario for `capture: true`:**\nConsider a case where you want to prevent clicks on any element *inside* a specific container from reaching their intended target, perhaps to implement a modal overlay that blocks interaction with the underlying content. You could attach a click listener to the container with `capture: true` and call `e.stopPropagation()` and/or `e.preventDefault()`. This listener would fire during the capturing phase *before* the click event reaches any child elements, allowing you to intercept and stop it early. This is useful for implementing global interceptors or decorators for events.",
          "analysisPoints": [
            "Understanding `useCapture`'s role in event phases.",
            "Ability to articulate the practical benefits of capturing.",
            "Providing a relevant and well-explained use case."
          ],
          "keyConcepts": [
            "Event Capturing",
            "addEventListener",
            "Event Propagation"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Practical application understanding.",
            "Accuracy of technical details."
          ],
          "example": "```javascript\n<div id=\"overlay\" style=\"position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center;\">\n  <button id=\"modalButton\">Click Me (within modal)</button>\n</div>\n<button id=\"pageButton\">Click Me (on page)</button>\n\n<script>\n  document.getElementById('overlay').addEventListener('click', function(e) {\n    console.log('Overlay capturing:', e.target.id);\n    e.stopPropagation(); // Stop propagation from going further down or bubbling up\n  }, true); // Listen in capturing phase\n\n  document.getElementById('modalButton').addEventListener('click', function(e) {\n    console.log('Modal button clicked');\n  });\n\n  document.getElementById('pageButton').addEventListener('click', function(e) {\n    console.log('Page button clicked');\n  });\n\n  // To demonstrate, try clicking pageButton when overlay is visible.\n  // If overlay has capture:true and stopPropagation, pageButton's click will be blocked.\n</script>\n```",
          "tags": [
            "DOM",
            "Events",
            "Event Listeners",
            "JavaScript"
          ],
          "prerequisites": [
            "event_propagation"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_propagation_3",
          "topic": "Event Propagation Scenario Analysis",
          "level": "hard",
          "type": "code",
          "question": "Consider the following HTML and JavaScript. Predict the exact sequence of console logs when the 'Inner Div' is clicked. Explain your reasoning for each log.",
          "answer": "```javascript\n// Expected Output:\n// Outer Div (Capturing)\n// Inner Div (Capturing)\n// Inner Div (Bubbling)\n// Outer Div (Bubbling)\n```\n\n**Reasoning:**\n1.  **'Outer Div (Capturing)'**: The click event originates on the 'Inner Div'. The browser first enters the capturing phase, traversing from the `document` down to the target. The `outerDiv` has a listener attached with `true` for the capturing phase, so it logs first.\n2.  **'Inner Div (Capturing)'**: The event continues its capturing journey. The `innerDiv` also has a listener attached with `true` for the capturing phase, so it logs next.\n3.  **'Inner Div (Bubbling)'**: After the capturing phase completes, the event switches to the bubbling phase, starting at the target element (`innerDiv`). The `innerDiv` has a listener attached with `false` (or default) for the bubbling phase, so it logs.\n4.  **'Outer Div (Bubbling)'**: The event then bubbles up to the parent element. The `outerDiv` has a listener attached with `false` (or default) for the bubbling phase, so it logs last.",
          "options": [],
          "analysisPoints": [
            "Correctly identifying the capturing phase flow.",
            "Correctly identifying the bubbling phase flow.",
            "Understanding that `addEventListener`'s third argument controls the phase.",
            "Applying the complete event propagation model (capturing down, then bubbling up)."
          ],
          "keyConcepts": [
            "Event Capturing",
            "Event Bubbling",
            "addEventListener",
            "Event Flow"
          ],
          "evaluationCriteria": [
            "Precise prediction of output.",
            "Clear and accurate justification for each step.",
            "Demonstrated deep understanding of event propagation."
          ],
          "example": "```html\n<div id=\"outerDiv\" style=\"padding: 20px; background-color: lightblue;\">\n  Outer Div\n  <div id=\"innerDiv\" style=\"padding: 10px; background-color: lightcoral;\">\n    Inner Div\n  </div>\n</div>\n\n<script>\n  const outerDiv = document.getElementById('outerDiv');\n  const innerDiv = document.getElementById('innerDiv');\n\n  outerDiv.addEventListener('click', function(e) {\n    console.log('Outer Div (Capturing)');\n  }, true); // Capturing phase\n\n  innerDiv.addEventListener('click', function(e) {\n    console.log('Inner Div (Capturing)');\n  }, true); // Capturing phase\n\n  innerDiv.addEventListener('click', function(e) {\n    console.log('Inner Div (Bubbling)');\n  }, false); // Bubbling phase (default)\n\n  outerDiv.addEventListener('click', function(e) {\n    console.log('Outer Div (Bubbling)');\n  }, false); // Bubbling phase (default)\n</script>\n```",
          "tags": [
            "DOM",
            "Events",
            "JavaScript",
            "Event Propagation"
          ],
          "prerequisites": [
            "event_listeners",
            "event_propagation"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_propagation_flashcard_1",
          "topic": "Event Propagation Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two main phases of event propagation in the DOM?",
          "answer": "Capturing phase and Bubbling phase.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Event Propagation",
            "Capturing Phase",
            "Bubbling Phase"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "DOM",
            "Events",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_stopping_propagation_1",
          "topic": "Event Stopping Methods",
          "level": "easy",
          "type": "mcq",
          "question": "Which method prevents the browser's default action associated with an event (e.g., navigating when clicking a link) but allows the event to continue propagating through the DOM?",
          "answer": "`e.preventDefault()`",
          "options": [
            "`e.stopPropagation()`",
            "`e.stopImmediatePropagation()`",
            "`e.cancelBubble()`",
            "`e.preventDefault()`"
          ],
          "analysisPoints": [
            "Distinguishing between preventing default behavior and stopping propagation.",
            "Identifying the correct method for each scenario."
          ],
          "keyConcepts": [
            "preventDefault",
            "stopPropagation",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Correctly identifying the method for default action prevention.",
            "Understanding the side effects (or lack thereof) on propagation."
          ],
          "example": "When a user clicks on an `<a>` tag, `e.preventDefault()` will stop the browser from navigating to the `href` URL, but the click event will still bubble up to parent elements. This is crucial for single-page applications where navigation is handled by JavaScript.",
          "tags": [
            "DOM",
            "Events",
            "JavaScript"
          ],
          "prerequisites": [
            "event_listeners"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_stopping_propagation_2",
          "topic": "Difference between stopPropagation and stopImmediatePropagation",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between `e.stopPropagation()` and `e.stopImmediatePropagation()`. Provide a simple code example illustrating when `stopImmediatePropagation()` would be necessary.",
          "answer": "`e.stopPropagation()` prevents the event from continuing its journey up (or down) the DOM tree to parent (or child) elements. It stops propagation to subsequent elements in the hierarchy.\n\n`e.stopImmediatePropagation()` does two things: it stops propagation to parent/child elements (like `stopPropagation()`), AND it prevents any other event handlers *on the same element* (for the same event type) from executing. If an element has multiple listeners for the same event, `stopImmediatePropagation()` ensures only the ones registered before it will run.\n\n**Example for `stopImmediatePropagation()`:**\n```html\n<button id=\"myButton\">Click Me</button>\n\n<script>\n  const button = document.getElementById('myButton');\n\n  button.addEventListener('click', function(e) {\n    console.log('Handler 1: This will always run.');\n    e.stopImmediatePropagation(); // Stops further handlers on this element AND bubbling\n  });\n\n  button.addEventListener('click', function(e) {\n    console.log('Handler 2: This will NOT run because Handler 1 called stopImmediatePropagation.');\n  });\n\n  document.body.addEventListener('click', function(e) {\n    console.log('Body Handler: This will NOT run either due to stopImmediatePropagation from button.');\n  });\n</script>\n```\nIn this example, clicking 'myButton' will only log 'Handler 1'. 'Handler 2' (on the same button) and 'Body Handler' (on a parent element) will not execute.",
          "analysisPoints": [
            "Clear distinction between stopping propagation to ancestors vs. stopping propagation to sibling handlers.",
            "Accurate code example that highlights the unique effect of `stopImmediatePropagation()`."
          ],
          "keyConcepts": [
            "stopPropagation",
            "stopImmediatePropagation",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions.",
            "Effectiveness of the illustrative code.",
            "Understanding of specific use cases."
          ],
          "example": "See provided answer for code example.",
          "tags": [
            "DOM",
            "Events",
            "JavaScript"
          ],
          "prerequisites": [
            "event_listeners",
            "event_propagation"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_stopping_propagation_3",
          "topic": "Combined Event Handling Scenario",
          "level": "hard",
          "type": "code",
          "question": "Given the following HTML and JavaScript, what will be printed to the console when the `link` element is clicked? Explain the behavior of each event handler.",
          "answer": "```javascript\n// Expected Output:\n// Link clicked! Default prevented.\n// Parent div click detected.\n```\n\n**Reasoning:**\n1.  **`link` click handler**: When the link is clicked, its first `addEventListener` is triggered. `e.preventDefault()` is called, which stops the default browser behavior of navigating to 'https://example.com'. `console.log('Link clicked! Default prevented.')` is then executed.\n2.  **`link` second click handler**: This handler is not affected by `e.preventDefault()`, as `preventDefault()` only stops the browser's default action, not propagation or other handlers on the same element. So, `console.log('Another handler on link.')` would normally run. *However*, there is no second handler on the `link` in the provided code snippet, only the `div`'s bubbling handler. If there was one, it would run.\n3.  **`div` click handler**: Since `e.preventDefault()` does *not* stop event propagation, the click event continues to bubble up to the `div` element. The `div`'s click listener then triggers, executing `console.log('Parent div click detected.')`.",
          "options": [],
          "analysisPoints": [
            "Understanding that `preventDefault()` doesn't stop propagation.",
            "Recognizing that events bubble up from target to ancestors.",
            "Correctly predicting the console output based on event flow."
          ],
          "keyConcepts": [
            "preventDefault",
            "Event Bubbling",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Accurate prediction of console logs.",
            "Clear explanation of `preventDefault()`'s scope.",
            "Demonstrated understanding of event flow."
          ],
          "example": "```html\n<div id=\"parentDiv\" style=\"padding: 20px; background-color: lightblue;\">\n  Parent Div\n  <a href=\"https://example.com\" id=\"link\" style=\"display: block; margin-top: 10px;\">Click Me Link</a>\n</div>\n\n<script>\n  document.getElementById('link').addEventListener('click', function(e) {\n    e.preventDefault(); // Prevents navigation\n    console.log('Link clicked! Default prevented.');\n    // Event still bubbles\n  });\n\n  document.getElementById('parentDiv').addEventListener('click', function(e) {\n    console.log('Parent div click detected.');\n  });\n</script>\n```",
          "tags": [
            "DOM",
            "Events",
            "JavaScript",
            "preventDefault",
            "Event Propagation"
          ],
          "prerequisites": [
            "event_listeners",
            "event_propagation",
            "stopping_event_propagation_default"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_stopping_propagation_flashcard_1",
          "topic": "Preventing Default Behavior",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `event.preventDefault()`?",
          "answer": "To stop the browser's default action associated with an event (e.g., submitting a form, navigating a link) without necessarily stopping event propagation.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "preventDefault",
            "Event Handling"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "DOM",
            "Events",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_delegation_1",
          "topic": "Benefits of Event Delegation",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a primary benefit of using event delegation?",
          "answer": "It automatically adjusts event listeners if the DOM structure changes drastically.",
          "options": [
            "Reduced memory footprint due to fewer event listeners.",
            "Automatic handling of dynamically added elements.",
            "Simplified code by reducing the need for attach/detach logic.",
            "It automatically adjusts event listeners if the DOM structure changes drastically."
          ],
          "analysisPoints": [
            "Recalling the core benefits of event delegation (efficiency, dynamic elements, simpler code).",
            "Identifying a statement that is not a direct benefit or is misleading (structural changes may still require re-evaluation of target logic, but not listener re-attachment).",
            "Understanding that 'drastically' changed DOM structure might still require changes to the delegation logic itself, even if listeners don't need re-attaching."
          ],
          "keyConcepts": [
            "Event Delegation",
            "Performance",
            "Dynamic Elements"
          ],
          "evaluationCriteria": [
            "Correctly identifying non-benefits.",
            "Understanding the scope of event delegation's advantages."
          ],
          "example": "Event delegation's strength is that it manages events for current and future children within a *stable* parent. While adding/removing children is fine, a fundamental restructuring of the *parent-child relationship* or the `tagName` logic used within the delegate might still require code changes, which is what the incorrect option implies.",
          "tags": [
            "DOM",
            "Events",
            "Event Delegation",
            "Performance"
          ],
          "prerequisites": [
            "event_propagation"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_delegation_2",
          "topic": "Implementing Event Delegation",
          "level": "medium",
          "type": "code",
          "question": "You have an unordered list (`<ul>`) with several list items (`<li>`). You want to log the text content of any `<li>` that is clicked. Demonstrate how to achieve this using event delegation, including how to handle `e.target`.",
          "answer": "```html\n<ul id=\"myList\">\n  <li>Item One</li>\n  <li>Item Two</li>\n  <li>Item Three</li>\n</ul>\n\n<script>\n  const myList = document.getElementById('myList');\n\n  myList.addEventListener('click', function(e) {\n    // Check if the clicked element (e.target) is an <li>\n    if (e.target.tagName === 'LI') {\n      console.log('Clicked item:', e.target.textContent);\n      // You could also add more specific checks, e.g., by class name:\n      // if (e.target.classList.contains('clickable-item')) {\n      //   console.log('Clickable item clicked:', e.target.textContent);\n      // }\n    }\n  });\n</script>\n```",
          "options": [],
          "analysisPoints": [
            "Correctly attaching the listener to the parent (`ul`).",
            "Using `e.target` to identify the specific child element that was clicked.",
            "Implementing a check (e.g., `tagName`) to ensure the target is the desired element type.",
            "Accessing properties like `textContent` from `e.target`."
          ],
          "keyConcepts": [
            "Event Delegation",
            "e.target",
            "Event Bubbling",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Correct implementation of event delegation.",
            "Proper use of `e.target`.",
            "Clear and functional code."
          ],
          "example": "The code demonstrates attaching a single click listener to the `<ul>` element. When a click occurs anywhere within the `<ul>`, the event bubbles up to it. Inside the handler, `e.target` is used to identify the actual element that was clicked (e.g., one of the `<li>`s). A check ensures that only clicks on `<li>` elements are processed, and their `textContent` is logged.",
          "tags": [
            "DOM",
            "Events",
            "Event Delegation",
            "JavaScript"
          ],
          "prerequisites": [
            "event_propagation",
            "event_listeners"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_delegation_3",
          "topic": "Event Delegation vs. Individual Listeners",
          "level": "hard",
          "type": "open",
          "question": "You are building a dynamic photo gallery where users can add or remove images. Each image, when clicked, should open a full-screen viewer. Discuss the advantages of using event delegation for this feature compared to attaching individual listeners to each image element. How would you handle clicks on non-image elements within the gallery container?",
          "answer": "**Advantages of Event Delegation:**\n1.  **Memory Efficiency**: Instead of `N` listeners for `N` images, only one listener is needed on the gallery container. This significantly reduces memory consumption, especially with many images.\n2.  **Dynamic Elements**: When new images are added or existing ones are removed, no manual `addEventListener` or `removeEventListener` calls are needed. The single delegated listener on the container will automatically handle events for all current and future images.\n3.  **Simplified Code**: Less boilerplate code is required for managing listeners, leading to cleaner and more maintainable code.\n4.  **Performance**: Fewer active listeners in the DOM can lead to better overall performance, especially during DOM mutations.\n\n**Handling Clicks on Non-Image Elements:**\nWhen using event delegation, the listener is on a parent element, so clicks on *any* child of that parent will trigger the handler. To ensure only image clicks are processed, you'd check `e.target` within the delegated handler:\n\n```javascript\nconst gallery = document.getElementById('photoGallery');\n\ngallery.addEventListener('click', function(e) {\n  // Check if the clicked element (e.target) is an <img> tag\n  // Or, if images have a specific class, e.g., 'gallery-image'\n  if (e.target.tagName === 'IMG' || e.target.classList.contains('gallery-image')) {\n    console.log('Image clicked:', e.target.src); // Or e.target.dataset.imageId\n    openFullScreenViewer(e.target.src);\n  } else {\n    // Optionally handle clicks on non-image elements, or do nothing\n    console.log('Clicked on a non-image element within the gallery:', e.target.tagName);\n  }\n});\n\nfunction openFullScreenViewer(imageUrl) {\n  // Logic to display image in full-screen\n  alert('Opening: ' + imageUrl);\n}\n```\nThis approach ensures that clicks on elements like text descriptions, navigation buttons, or placeholders within the gallery container are ignored or handled differently without interfering with the image click logic.",
          "analysisPoints": [
            "Thorough understanding of event delegation benefits.",
            "Ability to compare delegated vs. individual listener approaches.",
            "Practical application of `e.target` to filter events.",
            "Consideration of edge cases (non-target clicks)."
          ],
          "keyConcepts": [
            "Event Delegation",
            "Performance Optimization",
            "Dynamic Content",
            "e.target",
            "DOM Events"
          ],
          "evaluationCriteria": [
            "Comprehensive enumeration of advantages.",
            "Clear and correct explanation of event filtering.",
            "Appropriate code example for the scenario."
          ],
          "example": "See provided answer for code example.",
          "tags": [
            "DOM",
            "Events",
            "Event Delegation",
            "Performance",
            "Architecture"
          ],
          "prerequisites": [
            "event_delegation",
            "dom_manipulation"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_delegation_flashcard_1",
          "topic": "Event Delegation Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is event delegation?",
          "answer": "A technique where you attach a single event listener to a common ancestor element, rather than individual listeners to multiple descendant elements, leveraging event bubbling to handle events.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Event Delegation",
            "Event Bubbling"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "DOM",
            "Events",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_await_1",
          "topic": "Async/Await Basics",
          "level": "easy",
          "type": "mcq",
          "question": "Which statement about `async` and `await` is true?",
          "answer": "An `async` function always returns a Promise.",
          "options": [
            "The `await` keyword can be used anywhere in JavaScript code.",
            "An `async` function always returns a Promise.",
            "Using `async/await` makes JavaScript code blocking.",
            "`await` can only be used with synchronous functions."
          ],
          "analysisPoints": [
            "Understanding that `await` must be inside an `async` function.",
            "Knowing that `async` functions always return Promises.",
            "Clarifying that `async/await` is non-blocking.",
            "Recognizing that `await` is for Promises (asynchronous operations)."
          ],
          "keyConcepts": [
            "async",
            "await",
            "Promises",
            "Asynchronous JavaScript"
          ],
          "evaluationCriteria": [
            "Correctly identifying core characteristics of `async`/`await`.",
            "Dispelling common misconceptions (blocking nature, placement of `await`)."
          ],
          "example": "```javascript\nasync function myFunction() {\n  return 10; // This will return Promise.resolve(10)\n}\nmyFunction().then(value => console.log(value)); // Logs 10\n\nasync function otherFunction() {\n  const result = await Promise.resolve(5);\n  console.log(result); // Logs 5 after the promise resolves\n}\notherFunction();\n```",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Promises"
          ],
          "prerequisites": [
            "promises"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_await_2",
          "topic": "Async/Await Error Handling",
          "level": "medium",
          "type": "code",
          "question": "Write an `async` function called `fetchUserData` that takes a `userId`. Inside this function, simulate fetching user data from an API that might fail. Implement error handling using `try...catch` such that if the fetch fails, it logs an error message and returns `null`.",
          "answer": "```javascript\nasync function simulateFetchUser(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 1) {\n        resolve({ id: 1, name: 'Alice', email: 'alice@example.com' });\n      } else if (userId === 2) {\n        reject(new Error('User with ID 2 not found.'));\n      } else {\n        reject(new Error('Invalid user ID provided.'));\n      }\n    }, 500);\n  });\n}\n\nasync function fetchUserData(userId) {\n  try {\n    console.log(`Attempting to fetch user with ID: ${userId}`);\n    const userData = await simulateFetchUser(userId);\n    console.log(`Successfully fetched user: ${JSON.stringify(userData)}`);\n    return userData;\n  } catch (error) {\n    console.error(`Error fetching user ${userId}: ${error.message}`);\n    return null; // Return null or a default value on error\n  }\n}\n\n// Test cases\n(async () => {\n  await fetchUserData(1); // Should succeed\n  await fetchUserData(2); // Should fail (User not found)\n  await fetchUserData(3); // Should fail (Invalid user ID)\n})();\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `async` keyword.",
            "Proper use of `await` with a Promise.",
            "Implementation of `try...catch` for error handling.",
            "Handling the rejected Promise from `await` by logging and returning `null`.",
            "Providing simulated asynchronous operation (Promise with `setTimeout`)."
          ],
          "keyConcepts": [
            "async",
            "await",
            "Error Handling",
            "Promises",
            "try...catch"
          ],
          "evaluationCriteria": [
            "Functional `async` function.",
            "Correct error handling implementation.",
            "Clear and understandable code."
          ],
          "example": "See provided answer for code example.",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Error Handling",
            "Promises"
          ],
          "prerequisites": [
            "promises",
            "async_await_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_await_3",
          "topic": "Async/Await Execution Flow",
          "level": "hard",
          "type": "code",
          "question": "Analyze the following JavaScript code. What will be the exact order of console logs? Explain why.",
          "answer": "```javascript\n// Expected Output:\n// Start\n// Before await\n// Function call complete (non-blocking)\n// After await (resolved)\n```\n\n**Reasoning:**\n1.  **`console.log('Start');`**: This is the first synchronous line of code, so it executes immediately.\n2.  **`console.log('Before await');`**: `myAsyncFunction` is called. The first line inside it is synchronous, so it logs immediately.\n3.  **`await delay(1000);`**: The `await` keyword pauses the execution of `myAsyncFunction`. It does *not* pause the entire program. The `delay` function returns a Promise that will resolve after 1 second. The `myAsyncFunction` is suspended, and control is returned to the event loop.\n4.  **`console.log('Function call complete (non-blocking)');`**: This line is outside the `async` function and runs immediately after `myAsyncFunction` is called and pauses at `await`. This demonstrates the non-blocking nature of `async/await`.\n5.  **`// 1 second delay passes`**\n6.  **`console.log('After await (resolved)');`**: After 1 second, the `delay(1000)` Promise resolves. The `myAsyncFunction` resumes execution from where it left off (after the `await`), and this line is logged.",
          "options": [],
          "analysisPoints": [
            "Understanding that `await` pauses only the `async` function, not the entire program.",
            "Identifying synchronous vs. asynchronous execution parts.",
            "Correctly predicting the interleaving of logs due to the event loop."
          ],
          "keyConcepts": [
            "async",
            "await",
            "Event Loop",
            "Asynchronous JavaScript"
          ],
          "evaluationCriteria": [
            "Accurate prediction of console output.",
            "Clear explanation of `async`/`await`'s non-blocking behavior.",
            "Demonstrated understanding of the JavaScript Event Loop."
          ],
          "example": "```javascript\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function myAsyncFunction() {\n  console.log('Before await');\n  await delay(1000); // This pauses the function for 1 second\n  console.log('After await (resolved)');\n}\n\nconsole.log('Start');\nmyAsyncFunction();\nconsole.log('Function call complete (non-blocking)');\n```",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Event Loop",
            "Concurrency"
          ],
          "prerequisites": [
            "promises",
            "async_await_basics",
            "event_loop_concept"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_await_flashcard_1",
          "topic": "Async/Await Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using `async/await`?",
          "answer": "It makes asynchronous code look and behave like synchronous code, improving readability and maintainability while retaining non-blocking behavior.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "async",
            "await",
            "Readability",
            "Asynchronous JavaScript"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_await_error_1",
          "topic": "Error Handling in Async/Await",
          "level": "easy",
          "type": "mcq",
          "question": "How should errors (rejected Promises) be handled within an `async` function using `await`?",
          "answer": "Using a `try...catch` block around the `await` expression.",
          "options": [
            "Using a `.then().catch()` chain after the `await`.",
            "Using a `try...catch` block around the `await` expression.",
            "Errors are automatically caught by the surrounding function without explicit `try...catch`.",
            "Only global error handlers can catch errors from `await`."
          ],
          "analysisPoints": [
            "Identifying the standard pattern for error handling with `async/await`.",
            "Differentiating from Promise chaining, which `async/await` simplifies.",
            "Understanding that `await` effectively converts Promise rejections into thrown errors."
          ],
          "keyConcepts": [
            "Error Handling",
            "async",
            "await",
            "try...catch"
          ],
          "evaluationCriteria": [
            "Correctly identifying the `try...catch` pattern.",
            "Understanding how `await` integrates with traditional error handling."
          ],
          "example": "```javascript\nasync function mightFail() {\n  return Promise.reject(new Error('Something went wrong!'));\n}\n\nasync function process() {\n  try {\n    const result = await mightFail();\n    console.log(result);\n  } catch (error) {\n    console.error('Caught an error:', error.message);\n  }\n}\nprocess(); // Will log 'Caught an error: Something went wrong!'\n```",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Error Handling"
          ],
          "prerequisites": [
            "async_await_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_await_error_2",
          "topic": "AbortController for Timeouts",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of `AbortController` in implementing a timeout for a `fetch` request with `async/await`. Describe the sequence of steps involved.",
          "answer": "The `AbortController` API provides a mechanism to cancel (abort) DOM requests like `fetch`. It's crucial for timeouts because `fetch` itself doesn't have a built-in timeout option.\n\n**Role of `AbortController`:**\n`AbortController` creates an `AbortSignal` object, which can be associated with an `fetch` request. When `controller.abort()` is called, the signal is triggered, causing any associated `fetch` request to immediately reject with an `AbortError` (a DOMException).\n\n**Sequence of Steps for Timeout:**\n1.  **Instantiate `AbortController`**: Create `const controller = new AbortController();`.\n2.  **Get the Signal**: Access the signal: `const signal = controller.signal;`.\n3.  **Set Timeout for Abort**: Use `setTimeout` to call `controller.abort()` after the desired timeout duration: `const timeoutId = setTimeout(() => controller.abort(), timeoutMs);`.\n4.  **Pass Signal to `fetch`**: Include the `signal` in the `fetch` options: `const response = await fetch(url, { signal });`.\n5.  **Clear Timeout**: If the `fetch` request resolves or rejects for reasons *other than* a timeout (e.g., successful response, network error), call `clearTimeout(timeoutId)` to prevent `controller.abort()` from being called unnecessarily.\n6.  **Handle AbortError**: In the `catch` block of the `try...catch` surrounding the `fetch`, check if `error.name === 'AbortError'` to specifically handle the timeout case, distinguishing it from other network errors.",
          "analysisPoints": [
            "Understanding `AbortController`'s purpose.",
            "Correctly outlining the steps to implement a timeout.",
            "Knowing how to differentiate `AbortError` from other errors.",
            "Importance of `clearTimeout`."
          ],
          "keyConcepts": [
            "AbortController",
            "fetch API",
            "Timeouts",
            "Asynchronous Programming",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Clear and concise explanation.",
            "Accurate step-by-step process.",
            "Demonstrated knowledge of `AbortController` and error types."
          ],
          "example": "See `theory_async_await_error_handling_timeout` for the code example. It clearly shows the usage of `AbortController` within a `fetchWithTimeout` function.",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Network",
            "Error Handling",
            "API"
          ],
          "prerequisites": [
            "async_await_basics",
            "fetch_api",
            "promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_await_error_3",
          "topic": "Chaining Async Operations with Error Handling",
          "level": "hard",
          "type": "code",
          "question": "Implement an `async` function `processUserWorkflow` that performs the following steps in sequence:\n1.  `fetchUser(id)`: Fetches user data. Should simulate a network error (reject) if `id` is 0.\n2.  `validateUser(user)`: Validates user data. Should simulate a validation error (reject) if `user.name` is empty.\n3.  `saveUser(user)`: Saves the user data. Should always resolve.\n\nYour `processUserWorkflow` function should use `async/await` and handle errors at each step, logging a specific message for each type of error. If any step fails, the subsequent steps should not execute, and the function should return `false`. If all steps succeed, it should return `true`.",
          "answer": "```javascript\nasync function fetchUser(id) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id === 0) {\n        reject(new Error('Network Error: User ID 0 is reserved.'));\n      } else {\n        resolve({ id: id, name: id === 99 ? '' : `User ${id}`, email: `user${id}@example.com` });\n      }\n    }, 500);\n  });\n}\n\nasync function validateUser(user) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!user || !user.name) {\n        reject(new Error('Validation Error: User name cannot be empty.'));\n      } else {\n        resolve(user);\n      }\n    }, 200);\n  });\n}\n\nasync function saveUser(user) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`User ${user.id} saved successfully!`);\n      resolve(true);\n    }, 300);\n  });\n}\n\nasync function processUserWorkflow(userId) {\n  let user;\n  try {\n    console.log(`Starting workflow for user ${userId}...`);\n    user = await fetchUser(userId);\n    console.log(`User ${userId} fetched.`);\n\n    await validateUser(user);\n    console.log(`User ${userId} validated.`);\n\n    await saveUser(user);\n    console.log(`Workflow for user ${userId} completed successfully.`);\n    return true;\n  } catch (error) {\n    if (error.message.includes('Network Error')) {\n      console.error(`Workflow Failed: ${error.message}`);\n    } else if (error.message.includes('Validation Error')) {\n      console.error(`Workflow Failed: ${error.message}`);\n    } else {\n      console.error(`An unexpected error occurred during workflow for user ${userId}: ${error.message}`);\n    }\n    return false;\n  }\n}\n\n// Test cases\n(async () => {\n  console.log('\\n--- Test Case 1: Success ---');\n  let result1 = await processUserWorkflow(1);\n  console.log(`Result for user 1: ${result1}`); // Expected: true\n\n  console.log('\\n--- Test Case 2: Network Error ---');\n  let result2 = await processUserWorkflow(0);\n  console.log(`Result for user 0: ${result2}`); // Expected: false\n\n  console.log('\\n--- Test Case 3: Validation Error ---');\n  let result3 = await processUserWorkflow(99); // Simulates empty name\n  console.log(`Result for user 99: ${result3}`); // Expected: false\n})();\n```",
          "options": [],
          "analysisPoints": [
            "Correctly structuring chained `await` calls.",
            "Centralized `try...catch` block for multiple `await` calls.",
            "Differentiating error types using `error.message` or custom error classes.",
            "Returning appropriate boolean status.",
            "Simulating realistic async operations and failures."
          ],
          "keyConcepts": [
            "async",
            "await",
            "Promises",
            "Error Handling",
            "Chaining Asynchronous Operations",
            "Control Flow"
          ],
          "evaluationCriteria": [
            "Functional, robust `async` workflow.",
            "Effective error handling for different failure points.",
            "Correct return values based on success/failure.",
            "Readable and maintainable code structure."
          ],
          "example": "See provided answer for comprehensive code example and test cases.",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Error Handling",
            "Workflow",
            "Promises"
          ],
          "prerequisites": [
            "async_await_basics",
            "async_await_error_handling_timeout"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_await_error_flashcard_1",
          "topic": "Aborting Fetch Requests",
          "level": "medium",
          "type": "flashcard",
          "question": "Which API is commonly used with `fetch` to cancel a request, often for implementing timeouts?",
          "answer": "The `AbortController` API.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "AbortController",
            "fetch API",
            "Timeouts"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "JavaScript",
            "Network",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_event_propagation_visualizer",
          "title": "Interactive Event Propagation Visualizer",
          "description": "\nCreate a simple HTML page with nested `div` elements (e.g., Grandparent > Parent > Child). Attach click event listeners to each `div`.\n\n**Requirements:**\n1.  Each `div` should display its name (e.g., 'Grandparent', 'Parent', 'Child').\n2.  When a `div` is clicked, log to the console the `id` of the element, the `event.target.id`, the `event.currentTarget.id`, and indicate if the listener is for the 'capturing' or 'bubbling' phase.\n3.  Implement listeners for *both* capturing and bubbling phases on all three `div`s.\n4.  Add a button to the child div. When clicked, it should call `e.stopPropagation()` and log a message indicating that propagation was stopped.\n5.  Visually distinguish the `div`s (e.g., with different background colors and borders).\n\nYour solution should help demonstrate the order of event propagation and the effect of `stopPropagation()`.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Propagation Visualizer</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    .grandparent, .parent, .child {\n      padding: 20px;\n      border: 2px solid black;\n      margin: 10px;\n      text-align: center;\n      font-weight: bold;\n    }\n    .grandparent { background-color: #e0f2f7; border-color: blue; }\n    .parent { background-color: #c8e6c9; border-color: green; }\n    .child { background-color: #ffe0b2; border-color: orange; }\n    button { margin-top: 10px; padding: 5px 10px; }\n  </style>\n</head>\n<body>\n  <div id=\"grandparent\" class=\"grandparent\">\n    Grandparent\n    <div id=\"parent\" class=\"parent\">\n      Parent\n      <div id=\"child\" class=\"child\">\n        Child\n        <button id=\"stopBtn\">Stop Propagation</button>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    const grandparent = document.getElementById('grandparent');\n    const parent = document.getElementById('parent');\n    const child = document.getElementById('child');\n    const stopBtn = document.getElementById('stopBtn');\n\n    // TODO: Add event listeners for capturing and bubbling phases for grandparent, parent, and child\n    // TODO: Implement stopPropagation on the stopBtn click handler\n\n  </script>\n</body>\n</html>",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Propagation Visualizer</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    .grandparent, .parent, .child {\n      padding: 20px;\n      border: 2px solid black;\n      margin: 10px;\n      text-align: center;\n      font-weight: bold;\n    }\n    .grandparent { background-color: #e0f2f7; border-color: blue; }\n    .parent { background-color: #c8e6c9; border-color: green; }\n    .child { background-color: #ffe0b2; border-color: orange; }\n    button { margin-top: 10px; padding: 5px 10px; }\n  </style>\n</head>\n<body>\n  <div id=\"grandparent\" class=\"grandparent\">\n    Grandparent\n    <div id=\"parent\" class=\"parent\">\n      Parent\n      <div id=\"child\" class=\"child\">\n        Child\n        <button id=\"stopBtn\">Stop Propagation</button>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    const grandparent = document.getElementById('grandparent');\n    const parent = document.getElementById('parent');\n    const child = document.getElementById('child');\n    const stopBtn = document.getElementById('stopBtn');\n\n    function addListeners(element, name) {\n      element.addEventListener('click', function(e) {\n        console.log(`[${name} - Capturing] target: ${e.target.id}, currentTarget: ${e.currentTarget.id}`);\n      }, true); // Capturing Phase\n\n      element.addEventListener('click', function(e) {\n        console.log(`[${name} - Bubbling] target: ${e.target.id}, currentTarget: ${e.currentTarget.id}`);\n      }, false); // Bubbling Phase\n    }\n\n    addListeners(grandparent, 'Grandparent');\n    addListeners(parent, 'Parent');\n    addListeners(child, 'Child');\n\n    stopBtn.addEventListener('click', function(e) {\n      console.log('Stop Button Clicked! Calling stopPropagation().');\n      e.stopPropagation();\n    });\n  </script>\n</body>\n</html>",
          "testCases": [
            "Click the 'Grandparent' div: Only Grandparent capturing and bubbling logs should appear.",
            "Click the 'Parent' div: Grandparent capturing -> Parent capturing -> Parent bubbling -> Grandparent bubbling logs should appear.",
            "Click the 'Child' div: Grandparent capturing -> Parent capturing -> Child capturing -> Child bubbling -> Parent bubbling -> Grandparent bubbling logs should appear.",
            "Click the 'Stop Propagation' button: Grandparent capturing -> Parent capturing -> Child capturing -> 'Stop Button Clicked!' log should appear, and then propagation should stop. No bubbling logs from Child, Parent, or Grandparent should appear."
          ],
          "hints": [
            "Remember that `event.target` is the element where the event originated, while `event.currentTarget` is the element to which the event listener is currently attached.",
            "The third argument of `addEventListener` (or the `capture` property in the options object) is key for distinguishing between capturing and bubbling phase listeners.",
            "Test clicking different elements to observe the full propagation path."
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Propagation",
            "JavaScript",
            "Front-end Basics"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "event_propagation",
            "event_listeners"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "event_delegation",
            "stopPropagation"
          ]
        },
        {
          "id": "task_form_validation_and_propagation",
          "title": "Preventing Default Form Submission with Event Propagation Control",
          "description": "\nCreate an HTML form with a text input, a checkbox, and a submit button inside a `div` container. Implement client-side validation and demonstrate control over event propagation.\n\n**Requirements:**\n1.  When the form is submitted:\n    *   Prevent the default form submission (page reload).\n    *   Validate that the text input is not empty and the checkbox is checked.\n    *   If validation fails, display an error message below the form.\n    *   If validation passes, display a success message.\n2.  Add a click listener to the `div` container that wraps the form. This listener should log a message indicating that a click inside the container occurred.\n3.  Add a click listener directly to the submit button that logs 'Submit button clicked' and uses `e.stopImmediatePropagation()`.\n4.  Add a *second* click listener directly to the submit button that logs 'This should NOT appear'.\n\nObserve and explain the console output when you submit the form, especially noting the effects of `preventDefault()` and `stopImmediatePropagation()`.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Form Validation & Propagation Control</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    .container { padding: 20px; border: 2px solid purple; margin-bottom: 20px; }\n    form { border: 1px solid #ccc; padding: 15px; }\n    label, input { display: block; margin-bottom: 10px; }\n    .error, .success { color: red; font-weight: bold; margin-top: 10px; }\n    .success { color: green; }\n  </style>\n</head>\n<body>\n  <div id=\"formContainer\" class=\"container\">\n    <h2>User Registration Form</h2>\n    <form id=\"myForm\">\n      <label for=\"username\">Username:</label>\n      <input type=\"text\" id=\"username\" name=\"username\">\n      \n      <input type=\"checkbox\" id=\"agree\" name=\"agree\">\n      <label for=\"agree\">I agree to terms and conditions</label>\n      \n      <button type=\"submit\" id=\"submitBtn\">Register</button>\n    </form>\n    <p id=\"message\"></p>\n  </div>\n\n  <script>\n    const form = document.getElementById('myForm');\n    const usernameInput = document.getElementById('username');\n    const agreeCheckbox = document.getElementById('agree');\n    const messagePara = document.getElementById('message');\n    const formContainer = document.getElementById('formContainer');\n    const submitBtn = document.getElementById('submitBtn');\n\n    // TODO: Add event listeners for form submission, container click, and submit button clicks\n\n  </script>\n</body>\n</html>",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Form Validation & Propagation Control</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    .container { padding: 20px; border: 2px solid purple; margin-bottom: 20px; }\n    form { border: 1px solid #ccc; padding: 15px; }\n    label, input { display: block; margin-bottom: 10px; }\n    .error, .success { color: red; font-weight: bold; margin-top: 10px; }\n    .success { color: green; }\n  </style>\n</head>\n<body>\n  <div id=\"formContainer\" class=\"container\">\n    <h2>User Registration Form</h2>\n    <form id=\"myForm\">\n      <label for=\"username\">Username:</label>\n      <input type=\"text\" id=\"username\" name=\"username\">\n      \n      <input type=\"checkbox\" id=\"agree\" name=\"agree\">\n      <label for=\"agree\">I agree to terms and conditions</label>\n      \n      <button type=\"submit\" id=\"submitBtn\">Register</button>\n    </form>\n    <p id=\"message\"></p>\n  </div>\n\n  <script>\n    const form = document.getElementById('myForm');\n    const usernameInput = document.getElementById('username');\n    const agreeCheckbox = document.getElementById('agree');\n    const messagePara = document.getElementById('message');\n    const formContainer = document.getElementById('formContainer');\n    const submitBtn = document.getElementById('submitBtn');\n\n    // 1. Form submission handler\n    form.addEventListener('submit', function(e) {\n      e.preventDefault(); // Prevent default page reload\n      messagePara.textContent = ''; // Clear previous messages\n      messagePara.className = '';\n\n      const username = usernameInput.value.trim();\n      const agreed = agreeCheckbox.checked;\n\n      if (username === '') {\n        messagePara.textContent = 'Error: Username cannot be empty.';\n        messagePara.className = 'error';\n        return;\n      }\n      if (!agreed) {\n        messagePara.textContent = 'Error: You must agree to the terms.';\n        messagePara.className = 'error';\n        return;\n      }\n\n      messagePara.textContent = 'Success! Form submitted.';\n      messagePara.className = 'success';\n      console.log('Form submission processed (validation passed).');\n    });\n\n    // 2. Container click listener\n    formContainer.addEventListener('click', function(e) {\n      console.log(`Container click detected. Target: ${e.target.id || e.target.tagName}. CurrentTarget: ${e.currentTarget.id}`);\n    });\n\n    // 3. First submit button click listener with stopImmediatePropagation\n    submitBtn.addEventListener('click', function(e) {\n      console.log('Submit button clicked! (Handler 1)');\n      e.stopImmediatePropagation(); // Stops further handlers on this button and bubbling\n    });\n\n    // 4. Second submit button click listener (will not run)\n    submitBtn.addEventListener('click', function(e) {\n      console.log('This should NOT appear! (Handler 2)');\n    });\n  </script>\n</body>\n</html>",
          "testCases": [
            "Submit an empty form: Should display 'Username cannot be empty.' and not reload. Console should show 'Submit button clicked! (Handler 1)'.",
            "Submit with username but unchecked checkbox: Should display 'You must agree to the terms.' and not reload. Console should show 'Submit button clicked! (Handler 1)'.",
            "Submit with valid username and checked checkbox: Should display 'Success!' and not reload. Console should show 'Submit button clicked! (Handler 1)' and 'Form submission processed (validation passed).'",
            "Click anywhere inside the container but not on the button (e.g., on the label): Container click log should appear.",
            "Observe console: Verify that 'This should NOT appear!' never logs and that 'Container click detected' does not log when the submit button is clicked (due to `stopImmediatePropagation`)."
          ],
          "hints": [
            "Remember that `preventDefault()` prevents the browser's default action, but it does *not* stop event propagation. `stopPropagation()` or `stopImmediatePropagation()` are needed for that.",
            "`submit` events on forms can be triggered by clicking a submit button or pressing Enter in a text field.",
            "Pay close attention to the order of `addEventListener` calls when testing `stopImmediatePropagation()`."
          ],
          "tags": [
            "DOM",
            "Forms",
            "Events",
            "Validation",
            "JavaScript",
            "stopPropagation",
            "preventDefault",
            "stopImmediatePropagation"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "event_propagation",
            "stopping_event_propagation_default",
            "form_handling"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "event_delegation",
            "client_side_validation"
          ]
        },
        {
          "id": "task_dynamic_list_management",
          "title": "Interactive Shopping List with Event Delegation",
          "description": "\nBuild a simple interactive shopping list application. Users should be able to add new items, mark items as 'purchased', and remove items.\n\n**Requirements:**\n1.  **Add Item**: An input field and a 'Add Item' button. When the button is clicked, the text from the input field should be added as a new `<li>` to an unordered list (`<ul>`). The input field should be cleared after adding.\n2.  **Mark as Purchased**: When an `<li>` is clicked, toggle a 'purchased' class on it. This class should apply a strikethrough style.\n3.  **Remove Item**: Each `<li>` should have a 'Remove' button next to it. Clicking this button should remove the corresponding `<li>` from the list.\n4.  **Event Delegation**: Crucially, *all* interactions (marking as purchased, removing) on list items should be handled using **event delegation** on the `<ul>` element. This means only one click listener on the `<ul>` for handling clicks on dynamically added `<li>`s and their nested 'Remove' buttons.\n",
          "difficulty": "hard",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Shopping List with Delegation</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    ul { list-style: none; padding: 0; }\n    li { background-color: #f0f0f0; padding: 10px; margin-bottom: 5px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }\n    li.purchased { text-decoration: line-through; background-color: #d4edda; color: #505050; }\n    li button { background-color: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; }\n    #addItemContainer { margin-bottom: 20px; }\n    #addItemInput { padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-right: 10px; }\n    #addItemButton { background-color: #007bff; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; }\n  </style>\n</head>\n<body>\n  <h1>My Shopping List</h1>\n\n  <div id=\"addItemContainer\">\n    <input type=\"text\" id=\"addItemInput\" placeholder=\"Add a new item\">\n    <button id=\"addItemButton\">Add Item</button>\n  </div>\n\n  <ul id=\"shoppingList\">\n    <!-- Dynamic items will go here -->\n  </ul>\n\n  <script>\n    const addItemInput = document.getElementById('addItemInput');\n    const addItemButton = document.getElementById('addItemButton');\n    const shoppingList = document.getElementById('shoppingList');\n\n    // TODO: Implement adding new items\n\n    // TODO: Implement event delegation for mark/remove actions\n\n  </script>\n</body>\n</html>",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Shopping List with Delegation</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    ul { list-style: none; padding: 0; }\n    li { background-color: #f0f0f0; padding: 10px; margin-bottom: 5px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }\n    li.purchased { text-decoration: line-through; background-color: #d4edda; color: #505050; }\n    li button { background-color: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; }\n    #addItemContainer { margin-bottom: 20px; }\n    #addItemInput { padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-right: 10px; }\n    #addItemButton { background-color: #007bff; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; }\n  </style>\n</head>\n<body>\n  <h1>My Shopping List</h1>\n\n  <div id=\"addItemContainer\">\n    <input type=\"text\" id=\"addItemInput\" placeholder=\"Add a new item\">\n    <button id=\"addItemButton\">Add Item</button>\n  </div>\n\n  <ul id=\"shoppingList\">\n    <!-- Dynamic items will go here -->\n  </ul>\n\n  <script>\n    const addItemInput = document.getElementById('addItemInput');\n    const addItemButton = document.getElementById('addItemButton');\n    const shoppingList = document.getElementById('shoppingList');\n\n    // Function to add new list item\n    addItemButton.addEventListener('click', function() {\n      const itemText = addItemInput.value.trim();\n      if (itemText === '') return;\n\n      const listItem = document.createElement('li');\n      listItem.innerHTML = `\n        <span>${itemText}</span>\n        <button class=\"remove-btn\">Remove</button>\n      `;\n      shoppingList.appendChild(listItem);\n      addItemInput.value = ''; // Clear input\n    });\n\n    // Event Delegation for mark as purchased and remove item\n    shoppingList.addEventListener('click', function(e) {\n      // Check if a remove button was clicked\n      if (e.target.classList.contains('remove-btn')) {\n        e.target.closest('li').remove(); // Remove the parent <li>\n      } \n      // Check if an <li> was clicked (but not on the remove button itself)\n      else if (e.target.tagName === 'LI' || e.target.closest('li')) {\n        // Use closest('li') to ensure we get the LI element even if a child span was clicked\n        const listItem = e.target.closest('li');\n        if (listItem) {\n            listItem.classList.toggle('purchased');\n        }\n      }\n    });\n  </script>\n</body>\n</html>",
          "testCases": [
            "Add a new item: Enter text and click 'Add Item'. Verify a new `<li>` appears.",
            "Click on a newly added item's text: Verify it gets the 'purchased' (strikethrough) style. Click again to remove the style.",
            "Click the 'Remove' button on a newly added item: Verify the item is removed from the list.",
            "Add multiple items, mark some, remove others: Ensure all functionalities work correctly for all items, demonstrating delegation.",
            "Verify no direct listeners are attached to `<li>` or `.remove-btn` elements."
          ],
          "hints": [
            "Attach only ONE event listener to the `<ul>` element.",
            "Use `event.target` inside the delegated listener to determine *what* exactly was clicked (the `<li>` text, or the 'Remove' button).",
            "You'll need `e.target.tagName` or `e.target.classList.contains()` to differentiate between a click on the `<li>` itself (for toggling 'purchased') and a click on the 'Remove' button.",
            "For removing an item, `e.target.closest('li')` can be useful to get the parent `<li>` element of the clicked 'Remove' button."
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Delegation",
            "Dynamic Content",
            "JavaScript",
            "Front-end Development"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "event_delegation",
            "dom_manipulation"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "single_page_application",
            "component_architecture"
          ]
        },
        {
          "id": "task_fetch_and_display_data",
          "title": "Asynchronous Data Fetching and Display",
          "description": "\nImplement a web page that fetches a list of users from a public API and displays them dynamically. Use `async/await` for the API call.\n\n**Requirements:**\n1.  Create an HTML structure with a button to 'Load Users' and an empty `<ul>` to display the users.\n2.  When the 'Load Users' button is clicked, make an asynchronous request to `https://jsonplaceholder.typicode.com/users`.\n3.  Use an `async` function and `await` for the `fetch` call.\n4.  Parse the JSON response.\n5.  For each user received, create a new `<li>` element containing the user's `name` and `email`, and append it to the `<ul>`.\n6.  Implement basic error handling: If the fetch fails (e.g., network error, invalid URL), log the error to the console and display an error message on the page instead of the user list.\n7.  Show a 'Loading...' message while the data is being fetched and remove it once data is displayed or an error occurs.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Fetch Users</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    #userList { list-style: none; padding: 0; }\n    #userList li { background-color: #f4f4f4; margin-bottom: 5px; padding: 10px; border-radius: 4px; }\n    .message { font-style: italic; color: gray; }\n    .error { color: red; font-weight: bold; }\n  </style>\n</head>\n<body>\n  <h1>User List</h1>\n  <button id=\"loadUsersBtn\">Load Users</button>\n  <p id=\"statusMessage\" class=\"message\"></p>\n  <ul id=\"userList\"></ul>\n\n  <script>\n    const loadUsersBtn = document.getElementById('loadUsersBtn');\n    const userList = document.getElementById('userList');\n    const statusMessage = document.getElementById('statusMessage');\n\n    // TODO: Implement the async function to fetch and display users\n\n    loadUsersBtn.addEventListener('click', () => {\n      // TODO: Call the async function and handle initial state/loading\n    });\n  </script>\n</body>\n</html>",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Fetch Users</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    #userList { list-style: none; padding: 0; }\n    #userList li { background-color: #f4f4f4; margin-bottom: 5px; padding: 10px; border-radius: 4px; }\n    .message { font-style: italic; color: gray; }\n    .error { color: red; font-weight: bold; }\n  </style>\n</head>\n<body>\n  <h1>User List</h1>\n  <button id=\"loadUsersBtn\">Load Users</button>\n  <p id=\"statusMessage\" class=\"message\"></p>\n  <ul id=\"userList\"></ul>\n\n  <script>\n    const loadUsersBtn = document.getElementById('loadUsersBtn');\n    const userList = document.getElementById('userList');\n    const statusMessage = document.getElementById('statusMessage');\n\n    async function fetchAndDisplayUsers() {\n      userList.innerHTML = ''; // Clear previous list\n      statusMessage.textContent = 'Loading users...';\n      statusMessage.className = 'message';\n\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/users');\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const users = await response.json();\n\n        if (users.length === 0) {\n          statusMessage.textContent = 'No users found.';\n          statusMessage.className = 'message';\n          return;\n        }\n\n        users.forEach(user => {\n          const listItem = document.createElement('li');\n          listItem.textContent = `${user.name} (${user.email})`;\n          userList.appendChild(listItem);\n        });\n\n        statusMessage.textContent = ''; // Clear loading message\n      } catch (error) {\n        console.error('Failed to fetch users:', error);\n        statusMessage.textContent = `Error: ${error.message}. Could not load users.`;\n        statusMessage.className = 'error';\n      }\n    }\n\n    loadUsersBtn.addEventListener('click', fetchAndDisplayUsers);\n\n    // Optional: Load users automatically on page load\n    // document.addEventListener('DOMContentLoaded', fetchAndDisplayUsers);\n  </script>\n</body>\n</html>",
          "testCases": [
            "Click 'Load Users' button: Verify 'Loading...' message appears, then disappears, and a list of users (e.g., Leanne Graham, Ervin Howell) is displayed.",
            "Simulate network error (e.g., change URL to `invalid-url`): Verify an error message is displayed on the page and logged to the console.",
            "Handle empty response (e.g., modify API to return `[]`): Verify 'No users found.' message is displayed.",
            "Multiple clicks: Ensure list is cleared and repopulated correctly on successive clicks."
          ],
          "hints": [
            "Remember to use `response.json()` to parse the response body into a JavaScript object.",
            "Check `response.ok` (or `response.status`) to handle HTTP errors explicitly, as `fetch` itself doesn't reject on HTTP error codes (like 404 or 500) by default.",
            "Clear previous content of `userList` before appending new items on subsequent loads.",
            "Manage the `statusMessage` text and class to provide visual feedback for loading and errors."
          ],
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Fetch API",
            "DOM Manipulation",
            "Error Handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "async_await_basics",
            "fetch_api"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "promises",
            "error_handling"
          ]
        },
        {
          "id": "task_robust_api_client",
          "title": "Building a Robust API Client with Timeout and Retry Logic",
          "description": "\nDevelop a robust `fetchWithRetryAndTimeout` function that can make HTTP GET requests. This function should include both a timeout mechanism and a retry strategy for transient network failures.\n\n**Requirements:**\n1.  **`fetchWithRetryAndTimeout(url, options)` function**: \n    *   Takes `url` and an `options` object. The `options` object can include `timeout` (in ms, default 5000) and `retries` (number of retries, default 3) properties.\n    *   Uses `async/await` and `AbortController` for the timeout.\n    *   If the request fails due to a network error (`TypeError` or `AbortError`), it should retry the request up to the specified `retries` count.\n    *   Include a small delay (e.g., 500ms) between retries to avoid overwhelming the server.\n    *   If all retries are exhausted or the error is not a network error (e.g., HTTP 4xx/5xx status), it should throw the final error.\n2.  **Usage Example**: Demonstrate its usage by fetching data from a hypothetical API endpoint that sometimes fails or is slow.\n    *   Make a call to `https://jsonplaceholder.typicode.com/todos/1?_delay=X` where `X` is a random delay to simulate slow/timeout cases.\n    *   Make a call to a non-existent URL or one that returns a 500 error to test retry logic.\n    *   Log success or failure messages clearly.\n",
          "difficulty": "hard",
          "startingCode": "```typescript\ninterface FetchOptions extends RequestInit {\n  timeout?: number;\n  retries?: number;\n}\n\nasync function fetchWithRetryAndTimeout(url: string, options: FetchOptions = {}): Promise<any> {\n  const { timeout = 5000, retries = 3, ...fetchInit } = options;\n\n  // TODO: Implement the fetch with timeout and retry logic\n\n  // Hint: You'll need AbortController for timeout.\n  // Hint: Use a loop for retries and try/catch inside.\n  // Hint: Add a delay between retries using new Promise(resolve => setTimeout(resolve, delay));\n\n  throw new Error('Not implemented yet');\n}\n\n// Example Usage (Test Cases)\n(async () => {\n  console.log('--- Test Case 1: Successful Fetch ---');\n  try {\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/posts/1', { timeout: 10000 });\n    console.log('Success:', data.title.substring(0, 30) + '...');\n  } catch (err) {\n    console.error('Failure:', err.message);\n  }\n\n  console.log('\\n--- Test Case 2: Simulating Timeout and Retry ---');\n  // This URL can be manipulated to introduce delay (e.g., ?_delay=6000)\n  // You might need a local mock server to reliably simulate random failures/delays\n  // For testing, let's assume this might timeout given a low timeout value.\n  try {\n    // This endpoint has variable delay, simulate it sometimes timing out\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/posts/1?_delay=6000', { timeout: 2000, retries: 2 });\n    console.log('Success (after retry/timeout test):', data.title.substring(0, 30) + '...');\n  } catch (err) {\n    console.error('Failure (after retry/timeout test):', err.message);\n  }\n\n  console.log('\\n--- Test Case 3: Simulating HTTP Error (No Retry) ---');\n  try {\n    // This URL will return 404, should not retry\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/non-existent-path', { retries: 3 });\n    console.log('Success (should not happen):', data);\n  } catch (err) {\n    console.error('Failure (HTTP error, no retry):', err.message);\n  }\n})();\n\n```",
          "solutionCode": "```typescript\ninterface FetchOptions extends RequestInit {\n  timeout?: number;\n  retries?: number;\n  retryDelay?: number;\n}\n\nasync function fetchWithRetryAndTimeout(url: string, options: FetchOptions = {}): Promise<any> {\n  const { timeout = 5000, retries = 3, retryDelay = 500, ...fetchInit } = options;\n\n  for (let i = 0; i <= retries; i++) {\n    const controller = new AbortController();\n    const { signal } = controller;\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const response = await fetch(url, { signal, ...fetchInit });\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        // HTTP errors (4xx, 5xx) are not retried by default, throw immediately\n        const errorBody = await response.text();\n        throw new Error(`HTTP error! Status: ${response.status}. Body: ${errorBody.substring(0, 100)}`);\n      }\n\n      return await response.json();\n    } catch (error: any) {\n      clearTimeout(timeoutId); // Clear timeout even if fetch fails for other reasons\n\n      const isNetworkError = error.name === 'TypeError' || error.name === 'AbortError';\n      \n      if (isNetworkError && i < retries) {\n        console.warn(`Attempt ${i + 1}/${retries + 1} failed for ${url}: ${error.message}. Retrying in ${retryDelay}ms...`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        continue; // Go to next retry attempt\n      } else {\n        // If not a network error, or max retries reached, re-throw\n        console.error(`Final attempt failed for ${url}: ${error.message}`);\n        throw error;\n      }\n    }\n  }\n}\n\n// Example Usage (Test Cases)\n(async () => {\n  console.log('--- Test Case 1: Successful Fetch ---');\n  try {\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/posts/1', { timeout: 10000 });\n    console.log('Success:', data.title.substring(0, 30) + '...');\n  } catch (err: any) {\n    console.error('Failure:', err.message);\n  }\n\n  console.log('\\n--- Test Case 2: Simulating Timeout and Retry ---');\n  // To reliably test timeout, you'd need a server that can introduce delays.\n  // `jsonplaceholder.typicode.com` often has _delay param, but it's not always reliable in all environments.\n  // This example simulates a timeout by making the API call take longer than the local timeout.\n  try {\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/posts/1?_delay=6000', { timeout: 2000, retries: 2 });\n    console.log('Success (after retry/timeout test):', data.title.substring(0, 30) + '...');\n  } catch (err: any) {\n    console.error('Failure (after retry/timeout test):', err.message);\n  }\n\n  console.log('\\n--- Test Case 3: Simulating Network Error and Retry ---');\n  // Temporarily change to a non-existent domain to simulate DNS/network error for retries\n  try {\n    const data = await fetchWithRetryAndTimeout('http://nonexistent-domain-for-test.com/data', { retries: 3 });\n    console.log('Success (should not happen):', data);\n  } catch (err: any) {\n    console.error('Failure (Network error, retried):', err.message);\n  }\n\n  console.log('\\n--- Test Case 4: Simulating HTTP Error (No Retry) ---');\n  try {\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/non-existent-path-404', { retries: 3 });\n    console.log('Success (should not happen):', data);\n  } catch (err: any) {\n    console.error('Failure (HTTP 404 error, no retry):', err.message);\n  }\n})();\n```",
          "testCases": [
            "Successful fetch: Call with a valid URL and sufficient timeout. Verify data is returned.",
            "Timeout (no retry succeeds): Call with a URL that will delay longer than `timeout`, but with `retries: 0`. Verify an `AbortError` is thrown.",
            "Timeout (retry succeeds): Call with a URL that delays, but is eventually shorter than `timeout * (retries + 1)`. Verify it retries and then succeeds.",
            "Network Error (retry fails): Use an invalid URL (e.g., `http://localhost:9999/` if nothing is running there) and `retries > 0`. Verify it retries `retries` times and then throws the final network error.",
            "HTTP Error (e.g., 404 or 500): Call with a valid URL that returns an HTTP error code. Verify it throws the HTTP error immediately without retries.",
            "Edge case: `retries: 0` should mean no retries are attempted."
          ],
          "hints": [
            "Wrap the `fetch` call in a `for` loop to manage retries.",
            "Inside the loop, each iteration needs its own `AbortController` and `setTimeout` for the timeout.",
            "Distinguish between network errors (e.g., `TypeError`, `AbortError`) that warrant a retry, and HTTP errors (like 404, 500) that usually indicate a server-side problem and typically don't benefit from retries.",
            "A `Promise` with `setTimeout` is a simple way to create a delay between retries: `await new Promise(resolve => setTimeout(resolve, delay));`.",
            "Ensure `clearTimeout` is called in both success and catch blocks to prevent memory leaks."
          ],
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Fetch API",
            "Error Handling",
            "Retries",
            "Timeouts",
            "AbortController",
            "Advanced Concepts"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "async_await_basics",
            "async_await_error_handling_timeout",
            "promises"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "expert",
          "relatedConcepts": [
            "network_requests",
            "api_design_patterns",
            "resilience"
          ]
        }
      ]
    }
  },
  {
    "id": "35a33fd1-3f87-4ae5-a5ec-f1ef7f0bc4fd",
    "startLine": 1900,
    "endLine": 1999,
    "processedDate": "2025-06-17T08:05:25.469Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_async_timeout_abortcontroller",
          "title": "Asynchronous Operations with Timeout and AbortController",
          "content": "Asynchronous operations like fetching data from an API are fundamental in frontend development. However, these operations can sometimes hang indefinitely or take too long, leading to a poor user experience. Implementing timeouts is crucial to prevent such scenarios and provide responsive feedback.\n\n## Key Concepts\n\n### `AbortController`\nThe `AbortController` interface provides a way to abort one or more Web requests as and when desired. It's a modern and recommended way to cancel `fetch` requests or any other asynchronous operation that accepts an `AbortSignal`.\n\n-   **`AbortController` instance:** `const controller = new AbortController();`\n-   **`signal` property:** `controller.signal` returns an `AbortSignal` object. This signal can be passed to an asynchronous operation (e.g., `fetch(url, { signal: controller.signal })`).\n-   **`abort()` method:** `controller.abort()` aborts the associated signal. When the signal is aborted, any operations listening to it (like an ongoing `fetch` request) will be cancelled, and a `DOMException` with `name` 'AbortError' will be thrown.\n\n### Timeout Mechanism\nCombining `setTimeout` with `AbortController` allows for implementing a timeout for network requests:\n\n1.  Start a timer using `setTimeout`.\n2.  If the timer expires before the `fetch` request completes, call `controller.abort()` to cancel the request.\n3.  If the `fetch` request completes successfully before the timer expires, clear the timer using `clearTimeout` to prevent the `abort()` call from executing.\n\n### Error Handling\nProper error handling is vital for robust asynchronous code:\n\n-   **`try...catch` block:** Catches errors thrown by the `await` expression, including network errors, JSON parsing errors, or `AbortError`.\n-   **`AbortError`:** Specifically checks for `error.name === 'AbortError'` to differentiate a user-initiated or timeout-based cancellation from other network errors.\n-   **HTTP Status Codes:** After a successful `fetch` call (meaning the network request completed, even if the server responded with an error status like 404 or 500), check `response.ok`. If `response.ok` is `false`, it indicates an HTTP error (status outside 200-299 range), and you should throw a custom error.\n\n## Best Practices\n- Always clear the timeout (`clearTimeout`) on successful completion to avoid memory leaks and unintended `abort()` calls.\n- Provide clear error messages to the user for timeouts or other network failures.\n- Consider retries for transient errors, but not for timeouts or permanent errors.",
          "examples": [
            {
              "id": "example_timeout_abort_1",
              "title": "Implementing fetch with Timeout",
              "code": "async function fetchWithTimeout(url, timeout = 5000) {\n  const controller = new AbortController();\n  // Set up a timeout to abort the request\n  const id = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    // Initiate fetch with the signal\n    const response = await fetch(url, { signal: controller.signal });\n    // Clear the timeout if fetch completes successfully\n    clearTimeout(id);\n    \n    // Check for HTTP errors (e.g., 404, 500)\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    // Always clear timeout in catch block too to prevent hanging timers\n    clearTimeout(id);\n    \n    // Distinguish timeout errors from other errors\n    if (error.name === 'AbortError') {\n      throw new Error(`Request timed out after ${timeout}ms`);\n    }\n    // Re-throw other errors\n    throw error;\n  }\n}\n\n// Example usage:\n// (async () => {\n//   try {\n//     const data = await fetchWithTimeout('https://jsonplaceholder.typicode.com/todos/1', 2000);\n//     console.log('Fetched data:', data);\n//   } catch (e) {\n//     console.error('Fetch error:', e.message);\n//   }\n// })();",
              "explanation": "This example demonstrates how to implement a timeout for a `fetch` request using `AbortController` and `setTimeout`. It shows how to create an `AbortController`, link its `signal` to the `fetch` request, and use `setTimeout` to trigger the `abort()` method if the request takes too long. Crucially, `clearTimeout` is used in both the `try` and `catch` blocks to ensure the timeout is always cleared once the `fetch` promise settles, preventing resource leaks. Error handling differentiates between `AbortError` (timeout) and other potential fetch errors.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "async",
            "fetch",
            "AbortController",
            "timeout",
            "error-handling",
            "web-apis"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "async-await",
            "event-loop-basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust-api-clients",
            "real-time-applications"
          ]
        },
        {
          "id": "theory_async_retry_pattern",
          "title": "Asynchronous Operations with Retry Pattern",
          "content": "In distributed systems and web applications, transient network issues, server overloads, or temporary service unavailability can cause API requests to fail. A retry pattern is a common strategy to make asynchronous operations more resilient by automatically re-attempting a failed request a certain number of times before giving up.\n\n## Key Concepts\n\n### Retry Logic\nThe core of a retry pattern involves re-executing the failed operation. This can be implemented using:\n\n-   **Recursion:** A function calls itself upon failure, decrementing a retry counter.\n-   **Looping:** A `while` or `for` loop attempts the operation repeatedly until success or retries are exhausted.\n\n### Delay Between Retries\nInstead of immediately retrying, introducing a delay is crucial:\n\n-   **Prevents overloading the server:** Gives the server time to recover.\n-   **Avoids busy-waiting:** Doesn't block the event loop unnecessarily.\n-   **`setTimeout` with `Promise`:** A common way to create a delay in `async/await` contexts is `await new Promise(resolve => setTimeout(resolve, delay));`.\n\n### Exponential Backoff\nThis is a strategy where the delay between retries increases exponentially (e.g., 1s, 2s, 4s, 8s...). This is generally preferred over fixed delays:\n\n-   **Reduces server load:** When a server is struggling, repeated rapid retries can exacerbate the problem.\n-   **Increases success probability:** Gives more time for the underlying issue to resolve.\n-   **Formula:** `delay * multiplier` (e.g., `delay * 2`).\n\n### Maximum Retries\nA finite number of retries must be set to prevent infinite loops and ensure the application eventually fails fast if the issue is persistent.\n\n### Error Handling\n-   Only retry for *transient* errors (e.g., network issues, 5xx server errors). Do not retry for *permanent* errors (e.g., 4xx client errors like 404 Not Found, 401 Unauthorized, or validation errors).\n-   If all retries fail, the original error should be re-thrown so the calling code can handle the ultimate failure.\n\n## Considerations\n-   **Idempotency:** Retrying operations that are not idempotent (i.e., multiple executions have different effects than one execution) can lead to unintended side effects (e.g., creating duplicate records). Only retry idempotent operations or design your retry mechanism to handle non-idempotent operations carefully.\n-   **Jitter:** Adding a small random variation to the backoff delay can help prevent multiple clients from retrying simultaneously, causing a 'thundering herd' problem.",
          "examples": [
            {
              "id": "example_retry_1",
              "title": "Recursive Fetch with Retry and Exponential Backoff",
              "code": "async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {\n  try {\n    // Attempt the fetch operation\n    const response = await fetch(url, options);\n    \n    // If response is not OK, consider it a failure for retry purposes\n    // (This example retries on any fetch error, but in practice, you'd check response.ok or specific status codes)\n    if (!response.ok && response.status >= 500) { // Example: Only retry 5xx errors\n       throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return response;\n  } catch (error) {\n    // Check if retries are exhausted\n    if (retries <= 1) {\n      console.error(`Fetch failed after ${retries} attempt(s).`);\n      throw error; // Re-throw the original error\n    }\n    \n    console.warn(`Fetch failed, retrying in ${delay}ms... (Attempts left: ${retries - 1})`);\n    \n    // Wait before retrying using a Promise-based delay\n    await new Promise(resolve => setTimeout(resolve, delay));\n    \n    // Recursively call itself with decremented retries and increased delay\n    return fetchWithRetry(url, options, retries - 1, delay * 2); // Exponential backoff\n  }\n}\n\n// Example usage:\n// (async () => {\n//   try {\n//     // This URL might fail initially for demonstration if configured to do so\n//     const data = await fetchWithRetry('https://httpstat.us/503', {}, 5, 500);\n//     // Or a successful one:\n//     // const data = await fetchWithRetry('https://jsonplaceholder.typicode.com/todos/1');\n//     console.log('Fetched data successfully after retries:', await data.json());\n//   } catch (e) {\n//     console.error('Final fetch error:', e.message);\n//   }\n// })();",
              "explanation": "This example implements a `fetchWithRetry` function using a recursive approach and exponential backoff. It attempts the `fetch` operation. If it fails (either a network error or a 5xx HTTP status code in this refined example), it checks if there are retries left. If so, it waits for a `delay` period (which doubles with each attempt) and then calls itself again. If retries are exhausted, the original error is re-thrown. This pattern makes network requests more resilient to transient failures.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "async",
            "retry",
            "fetch",
            "error-handling",
            "resilience",
            "exponential-backoff",
            "recursion"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "async-await",
            "error-handling-basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust-api-clients",
            "microservices-communication"
          ]
        },
        {
          "id": "theory_event_loop_micro_macro",
          "title": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "content": "Understanding the JavaScript Event Loop is crucial for writing non-blocking and efficient asynchronous code. It dictates the order in which different types of asynchronous operations are executed.\n\n## Key Concepts\n\n### The Event Loop\nJavaScript is single-threaded, meaning it can only execute one task at a time. The Event Loop enables non-blocking asynchronous operations by offloading tasks to the browser's Web APIs (or Node.js's C++ APIs) and then queuing their callbacks to be executed once the main call stack is empty.\n\n### Macrotasks (Tasks)\nMacrotasks (also known as tasks) represent discrete, larger units of work. The browser processes one macrotask at a time from the macrotask queue. After a macrotask completes, the browser renders, and then it processes the *entire* microtask queue before picking up the next macrotask.\n\n**Examples of Macrotasks:**\n-   `setTimeout()`\n-   `setInterval()`\n-   `setImmediate()` (Node.js specific)\n-   `requestAnimationFrame()` (browser specific, often considered a distinct phase after rendering)\n-   I/O operations (e.g., network requests, file reading)\n-   UI rendering (browser specific)\n-   User interactions (e.g., `click`, `keydown` events)\n\n### Microtasks\nMicrotasks are smaller, higher-priority tasks that are executed *after* the currently executing script finishes, but *before* the next macrotask is picked from the macrotask queue. The microtask queue is processed completely before the event loop proceeds to the next macrotask.\n\n**Examples of Microtasks:**\n-   `Promise.then()`, `Promise.catch()`, `Promise.finally()` callbacks\n-   `queueMicrotask()`\n-   `process.nextTick()` (Node.js specific, runs before all other microtasks)\n-   `MutationObserver` callbacks\n\n### Execution Order\nThe general order of execution within a single pass of the Event Loop:\n\n1.  **Synchronous Code:** The main script runs to completion.\n2.  **Microtask Queue:** All microtasks generated during the synchronous execution (or previous macrotask execution) are executed until the microtask queue is empty.\n3.  **Render (Browser only):** The browser may choose to render UI updates.\n4.  **Macrotask Queue:** The event loop picks *one* macrotask from its queue and executes it.\n5.  **Repeat:** After that macrotask completes, the process returns to step 2 (execute all microtasks), then step 3 (render), then step 4 (next macrotask), and so on.\n\nThis cycle ensures that promises and other high-priority asynchronous operations resolve quickly and consistently before the browser moves on to potentially slower tasks like UI rendering or I/O.",
          "examples": [
            {
              "id": "example_event_loop_1",
              "title": "Microtasks vs Macrotasks Execution Order",
              "code": "// Macrotasks: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering\n// Microtasks: Promises, process.nextTick, queueMicrotask, MutationObserver\n\nconsole.log('Script start');\n\nsetTimeout(() => {\n  console.log('Timeout 1'); // Macrotask\n}, 0);\n\nqueueMicrotask(() => {\n  console.log('Microtask 1');\n  \n  queueMicrotask(() => {\n    console.log('Nested microtask');\n  });\n});\n\nPromise.resolve().then(() => {\n  console.log('Promise 1'); // Microtask\n  \n  setTimeout(() => {\n    console.log('Timeout in promise'); // Macrotask\n  }, 0);\n});\n\nsetTimeout(() => {\n  console.log('Timeout 2'); // Macrotask\n}, 0);\n\nconsole.log('Script end');\n\n/*\nExpected Output Explanation:\n1. 'Script start' (Synchronous code)\n2. 'Script end' (Synchronous code completes)\n\n--- End of current script execution. Now process Microtasks. ---\n\n3. 'Microtask 1' (queueMicrotask callback)\n4. 'Promise 1' (Promise.resolve().then() callback)\n   - During 'Promise 1' execution, a new setTimeout ('Timeout in promise') is scheduled, adding to Macrotask queue.\n5. 'Nested microtask' (queueMicrotask callback scheduled from 'Microtask 1')\n\n--- Microtask queue is now empty. Now process next Macrotask. ---\n\n6. 'Timeout 1' (First setTimeout callback)\n\n--- 'Timeout 1' macrotask completes. Microtask queue is empty. Now process next Macrotask. ---\n\n7. 'Timeout 2' (Second setTimeout callback)\n\n--- 'Timeout 2' macrotask completes. Microtask queue is empty. Now process next Macrotask. ---\n\n8. 'Timeout in promise' (setTimeout callback scheduled from 'Promise 1')\n\nFinal Output:\nScript start\nScript end\nMicrotask 1\nPromise 1\nNested microtask\nTimeout 1\nTimeout 2\nTimeout in promise\n*/",
              "explanation": "This example vividly illustrates the priority and execution order of synchronous code, microtasks, and macrotasks. First, all synchronous `console.log` statements run. Then, the microtask queue is fully drained: `queueMicrotask` and `Promise.then` callbacks execute. Any new microtasks created within these (like 'Nested microtask') are also processed in the same microtask phase. Only after the microtask queue is completely empty does the event loop proceed to pick and execute one macrotask from its queue. This process repeats: one macrotask, then all microtasks, then the next macrotask.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "event-loop",
            "asynchronicity",
            "microtasks",
            "macrotasks",
            "promises",
            "setTimeout",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "callbacks",
            "asynchronous-javascript",
            "scope-closure"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "requiredFor": [
            "performance-optimization",
            "complex-async-flows",
            "debugging-async-issues"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_async_timeout_abortcontroller_1",
          "topic": "Asynchronous Operations with Timeout and AbortController",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of `AbortController` in the context of `fetch` API requests?",
          "answer": "To cancel ongoing `fetch` requests.",
          "options": [
            "To handle HTTP status codes (e.g., 404, 500).",
            "To automatically retry failed requests.",
            "To convert response data to JSON format.",
            "To cancel ongoing `fetch` requests."
          ],
          "analysisPoints": [
            "`AbortController` is specifically designed for cancellation of asynchronous tasks, notably `fetch` requests.",
            "HTTP status codes are handled by checking `response.ok` or `response.status` after the `fetch` completes.",
            "Retry logic is a separate pattern, often built on top of `fetch`.",
            "JSON conversion is done via `response.json()`."
          ],
          "keyConcepts": [
            "AbortController",
            "fetch",
            "cancellation"
          ],
          "evaluationCriteria": [
            "Understanding of `AbortController`'s core functionality.",
            "Ability to distinguish its purpose from other `fetch`-related concerns."
          ],
          "example": "```typescript\nconst controller = new AbortController();\nconst signal = controller.signal;\n\n// To cancel a fetch request:\n// fetch(url, { signal });\n// controller.abort();\n```",
          "tags": [
            "AbortController",
            "fetch",
            "basic",
            "API",
            "web-apis"
          ],
          "prerequisites": [
            "fetch-api"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_timeout_abortcontroller_2",
          "topic": "Asynchronous Operations with Timeout and AbortController",
          "level": "medium",
          "type": "code",
          "question": "Modify the `fetchWithTimeout` function to include a `finally` block that *always* clears the timeout, even if an error is caught before `clearTimeout(id)` in the `try` block. Assume `id` is the `setTimeout` ID.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "The `finally` block in `try...catch...finally` always executes regardless of whether an exception was thrown or caught.",
            "Placing `clearTimeout(id)` in `finally` guarantees resource cleanup for the timer.",
            "This is a best practice to prevent memory leaks from uncleaned timers."
          ],
          "keyConcepts": [
            "try-catch-finally",
            "setTimeout",
            "clearTimeout",
            "resource-management"
          ],
          "evaluationCriteria": [
            "Correct use of `finally` block.",
            "Understanding of guaranteed execution in `finally`.",
            "Awareness of best practices for timer cleanup."
          ],
          "example": "```typescript\nasync function fetchWithTimeoutImproved(url, timeout = 5000) {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    const response = await fetch(url, { signal: controller.signal });\n    // Removed clearTimeout from here\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    return response.json();\n  } catch (error) {\n    // Removed clearTimeout from here\n    if (error.name === 'AbortError') {\n      throw new Error(`Request timed out after ${timeout}ms`);\n    }\n    throw error;\n  } finally {\n    clearTimeout(id); // Ensures timeout is always cleared\n  }\n}\n```",
          "tags": [
            "AbortController",
            "fetch",
            "error-handling",
            "code-refactoring",
            "best-practices"
          ],
          "prerequisites": [
            "async-await",
            "try-catch"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_timeout_abortcontroller_3",
          "topic": "Asynchronous Operations with Timeout and AbortController",
          "level": "hard",
          "type": "open",
          "question": "Explain the difference between a `fetch` request failing due to a network error (e.g., no internet connection) and failing due to an `AbortError` caused by a timeout. How would you differentiate and handle these in your `fetchWithTimeout` implementation?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Network errors (e.g., DNS resolution failure, no internet) typically result in a `TypeError` for `fetch` promises, or a generic `Error` object depending on the environment/browser.",
            "`AbortError` is a specific `DOMException` with `error.name === 'AbortError'` that occurs when `controller.abort()` is called and the `fetch` request's `signal` is aborted.",
            "Differentiation: Inside the `catch` block, check `if (error.name === 'AbortError')` to identify a timeout. Any other error typically indicates a network issue or other problem during the `fetch` operation.",
            "Handling: For `AbortError`, you'd inform the user about a timeout. For other errors, you might inform them about a general network problem or server issue."
          ],
          "keyConcepts": [
            "fetch-errors",
            "AbortError",
            "error-handling",
            "network-issues",
            "DOMException"
          ],
          "evaluationCriteria": [
            "Detailed understanding of `fetch` error types.",
            "Ability to distinguish between specific error scenarios.",
            "Practical application of error differentiation in code."
          ],
          "example": "```typescript\n// Inside a catch block:\n// try { ... } catch (error) {\n//   if (error.name === 'AbortError') {\n//     console.error('Request was aborted due to timeout.');\n//   } else if (error instanceof TypeError) { // Common for network errors\n//     console.error('Network error (e.g., no internet connection):', error.message);\n//   } else {\n//     console.error('Other fetch error:', error.message);\n//   }\n//   throw error;\n// }\n```",
          "tags": [
            "AbortController",
            "fetch",
            "error-handling",
            "conceptual",
            "interview"
          ],
          "prerequisites": [
            "async-error-handling",
            "javascript-error-types"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_timeout_abortcontroller_4",
          "topic": "Asynchronous Operations with Timeout and AbortController",
          "level": "easy",
          "type": "flashcard",
          "question": "What happens when `controller.abort()` is called on an `AbortController` linked to an ongoing `fetch` request?",
          "answer": "The `fetch` request is cancelled, and its promise rejects with an `AbortError`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "AbortController",
            "cancellation",
            "fetch",
            "AbortError"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "AbortController",
            "fetch",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_retry_pattern_1",
          "topic": "Asynchronous Operations with Retry Pattern",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `fetchWithRetry` function. What is the purpose of `await new Promise(resolve => setTimeout(resolve, delay));`?",
          "answer": "To pause execution for a specified `delay` before the next retry attempt.",
          "options": [
            "To immediately re-execute the `fetch` request.",
            "To transform the `fetch` response into a Promise.",
            "To ensure the `fetch` request completes within the `delay`.",
            "To pause execution for a specified `delay` before the next retry attempt."
          ],
          "analysisPoints": [
            "The `await` keyword pauses the `async` function's execution.",
            "The `new Promise` combined with `setTimeout` creates a Promise that resolves after the `delay`.",
            "When this Promise resolves, the `await` expression completes, and the function resumes, allowing the next retry attempt.",
            "This is a standard pattern for introducing delays in `async/await` flows."
          ],
          "keyConcepts": [
            "async-await",
            "promises",
            "setTimeout",
            "delay",
            "retry-pattern"
          ],
          "evaluationCriteria": [
            "Understanding of `await` and `setTimeout` with Promises for delaying execution.",
            "Correct interpretation of the code snippet's role in the retry pattern."
          ],
          "example": "```typescript\nasync function simulateDelay(ms) {\n  console.log(`Waiting for ${ms}ms...`);\n  await new Promise(resolve => setTimeout(resolve, ms));\n  console.log('Done waiting!');\n}\n\n// simulateDelay(1000); // This would pause execution for 1 second\n```",
          "tags": [
            "retry",
            "async",
            "promises",
            "setTimeout",
            "basic"
          ],
          "prerequisites": [
            "promises",
            "async-await"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_retry_pattern_2",
          "topic": "Asynchronous Operations with Retry Pattern",
          "level": "medium",
          "type": "open",
          "question": "The provided `fetchWithRetry` function uses `delay * 2` for subsequent retries. What is this technique called, and what is its main advantage in a retry mechanism?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "The technique is called **Exponential Backoff**.",
            "Main advantage: It helps prevent overwhelming a struggling server or service by increasing the delay between retries. If many clients are retrying, exponential backoff spreads out the load, giving the server more time to recover, thus increasing the chance of successful future retries for all clients. It also prevents the 'thundering herd' problem."
          ],
          "keyConcepts": [
            "exponential-backoff",
            "retry-pattern",
            "resilience",
            "server-load",
            "thundering-herd"
          ],
          "evaluationCriteria": [
            "Knowledge of exponential backoff terminology.",
            "Understanding the benefits of exponential backoff for system stability and resilience.",
            "Ability to articulate the 'why' behind this design choice."
          ],
          "example": "```typescript\n// Initial delay = D\n// 1st retry delay = D * 2\n// 2nd retry delay = D * 2 * 2 = D * 4\n// 3rd retry delay = D * 4 * 2 = D * 8\n// ...and so on.\n```",
          "tags": [
            "retry",
            "exponential-backoff",
            "design-pattern",
            "interview"
          ],
          "prerequisites": [],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_retry_pattern_3",
          "topic": "Asynchronous Operations with Retry Pattern",
          "level": "hard",
          "type": "code",
          "question": "Modify the `fetchWithRetry` function to only retry if the `fetch` operation results in an HTTP status code 5xx (Server Error) or a network error. Client errors (4xx) should not trigger a retry.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "The `catch` block handles network errors by default.",
            "Within the `try` block, after `await fetch(url, options)`, check `response.ok` or `response.status`.",
            "If `!response.ok` and `response.status` is in the 5xx range (`>= 500 && < 600`), then throw an error to trigger the retry logic.",
            "If `!response.ok` and `response.status` is in the 4xx range (`>= 400 && < 500`), immediately `throw new Error` without triggering a retry."
          ],
          "keyConcepts": [
            "retry-pattern",
            "error-handling",
            "HTTP-status-codes",
            "conditional-logic"
          ],
          "evaluationCriteria": [
            "Ability to implement nuanced error handling.",
            "Correctly applying HTTP status code logic.",
            "Understanding which errors are transient vs. permanent for retries."
          ],
          "example": "```typescript\nasync function fetchWithRetrySelective(url, options = {}, retries = 3, delay = 1000) {\n  try {\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      if (response.status >= 500 && response.status < 600) {\n        // Server error (5xx) - potentially transient, throw to retry\n        throw new Error(`Server error: ${response.status}`);\n      } else if (response.status >= 400 && response.status < 500) {\n        // Client error (4xx) - usually permanent, do NOT retry\n        // Instead, throw a specific error that isn't caught for retry\n        throw new Error(`Client error: ${response.status}`);\n      } else {\n        // Other non-ok responses (e.g., 3xx redirects without follow)\n        throw new Error(`Unexpected HTTP status: ${response.status}`);\n      }\n    }\n    return response;\n  } catch (error) {\n    // Only retry if it's a network error or a specific error we threw for retries\n    // Check if error message indicates 5xx or it's a generic network error\n    const shouldRetry = (error.message.includes('Server error') || error instanceof TypeError || (error.message && !error.message.includes('Client error')));\n    \n    if (retries <= 1 || !shouldRetry) {\n      throw error; \n    }\n    \n    await new Promise(resolve => setTimeout(resolve, delay));\n    return fetchWithRetrySelective(url, options, retries - 1, delay * 2);\n  }\n}\n```",
          "tags": [
            "retry",
            "error-handling",
            "HTTP",
            "advanced",
            "code-challenge"
          ],
          "prerequisites": [
            "async-await",
            "http-status-codes",
            "error-handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_retry_pattern_4",
          "topic": "Asynchronous Operations with Retry Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary concern when retrying an operation that is *not* idempotent?",
          "answer": "Retrying a non-idempotent operation can lead to unintended side effects, such as creating duplicate records or incorrect state changes.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "idempotency",
            "retry-pattern",
            "side-effects"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "retry",
            "idempotency",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_micro_macro_1",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following code, what will be the correct output order?\n\n```javascript\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('C');\n});\n\nconsole.log('D');\n```",
          "answer": "A, D, C, B",
          "options": [
            "A, B, C, D",
            "A, D, B, C",
            "A, C, D, B",
            "A, D, C, B"
          ],
          "analysisPoints": [
            "Synchronous code runs first: 'A', then 'D'.",
            "After synchronous code, the microtask queue is processed entirely. `Promise.resolve().then()` adds 'C' to the microtask queue.",
            "After microtasks, one macrotask is picked. `setTimeout()` adds 'B' to the macrotask queue. Since its delay is 0, it's ready, but it's a macrotask, so it runs after all microtasks."
          ],
          "keyConcepts": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "promises",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Correctly identifies synchronous execution.",
            "Understands the priority of microtasks over macrotasks.",
            "Predicts the final output sequence accurately."
          ],
          "example": "```javascript\n// Output Explained:\n// 1. 'A' (sync)\n// 2. 'D' (sync)\n// (End of script, microtask queue gets priority)\n// 3. 'C' (microtask from Promise)\n// (Microtask queue empty, macrotask queue next)\n// 4. 'B' (macrotask from setTimeout)\n```",
          "tags": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "prediction",
            "JavaScript"
          ],
          "prerequisites": [
            "callbacks",
            "promises"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_micro_macro_2",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "hard",
          "type": "mcq",
          "question": "Referencing the original example output:\n`Script start`\n`Script end`\n`Microtask 1`\n`Promise 1`\n`Nested microtask`\n`Timeout 1`\n`Timeout 2`\n`Timeout in promise`\n\nWhy does 'Nested microtask' execute before 'Timeout 1', even though 'Timeout 1' was scheduled earlier than the `setTimeout` inside 'Promise 1'?",
          "answer": "All microtasks from the current and previous phases are executed before the next macrotask is picked, and 'Nested microtask' is a microtask.",
          "options": [
            "'Timeout 1' has a minimum delay of 4ms, making it slower than microtasks.",
            "'Nested microtask' is a special type of `queueMicrotask` that has higher priority than `setTimeout`.",
            "All microtasks from the current and previous phases are executed before the next macrotask is picked, and 'Nested microtask' is a microtask.",
            "The browser optimizes `setTimeout` calls, reordering them based on their content."
          ],
          "analysisPoints": [
            "The core understanding here is the Event Loop's processing order: synchronous code completes, then *all* pending microtasks (including new ones queued during the current microtask phase) are processed. Only then does the event loop pick *one* macrotask.",
            "'Timeout 1' is a macrotask. 'Nested microtask' is a microtask, even if it's 'nested' or queued later than 'Timeout 1' in terms of code flow.",
            "The 0ms delay for `setTimeout` means it's queued immediately, but still as a macrotask.",
            "Microtasks have higher priority and are completely drained before any macrotasks are processed."
          ],
          "keyConcepts": [
            "event-loop",
            "microtasks-priority",
            "macrotasks-execution-order",
            "queueMicrotask",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Deep understanding of microtask/macrotask processing flow.",
            "Ability to explain nested asynchronous behavior.",
            "Accurate application of event loop rules to predict output."
          ],
          "example": "```javascript\n// Explanation Trace:\n// 1. Script start (sync)\n// 2. setTimeout(() => console.log('Timeout 1')) -> Macrotask Queue [T1]\n// 3. queueMicrotask(() => { console.log('Microtask 1'); queueMicrotask(() => console.log('Nested microtask')); }) -> Microtask Queue [M1]\n// 4. Promise.resolve().then(() => { console.log('Promise 1'); setTimeout(() => console.log('Timeout in promise')); }) -> Microtask Queue [M1, P1]\n// 5. setTimeout(() => console.log('Timeout 2')) -> Macrotask Queue [T1, T2]\n// 6. Script end (sync)\n\n// *Drain Microtask Queue:*\n// 7. M1 executes -> console.log('Microtask 1'); queueMicrotask(() => console.log('Nested microtask')) -> Microtask Queue [P1, NestedM]\n// 8. P1 executes -> console.log('Promise 1'); setTimeout(() => console.log('Timeout in promise')) -> Macrotask Queue [T1, T2, T_in_P]\n// 9. NestedM executes -> console.log('Nested microtask')\n// Microtask Queue empty.\n\n// *Process ONE Macrotask:*\n// 10. T1 executes -> console.log('Timeout 1')\n\n// *Microtask Queue empty, Process ONE Macrotask:*\n// 11. T2 executes -> console.log('Timeout 2')\n\n// *Microtask Queue empty, Process ONE Macrotask:*\n// 12. T_in_P executes -> console.log('Timeout in promise')\n```",
          "tags": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "advanced",
            "conceptual"
          ],
          "prerequisites": [
            "event-loop-basics",
            "promises",
            "queueMicrotask"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_loop_micro_macro_3",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "medium",
          "type": "open",
          "question": "Name two types of microtasks and two types of macrotasks in a browser environment, and briefly explain when their callbacks are typically executed by the Event Loop.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Microtasks: `Promise.then/catch/finally` callbacks, `queueMicrotask` callbacks, `MutationObserver` callbacks.",
            "Macrotasks: `setTimeout`, `setInterval`, I/O operations (like `fetch` completion), UI rendering, user interaction events (e.g., `click`).",
            "Execution Timing: Microtask callbacks are executed immediately after the currently executing script or macrotask finishes, and the entire microtask queue is emptied before the next macrotask is processed. Macrotask callbacks are picked one at a time from their queue, and after each macrotask, the microtask queue is drained again."
          ],
          "keyConcepts": [
            "microtasks",
            "macrotasks",
            "event-loop-timing",
            "callbacks"
          ],
          "evaluationCriteria": [
            "Correctly identifies examples of both task types.",
            "Accurate description of their execution phases within the event loop cycle.",
            "Clarity and conciseness of explanation."
          ],
          "example": "```javascript\n// Microtask examples: Promise.resolve().then(() => {}), queueMicrotask(() => {})\n// Macrotask examples: setTimeout(() => {}, 0), fetch('/api').then(() => {})\n\n// Execution:\n// 1. Current script runs to completion.\n// 2. All microtasks (Promises, queueMicrotask) run until the microtask queue is empty.\n// 3. Browser may render.\n// 4. One macrotask (setTimeout, fetch callback) runs.\n// 5. Go back to step 2 (drain microtasks again).\n```",
          "tags": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "conceptual",
            "interview"
          ],
          "prerequisites": [
            "asynchronous-javascript"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_micro_macro_4",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "easy",
          "type": "flashcard",
          "question": "Is `setTimeout` a microtask or a macrotask?",
          "answer": "Macrotask",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "setTimeout",
            "macrotask",
            "event-loop"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "event-loop",
            "macrotasks",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_loop_micro_macro_5",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "easy",
          "type": "flashcard",
          "question": "Are Promise callbacks (`.then()`, `.catch()`) microtasks or macrotasks?",
          "answer": "Microtasks",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "promises",
            "microtasks",
            "event-loop"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "event-loop",
            "microtasks",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_async_timeout_abortcontroller_1",
          "title": "Implement a Cancellable Data Fetcher with Timeout Display",
          "description": "\nImplement a function `createCancellableFetcher` that returns an object with a `fetchData` method and a `cancel` method. The `fetchData` method should behave like `fetchWithTimeout` and also emit progress updates to a provided callback. The `cancel` method should abort any ongoing `fetchData` call.\n\n**Requirements:**\n1.  `createCancellableFetcher()` should return an object `{ fetchData, cancel }`.\n2.  `fetchData(url: string, timeoutMs: number, onProgress?: (msg: string) => void)`:\n    *   Uses `AbortController` for cancellation and timeout.\n    *   `onProgress` callback should be called with messages like 'Fetching...', 'Timed out!', 'Fetch successful!', 'Request cancelled!' or 'Error: [message]'.\n    *   Returns the parsed JSON data on success or throws an error on failure/timeout/cancellation.\n3.  `cancel()`: Aborts any ongoing `fetchData` call.\n4.  Ensure proper cleanup of `setTimeout` timers.\n5.  Handle `AbortError` specifically for timeout vs. manual cancellation (distinguish by `controller.signal.aborted` status or context).\n",
          "difficulty": "medium",
          "startingCode": "class CancellableFetcher {\n  private controller: AbortController | null = null;\n  private timeoutId: NodeJS.Timeout | null = null;\n\n  constructor() {}\n\n  async fetchData(url: string, timeoutMs: number, onProgress?: (msg: string) => void): Promise<any> {\n    // TODO: Implement fetch with timeout and progress updates\n    // Use this.controller and this.timeoutId\n    // Call onProgress as appropriate\n    // Handle AbortError distinguishing timeout vs manual cancel\n    return Promise.reject(new Error('Not implemented'));\n  }\n\n  cancel(): void {\n    // TODO: Implement cancellation\n    // Call onProgress if a fetch was ongoing\n  }\n}\n\n// Example usage:\n// const fetcher = new CancellableFetcher();\n// (async () => {\n//   try {\n//     console.log('--- Test 1: Successful Fetch ---');\n//     const data = await fetcher.fetchData('https://jsonplaceholder.typicode.com/todos/1', 5000, (msg) => console.log('Progress:', msg));\n//     console.log('Result:', data);\n\n//     console.log('\\n--- Test 2: Timeout ---');\n//     const data2 = await fetcher.fetchData('https://httpstat.us/200?sleep=6000', 3000, (msg) => console.log('Progress:', msg));\n//     console.log('Result:', data2);\n//   } catch (e) {\n//     console.error('Error in test 1/2:', e.message);\n//   }\n// })();\n\n// (async () => {\n//   console.log('\\n--- Test 3: Manual Cancel ---');\n//   const fetcher2 = new CancellableFetcher();\n//   const fetchPromise = fetcher2.fetchData('https://httpstat.us/200?sleep=5000', 10000, (msg) => console.log('Progress (T3):', msg));\n//   setTimeout(() => fetcher2.cancel(), 1000);\n//   try {\n//     await fetchPromise;\n//   } catch (e) {\n//     console.error('Error in test 3:', e.message);\n//   }\n// })();",
          "solutionCode": "class CancellableFetcher {\n  private controller: AbortController | null = null;\n  private timeoutId: NodeJS.Timeout | null = null;\n\n  constructor() {}\n\n  async fetchData(url: string, timeoutMs: number, onProgress?: (msg: string) => void): Promise<any> {\n    if (this.controller) {\n      // Abort any existing ongoing request before starting a new one\n      this.cancel();\n      if (onProgress) onProgress('Previous request aborted for new one.');\n    }\n\n    this.controller = new AbortController();\n    const signal = this.controller.signal;\n    let isTimeout = false;\n\n    if (onProgress) onProgress('Fetching...');\n\n    this.timeoutId = setTimeout(() => {\n      isTimeout = true; // Flag to distinguish timeout from manual cancel\n      this.controller?.abort();\n    }, timeoutMs);\n\n    try {\n      const response = await fetch(url, { signal });\n\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n      this.controller = null; // Clear controller after successful completion\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (onProgress) onProgress('Fetch successful!');\n      return data;\n    } catch (error: any) {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n      this.controller = null; // Clear controller after error\n\n      if (error.name === 'AbortError') {\n        if (onProgress) {\n          onProgress(isTimeout ? `Timed out after ${timeoutMs}ms!` : 'Request cancelled!');\n        }\n        // Re-throw specific error messages for external handling\n        throw new Error(isTimeout ? `Request timed out after ${timeoutMs}ms` : 'Request cancelled by user');\n      } else {\n        if (onProgress) onProgress(`Error: ${error.message}`);\n        throw error;\n      }\n    }\n  }\n\n  cancel(): void {\n    if (this.controller) {\n      this.controller.abort();\n      this.controller = null;\n    }\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n  }\n}\n",
          "testCases": [
            "Test with a successful fetch call: `fetcher.fetchData('https://jsonplaceholder.typicode.com/todos/1', 5000)` should resolve with data and emit 'Fetch successful!'.",
            "Test with a timeout: `fetcher.fetchData('https://httpstat.us/200?sleep=6000', 3000)` should throw an error containing 'timed out' and emit 'Timed out!'.",
            "Test with manual cancellation: Call `fetcher.fetchData` and then `fetcher.cancel()` shortly after. It should throw an error containing 'cancelled' and emit 'Request cancelled!'.",
            "Test with HTTP error (e.g., 404): `fetcher.fetchData('https://jsonplaceholder.typicode.com/nonexistent', 5000)` should throw an 'HTTP error!' and emit 'Error: HTTP error!'.",
            "Test subsequent calls: Ensure calling `fetchData` multiple times correctly aborts previous requests."
          ],
          "hints": [
            "The `onProgress` callback should be used for status messages.",
            "You can use a flag (e.g., `isTimeout`) to differentiate between `AbortError` caused by `setTimeout` and `AbortError` caused by a manual `cancel()` call.",
            "Remember to reset `this.controller` and `this.timeoutId` to `null` after the fetch operation completes (success or failure) and in the `cancel` method for proper state management.",
            "Consider using a class to manage the state of the `AbortController` and `timeoutId`."
          ],
          "tags": [
            "fetch-api",
            "AbortController",
            "timeout",
            "cancellation",
            "error-handling",
            "class-design",
            "state-management"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "async-await",
            "promises",
            "AbortController",
            "setTimeout"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "observable-pattern",
            "resource-management"
          ]
        },
        {
          "id": "task_async_retry_pattern_1",
          "title": "Build a Generic Retry Utility Function",
          "description": "\nCreate a generic `retry` utility function that can execute any asynchronous function with a specified number of retries and an exponential backoff delay.\n\n**Requirements:**\n1.  `retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>`:\n    *   `fn`: An asynchronous function that returns a Promise.\n    *   `options`: An optional object with:\n        *   `attempts?: number` (default: 3) - Maximum number of retry attempts.\n        *   `delay?: number` (default: 1000) - Initial delay in milliseconds.\n        *   `backoffFactor?: number` (default: 2) - Factor by which delay increases each retry.\n        *   `shouldRetry?: (error: any) => boolean` (default: always retry) - A predicate function to determine if a specific error warrants a retry.\n    *   Returns a Promise that resolves with the `fn`'s result or rejects after all attempts fail.\n2.  Implement exponential backoff for delays.\n3.  Allow custom retry logic via `shouldRetry` predicate. If `shouldRetry` is not provided or returns `true`, retry.\n4.  Log retry attempts (optional, but good for debugging).\n",
          "difficulty": "medium",
          "startingCode": "interface RetryOptions {\n  attempts?: number;\n  delay?: number;\n  backoffFactor?: number;\n  shouldRetry?: (error: any) => boolean;\n}\n\nasync function retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T> {\n  const { \n    attempts = 3,\n    delay = 1000,\n    backoffFactor = 2,\n    shouldRetry = () => true // Default: always retry\n  } = options || {};\n\n  // TODO: Implement the retry logic with exponential backoff and custom retry predicate\n  return Promise.reject(new Error('Not implemented'));\n}\n\n// Example usage:\n// async function flakyOperation(attempt: number): Promise<string> {\n//   console.log(`Attempt ${attempt}: Executing flaky operation...`);\n//   if (attempt < 2) { // Fail first 2 attempts\n//     throw new Error('Simulated transient failure');\n//   }\n//   return 'Operation successful!';\n// }\n\n// (async () => {\n//   try {\n//     const result = await retry(() => flakyOperation(1), {\n//       attempts: 3,\n//       delay: 200,\n//       shouldRetry: (error) => error.message === 'Simulated transient failure'\n//     });\n//     console.log('Final Result:', result);\n//   } catch (error: any) {\n//     console.error('Operation failed after all retries:', error.message);\n//   }\n// })();\n\n// async function alwaysFailsOperation(): Promise<string> {\n//   throw new Error('Permanent failure');\n// }\n\n// (async () => {\n//   try {\n//     const result = await retry(() => alwaysFailsOperation(), {\n//       attempts: 2,\n//       delay: 100,\n//       shouldRetry: (error) => error.message === 'Simulated transient failure' // This won't retry 'Permanent failure'\n//     });\n//     console.log('Final Result (Should not be seen):', result);\n//   } catch (error: any) {\n//     console.error('Operation failed immediately as not retryable:', error.message);\n//   }\n// })();",
          "solutionCode": "interface RetryOptions {\n  attempts?: number;\n  delay?: number;\n  backoffFactor?: number;\n  shouldRetry?: (error: any) => boolean;\n}\n\nasync function retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T> {\n  const { \n    attempts = 3,\n    delay = 1000,\n    backoffFactor = 2,\n    shouldRetry = () => true // Default: always retry\n  } = options || {};\n\n  let currentDelay = delay;\n  for (let i = 0; i < attempts; i++) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      // Check if this error should trigger a retry and if attempts are left\n      if (i < attempts - 1 && shouldRetry(error)) {\n        console.warn(`Attempt ${i + 1} failed. Retrying in ${currentDelay}ms... (Error: ${error.message})`);\n        await new Promise(resolve => setTimeout(resolve, currentDelay));\n        currentDelay *= backoffFactor; // Increase delay for next attempt\n      } else {\n        // No more attempts or error is not retryable, re-throw\n        console.error(`Operation failed after ${i + 1} attempt(s). Last error: ${error.message}`);\n        throw error; \n      }\n    }\n  }\n  // This part should ideally not be reached if initial 'attempts' is > 0 and loop is correctly structured.\n  // Added for strict typing, though the loop ensures an eventual return or throw.\n  throw new Error('Retry logic exhausted without success.');\n}\n",
          "testCases": [
            "Test with a function that succeeds on the first attempt: `retry(() => Promise.resolve('Success'))` should resolve immediately.",
            "Test with a function that fails a few times then succeeds: `retry(() => flakyOp(N))` where `flakyOp` fails `N-1` times, then succeeds. Verify it resolves on the `N`th attempt.",
            "Test with a function that always fails: `retry(() => Promise.reject('Always fails'))` should reject after `attempts` tries.",
            "Test with `shouldRetry` predicate: Pass a function that only retries for specific error messages. Ensure non-retryable errors fail immediately.",
            "Test default options: Call `retry(fn)` without options and verify it uses default attempts and delay.",
            "Test `backoffFactor`: Verify delays are correctly increasing (e.g., by logging `currentDelay`)."
          ],
          "hints": [
            "Use a `for` loop to iterate through the attempts.",
            "The `await new Promise(resolve => setTimeout(resolve, currentDelay))` pattern is key for the delay.",
            "Remember to update `currentDelay` within the loop for exponential backoff.",
            "The `shouldRetry` predicate needs to be checked before waiting for a delay and before deciding to re-throw the error."
          ],
          "tags": [
            "retry-pattern",
            "async-await",
            "promises",
            "utility-function",
            "higher-order-function",
            "error-handling"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "promises",
            "async-await",
            "functions-as-arguments"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "design-patterns",
            "resilience",
            "fault-tolerance"
          ]
        },
        {
          "id": "task_event_loop_micro_macro_1",
          "title": "Predict and Verify Event Loop Execution Order",
          "description": "\nWrite a JavaScript program that uses `setTimeout`, `Promise.resolve().then()`, and `queueMicrotask` to demonstrate the priority and execution order of tasks in the Event Loop. Your program should print messages to the console that clearly show this order. Then, explain the output based on your understanding of microtasks and macrotasks.\n\n**Requirements:**\n1.  Include at least two `setTimeout` calls with `0` delay.\n2.  Include at least two `Promise.resolve().then()` calls.\n3.  Include at least one `queueMicrotask` call.\n4.  Include synchronous `console.log` statements at the start and end of the main script, and within the asynchronous callbacks.\n5.  The `console.log` messages should be descriptive (e.g., 'Sync start', 'Promise 1', 'Timeout 2').\n6.  **Crucially:** After the code, provide a detailed textual explanation of *why* the output appears in that specific order, referencing the concepts of synchronous code, microtask queue, macrotask queue, and the event loop's processing cycle.\n",
          "difficulty": "medium",
          "startingCode": "console.log('// --- START YOUR CODE HERE ---');\n\n// Add your synchronous, setTimeout, Promise, and queueMicrotask calls here.\n// Make sure to include descriptive console.log statements.\n\nconsole.log('// --- END YOUR CODE HERE ---');\n\n/*\n\n   --- DETAILED EXPLANATION OF OUTPUT ORDER --- \n\n   (Provide your explanation here. Example structure below)\n\n   1.  Synchronous Code:\n       - Explain which `console.log` statements run first and why.\n\n   2.  Microtask Queue Processing:\n       - Explain how microtasks are gathered.\n       - Explain the order in which they execute and why they execute before macrotasks.\n       - Mention if any new microtasks/macrotasks are scheduled during this phase.\n\n   3.  Macrotask Queue Processing:\n       - Explain how macrotasks are picked one by one.\n       - Explain the order in which they execute.\n       - Mention if any new microtasks/macrotasks are scheduled during this phase.\n\n   4.  Overall Cycle:\n       - Summarize the continuous cycle of the Event Loop.\n\n*/\n",
          "solutionCode": "console.log('// --- START YOUR CODE HERE ---');\n\nconsole.log('1. Sync: Script Start');\n\nsetTimeout(() => {\n  console.log('4. Macrotask: Timeout 1');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3. Microtask: Promise 1');\n  Promise.resolve().then(() => {\n    console.log('3.2 Microtask: Nested Promise');\n  });\n  setTimeout(() => {\n    console.log('5. Macrotask: Timeout in Promise');\n  }, 0);\n});\n\nqueueMicrotask(() => {\n  console.log('3.1 Microtask: Queue Microtask');\n});\n\nsetTimeout(() => {\n  console.log('6. Macrotask: Timeout 2');\n}, 0);\n\nconsole.log('2. Sync: Script End');\n\nconsole.log('// --- END YOUR CODE HERE ---');\n\n/*\n\n   --- DETAILED EXPLANATION OF OUTPUT ORDER ---\n\n   The JavaScript Event Loop processes tasks in a specific order: all synchronous code, then all microtasks, then one macrotask, then all microtasks again, and so on.\n\n   1.  Synchronous Code:\n       - **Output: '1. Sync: Script Start'**\n       - **Output: '2. Sync: Script End'**\n       - Explanation: All top-level synchronous code executes first and completely before any asynchronous callbacks are considered. The `setTimeout`, `Promise.then`, and `queueMicrotask` calls merely schedule their respective callbacks; their execution doesn't happen immediately.\n\n   2.  Microtask Queue Processing:\n       - After the synchronous script finishes, the Event Loop checks the Microtask Queue. All microtasks in this queue are executed *before* any macrotasks.\n       - **Output: '3. Microtask: Queue Microtask'**\n           - This was queued by `queueMicrotask`.\n       - **Output: '3.1 Microtask: Promise 1'**\n           - This was queued by `Promise.resolve().then()`.\n           - Inside this microtask, a *new microtask* ('3.2 Microtask: Nested Promise') and a *new macrotask* ('5. Macrotask: Timeout in Promise') are scheduled. The new microtask is added to the *current* microtask queue to be processed in this same phase.\n       - **Output: '3.2 Microtask: Nested Promise'**\n           - This microtask, queued during the execution of '3.1 Microtask: Promise 1', is processed immediately because the microtask queue must be fully drained before moving to macrotasks.\n       - The microtask queue is now empty.\n\n   3.  Macrotask Queue Processing:\n       - Once the microtask queue is empty, the Event Loop picks *one* macrotask from the Macrotask Queue (which holds callbacks from `setTimeout`, `setInterval`, I/O, etc.). After executing that single macrotask, it goes back to drain the microtask queue again (though in this specific example, no new microtasks are scheduled by the remaining macrotasks).\n       - **Output: '4. Macrotask: Timeout 1'**\n           - This was the first `setTimeout` scheduled. It's the first macrotask to be picked.\n       - **Output: '6. Macrotask: Timeout 2'**\n           - This was the second `setTimeout` scheduled. It's picked after '4. Macrotask: Timeout 1' and any intervening microtasks (none in this step).\n       - **Output: '5. Macrotask: Timeout in Promise'**\n           - This `setTimeout` was scheduled *from within a microtask ('Promise 1')*. It's added to the macrotask queue, but because macrotasks are processed one by one, and it was scheduled after 'Timeout 1' and 'Timeout 2' (in terms of being added to the queue), it executes last among the timeouts in this sequence.\n       - The macrotask queue is now empty.\n\n   4.  Overall Cycle:\n       The Event Loop continuously cycles: (1) Execute synchronous code. (2) Execute all microtasks. (3) (Browser render optional). (4) Execute one macrotask. Then repeat from (2).\n\n*/",
          "testCases": [
            "Run the code in a browser's console or Node.js environment.",
            "Compare the actual output to the predicted output and the detailed explanation provided.",
            "Verify that `console.log` messages appear in the exact order predicted by the event loop rules."
          ],
          "hints": [
            "Remember the strict priority: Synchronous code -> All Microtasks -> One Macrotask -> All Microtasks -> One Macrotask, and so on.",
            "New microtasks generated *during* a microtask phase are processed within the *same* phase.",
            "New macrotasks generated are added to the macrotask queue and will be picked up in subsequent macrotask phases.",
            "Use clear prefixes in your `console.log` messages (e.g., 'Sync:', 'Micro:', 'Macro:') to make the output easy to follow."
          ],
          "tags": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "asynchronicity",
            "JavaScript",
            "conceptual",
            "debugging"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "promises",
            "setTimeout",
            "queueMicrotask"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "non-blocking-io",
            "concurrency-model"
          ]
        }
      ]
    }
  },
  {
    "id": "5b3f79a8-86e0-4b5d-a48c-65f527cac722",
    "startLine": 2000,
    "endLine": 2099,
    "processedDate": "2025-06-17T08:06:54.131Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_async_fetch_retry",
          "title": "Asynchronous Operations: Fetch with Retry and Exponential Backoff",
          "content": "## Concept\nWhen making network requests (e.g., using `fetch`), transient errors like network glitches or server overload can occur. A retry mechanism allows an application to automatically re-attempt a failed request, improving robustness and user experience. Exponential backoff is a strategy often combined with retries, where the delay between retries increases exponentially. This prevents overwhelming a potentially recovering server and gives it time to stabilize.\n\n## Implementation Details\n*   **`fetch(url, options)`**: The standard Web API for making network requests, returning a `Promise` that resolves to a `Response` object.\n*   **`async`/`await`**: Simplifies asynchronous code, making it look more synchronous. `await` pauses execution until the `Promise` settles (resolves or rejects).\n*   **`try...catch`**: Catches errors that occur during the `fetch` operation. If an error is caught, the retry logic is initiated.\n*   **Recursion**: The `fetchWithRetry` function calls itself (`return fetchWithRetry(...)`) with a decremented `retries` count. This allows for a clean, recursive retry loop.\n*   **`retries` parameter**: A counter that tracks the number of remaining attempts. The recursion stops when `retries` reaches 0, at which point the error is re-thrown.\n*   **`backoff` parameter**: The initial delay (in milliseconds) before the first retry. This value is used to calculate subsequent delays.\n*   **Exponential Delay Calculation**: `delay = backoff * Math.pow(2, 3 - retries)`. This formula calculates an exponentially increasing delay. For example, if `retries` starts at 3:\n    *   1st retry (`retries=2`): `backoff * Math.pow(2, 1)`\n    *   2nd retry (`retries=1`): `backoff * Math.pow(2, 2)`\n    *   3rd retry (`retries=0`): `backoff * Math.pow(2, 3)`\n*   **`new Promise(resolve => setTimeout(resolve, delay))`**: Creates a promise that resolves after a specified `delay`. Awaiting this promise pauses the function's execution, creating the necessary delay before the next retry attempt.\n\n## Advantages\n*   **Improved Reliability**: Makes network operations more resilient to temporary failures.\n*   **Reduced Server Load**: Exponential backoff prevents stampeding retries from hammering a struggling server.\n*   **Better User Experience**: Transparently handles failures without immediate error messages.\n\n## Disadvantages\n*   **Increased Latency**: Retries introduce delays, potentially making operations take longer.\n*   **Complexity**: Adds logic to network requests that might not always be necessary.\n*   **Not for all errors**: Only suitable for transient errors; permanent errors (e.g., 404 Not Found, 401 Unauthorized) should not be retried indefinitely.",
          "examples": [
            {
              "id": "example_async_fetch_retry_1",
              "title": "Basic Fetch with Retry Implementation",
              "code": "async function fetchWithRetry(url, options = {}, retries = 3, backoff = 300) {\n  try {\n    console.log(`Attempting fetch for ${url} (retries left: ${retries})`);\n    const response = await fetch(url, options);\n    if (!response.ok) {\n      // Consider non-2xx responses as errors for retry purposes, e.g., 5xx errors\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response;\n  } catch (error) {\n    console.error(`Fetch failed: ${error.message}`);\n    if (retries > 0) {\n      const delay = backoff * Math.pow(2, 3 - retries);\n      console.log(`Retrying in ${delay}ms...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return fetchWithRetry(url, options, retries - 1, backoff);\n    }\n    throw error; // Re-throw if no retries left\n  }\n}\n\n// Example usage:\n// (async () => {\n//   try {\n//     const data = await fetchWithRetry('https://jsonplaceholder.typicode.com/todos/1', {}, 3, 200);\n//     console.log('Data fetched successfully:', await data.json());\n//   } catch (err) {\n//     console.error('Failed after multiple retries:', err.message);\n//   }\n// })();\n\n// Example for a failing URL (uncomment to test retry logic)\n// (async () => {\n//   try {\n//     const data = await fetchWithRetry('https://httpstat.us/500', {}, 3, 200);\n//     console.log('Data fetched successfully:', await data.json());\n//   } catch (err) {\n//     console.error('Failed after multiple retries:', err.message);\n//   }\n// })();",
              "explanation": "This example demonstrates the `fetchWithRetry` function with added logging to show the retry attempts and delays. It includes a check for `response.ok` to treat non-2xx HTTP responses as errors that trigger retries. The commented-out sections show how to call the function with a successful URL and a simulated failing URL (HTTP 500) to observe the retry mechanism in action.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_fetch_retry_mcq_1",
            "question_fetch_retry_open_1",
            "question_fetch_retry_flashcard_1",
            "question_fetch_retry_code_1"
          ],
          "relatedTasks": [
            "task_implement_fetch_with_jitter"
          ],
          "tags": [
            "async",
            "promises",
            "error-handling",
            "network",
            "api-calls",
            "resilience"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "async_await",
            "promises",
            "error_handling",
            "fetch_api"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust_api_design",
            "client_server_communication"
          ]
        },
        {
          "id": "theory_async_concurrent_limit",
          "title": "Asynchronous Operations: Concurrent Task Limiter",
          "content": "## Concept\nWhen dealing with a large number of asynchronous tasks (e.g., many API calls, file processing, or image loading), executing them all concurrently can overwhelm system resources, lead to rate limiting from servers, or degrade performance. A concurrent task limiter (or concurrency pool/throttle) allows you to control the maximum number of tasks that can run simultaneously. Once the limit is reached, subsequent tasks wait until one of the currently executing tasks completes, freeing up a slot.\n\n## Implementation Details\n*   **`tasks` array**: An array of functions, where each function returns a Promise. This design makes the limiter generic, as it doesn't care what the promise does, only that it produces one.\n*   **`limit`**: The maximum number of concurrent tasks allowed.\n*   **`results` array**: Stores promises for the final results of all tasks. `Promise.all(results)` is used at the end to wait for all tasks (even those that were queued) to complete and collect their results in order.\n*   **`executing` array**: This is the core of the concurrency control. It holds promises that represent the *currently running* tasks. When a task starts, its completion promise is added to `executing`.\n*   **`Promise.resolve().then(() => task())`**: Ensures that each `task()` function is called and its result (a promise) is immediately wrapped and pushed to `results`. This also ensures that `task()` is only called when its turn comes in the loop, not necessarily when it's allowed to *execute* concurrently.\n*   **`p.then(() => executing.splice(executing.indexOf(e), 1))`**: Once a promise `p` (representing a task's execution) resolves, its corresponding entry `e` is removed from the `executing` array. This frees up a slot for a new task.\n*   **`if (executing.length >= limit)`**: This condition checks if the concurrency limit has been reached. If it has, the system needs to wait for an existing task to finish before starting a new one.\n*   **`await Promise.race(executing)`**: This is the key to pausing execution. `Promise.race()` returns a promise that settles as soon as *any* of the promises in the `executing` array settles. By `await`ing this, the loop effectively pauses until a slot becomes available (i.e., one of the currently running tasks finishes and its promise resolves/rejects). After `Promise.race` resolves, the `then` callback associated with the finished promise (which removes it from `executing`) will run, making space.\n\n## How it Works (Simplified Flow)\n1.  Iterate through `tasks`.\n2.  For each `task`, create a promise `p` that represents its execution.\n3.  Add `p` to the `results` array (to eventually collect all results).\n4.  Create a separate promise `e` that resolves when `p` resolves, and critically, when `e` resolves, it removes itself from the `executing` array.\n5.  Add `e` to the `executing` array.\n6.  If `executing.length` reaches `limit`, `await Promise.race(executing)`. This pauses the `for` loop until *any* of the `executing` tasks finishes, which then removes itself from `executing`, reducing its length below the limit and allowing the loop to continue with the next task.\n7.  After the loop finishes, `Promise.all(results)` waits for all tasks to truly complete and collects their outcomes.\n\n## Advantages\n*   **Resource Management**: Prevents overwhelming the client or server.\n*   **Stability**: Avoids hitting rate limits or crashing due to too many open connections.\n*   **Predictable Performance**: Ensures a more stable execution flow.\n\n## Disadvantages\n*   **Increased Complexity**: Requires careful management of promises and execution state.\n*   **Potential Deadlocks (if not careful)**: Incorrect logic could lead to tasks waiting indefinitely.\n*   **Overhead**: Some performance overhead due to managing the queue and promises.",
          "examples": [
            {
              "id": "example_async_concurrent_limit_1",
              "title": "Basic Concurrent Task Limiter Usage",
              "code": "async function concurrentLimit(tasks, limit) {\n  const results = [];\n  const executing = [];\n\n  for (const task of tasks) {\n    // Wrap task in a Promise to ensure it's a promise, and to track its resolution.\n    // We immediately push this promise to results, as we want to collect ALL results.\n    const p = Promise.resolve().then(() => task());\n    results.push(p);\n\n    if (limit <= tasks.length) {\n      // 'e' represents the promise that resolves when 'p' finishes AND removes itself\n      // from the 'executing' queue. This is crucial for freeing up a slot.\n      const e = p.then(() => executing.splice(executing.indexOf(e), 1));\n      executing.push(e);\n\n      // If we've hit the limit, wait for at least one task to complete.\n      // Promise.race allows us to wait for *any* of the currently executing\n      // tasks to finish, freeing up a slot for the next task in the loop.\n      if (executing.length >= limit) {\n        await Promise.race(executing);\n      }\n    }\n  }\n  \n  // Wait for all tasks (both currently executing and those that were queued) to complete.\n  return Promise.all(results);\n}\n\n// Helper function to simulate an async task\nconst createTask = (id, duration) => () => {\n  console.log(`Task ${id} started (duration: ${duration}ms)`);\n  return new Promise(resolve => setTimeout(() => {\n    console.log(`Task ${id} finished`);\n    resolve(`Result of Task ${id}`);\n  }, duration));\n};\n\n// Example usage:\n// const tasksToRun = [\n//   createTask(1, 1000),\n//   createTask(2, 500),\n//   createTask(3, 1200),\n//   createTask(4, 700),\n//   createTask(5, 300),\n//   createTask(6, 1500),\n// ];\n\n// (async () => {\n//   console.log('Starting concurrent tasks with limit 2...');\n//   const results = await concurrentLimit(tasksToRun, 2);\n//   console.log('All tasks completed:', results);\n// })();\n\n// Expected output with limit 2:\n// Task 1 started (duration: 1000ms)\n// Task 2 started (duration: 500ms)\n// Task 2 finished\n// Task 3 started (duration: 1200ms)\n// Task 1 finished\n// Task 4 started (duration: 700ms)\n// Task 5 started (duration: 300ms)\n// Task 5 finished\n// Task 6 started (duration: 1500ms)\n// Task 4 finished\n// Task 3 finished\n// Task 6 finished\n// All tasks completed: [ 'Result of Task 1', 'Result of Task 2', 'Result of Task 3', 'Result of Task 4', 'Result of Task 5', 'Result of Task 6' ]",
              "explanation": "This example provides a concrete demonstration of the `concurrentLimit` function. It includes a `createTask` helper to easily generate simulated asynchronous operations with varying durations. By uncommenting the example usage, you can observe how tasks are initiated and completed, adhering to the specified concurrency limit. The log messages illustrate the staggered start and finish times, confirming that only a maximum of `limit` tasks run at any given moment.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_concurrent_limit_mcq_1",
            "question_concurrent_limit_open_1",
            "question_concurrent_limit_flashcard_1",
            "question_concurrent_limit_code_1"
          ],
          "relatedTasks": [
            "task_implement_concurrency_pool"
          ],
          "tags": [
            "async",
            "promises",
            "concurrency",
            "task-management",
            "performance",
            "resource-control"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "async_await",
            "promises",
            "promise_all",
            "promise_race"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_async_flows",
            "data_fetching_optimization"
          ]
        },
        {
          "id": "theory_async_cancellable_promises",
          "title": "Asynchronous Operations: Cancellable Promises",
          "content": "## Concept\nStandard JavaScript Promises are not inherently cancellable. Once initiated, there's no built-in mechanism to stop their execution or prevent their `.then()` or `.catch()` callbacks from firing. This can lead to issues like:\n*   **Memory Leaks/Performance Issues**: Holding references to components that have been unmounted (e.g., waiting for an API call, then trying to update state on a non-existent component).\n*   **Race Conditions**: When multiple async operations are triggered, and an earlier, slower operation finishes after a later, faster one, potentially overwriting correct state.\n\nA cancellable promise pattern introduces a way to signal that the result of an asynchronous operation should be ignored or that the operation itself should ideally cease execution (though truly stopping a low-level operation like `fetch` mid-flight is not possible in JavaScript without browser intervention). Instead, it prevents the resolution/rejection callbacks from propagating their values if cancellation has been requested.\n\n## Implementation Details\n*   **`isCancelled` flag**: A boolean variable, typically closed over by a closure, which indicates whether the cancellation signal has been received.\n*   **`wrappedPromise`**: A new `Promise` is created to wrap the original `promise`. This wrapper promise is what consumers will interact with.\n*   **Conditional Resolution/Rejection**: Inside the `wrappedPromise`'s executor, the original `promise`'s `then` method is called. The crucial part is that within the `then` callbacks (both for success and failure), the `isCancelled` flag is checked:\n    *   If `isCancelled` is `true`, the `wrappedPromise` is rejected with a specific object (e.g., `{ isCancelled: true }`). This allows the consumer to differentiate between a true error and a cancellation.\n    *   If `isCancelled` is `false`, the original value or error is propagated to `resolve` or `reject` respectively.\n*   **`cancel` function**: A simple function that sets the `isCancelled` flag to `true`.\n*   **Return Object**: The `createCancellablePromise` function returns an object containing both the `promise` (the `wrappedPromise`) and the `cancel` function, allowing the consumer to manage the promise's lifecycle.\n\n## How it Works\nWhen you call `cancel()`, the `isCancelled` flag is set. If the original promise subsequently resolves or rejects, the `wrappedPromise`'s internal `then` callbacks will check `isCancelled`. If `true`, instead of resolving with the original value or rejecting with the original error, it will immediately reject with a cancellation signal. Consumers of the `wrappedPromise` can then catch this specific cancellation rejection and handle it appropriately (e.g., by doing nothing or cleaning up).\n\n## Limitations\n*   **Does not truly abort an ongoing operation**: For network requests (like `fetch`), the underlying request will still complete and consume network resources. This pattern only prevents the *JavaScript callbacks* from executing their payload.\n*   **Requires cooperation**: The calling code must check for the cancellation rejection to properly ignore the result.\n*   **More advanced cancellation**: For truly aborting `fetch` requests, the `AbortController` API is the modern and recommended approach.",
          "examples": [
            {
              "id": "example_async_cancellable_promises_1",
              "title": "Basic Cancellable Promise Usage",
              "code": "function createCancellablePromise(promise) {\n  let isCancelled = false;\n  \n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then(\n      value => isCancelled ? reject({ isCancelled: true, message: 'Promise cancelled' }) : resolve(value),\n      error => isCancelled ? reject({ isCancelled: true, message: 'Promise cancelled due to error' }) : reject(error)\n    );\n  });\n  \n  return {\n    promise: wrappedPromise,\n    cancel: () => { isCancelled = true; }\n  };\n}\n\n// Simulate an async operation\nconst longRunningOperation = (value, delay) => new Promise(resolve => {\n  console.log(`Operation '${value}' started, will resolve in ${delay}ms`);\n  setTimeout(() => {\n    console.log(`Operation '${value}' actually completed`);\n    resolve(value);\n  }, delay);\n});\n\n// Example 1: Successful completion\n// (async () => {\n//   console.log('\\n--- Example 1: Successful completion ---');\n//   const { promise } = createCancellablePromise(longRunningOperation('Data A', 100));\n//   try {\n//     const result = await promise;\n//     console.log('Result:', result);\n//   } catch (error) {\n//     console.error('Error (should not happen):', error);\n//   }\n// })();\n\n// Example 2: Cancellation before completion\n// (async () => {\n//   console.log('\\n--- Example 2: Cancellation before completion ---');\n//   const { promise, cancel } = createCancellablePromise(longRunningOperation('Data B', 500));\n//   setTimeout(() => {\n//     console.log('Calling cancel() for Data B');\n//     cancel();\n//   }, 100);\n\n//   try {\n//     const result = await promise;\n//     console.log('Result:', result); // This line won't be reached\n//   } catch (error) {\n//     if (error && error.isCancelled) {\n//       console.warn('Promise was cancelled:', error.message);\n//     } else {\n//       console.error('Regular error:', error);\n//     }\n//   }\n// })();\n\n// Example 3: Original promise rejects, but cancelled\n// (async () => {\n//   console.log('\\n--- Example 3: Original promise rejects, but cancelled ---');\n//   const failingOperation = () => new Promise((_, reject) => {\n//     setTimeout(() => reject(new Error('Original operation failed')), 300);\n//   });\n//   const { promise, cancel } = createCancellablePromise(failingOperation());\n//   setTimeout(() => {\n//     console.log('Calling cancel() for failing operation');\n//     cancel();\n//   }, 100);\n\n//   try {\n//     await promise;\n//   } catch (error) {\n//     if (error && error.isCancelled) {\n//       console.warn('Promise was cancelled during original rejection:', error.message);\n//     } else {\n//       console.error('Regular error:', error.message);\n//     }\n//   }\n// })();",
              "explanation": "This example demonstrates how to use the `createCancellablePromise` function. It includes a `longRunningOperation` helper to simulate an asynchronous task. Three scenarios are shown:\n1.  **Successful Completion**: The promise resolves normally as no cancellation occurs.\n2.  **Cancellation before Completion**: The `cancel()` function is called before `longRunningOperation` finishes. The `wrappedPromise` then rejects with `{ isCancelled: true }`, which is caught and handled.\n3.  **Original Promise Rejects but Cancelled**: Even if the original promise would have rejected, if `cancel()` is called first, the `wrappedPromise` still rejects with the cancellation signal, overriding the original error. This highlights that cancellation takes precedence.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_cancellable_promises_mcq_1",
            "question_cancellable_promises_open_1",
            "question_cancellable_promises_flashcard_1",
            "question_cancellable_promises_code_1"
          ],
          "relatedTasks": [
            "task_implement_cancel_previous_fetch"
          ],
          "tags": [
            "async",
            "promises",
            "cancellation",
            "error-handling",
            "frontend-patterns",
            "lifecycle"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "async_await",
            "closures"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "react_component_lifecycle",
            "efficient_ui_updates"
          ]
        },
        {
          "id": "theory_object_creation_patterns",
          "title": "Objects and Prototypes: Object Creation Patterns",
          "content": "## Concept\nIn JavaScript, objects are fundamental. There are several common patterns for creating objects, each with its own advantages, disadvantages, and implications for inheritance, `this` binding, and memory usage. Understanding these patterns is crucial for writing efficient, maintainable, and idiomatic JavaScript code.\n\n## Object Literal Pattern\n*   **Description**: The simplest way to create a single object. It's a direct declaration of an object with its properties and methods.\n*   **Syntax**: `const obj = { key: value, method() {} };`\n*   **Pros**: Easy to read and write, ideal for single instances or quick data structures.\n*   **Cons**: Not suitable for creating multiple instances with shared methods (methods would be duplicated for each object, consuming more memory).\n*   **`this` context**: `this` inside methods refers to the object itself.\n\n```javascript\nconst personLiteral = {\n  firstName: 'John',\n  lastName: 'Doe',\n  getFullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n```\n\n## Constructor Function Pattern\n*   **Description**: Uses a regular function called with the `new` keyword to create new instances of objects. This pattern mimics class-based inheritance in other languages, though JavaScript's underlying mechanism is prototype-based.\n*   **Syntax**: `function MyObject(prop1) { this.prop1 = prop1; } const instance = new MyObject('value');`\n*   **Pros**: Allows for creating multiple instances with a clear blueprint. Methods can be shared via the prototype chain (`MyObject.prototype.method = ...`), saving memory.\n*   **Cons**: Requires the `new` keyword, which can be easily forgotten, leading to incorrect `this` binding (global object in non-strict mode, `undefined` in strict mode). Methods defined directly on `this` inside the constructor are duplicated for every instance.\n*   **`this` context**: When called with `new`, `this` inside the constructor refers to the newly created object. Methods defined on `this` refer to that specific instance. Methods defined on `MyObject.prototype` also correctly refer to the instance when called on an instance.\n\n```javascript\nfunction PersonConstructor(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n  // Method defined directly on instance (memory inefficient for many instances)\n  this.getFullName = function() {\n    return this.firstName + ' ' + this.lastName;\n  };\n}\n// Better: method on prototype (shared across instances)\n// PersonConstructor.prototype.getFullName = function() {\n//   return this.firstName + ' ' + this.lastName;\n// };\n\nconst john = new PersonConstructor('John', 'Doe');\n```\n\n## Factory Function Pattern\n*   **Description**: A function that returns a new object. It doesn't use `new` and typically avoids `this` entirely, instead relying on closures to manage private data or parameters.\n*   **Syntax**: `function createMyObject(prop1) { return { prop1, method: () => prop1 }; } const instance = createMyObject('value');`\n*   **Pros**: Very flexible, no `new` keyword required, simplifies `this` binding issues as it often avoids `this`. Can create objects with private variables using closures. Can return different types of objects.\n*   **Cons**: Each method is recreated for every object instance (unless manually managed, e.g., by importing methods). No direct link to a shared prototype, which means `instanceof` won't work for type checking (though `typeof` will).\n*   **`this` context**: Often avoids `this` entirely. If `this` is used, its context depends on how the returned object's method is called.\n\n```javascript\nfunction createPersonFactory(firstName, lastName) {\n  return {\n    firstName,\n    lastName,\n    getFullName() {\n      // Can directly access lexical scope variables here if preferred\n      return firstName + ' ' + lastName; // Example using closure, or this.firstName\n    }\n  };\n}\nconst jane = createPersonFactory('Jane', 'Doe');\n```\n\n## `Object.create()` Pattern\n*   **Description**: `Object.create()` creates a new object, using an existing object as the prototype of the newly created object. This provides a direct and explicit way to manage the prototype chain.\n*   **Syntax**: `const proto = { method() {} }; const obj = Object.create(proto);`\n*   **Pros**: Directly sets up prototype inheritance, enabling efficient method sharing. Good for implementing classical inheritance patterns or when you need a specific prototype chain.\n*   **Cons**: Less intuitive for beginners than object literals or constructor functions. Properties must be added manually or via `Object.defineProperties()`, which can be verbose.\n*   **`this` context**: Methods inherited from the prototype correctly reference `this` as the instance itself.\n\n```javascript\nconst personProto = {\n  getFullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\nconst bob = Object.create(personProto);\nbob.firstName = 'Bob';\nbob.lastName = 'Smith';\n```\n\n## ES6 Class Syntax (Syntactic Sugar)\nWhile not explicitly in the provided markdown, it's essential to understand that ES6 `class` syntax is syntactic sugar over the constructor function and prototype pattern. It simplifies the definition of constructor functions and their prototype methods.\n\n```javascript\nclass PersonClass {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  getFullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n}\nconst alice = new PersonClass('Alice', 'Wonderland');\n```\n\n## Choosing a Pattern\n*   **Object Literal**: For single, unique objects (e.g., configuration objects, utility namespaces).\n*   **Constructor Function / ES6 Class**: For creating multiple instances of the same 'type' of object where inheritance and `instanceof` checks are desired, and methods should be shared via the prototype.\n*   **Factory Function**: For creating objects where `new` keyword is undesirable, or where privacy (via closures) is needed, or when you need to return different types of objects based on input.\n*   **`Object.create()`**: When you need precise control over the prototype chain, e.g., for mixins or explicit inheritance models.",
          "examples": [
            {
              "id": "example_object_creation_patterns_1",
              "title": "Demonstration of Object Literal",
              "code": "const config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  version: '1.0',\n  getConfig() {\n    return `API URL: ${this.apiUrl}, Timeout: ${this.timeout}ms`;\n  }\n};\n\nconsole.log(config.getConfig()); // Output: API URL: https://api.example.com, Timeout: 5000ms",
              "explanation": "This example shows a simple object literal used for a configuration object. It's concise and perfectly suited for a single instance of an object that holds related properties and methods.",
              "language": "typescript"
            },
            {
              "id": "example_object_creation_patterns_2",
              "title": "Demonstration of Constructor Function with Prototype Method",
              "code": "function Book(title, author) {\n  this.title = title;\n  this.author = author;\n}\n\n// Method added to the prototype, shared by all instances\nBook.prototype.getSummary = function() {\n  return `${this.title} by ${this.author}`;\n};\n\nconst book1 = new Book('The Hobbit', 'J.R.R. Tolkien');\nconst book2 = new Book('1984', 'George Orwell');\n\nconsole.log(book1.getSummary()); // Output: The Hobbit by J.R.R. Tolkien\nconsole.log(book2.getSummary()); // Output: 1984 by George Orwell\nconsole.log(book1.getSummary === book2.getSummary); // Output: true (methods are shared)",
              "explanation": "This example uses a constructor function `Book`. Crucially, the `getSummary` method is added to `Book.prototype`. This ensures that all instances of `Book` share the same `getSummary` method, leading to better memory efficiency compared to defining the method directly on `this` inside the constructor. The `console.log` confirms that the method reference is identical for both instances.",
              "language": "typescript"
            },
            {
              "id": "example_object_creation_patterns_3",
              "title": "Demonstration of Factory Function with Closure",
              "code": "function createCounter(initialValue = 0) {\n  let count = initialValue; // Private variable via closure\n  return {\n    increment: () => { count++; return count; },\n    decrement: () => { count--; return count; },\n    getCount: () => count\n  };\n}\n\nconst counter1 = createCounter(5);\nconsole.log(counter1.increment()); // Output: 6\nconsole.log(counter1.getCount());    // Output: 6\n\nconst counter2 = createCounter(10);\nconsole.log(counter2.decrement()); // Output: 9\nconsole.log(counter1.getCount());    // Output: 6 (counter1's count is independent)",
              "explanation": "This example demonstrates a factory function `createCounter`. It utilizes a closure to create a private `count` variable that cannot be accessed directly from outside the returned object. Each call to `createCounter` creates a new, independent counter instance with its own `count` state. This pattern is excellent for encapsulating state and methods without relying on `this`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_object_creation_mcq_1",
            "question_object_creation_open_1",
            "question_object_creation_flashcard_1",
            "question_object_creation_code_1",
            "question_object_creation_mcq_2",
            "question_object_creation_open_2"
          ],
          "relatedTasks": [
            "task_implement_shape_factory",
            "task_create_user_manager"
          ],
          "tags": [
            "objects",
            "prototypes",
            "inheritance",
            "javascript-fundamentals",
            "design-patterns",
            "this-keyword"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "functions",
            "closures",
            "this_keyword"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "oop_in_js",
            "design_patterns",
            "react_component_state"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_fetch_retry_mcq_1",
          "topic": "Fetch with Retry and Exponential Backoff",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `fetchWithRetry` function provided. What is the primary purpose of `await new Promise(resolve => setTimeout(resolve, delay))` within the `catch` block?",
          "answer": "To introduce a delay before retrying the fetch request.",
          "options": [
            "To introduce a delay before retrying the fetch request.",
            "To convert the `setTimeout` callback into a Promise.",
            "To ensure the error is caught asynchronously.",
            "To prevent the browser from freezing during the retry."
          ],
          "analysisPoints": [
            "The core functionality of `setTimeout` is to schedule a function to run after a delay, but it doesn't return a Promise.",
            "Wrapping `setTimeout` in `new Promise` allows `await` to be used with it, pausing the execution of the `async` function until the delay is over.",
            "This pause is essential for implementing the backoff strategy, giving the server time to recover or reducing network congestion.",
            "It's not primarily about converting a callback to a Promise, but rather about making a non-Promise-based delay mechanism `await`-able."
          ],
          "keyConcepts": [
            "async/await",
            "Promises",
            "setTimeout",
            "Exponential Backoff"
          ],
          "evaluationCriteria": [
            "Understanding of `async/await` and Promises.",
            "Knowledge of how to introduce delays in asynchronous functions.",
            "Recognition of the purpose of exponential backoff."
          ],
          "example": "The code `await new Promise(resolve => setTimeout(resolve, delay))` uses `setTimeout` to wait for a specified `delay` and then resolves the internal promise. The `await` keyword then pauses the `fetchWithRetry` function's execution until that promise resolves, effectively creating a non-blocking delay before the next retry attempt.",
          "tags": [
            "async",
            "promises",
            "error-handling",
            "network"
          ],
          "prerequisites": [
            "async_await",
            "promises",
            "setTimeout"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_fetch_retry_open_1",
          "topic": "Fetch with Retry and Exponential Backoff",
          "level": "hard",
          "type": "open",
          "question": "The provided `fetchWithRetry` function implements a basic exponential backoff. Describe a scenario where this specific backoff strategy (`backoff * Math.pow(2, 3 - retries)`) might not be optimal, and suggest how you would modify it to incorporate 'jitter'. Explain why jitter is beneficial.",
          "answer": "This backoff strategy (pure exponential `backoff * Math.pow(2, 3 - retries)`) might not be optimal in scenarios where multiple clients simultaneously experience a failure and attempt to retry at the exact same exponential intervals. This can lead to a 'thundering herd' problem, where all clients retry at roughly the same time, hitting the server simultaneously and potentially causing another cascade of failures, rather than allowing the server to recover.\n\nTo incorporate 'jitter', you would add a random component to the calculated delay. There are two main types:\n1.  **Full Jitter**: `delay = Math.random() * (backoff * Math.pow(2, retries_attempted))`\n2.  **Decorrelated Jitter**: `delay = min(max_delay, random_multiplier * last_delay_duration)`\n\nFor the provided function, a simple way to add full jitter would be to modify the delay calculation to something like:\n```javascript\nconst delay = Math.random() * (backoff * Math.pow(2, 3 - retries));\n```\n(Adjusting `3 - retries` to be `initial_retries - retries` or `retries_attempted` for clarity, e.g., `retriesAttempted = initialRetries - retries; const delay = Math.random() * (backoff * Math.pow(2, retriesAttempted));`)\n\n**Why Jitter is Beneficial:**\nJitter helps to spread out the retry attempts over a slightly wider time window. Instead of all clients retrying at 1s, then 2s, then 4s, etc., they might retry at 0.7s, 1.3s, 1.9s, 3.5s, etc. This randomizes the timing of requests, reducing the likelihood of a large number of clients hitting the server at precisely the same moment. It effectively dampens the 'thundering herd' effect, allowing a recovering server to gradually handle incoming requests rather than being immediately overwhelmed again, thus improving overall system stability and recovery time.",
          "analysisPoints": [
            "Identifies the 'thundering herd' problem as a limitation of deterministic exponential backoff.",
            "Explains the concept of 'jitter' in the context of retry strategies.",
            "Proposes a concrete code modification to add jitter (e.g., using `Math.random()`).",
            "Articulates the benefits of jitter, such as preventing server overload and improving recovery."
          ],
          "keyConcepts": [
            "Exponential Backoff",
            "Jitter",
            "Thundering Herd Problem",
            "Distributed Systems",
            "Error Handling",
            "Network Resilience"
          ],
          "evaluationCriteria": [
            "Depth of understanding of retry strategies.",
            "Ability to identify potential performance bottlenecks in distributed systems.",
            "Creativity and correctness in proposing code modifications.",
            "Clarity in explaining technical rationale."
          ],
          "example": "```javascript\nasync function fetchWithRetryWithJitter(url, options = {}, retries = 3, backoff = 300) {\n  try {\n    return await fetch(url, options);\n  } catch (error) {\n    if (retries > 0) {\n      const retriesAttempted = 3 - retries; // How many retries have occurred\n      // Full jitter: delay is a random value up to the calculated max exponential backoff\n      const maxDelay = backoff * Math.pow(2, retriesAttempted);\n      const delay = Math.random() * maxDelay;\n      \n      console.log(`Retrying in ${delay.toFixed(0)}ms (max ${maxDelay}ms)...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return fetchWithRetryWithJitter(url, options, retries - 1, backoff);\n    }\n    throw error;\n  }\n}\n\n// (async () => {\n//   try {\n//     await fetchWithRetryWithJitter('https://httpstat.us/500', {}, 3, 200); // Simulate failures\n//   } catch (err) {\n//     console.error('Failed after retries with jitter:', err.message);\n//   }\n// })();\n```",
          "tags": [
            "async",
            "promises",
            "error-handling",
            "network",
            "advanced-concepts",
            "performance"
          ],
          "prerequisites": [
            "fetch_retry",
            "math_random"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_fetch_retry_flashcard_1",
          "topic": "Fetch with Retry",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of adding a retry mechanism to network requests?",
          "answer": "Increases the robustness and reliability of API calls by automatically re-attempting failed requests, thereby improving resilience to transient network issues or server instability.",
          "analysisPoints": [],
          "keyConcepts": [
            "Retry mechanism",
            "Robustness",
            "Reliability",
            "Transient errors"
          ],
          "evaluationCriteria": [
            "Basic understanding of retry purpose"
          ],
          "example": "",
          "tags": [
            "async",
            "network"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_fetch_retry_code_1",
          "topic": "Fetch with Retry",
          "level": "medium",
          "type": "code",
          "question": "Modify the `fetchWithRetry` function to include an `onError` callback that gets triggered on each failed retry attempt, receiving the `error` and the current `retryCount` (how many retries are left). The callback should not prevent the retry mechanism from continuing.",
          "answer": "```javascript\nasync function fetchWithRetry(url, options = {}, retries = 3, backoff = 300, onError = () => {}) {\n  try {\n    return await fetch(url, options);\n  } catch (error) {\n    onError(error, retries); // Call the onError callback\n    if (retries > 0) {\n      const delay = backoff * Math.pow(2, 3 - retries);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return fetchWithRetry(url, options, retries - 1, backoff, onError); // Pass callback in recursive call\n    }\n    throw error;\n  }\n}\n\n// Example usage:\n// (async () => {\n//   console.log('Testing fetchWithRetry with onError callback...');\n//   try {\n//     const response = await fetchWithRetry(\n//       'https://httpstat.us/500', // URL that will fail\n//       {},\n//       3, // 3 retries\n//       100, // 100ms initial backoff\n//       (error, retriesLeft) => {\n//         console.warn(`Retry failed: ${error.message}. ${retriesLeft} retries left.`);\n//       }\n//     );\n//     console.log('Fetch succeeded after retries (should not happen for 500):', response.status);\n//   } catch (finalError) {\n//     console.error('Final failure after all retries:', finalError.message);\n//   }\n// })();\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies where to place the `onError` callback (inside the `catch` block before checking `retries > 0`).",
            "Ensures the `onError` callback receives the correct arguments (`error` and `retries`).",
            "Properly passes the `onError` callback in the recursive call to maintain its functionality across retries.",
            "Demonstrates understanding that the callback should not interfere with the retry logic itself."
          ],
          "keyConcepts": [
            "Callbacks",
            "Function Parameters",
            "Recursion",
            "Error Handling",
            "Asynchronous Logic"
          ],
          "evaluationCriteria": [
            "Ability to integrate new functionality into existing async code.",
            "Correct parameter passing in recursive functions.",
            "Maintaining non-blocking behavior for callbacks."
          ],
          "example": "The provided solution adds an `onError` parameter to the `fetchWithRetry` function. Inside the `catch` block, immediately after an error occurs, `onError(error, retries)` is called. This allows external logic to react to each failed attempt. Crucially, the `onError` parameter is also passed into the recursive call `fetchWithRetry(url, options, retries - 1, backoff, onError)` to ensure the callback remains available for subsequent retries.",
          "tags": [
            "async",
            "promises",
            "error-handling",
            "callbacks",
            "refactoring"
          ],
          "prerequisites": [
            "fetch_retry",
            "functions",
            "recursion"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_concurrent_limit_mcq_1",
          "topic": "Concurrent Task Limiter",
          "level": "medium",
          "type": "mcq",
          "question": "In the `concurrentLimit` function, what is the primary role of `Promise.race(executing)`?",
          "answer": "To pause the execution of the loop until at least one of the currently running tasks completes, freeing up a slot.",
          "options": [
            "To pause the execution of the loop until at least one of the currently running tasks completes, freeing up a slot.",
            "To ensure all tasks in the `executing` array finish before the loop continues.",
            "To return the result of the fastest task currently executing.",
            "To cancel all pending tasks if one task fails."
          ],
          "analysisPoints": [
            "`Promise.race` resolves or rejects as soon as *any* of the promises in its iterable settles.",
            "In this context, it's used to detect when *any* of the `executing` tasks finishes.",
            "Awaiting `Promise.race(executing)` allows the `for` loop to pause until a slot becomes available in the `executing` array.",
            "It does not wait for *all* tasks (that's `Promise.all`), nor does it necessarily return the result to the caller (it's awaited internally), nor does it cancel tasks."
          ],
          "keyConcepts": [
            "Promise.race",
            "Concurrency Control",
            "Async/Await",
            "Task Queue"
          ],
          "evaluationCriteria": [
            "Understanding of `Promise.race` functionality.",
            "Ability to explain how `Promise.race` is applied for concurrency control.",
            "Distinguishing between `Promise.race` and `Promise.all`."
          ],
          "example": "```javascript\n// Consider `executing` = [P1 (resolves in 100ms), P2 (resolves in 500ms)]\n// await Promise.race(executing) will resolve after P1 (100ms), \n// allowing the loop to proceed even if P2 is still running. \n// This is how it 'frees up a slot' for the next task without waiting for everything.\n```",
          "tags": [
            "async",
            "promises",
            "concurrency",
            "performance"
          ],
          "prerequisites": [
            "promise_race",
            "async_await"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_concurrent_limit_open_1",
          "topic": "Concurrent Task Limiter",
          "level": "hard",
          "type": "open",
          "question": "The provided `concurrentLimit` function uses `executing.splice(executing.indexOf(e), 1)` to remove completed tasks from the `executing` array. Discuss potential edge cases or issues with this approach, especially if a task might fail or if promises could resolve unexpectedly quickly or slowly. How might you make this removal more robust?",
          "answer": "The `executing.splice(executing.indexOf(e), 1)` approach has a potential edge case, though it's often negligible in practice:\n\n**Potential Issue: Multiple Identical Promises / Reference Integrity**: If, for some reason, the `executing` array could contain multiple *references to the exact same promise object `e`* (which is unlikely in the provided code, as `e` is newly created per task), `indexOf` would only find the *first* occurrence. `splice` would then only remove that first occurrence, leaving duplicates. However, in the given code, `e` is a unique `Promise` instance created for each `p` (`p.then(...)`), so this specific issue is less likely.\n\n**More significant consideration: Debugging and Clarity**: While functional, `indexOf` and `splice` can be less intuitive for managing a queue of promises. If a promise *fails*, it still settles and should be removed, which `p.then(() => ...)` correctly handles (as `then` runs for both resolution and rejection if the second argument is omitted, or the error propagates if not handled and removes the `e` from the `executing` array implicitly).\n\n**Robustness / Alternative Approaches:**\n1.  **Using a `Set` or `Map`**: Instead of an array, a `Set` (for unique promises) or a `Map` (if you need to associate data with each promise) can provide more robust and efficient removal, especially if the list of `executing` promises could become large.\n    *   **Set**: Add `e` to Set, then `executingSet.delete(e)` upon completion.\n    ```javascript\n    // ... inside loop\n    const executingSet = new Set();\n    // ...\n    const e = p.finally(() => executingSet.delete(e)); // `finally` ensures removal regardless of resolve/reject\n    executingSet.add(e);\n    if (executingSet.size >= limit) {\n        await Promise.race(executingSet);\n    }\n    // ...\n    return Promise.all(results);\n    ```\n    This is more robust as `Set.delete()` operates directly on the reference, not an index, avoiding `indexOf`'s potential pitfalls.\n\n2.  **Tracking `executing` promises via a counter and a queue**: A more traditional approach might involve a separate queue for pending tasks and a counter for currently running tasks. When a task finishes, the counter decrements, and the next task from the queue is started.\n    This allows for more explicit control over the flow and simplifies the `executing` array management.\n\n**Why `splice(indexOf(e))` works for this specific case:**\n*   Each `e` promise is a unique instance created via `p.then(...)`. So there won't be duplicate references to the same `e` in `executing` to confuse `indexOf`.\n*   `p.then(...)` will trigger its callback whether `p` resolves or rejects, ensuring `e` (and thus `p`) is removed from `executing` correctly upon settlement (completion).\n\nHowever, using `Set` with `finally` makes the completion handling slightly cleaner and semantically clearer that the promise is being removed from the set regardless of its outcome, and it can be more performant for very large `executing` arrays as `Set.delete` is average O(1) vs. `indexOf` which is O(N).",
          "analysisPoints": [
            "Identifies the specific technical point about `indexOf` and potential issues with non-unique references (though noting its less likely here).",
            "Highlights the importance of handling both resolution and rejection for removal (`.then()` vs. `.finally()`).",
            "Proposes a more robust alternative (using `Set.delete` or a task queue/counter) with code examples.",
            "Explains the benefits of the proposed alternative (clarity, performance, direct reference handling)."
          ],
          "keyConcepts": [
            "Promises",
            "Array Methods (`indexOf`, `splice`)",
            "Set Data Structure",
            "Error Handling",
            "Concurrency Patterns",
            "Promise.finally"
          ],
          "evaluationCriteria": [
            "Ability to critically analyze provided code for edge cases.",
            "Knowledge of alternative data structures (Set) and their use cases.",
            "Understanding of promise lifecycle (`.finally`).",
            "Clarity and completeness of alternative solutions."
          ],
          "example": "```javascript\n// Alternative using Set and Promise.finally\nasync function concurrentLimitRobust(tasks, limit) {\n  const results = [];\n  const executingSet = new Set(); // Use a Set for robust removal\n  \n  for (const task of tasks) {\n    const p = Promise.resolve().then(() => task());\n    results.push(p);\n    \n    // Create a wrapper promise 'e' that removes itself from the set upon settlement\n    const e = p.finally(() => executingSet.delete(e));\n    executingSet.add(e); // Add to the set of executing promises\n    \n    if (executingSet.size >= limit) {\n      await Promise.race(executingSet); // Wait for any promise in the set to settle\n    }\n  }\n  \n  return Promise.all(results);\n}\n\n// (async () => {\n//   console.log('Testing robust concurrentLimit with Set...');\n//   const tasksToRun = [\n//     () => new Promise(res => setTimeout(() => { console.log('Task A done'); res('A'); }, 1000)),\n//     () => new Promise(res => setTimeout(() => { console.log('Task B done'); res('B'); }, 500)),\n//     () => new Promise((_, rej) => setTimeout(() => { console.log('Task C failed'); rej('C'); }, 1200))\n//   ];\n//   try {\n//     const results = await concurrentLimitRobust(tasksToRun, 2);\n//     console.log('All tasks completed:', results);\n//   } catch (error) {\n//     console.error('One or more tasks failed:', error);\n//   }\n// })();\n```",
          "tags": [
            "async",
            "promises",
            "concurrency",
            "data-structures",
            "refactoring",
            "edge-cases"
          ],
          "prerequisites": [
            "concurrent_limit",
            "set_data_structure",
            "promise_finally"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_concurrent_limit_flashcard_1",
          "topic": "Concurrent Task Limiter",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using a concurrent task limiter?",
          "answer": "It controls the maximum number of asynchronous operations running simultaneously, preventing resource exhaustion, rate limiting, and performance degradation.",
          "analysisPoints": [],
          "keyConcepts": [
            "Concurrency",
            "Resource management",
            "Rate limiting",
            "Performance"
          ],
          "evaluationCriteria": [
            "Basic understanding of concurrency control"
          ],
          "example": "",
          "tags": [
            "async",
            "concurrency"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_concurrent_limit_code_1",
          "topic": "Concurrent Task Limiter",
          "level": "hard",
          "type": "code",
          "question": "Modify the `concurrentLimit` function to also return the results of tasks in the order they were provided, even if they completed out of order. Ensure that if any task fails, the final `Promise.all` still rejects, but all tasks are still attempted.",
          "answer": "```javascript\nasync function concurrentLimit(tasks, limit) {\n  const results = []; // Stores promises for all task outcomes, in original order\n  const executing = []; // Stores promises for tasks currently running\n\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    \n    // Create a promise for the current task. Use Promise.resolve() to ensure consistency\n    // and immediately call the task function.\n    const taskPromise = Promise.resolve().then(() => task());\n    results.push(taskPromise); // Store its promise in results to maintain order\n\n    // Create a promise 'completionPromise' that resolves when taskPromise completes.\n    // This is the one we add to 'executing' and remove when it's done.\n    // Using .finally() ensures it's removed whether it resolves or rejects.\n    const completionPromise = taskPromise.finally(() => {\n      // Remove the completionPromise from the executing array\n      executing.splice(executing.indexOf(completionPromise), 1);\n    });\n    executing.push(completionPromise);\n\n    // If the limit is reached, wait for any currently executing task to finish\n    if (executing.length >= limit) {\n      await Promise.race(executing);\n    }\n  }\n\n  // Wait for all tasks to complete, regardless of success or failure.\n  // Promise.all handles rejection correctly if any input promise rejects.\n  return Promise.all(results);\n}\n\n// Example usage:\n// const taskA = () => new Promise(res => setTimeout(() => { console.log('A done'); res('Result A'); }, 1000));\n// const taskB = () => new Promise((_, rej) => setTimeout(() => { console.log('B failed'); rej('Error B'); }, 300));\n// const taskC = () => new Promise(res => setTimeout(() => { console.log('C done'); res('Result C'); }, 700));\n\n// (async () => {\n//   console.log('Starting tasks with concurrency limit 1, expecting rejection...');\n//   try {\n//     const results = await concurrentLimit([taskA, taskB, taskC], 1);\n//     console.log('All results:', results);\n//   } catch (error) {\n//     console.error('Caught error:', error);\n//   }\n// })();\n\n// (async () => {\n//   console.log('\\nStarting tasks with concurrency limit 2, all success...');\n//   const tasks = [\n//     () => new Promise(res => setTimeout(() => res('First'), 800)),\n//     () => new Promise(res => setTimeout(() => res('Second'), 300)),\n//     () => new Promise(res => setTimeout(() => res('Third'), 1200))\n//   ];\n//   try {\n//     const results = await concurrentLimit(tasks, 2);\n//     console.log('All results:', results);\n//   } catch (error) {\n//     console.error('Caught error (should not happen):', error);\n//   }\n// })();\n\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `results.push(taskPromise)` to store the original task's promise, ensuring that `Promise.all(results)` maintains order.",
            "The `executing` array correctly stores and manages the 'completion' promises, allowing the `Promise.race` logic to work for concurrency.",
            "Using `.finally()` on the `taskPromise` to trigger the removal from `executing` ensures that the slot is freed up whether the task resolves or rejects.",
            "Confirms that `Promise.all` inherently rejects if any promise in its array rejects, fulfilling the failure condition."
          ],
          "keyConcepts": [
            "Promise.all",
            "Promise.race",
            "Concurrency Control",
            "Promise.finally",
            "Error Handling in Promises",
            "Array Order Preservation"
          ],
          "evaluationCriteria": [
            "Ability to manage promise states and order correctly.",
            "Effective use of `Promise.finally` for cleanup.",
            "Understanding of how `Promise.all` handles rejections.",
            "Complex asynchronous control flow implementation."
          ],
          "example": "The solution ensures tasks are processed concurrently while preserving the original order of their results by pushing the `taskPromise` directly into the `results` array. The `executing` array's promises are responsible solely for concurrency management, using `.finally()` to guarantee removal when a task settles (either resolves or rejects). `Promise.all(results)` then correctly collects all outcomes in the initial order, rejecting if any task failed.",
          "tags": [
            "async",
            "promises",
            "concurrency",
            "error-handling",
            "advanced-patterns"
          ],
          "prerequisites": [
            "concurrent_limit",
            "promise_all",
            "promise_finally"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_cancellable_promises_mcq_1",
          "topic": "Cancellable Async Operations",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the core mechanism used by `createCancellablePromise` to implement cancellation?",
          "answer": "A flag that, when set, causes the wrapped promise to reject with a specific cancellation object instead of its original value or error.",
          "options": [
            "A flag that, when set, causes the wrapped promise to reject with a specific cancellation object instead of its original value or error.",
            "It stops the underlying asynchronous operation (e.g., `fetch`) from completing.",
            "It uses `Promise.race` to quickly resolve or reject the wrapped promise.",
            "It removes the original promise from the JavaScript event loop queue."
          ],
          "analysisPoints": [
            "The `isCancelled` flag is central to the mechanism.",
            "When `isCancelled` is true, the `then` callbacks of the original promise check this flag.",
            "Instead of `resolve(value)` or `reject(error)`, `reject({ isCancelled: true })` is called.",
            "It's crucial to understand that this pattern *does not* abort the underlying operation itself, only prevents its callbacks from affecting subsequent logic.",
            "It does not directly interact with the event loop or use `Promise.race` for cancellation."
          ],
          "keyConcepts": [
            "Promise Cancellation",
            "Closures",
            "Flag Mechanism",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Understanding of the cancellation pattern's mechanics.",
            "Distinguishing between soft cancellation (ignoring results) and hard cancellation (aborting operations).",
            "Knowledge of how closures enable this pattern."
          ],
          "example": "```javascript\n// Inside createCancellablePromise:\n// promise.then(\n//   value => isCancelled ? reject({ isCancelled: true }) : resolve(value),\n//   error => isCancelled ? reject({ isCancelled: true }) : reject(error)\n// );\n// This snippet shows the conditional logic based on the `isCancelled` flag.\n```",
          "tags": [
            "async",
            "promises",
            "cancellation",
            "frontend-patterns"
          ],
          "prerequisites": [
            "promises",
            "closures"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cancellable_promises_open_1",
          "topic": "Cancellable Async Operations",
          "level": "hard",
          "type": "open",
          "question": "The provided cancellable promise implementation offers a 'soft' cancellation. Explain the difference between 'soft' and 'hard' cancellation in the context of asynchronous operations like `fetch`. When would you prefer the `AbortController` API over this custom implementation?",
          "answer": "**Soft Cancellation (as implemented):**\nThis mechanism prevents the *callbacks* of a promise from executing their payload if a cancellation signal has been issued. The underlying asynchronous operation (e.g., a network request started by `fetch`) still completes, consuming network bandwidth and server resources. The `isCancelled` flag merely tells the wrapper promise to ignore the original promise's resolution/rejection and instead reject with a cancellation error. It's about preventing side effects (like updating unmounted React components).\n\n**Hard Cancellation:**\nThis attempts to genuinely stop the underlying asynchronous operation mid-flight. For network requests, this means aborting the actual HTTP request so that it never reaches the server or stops consuming network resources if it's already in progress. This is often more resource-efficient and can prevent unnecessary work on both the client and server.\n\n**When to prefer `AbortController` over this custom implementation:**\nYou would prefer the `AbortController` API in modern browser environments primarily when dealing with `fetch` (or other APIs that support it, like `XMLHttpRequest`, `WebSockets`, `ReadableStream`): \n1.  **True Resource Abortions**: When you need to stop the actual network request or other long-running operations. This is crucial for optimizing network usage, preventing unnecessary server load, and improving perceived performance.\n2.  **Standardized API**: `AbortController` is a web standard, offering a consistent and widely supported way to implement cancellability for browser APIs.\n3.  **Cleaner Integration**: It provides a `signal` property that can be passed directly to `fetch` options, making the integration straightforward.\n4.  **Error Differentiation**: It throws a specific `AbortError` DOMException, which allows clearer error handling than a custom `{ isCancelled: true }` object.\n\nWhile the custom `createCancellablePromise` is useful for demonstrating the concept or wrapping promises from libraries that don't support `AbortController`, `AbortController` is generally the superior choice for `fetch` due to its ability to perform hard cancellations and its standardized nature.",
          "analysisPoints": [
            "Clearly defines soft cancellation (callback prevention) and hard cancellation (underlying operation termination).",
            "Explains the resource implications of each type.",
            "Lists specific advantages of `AbortController` (true abortion, standardization, cleaner integration, specific error type).",
            "Contextualizes when each approach is appropriate."
          ],
          "keyConcepts": [
            "Promise Cancellation",
            "Soft vs. Hard Cancellation",
            "AbortController API",
            "Fetch API",
            "Resource Management",
            "Web APIs"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of cancellation types.",
            "Knowledge of `AbortController` and its benefits.",
            "Ability to compare and contrast different async patterns.",
            "Practical application scenarios for each approach."
          ],
          "example": "```javascript\n// Example using AbortController with fetch\nconst controller = new AbortController();\nconst signal = controller.signal;\n\nasync function fetchWithAbort(url) {\n  try {\n    console.log('Fetching with AbortController...');\n    const response = await fetch(url, { signal });\n    const data = await response.json();\n    console.log('Data fetched:', data);\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.warn('Fetch request was aborted.');\n    } else {\n      console.error('Fetch error:', error);\n    }\n  }\n}\n\nconst promise = fetchWithAbort('https://jsonplaceholder.typicode.com/todos/1');\n\nsetTimeout(() => {\n  console.log('Aborting fetch...');\n  controller.abort();\n}, 50);\n\n// Expected: 'Fetching with AbortController...', 'Aborting fetch...', 'Fetch request was aborted.'\n// The actual network request would ideally be cancelled by the browser.",
          "tags": [
            "async",
            "promises",
            "cancellation",
            "abortcontroller",
            "fetch-api",
            "web-apis"
          ],
          "prerequisites": [
            "cancellable_promises",
            "fetch_api"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_cancellable_promises_flashcard_1",
          "topic": "Cancellable Async Operations",
          "level": "easy",
          "type": "flashcard",
          "question": "Why are native JavaScript Promises often described as 'not cancellable'?",
          "answer": "Once a native Promise is created and an asynchronous operation starts, there's no built-in method to stop that operation or prevent its `.then()` or `.catch()` handlers from eventually being called, regardless of external state.",
          "analysisPoints": [],
          "keyConcepts": [
            "Promises",
            "Cancellability",
            "Asynchronous operations"
          ],
          "evaluationCriteria": [
            "Basic understanding of Promise immutability"
          ],
          "example": "",
          "tags": [
            "async",
            "promises"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_cancellable_promises_code_1",
          "topic": "Cancellable Async Operations",
          "level": "medium",
          "type": "code",
          "question": "Extend the `createCancellablePromise` function to accept an optional `cleanup` callback. This `cleanup` function should be executed if the promise is cancelled, providing an opportunity to release resources or perform other side effects associated with the aborted operation. The `cleanup` callback should receive the `isCancelled` flag as its argument.",
          "answer": "```javascript\nfunction createCancellablePromise(promise, cleanup = (isCancelled) => {}) {\n  let isCancelled = false;\n  \n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then(\n      value => {\n        if (isCancelled) {\n          cleanup(true); // Execute cleanup on cancellation\n          reject({ isCancelled: true, message: 'Promise cancelled' });\n        } else {\n          resolve(value);\n        }\n      },\n      error => {\n        if (isCancelled) {\n          cleanup(true); // Execute cleanup on cancellation, even if original rejected\n          reject({ isCancelled: true, message: 'Promise cancelled due to error' });\n        } else {\n          cleanup(false); // Execute cleanup on non-cancellation error\n          reject(error);\n        }\n      }\n    );\n  });\n  \n  return {\n    promise: wrappedPromise,\n    cancel: () => { \n      isCancelled = true; \n      // If the promise hasn't settled yet, the cleanup will be called \n      // when its original .then/.catch fires and sees isCancelled = true.\n      // If you needed immediate cleanup regardless of original promise state,\n      // you might add cleanup() here, but be careful with async cleanup.\n    }\n  };\n}\n\n// Example usage:\n// const resourceTracker = new Set();\n// const simulateFetch = (id, delay) => {\n//   console.log(`Starting fetch ${id}`);\n//   resourceTracker.add(id);\n//   return new Promise(res => setTimeout(() => {\n//     console.log(`Fetch ${id} completed`);\n//     res(`Data from ${id}`);\n//   }, delay));\n// };\n\n// (async () => {\n//   console.log('\\n--- Testing cleanup on cancel ---');\n//   const { promise, cancel } = createCancellablePromise(\n//     simulateFetch('img-1', 500),\n//     (wasCancelled) => {\n//       console.log(`Cleanup called for img-1. Was cancelled: ${wasCancelled}`);\n//       resourceTracker.delete('img-1');\n//     }\n//   );\n\n//   setTimeout(() => {\n//     console.log('Cancelling img-1 fetch...');\n//     cancel();\n//   }, 100);\n\n//   try {\n//     await promise;\n//   } catch (error) {\n//     if (error && error.isCancelled) {\n//       console.warn('img-1 fetch was cancelled.');\n//     } else {\n//       console.error('img-1 fetch error:', error.message);\n//     }\n//   }\n//   setTimeout(() => console.log('Current resources:', Array.from(resourceTracker)), 600);\n// })();\n\n// (async () => {\n//   console.log('\\n--- Testing cleanup on success ---');\n//   const { promise } = createCancellablePromise(\n//     simulateFetch('img-2', 100),\n//     (wasCancelled) => {\n//       console.log(`Cleanup called for img-2. Was cancelled: ${wasCancelled}`);\n//       resourceTracker.delete('img-2');\n//     }\n//   );\n//   try {\n//     await promise;\n//     console.log('img-2 fetch completed successfully.');\n//   } catch (error) {\n//     console.error('img-2 fetch error:', error.message);\n//   }\n//   setTimeout(() => console.log('Current resources:', Array.from(resourceTracker)), 200);\n// })();\n```",
          "options": [],
          "analysisPoints": [
            "Correctly adds `cleanup` as an optional parameter to the main function.",
            "Ensures `cleanup` is called inside both `resolve` and `reject` handlers of the original promise.",
            "Passes the `isCancelled` status to the `cleanup` callback.",
            "Maintains the existing cancellation logic while adding the new callback.",
            "Considers scenarios where the original promise resolves, rejects, or is cancelled, and ensures `cleanup` is triggered appropriately."
          ],
          "keyConcepts": [
            "Callbacks",
            "Function Parameters",
            "Error Handling",
            "Resource Management",
            "Promise Lifecycle"
          ],
          "evaluationCriteria": [
            "Ability to extend existing asynchronous patterns.",
            "Correct handling of different promise settlement states.",
            "Understanding of cleanup logic in concurrent operations."
          ],
          "example": "The solution modifies `createCancellablePromise` to accept an optional `cleanup` callback. This callback is invoked within the `then` and `catch` blocks of the wrapped promise, specifically when the original promise settles. It receives a `boolean` argument indicating whether the cancellation flag was `true` at the time of settlement. This allows for conditional resource release or logging based on whether the operation was ignored due to cancellation or completed/failed naturally.",
          "tags": [
            "async",
            "promises",
            "cancellation",
            "resource-management",
            "callbacks"
          ],
          "prerequisites": [
            "cancellable_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_creation_mcq_1",
          "topic": "Object Creation Patterns",
          "level": "easy",
          "type": "mcq",
          "question": "Which object creation pattern is best suited for creating a single, unique object like a configuration settings object?",
          "answer": "Object Literal",
          "options": [
            "Object Literal",
            "Constructor Function",
            "Factory Function",
            "Using Object.create()"
          ],
          "analysisPoints": [
            "Object literals are direct and simple, ideal for one-off objects.",
            "Constructor functions, factory functions, and `Object.create()` are generally used when you need to create multiple instances or manage inheritance/prototypes.",
            "For a single, unique instance, the overhead and complexity of other patterns are unnecessary."
          ],
          "keyConcepts": [
            "Object Literal",
            "Object Creation Patterns",
            "Single Instance"
          ],
          "evaluationCriteria": [
            "Basic knowledge of object literal usage.",
            "Understanding the common use cases for different patterns."
          ],
          "example": "```javascript\nconst appConfig = {\n  debugMode: true,\n  logLevel: 'info',\n  getDebugStatus() {\n    return this.debugMode ? 'Debug ON' : 'Debug OFF';\n  }\n};\nconsole.log(appConfig.getDebugStatus()); // Output: Debug ON\n```\nThis example demonstrates an object literal for a single configuration object.",
          "tags": [
            "objects",
            "javascript-fundamentals"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_creation_open_1",
          "topic": "Object Creation Patterns",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast the Constructor Function pattern with the Factory Function pattern in JavaScript. Discuss their main differences, advantages, and disadvantages, especially concerning `this` binding and prototype inheritance.",
          "answer": "**Constructor Function Pattern**\n*   **How it works**: A regular function invoked with the `new` keyword. Inside the constructor, `this` refers to the newly created object. Properties and methods are typically assigned to `this` (or to `Constructor.prototype` for shared methods).\n*   **Advantages**: \n    *   Clear blueprint for creating multiple instances.\n    *   Supports `instanceof` operator for type checking (`instance instanceof Constructor`).\n    *   Methods can be shared via the prototype chain (`Constructor.prototype`), leading to memory efficiency for many instances.\n*   **Disadvantages**: \n    *   Requires the `new` keyword, which is a common source of errors if omitted (results in `this` binding to global object/`undefined` in strict mode).\n    *   Methods defined directly on `this` inside the constructor are duplicated for every instance, leading to memory inefficiency.\n    *   Less flexible if you want to return different types of objects or objects with private state (without using closures).\n*   **`this` binding**: When called with `new`, `this` is implicitly bound to the new object. Methods on `prototype` also correctly bind `this` to the instance.\n*   **Prototype inheritance**: Naturally leverages JavaScript's prototype chain for method sharing and inheritance.\n\n**Factory Function Pattern**\n*   **How it works**: A simple function that returns a new object. It does not use the `new` keyword. Properties and methods are created and returned as part of the new object.\n*   **Advantages**: \n    *   No `new` keyword, making it less error-prone and more flexible in usage.\n    *   Simplifies `this` binding issues as it often avoids `this` or explicitly controls it.\n    *   Excellent for creating objects with private variables using closures.\n    *   Can return different types of objects based on input parameters.\n*   **Disadvantages**: \n    *   Methods are generally recreated for every object instance, potentially leading to memory inefficiency if many instances are created and methods are complex (unless methods are external and imported).\n    *   Does not naturally support `instanceof` for type checking, as there's no direct prototype linkage in the same way constructor functions provide.\n    *   No direct prototype chain for shared methods, requiring manual management if method sharing is desired.\n*   **`this` binding**: Often avoids `this` entirely, relying on lexical scope/closures. If `this` is used within the returned object's methods, its context depends on how the method is called (e.g., `object.method()`, `method.call(obj)`).\n*   **Prototype inheritance**: Does not inherently use prototype inheritance for methods or properties, although `Object.create()` could be combined within a factory function.\n\n**Key Differences Summarized:**\n| Feature            | Constructor Function          | Factory Function              |\n| :----------------- | :---------------------------- | :---------------------------- |\n| **`new` keyword**  | Required                      | Not used (and discouraged)    |\n| **`this` binding** | Implicitly bound to new object| Often avoids `this`, uses closures |\n| **Prototype**      | Direct prototype chain (`.prototype`)| No inherent prototype chain    |\n| **Memory**         | Efficient with prototype methods| Less efficient (methods recreated per instance)|\n| **`instanceof`**   | Supported                     | Not supported natively        |\n| **Privacy**        | Harder (requires conventions)| Easy with closures            |\n| **Flexibility**    | Less flexible for varied returns| Highly flexible for varied returns|\n\nChoosing between them depends on the specific requirements: constructor functions/classes are often preferred when classic inheritance and type checking are important, while factory functions are great for flexibility, encapsulation, and avoiding `this` complexities.",
          "analysisPoints": [
            "Provides clear descriptions of both patterns.",
            "Lists distinct advantages and disadvantages for each.",
            "Explicitly addresses `this` binding behavior in both contexts.",
            "Compares how prototype inheritance works (or doesn't inherently) for each.",
            "Includes a summary table for quick comparison, enhancing clarity."
          ],
          "keyConcepts": [
            "Constructor Function",
            "Factory Function",
            "Object Creation Patterns",
            "this Keyword",
            "Prototype Inheritance",
            "Closures",
            "Instanceof Operator"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of both patterns.",
            "Ability to articulate nuanced differences.",
            "Knowledge of `this` binding rules.",
            "Understanding of memory implications and prototype chain."
          ],
          "example": "See theory block examples for `Constructor Function` and `Factory Function` for concrete code demonstrations.",
          "tags": [
            "objects",
            "javascript-fundamentals",
            "design-patterns",
            "prototype",
            "this-keyword"
          ],
          "prerequisites": [
            "object_creation_patterns",
            "this_keyword",
            "prototypes",
            "closures"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_creation_flashcard_1",
          "topic": "Object Creation Patterns",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main drawback of defining methods directly inside a Constructor Function (e.g., `this.method = function() {...}`) instead of on its prototype?",
          "answer": "Each instance created by the constructor will have its own copy of the method, leading to increased memory consumption, especially with many instances.",
          "analysisPoints": [],
          "keyConcepts": [
            "Constructor Function",
            "Prototype",
            "Memory efficiency",
            "Method duplication"
          ],
          "evaluationCriteria": [
            "Basic understanding of prototype benefits"
          ],
          "example": "",
          "tags": [
            "objects",
            "prototype"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_creation_code_1",
          "topic": "Object Creation Patterns",
          "level": "medium",
          "type": "code",
          "question": "Implement a `Dog` object using the Constructor Function pattern, ensuring that `speak` and `wagTail` methods are shared across all `Dog` instances for memory efficiency. Each `Dog` should have a `name` and `breed` property.",
          "answer": "```javascript\nfunction Dog(name, breed) {\n  this.name = name;\n  this.breed = breed;\n}\n\nDog.prototype.speak = function() {\n  return `${this.name} barks: Woof! Woof!`;\n};\n\nDog.prototype.wagTail = function() {\n  return `${this.name} wags its tail happily.`;\n};\n\n// Example Usage:\n// const max = new Dog('Max', 'Golden Retriever');\n// const buddy = new Dog('Buddy', 'Labrador');\n\n// console.log(max.speak());        // Max barks: Woof! Woof!\n// console.log(buddy.wagTail());      // Buddy wags its tail happily.\n// console.log(max.speak === buddy.speak); // true (methods are shared)\n```",
          "options": [],
          "analysisPoints": [
            "Correctly defines the `Dog` constructor function with `name` and `breed` properties.",
            "Properly places the `speak` and `wagTail` methods on `Dog.prototype`.",
            "Demonstrates understanding of how `this` refers to the instance within prototype methods.",
            "Validates that methods are indeed shared by checking strict equality."
          ],
          "keyConcepts": [
            "Constructor Function",
            "Prototype",
            "this Keyword",
            "Memory Efficiency",
            "Object Inheritance"
          ],
          "evaluationCriteria": [
            "Ability to apply the Constructor Function pattern correctly.",
            "Understanding of prototype-based inheritance for method sharing.",
            "Correct use of `this` context."
          ],
          "example": "The solution defines `Dog` as a constructor function that initializes instance-specific properties (`name`, `breed`). The `speak` and `wagTail` methods are then attached to `Dog.prototype`. This makes these methods accessible to all `Dog` instances through the prototype chain, ensuring that only one copy of these methods exists in memory, regardless of how many `Dog` objects are created.",
          "tags": [
            "objects",
            "prototype",
            "constructor-function",
            "javascript-fundamentals"
          ],
          "prerequisites": [
            "object_creation_patterns"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_creation_mcq_2",
          "topic": "Object Creation Patterns",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about Factory Functions is TRUE?",
          "answer": "They can easily create objects with private variables using closures.",
          "options": [
            "They explicitly require the `new` keyword for proper instantiation.",
            "Methods defined within them are automatically shared via a prototype chain.",
            "They can easily create objects with private variables using closures.",
            "The `instanceof` operator works reliably for objects created by factory functions."
          ],
          "analysisPoints": [
            "Factory functions *do not* use the `new` keyword; this is a key differentiator from constructor functions.",
            "They *do not* automatically share methods via a prototype chain. Methods are typically recreated per instance unless externalized.",
            "The `instanceof` operator does *not* work reliably as there's no `constructor` property or shared prototype chain in the same way.",
            "Factory functions are excellent for implementing privacy through closures, as variables declared within the factory function's scope are accessible by the returned object's methods but not from outside."
          ],
          "keyConcepts": [
            "Factory Function",
            "Closures",
            "Private Variables",
            "Prototype",
            "Instanceof",
            "New Keyword"
          ],
          "evaluationCriteria": [
            "Detailed understanding of Factory Function characteristics.",
            "Ability to distinguish features from other creation patterns.",
            "Knowledge of closures for privacy."
          ],
          "example": "```javascript\nfunction createBankAccount(initialBalance) {\n  let balance = initialBalance; // Private variable\n\n  return {\n    deposit: (amount) => { balance += amount; },\n    withdraw: (amount) => { if (balance >= amount) balance -= amount; },\n    getBalance: () => balance // Accesses private 'balance'\n  };\n}\n\nconst account = createBankAccount(100);\naccount.deposit(50); \nconsole.log(account.getBalance()); // Output: 150\n// console.log(account.balance); // Undefined - 'balance' is private\n```\nThis example shows how `balance` remains private within the factory function's closure.",
          "tags": [
            "objects",
            "factory-function",
            "closures",
            "privacy"
          ],
          "prerequisites": [
            "object_creation_patterns",
            "closures"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_creation_open_2",
          "topic": "Objects and Prototypes",
          "level": "hard",
          "type": "open",
          "question": "Explain the concept of the prototype chain in JavaScript. How does `Object.create()` directly leverage this concept, and what are its advantages compared to other object creation patterns for managing inheritance?",
          "answer": "**The Prototype Chain in JavaScript:**\nIn JavaScript, every object has an internal slot called `[[Prototype]]` (exposed as `__proto__` in some environments, or accessible via `Object.getPrototypeOf()`). When you try to access a property or method on an object, JavaScript first looks for it directly on that object. If it doesn't find it, it then looks at the object referenced by its `[[Prototype]]`. If still not found, it continues up the chain to that prototype's `[[Prototype]]`, and so on, until it reaches `null` (the end of the chain). This forms a 'prototype chain' that enables inheritance and method sharing.\n\n**How `Object.create()` Leverages the Prototype Chain:**\n`Object.create(proto)` directly creates a new, empty object whose `[[Prototype]]` points precisely to the `proto` object passed as its argument. This is its primary and explicit function. This means the newly created object immediately inherits all properties and methods from `proto` through the prototype chain.\n\nFor example:\n```javascript\nconst animalProto = { sound: '...', makeSound() { console.log(this.sound); } };\nconst dog = Object.create(animalProto);\ndog.sound = 'Woof';\ndog.makeSound(); // 'Woof' (this.sound is dog's own property, makeSound is inherited)\nconsole.log(Object.getPrototypeOf(dog) === animalProto); // true\n```\n\n**Advantages of `Object.create()` for Managing Inheritance:**\n1.  **Direct Prototype Linkage**: Unlike constructor functions (where inheritance involves `Constructor.prototype = Object.create(Parent.prototype)`), `Object.create()` provides a single, direct step to establish the prototype link for a new object. It's explicit and clear.\n2.  **No `new` Keyword/Constructor Involvement**: You don't need a constructor function, nor do you use the `new` keyword. This avoids `this` binding pitfalls associated with forgetting `new`.\n3.  **Flexible Inheritance**: It allows you to create objects with *any* existing object as their prototype, not just prototypes derived from constructor functions. This is powerful for patterns like mixins or when implementing classical inheritance without classes.\n4.  **Creating Empty Objects with Specific Prototypes**: It's the most straightforward way to create an object that specifically inherits from another object but initially has no own properties, allowing you to gradually add them.\n5.  **Simpler Property Descriptors**: The second optional argument allows defining properties with full descriptor control (`value`, `writable`, `enumerable`, `configurable`) at creation time.\n\n**Comparison to Other Patterns:**\n*   **vs. Object Literal**: Object literals implicitly inherit from `Object.prototype`. `Object.create()` gives you control over *which* object the new object inherits from.\n*   **vs. Constructor Function / ES6 Class**: While constructor functions/classes use prototypes for method sharing, `Object.create()` provides a lower-level, more direct way to manage the `[[Prototype]]` link. Constructor functions essentially automate `Object.create()` behind the scenes when setting up inheritance between parent and child constructors' prototypes. `Object.create()` gives you explicit control over this step.\n*   **vs. Factory Function**: Factory functions typically don't use prototype inheritance by default. If a factory function wanted to leverage prototype inheritance, it might internally use `Object.create()` to construct the object it returns.\n\nIn essence, `Object.create()` offers precise, explicit control over an object's `[[Prototype]]`, making it a powerful tool for advanced inheritance patterns and understanding the core of JavaScript's object model.",
          "analysisPoints": [
            "Defines the prototype chain clearly, explaining the lookup mechanism.",
            "Explains how `Object.create()` directly manipulates the `[[Prototype]]` link.",
            "Lists at least 3-4 distinct advantages of `Object.create()`.",
            "Compares `Object.create()` against other patterns, highlighting its unique benefits in inheritance management.",
            "Demonstrates solid understanding of JavaScript's fundamental object model."
          ],
          "keyConcepts": [
            "Prototype Chain",
            "Object.create()",
            "Inheritance",
            "[[Prototype]]",
            "Constructor Function",
            "Factory Function",
            "Object Literal"
          ],
          "evaluationCriteria": [
            "Depth of knowledge regarding JavaScript's prototype system.",
            "Ability to explain the mechanics of `Object.create()`.",
            "Comparative analysis skills for object creation patterns.",
            "Clarity and structure of explanation."
          ],
          "example": "See theory block example for `Object.create()`.",
          "tags": [
            "objects",
            "prototype",
            "inheritance",
            "object-create",
            "javascript-fundamentals"
          ],
          "prerequisites": [
            "object_creation_patterns",
            "prototypes"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_fetch_with_jitter",
          "title": "Implement Fetch with Exponential Backoff and Jitter",
          "description": "\nImplement a `fetchWithRetry` function that makes an HTTP request and retries on failure. The function should incorporate:\n\n1.  **Exponential Backoff**: The delay between retries should increase exponentially.\n2.  **Full Jitter**: Randomize the delay within the exponential range to prevent the 'thundering herd' problem. The delay should be a random value between 0 and the calculated exponential backoff value.\n3.  **Retry Limit**: A maximum number of retry attempts.\n4.  **Error Handling**: Throw the final error if all retries are exhausted.\n\nYour solution should be an `async` function and use `fetch`.\n",
          "difficulty": "medium",
          "startingCode": "async function fetchWithRetry(url, options = {}, retries = 3, initialBackoff = 300) {\n  // TODO: Implement the fetch with retry and jitter logic\n  // Use initialBackoff as the base for exponential calculation.\n  // Full jitter means delay = Math.random() * (base_backoff * Math.pow(2, attempted_retries))\n  \n  // Consider edge cases:\n  // 1. What if retries is 0 initially?\n  // 2. What if fetch always fails?\n  \n  try {\n    // Initial attempt\n    const response = await fetch(url, options);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response;\n  } catch (error) {\n    // TODO: Implement retry logic here\n    if (retries > 0) {\n      // Calculate delay with jitter\n      // Await delay\n      // Recursive call\n    }\n    throw error; // Final throw if no retries left\n  }\n}\n\n// Helper to simulate a failing fetch for testing\n// const simulateFailingFetch = (url, options) => {\n//   let attempt = 0;\n//   return () => new Promise((resolve, reject) => {\n//     attempt++;\n//     console.log(`Simulated fetch to ${url}, attempt ${attempt}`);\n//     if (attempt < 3) { // Fail first 2 attempts\n//       setTimeout(() => reject(new Error(`Simulated Network Error (Attempt ${attempt})`)), 50);\n//     } else {\n//       setTimeout(() => resolve({ ok: true, status: 200, json: () => Promise.resolve({ data: 'success' }) }), 50);\n//     }\n//   });\n// };\n\n// const failingFetch = simulateFailingFetch('https://example.com/api/data');\n\n// // Example Usage:\n// (async () => {\n//   try {\n//     const response = await fetchWithRetry('https://example.com/api/data', { fetcher: failingFetch }, 4, 100);\n//     const data = await response.json();\n//     console.log('Final Data:', data);\n//   } catch (error) {\n//     console.error('Final Error:', error.message);\n//   }\n// })();",
          "solutionCode": "async function fetchWithRetry(url, options = {}, retries = 3, initialBackoff = 300) {\n  let currentRetries = retries;\n  const originalRetries = retries;\n\n  while (currentRetries >= 0) {\n    try {\n      console.log(`Attempting fetch for ${url} (retries left: ${currentRetries}, total attempts: ${originalRetries - currentRetries + 1})`);\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        // Treat non-2xx responses as errors that trigger retries\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return response;\n    } catch (error) {\n      console.error(`Fetch failed: ${error.message}`);\n      if (currentRetries > 0) {\n        const retriesAttempted = originalRetries - currentRetries; // How many retries have already happened\n        const baseDelay = initialBackoff * Math.pow(2, retriesAttempted);\n        const delayWithJitter = Math.random() * baseDelay; // Full jitter\n        \n        console.log(`Retrying in ${delayWithJitter.toFixed(0)}ms (max ${baseDelay}ms) ...`);\n        await new Promise(resolve => setTimeout(resolve, delayWithJitter));\n        currentRetries--;\n      } else {\n        throw error; // Re-throw the error if no retries left\n      }\n    }\n  }\n}\n\n// Helper to simulate a failing fetch for testing (if fetch is not mocked)\n/*\nconst createSimulatedFailingFetch = (successOnAttempt = 3) => {\n  let currentAttempt = 0;\n  return (url, options) => {\n    currentAttempt++;\n    return new Promise((resolve, reject) => {\n      console.log(`[Simulated] Fetching ${url}, attempt ${currentAttempt}...`);\n      if (currentAttempt < successOnAttempt) {\n        setTimeout(() => reject(new Error(`Simulated transient error on attempt ${currentAttempt}`)), 50);\n      } else {\n        setTimeout(() => resolve({ ok: true, status: 200, json: () => Promise.resolve({ message: 'Success after retries!' + currentAttempt }) }), 50);\n      }\n    });\n  };\n};\n\n// To use the simulated fetch, you'd typically pass it in options or mock global fetch\n// Example: Mocking global fetch for testing\n// const originalFetch = global.fetch;\n// global.fetch = createSimulatedFailingFetch(3);\n\n// (async () => {\n//   try {\n//     console.log('\\n--- Test Case 1: Succeeds after retries ---');\n//     const response = await fetchWithRetry('https://api.example.com/data', {}, 3, 100);\n//     const data = await response.json();\n//     console.log('SUCCESS: ', data);\n//   } catch (err) {\n//     console.error('FAILED: ', err.message);\n//   }\n// })();\n\n// global.fetch = createSimulatedFailingFetch(5); // Now fails 4 times\n\n// (async () => {\n//   try {\n//     console.log('\\n--- Test Case 2: Fails after all retries ---');\n//     const response = await fetchWithRetry('https://api.example.com/data', {}, 3, 100); // Only 3 retries\n//     const data = await response.json();\n//     console.log('SUCCESS: ', data);\n//   } catch (err) {\n//     console.error('FAILED: ', err.message);\n//   }\n// })();\n\n// global.fetch = originalFetch; // Restore original fetch\n*/",
          "testCases": [
            "Test with a URL that always succeeds (0 retries should occur).",
            "Test with a URL that fails transiently but succeeds within the retry limit (e.g., fails 2 times, succeeds on 3rd attempt, with `retries = 3`). Verify successful return.",
            "Test with a URL that always fails (e.g., a non-existent URL or a mock that always throws). Verify that the function throws an error after exhausting all retries.",
            "Test with `retries = 0`. Verify that it attempts once and throws immediately on failure.",
            "Observe logs to ensure exponential backoff and jitter are applied (delays should vary and increase).",
            "Test with a non-2xx HTTP status code (e.g., 500 Internal Server Error) to ensure it triggers retries."
          ],
          "hints": [
            "Use a `while` loop or recursion for the retry logic.",
            "Remember to `await new Promise(resolve => setTimeout(resolve, delay))` for the backoff.",
            "The formula for full jitter is `Math.random() * (base_backoff * Math.pow(2, current_retry_number))`.",
            "Ensure the `retries` count correctly decrements and the error is re-thrown when no retries are left."
          ],
          "tags": [
            "async",
            "promises",
            "error-handling",
            "network",
            "algorithms",
            "resilience"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_async_fetch_retry"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "fetch_api",
            "exponential_backoff",
            "jitter",
            "error_handling"
          ]
        },
        {
          "id": "task_implement_concurrency_pool",
          "title": "Implement a Generic Concurrency Pool",
          "description": "\nImplement a function `concurrencyPool(tasks, limit)` that executes a list of asynchronous tasks with a specified concurrency limit. The function should:\n\n1.  Accept an array of `tasks`, where each `task` is a function that returns a `Promise`.\n2.  Accept a `limit` number, representing the maximum concurrent tasks.\n3.  Ensure that no more than `limit` tasks are running at any given time.\n4.  Return a `Promise` that resolves with an array of all task results, in the order the tasks were provided, once all tasks have completed (regardless of individual success or failure).\n5.  If any task rejects, the final returned `Promise` should also reject.\n\nYour implementation should be robust and handle task completions (both resolution and rejection) correctly to free up concurrency slots.\n",
          "difficulty": "hard",
          "startingCode": "async function concurrencyPool(tasks, limit) {\n  const results = [];     // To store the results of all tasks in order\n  const executing = [];   // To track promises that are currently running\n\n  // TODO: Implement the concurrency logic\n  // Iterate through tasks, start new ones if limit allows, otherwise wait.\n  // Use Promise.race and Promise.all effectively.\n\n  return Promise.all(results); // Final collection of results\n}\n\n// Helper to create a simulated async task\n// const createTask = (id, duration, shouldFail = false) => () => {\n//   console.log(`Task ${id} started (duration: ${duration}ms)`);\n//   return new Promise((resolve, reject) => {\n//     setTimeout(() => {\n//       if (shouldFail) {\n//         console.log(`Task ${id} FAILED`);\n//         reject(new Error(`Error from Task ${id}`));\n//       } else {\n//         console.log(`Task ${id} finished`);\n//         resolve(`Result of Task ${id}`);\n//       }\n//     }, duration);\n//   });\n// };\n\n// // Example Usage:\n// (async () => {\n//   console.log('\\n--- Test Case 1: All tasks succeed, limit 2 ---');\n//   const tasks1 = [\n//     createTask(1, 1000),\n//     createTask(2, 500),\n//     createTask(3, 1200),\n//     createTask(4, 700),\n//   ];\n//   try {\n//     const results = await concurrencyPool(tasks1, 2);\n//     console.log('All results:', results);\n//   } catch (error) {\n//     console.error('Error:', error.message);\n//   }\n// })();\n\n// (async () => {\n//   console.log('\\n--- Test Case 2: One task fails, limit 2 ---');\n//   const tasks2 = [\n//     createTask(A, 1000),\n//     createTask(B, 300, true), // This one fails\n//     createTask(C, 700),\n//   ];\n//   try {\n//     const results = await concurrencyPool(tasks2, 2);\n//     console.log('All results:', results);\n//   } catch (error) {\n//     console.error('Error:', error.message);\n//   }\n// })();",
          "solutionCode": "async function concurrencyPool(tasks, limit) {\n  const results = [];\n  const executing = new Set(); // Using a Set for efficient add/delete of executing promises\n  \n  for (const taskFn of tasks) {\n    // Wrap the task function call in a Promise.resolve() to ensure consistency\n    // and capture the promise returned by the task.\n    const taskPromise = Promise.resolve().then(() => taskFn());\n    results.push(taskPromise); // Store this promise to collect all results in order\n\n    // Create a 'completion promise' that removes itself from the executing set\n    // when it settles (either resolves or rejects). Using .finally() ensures this.\n    const completionPromise = taskPromise.finally(() => {\n      executing.delete(completionPromise);\n    });\n    executing.add(completionPromise); // Add to the set of currently executing promises\n\n    // If the number of executing tasks reaches the limit, wait for one to finish.\n    // Promise.race waits for the *first* promise in the set to settle.\n    if (executing.size >= limit) {\n      await Promise.race(executing); \n    }\n  }\n  \n  // Wait for all tasks to genuinely complete (including those that were queued).\n  // Promise.all will resolve with an array of results or reject if any promise rejected.\n  return Promise.all(results);\n}\n\n// Helper to create a simulated async task\n/*\nconst createTask = (id, duration, shouldFail = false) => () => {\n  console.log(`Task ${id} started (duration: ${duration}ms)`);\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldFail) {\n        console.log(`Task ${id} FAILED`);\n        reject(new Error(`Error from Task ${id}`));\n      } else {\n        console.log(`Task ${id} finished`);\n        resolve(`Result of Task ${id}`);\n      }\n    }, duration);\n  });\n};\n\n// Example Usage:\n// (async () => {\n//   console.log('\\n--- Test Case 1: All tasks succeed, limit 2 ---');\n//   const tasks1 = [\n//     createTask('A', 1000),\n//     createTask('B', 500),\n//     createTask('C', 1200),\n//     createTask('D', 700),\n//   ];\n//   try {\n//     const results = await concurrencyPool(tasks1, 2);\n//     console.log('All results:', results);\n//   } catch (error) {\n//     console.error('Error:', error.message);\n//   }\n// })();\n\n// (async () => {\n//   console.log('\\n--- Test Case 2: One task fails, limit 2 ---');\n//   const tasks2 = [\n//     createTask('X', 1000),\n//     createTask('Y', 300, true), // This one fails\n//     createTask('Z', 700),\n//   ];\n//   try {\n//     const results = await concurrencyPool(tasks2, 2);\n//     console.log('All results:', results);\n//   } catch (error) {\n//     console.error('Error (expected):', error.message);\n//   }\n// })();\n\n// (async () => {\n//   console.log('\\n--- Test Case 3: Empty tasks array ---');\n//   try {\n//     const results = await concurrencyPool([], 2);\n//     console.log('Empty tasks results:', results); // Expected: []\n//   } catch (error) {\n//     console.error('Error (unexpected):', error.message);\n//   }\n// })();\n\n// (async () => {\n//   console.log('\\n--- Test Case 4: Limit > tasks.length ---');\n//   const tasks4 = [\n//     createTask('P', 500),\n//     createTask('Q', 200),\n//   ];\n//   try {\n//     const results = await concurrencyPool(tasks4, 5);\n//     console.log('Limit > tasks results:', results); // Should run all concurrently\n//   } catch (error) {\n//     console.error('Error (unexpected):', error.message);\n//   }\n// })();\n\n// (async () => {\n//   console.log('\\n--- Test Case 5: Limit = 1 (sequential) ---');\n//   const tasks5 = [\n//     createTask('S1', 300),\n//     createTask('S2', 200),\n//     createTask('S3', 400)\n//   ];\n//   try {\n//     const results = await concurrencyPool(tasks5, 1);\n//     console.log('Sequential results:', results);\n//   } catch (error) {\n//     console.error('Error (unexpected):', error.message);\n//   }\n// })();\n*/",
          "testCases": [
            "Test with `limit = 1` (sequential execution): Ensure tasks run one after another.",
            "Test with `limit` equal to the number of tasks: Ensure all tasks start immediately.",
            "Test with `limit` less than the number of tasks: Verify that no more than `limit` tasks run concurrently at any point.",
            "Test with an empty `tasks` array: Should return an empty array.",
            "Test where all tasks succeed: Verify all results are returned in the correct order.",
            "Test where one or more tasks fail: Verify that the `concurrencyPool` promise rejects, but all tasks are still attempted and their completion frees up slots.",
            "Measure the total execution time for different limits to confirm concurrent vs. sequential behavior (e.g., total time for 4 tasks of 1000ms each should be ~2000ms with limit 2, and ~4000ms with limit 1).",
            "Test with `limit = 0` or negative `limit` (handle as sequential or throw error, or clamp to 1)."
          ],
          "hints": [
            "The `results` array should store the original promises (`taskPromise`) to preserve order for `Promise.all`.",
            "The `executing` collection should contain promises that represent the *completion* of active tasks, not necessarily their results.",
            "Use `Promise.race(executing)` to wait for *any* currently running task to finish when the limit is reached.",
            "Consider using a `Set` for `executing` to simplify adding and deleting promises.",
            "The `.finally()` method on a promise is useful for cleanup (like removing from `executing`) regardless of whether the promise resolves or rejects."
          ],
          "tags": [
            "async",
            "promises",
            "concurrency",
            "algorithms",
            "data-structures",
            "performance"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_async_concurrent_limit",
            "promise_all",
            "promise_race"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "event_loop",
            "task_queuing",
            "resource_management"
          ]
        },
        {
          "id": "task_implement_cancel_previous_fetch",
          "title": "Implement a 'Cancel Previous' Fetch Mechanism",
          "description": "\nImplement a function `debounceFetch(url, options)` that ensures only the *latest* `fetch` request is active at any given time. If a new `debounceFetch` call is made while a previous one is still pending, the previous one should be cancelled or ignored.\n\nThis is a common pattern for type-ahead search inputs or rapid button clicks where only the most recent action's result is relevant.\n\nYour solution should:\n1.  Return a Promise that resolves with the `Response` of the *latest* successful `fetch` call.\n2.  Use the `AbortController` API for effective cancellation of previous `fetch` requests.\n3.  Maintain a reference to the active `AbortController` and its associated Promise.\n4.  Handle `AbortError` specifically, ensuring it doesn't propagate as a regular error.\n",
          "difficulty": "hard",
          "startingCode": "let activeController = null; // Store the active AbortController globally or in a closure\nlet activePromise = null;    // Store the promise of the active fetch operation\n\nasync function debounceFetch(url, options = {}) {\n  // TODO: Implement cancellation logic for previous fetch\n  // 1. If an activeController exists, abort it.\n  // 2. Create a new AbortController.\n  // 3. Perform the fetch request with the new controller's signal.\n  // 4. Handle AbortError specifically.\n  // 5. Update activeController and activePromise for the new request.\n\n  return new Promise((resolve, reject) => {\n    // Placeholder: actual fetch logic will go here\n    // resolve(new Response('{}', { status: 200 })); \n  });\n}\n\n// Helper to simulate network delay for testing\n// const simulateNetworkDelay = (ms) => new Promise(res => setTimeout(res, ms));\n\n// // Example Usage:\n// (async () => {\n//   console.log('--- Rapid Firing Test ---');\n//   debounceFetch('api/search?q=a', { requestId: 1 }).then(res => console.log('Result 1:', res.url)).catch(err => console.log('Error 1:', err.name)); // Should be cancelled\n//   await simulateNetworkDelay(50);\n//   debounceFetch('api/search?q=ab', { requestId: 2 }).then(res => console.log('Result 2:', res.url)).catch(err => console.log('Error 2:', err.name)); // Should be cancelled\n//   await simulateNetworkDelay(50);\n//   debounceFetch('api/search?q=abc', { requestId: 3 }).then(res => console.log('Result 3:', res.url)).catch(err => console.log('Error 3:', err.name)); // Should succeed\n\n//   await simulateNetworkDelay(200); // Allow last fetch to complete\n//   console.log('--- Single Firing Test ---');\n//   debounceFetch('api/data', { requestId: 4 }).then(res => console.log('Result 4:', res.url)).catch(err => console.log('Error 4:', err.name)); // Should succeed\n\n//   await simulateNetworkDelay(200); // Allow last fetch to complete\n// })();",
          "solutionCode": "let activeController = null; // Stores the AbortController for the currently active fetch\nlet activePromise = null;    // Stores the promise of the currently active fetch operation\n\nasync function debounceFetch(url, options = {}) {\n  // 1. If there's an active request, abort it.\n  if (activeController) {\n    activeController.abort();\n  }\n\n  // 2. Create a new AbortController for the current request.\n  const currentController = new AbortController();\n  const signal = currentController.signal;\n  activeController = currentController; // Set this as the new active controller\n\n  // 3. Create a promise for the current fetch operation.\n  // We need to wrap it so we can specifically handle AbortError.\n  const currentFetchPromise = new Promise(async (resolve, reject) => {\n    try {\n      const response = await fetch(url, { ...options, signal });\n      // Important: After fetch resolves, check if *this* specific fetch was cancelled by a later call.\n      // This handles the race condition where the fetch succeeds, but then a new debounceFetch call\n      // comes in and aborts *this* one before its then/catch handlers execute.\n      if (activeController !== currentController) {\n        // This means a newer request has taken over. Treat this one as effectively cancelled.\n        // We don't want to resolve/reject for an outdated request.\n        return reject({ name: 'StaleRequestError', message: 'This request was superseded.' });\n      }\n      resolve(response);\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        // This is the intended cancellation. We should not propagate this as a regular error.\n        // Only reject if it's not the currently active request that got aborted.\n        if (activeController === currentController) {\n          // This indicates this request was aborted by an external mechanism, and it's currently active\n          // This specific pattern here aims to handle cases where *this* exact request was aborted.\n          // For debounce, we want to reject silently if *this* specific call was aborted by a new call.\n          reject(error); // This will then be caught by the outer catch to differentiate\n        } else {\n           // If activeController is already different, it means *this* promise was aborted by a newer call.\n           // In debounce, we usually want to silently ignore these.\n           // The caller of the `activePromise` (which is `currentFetchPromise`) will then reject if awaited.\n           reject(error);\n        }\n      } else if (activeController !== currentController) {\n          // If a new request has taken over, and this one errors out, silently ignore it as well.\n          reject({ name: 'StaleRequestError', message: 'This request failed but was superseded.' });\n      } else {\n        // Regular error not related to cancellation\n        reject(error);\n      }\n    }\n  });\n\n  activePromise = currentFetchPromise; // Store the promise for external waiting\n  \n  // Return a promise that only resolves if it's still the active one,\n  // and also handles the AbortError internally without propagating it to the outside `then` chain.\n  return new Promise((resolve, reject) => {\n    currentFetchPromise.then(response => {\n      if (activeController === currentController) {\n        resolve(response);\n      } else {\n        // This should theoretically be handled by the currentFetchPromise's internal logic\n        // but this adds an extra layer of safety for race conditions.\n        reject(new Error('Previous request superseded, results ignored.'));\n      }\n    }).catch(error => {\n      if (error.name === 'AbortError' || error.name === 'StaleRequestError') {\n        // Silently catch the abortion or stale request error for debounce pattern.\n        // This makes the returned promise neither resolve nor reject for cancelled requests.\n        // console.log(`Request for ${url} was cancelled/superseded.`);\n        // Do nothing, the promise effectively 'hangs' or is never fulfilled from this perspective.\n      } else {\n        reject(error); // Propagate actual errors\n      }\n    });\n  });\n}\n\n// --- Test Setup --- (To be run in a browser or Node.js environment with fetch API available)\n/*\nconst wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nconst mockFetch = async (url, options) => {\n  const duration = Math.random() * 200 + 100; // Simulate network delay\n  await wait(duration);\n  if (options.signal && options.signal.aborted) {\n    throw new DOMException('Aborted', 'AbortError');\n  }\n  console.log(`[Mock] Fetch completed for ${url} after ${duration.toFixed(0)}ms`);\n  return new Response(JSON.stringify({ url, data: `content for ${url}` }), { status: 200 });\n};\n\n// Replace global fetch for testing (or pass mockFetch in options)\n// const originalFetch = global.fetch;\n// global.fetch = mockFetch;\n\n// Test Case 1: Rapid Firing (Debounce)\n// (async () => {\n//   console.log('\\n--- Test Case 1: Rapid Firing (Debounce) ---');\n//   const results = [];\n//   debounceFetch('/api/search?q=a').then(res => results.push(`A: ${res.url}`)).catch(err => err.name === 'AbortError' ? null : results.push(`A_Err: ${err.name}`));\n//   await wait(30);\n//   debounceFetch('/api/search?q=ab').then(res => results.push(`AB: ${res.url}`)).catch(err => err.name === 'AbortError' ? null : results.push(`AB_Err: ${err.name}`));\n//   await wait(30);\n//   debounceFetch('/api/search?q=abc').then(res => results.push(`ABC: ${res.url}`)).catch(err => err.name === 'AbortError' ? null : results.push(`ABC_Err: ${err.name}`));\n//   await wait(500); // Wait for last request to complete\n//   console.log('Final results for Test 1 (expect only ABC):', results);\n// })();\n\n// Test Case 2: Single Call (Should succeed)\n// (async () => {\n//   console.log('\\n--- Test Case 2: Single Call ---');\n//   const results = [];\n//   debounceFetch('/api/data').then(res => results.push(`Data: ${res.url}`)).catch(err => err.name === 'AbortError' ? null : results.push(`Data_Err: ${err.name}`));\n//   await wait(500);\n//   console.log('Final results for Test 2 (expect Data):', results);\n// })();\n\n// Test Case 3: Error Handling (Non-AbortError)\n// global.fetch = async (url, options) => { await wait(10); if (url === '/api/error') throw new Error('Simulated API Error'); return new Response('{}'); };\n// (async () => {\n//   console.log('\\n--- Test Case 3: Error Handling (Non-AbortError) ---');\n//   const results = [];\n//   debounceFetch('/api/error').then(res => results.push(`ErrorTest: ${res.url}`)).catch(err => results.push(`ErrorTest_Err: ${err.name || err.message}`));\n//   await wait(100);\n//   console.log('Final results for Test 3 (expect ErrorTest_Err):', results);\n// })();\n// global.fetch = originalFetch; // Restore original fetch\n*/",
          "testCases": [
            "**Rapid Sequential Calls**: Call `debounceFetch` rapidly multiple times (e.g., 3 calls with small delays between them). Only the *last* call should resolve successfully, and previous calls should be cancelled or their results ignored.",
            "**Single Call**: Call `debounceFetch` once. It should resolve normally.",
            "**Call, Wait, Call Again**: Call `debounceFetch`, wait for it to complete, then call it again. Both should resolve successfully.",
            "**External Error Handling**: Simulate a network error (not an abort) from the `fetch` call (e.g., a 404 or 500 status, or network down). Verify that the `debounceFetch` promise rejects with the actual error, assuming it was the last active request.",
            "**Edge Case: Immediate Abort**: Call `debounceFetch`, then immediately call `activeController.abort()` externally (if `activeController` is exposed). The initial call's promise should be handled as aborted.",
            "Verify no unhandled promise rejections occur due to ignored cancellations."
          ],
          "hints": [
            "You'll need a variable (`activeController`) outside the function scope (or in a closure) to keep track of the currently active `AbortController`.",
            "Before making a new fetch, check if `activeController` exists and call `activeController.abort()` if it does.",
            "Pass the new `controller.signal` to your `fetch` call's options.",
            "Wrap the `fetch` call in a `try...catch` block to specifically catch `AbortError` and handle it silently.",
            "Be careful with race conditions: even if a `fetch` resolves, a new `debounceFetch` might have been called *just before* your `.then()` handler runs. You might need to check if `activeController` is still the same *inside* the `.then()` callback."
          ],
          "tags": [
            "async",
            "promises",
            "cancellation",
            "abortcontroller",
            "debounce",
            "frontend-architecture",
            "race-conditions"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_async_cancellable_promises",
            "fetch_api",
            "closures"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "event_loop",
            "ui_patterns",
            "resource_management"
          ]
        },
        {
          "id": "task_implement_shape_factory",
          "title": "Implement a Flexible Shape Factory",
          "description": "\nImplement a `createShape` factory function that can generate different geometric shape objects (e.g., `Circle`, `Rectangle`) based on an input `type`.\n\nEach shape object should have:\n\n1.  Properties specific to its type (e.g., `radius` for `Circle`, `width` and `height` for `Rectangle`).\n2.  A common method `getArea()` that calculates and returns the area of the shape.\n3.  A common method `getType()` that returns the shape's type (e.g., 'Circle', 'Rectangle').\n\nYour solution should:\n*   Use the Factory Function pattern.\n*   Avoid `new` keyword.\n*   Ensure that methods (`getArea`, `getType`) are defined efficiently (e.g., not recreated for every instance if possible, or explain why they are).\n*   Handle invalid `type` input by throwing an error.\n",
          "difficulty": "medium",
          "startingCode": "function createShape(type, options) {\n  switch (type.toLowerCase()) {\n    case 'circle':\n      // TODO: Create a circle object\n      // Properties: radius\n      // Methods: getArea(), getType()\n      break;\n    case 'rectangle':\n      // TODO: Create a rectangle object\n      // Properties: width, height\n      // Methods: getArea(), getType()\n      break;\n    default:\n      throw new Error(`Unknown shape type: ${type}`);\n  }\n}\n\n// Example Usage:\n// const circle = createShape('circle', { radius: 5 });\n// console.log(circle.getType()); // Output: Circle\n// console.log(circle.getArea()); // Output: 78.539...\n\n// const rectangle = createShape('rectangle', { width: 10, height: 4 });\n// console.log(rectangle.getType()); // Output: Rectangle\n// console.log(rectangle.getArea()); // Output: 40\n\n// try {\n//   createShape('triangle', { side1: 3 });\n// } catch (e) {\n//   console.error(e.message); // Output: Unknown shape type: triangle\n// }",
          "solutionCode": "const PI = Math.PI;\n\n// Define common methods outside to avoid recreation per instance\nconst commonShapeMethods = {\n  getType() {\n    return this.type; // 'this' will refer to the specific shape object\n  },\n  // getArea will be defined per shape type or conditionally\n};\n\nfunction createShape(type, options) {\n  let shape;\n\n  switch (type.toLowerCase()) {\n    case 'circle':\n      if (typeof options.radius !== 'number' || options.radius < 0) {\n        throw new Error('Circle requires a positive numeric radius.');\n      }\n      shape = {\n        type: 'Circle',\n        radius: options.radius,\n        getArea: () => PI * options.radius * options.radius // Uses closure over options.radius\n      };\n      break;\n    case 'rectangle':\n      if (typeof options.width !== 'number' || typeof options.height !== 'number' || options.width < 0 || options.height < 0) {\n        throw new Error('Rectangle requires positive numeric width and height.');\n      }\n      shape = {\n        type: 'Rectangle',\n        width: options.width,\n        height: options.height,\n        getArea: () => options.width * options.height // Uses closure over options.width/height\n      };\n      break;\n    default:\n      throw new Error(`Unknown shape type: ${type}`);\n  }\n\n  // Merge common methods. Here, `getType` uses `this` which refers to the `shape` object.\n  // `getArea` is defined as a closure for specific properties, which is acceptable for factories\n  // for encapsulation, though it means a new function per instance.\n  return Object.assign(shape, commonShapeMethods);\n}\n\n// Example Usage:\n/*\nconst circle = createShape('circle', { radius: 5 });\nconsole.log(circle.getType()); // Output: Circle\nconsole.log(circle.getArea()); // Output: 78.53981633974483\n\nconst rectangle = createShape('rectangle', { width: 10, height: 4 });\nconsole.log(rectangle.getType()); // Output: Rectangle\nconsole.log(rectangle.getArea()); // Output: 40\n\nconsole.log(circle.getType === rectangle.getType); // true (shared method)\nconsole.log(circle.getArea === rectangle.getArea); // false (methods created per instance, using closure)\n\ntry {\n  createShape('triangle', { side1: 3 });\n} catch (e) {\n  console.error(e.message); // Output: Unknown shape type: triangle\n}\n\ntry {\n  createShape('circle', { radius: 'abc' });\n} catch (e) {\n  console.error(e.message); // Output: Circle requires a positive numeric radius.\n}\n\ntry {\n  createShape('rectangle', { width: -5, height: 10 });\n} catch (e) {\n  console.error(e.message); // Output: Rectangle requires positive numeric width and height.\n}\n*/",
          "testCases": [
            "Create a Circle: `createShape('circle', { radius: 7 })` should return a correct object with `type: 'Circle'`, `radius: 7`, and working `getArea()` and `getType()`.",
            "Create a Rectangle: `createShape('rectangle', { width: 8, height: 5 })` should return a correct object with `type: 'Rectangle'`, `width: 8`, `height: 5`, and working `getArea()` and `getType()`.",
            "Invalid type: `createShape('triangle', {})` should throw an `Error`.",
            "Missing/invalid options for Circle: `createShape('circle', {})` or `createShape('circle', { radius: -1 })` or `createShape('circle', { radius: 'abc' })` should throw errors.",
            "Missing/invalid options for Rectangle: `createShape('rectangle', { width: 5 })` or `createShape('rectangle', { width: -2, height: 5 })` should throw errors.",
            "Verify `getType` method is shared (e.g., `circle.getType === rectangle.getType` should be `true` if implemented optimally).",
            "Verify `getArea` method behavior (its specific calculation) for each shape."
          ],
          "hints": [
            "Use a `switch` statement based on `type`.",
            "For efficiency, `getType` could be a method defined once and applied to all shapes (e.g., using `Object.assign` or prototype chaining, though direct prototype is less common in pure factories).",
            "For `getArea`, you might define it directly in the returned object, using a closure to capture the specific dimensions. This is a common factory pattern trade-off for encapsulation.",
            "Remember to validate input `options` (e.g., `radius` must be a positive number)."
          ],
          "tags": [
            "objects",
            "factory-function",
            "design-patterns",
            "javascript-fundamentals",
            "encapsulation"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_object_creation_patterns",
            "closures"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "polymorphism",
            "creational_patterns",
            "data_validation"
          ]
        },
        {
          "id": "task_create_user_manager",
          "title": "Create a User Manager with Private State",
          "description": "\nImplement a `createUserManager` factory function that returns an object capable of managing a collection of users. The user data (`users` array) should be private to the manager instance.\n\nThe returned manager object should expose the following public methods:\n\n1.  `addUser(user)`: Adds a user object (`{ id: string, name: string, email: string }`) to the internal collection. Throws an error if a user with the same `id` already exists.\n2.  `getUser(id)`: Returns the user object with the given `id`, or `null` if not found.\n3.  `updateUser(id, updates)`: Finds a user by `id` and applies partial `updates` to it. Throws an error if the user is not found. Ensures `id` is not modifiable.\n4.  `deleteUser(id)`: Removes a user by `id`. Returns `true` if deleted, `false` if not found.\n5.  `getAllUsers()`: Returns a *copy* of the internal user array to prevent direct modification of the private state.\n\nYour solution must:\n*   Use the **Factory Function** pattern.\n*   Utilize **closures** to keep the `users` array private.\n*   Perform basic **input validation** (e.g., user `id` uniqueness, user existence).\n",
          "difficulty": "medium",
          "startingCode": "function createUserManager() {\n  let users = []; // This array should be private\n\n  return {\n    addUser(user) {\n      // TODO: Implement user addition with ID uniqueness check\n    },\n    getUser(id) {\n      // TODO: Implement user retrieval\n    },\n    updateUser(id, updates) {\n      // TODO: Implement user update (prevent ID modification)\n    },\n    deleteUser(id) {\n      // TODO: Implement user deletion\n    },\n    getAllUsers() {\n      // TODO: Return a COPY of the users array\n    }\n  };\n}\n\n// Example Usage:\n// const userManager = createUserManager();\n\n// userManager.addUser({ id: '1', name: 'Alice', email: 'alice@example.com' });\n// userManager.addUser({ id: '2', name: 'Bob', email: 'bob@example.com' });\n// console.log('All users:', userManager.getAllUsers());\n\n// console.log('Get user 1:', userManager.getUser('1'));\n\n// userManager.updateUser('1', { name: 'Alicia' });\n// console.log('Updated user 1:', userManager.getUser('1'));\n\n// console.log('Delete user 2:', userManager.deleteUser('2'));\n// console.log('All users after delete:', userManager.getAllUsers());\n\n// try {\n//   userManager.addUser({ id: '1', name: 'Charlie', email: 'charlie@example.com' });\n// } catch (e) {\n//   console.error(e.message); // Should throw: User with ID '1' already exists.\n// }",
          "solutionCode": "function createUserManager() {\n  // Private state using closure\n  let users = []; \n\n  return {\n    /**\n     * Adds a user to the manager.\n     * @param {object} user - The user object ({ id, name, email }).\n     * @throws {Error} If a user with the same ID already exists.\n     */\n    addUser(user) {\n      if (!user || !user.id) {\n        throw new Error('User object must have an id.');\n      }\n      if (users.some(u => u.id === user.id)) {\n        throw new Error(`User with ID '${user.id}' already exists.`);\n      }\n      users.push({ ...user }); // Store a copy to prevent external modification\n    },\n\n    /**\n     * Retrieves a user by ID.\n     * @param {string} id - The ID of the user to retrieve.\n     * @returns {object|null} The user object or null if not found.\n     */\n    getUser(id) {\n      const user = users.find(u => u.id === id);\n      return user ? { ...user } : null; // Return a copy\n    },\n\n    /**\n     * Updates an existing user by ID.\n     * @param {string} id - The ID of the user to update.\n     * @param {object} updates - An object containing partial updates.\n     * @throws {Error} If the user is not found.\n     */\n    updateUser(id, updates) {\n      const userIndex = users.findIndex(u => u.id === id);\n      if (userIndex === -1) {\n        throw new Error(`User with ID '${id}' not found.`);\n      }\n      // Prevent updating the ID\n      if (updates && updates.id && updates.id !== id) {\n        throw new Error('Cannot change user ID.');\n      }\n      users[userIndex] = { ...users[userIndex], ...updates };\n    },\n\n    /**\n     * Deletes a user by ID.\n     * @param {string} id - The ID of the user to delete.\n     * @returns {boolean} True if deleted, false if not found.\n     */\n    deleteUser(id) {\n      const initialLength = users.length;\n      users = users.filter(u => u.id !== id);\n      return users.length < initialLength;\n    },\n\n    /**\n     * Returns a copy of all users.\n     * @returns {Array<object>} A new array containing copies of all user objects.\n     */\n    getAllUsers() {\n      return users.map(user => ({ ...user })); // Return deep copy if users can be nested objects\n    }\n  };\n}\n\n// Example Usage:\n/*\nconst userManager = createUserManager();\n\nconsole.log('--- Add Users ---');\nuserManager.addUser({ id: '1', name: 'Alice', email: 'alice@example.com' });\nuserManager.addUser({ id: '2', name: 'Bob', email: 'bob@example.com' });\nuserManager.addUser({ id: '3', name: 'Charlie', email: 'charlie@example.com' });\nconsole.log('Initial users:', userManager.getAllUsers());\n\nconsole.log('\\n--- Get User ---');\nconsole.log('Get user 1:', userManager.getUser('1')); // { id: '1', name: 'Alice', email: 'alice@example.com' }\nconsole.log('Get non-existent user 99:', userManager.getUser('99')); // null\n\nconsole.log('\\n--- Update User ---');\nuserManager.updateUser('1', { name: 'Alicia Smith', email: 'alicia.s@example.com' });\nconsole.log('Updated user 1:', userManager.getUser('1'));\n\ntry {\n  userManager.updateUser('99', { name: 'NonExistent' });\n} catch (e) {\n  console.error('Update Error (expected):', e.message); // User with ID '99' not found.\n}\n\ntry {\n  userManager.updateUser('1', { id: 'newId' });\n} catch (e) {\n  console.error('Update ID Error (expected):', e.message); // Cannot change user ID.\n}\n\nconsole.log('\\n--- Delete User ---');\nconsole.log('Delete user 2:', userManager.deleteUser('2')); // true\nconsole.log('All users after deleting user 2:', userManager.getAllUsers());\nconsole.log('Delete non-existent user 99:', userManager.deleteUser('99')); // false\n\nconsole.log('\\n--- Add Duplicate User ---');\ntry {\n  userManager.addUser({ id: '1', name: 'Frank', email: 'frank@example.com' });\n} catch (e) {\n  console.error('Add Duplicate Error (expected):', e.message); // User with ID '1' already exists.\n}\n\nconsole.log('\\n--- Verify Privacy ---');\nconst allUsers = userManager.getAllUsers();\nallUsers.pop(); // Modify the returned copy\nconsole.log('Modified returned copy. Original users are still:', userManager.getAllUsers()); // Should be unchanged\n\nconst user1 = userManager.getUser('1');\nuser1.name = 'External Change'; // Modify the returned copy\nconsole.log('Modified returned user. Original user is still:', userManager.getUser('1')); // Should be unchanged\n*/",
          "testCases": [
            "**Add User**: Add multiple unique users. Verify `getAllUsers()` returns them correctly.",
            "**Add Duplicate User**: Attempt to add a user with an existing `id`. Verify it throws an error.",
            "**Get User**: Retrieve an existing user by `id`. Retrieve a non-existent user. Verify correct return values (`object` or `null`).",
            "**Update User**: Update an existing user's properties. Verify changes are applied. Attempt to update a non-existent user; verify error. Attempt to change a user's `id`; verify error.",
            "**Delete User**: Delete an existing user. Verify `getAllUsers()` reflects the change and `deleteUser` returns `true`. Attempt to delete a non-existent user; verify `deleteUser` returns `false`.",
            "**Privacy**: After `getAllUsers()` or `getUser(id)` is called, modify the *returned* object/array (e.g., `returnedUsers.pop()`, `returnedUser.name = 'X'`). Verify that the internal `users` array in the `userManager` remains unchanged, demonstrating privacy through copying.",
            "**Input Validation**: Test `addUser` with `null` or missing `id`."
          ],
          "hints": [
            "The `users` array inside `createUserManager` is naturally private due to the closure.",
            "For `getAllUsers()` and `getUser(id)`, remember to return *copies* of the user objects/array to prevent external code from directly modifying the private state (e.g., using `map` or spread syntax `{...user}` or `[...users]`).",
            "Use array methods like `find()`, `findIndex()`, `some()`, and `filter()` for efficient data manipulation.",
            "When updating a user, use the spread syntax (`{...existingUser, ...updates}`) to apply partial updates.",
            "For `updateUser`, explicitly check if `updates.id` is present and if it's different from the original `id` to prevent ID modification."
          ],
          "tags": [
            "objects",
            "factory-function",
            "closures",
            "data-management",
            "privacy",
            "frontend-architecture"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_object_creation_patterns",
            "array_methods",
            "closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "crud_operations",
            "state_management",
            "encapsulation"
          ]
        }
      ]
    }
  },
  {
    "id": "ea875451-4590-4345-ae70-694522064542",
    "startLine": 2100,
    "endLine": 2199,
    "processedDate": "2025-06-17T08:12:06.642Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_es6_classes",
          "title": "ES6 Classes: Syntax and Basic Usage",
          "content": "ES6 Classes provide a syntactic sugar over JavaScript's existing prototype-based inheritance. They offer a cleaner and more structured way to create objects and handle inheritance compared to traditional constructor functions and prototype chains, making code more readable and maintainable, especially for developers familiar with class-based languages. However, it's crucial to understand that under the hood, ES6 classes still operate on the prototypal inheritance model.\n\n## Key Concepts\n\n*   **`class` Keyword**: Used to declare a class. Class declarations are not hoisted, unlike function declarations.\n*   **`constructor` Method**: A special method for creating and initializing an object created with a class. There can only be one special method with the name \"constructor\" in a class. If you don't specify a constructor method, a default empty one is used.\n*   **Instance Properties**: Properties assigned within the `constructor` using `this` become instance-specific properties.\n*   **Methods**: Functions defined directly within the class body (outside the constructor) become methods on the class's prototype, meaning they are shared by all instances of the class, saving memory and allowing for method inheritance.\n*   **Instantiation**: Classes are instantiated using the `new` keyword, which calls the `constructor` method.\n\n## Class Declaration Syntax\n```javascript\nclass ClassName {\n  constructor(param1, param2) {\n    this.param1 = param1;\n    this.param2 = param2;\n  }\n\n  methodName() {\n    // Class method logic\n  }\n}\n```\n\n## Class Expression Syntax\nClasses can also be defined using expressions, which can be named or unnamed. A named class expression's name is only visible within the class scope.\n\n```javascript\n// Unnamed class expression\nconst MyClass = class {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\n// Named class expression\nconst AnotherClass = class NamedClass {\n  constructor(value) {\n    this.value = value;\n  }\n  getName() {\n    // NamedClass is accessible here\n    return NamedClass.name; \n  }\n};\n```",
          "examples": [
            {
              "id": "example_es6_classes_1",
              "title": "Basic Class Definition and Instantiation",
              "code": "class PersonClass {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  \n  getFullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n}\n\nconst alice = new PersonClass('Alice', 'Johnson');\nconsole.log(alice.getFullName()); // Alice Johnson\nconsole.log(alice.firstName);     // Alice\n",
              "explanation": "This example demonstrates a basic `PersonClass` with a constructor to initialize `firstName` and `lastName`, and a `getFullName` method. An instance `alice` is created using `new`, and its method is called.",
              "language": "javascript"
            },
            {
              "id": "example_es6_classes_2",
              "title": "Understanding Class Methods and Prototype",
              "code": "class Car {\n  constructor(make, model) {\n    this.make = make;\n    this.model = model;\n  }\n  \n  getDetails() {\n    return `${this.make} ${this.model}`;\n  }\n}\n\nconst myCar = new Car('Toyota', 'Camry');\nconst otherCar = new Car('Honda', 'Civic');\n\n// getDetails is a method on the prototype, shared by all instances\nconsole.log(myCar.getDetails === otherCar.getDetails); // true\nconsole.log(myCar.hasOwnProperty('getDetails')); // false (it's on prototype)\n",
              "explanation": "This example illustrates that methods defined within a class body (like `getDetails`) are added to the class's prototype (`Car.prototype`), not directly to each instance. This allows all instances to share the same method, promoting memory efficiency. Instance-specific properties (like `make`, `model`) are defined in the constructor using `this`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_es6_classes_1",
            "question_es6_classes_2",
            "question_es6_classes_3",
            "question_es6_classes_4"
          ],
          "relatedTasks": [
            "task_es6_classes_1"
          ],
          "tags": [
            "ES6",
            "Classes",
            "OOP",
            "JavaScript",
            "Frontend"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "this_keyword"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_components",
            "angular_components"
          ]
        },
        {
          "id": "theory_prototypal_inheritance",
          "title": "Prototypal Inheritance in JavaScript",
          "content": "JavaScript is a prototype-based language, meaning that objects inherit properties and methods from other objects. This is a fundamental concept distinct from class-based inheritance found in languages like Java or C++. Every JavaScript object has an internal `[[Prototype]]` property (accessible via `__proto__` or `Object.getPrototypeOf()`) that links to another object, forming a 'prototype chain'. When a property or method is accessed on an object, if it's not found directly on the object itself, the JavaScript engine looks up the prototype chain until it finds the property or reaches the end of the chain (null).\n\n## Key Concepts\n\n*   **Prototype Chain**: A series of links from one object's `[[Prototype]]` to another, ending in `null`. This chain determines how properties and methods are inherited.\n*   **`prototype` Property of Functions**: Functions in JavaScript automatically get a `prototype` property. This property is an object that becomes the `[[Prototype]]` of objects created with `new` using that function as a constructor.\n*   **Constructor Functions**: Historically, objects were created using constructor functions, where methods and shared properties were added to the `constructor.prototype`.\n*   **`__proto__`**: A non-standard, but widely supported, property that exposes an object's `[[Prototype]]`. While useful for inspection, `Object.getPrototypeOf()` and `Object.setPrototypeOf()` are the standard ways to interact with prototypes.\n*   **`Object.create()`**: A method for creating a new object, using an existing object as the prototype of the newly created object. This is a clean way to implement prototypal inheritance without constructor functions.\n\n## How Prototypal Inheritance Works\nWhen you try to access a property `prop` on an object `obj`:\n1.  The engine first checks if `prop` exists directly on `obj`.\n2.  If not, it checks `obj`'s prototype (`obj.__proto__`).\n3.  If still not found, it checks the prototype's prototype, and so on.\n4.  This continues until the property is found or the end of the prototype chain (which is `null`) is reached. If not found, `undefined` is returned.\n\n## Modifying Prototypes\nModifying a prototype affects all objects that inherit from it. If you reassign the `prototype` property of a constructor function *after* instances have been created, those existing instances will retain a link to the *original* prototype object. New instances created after the reassignment will link to the *new* prototype object. This can lead to unexpected behavior if not understood.",
          "examples": [
            {
              "id": "example_prototypal_inheritance_1",
              "title": "Basic Prototype Inheritance with Constructor Functions",
              "code": "function Main() {}\nMain.prototype = { protected: true, someMethod: function() { console.log('Method from prototype'); } };\nconst obj = new Main();\n\nconsole.log('Object protection (initial): ', obj.protected); // true\nobj.someMethod(); // Method from prototype\n\n// Reassigning Main.prototype AFTER obj is created\nMain.prototype = { protected: false, anotherMethod: function() { console.log('New method'); } };\n\nconsole.log('Object protection (after reassign): ', obj.protected); // true (obj still links to the OLD prototype)\n// obj.anotherMethod(); // TypeError: obj.anotherMethod is not a function (obj doesn't have the new method)\n\nconst newObj = new Main();\nconsole.log('New object protection: ', newObj.protected); // false (newObj links to the NEW prototype)\nnewObj.anotherMethod(); // New method\n",
              "explanation": "This example illustrates a critical aspect of prototypal inheritance: when an object is created using `new`, its `[[Prototype]]` link is established to the `prototype` object that the constructor function *currently* points to. Subsequent reassignment of `Constructor.prototype` will *not* affect already existing instances, only new ones.",
              "language": "javascript"
            },
            {
              "id": "example_prototypal_inheritance_2",
              "title": "Prototypal Inheritance with Object.create",
              "code": "const animal = {\n  init: function(name) {\n    this.name = name;\n    return this;\n  },\n  eat: function() {\n    console.log(`${this.name} is eating.`);\n  }\n};\n\nconst dog = Object.create(animal);\ndog.bark = function() {\n  console.log(`${this.name} is barking.`);\n};\n\nconst bingo = Object.create(dog).init('Bingo');\nbingo.eat();  // Bingo is eating.\nbingo.bark(); // Bingo is barking.\nconsole.log(Object.getPrototypeOf(bingo) === dog); // true\nconsole.log(Object.getPrototypeOf(dog) === animal); // true\n",
              "explanation": "`Object.create()` creates a new object and sets its `[[Prototype]]` to the specified object. Here, `dog` inherits from `animal`, and `bingo` inherits from `dog`. This creates a prototype chain: `bingo` -> `dog` -> `animal` -> `Object.prototype` -> `null`. `bingo` can access methods from `dog` (its direct prototype) and `animal` (via `dog`'s prototype). The `init` method is used for initialization as `Object.create` does not call a constructor.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_prototypal_inheritance_1",
            "question_prototypal_inheritance_2",
            "question_prototypal_inheritance_3",
            "question_prototypal_inheritance_4",
            "question_prototypal_inheritance_5"
          ],
          "relatedTasks": [
            "task_prototypal_inheritance_1",
            "task_prototypal_inheritance_2"
          ],
          "tags": [
            "JavaScript",
            "Inheritance",
            "Prototypes",
            "OOP",
            "Fundamental"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "functions_as_first_class_citizens"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_javascript",
            "understanding_frameworks"
          ]
        },
        {
          "id": "theory_class_inheritance",
          "title": "ES6 Class Inheritance",
          "content": "ES6 classes introduce the `extends` keyword, providing a much cleaner and more familiar syntax for implementing inheritance compared to traditional prototypal inheritance. Despite the syntactic sugar, it still leverages JavaScript's underlying prototype chain. When one class `extends` another, it creates a prototype chain where the child class's prototype inherits from the parent class's prototype.\n\n## Key Concepts\n\n*   **`extends` Keyword**: Used to create a class that is a child of another class. The child class inherits all methods and properties from the parent class.\n*   **`super()` Keyword**: In a subclass constructor, `super()` must be called before `this` can be accessed. `super()` calls the constructor of the parent class, ensuring that the parent class's properties are initialized on the instance. If a subclass does not have a constructor, a default one is provided that calls `super()`.\n*   **Method Overriding**: A subclass can provide its own implementation for a method that is already defined in its superclass. To call the parent class's method from the overridden method, use `super.methodName()`.\n*   **`instanceof` Operator**: This operator checks if an object is an instance of a particular class (or a class that inherits from it) in its prototype chain. `childInstance instanceof ChildClass` and `childInstance instanceof ParentClass` will both return `true`.\n\n## Inheritance Process\n1.  When a `ChildClass` `extends` a `ParentClass`:\n    *   `ChildClass.prototype.__proto__` is set to `ParentClass.prototype`.\n    *   `ChildClass.__proto__` (the static `[[Prototype]]`) is set to `ParentClass` (allowing inheritance of static methods).\n2.  When `new ChildClass()` is called:\n    *   A new instance `this` is created.\n    *   The `ChildClass` constructor is executed.\n    *   If `super()` is called, the `ParentClass` constructor is executed on the `this` context, initializing parent properties.\n    *   After `super()`, `this` can be used to add child-specific properties.\n\nUnderstanding `super()` is crucial: when used as a function (`super()`), it calls the parent constructor. When used as an object (`super.methodName`), it refers to the parent's prototype methods.",
          "examples": [
            {
              "id": "example_class_inheritance_1",
              "title": "Basic Class Inheritance",
              "code": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name); // Call parent constructor with 'name'\n    this.breed = breed; // Add Dog-specific property\n  }\n  \n  bark() {\n    console.log(`${this.name} is barking.`);\n  }\n}\n\nconst rex = new Dog('Rex', 'German Shepherd');\nrex.eat();  // Rex is eating. (inherited from Animal)\nrex.bark(); // Rex is barking. (Dog's own method)\nconsole.log(rex.breed); // German Shepherd\n",
              "explanation": "This example shows `Dog` extending `Animal`. The `Dog` constructor calls `super(name)` to initialize the `name` property from the `Animal` class, then adds its own `breed` property. `rex` can call both its own `bark` method and the inherited `eat` method.",
              "language": "javascript"
            },
            {
              "id": "example_class_inheritance_2",
              "title": "Method Overriding and Calling Super Method",
              "code": "class Vehicle {\n  start() {\n    return 'Vehicle starting...';\n  }\n  stop() {\n    return 'Vehicle stopping...';\n  }\n}\n\nclass Car extends Vehicle {\n  start() {\n    console.log(super.start()); // Call the parent's start method\n    return 'Car engine ignites!';\n  }\n  honk() {\n    return 'Beep beep!';\n  }\n}\n\nconst myCar = new Car();\nconsole.log(myCar.start());\n// Expected Output:\n// Vehicle starting...\n// Car engine ignites!\nconsole.log(myCar.stop()); // Vehicle stopping...\n",
              "explanation": "Here, `Car` overrides the `start` method from `Vehicle`. Inside the `Car`'s `start` method, `super.start()` is used to explicitly call the overridden `start` method from the `Vehicle` parent class. This demonstrates how to extend and modify parent behavior while still leveraging its original logic.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_class_inheritance_1",
            "question_class_inheritance_2",
            "question_class_inheritance_3",
            "question_class_inheritance_4",
            "question_class_inheritance_5"
          ],
          "relatedTasks": [
            "task_class_inheritance_1"
          ],
          "tags": [
            "ES6",
            "Classes",
            "Inheritance",
            "OOP",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_es6_classes",
            "theory_prototypal_inheritance"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_class_components",
            "vue_components",
            "angular_components"
          ]
        },
        {
          "id": "theory_object_descriptors_attributes",
          "title": "Object Descriptors and Property Attributes",
          "content": "In JavaScript, every property of an object has a set of attributes that define its behavior. These attributes are not directly visible when you access a property, but they control how the property can be read, written, enumerated, and configured. `Object.defineProperty()` and `Object.defineProperties()` are powerful methods that allow direct manipulation of these attributes, giving fine-grained control over object properties.\n\n## Key Concepts\n\nProperties can be categorized into two main types:\n\n1.  **Data Properties**: These hold a value.\n    *   **`value`**: The actual value of the property. (Default: `undefined`)\n    *   **`writable`**: A boolean indicating whether the property's `value` can be changed using the assignment operator (`=`). (Default: `false`)\n    *   **`enumerable`**: A boolean indicating whether the property will show up during enumeration (e.g., in `for...in` loops, `Object.keys()`, `JSON.stringify()`). (Default: `false`)\n    *   **`configurable`**: A boolean indicating whether the property's descriptor can be changed (i.e., its attributes reconfigured), and whether the property can be deleted from the object. (Default: `false`)\n\n2.  **Accessor Properties (Getters and Setters)**: These do not hold a value directly but instead consist of a getter function and/or a setter function.\n    *   **`get`**: A function that serves as a getter for the property. When the property is read, this function is called. (Default: `undefined`)\n    *   **`set`**: A function that serves as a setter for the property. When the property is assigned a value, this function is called. (Default: `undefined`)\n    *   **`enumerable`**: Same as for data properties. (Default: `false`)\n    *   **`configurable`**: Same as for data properties. (Default: `false`)\n\n    *Important Note*: An accessor property cannot have `value` or `writable` attributes. It must have either `get` or `set` (or both) and its `enumerable` and `configurable` attributes.\n\n## `Object.defineProperty()`\n\nSyntax:\n`Object.defineProperty(obj, prop, descriptor)`\n\n*   `obj`: The object on which to define the property.\n*   `prop`: The name of the property to be defined or modified.\n*   `descriptor`: An object whose properties specify the attributes for the property being defined or modified. If an attribute is omitted from the descriptor, its default value (usually `false` for boolean flags, `undefined` for `value`/`get`/`set`) is used.\n\nThis method returns the object that had the property defined.\n\n## Default Attribute Values\nWhen a property is created in a typical way (e.g., `obj.prop = value` or within an object literal `{ prop: value }`), its attributes default to `true` for `writable`, `enumerable`, and `configurable`. When `Object.defineProperty` is used without explicitly setting these, they default to `false`.\n\nThis distinction is crucial for understanding why `Object.defineProperty` provides such strong control.",
          "examples": [
            {
              "id": "example_object_descriptors_1",
              "title": "Defining Data Properties with Attributes",
              "code": "const user = {};\n\nObject.defineProperty(user, 'name', {\n  value: 'John Doe',\n  writable: true,      // Allows name to be changed\n  enumerable: true,    // Allows name to show up in for...in loops, Object.keys()\n  configurable: true   // Allows name to be deleted or its attributes to be modified\n});\n\nObject.defineProperty(user, 'id', {\n  value: 12345,\n  writable: false,     // Makes id read-only\n  enumerable: false,   // Hides id from enumeration\n  configurable: false  // Prevents id from being deleted or its attributes changed\n});\n\nconsole.log(user.name); // John Doe\nuser.name = 'Jane Doe';\nconsole.log(user.name); // Jane Doe\n\nconsole.log(user.id);   // 12345\ntry {\n  user.id = 54321; // Attempt to change read-only property\n} catch (e) {\n  console.log('Error setting id:', e.message); // In strict mode, this would throw a TypeError\n} \nconsole.log(user.id); // 12345 (value remains unchanged)\n\nfor (let key in user) {\n  console.log(key); // Only 'name' will be logged, 'id' is not enumerable\n}\n\ndelete user.name; // Allowed because configurable: true\nconsole.log(user.name); // undefined\n\ntry {\n  delete user.id; // Not allowed because configurable: false\n} catch (e) {\n  console.log('Error deleting id:', e.message); // In strict mode, this would throw a TypeError\n}\nconsole.log(user.id); // 12345 (value remains)\n\n// Attempt to redefine 'id' property (will fail)\ntry {\n  Object.defineProperty(user, 'id', { writable: true });\n} catch (e) {\n  console.log('Error reconfiguring id:', e.message); // TypeError: Cannot redefine property: id\n}\n",
              "explanation": "This example demonstrates how `writable`, `enumerable`, and `configurable` attributes control property behavior. `name` is fully mutable, enumerable, and configurable. `id` is a read-only, non-enumerable, non-configurable property, showing how its value cannot be changed, it won't appear in `for...in` loops, and its attributes cannot be altered.",
              "language": "javascript"
            },
            {
              "id": "example_object_descriptors_2",
              "title": "Defining Accessor Properties (Getters and Setters)",
              "code": "const person = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\nObject.defineProperty(person, 'fullName', {\n  get: function() {\n    console.log('Getting fullName...');\n    return `${this.firstName} ${this.lastName}`;\n  },\n  set: function(value) {\n    console.log('Setting fullName to:', value);\n    const parts = value.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1] || '';\n  },\n  enumerable: true, // Make it enumerable so it shows up like a regular property\n  configurable: true // Allow it to be deleted or reconfigured\n});\n\nconsole.log(person.fullName); // Getting fullName...\n                              // John Doe\n\nperson.fullName = 'Jane Smith'; // Setting fullName to: Jane Smith\nconsole.log(person.firstName); // Jane\nconsole.log(person.lastName);  // Smith\nconsole.log(person.fullName); // Getting fullName...\n                              // Jane Smith\n\n// Attempt to define value/writable on an accessor property (will throw error)\ntry {\n  Object.defineProperty(person, 'age', {\n    value: 30,\n    get: function() { return this._age; }\n  });\n} catch (e) {\n  console.error('Error defining mixed property:', e.message);\n  // TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute\n}\n",
              "explanation": "This example creates a `fullName` accessor property on `person`. When `person.fullName` is read, the `get` function is called. When `person.fullName` is assigned a value, the `set` function is called, which then updates `firstName` and `lastName`. This demonstrates how getters and setters can provide calculated properties or control how values are set, decoupling direct property access from underlying data storage. It also shows the error when attempting to mix `value`/`writable` with `get`/`set`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_object_descriptors_1",
            "question_object_descriptors_2",
            "question_object_descriptors_3",
            "question_object_descriptors_4",
            "question_object_descriptors_5"
          ],
          "relatedTasks": [
            "task_object_descriptors_1"
          ],
          "tags": [
            "JavaScript",
            "Objects",
            "Descriptors",
            "Attributes",
            "Advanced",
            "Meta-programming"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "functions_as_first_class_citizens"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "proxy_api",
            "custom_frameworks"
          ]
        },
        {
          "id": "theory_this_keyword",
          "title": "Understanding the `this` Keyword in JavaScript",
          "content": "The `this` keyword in JavaScript is one of the most frequently misunderstood concepts. Its value is not determined by where the function is defined, but by *how* and *where* the function is called. This dynamic nature means `this` can refer to different objects depending on the execution context. Understanding `this` is fundamental for working with objects, classes, and event handlers.\n\n## Key Binding Rules for `this`\n\nThere are generally four main rules that determine the value of `this`:\n\n1.  **Default Binding (Global Object)**: If a function is called in strict mode, `this` is `undefined`. In non-strict mode, `this` refers to the global object (`window` in browsers, `global` in Node.js).\n    ```javascript\n    function showThis() { console.log(this); }\n    showThis(); // In browser: Window object; In strict mode: undefined\n    ```\n\n2.  **Implicit Binding (Object Method Call)**: When a function is called as a method of an object, `this` refers to the object that owns the method.\n    ```javascript\n    const person = { \n      name: 'Alice', \n      greet: function() { console.log(`Hello, I'm ${this.name}`); }\n    };\n    person.greet(); // this refers to 'person'\n    ```\n\n3.  **Explicit Binding (`call`, `apply`, `bind`)**: You can explicitly set the value of `this` using `call()`, `apply()`, or `bind()` methods available on all functions.\n    *   `call(thisArg, arg1, arg2, ...)`: Executes the function immediately with `this` set to `thisArg` and arguments passed individually.\n    *   `apply(thisArg, [argsArray])`: Executes the function immediately with `this` set to `thisArg` and arguments passed as an array.\n    *   `bind(thisArg)`: Returns a *new* function with `this` permanently bound to `thisArg`. The function is not executed immediately.\n    ```javascript\n    function introduce(age) { console.log(`My name is ${this.name} and I'm ${age}.`); }\n    const user = { name: 'Bob' };\n    introduce.call(user, 30);  // My name is Bob and I'm 30.\n    const boundIntroduce = introduce.bind(user, 40);\n    boundIntroduce(); // My name is Bob and I'm 40.\n    ```\n\n4.  **New Binding (Constructor Call)**: When a function is called with the `new` keyword (as a constructor), `this` refers to the newly created object instance.\n    ```javascript\n    function Person(name) { this.name = name; }\n    const john = new Person('John'); // this refers to 'john' instance\n    console.log(john.name); // John\n    ```\n\n## Arrow Functions and `this`\n\nArrow functions (`=>`) behave differently regarding `this`. They do not have their own `this` context. Instead, they lexically inherit `this` from their enclosing scope at the time they are defined. This means `this` inside an arrow function will always be the same as `this` in the code that immediately contains the arrow function. This makes them very useful for callbacks and methods where you want `this` to refer to the surrounding context, not the context of the function's invocation.\n\n```javascript\nconst counter = {\n  count: 0,\n  start: function() {\n    setInterval(() => {\n      // 'this' here refers to 'counter' due to lexical scoping\n      this.count++; \n      console.log(this.count);\n    }, 1000);\n  },\n  stop: function() {\n    setInterval(function() {\n      // 'this' here refers to the global object (or undefined in strict mode)\n      // because it's a regular function called by setInterval (default binding)\n      // console.log(this.count); // This would likely fail or log undefined/NaN\n    }, 1000);\n  }\n};\ncounter.start();\n```",
          "examples": [
            {
              "id": "example_this_keyword_1",
              "title": "Demonstrating `this` in various contexts",
              "code": "class Greeter {\n  constructor(name) {\n    this.name = name;\n  }\n\n  // Method defined on prototype, 'this' refers to instance\n  greet() {\n    console.log(`Hello, ${this.name}`);\n  }\n\n  // Arrow function method, 'this' lexically binds to instance\n  greetArrow = () => {\n    console.log(`Arrow Hello, ${this.name}`);\n  }\n\n  // Example with callback - problematic 'this'\n  delayedGreetProblem() {\n    setTimeout(function() {\n      // 'this' here is likely Window/undefined, not the Greeter instance\n      console.log(`Delayed Hello, ${this.name}`); \n    }, 100);\n  }\n\n  // Example with callback - fixed 'this' using arrow function\n  delayedGreetFixed() {\n    setTimeout(() => {\n      // 'this' here correctly refers to the Greeter instance\n      console.log(`Fixed Delayed Hello, ${this.name}`);\n    }, 100);\n  }\n}\n\nconst person = new Greeter('Alice');\nperson.greet(); // Hello, Alice\nperson.greetArrow(); // Arrow Hello, Alice\n\nperson.delayedGreetProblem(); // Delayed Hello, undefined (or error in strict mode)\nperson.delayedGreetFixed(); // Fixed Delayed Hello, Alice\n\n// Detached method call - 'this' becomes global/undefined\nconst detachedGreet = person.greet;\ndetachedGreet(); // Hello, undefined (or error in strict mode)\n",
              "explanation": "This example illustrates how `this` behaves in different scenarios: as a method on an object (`person.greet()`), as a lexically bound arrow function (`person.greetArrow()`), and in callbacks. It highlights the common pitfall of `this` losing context in regular function callbacks and how arrow functions solve this by inheriting `this` from their surrounding scope.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_this_keyword_1",
            "question_this_keyword_2",
            "question_this_keyword_3",
            "question_this_keyword_4"
          ],
          "relatedTasks": [
            "task_this_keyword_1"
          ],
          "tags": [
            "JavaScript",
            "this",
            "Context",
            "Execution",
            "Functions",
            "OOP"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_objects"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_components",
            "event_handling",
            "callback_functions"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_es6_classes_1",
          "topic": "ES6 Classes Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `constructor` method in an ES6 class?",
          "answer": "To create and initialize an object created with a class.",
          "options": [],
          "analysisPoints": [
            "Understanding the role of the constructor in class instantiation.",
            "Distinguishing it from regular methods."
          ],
          "keyConcepts": [
            "Class constructor",
            "Object initialization",
            "Instance properties"
          ],
          "evaluationCriteria": [
            "Basic knowledge of ES6 class syntax."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Constructor"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_es6_classes_2",
          "topic": "ES6 Classes vs. Traditional Constructors",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code snippets:\n\n**Snippet A:**\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    return `Hello, ${this.name}`;\n  }\n}\n```\n\n**Snippet B:**\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHello = function() {\n  return `Hello, ${this.name}`;\n};\n```\n\nWhich statement accurately describes the relationship between Snippet A (ES6 Class) and Snippet B (Traditional Constructor Function)?",
          "answer": "Snippet A is syntactic sugar over Snippet B, meaning they both result in similar underlying prototypal inheritance mechanisms.",
          "options": [
            "Snippet A uses classical inheritance, while Snippet B uses prototypal inheritance.",
            "Snippet A is more performant than Snippet B due to JavaScript engine optimizations.",
            "Snippet A is syntactic sugar over Snippet B, meaning they both result in similar underlying prototypal inheritance mechanisms.",
            "Snippet B allows for private methods, which are not possible with Snippet A."
          ],
          "analysisPoints": [
            "Recognizing that ES6 classes are syntactic sugar.",
            "Understanding that JavaScript fundamentally uses prototypal inheritance.",
            "Dispelling common misconceptions about class-based vs. prototypal inheritance in JavaScript."
          ],
          "keyConcepts": [
            "ES6 Classes",
            "Prototypal Inheritance",
            "Syntactic Sugar",
            "Constructor Functions"
          ],
          "evaluationCriteria": [
            "Deep understanding of JavaScript's inheritance model.",
            "Ability to differentiate syntax from underlying mechanism."
          ],
          "example": "Both snippets produce objects where `sayHello` is found on the `Person.prototype`. This means that instances created from either will share the same `sayHello` method, demonstrating that ES6 classes are indeed a more convenient way to write the same underlying prototypal pattern.\n\n```javascript\n// Test for Snippet A\nconst personA = new Person('Alice');\nconsole.log(personA.sayHello());\n\n// Test for Snippet B\nconst personB = new Person('Bob');\nconsole.log(personB.sayHello());\n\n// Both methods are on the prototype:\nconsole.log(Object.getPrototypeOf(personA).sayHello === Person.prototype.sayHello); // true\nconsole.log(Object.getPrototypeOf(personB).sayHello === Person.prototype.sayHello); // true\n```",
          "tags": [
            "ES6",
            "Classes",
            "Prototypal Inheritance",
            "Syntactic Sugar"
          ],
          "prerequisites": [
            "theory_es6_classes",
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_es6_classes_3",
          "topic": "Class Methods and Prototype",
          "level": "medium",
          "type": "open",
          "question": "Where are methods defined directly within an ES6 class body (e.g., `getFullName()` in `PersonClass`) stored, and why is this design beneficial for performance and memory usage when creating multiple instances?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explain that methods are stored on the class's `prototype`.",
            "Discuss memory efficiency: only one copy of the method exists, shared by all instances.",
            "Explain performance: method lookup follows the prototype chain, which is efficient."
          ],
          "keyConcepts": [
            "Class methods",
            "Prototype chain",
            "Memory management",
            "Performance optimization"
          ],
          "evaluationCriteria": [
            "Ability to explain prototypal inheritance's role in ES6 classes.",
            "Understanding of memory and performance implications."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Prototype",
            "Performance",
            "Memory"
          ],
          "prerequisites": [
            "theory_es6_classes",
            "theory_prototypal_inheritance"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_es6_classes_4",
          "topic": "Class Declaration vs. Expression Hoisting",
          "level": "easy",
          "type": "flashcard",
          "question": "Are ES6 Class Declarations hoisted in the same way as `function` declarations?",
          "answer": "No. ES6 Class Declarations are not hoisted. You cannot access a class before it is defined, which results in a `ReferenceError`.",
          "options": [],
          "analysisPoints": [
            "Understanding the difference in hoisting behavior between functions and classes.",
            "Identifying potential `ReferenceError` scenarios."
          ],
          "keyConcepts": [
            "Hoisting",
            "Class Declaration",
            "Function Declaration",
            "Temporal Dead Zone"
          ],
          "evaluationCriteria": [
            "Basic knowledge of JavaScript hoisting rules."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Hoisting",
            "ReferenceError"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_prototypal_inheritance_1",
          "topic": "Prototype Chain Lookup",
          "level": "easy",
          "type": "flashcard",
          "question": "When you try to access a property on an object in JavaScript, and that property is not found directly on the object, what mechanism does JavaScript use to try and find it?",
          "answer": "It looks up the prototype chain until it finds the property or reaches the end of the chain (null).",
          "options": [],
          "analysisPoints": [
            "Understanding the fundamental lookup mechanism in prototypal inheritance."
          ],
          "keyConcepts": [
            "Prototype chain",
            "Property lookup",
            "Inheritance"
          ],
          "evaluationCriteria": [
            "Basic understanding of prototypal inheritance."
          ],
          "example": null,
          "tags": [
            "Prototypes",
            "Inheritance",
            "JavaScript Fundamentals"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_prototypal_inheritance_2",
          "topic": "Object.create() vs. new Constructor()",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the difference in how `Object.create()` and the `new` keyword (with a constructor function) create objects in terms of their `[[Prototype]]`?",
          "answer": "`Object.create(protoObject)` sets the new object's `[[Prototype]]` directly to `protoObject`, whereas `new Constructor()` sets the new object's `[[Prototype]]` to `Constructor.prototype`.",
          "options": [
            "`Object.create()` creates objects without any prototype, while `new` always assigns `Object.prototype`.",
            "`Object.create(protoObject)` sets the new object's `[[Prototype]]` directly to `protoObject`, whereas `new Constructor()` sets the new object's `[[Prototype]]` to `Constructor.prototype`.",
            "`new` always calls a constructor, while `Object.create()` does not and requires manual initialization.",
            "`Object.create()` can only create objects with `null` prototype, while `new` can create objects with any prototype."
          ],
          "analysisPoints": [
            "Distinguishing the core mechanism of `Object.create()` (direct prototype assignment) from `new` (prototype via constructor's `prototype` property).",
            "Understanding the role of `Constructor.prototype`.",
            "Recognizing that `Object.create` does not invoke a constructor function.",
            "Identifying common misconceptions about `null` prototypes."
          ],
          "keyConcepts": [
            "Object.create",
            "New keyword",
            "Prototypal Inheritance",
            "Constructor Functions",
            "[[Prototype]]"
          ],
          "evaluationCriteria": [
            "Detailed understanding of object creation patterns.",
            "Ability to explain the underlying prototype linkages."
          ],
          "example": "```javascript\n// Using new\nfunction Vehicle() {}\nVehicle.prototype.wheels = 4;\nconst car = new Vehicle();\nconsole.log(Object.getPrototypeOf(car) === Vehicle.prototype); // true\n\n// Using Object.create\nconst animalPrototype = { legs: 4 };\nconst dog = Object.create(animalPrototype);\nconsole.log(Object.getPrototypeOf(dog) === animalPrototype); // true\n```",
          "tags": [
            "Prototypes",
            "Object.create",
            "New Keyword",
            "Inheritance"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prototypal_inheritance_3",
          "topic": "Dynamic Prototype Reassignment",
          "level": "hard",
          "type": "code",
          "question": "Analyze the following code and predict the output. Explain why `obj.protected` returns `true` even after `Main.prototype` is reassigned to `{ protected: false }`.",
          "answer": "```javascript\n// Output:\n// Object protection:  true\n\n// Explanation:\n// When `obj` is created with `const obj = new Main();`, its internal `[[Prototype]]` link (`obj.__proto__`) is set to point to the `Main.prototype` object *at that specific moment*. \n// At that time, `Main.prototype` was `{ protected: true }`. \n// When `Main.prototype` is later reassigned to a *new object* `{ protected: false }`, `obj`'s `[[Prototype]]` link does not change. It still points to the *original* prototype object. \n// Therefore, when `obj.protected` is accessed, the JavaScript engine looks up the prototype chain, finds `protected: true` on the original prototype object, and returns it.\n// Only new instances created *after* the `Main.prototype` reassignment would inherit from the new prototype.",
          "options": [],
          "analysisPoints": [
            "Understanding that an object's prototype link is established at creation time.",
            "Explaining the difference between modifying an existing prototype object and reassigning the `prototype` property to a new object.",
            "Predicting the exact output based on prototypal chain lookup."
          ],
          "keyConcepts": [
            "Prototypal Inheritance",
            "Prototype Chain",
            "Object Creation",
            "Reference vs. Value Semantics"
          ],
          "evaluationCriteria": [
            "Ability to debug and trace prototypal inheritance.",
            "Clear explanation of the underlying mechanism."
          ],
          "example": "```javascript\n// Basic prototype inheritance\nfunction Main() {}\nMain.prototype = { protected: true };\nconst obj = new Main();\nMain.prototype = { protected: false };\nconsole.log('Object protection: ', obj.protected); // true\n```",
          "tags": [
            "Prototypes",
            "Inheritance",
            "Debugging",
            "Advanced JavaScript"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_prototypal_inheritance_4",
          "topic": "Prototypal vs. Classical Inheritance",
          "level": "medium",
          "type": "open",
          "question": "JavaScript is often described as a 'prototype-based' language, contrasting with 'class-based' languages like Java or C++. Explain the fundamental difference between these two inheritance models and how JavaScript achieves inheritance using prototypes.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Define classical inheritance (blueprints, instances are copies).",
            "Define prototypal inheritance (objects inheriting from other objects).",
            "Explain how JavaScript achieves this via `[[Prototype]]` links and the prototype chain lookup.",
            "Discuss the concept of delegation vs. copying."
          ],
          "keyConcepts": [
            "Prototypal Inheritance",
            "Classical Inheritance",
            "Prototype Chain",
            "Delegation"
          ],
          "evaluationCriteria": [
            "Clear articulation of fundamental OOP concepts.",
            "Ability to compare and contrast programming paradigms."
          ],
          "example": null,
          "tags": [
            "Prototypes",
            "Inheritance",
            "OOP",
            "Concepts"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prototypal_inheritance_5",
          "topic": "Prototype Chain and `__proto__`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the standard way to programmatically access an object's prototype in JavaScript, and what is the difference between `obj.__proto__` and `obj.prototype`?",
          "answer": "The standard way to access an object's prototype is `Object.getPrototypeOf(obj)`. \n\n`obj.__proto__` is a non-standard (though widely supported) accessor property that exposes the internal `[[Prototype]]` of an object. It represents the actual object from which `obj` inherits.\n\n`obj.prototype` is only relevant for *constructor functions* and *classes*. It refers to the object that will become the `[[Prototype]]` of instances created by that constructor/class. Regular objects do not have a `prototype` property.",
          "options": [],
          "analysisPoints": [
            "Distinguishing between the instance's prototype (`__proto__` / `Object.getPrototypeOf`) and a constructor's `prototype` property.",
            "Highlighting the standard vs. non-standard access methods."
          ],
          "keyConcepts": [
            "Prototype",
            "[[Prototype]]",
            "Constructor.prototype",
            "Object.getPrototypeOf",
            "__proto__"
          ],
          "evaluationCriteria": [
            "Accuracy in defining core prototype concepts.",
            "Knowledge of standard API vs. legacy properties."
          ],
          "example": null,
          "tags": [
            "Prototypes",
            "JavaScript Objects",
            "API"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_inheritance_1",
          "topic": "ES6 Class Inheritance Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary keyword used in ES6 to establish an inheritance relationship between two classes?",
          "answer": "`extends`",
          "options": [],
          "analysisPoints": [
            "Basic knowledge of ES6 class inheritance syntax."
          ],
          "keyConcepts": [
            "Class Inheritance",
            "Extends Keyword"
          ],
          "evaluationCriteria": [
            "Understanding core ES6 syntax."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Inheritance"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_inheritance_2",
          "topic": "Super Keyword in Class Inheritance",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following ES6 class structure:\n\n```javascript\nclass BaseEntity {\n  constructor(id) {\n    this.id = id;\n  }\n  getInfo() {\n    return `ID: ${this.id}`;\n  }\n}\n\nclass User extends BaseEntity {\n  constructor(id, username) {\n    // Line A\n    this.username = username;\n  }\n  getUserInfo() {\n    return `${this.username} - ${this.getInfo()}`;\n  }\n}\n\nconst user = new User(1, 'jsdev');\n```\n\nWhat would happen if `Line A` is the only line missing in the `User` class constructor, and you try to create an instance of `User`? And what is the correct way to fix it?",
          "answer": "A `ReferenceError` would be thrown because `this` cannot be accessed before `super()` is called in a subclass constructor. The correct fix is to add `super(id);` as `Line A`.",
          "options": [
            "The `username` property would be undefined, but no error would be thrown.",
            "A `TypeError` would be thrown because the `BaseEntity` constructor was not called.",
            "A `ReferenceError` would be thrown because `this` cannot be accessed before `super()` is called in a subclass constructor. The correct fix is to add `super(id);` as `Line A`.",
            "The code would work fine, as ES6 classes automatically call the parent constructor."
          ],
          "analysisPoints": [
            "Understanding the mandatory call to `super()` in subclass constructors.",
            "Knowing that `this` is not available in a subclass constructor until `super()` is called.",
            "Identifying the specific type of error (`ReferenceError`)."
          ],
          "keyConcepts": [
            "Class Inheritance",
            "Super Keyword",
            "Constructor",
            "ReferenceError",
            "This Keyword"
          ],
          "evaluationCriteria": [
            "Knowledge of `super()` and its implications for `this`.",
            "Ability to identify and correct common inheritance issues."
          ],
          "example": "```javascript\nclass BaseEntity {\n  constructor(id) {\n    this.id = id;\n  }\n}\n\nclass User extends BaseEntity {\n  constructor(id, username) {\n    // Incorrect: try to use 'this' before super()\n    // this.username = username; // This line would cause ReferenceError\n    \n    // Correct way:\n    super(id); // Must call super() first to initialize 'this' from parent\n    this.username = username;\n  }\n}\n\ntry {\n  const user = new User(1, 'jsdev');\n  console.log(user.id); // 1\n  console.log(user.username); // jsdev\n} catch (e) {\n  console.error(e.message);\n}\n```",
          "tags": [
            "ES6",
            "Classes",
            "Inheritance",
            "Super",
            "Errors"
          ],
          "prerequisites": [
            "theory_class_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_inheritance_3",
          "topic": "Method Overriding in Class Inheritance",
          "level": "medium",
          "type": "open",
          "question": "Explain how method overriding works in ES6 class inheritance. Provide an example of a child class overriding a parent method and then calling the parent's original method from within the overridden one.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Define method overriding (subclass provides its own implementation).",
            "Explain how to call the parent's method using `super.methodName()`.",
            "Provide a clear code example demonstrating both overriding and `super.methodName()`."
          ],
          "keyConcepts": [
            "Method Overriding",
            "ES6 Classes",
            "Inheritance",
            "Super Keyword"
          ],
          "evaluationCriteria": [
            "Ability to explain and demonstrate method overriding.",
            "Correct usage of `super.methodName()`."
          ],
          "example": "```javascript\nclass Shape {\n  draw() {\n    return 'Drawing a generic shape.';\n  }\n}\n\nclass Circle extends Shape {\n  draw() {\n    const parentDraw = super.draw(); // Call parent method\n    return `${parentDraw} Specifically, drawing a circle.`;\n  }\n}\n\nconst myCircle = new Circle();\nconsole.log(myCircle.draw()); // Output: Drawing a generic shape. Specifically, drawing a circle.\n```",
          "tags": [
            "ES6",
            "Classes",
            "Inheritance",
            "Method Overriding",
            "Super"
          ],
          "prerequisites": [
            "theory_class_inheritance"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_inheritance_4",
          "topic": "Class Inheritance and `instanceof`",
          "level": "easy",
          "type": "flashcard",
          "question": "If `Dog` `extends` `Animal`, and `rex` is an instance of `Dog`, what will `rex instanceof Animal` evaluate to?",
          "answer": "`true`",
          "options": [],
          "analysisPoints": [
            "Understanding how `instanceof` checks the prototype chain."
          ],
          "keyConcepts": [
            "Instanceof operator",
            "Class Inheritance",
            "Prototype Chain"
          ],
          "evaluationCriteria": [
            "Basic understanding of type checking in inheritance."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Instanceof"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_inheritance_5",
          "topic": "Static Methods in Class Inheritance",
          "level": "medium",
          "type": "open",
          "question": "Can static methods be inherited in ES6 classes? If so, how does this work under the hood?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Confirm that static methods are inherited.",
            "Explain that this works because `ChildClass.__proto__` points to `ParentClass`.",
            "Provide a simple code example."
          ],
          "keyConcepts": [
            "Static Methods",
            "Class Inheritance",
            "Prototype Chain",
            "[[Prototype]]"
          ],
          "evaluationCriteria": [
            "Understanding of static properties/methods and their inheritance.",
            "Ability to explain the underlying prototype link."
          ],
          "example": "```javascript\nclass Parent {\n  static staticMethod() {\n    return 'Parent static method';\n  }\n}\n\nclass Child extends Parent {\n  static childStaticMethod() {\n    return super.staticMethod() + ' from Child.';\n  }\n}\n\nconsole.log(Child.staticMethod()); // Parent static method\nconsole.log(Child.childStaticMethod()); // Parent static method from Child.\n```",
          "tags": [
            "ES6",
            "Classes",
            "Static",
            "Inheritance"
          ],
          "prerequisites": [
            "theory_class_inheritance",
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_descriptors_1",
          "topic": "Property Attributes Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `writable` attribute for an object property?",
          "answer": "It determines whether the property's `value` can be changed (reassigned) using the assignment operator (`=`). If `writable` is `false`, the property is read-only.",
          "options": [],
          "analysisPoints": [
            "Understanding the basic function of the `writable` attribute."
          ],
          "keyConcepts": [
            "Property Attributes",
            "Writable",
            "Object.defineProperty"
          ],
          "evaluationCriteria": [
            "Basic knowledge of object property configuration."
          ],
          "example": null,
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "Writable"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_descriptors_2",
          "topic": "Enumerable Attribute",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following object and how properties are defined:\n\n```javascript\nconst item = {\n  name: 'Laptop',\n  price: 1200\n};\n\nObject.defineProperty(item, 'id', {\n  value: 'LPT-001',\n  enumerable: false\n});\n\nObject.defineProperty(item, 'category', {\n  value: 'Electronics',\n  enumerable: true\n});\n\nconst keys = Object.keys(item);\nlet count = 0;\nfor (let prop in item) {\n  count++;\n}\n```\n\nWhat will be the value of `keys` and `count` respectively?",
          "answer": "`keys` will be `['name', 'price', 'category']` and `count` will be `3`.",
          "options": [
            "`keys` will be `['name', 'price', 'id', 'category']` and `count` will be `4`.",
            "`keys` will be `['name', 'price', 'category']` and `count` will be `3`.",
            "`keys` will be `['Laptop', 1200, 'LPT-001', 'Electronics']` and `count` will be `4`.",
            "`keys` will be `['name', 'price']` and `count` will be `2`."
          ],
          "analysisPoints": [
            "Understanding the effect of `enumerable: false` on `Object.keys()` and `for...in` loops.",
            "Distinguishing between default `enumerable` for literal properties and `defineProperty`.",
            "Tracing property enumeration."
          ],
          "keyConcepts": [
            "Enumerable",
            "Object.keys()",
            "for...in loop",
            "Object.defineProperty"
          ],
          "evaluationCriteria": [
            "Ability to predict property enumeration behavior.",
            "Understanding of descriptor defaults."
          ],
          "example": "```javascript\nconst item = {\n  name: 'Laptop',\n  price: 1200\n};\n\nObject.defineProperty(item, 'id', {\n  value: 'LPT-001',\n  enumerable: false\n});\n\nObject.defineProperty(item, 'category', {\n  value: 'Electronics',\n  enumerable: true\n});\n\nconst keys = Object.keys(item);\nconsole.log(keys); // ['name', 'price', 'category']\nlet count = 0;\nfor (let prop in item) {\n  count++;\n}\nconsole.log(count); // 3\n```",
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "Enumerable",
            "Object.keys"
          ],
          "prerequisites": [
            "theory_object_descriptors_attributes"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_descriptors_3",
          "topic": "Configurable Attribute and Deletion",
          "level": "medium",
          "type": "open",
          "question": "What is the purpose of the `configurable` attribute? Provide an example demonstrating how it affects the deletion and re-configuration of a property.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Define `configurable` (allows deletion and attribute modification).",
            "Show an example where `configurable: true` allows deletion/redefinition.",
            "Show an example where `configurable: false` prevents deletion/redefinition (and potential `TypeError`)."
          ],
          "keyConcepts": [
            "Configurable",
            "Object.defineProperty",
            "Property Deletion",
            "TypeError"
          ],
          "evaluationCriteria": [
            "Ability to explain complex property attributes.",
            "Demonstration of practical impact with code."
          ],
          "example": "```javascript\nconst myObject = {};\n\n// Configurable: true (default for literal properties)\nmyObject.prop1 = 'value1';\nconsole.log('prop1 initially:', myObject.prop1);\ndelete myObject.prop1;\nconsole.log('prop1 after delete:', myObject.prop1); // undefined\n\n// Configurable: false (default for Object.defineProperty without explicit setting)\nObject.defineProperty(myObject, 'prop2', {\n  value: 'value2',\n  configurable: false\n});\nconsole.log('prop2 initially:', myObject.prop2);\n\ntry {\n  delete myObject.prop2;\n} catch (e) {\n  console.error('Error deleting prop2:', e.message); // TypeError in strict mode\n}\nconsole.log('prop2 after attempted delete:', myObject.prop2); // value2 (not deleted)\n\ntry {\n  Object.defineProperty(myObject, 'prop2', { writable: true }); // Attempt to reconfigure\n} catch (e) {\n  console.error('Error reconfiguring prop2:', e.message); // TypeError: Cannot redefine property: prop2\n}\n```",
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "Configurable",
            "Property Deletion"
          ],
          "prerequisites": [
            "theory_object_descriptors_attributes"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_descriptors_4",
          "topic": "Accessor vs. Data Properties",
          "level": "hard",
          "type": "mcq",
          "question": "Which of the following property descriptors is **invalid** when used with `Object.defineProperty()`?",
          "answer": "```javascript\n{\n  value: 'static value',\n  get: function() { return 'dynamic value'; }\n}\n```",
          "options": [
            "```javascript\n{\n  value: 10,\n  writable: false\n}\n```",
            "```javascript\n{\n  get: function() { return this._x; },\n  set: function(val) { this._x = val; }\n}\n```",
            "```javascript\n{\n  value: 'static value',\n  get: function() { return 'dynamic value'; }\n}\n```",
            "```javascript\n{\n  configurable: true,\n  enumerable: true\n}\n```"
          ],
          "analysisPoints": [
            "Understanding the mutual exclusivity of data property attributes (`value`, `writable`) and accessor property attributes (`get`, `set`).",
            "Identifying the correct combination of attributes for each property type.",
            "Recognizing that `configurable` and `enumerable` can be present in both types."
          ],
          "keyConcepts": [
            "Object.defineProperty",
            "Data Property",
            "Accessor Property",
            "Property Descriptors"
          ],
          "evaluationCriteria": [
            "Detailed knowledge of `Object.defineProperty` rules.",
            "Ability to identify invalid property configurations."
          ],
          "example": "If you try to use `value` or `writable` along with `get` or `set` in the same descriptor, JavaScript will throw a `TypeError` because a property cannot be both a data property (holding a value directly) and an accessor property (defined by getter/setter functions) simultaneously.\n\n```javascript\nconst obj = {};\ntry {\n  Object.defineProperty(obj, 'invalidProp', {\n    value: 10,\n    get: function() { return 20; }\n  });\n} catch (e) {\n  console.error(e.message); // TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute\n}\n```",
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "TypeError",
            "API"
          ],
          "prerequisites": [
            "theory_object_descriptors_attributes"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_descriptors_5",
          "topic": "Default Property Attributes",
          "level": "easy",
          "type": "flashcard",
          "question": "When you define a property using an object literal (e.g., `const obj = { prop: 'value' };`), what are the default values for its `writable`, `enumerable`, and `configurable` attributes?",
          "answer": "All are `true` by default when defined via an object literal or direct assignment.",
          "options": [],
          "analysisPoints": [
            "Understanding the difference in default attribute values based on property creation method."
          ],
          "keyConcepts": [
            "Property Attributes",
            "Default Values",
            "Object Literal"
          ],
          "evaluationCriteria": [
            "Basic recall of property attribute defaults."
          ],
          "example": null,
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "Defaults"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_keyword_1",
          "topic": "Implicit Binding of `this`",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code:\n\n```javascript\nconst user = {\n  name: 'Alice',\n  greet: function() {\n    console.log(`Hello, ${this.name}`);\n  },\n  sayNameLater: function() {\n    setTimeout(function() {\n      console.log(`Later, ${this.name}`);\n    }, 100);\n  }\n};\n\nuser.greet();\nuser.sayNameLater();\n```\n\nWhat will be the output of `user.sayNameLater()` after 100ms (assuming a browser environment and non-strict mode)?",
          "answer": "`Later, undefined` (or similar, depending on the global object's `name` property or strict mode)",
          "options": [
            "`Later, Alice`",
            "`TypeError: Cannot read property 'name' of undefined`",
            "`Later, [object Window]` (if `this` refers to `window` and it has a `name` property)",
            "`Later, undefined` (or similar, depending on the global object's `name` property or strict mode)"
          ],
          "analysisPoints": [
            "Understanding that `this` in a regular function loses its context when passed as a callback (`setTimeout`).",
            "Recognizing the default binding rule in non-strict mode (global object).",
            "Predicting the value of `this.name` when `this` is the global object."
          ],
          "keyConcepts": [
            "This Keyword",
            "Implicit Binding",
            "Default Binding",
            "Callback Functions",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Ability to trace `this` context changes.",
            "Understanding common `this` pitfalls."
          ],
          "example": "In a browser, if `window.name` is not set, `this.name` would be `undefined`. In strict mode, `this` in the `setTimeout` callback would be `undefined`, leading to `TypeError: Cannot read properties of undefined (reading 'name')`.\n\n```javascript\nconst user = {\n  name: 'Alice',\n  sayNameLater: function() {\n    setTimeout(function() {\n      console.log(`Later, ${this.name}`);\n    }, 100);\n  }\n};\nuser.sayNameLater(); // After 100ms: Later, undefined (in browser, non-strict mode if window.name is not set)\n```",
          "tags": [
            "JavaScript",
            "this",
            "Callbacks",
            "setTimeout",
            "Context"
          ],
          "prerequisites": [
            "theory_this_keyword"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_keyword_2",
          "topic": "Arrow Functions and `this`",
          "level": "medium",
          "type": "open",
          "question": "How do arrow functions (`=>`) handle the `this` keyword differently from regular function expressions? When would you prefer using an arrow function for `this` binding?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explain lexical `this` binding in arrow functions (inherits from enclosing scope).",
            "Contrast with regular functions' dynamic `this` binding (depends on invocation context).",
            "Provide scenarios where arrow functions are ideal (callbacks, class methods where `this` needs to stay bound to instance)."
          ],
          "keyConcepts": [
            "Arrow Functions",
            "This Keyword",
            "Lexical Scoping",
            "Callback Functions",
            "Class Methods"
          ],
          "evaluationCriteria": [
            "Clear explanation of `this` behavior.",
            "Ability to identify appropriate use cases for arrow functions."
          ],
          "example": "```javascript\nclass Timer {\n  constructor() {\n    this.seconds = 0;\n    setInterval(() => {\n      this.seconds++; // 'this' correctly refers to the Timer instance\n      console.log(this.seconds);\n    }, 1000);\n  }\n}\n\n// Compare to a problematic regular function:\n// class TimerProblem {\n//   constructor() {\n//     this.seconds = 0;\n//     setInterval(function() {\n//       this.seconds++; // 'this' here refers to global object/undefined\n//       console.log(this.seconds);\n//     }, 1000);\n//   }\n// }\n```",
          "tags": [
            "JavaScript",
            "this",
            "Arrow Functions",
            "Context",
            "Callbacks"
          ],
          "prerequisites": [
            "theory_this_keyword"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_keyword_3",
          "topic": "Explicit Binding (`call`, `apply`, `bind`)",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the key difference between `Function.prototype.call()`, `Function.prototype.apply()`, and `Function.prototype.bind()` in terms of how they set `this` and execute the function?",
          "answer": "`call()`: Executes the function immediately. Arguments are passed individually.\n`apply()`: Executes the function immediately. Arguments are passed as an array.\n`bind()`: Does NOT execute the function immediately. It returns a *new* function with `this` permanently bound to the specified object, which can be called later.",
          "options": [],
          "analysisPoints": [
            "Distinguishing immediate execution vs. returning a bound function.",
            "Understanding argument passing differences (`call` vs `apply`)."
          ],
          "keyConcepts": [
            "This Keyword",
            "Call",
            "Apply",
            "Bind",
            "Explicit Binding"
          ],
          "evaluationCriteria": [
            "Clear understanding of explicit binding methods.",
            "Knowledge of their differences in usage."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "this",
            "Call Apply Bind",
            "Functions"
          ],
          "prerequisites": [
            "theory_this_keyword"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_keyword_4",
          "topic": "`this` in Global Scope and Strict Mode",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the value of `this` in the global execution context (outside any function) and inside a simple function call in strict mode?",
          "answer": "In the global execution context (outside any function), `this` always refers to the global object (`window` in browsers, `global` in Node.js).\n\nInside a simple function call in strict mode, `this` is `undefined`.",
          "options": [],
          "analysisPoints": [
            "Understanding global `this`.",
            "Understanding strict mode impact on `this`."
          ],
          "keyConcepts": [
            "This Keyword",
            "Global Scope",
            "Strict Mode"
          ],
          "evaluationCriteria": [
            "Basic knowledge of `this` in different modes."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "this",
            "Strict Mode"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_es6_classes_1",
          "title": "Create a `ShoppingCart` Class",
          "description": "\nDesign and implement an ES6 `ShoppingCart` class. This class should manage a collection of products.\n\n**Requirements:**\n1.  The `ShoppingCart` class must have a `constructor` that initializes an empty array to store `items`.\n2.  Implement an `addItem(product, quantity)` method:\n    *   It should add a product (object with `id`, `name`, `price`) and its `quantity` to the `items` array.\n    *   If the product is already in the cart, update its quantity (add to existing).\n    *   Ensure `quantity` is a positive number.\n3.  Implement a `removeItem(productId)` method:\n    *   Removes the product with the given `productId` from the cart.\n    *   If the product is not found, do nothing or log a message.\n4.  Implement a `getTotalItems()` method that returns the total count of all items in the cart (sum of all quantities).\n5.  Implement a `getTotalPrice()` method that calculates and returns the total price of all items in the cart (sum of `product.price * quantity`).\n\nYour solution should demonstrate proper use of class syntax, instance properties, and methods.\n",
          "difficulty": "medium",
          "startingCode": "class ShoppingCart {\n  constructor() {\n    // TODO: Initialize items array\n  }\n\n  addItem(product, quantity) {\n    // TODO: Implement adding/updating product quantity\n    // product: { id: string, name: string, price: number }\n  }\n\n  removeItem(productId) {\n    // TODO: Implement removing product by ID\n  }\n\n  getTotalItems() {\n    // TODO: Calculate total quantity of all items\n    return 0;\n  }\n\n  getTotalPrice() {\n    // TODO: Calculate total price of all items\n    return 0;\n  }\n}\n\n// Example Usage (for testing):\n// const cart = new ShoppingCart();\n// cart.addItem({ id: 'P1', name: 'Laptop', price: 1200 }, 1);\n// cart.addItem({ id: 'P2', name: 'Mouse', price: 25 }, 2);\n// console.log('Total Items:', cart.getTotalItems()); // Expected: 3\n// console.log('Total Price:', cart.getTotalPrice()); // Expected: 1250\n// cart.addItem({ id: 'P1', name: 'Laptop', price: 1200 }, 1); // Add another Laptop\n// console.log('Total Items after adding more Laptop:', cart.getTotalItems()); // Expected: 4\n// console.log('Total Price after adding more Laptop:', cart.getTotalPrice()); // Expected: 2450\n// cart.removeItem('P2');\n// console.log('Total Items after removing Mouse:', cart.getTotalItems()); // Expected: 2\n// console.log('Total Price after removing Mouse:', cart.getTotalPrice()); // Expected: 2400\n",
          "solutionCode": "class ShoppingCart {\n  constructor() {\n    this.items = []; // Each item: { product: { id, name, price }, quantity: number }\n  }\n\n  addItem(product, quantity) {\n    if (!product || typeof quantity !== 'number' || quantity <= 0) {\n      console.warn('Invalid product or quantity provided.');\n      return;\n    }\n\n    const existingItem = this.items.find(item => item.product.id === product.id);\n\n    if (existingItem) {\n      existingItem.quantity += quantity;\n    } else {\n      this.items.push({ product, quantity });\n    }\n  }\n\n  removeItem(productId) {\n    const initialLength = this.items.length;\n    this.items = this.items.filter(item => item.product.id !== productId);\n    if (this.items.length === initialLength) {\n      console.log(`Product with ID ${productId} not found in cart.`);\n    }\n  }\n\n  getTotalItems() {\n    return this.items.reduce((total, item) => total + item.quantity, 0);\n  }\n\n  getTotalPrice() {\n    return this.items.reduce((total, item) => total + (item.product.price * item.quantity), 0);\n  }\n}\n",
          "testCases": [
            "Initialize empty cart: `new ShoppingCart().getTotalItems()` should be 0.",
            "Add a single item: `cart.addItem({id: 'A', name: 'X', price: 10}, 1); cart.getTotalItems()` should be 1, `getTotalPrice()` should be 10.",
            "Add existing item: `cart.addItem({id: 'A', name: 'X', price: 10}, 2); cart.getTotalItems()` should be 3, `getTotalPrice()` should be 30.",
            "Add multiple different items: check total items and total price.",
            "Remove an existing item: `cart.removeItem('A');` should correctly update totals.",
            "Remove a non-existing item: `cart.removeItem('Z');` should not change state, no error.",
            "Add item with zero or negative quantity: should not add/modify items, or warn.",
            "Edge case: empty cart operations (remove, get totals) should not throw errors."
          ],
          "hints": [
            "Use `Array.prototype.find()` to check if a product already exists.",
            "Use `Array.prototype.filter()` for `removeItem`.",
            "Remember to use `this` to access instance properties and methods.",
            "For totals, `Array.prototype.reduce()` is very suitable."
          ],
          "tags": [
            "ES6 Classes",
            "OOP",
            "Data Structures",
            "Arrays",
            "Frontend Interview"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_es6_classes",
            "javascript_arrays"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "object_oriented_programming",
            "array_methods",
            "data_encapsulation"
          ]
        },
        {
          "id": "task_prototypal_inheritance_1",
          "title": "Implement a Simple Logger with Prototypal Inheritance",
          "description": "\nImplement a basic logging utility using JavaScript's prototypal inheritance model. This task focuses on understanding `Object.create()` and defining shared methods on a prototype.\n\n**Requirements:**\n1.  Create a `loggerPrototype` object that contains common logging methods.\n2.  The `loggerPrototype` should have a method `log(message)` that prints `[LOG] message` to the console.\n3.  The `loggerPrototype` should have a method `warn(message)` that prints `[WARN] message` to the console.\n4.  Create a new `infoLogger` object using `Object.create()` from `loggerPrototype`.\n5.  Add a specific method `info(message)` to `infoLogger` that prints `[INFO] message` to the console. This method should *only* be available on `infoLogger` and its instances, not on `loggerPrototype`.\n6.  Create another `errorLogger` object using `Object.create()` from `loggerPrototype`.\n7.  Add a specific method `error(message)` to `errorLogger` that prints `[ERROR] message` to the console.\n\nYour solution should demonstrate how objects can inherit from a shared prototype and also define their own unique methods.\n",
          "difficulty": "medium",
          "startingCode": "const loggerPrototype = {\n  // TODO: Implement log and warn methods\n};\n\n// TODO: Create infoLogger and add info method\n\n// TODO: Create errorLogger and add error method\n\n// Example Usage:\n// infoLogger.log('This is a log message.');\n// infoLogger.warn('This is a warning!');\n// infoLogger.info('This is an info message.');\n// // errorLogger.info('Should not work'); // This should throw an error or be undefined\n\n// errorLogger.log('Another log.');\n// errorLogger.error('Critical error!');\n",
          "solutionCode": "const loggerPrototype = {\n  log: function(message) {\n    console.log(`[LOG] ${message}`);\n  },\n  warn: function(message) {\n    console.warn(`[WARN] ${message}`);\n  }\n};\n\nconst infoLogger = Object.create(loggerPrototype);\ninfoLogger.info = function(message) {\n  console.info(`[INFO] ${message}`);\n};\n\nconst errorLogger = Object.create(loggerPrototype);\nerrorLogger.error = function(message) {\n  console.error(`[ERROR] ${message}`);\n};\n",
          "testCases": [
            "`infoLogger.log('test')` should output `[LOG] test`.",
            "`infoLogger.warn('test')` should output `[WARN] test`.",
            "`infoLogger.info('test')` should output `[INFO] test`.",
            "`errorLogger.log('test')` should output `[LOG] test`.",
            "`errorLogger.warn('test')` should output `[WARN] test`.",
            "`errorLogger.error('test')` should output `[ERROR] test`.",
            "`Object.getPrototypeOf(infoLogger)` should be `loggerPrototype`.",
            "`Object.getPrototypeOf(errorLogger)` should be `loggerPrototype`.",
            "`infoLogger.hasOwnProperty('info')` should be `true`.",
            "`infoLogger.hasOwnProperty('log')` should be `false`.",
            "`errorLogger.hasOwnProperty('error')` should be `true`.",
            "`errorLogger.hasOwnProperty('log')` should be `false`.",
            "`infoLogger.error` should be `undefined`.",
            "`errorLogger.info` should be `undefined`."
          ],
          "hints": [
            "Remember that `Object.create(proto)` sets the `[[Prototype]]` of the new object to `proto`.",
            "Methods added directly to `infoLogger` or `errorLogger` will be 'own' properties of those objects, not shared via the prototype.",
            "Use `Object.getPrototypeOf()` to verify the prototype chain."
          ],
          "tags": [
            "JavaScript",
            "Prototypes",
            "Object.create",
            "Inheritance",
            "OOP"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "object_composition",
            "factory_functions"
          ]
        },
        {
          "id": "task_prototypal_inheritance_2",
          "title": "Migrate Constructor Function to `Object.create` Pattern",
          "description": "\nYou are given a set of objects and a constructor function using the traditional prototypal inheritance pattern. Your task is to refactor this setup to use the `Object.create()` pattern, demonstrating a clearer delegation model.\n\n**Given:**\n```javascript\nfunction Character(name, health) {\n  this.name = name;\n  this.health = health;\n}\n\nCharacter.prototype.attack = function(target) {\n  console.log(`${this.name} attacks ${target.name} for 10 damage.`);\n  target.health -= 10;\n};\n\nCharacter.prototype.takeDamage = function(amount) {\n  this.health -= amount;\n  console.log(`${this.name} takes ${amount} damage. Health: ${this.health}`);\n};\n```\n\n**Requirements:**\n1.  Create a `characterPrototype` object that contains the `attack` and `takeDamage` methods. This will be the base prototype for all character objects.\n2.  Create a `createCharacter(name, health)` factory function.\n    *   This function should use `Object.create(characterPrototype)` to create a new character object.\n    *   It should then initialize the `name` and `health` properties directly on the new character object (not on the prototype).\n    *   It should return the newly created and initialized character object.\n3.  Test your new factory function by creating a few character instances and demonstrating their methods.\n\nThis task highlights the flexibility of prototypal inheritance and moves away from the `new` keyword and constructor functions for object creation, favoring a more direct prototype delegation approach.\n",
          "difficulty": "medium",
          "startingCode": "// Original (for context, do not modify):\n// function Character(name, health) {\n//   this.name = name;\n//   this.health = health;\n// }\n//\n// Character.prototype.attack = function(target) {\n//   console.log(`${this.name} attacks ${target.name} for 10 damage.`);\n//   target.health -= 10;\n// };\n//\n// Character.prototype.takeDamage = function(amount) {\n//   this.health -= amount;\n//   console.log(`${this.name} takes ${amount} damage. Health: ${this.health}`);\n// };\n\n// TODO: Implement characterPrototype\nconst characterPrototype = {\n  // ... methods here\n};\n\n// TODO: Implement createCharacter factory function\nfunction createCharacter(name, health) {\n  // ... implementation here\n}\n\n// Example Usage:\n// const hero = createCharacter('Hero', 100);\n// const villain = createCharacter('Villain', 80);\n// hero.attack(villain); // Hero attacks Villain for 10 damage.\n//                       // Villain takes 10 damage. Health: 70\n// villain.takeDamage(5); // Villain takes 5 damage. Health: 65\n// console.log(hero.health); // 100\n",
          "solutionCode": "const characterPrototype = {\n  attack: function(target) {\n    console.log(`${this.name} attacks ${target.name} for 10 damage.`);\n    target.health -= 10;\n  },\n  takeDamage: function(amount) {\n    this.health -= amount;\n    console.log(`${this.name} takes ${amount} damage. Health: ${this.health}`);\n  }\n};\n\nfunction createCharacter(name, health) {\n  const character = Object.create(characterPrototype);\n  character.name = name;\n  character.health = health;\n  return character;\n}\n",
          "testCases": [
            "Create two characters: `hero = createCharacter('Hero', 100);` `villain = createCharacter('Villain', 80);`",
            "`hero.name` should be 'Hero', `hero.health` should be 100.",
            "`villain.name` should be 'Villain', `villain.health` should be 80.",
            "`hero.attack(villain)` should correctly decrease `villain.health` by 10 and log messages.",
            "`villain.takeDamage(5)` should correctly decrease `villain.health` by 5 and log messages.",
            "`hero.hasOwnProperty('attack')` should be `false` (method on prototype).",
            "`hero.hasOwnProperty('name')` should be `true` (property on instance).",
            "`Object.getPrototypeOf(hero)` should be `characterPrototype`.",
            "Check if methods are shared: `hero.attack === villain.attack` should be `true`."
          ],
          "hints": [
            "`Object.create()` creates an empty object whose prototype is the object passed as the argument.",
            "Properties like `name` and `health` that vary per instance should be assigned directly to the new object returned by `Object.create()`, not to the `characterPrototype`."
          ],
          "tags": [
            "JavaScript",
            "Prototypes",
            "Object.create",
            "Factory Functions",
            "Inheritance Refactoring"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "factory_pattern",
            "functional_programming_with_objects"
          ]
        },
        {
          "id": "task_class_inheritance_1",
          "title": "Build a Hierarchical Notification System with ES6 Classes",
          "description": "\nImplement a notification system using ES6 class inheritance. You will create a base `Notification` class and extend it to create more specific types of notifications.\n\n**Requirements:**\n1.  **`Notification` Base Class:**\n    *   Constructor takes `message` (string) and optional `timestamp` (Date, default to `new Date()`).\n    *   Method `display()`: Logs the message and timestamp to the console. E.g., `[2023-10-27 10:30:00] Message: Hello World`.\n    *   Method `getMessage()`: Returns the notification message.\n\n2.  **`UrgentNotification` Subclass:**\n    *   Extends `Notification`.\n    *   Constructor takes `message`, `priority` (number, default 5), and optional `timestamp`.\n    *   Overrides `display()`: Logs `[URGENT] [Priority: X] [TIMESTAMP] Message: Y`. Ensure it uses the parent's `timestamp` and `message`.\n\n3.  **`ErrorNotification` Subclass:**\n    *   Extends `Notification`.\n    *   Constructor takes `message`, `errorCode` (string, default 'UNKNOWN'), and optional `timestamp`.\n    *   Overrides `display()`: Logs `[ERROR] [Code: Z] [TIMESTAMP] Message: Y`. Ensure it uses the parent's `timestamp` and `message`.\n    *   Method `getErrorCode()`: Returns the error code.\n\nYour solution should demonstrate proper use of `extends`, `super()`, and method overriding.\n",
          "difficulty": "medium",
          "startingCode": "class Notification {\n  constructor(message, timestamp = new Date()) {\n    // TODO: Initialize message and timestamp\n  }\n\n  display() {\n    // TODO: Implement generic display\n  }\n\n  getMessage() {\n    // TODO: Return message\n  }\n}\n\nclass UrgentNotification extends Notification {\n  constructor(message, priority = 5, timestamp) {\n    // TODO: Call super and initialize priority\n  }\n\n  display() {\n    // TODO: Override display to include priority\n  }\n}\n\nclass ErrorNotification extends Notification {\n  constructor(message, errorCode = 'UNKNOWN', timestamp) {\n    // TODO: Call super and initialize errorCode\n  }\n\n  display() {\n    // TODO: Override display to include error code\n  }\n\n  getErrorCode() {\n    // TODO: Return error code\n  }\n}\n\n// Example Usage:\n// const notif1 = new Notification('Your order has been placed.');\n// notif1.display();\n\n// const urgentNotif = new UrgentNotification('Server going down!', 10);\n// urgentNotif.display();\n\n// const errorNotif = new ErrorNotification('Failed to fetch data.', 'HTTP_500');\n// errorNotif.display();\n// console.log(errorNotif.getErrorCode());\n\n// console.log(urgentNotif instanceof Notification); // true\n// console.log(errorNotif instanceof Notification); // true\n",
          "solutionCode": "class Notification {\n  constructor(message, timestamp = new Date()) {\n    this.message = message;\n    this.timestamp = timestamp;\n  }\n\n  display() {\n    const formattedTime = this.timestamp.toISOString().replace(/T/, ' ').replace(/\\..+/, '');\n    console.log(`[${formattedTime}] Message: ${this.message}`);\n  }\n\n  getMessage() {\n    return this.message;\n  }\n}\n\nclass UrgentNotification extends Notification {\n  constructor(message, priority = 5, timestamp) {\n    super(message, timestamp);\n    this.priority = priority;\n  }\n\n  display() {\n    const formattedTime = this.timestamp.toISOString().replace(/T/, ' ').replace(/\\..+/, '');\n    console.log(`[URGENT] [Priority: ${this.priority}] [${formattedTime}] Message: ${this.message}`);\n  }\n}\n\nclass ErrorNotification extends Notification {\n  constructor(message, errorCode = 'UNKNOWN', timestamp) {\n    super(message, timestamp);\n    this.errorCode = errorCode;\n  }\n\n  display() {\n    const formattedTime = this.timestamp.toISOString().replace(/T/, ' ').replace(/\\..+/, '');\n    console.log(`[ERROR] [Code: ${this.errorCode}] [${formattedTime}] Message: ${this.message}`);\n  }\n\n  getErrorCode() {\n    return this.errorCode;\n  }\n}\n",
          "testCases": [
            "`Notification` instance: `display()` method output matches format.",
            "`UrgentNotification` instance: `display()` method output includes priority and correct timestamp/message from superclass.",
            "`ErrorNotification` instance: `display()` method output includes error code and correct timestamp/message from superclass.",
            "`ErrorNotification` instance: `getErrorCode()` returns correct code.",
            "Check `instanceof` relationships: `urgentNotif instanceof Notification` should be `true`, `errorNotif instanceof Notification` should be `true`.",
            "Default values for `timestamp`, `priority`, `errorCode` are correctly applied when not provided.",
            "Calling `getMessage()` on subclasses returns the correct message."
          ],
          "hints": [
            "Remember to call `super()` in subclass constructors before accessing `this`.",
            "To format the `Date` object for display, consider `toISOString()` and string manipulation.",
            "When overriding `display()`, you'll likely want to re-calculate the timestamp string for consistency, or extract that logic to a shared helper.",
            "The `message` and `timestamp` are managed by the parent `Notification` class, so ensure you pass them correctly to `super()`."
          ],
          "tags": [
            "ES6 Classes",
            "Inheritance",
            "OOP",
            "Method Overriding",
            "System Design"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_class_inheritance"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "polymorphism",
            "data_encapsulation"
          ]
        },
        {
          "id": "task_object_descriptors_1",
          "title": "Create a Protected Configuration Object",
          "description": "\nYour task is to create a configuration object for a web application that has certain properties that should not be accidentally modified or enumerated. You will use `Object.defineProperty()` to achieve this.\n\n**Requirements:**\n1.  Create an empty object named `appConfig`.\n2.  Define a property `version` on `appConfig`:\n    *   Value: `'1.0.0'`\n    *   Should be **read-only** (`writable: false`).\n    *   Should be **non-enumerable** (`enumerable: false`).\n    *   Should be **non-configurable** (`configurable: false`).\n3.  Define a property `apiEndpoint` on `appConfig`:\n    *   Value: `'https://api.example.com'`\n    *   Should be **writable** (`writable: true`).\n    *   Should be **enumerable** (`enumerable: true`).\n    *   Should be **configurable** (`configurable: true`).\n4.  Define an **accessor property** `lastAccessed` on `appConfig`:\n    *   It should internally store the last access timestamp (e.g., `_lastAccessed`).\n    *   The `get` method should return the stored timestamp and *update the internal timestamp to the current time* every time it's accessed.\n    *   The `set` method should only allow setting a new timestamp if it's a valid `Date` object and greater than the current `_lastAccessed`.\n    *   Should be **enumerable** (`enumerable: true`).\n    *   Should be **non-configurable** (`configurable: false`).\n\n**Testing Scenarios:**\n*   Attempt to change `version` and observe if it fails.\n*   Check if `version` appears in `for...in` loops or `Object.keys()`.\n*   Attempt to delete `version` and observe if it fails.\n*   Change `apiEndpoint` and verify the change.\n*   Access `lastAccessed` multiple times and verify its value updates and if `_lastAccessed` is hidden from enumeration.\n*   Attempt to set `lastAccessed` with an invalid date or an older date.\n",
          "difficulty": "hard",
          "startingCode": "const appConfig = {};\n\n// TODO: Define 'version' property\n\n// TODO: Define 'apiEndpoint' property\n\n// TODO: Define 'lastAccessed' accessor property\n\n// Example Usage and Tests:\n// console.log('Initial appConfig:', appConfig);\n\n// // Test version\n// console.log('Version:', appConfig.version);\n// try {\n//   appConfig.version = '2.0.0';\n//   console.log('Attempted to change version to:', appConfig.version);\n// } catch (e) {\n//   console.error('Error changing version:', e.message);\n// }\n// console.log('Version after attempt:', appConfig.version);\n// console.log('Keys:', Object.keys(appConfig));\n// for (let key in appConfig) { console.log('Prop in loop:', key); }\n\n// // Test apiEndpoint\n// console.log('API Endpoint:', appConfig.apiEndpoint);\n// appConfig.apiEndpoint = 'https://newapi.example.com';\n// console.log('New API Endpoint:', appConfig.apiEndpoint);\n\n// // Test lastAccessed\n// console.log('First access:', appConfig.lastAccessed);\n// setTimeout(() => {\n//   console.log('Second access:', appConfig.lastAccessed);\n//   appConfig.lastAccessed = new Date(new Date().getTime() + 100000);\n//   console.log('Set future access:', appConfig.lastAccessed);\n//   appConfig.lastAccessed = new Date(new Date().getTime() - 100000); // Should fail\n//   console.log('Set past access (should not change):', appConfig.lastAccessed);\n// }, 100);\n",
          "solutionCode": "const appConfig = {};\n\n// Internal storage for lastAccessed\nlet _lastAccessedTimestamp = null;\n\n// 1. Define 'version' property\nObject.defineProperty(appConfig, 'version', {\n  value: '1.0.0',\n  writable: false,      // Read-only\n  enumerable: false,    // Hidden from enumeration\n  configurable: false   // Cannot be deleted or reconfigured\n});\n\n// 2. Define 'apiEndpoint' property\nObject.defineProperty(appConfig, 'apiEndpoint', {\n  value: 'https://api.example.com',\n  writable: true,       // Writable\n  enumerable: true,     // Enumerable\n  configurable: true    // Configurable\n});\n\n// 3. Define 'lastAccessed' accessor property\nObject.defineProperty(appConfig, 'lastAccessed', {\n  get: function() {\n    // Update timestamp on read\n    _lastAccessedTimestamp = new Date(); \n    return _lastAccessedTimestamp;\n  },\n  set: function(newTimestamp) {\n    if (newTimestamp instanceof Date && (_lastAccessedTimestamp === null || newTimestamp.getTime() > _lastAccessedTimestamp.getTime())) {\n      _lastAccessedTimestamp = newTimestamp;\n      console.log('lastAccessed updated to:', _lastAccessedTimestamp.toISOString());\n    } else {\n      console.warn('Attempted to set invalid or older lastAccessed timestamp.');\n    }\n  },\n  enumerable: true,      // Enumerable\n  configurable: false    // Non-configurable\n});\n",
          "testCases": [
            "`appConfig.version` should be '1.0.0'.",
            "Attempting `appConfig.version = '2.0.0'` should not change `appConfig.version` (remains '1.0.0'). In strict mode, it should throw `TypeError`.",
            "`Object.keys(appConfig)` should not include `version`.",
            "`for...in` loop on `appConfig` should not include `version`.",
            "Attempting `delete appConfig.version` should not delete `version`. In strict mode, it should throw `TypeError`.",
            "`appConfig.apiEndpoint` should be initially 'https://api.example.com'.",
            "`appConfig.apiEndpoint = 'new.com'` should successfully change its value.",
            "`Object.keys(appConfig)` should include `apiEndpoint`.",
            "Accessing `appConfig.lastAccessed` multiple times should show an increasing timestamp value.",
            "`Object.keys(appConfig)` should include `lastAccessed`.",
            "`_lastAccessedTimestamp` variable should not be directly accessible on `appConfig`.",
            "Attempting `appConfig.lastAccessed = new Date(oldDate)` (where `oldDate` is older than current `_lastAccessedTimestamp`) should not change `lastAccessed`.",
            "Attempting `appConfig.lastAccessed = 'invalid'` should not change `lastAccessed`."
          ],
          "hints": [
            "Remember the default values for attributes when using `Object.defineProperty()` (they are all `false` unless explicitly set to `true`).",
            "For the `lastAccessed` accessor, you'll need an external variable (closure) to store the actual timestamp, as accessor properties don't have a `value` attribute.",
            "The `Date` object's `getTime()` method can be useful for comparing timestamps.",
            "Consider strict mode behavior when testing `writable: false` and `configurable: false` properties."
          ],
          "tags": [
            "JavaScript",
            "Objects",
            "Object.defineProperty",
            "Getters Setters",
            "Property Attributes",
            "Advanced JavaScript"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_object_descriptors_attributes"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "data_encapsulation",
            "closure",
            "module_pattern"
          ]
        },
        {
          "id": "task_this_keyword_1",
          "title": "Fix `this` Context in a Counter Object",
          "description": "\nYou are given a `Counter` object that attempts to increment a count at regular intervals but has issues with the `this` context. Your task is to fix the `this` binding using different methods.\n\n**Given:**\n```javascript\nconst counter = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    setInterval(function() {\n      this.count++; // Problematic 'this'\n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n```\n\n**Requirements:**\n1.  **Solution A (Arrow Function):** Modify the `start` method to use an arrow function for the `setInterval` callback to correctly bind `this` to the `counter` object.\n2.  **Solution B (`.bind()`):** Create a separate version of the `counter` object (`counterBind`) and fix the `start` method's `this` binding using the `.bind()` method.\n3.  **Solution C (Closure/Self):** Create a third version of the `counter` object (`counterClosure`) and fix the `start` method's `this` binding using a variable to capture `this` (e.g., `let self = this;`).\n\n**Constraints:**\n*   Each solution should demonstrate a different valid technique to ensure `this.count` correctly increments.\n*   Do not use ES6 Classes for this specific task; focus on object literals and functions.\n\n**Expected Output (for any solution):**\n```\nCounter starting...\nCurrent count: 1\nCurrent count: 2\nCurrent count: 3\n...\n```\n",
          "difficulty": "medium",
          "startingCode": "console.log('--- Solution A: Arrow Function ---');\nconst counterArrow = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    setInterval(function() {\n      // TODO: Fix 'this' using an arrow function\n      this.count++; \n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n// counterArrow.start(); // Uncomment to test\n\nconsole.log('\\n--- Solution B: .bind() ---');\nconst counterBind = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    // TODO: Fix 'this' using .bind()\n    setInterval(function() {\n      this.count++;\n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n// counterBind.start(); // Uncomment to test\n\nconsole.log('\\n--- Solution C: Closure/Self ---');\nconst counterClosure = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    // TODO: Fix 'this' using a closure (e.g., 'self = this')\n    setInterval(function() {\n      this.count++;\n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n// counterClosure.start(); // Uncomment to test\n",
          "solutionCode": "console.log('--- Solution A: Arrow Function ---');\nconst counterArrow = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    setInterval(() => { // Using arrow function\n      this.count++; \n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n// counterArrow.start(); \n\nconsole.log('\\n--- Solution B: .bind() ---');\nconst counterBind = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    setInterval(function() {\n      this.count++;\n      console.log('Current count:', this.count);\n    }.bind(this), 1000); // Using .bind(this)\n  }\n};\n// counterBind.start(); \n\nconsole.log('\\n--- Solution C: Closure/Self ---');\nconst counterClosure = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    const self = this; // Capture 'this' in a closure\n    setInterval(function() {\n      self.count++; // Use 'self' instead of 'this'\n      console.log('Current count:', self.count);\n    }, 1000);\n  }\n};\n// counterClosure.start(); \n",
          "testCases": [
            "Run `counterArrow.start()` for 3-5 seconds and verify `Current count:` increments correctly (1, 2, 3...).",
            "Run `counterBind.start()` for 3-5 seconds and verify `Current count:` increments correctly.",
            "Run `counterClosure.start()` for 3-5 seconds and verify `Current count:` increments correctly.",
            "Ensure no `TypeError: Cannot read properties of undefined (reading 'count')` or similar errors occur."
          ],
          "hints": [
            "For Solution A, consider how arrow functions handle `this` lexically.",
            "For Solution B, recall which method on `Function.prototype` returns a *new* function with `this` permanently bound.",
            "For Solution C, think about how variables in an outer scope are accessible in inner functions."
          ],
          "tags": [
            "JavaScript",
            "this",
            "Context",
            "Callbacks",
            "Arrow Functions",
            "Bind",
            "Closure",
            "Frontend Interview"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "theory_this_keyword",
            "javascript_functions",
            "closures"
          ],
          "complexity": 6,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "asynchronous_javascript",
            "setinterval",
            "function_scope"
          ]
        }
      ]
    }
  },
  {
    "id": "46d67387-9346-40d4-8c93-c7a4a333d06e",
    "startLine": 2200,
    "endLine": 2299,
    "processedDate": "2025-06-17T08:15:47.063Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_object_getters_setters",
          "title": "Object Getters and Setters",
          "content": "Getters and setters are special methods defined on objects that provide controlled access to an object's properties. They allow you to define what happens when a property is accessed (getter) or modified (setter).\n\n### Getters (Accessors)\n\nA getter method is executed when you attempt to retrieve the value of a property. It's defined using the `get` keyword before the property name. Getters are useful for:\n\n*   Returning computed values based on other properties.\n*   Formatting data before it's returned.\n*   Adding side effects (though generally not recommended for pure getters).\n\n### Setters (Mutators)\n\nA setter method is executed when you attempt to assign a value to a property. It's defined using the `set` keyword before the property name. Setters are useful for:\n\n*   Validation of input data before assignment.\n*   Transforming data before it's stored.\n*   Updating other properties or triggering side effects when a property changes.\n\n### Syntax\n\nGetters and setters are defined within object literal definitions or class declarations.",
          "examples": [
            {
              "id": "example_getters_setters_1",
              "title": "Basic Getter and Setter Example",
              "code": "const person = {\n  firstName: 'John',\n  lastName: 'Doe',\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n\n  set fullName(value) {\n    // The original markdown snippet starts here\n    [this.firstName, this.lastName] = value.split(' ');\n  }\n};\n\nconsole.log(person.fullName); // John Doe\nperson.fullName = 'Jane Smith';\nconsole.log(person.firstName); // Jane\nconsole.log(person.lastName);  // Smith\nconsole.log(person.fullName);  // Jane Smith",
              "explanation": "This example demonstrates a `fullName` property that is accessed via a getter and modified via a setter. When `person.fullName` is read, the `get fullName()` method concatenates `firstName` and `lastName`. When `person.fullName` is assigned a new string, the `set fullName(value)` method splits the string by space and assigns the parts to `firstName` and `lastName` respectively, showcasing how setters can deconstruct and update underlying properties.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_getters_setters_1",
            "question_getters_setters_2",
            "question_getters_setters_3",
            "question_getters_setters_4"
          ],
          "relatedTasks": [
            "task_object_getters_setters_1"
          ],
          "tags": [
            "objects",
            "properties",
            "getters",
            "setters",
            "javascript_basics"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "functions"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "vue_reactivity",
            "data_encapsulation"
          ]
        },
        {
          "id": "theory_equality_comparison",
          "title": "Equality and Comparison in JavaScript",
          "content": "JavaScript provides two primary operators for checking equality: the loose equality operator (`==`) and the strict equality operator (`===`). Understanding the difference between them, especially concerning type coercion and object comparison, is crucial.\n\n### Loose Equality (`==`)\n\nThe loose equality operator `==` compares two values for equality *after* converting them to a common type (type coercion). This can lead to unexpected results because values that appear different might evaluate to `true` after coercion.\n\nCommon coercion rules include:\n*   Numbers and numeric strings: Strings are converted to numbers.\n*   Booleans and non-booleans: Non-booleans are converted to booleans.\n*   `null` and `undefined`: Considered equal to each other.\n\n### Strict Equality (`===`)\n\nThe strict equality operator `===` compares two values for equality *without* performing any type conversion. If the values have different types, they are considered unequal. This operator is generally recommended for most comparisons as it prevents unexpected coercions.\n\n### Object Equality\n\nObjects in JavaScript (including arrays and functions) are compared by *reference*, not by *value*. This means two distinct objects, even if they have the same properties and values, will not be considered equal by either `==` or `===` unless they refer to the exact same object in memory.\n\nTo compare object *values*, you typically need to iterate through their properties or use methods like `JSON.stringify()` (with caveats) or deep comparison libraries.",
          "examples": [
            {
              "id": "example_equality_comparison_1",
              "title": "Loose vs. Strict Equality Examples",
              "code": "// == checks for equality with type conversion\n1 == '1';      // true (string '1' coerced to number 1)\n0 == false;    // true (false coerced to 0)\nnull == undefined; // true (special rule for null and undefined)\n\n// === checks for equality without type conversion (strict equality)\n1 === '1';      // false (number vs string, no coercion)\n0 === false;    // false (number vs boolean)\nnull === undefined; // false (different types)",
              "explanation": "These examples highlight the fundamental difference. `==` attempts to make types compatible, leading to `true` in the first three cases. `===` requires both value and type to be identical, resulting in `false` for the same comparisons.",
              "language": "javascript"
            },
            {
              "id": "example_equality_comparison_2",
              "title": "Object Reference Comparison",
              "code": "// Object equality - objects are compared by reference, not value\nconst obj1 = { a: 1 };\nconst obj2 = { a: 1 };\nconst obj3 = obj1;\n\nobj1 == obj2;  // false (different objects in memory)\nobj1 === obj2; // false (different objects in memory)\nobj1 == obj3;  // true (same object reference)\nobj1 === obj3; // true (same object reference)\n\n// Comparing object values (workaround, not recommended for complex objects)\nJSON.stringify(obj1) === JSON.stringify(obj2); // true (based on string representation)",
              "explanation": "This example clearly shows that `obj1` and `obj2`, despite having identical content, are distinct objects in memory, hence `==` and `===` return `false`. `obj3` points to the same memory location as `obj1`, so they are considered strictly equal. `JSON.stringify` provides a way to compare the *serialized* values, but it's limited for objects with `undefined`, `Symbol`, or functions, and doesn't handle property order.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_equality_1",
            "question_equality_2",
            "question_equality_3",
            "question_equality_4",
            "question_equality_5",
            "question_equality_6"
          ],
          "relatedTasks": [
            "task_equality_1"
          ],
          "tags": [
            "equality",
            "comparison",
            "type_coercion",
            "strict_equality",
            "loose_equality",
            "javascript_basics"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_datatypes",
            "operators"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "conditional_logic",
            "debugging",
            "data_comparison"
          ]
        },
        {
          "id": "theory_strict_vs_loose_equality_deep_dive",
          "title": "Strict vs. Loose Equality: A Deeper Dive",
          "content": "The `==` operator performs type coercion before comparison, meaning it attempts to convert the operands to the same type before checking their values. In contrast, the `===` operator performs a strict comparison, meaning it will return `true` only if both the value and the type of the operands are identical. The `===` operator is almost always preferred to avoid unexpected behavior due to implicit type conversions.\n\n### Common Coercion Scenarios with `==`\n\n*   **`undefined` and `null`**: `null == undefined` is `true`. They are special cases in the specification.\n*   **Boolean conversion**: `0`, `''` (empty string), `null`, `undefined`, `NaN` are all 'falsy' values. When compared with `false` using `==`, they can be coerced to `false`.\n*   **Objects vs Primitives**: Objects are generally converted to primitives for `==` comparison, often by calling their `valueOf()` or `toString()` methods.\n\n### The `Number` Object\n\nWhen `new Number(5)` is used, it creates an *object* wrapper around the primitive number `5`. While this object *represents* the value `5`, it is not the primitive `5` itself. Therefore, when compared strictly (`===`), it will be different from the primitive. However, with loose equality (`==`), the `Number` object might be coerced to its primitive value for comparison.",
          "examples": [
            {
              "id": "example_strict_vs_loose_equality_1",
              "title": "Specific Cases of Strict vs. Loose Equality",
              "code": "let abc = undefined;\nabc == undefined; // true, as undefined == undefined\nabc === undefined; // true - only if abc is strictly undefined\n\nabc = null;\nabc == undefined; // true, as null == undefined\nabc === undefined; // false, as null !== undefined\n\nabc = false;\nabc == false;    // true\nabc === false;   // true, only if abc is strictly false\n\nabc = 0;\nabc == false;    // true (0 is falsy, coerced to false)\nabc === false;   // false (number vs boolean)\n\nabc = '';\nabc == false;    // true (empty string is falsy, coerced to false)\nabc === false;   // false (string vs boolean)\n\nabc = []; // an empty array is a truthy object, but its primitive value can be 0 or '' in some contexts\nabc == false;    // true ([] is coerced to '' (empty string), then '' is coerced to false)\nababc === false;   // false (array object vs boolean)\n\n5 == 5;           // true\n5 === 5;          // true\nnew Number(5) == 5; // true (new Number(5) object is coerced to primitive 5)\nnew Number(5) === 5; // false! (new Number(5) is an object, 5 is a primitive number)",
              "explanation": "This example demonstrates various type coercion behaviors of `==` versus the strictness of `===`. Notice how `null == undefined` is a special case. `0`, `''`, `[]` (after coercion to primitive) are all considered `true` when loosely compared to `false` because they are falsy values. Crucially, `new Number(5)` creates an object, which, despite representing the value 5, is not strictly identical to the primitive 5. This distinction is vital for understanding object wrappers.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_equality_7",
            "question_equality_8",
            "question_equality_9",
            "question_equality_10",
            "question_equality_11"
          ],
          "relatedTasks": [
            "task_strict_loose_equality_1"
          ],
          "tags": [
            "strict_equality",
            "loose_equality",
            "type_coercion",
            "falsy_values",
            "javascript_operators",
            "primitives_objects"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_datatypes",
            "equality_comparison"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust_comparisons",
            "avoiding_bugs",
            "understanding_js_quirks"
          ]
        },
        {
          "id": "theory_closures_basics",
          "title": "Closures: Concept and Basics",
          "content": "A closure is a fundamental concept in JavaScript that refers to the combination of a function and the lexical environment within which that function was declared. In simpler terms, a closure gives you access to an outer function's scope from an inner function.\n\n### Lexical Scoping\n\nJavaScript uses *lexical scoping* (also known as static scoping), which means that the scope of variables is determined by where they are *declared* in the source code, not where they are *called*.\n\nWhen an inner function is defined, it 'remembers' the environment it was created in. This environment includes all local variables that were in-scope at the time the closure was created, even if the outer function has already finished executing.\n\n### How Closures Work\n\n1.  **Outer Function Execution**: An outer function is called and completes its execution.\n2.  **Inner Function Creation**: The outer function returns an inner function.\n3.  **Lexical Environment Retention**: Even though the outer function has finished, its local variables (from its lexical environment) are not garbage collected if the returned inner function still references them. The inner function 'closes over' these variables.\n4.  **Access**: The inner function can then access and manipulate these variables from its lexical environment, even much later when it is called.",
          "examples": [
            {
              "id": "example_closures_basics_1",
              "title": "Basic Closure Example: `makeAdder`",
              "code": "// Basic closure example\nfunction makeAdder(x) {\n  // 'x' is part of the lexical environment of the returned function\n  return function(y) {\n    return x + y;\n  };\n}\n\nconst add5 = makeAdder(5);  // 'add5' is a closure. It 'remembers' x = 5.\nconst add10 = makeAdder(10); // 'add10' is another closure. It 'remembers' x = 10.\n\nconsole.log(add5(2));  // 7 (x=5, y=2)\nconsole.log(add10(2)); // 12 (x=10, y=2)",
              "explanation": "In this example, `makeAdder` is the outer function. It takes an argument `x` and returns an anonymous inner function. When `makeAdder(5)` is called, the inner function is created and 'closes over' the value of `x` (which is `5`). This closure is then assigned to `add5`. Even after `makeAdder` finishes executing, `add5` can still access `x`. The same applies to `add10` with its own `x` value of `10`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_closures_1",
            "question_closures_2",
            "question_closures_3",
            "question_closures_4",
            "question_closures_5"
          ],
          "relatedTasks": [
            "task_closures_basic_1"
          ],
          "tags": [
            "closures",
            "lexical_scoping",
            "scope",
            "functions",
            "javascript_fundamentals"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "scope_chains"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "module_patterns",
            "data_privacy",
            "currying",
            "memoization"
          ]
        },
        {
          "id": "theory_practical_closures",
          "title": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "content": "Closures are incredibly powerful for creating private variables and implementing module patterns, offering a way to encapsulate data and methods within a function scope, making them accessible only through specific privileged methods. This is a core concept for achieving data privacy and managing state.\n\n### Data Encapsulation\n\nBy using closures, you can create variables that are 'private' to an outer function's scope. Inner functions returned by the outer function can access and modify these variables, but the variables themselves are not directly accessible from outside the outer function. This effectively creates an encapsulated 'object' where internal state is protected, and interactions are managed through public methods.\n\n### Module Pattern\n\nThe Module Pattern is a widely used design pattern in JavaScript that leverages closures to encapsulate 'private' members (variables, functions) and expose 'public' members through a returned object. This helps avoid polluting the global namespace and promotes modular, organized code.",
          "examples": [
            {
              "id": "example_practical_closures_1",
              "title": "Counter with Private Variable using Closure",
              "code": "function createCounter() {\n  let privateCounter = 0; // This variable is 'private' to createCounter's scope\n  \n  return {\n    increment: function() {\n      privateCounter++; // Can access and modify privateCounter\n    },\n    decrement: function() {\n      privateCounter--; // Can access and modify privateCounter\n    },\n    getValue: function() {\n      return privateCounter; // Can access privateCounter\n    }\n  };\n}\n\nconst counter = createCounter();\ncounter.increment();\ncounter.increment();\nconsole.log(counter.getValue()); // 2\n\n// console.log(counter.privateCounter); // Undefined! privateCounter is not directly accessible",
              "explanation": "This `createCounter` function demonstrates encapsulation. `privateCounter` is a local variable within `createCounter`. The returned object contains three methods (`increment`, `decrement`, `getValue`), all of which form closures over the `privateCounter` variable. This means they can access and modify `privateCounter`, but `privateCounter` itself is not exposed directly to the outside world, effectively making it a private variable. This pattern is fundamental for building robust and maintainable JavaScript modules.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_practical_closures_1",
            "question_practical_closures_2",
            "question_practical_closures_3",
            "question_practical_closures_4"
          ],
          "relatedTasks": [
            "task_closures_advanced_1"
          ],
          "tags": [
            "closures",
            "encapsulation",
            "data_privacy",
            "module_pattern",
            "design_patterns",
            "javascript_advanced"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures_basics",
            "object_literals"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "framework_architecture",
            "custom_modules",
            "state_management"
          ]
        },
        {
          "id": "theory_advanced_closure_patterns_conceptual",
          "title": "Advanced Closure Patterns (Conceptual Overview)",
          "content": "While the provided content only lists 'Advanced Closure Patterns' as a heading without specific examples, it's important to understand that closures form the basis for several powerful and common JavaScript programming patterns. These patterns leverage the ability of inner functions to 'remember' and access variables from their outer lexical environment even after the outer function has completed.\n\nCommon advanced closure patterns and their applications include:\n\n*   **Memoization**: Caching the results of expensive function calls to improve performance. A closure can store the cache.\n*   **Currying**: Transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument. Each step in the sequence is a closure.\n*   **Module Pattern (IIFE-based)**: As seen in practical uses, closures are fundamental to creating self-contained modules with private state and public interfaces, preventing global scope pollution. This is a common design pattern for organizing JavaScript code.\n*   **Iterators and Generators**: While modern JavaScript has built-in `Iterator` and `Generator` protocols, the underlying concept of maintaining state across multiple invocations often involves closure-like mechanisms.\n*   **Event Handlers**: When an event listener function is defined within another function, it often forms a closure over variables from its surrounding scope, allowing it to access context-specific data when the event fires.\n*   **Higher-Order Functions**: Functions that return other functions, or take functions as arguments, frequently rely on closures to maintain context and state.",
          "examples": [],
          "relatedQuestions": [
            "question_advanced_closures_1",
            "question_advanced_closures_2"
          ],
          "relatedTasks": [],
          "tags": [
            "closures",
            "advanced_patterns",
            "memoization",
            "currying",
            "module_pattern",
            "design_patterns"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures_basics",
            "practical_closures"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "functional_programming",
            "performance_optimization",
            "complex_system_design"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_getters_setters_1",
          "topic": "Object Getters and Setters",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a getter in JavaScript?",
          "answer": "To define a method that is executed when a property is accessed (read), often for returning computed values or formatting data.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "getters",
            "object_properties",
            "computed_properties"
          ],
          "evaluationCriteria": [
            "Understanding of basic getter function"
          ],
          "example": "",
          "tags": [
            "getters",
            "objects",
            "javascript_basics"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_getters_setters_2",
          "topic": "Object Getters and Setters",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a setter in JavaScript?",
          "answer": "To define a method that is executed when a property is assigned a value (written), often for validation or transforming input data.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "setters",
            "object_properties",
            "data_validation"
          ],
          "evaluationCriteria": [
            "Understanding of basic setter function"
          ],
          "example": "",
          "tags": [
            "setters",
            "objects",
            "javascript_basics"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_getters_setters_3",
          "topic": "Object Getters and Setters",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript object:\n\n```javascript\nconst product = {\n  _price: 100,\n  get price() {\n    return this._price;\n  },\n  set price(value) {\n    if (value > 0) {\n      this._price = value;\n    } else {\n      console.log('Price must be positive');\n    }\n  }\n};\n\nproduct.price = -50;\nconsole.log(product.price);\n```\n\nWhat will be logged to the console by the last `console.log` statement?",
          "answer": "100",
          "options": [
            "-50",
            "0",
            "100",
            "undefined"
          ],
          "analysisPoints": [
            "The setter `price` includes a validation check `if (value > 0)`.",
            "When `product.price = -50` is executed, the `set price(value)` method is called.",
            "Since `-50` is not `> 0`, the `if` condition is false, and `this._price` is not updated.",
            "The `else` block logs 'Price must be positive', but this does not change `_price`.",
            "Therefore, `_price` retains its initial value of `100`.",
            "When `console.log(product.price)` is called, the `get price()` method returns the current `_price` which is `100`."
          ],
          "keyConcepts": [
            "getters",
            "setters",
            "data_validation",
            "object_properties"
          ],
          "evaluationCriteria": [
            "Ability to trace execution flow through getter/setter logic.",
            "Understanding of conditional statements within setters.",
            "Knowledge of how internal properties are accessed by getters."
          ],
          "example": "The setter prevents the `_price` from being set to a non-positive value. The `console.log` inside the `else` branch is a side effect of the setter's logic, but the property itself remains unchanged if the validation fails.",
          "tags": [
            "getters",
            "setters",
            "objects",
            "data_validation",
            "mcq"
          ],
          "prerequisites": [
            "javascript_objects",
            "conditional_statements"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_getters_setters_4",
          "topic": "Object Getters and Setters",
          "level": "medium",
          "type": "open",
          "question": "Explain a scenario where using getters and setters would be more beneficial than directly accessing or modifying an object's properties. Provide a brief code example.",
          "answer": "Getters and setters are particularly beneficial when you need to control access to properties, perform validation, or derive property values dynamically. \n\n**Scenario**: Managing a user's age with validation and calculated properties.\n\n**Benefit**: \n1.  **Validation**: A setter for `age` can ensure that only valid numeric and positive values are assigned, preventing invalid data from entering the object's state.\n2.  **Computed Properties**: A getter for `isAdult` can automatically calculate whether a user is an adult based on their `age` without needing to store this as a separate, potentially desynchronized, property.\n3.  **Encapsulation**: It allows the internal representation of data (e.g., storing `birthYear` instead of `age`) to be abstracted away from the public interface.\n\n**Code Example**:\n```javascript\nconst user = {\n  _age: null, // Internal property\n\n  set age(value) {\n    if (typeof value === 'number' && value >= 0 && value <= 120) {\n      this._age = value;\n      console.log(`Age set to ${value}`);\n    } else {\n      console.error('Invalid age value. Age must be a number between 0 and 120.');\n    }\n  },\n\n  get age() {\n    return this._age;\n  },\n\n  get isAdult() {\n    return this._age >= 18;\n  }\n};\n\nuser.age = 25;       // Age set to 25\nconsole.log(user.isAdult); // true\nuser.age = 5;        // Age set to 5\nconsole.log(user.isAdult); // false\nuser.age = 150;      // Invalid age value. Age must be a number between 0 and 120.\nconsole.log(user.age);     // 5 (age remains unchanged due to validation failure)\n```\nIn this example, the `age` setter validates input, and the `isAdult` getter computes a value on the fly, demonstrating controlled access and derived properties.",
          "options": [],
          "analysisPoints": [
            "Demonstrates understanding of validation and computed properties.",
            "Provides a clear and concise code example.",
            "Articulates the 'why' behind using getters/setters effectively."
          ],
          "keyConcepts": [
            "getters",
            "setters",
            "data_validation",
            "computed_properties",
            "encapsulation",
            "data_integrity"
          ],
          "evaluationCriteria": [
            "Clarity of explanation and example.",
            "Identification of relevant benefits.",
            "Correct implementation of getter/setter logic."
          ],
          "example": "```javascript\nconst user = {\n  _age: null,\n  set age(value) {\n    if (typeof value === 'number' && value >= 0 && value <= 120) {\n      this._age = value;\n    } else {\n      console.error('Invalid age value.');\n    }\n  },\n  get age() {\n    return this._age;\n  },\n  get isAdult() {\n    return this._age >= 18;\n  }\n};\nuser.age = 25;\nconsole.log(user.isAdult);\nuser.age = 150;\nconsole.log(user.age);\n```",
          "tags": [
            "getters",
            "setters",
            "open-ended",
            "design_patterns",
            "data_modeling"
          ],
          "prerequisites": [
            "javascript_objects",
            "functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_1",
          "topic": "Equality and Comparison in JavaScript",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main difference between `==` and `===` operators?",
          "answer": "`==` performs type coercion before comparison, while `===` checks for both value and type without coercion.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "loose_equality",
            "strict_equality",
            "type_coercion"
          ],
          "evaluationCriteria": [
            "Ability to recall the fundamental difference."
          ],
          "example": "",
          "tags": [
            "equality",
            "operators",
            "javascript_basics"
          ],
          "prerequisites": [
            "javascript_datatypes"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_equality_2",
          "topic": "Equality and Comparison in JavaScript",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following expressions evaluates to `true`?\n\n```javascript\n// Option A\n'5' === 5;\n\n// Option B\nnull === undefined;\n\n// Option C\n0 == false;\n\n// Option D\n[1,2] == [1,2];\n```",
          "answer": "0 == false;",
          "options": [
            "'5' === 5;",
            "null === undefined;",
            "0 == false;",
            "[1,2] == [1,2];"
          ],
          "analysisPoints": [
            "Option A: `'5' === 5` is `false` because `===` checks types; string is not number.",
            "Option B: `null === undefined` is `false` because `===` checks types; `null` and `undefined` are different types.",
            "Option C: `0 == false` is `true` because `==` performs type coercion; `false` is coerced to `0`.",
            "Option D: `[1,2] == [1,2]` is `false` because objects (arrays) are compared by reference, and these are two distinct array objects."
          ],
          "keyConcepts": [
            "loose_equality",
            "strict_equality",
            "type_coercion",
            "object_equality"
          ],
          "evaluationCriteria": [
            "Understanding of type coercion with `==`.",
            "Understanding of strict equality with `===`.",
            "Knowledge of object reference comparison."
          ],
          "example": "The correct option `0 == false` is `true` because JavaScript's `==` operator will coerce `false` to `0` (a falsy value), making the comparison `0 == 0`, which is `true`.",
          "tags": [
            "equality",
            "comparison",
            "type_coercion",
            "mcq"
          ],
          "prerequisites": [
            "equality_comparison"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_equality_3",
          "topic": "Equality and Comparison in JavaScript",
          "level": "medium",
          "type": "open",
          "question": "Why do `obj1 == obj2` and `obj1 === obj2` both evaluate to `false` when `obj1 = { a: 1 };` and `obj2 = { a: 1 };`? How can you check if two objects have the same *values*?",
          "answer": "Both `obj1 == obj2` and `obj1 === obj2` evaluate to `false` because in JavaScript, objects are compared by *reference*, not by *value*. When you create `obj1` and `obj2` using object literals (`{}`), you are creating two distinct objects in memory, even if they have identical properties and values. Neither `==` nor `===` will check the content of the objects, only if they point to the exact same location in memory.\n\nTo check if two objects have the same *values* (i.e., deep equality), you typically need to implement a deep comparison logic or use a library that provides such functionality. A common, but **limited**, workaround for simple objects is to serialize them to JSON strings and compare the strings:\n\n```javascript\nconst obj1 = { a: 1, b: 'hello' };\nconst obj2 = { a: 1, b: 'hello' };\n\n// This is true for simple objects with consistent key order\nconsole.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true\n\n// Limitations: does not handle functions, undefined, Symbols, or different property order\nconst obj3 = { a: 1, func: () => {} };\nconst obj4 = { a: 1, func: () => {} };\nconsole.log(JSON.stringify(obj3) === JSON.stringify(obj4)); // false, because functions are stripped\n\nconst obj5 = { a: 1, b: 2 };\nconst obj6 = { b: 2, a: 1 };\n// This will be false if property order is not guaranteed by stringify\nconsole.log(JSON.stringify(obj5) === JSON.stringify(obj6)); // Might be false depending on engine's stringify order\n```\n\nFor robust deep comparison, one would need to write a recursive function that iterates through properties, checks their types, and compares their values, including nested objects and arrays. Libraries like Lodash's `isEqual` provide this functionality.",
          "options": [],
          "analysisPoints": [
            "Explains object comparison by reference.",
            "Highlights the limitation of `==` and `===` for value comparison.",
            "Suggests `JSON.stringify` as a workaround with caveats.",
            "Mentions the need for deep comparison logic for robust value checking."
          ],
          "keyConcepts": [
            "object_equality",
            "reference_comparison",
            "value_comparison",
            "deep_equality",
            "JSON.stringify"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation for reference vs. value.",
            "Identification of `JSON.stringify` workaround and its limitations.",
            "Understanding of the need for deep comparison."
          ],
          "example": "```javascript\nconst obj1 = { a: 1 };\nconst obj2 = { a: 1 };\nconst obj3 = obj1;\n\nconsole.log(obj1 === obj2); // false\nconsole.log(obj1 === obj3); // true\n\nconsole.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true (limited)\n```",
          "tags": [
            "equality",
            "objects",
            "reference_vs_value",
            "deep_comparison",
            "open-ended"
          ],
          "prerequisites": [
            "object_equality",
            "javascript_objects"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_4",
          "topic": "Equality and Comparison in JavaScript",
          "level": "medium",
          "type": "code",
          "question": "Implement a function `areArraysEqual` that strictly compares two arrays for element-by-element equality. The function should return `true` if both arrays have the same length and all elements at corresponding positions are strictly equal (`===`), and `false` otherwise. Do not use `JSON.stringify`.",
          "answer": "```javascript\nfunction areArraysEqual(arr1, arr2) {\n  if (!Array.isArray(arr1) || !Array.isArray(arr2)) {\n    // Handle non-array inputs if necessary, or throw an error\n    return false;\n  }\n\n  if (arr1.length !== arr2.length) {\n    return false; // Arrays must have the same length\n  }\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false; // Elements at corresponding positions must be strictly equal\n    }\n  }\n\n  return true; // All checks passed\n}\n\n// Test cases:\nconsole.log(areArraysEqual([1, 2, 3], [1, 2, 3]));          // true\nconsole.log(areArraysEqual([1, 2, '3'], [1, 2, 3]));        // false (type mismatch for '3' vs 3)\nconsole.log(areArraysEqual([1, 2], [1, 2, 3]));             // false (different lengths)\nconsole.log(areArraysEqual([], []));                       // true\nconsole.log(areArraysEqual([null, undefined], [null, undefined])); // true\nconsole.log(areArraysEqual([NaN], [NaN]));                   // false (NaN !== NaN)\nconsole.log(areArraysEqual([1, {a:1}], [1, {a:1}]));         // false (objects by reference)\nconsole.log(areArraysEqual([1, 'a', true], [1, 'a', true])); // true\n```",
          "options": [],
          "analysisPoints": [
            "Checks for array type first (optional, but good practice).",
            "Compares lengths as the first and most efficient check.",
            "Iterates through elements, using `!==` for strict inequality.",
            "Handles edge cases like empty arrays and `NaN` (though `NaN !== NaN` is a specific JS quirk).",
            "Does not attempt deep comparison for nested objects/arrays (as per strict `===` requirement for elements)."
          ],
          "keyConcepts": [
            "array_comparison",
            "strict_equality",
            "iteration",
            "edge_cases"
          ],
          "evaluationCriteria": [
            "Correct implementation of array length check.",
            "Correct use of `===` for element comparison.",
            "Handling of empty arrays.",
            "Efficiency (early exit on mismatch)."
          ],
          "example": "```javascript\nfunction areArraysEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n```",
          "tags": [
            "code_challenge",
            "arrays",
            "equality",
            "algorithms"
          ],
          "prerequisites": [
            "arrays",
            "strict_equality",
            "loops"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_5",
          "topic": "Equality and Comparison in JavaScript",
          "level": "hard",
          "type": "mcq",
          "question": "What is the result of the following comparison in JavaScript?\n\n```javascript\n[] == ![];\n```",
          "answer": "true",
          "options": [
            "true",
            "false",
            "TypeError",
            "undefined"
          ],
          "analysisPoints": [
            "**Step 1: Evaluate `![]`**\n    *   The `!` (logical NOT) operator converts its operand to a boolean. Any object, including an empty array `[]`, is considered 'truthy'.\n    *   So, `![]` evaluates to `!true`, which is `false`.\n*   **Step 2: Evaluate `[] == false`**\n    *   This is a loose equality comparison.\n    *   The spec says that if one operand is an object and the other is a primitive, the object is converted to a primitive.\n    *   `[]`'s `toString()` method returns `''` (empty string).\n    *   So the comparison becomes `'' == false`.\n*   **Step 3: Evaluate `'' == false`**\n    *   Both operands are now primitives. If one is a string and the other is a boolean, both are converted to numbers.\n    *   `''` converts to the number `0`.\n    *   `false` converts to the number `0`.\n    *   So the comparison becomes `0 == 0`, which is `true`."
          ],
          "keyConcepts": [
            "type_coercion",
            "loose_equality",
            "truthy_falsy",
            "object_to_primitive_conversion",
            "logical_operators"
          ],
          "evaluationCriteria": [
            "Understanding of the `!` operator's effect on objects.",
            "Knowledge of how `==` handles arrays when compared to booleans.",
            "Ability to trace multiple steps of type coercion."
          ],
          "example": "This is a classic JavaScript 'quirk' question. The sequence of coercions is crucial:\n1.  `![]` -> `false` (empty array is truthy, so `!truthy` is `false`)\n2.  `[] == false` -> (Array `[]` is converted to primitive string `''`)\n3.  `'' == false` -> (String `''` is converted to number `0`, Boolean `false` is converted to number `0`)\n4.  `0 == 0` -> `true`",
          "tags": [
            "equality",
            "type_coercion",
            "quirks",
            "advanced_js",
            "mcq"
          ],
          "prerequisites": [
            "equality_comparison",
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_equality_6",
          "topic": "Equality and Comparison in JavaScript",
          "level": "easy",
          "type": "flashcard",
          "question": "When comparing objects with `==` or `===`, what is actually compared?",
          "answer": "Their references (memory addresses), not their values or content.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "object_equality",
            "reference_comparison"
          ],
          "evaluationCriteria": [
            "Correctly identifying object comparison mechanism."
          ],
          "example": "",
          "tags": [
            "objects",
            "equality",
            "memory"
          ],
          "prerequisites": [
            "object_equality"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_equality_7",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements is true regarding `null` and `undefined` in JavaScript?\n\n```javascript\n// Option A\nnull === undefined;\n\n// Option B\nnull == undefined;\n\n// Option C\ntypeof null === 'undefined';\n\n// Option D\nnull + undefined === NaN;\n```",
          "answer": "null == undefined;",
          "options": [
            "null === undefined;",
            "null == undefined;",
            "typeof null === 'undefined';",
            "null + undefined === NaN;"
          ],
          "analysisPoints": [
            "Option A: `null === undefined` is `false` because they are of different types, and `===` does not perform type coercion.",
            "Option B: `null == undefined` is `true` because, according to JavaScript's specification, `null` and `undefined` are special cases considered loosely equal to each other.",
            "Option C: `typeof null` returns `'object'`, which is a historical quirk in JavaScript. So, `'object' === 'undefined'` is `false`.",
            "Option D: `null` converts to `0` in numeric contexts, and `undefined` converts to `NaN`. So `0 + NaN` results in `NaN`. Thus, `NaN === NaN` is `false` (NaN is never strictly equal to anything, including itself). The expression `null + undefined` *is* `NaN`, but `NaN === NaN` is `false`. So this statement `null + undefined === NaN` evaluates to `false`."
          ],
          "keyConcepts": [
            "null_undefined",
            "type_coercion",
            "strict_equality",
            "loose_equality",
            "typeof_operator",
            "NaN_comparison"
          ],
          "evaluationCriteria": [
            "Understanding of loose equality rule for `null` and `undefined`.",
            "Knowledge of `typeof null` quirk.",
            "Understanding of `NaN` behavior in comparisons."
          ],
          "example": "The key here is that `null` and `undefined` are *loosely* equal but not *strictly* equal because they are distinct types. The `typeof null` returning 'object' is a well-known JavaScript oddity.",
          "tags": [
            "equality",
            "datatypes",
            "null",
            "undefined",
            "type_coercion",
            "mcq"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_8",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "hard",
          "type": "open",
          "question": "Why does `new Number(5) === 5` evaluate to `false`, while `new Number(5) == 5` evaluates to `true`? Explain the underlying mechanism.",
          "answer": "`new Number(5) === 5` evaluates to `false` because `new Number(5)` creates an **object wrapper** around the primitive number `5`, whereas `5` is a **primitive number** itself. The strict equality operator (`===`) checks both the value and the *type* (and for objects, the reference). Since one operand is an object (`Number` object) and the other is a primitive (`number`), their types are different, hence the strict comparison returns `false`.\n\n`new Number(5) == 5` evaluates to `true` because the loose equality operator (`==`) performs **type coercion**. When comparing an object with a primitive, JavaScript attempts to convert the object to a primitive value. For `Number` objects, this conversion happens by calling the object's `valueOf()` method. The `valueOf()` method of a `Number` object returns the primitive numeric value it wraps. So, `new Number(5).valueOf()` returns the primitive `5`. The comparison then becomes `5 == 5`, which evaluates to `true`.",
          "options": [],
          "analysisPoints": [
            "Explains the difference between primitive values and object wrappers.",
            "Details how `===` considers type differences for `Number` object vs. primitive.",
            "Explains type coercion for `==`, specifically the `valueOf()` method for objects.",
            "Clearly differentiates between the behavior of `==` and `===` in this specific scenario."
          ],
          "keyConcepts": [
            "primitive_vs_object",
            "object_wrappers",
            "type_coercion",
            "valueOf_method",
            "strict_equality",
            "loose_equality"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation for both `===` and `==`.",
            "Correct understanding of `Number` object and `valueOf()`.",
            "Clarity and completeness of the explanation."
          ],
          "example": "```javascript\nconsole.log(typeof new Number(5)); // object\nconsole.log(typeof 5);           // number\n\nconsole.log(new Number(5) === 5); // false (object !== primitive)\n\nconsole.log(new Number(5).valueOf()); // 5 (primitive value)\nconsole.log(new Number(5) == 5);  // true (object coerced to primitive 5)\n```",
          "tags": [
            "equality",
            "primitives_objects",
            "type_coercion",
            "open-ended",
            "advanced_js"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive",
            "javascript_datatypes"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_equality_9",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "medium",
          "type": "flashcard",
          "question": "Is `NaN == NaN` true or false?",
          "answer": "False. `NaN` is the only value in JavaScript that is not equal to itself, even with loose or strict equality. You must use `Number.isNaN()` or `isNaN()` to check for `NaN`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "NaN",
            "equality",
            "Number.isNaN"
          ],
          "evaluationCriteria": [
            "Correctly identifies `NaN` comparison behavior."
          ],
          "example": "",
          "tags": [
            "NaN",
            "equality",
            "javascript_quirks"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_10",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of the following JavaScript code?\n\n```javascript\nconsole.log([] == 0);\nconsole.log([] == '');\nconsole.log(0 == '');\n```",
          "answer": "true\ntrue\ntrue",
          "options": [
            "true\ntrue\ntrue",
            "false\nfalse\nfalse",
            "true\nfalse\ntrue",
            "false\ntrue\nfalse"
          ],
          "analysisPoints": [
            "**`[] == 0`**:\n    *   `[]` (object) is converted to a primitive. `[].toString()` is `''`.\n    *   So, it becomes `'' == 0`.\n    *   `''` (string) is converted to `0` (number).\n    *   So, it becomes `0 == 0`, which is `true`.\n*   **`[] == ''`**:\n    *   `[]` (object) is converted to a primitive. `[].toString()` is `''`.\n    *   So, it becomes `'' == ''`, which is `true`.\n*   **`0 == ''`**:\n    *   `''` (string) is converted to `0` (number).\n    *   So, it becomes `0 == 0`, which is `true`."
          ],
          "keyConcepts": [
            "type_coercion",
            "loose_equality",
            "object_to_primitive_conversion",
            "falsy_values"
          ],
          "evaluationCriteria": [
            "Understanding of how empty arrays are coerced to primitive strings.",
            "Understanding of how empty strings are coerced to numbers.",
            "Ability to follow chain of type coercions."
          ],
          "example": "These demonstrate common implicit type coercions with the loose equality operator. The empty array `[]` often coerces to an empty string `''` when compared in a loose context, and both `''` and `0` are considered loosely equal to `false` and each other.",
          "tags": [
            "equality",
            "type_coercion",
            "javascript_quirks",
            "mcq"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_11",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "hard",
          "type": "code",
          "question": "Write a JavaScript function `areStrictlyEqual` that takes two arguments, `a` and `b`, and returns `true` if they are strictly equal (`a === b`), and `false` otherwise. Additionally, include comments explaining why each of the following test cases produces its result.\n\n```javascript\nconsole.log(areStrictlyEqual(5, '5'));        // Expected: false\nconsole.log(areStrictlyEqual(null, undefined)); // Expected: false\nconsole.log(areStrictlyEqual(0, false));      // Expected: false\nconsole.log(areStrictlyEqual(new Number(10), 10)); // Expected: false\nconsole.log(areStrictlyEqual({}, {}));        // Expected: false\nconsole.log(areStrictlyEqual(NaN, NaN));      // Expected: false\nconsole.log(areStrictlyEqual('hello', 'hello')); // Expected: true\nlet obj = { x: 1 };\nconsole.log(areStrictlyEqual(obj, obj));      // Expected: true\n```",
          "answer": "```javascript\nfunction areStrictlyEqual(a, b) {\n  return a === b;\n}\n\n// Test cases with explanations:\n\n// Expected: false\n// Explanation: '5' is a string, 5 is a number. Strict equality checks both value AND type.\nconsole.log(areStrictlyEqual(5, '5'));\n\n// Expected: false\n// Explanation: null and undefined are different types, even though they are loosely equal (null == undefined).\n// Strict equality does not perform type coercion.\nconsole.log(areStrictlyEqual(null, undefined));\n\n// Expected: false\n// Explanation: 0 is a number, false is a boolean. Strict equality checks both value AND type.\nconsole.log(areStrictlyEqual(0, false));\n\n// Expected: false\n// Explanation: new Number(10) creates a Number OBJECT, while 10 is a primitive number.\n// Strict equality checks object references for objects, and types for primitives.\nconsole.log(areStrictlyEqual(new Number(10), 10));\n\n// Expected: false\n// Explanation: {} creates a new, distinct object in memory each time.\n// Strict equality compares object references, and these are two different references.\nconsole.log(areStrictlyEqual({}, {}));\n\n// Expected: false\n// Explanation: NaN is a special numeric value that is never strictly equal to itself, nor any other value.\n// You must use Number.isNaN() or isNaN() to check for NaN.\nconsole.log(areStrictlyEqual(NaN, NaN));\n\n// Expected: true\n// Explanation: Both are primitive strings with the same value and same type.\nconsole.log(areStrictlyEqual('hello', 'hello'));\n\nlet obj = { x: 1 };\n// Expected: true\n// Explanation: Both arguments refer to the exact same object in memory.\n// Strict equality for objects checks if the references are identical.\nconsole.log(areStrictlyEqual(obj, obj));\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implements the `===` operator.",
            "Provides accurate and concise explanations for each test case.",
            "Demonstrates understanding of `===` behavior with different data types, object references, and special values like `null`, `undefined`, and `NaN`."
          ],
          "keyConcepts": [
            "strict_equality",
            "type_coercion",
            "object_reference",
            "NaN",
            "primitive_types",
            "object_wrappers"
          ],
          "evaluationCriteria": [
            "Correctness of the function.",
            "Accuracy and completeness of explanations for test cases.",
            "Demonstrated understanding of `===` nuances."
          ],
          "example": "The task focuses on explaining why `===` behaves the way it does across various data types and scenarios, highlighting that it never performs type coercion and always checks identity for objects.",
          "tags": [
            "code_challenge",
            "equality",
            "strict_equality",
            "javascript_fundamentals"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_closures_1",
          "topic": "Closures: Concept and Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a closure in JavaScript?",
          "answer": "A closure is the combination of a function and the lexical environment within which that function was declared, allowing the function to access variables from its outer scope even after the outer function has finished executing.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "closures",
            "lexical_environment",
            "scope"
          ],
          "evaluationCriteria": [
            "Correct definition of closure."
          ],
          "example": "",
          "tags": [
            "closures",
            "javascript_fundamentals"
          ],
          "prerequisites": [
            "javascript_functions",
            "scope_chains"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_closures_2",
          "topic": "Closures: Concept and Basics",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code:\n\n```javascript\nfunction outer() {\n  let counter = 0;\n  return function inner() {\n    counter++;\n    return counter;\n  };\n}\n\nconst fn1 = outer();\nconst fn2 = outer();\n\nconsole.log(fn1());\nconsole.log(fn1());\nconsole.log(fn2());\n```\n\nWhat will be the output?",
          "answer": "1\n2\n1",
          "options": [
            "1\n2\n3",
            "1\n1\n1",
            "1\n2\n1",
            "Error"
          ],
          "analysisPoints": [
            "Each call to `outer()` creates a *new* lexical environment and a *new* `counter` variable.",
            "`fn1` is a closure that 'remembers' its own `counter` (initialized to 0 when `fn1` was created).",
            "`fn2` is a *separate* closure that 'remembers' its own `counter` (also initialized to 0 when `fn2` was created).",
            "When `fn1()` is called, its `counter` increments to 1, then to 2.",
            "When `fn2()` is called, its *own* `counter` increments to 1, independently of `fn1`'s counter."
          ],
          "keyConcepts": [
            "closures",
            "lexical_scoping",
            "function_scope",
            "independent_closures"
          ],
          "evaluationCriteria": [
            "Understanding that each call to `outer()` creates a new, independent closure.",
            "Ability to trace the state of `counter` for each closure instance."
          ],
          "example": "```javascript\nfunction outer() {\n  let counter = 0;\n  return function inner() {\n    counter++;\n    return counter;\n  };\n}\n\nconst fn1 = outer(); // fn1 has its own 'counter' state\nconst fn2 = outer(); // fn2 has its own 'counter' state, separate from fn1\n\nconsole.log(fn1()); // 1 (fn1's counter becomes 1)\nconsole.log(fn1()); // 2 (fn1's counter becomes 2)\nconsole.log(fn2()); // 1 (fn2's counter becomes 1)\n```",
          "tags": [
            "closures",
            "scope",
            "mcq",
            "state_management"
          ],
          "prerequisites": [
            "closures_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_closures_3",
          "topic": "Closures: Concept and Basics",
          "level": "medium",
          "type": "open",
          "question": "What is 'lexical environment' in the context of closures, and how does it relate to 'lexical scoping'?",
          "answer": "The **lexical environment** is a conceptual structure that holds identifier-variable mappings. It's essentially a record of all local variables, arguments, and other identifiers that are accessible within a particular scope. Each time a function is called, a new lexical environment is created for that invocation.\n\n**Lexical scoping** (or static scoping) is the rule that JavaScript uses to determine the scope of a variable. It means that the scope of variables is defined by their position within the source code *at the time of definition*, not by where they are called. When a function is defined, it 'remembers' its lexical environment—the environment in which it was *created*.\n\n**Relation to Closures**: A closure arises when an inner function 'closes over' or retains access to the variables of its outer function's lexical environment, even after the outer function has finished executing. The inner function maintains a reference to the lexical environment of its parent scope. This allows it to access and modify those variables, effectively 'carrying' that environment with it, forming the closure.",
          "options": [],
          "analysisPoints": [
            "Defines lexical environment accurately.",
            "Explains lexical scoping and how it determines variable access.",
            "Connects these concepts to how closures enable access to outer scope variables."
          ],
          "keyConcepts": [
            "lexical_environment",
            "lexical_scoping",
            "scope_chain",
            "closures"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of definitions.",
            "Correctly explaining the relationship between the concepts.",
            "Demonstrated understanding of fundamental JS scope rules."
          ],
          "example": "```javascript\nfunction outer() {\n  let outerVar = 'I am outer';\n  function inner() {\n    // inner 'closes over' outerVar from outer's lexical environment\n    console.log(outerVar);\n  }\n  return inner;\n}\nconst myFunction = outer();\nmyFunction(); // Logs: I am outer (even though outer() has finished)\n```\nHere, `outerVar` is part of `outer`'s lexical environment. `inner` is defined within this environment and 'closes over' it. When `outer()` returns `inner`, `inner` carries a reference to `outer`'s lexical environment, allowing it to access `outerVar` later.",
          "tags": [
            "closures",
            "scope",
            "lexical_scoping",
            "open-ended"
          ],
          "prerequisites": [
            "closures_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_closures_4",
          "topic": "Closures: Concept and Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "Does a closure allow an inner function to access variables from its outer function's scope even after the outer function has completed execution?",
          "answer": "Yes, this is precisely what a closure enables.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "closures",
            "scope",
            "lexical_environment"
          ],
          "evaluationCriteria": [
            "Understanding the persistence of outer scope variables."
          ],
          "example": "",
          "tags": [
            "closures",
            "fundamentals"
          ],
          "prerequisites": [
            "closures_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_closures_5",
          "topic": "Closures: Concept and Basics",
          "level": "medium",
          "type": "code",
          "question": "Create a function `createMultiplier(factor)` that returns a new function. The returned function should take one argument `number` and return `number * factor`. Demonstrate its use to create functions `multiplyBy2` and `multiplyBy5`, then use them.",
          "answer": "```javascript\nfunction createMultiplier(factor) {\n  return function(number) {\n    return number * factor;\n  };\n}\n\n// Create closures\nconst multiplyBy2 = createMultiplier(2);\nconst multiplyBy5 = createMultiplier(5);\n\n// Demonstrate usage\nconsole.log(multiplyBy2(10)); // Expected: 20\nconsole.log(multiplyBy5(10)); // Expected: 50\nconsole.log(multiplyBy2(3));  // Expected: 6\n```",
          "options": [],
          "analysisPoints": [
            "Correctly defines an outer function `createMultiplier`.",
            "Correctly returns an inner function.",
            "The inner function correctly 'closes over' the `factor` parameter from its lexical environment.",
            "Demonstrates the creation of multiple independent closures.",
            "Uses the created closures effectively."
          ],
          "keyConcepts": [
            "closures",
            "higher_order_functions",
            "lexical_scope",
            "function_factories"
          ],
          "evaluationCriteria": [
            "Correct implementation of the closure pattern.",
            "Clarity of the example and demonstration.",
            "Understanding of how `factor` is retained."
          ],
          "example": "This task directly applies the basic closure concept, similar to `makeAdder`, but for multiplication. It shows how closures can be used to 'configure' functions with specific parameters.",
          "tags": [
            "closures",
            "code_challenge",
            "functions"
          ],
          "prerequisites": [
            "closures_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_practical_closures_1",
          "topic": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "level": "medium",
          "type": "flashcard",
          "question": "How can closures be used to achieve data privacy or encapsulation in JavaScript?",
          "answer": "By defining variables within an outer function's scope and returning inner functions that have access to these variables. The inner functions act as privileged methods, providing controlled access to the 'private' variables which are not directly accessible from outside.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "data_privacy",
            "encapsulation",
            "module_pattern",
            "closures"
          ],
          "evaluationCriteria": [
            "Understanding of data privacy through closures."
          ],
          "example": "",
          "tags": [
            "closures",
            "encapsulation",
            "data_privacy"
          ],
          "prerequisites": [
            "practical_closures"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_practical_closures_2",
          "topic": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "level": "medium",
          "type": "mcq",
          "question": "Given the `createCounter` example:\n\n```javascript\nfunction createCounter() {\n  let privateCounter = 0;\n  return {\n    increment: function() { privateCounter++; },\n    decrement: function() { privateCounter--; },\n    getValue: function() { return privateCounter; }\n  };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\ncounter1.increment();\ncounter1.increment();\ncounter2.decrement();\n\nconsole.log(counter1.getValue());\nconsole.log(counter2.getValue());\n```\n\nWhat will be the output?",
          "answer": "2\n-1",
          "options": [
            "2\n2",
            "2\n-1",
            "1\n0",
            "Error"
          ],
          "analysisPoints": [
            "Each call to `createCounter()` creates a separate instance of the counter, each with its own `privateCounter` variable.",
            "`counter1` operates on its own `privateCounter`, which increments from 0 to 1, then to 2.",
            "`counter2` operates on its *separate* `privateCounter`, which decrements from 0 to -1.",
            "The `getValue` method correctly returns the state of the `privateCounter` specific to its instance."
          ],
          "keyConcepts": [
            "closures",
            "encapsulation",
            "private_variables",
            "independent_instances"
          ],
          "evaluationCriteria": [
            "Understanding of how closures create independent instances with separate states.",
            "Ability to track the state of multiple encapsulated counters."
          ],
          "example": "The example shows how `createCounter` acts like a factory for counter objects, each maintaining its own private state (`privateCounter`) thanks to closures.",
          "tags": [
            "closures",
            "encapsulation",
            "state",
            "mcq"
          ],
          "prerequisites": [
            "practical_closures"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_practical_closures_3",
          "topic": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "level": "hard",
          "type": "open",
          "question": "Discuss the 'Module Pattern' in JavaScript and how closures are integral to its implementation. What are the advantages of using this pattern?",
          "answer": "The **Module Pattern** is a widely used design pattern in JavaScript for organizing code into self-contained units, often leveraging Immediately Invoked Function Expressions (IIFEs) and closures. It allows for the creation of 'private' variables and functions while exposing a public interface.\n\n**How Closures are Integral**: The core of the Module Pattern is typically an outer function (often an IIFE) that returns an object containing public methods. Inside this outer function, variables and functions are declared that are not part of the returned object. These variables and functions become 'private' to that module's scope. The public methods, because they are defined within the outer function's scope, form closures over these private members, giving them access. This means the private data and logic are encapsulated and cannot be directly accessed or modified from outside the module.\n\n**Example Structure (IIFE Module Pattern)**:\n```javascript\nconst MyModule = (function() {\n  let privateVar = 'I am private data';\n\n  function privateMethod() {\n    console.log('This is a private method accessing:', privateVar);\n  }\n\n  return { // Public interface exposed via an object\n    publicMethod: function() {\n      console.log('This is a public method.');\n      privateMethod(); // Can access private methods/vars\n    },\n    getPrivateVar: function() {\n      return privateVar; // Provides controlled access to private data\n    }\n  };\n})();\n\nMyModule.publicMethod();      // Logs: This is a public method. \n                              //       This is a private method accessing: I am private data\nconsole.log(MyModule.getPrivateVar()); // Logs: I am private data\n// console.log(MyModule.privateVar); // Undefined (not accessible directly)\n// MyModule.privateMethod();      // TypeError: MyModule.privateMethod is not a function\n```\n\n**Advantages of Using the Module Pattern**:\n\n1.  **Data Privacy/Encapsulation**: It allows you to create truly private variables and methods, protecting internal state from external tampering. This leads to more robust and predictable code.\n2.  **Avoids Global Namespace Pollution**: By encapsulating all module-related variables and functions within a single returned object, it keeps the global scope clean, reducing the risk of naming collisions.\n3.  **Modular Organization**: It promotes a clear separation of concerns, making code easier to understand, maintain, and refactor. Each module can focus on a specific piece of functionality.\n4.  **Reusability**: Modules can be designed to be self-contained and easily reusable across different parts of an application or even in different projects.\n5.  **State Management**: It's an effective way to manage encapsulated state for specific components or functionalities, similar to how classes manage instance state.",
          "options": [],
          "analysisPoints": [
            "Defines the Module Pattern and its typical structure (IIFE).",
            "Clearly explains the role of closures in maintaining private scope.",
            "Lists and explains multiple advantages of the pattern.",
            "Provides a concise and illustrative code example."
          ],
          "keyConcepts": [
            "module_pattern",
            "closures",
            "IIFE",
            "data_privacy",
            "encapsulation",
            "global_namespace_pollution",
            "design_patterns"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of the Module Pattern.",
            "Accurate description of closure's role.",
            "Thorough articulation of benefits.",
            "Clear example showcasing the pattern."
          ],
          "example": "```javascript\nconst MyModule = (function() {\n  let privateVar = 'secret';\n  function privateMethod() {\n    console.log(privateVar);\n  }\n  return {\n    publicMethod: function() {\n      privateMethod();\n    }\n  };\n})();\nMyModule.publicMethod();\n```",
          "tags": [
            "closures",
            "design_patterns",
            "architecture",
            "encapsulation",
            "open-ended"
          ],
          "prerequisites": [
            "practical_closures",
            "IIFE"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_practical_closures_4",
          "topic": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "level": "medium",
          "type": "code",
          "question": "Implement a `ShoppingCart` module using closures. It should have:\n*   A private array `items` to store products.\n*   A public method `addItem(productName, price)` that adds an item to `items`.\n*   A public method `getTotal()` that calculates and returns the total price of all items.\n*   A public method `getCartItems()` that returns a *copy* of the `items` array to prevent external modification.\n\nDemonstrate its usage.",
          "answer": "```javascript\nfunction createShoppingCart() {\n  let items = []; // Private array\n\n  return {\n    addItem: function(productName, price) {\n      if (typeof productName === 'string' && productName.length > 0 && typeof price === 'number' && price > 0) {\n        items.push({ name: productName, price: price });\n        console.log(`${productName} added to cart.`);\n      } else {\n        console.error('Invalid product name or price.');\n      }\n    },\n    getTotal: function() {\n      return items.reduce((total, item) => total + item.price, 0);\n    },\n    getCartItems: function() {\n      // Return a shallow copy to prevent external modification of the private array\n      return [...items]; \n      // Or: return items.slice();\n    },\n    removeItem: function(productName) {\n        const initialLength = items.length;\n        items = items.filter(item => item.name !== productName);\n        if (items.length < initialLength) {\n            console.log(`${productName} removed from cart.`);\n        } else {\n            console.log(`${productName} not found in cart.`);\n        }\n    }\n  };\n}\n\n// Demonstrate usage:\nconst myCart = createShoppingCart();\n\nmyCart.addItem('Laptop', 1200);\nmyCart.addItem('Mouse', 25);\nmyCart.addItem('Keyboard', 75);\n\nconsole.log('Current items:', myCart.getCartItems()); // Should show Laptop, Mouse, Keyboard\nconsole.log('Total:', myCart.getTotal()); // Expected: 1300\n\n// Attempt to modify the 'private' array externally (should not work on the original)\nconst cartItems = myCart.getCartItems();\ncartItems.push({ name: 'Fake Item', price: 0 });\nconsole.log('Items after external push attempt:', myCart.getCartItems()); // Should NOT show Fake Item\n\nmyCart.removeItem('Mouse');\nconsole.log('Items after removing Mouse:', myCart.getCartItems()); // Should show Laptop, Keyboard\nconsole.log('New Total:', myCart.getTotal()); // Expected: 1275\n\n// Invalid item\nmyCart.addItem('', -10);\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses a `let` variable for `items` to create a private state.",
            "All public methods (`addItem`, `getTotal`, `getCartItems`, `removeItem`) are closures that access this `items` variable.",
            "The `getCartItems` method returns a *copy* of the array, demonstrating proper encapsulation (preventing direct external modification).",
            "Includes basic validation within `addItem`.",
            "Demonstrates the module's usage and verifies data privacy."
          ],
          "keyConcepts": [
            "closures",
            "encapsulation",
            "data_privacy",
            "module_pattern",
            "private_variables",
            "array_methods",
            "shallow_copy"
          ],
          "evaluationCriteria": [
            "Successful implementation of private state.",
            "Correct functionality of all public methods.",
            "Proper handling of data privacy (copying arrays).",
            "Clear demonstration of usage."
          ],
          "example": "This task is a practical application of the module pattern using closures to manage a shopping cart's state, preventing external direct manipulation of its internal `items` array.",
          "tags": [
            "closures",
            "code_challenge",
            "encapsulation",
            "design_patterns",
            "frontend_interview"
          ],
          "prerequisites": [
            "practical_closures",
            "arrays",
            "object_literals"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_advanced_closures_1",
          "topic": "Advanced Closure Patterns (Conceptual Overview)",
          "level": "medium",
          "type": "flashcard",
          "question": "Name two common advanced closure patterns or applications of closures beyond simple data privacy.",
          "answer": "Two common advanced closure patterns are **Memoization** (for caching function results) and **Currying** (for transforming functions into a sequence of functions). Other applications include implementing event handlers and higher-order functions.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "memoization",
            "currying",
            "advanced_closures",
            "higher_order_functions"
          ],
          "evaluationCriteria": [
            "Correct identification of advanced closure patterns."
          ],
          "example": "",
          "tags": [
            "closures",
            "advanced_js",
            "design_patterns"
          ],
          "prerequisites": [
            "advanced_closure_patterns_conceptual"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_advanced_closures_2",
          "topic": "Advanced Closure Patterns (Conceptual Overview)",
          "level": "hard",
          "type": "open",
          "question": "Briefly explain how closures can be used to implement a memoization function. What are the benefits of memoization?",
          "answer": "**How Closures Implement Memoization**: A memoization function uses a closure to maintain a cache (often an object or a Map) of previously computed results. When the memoized function is called with arguments, it first checks this cache. If the result for those arguments is already present, it returns the cached result. If not, it computes the result, stores it in the cache, and then returns it.\n\nThe closure ensures that the cache variable (e.g., `cache` or `memo`) persists across multiple calls to the returned memoized function, making the cached data accessible and mutable only by the memoized function itself.\n\n**Example Sketch (conceptual)**:\n```javascript\nfunction memoize(func) {\n  const cache = {}; // This 'cache' is closed over by the returned function\n\n  return function(...args) {\n    const key = JSON.stringify(args); // Simple key for demonstration\n    if (cache[key]) {\n      console.log('Returning from cache for:', args);\n      return cache[key];\n    } else {\n      console.log('Calculating and caching for:', args);\n      const result = func.apply(this, args);\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n\n// Example usage:\nconst expensiveCalc = (num) => { /* Simulate heavy computation */ return num * num; };\nconst memoizedCalc = memoize(expensiveCalc);\n\nmemoizedCalc(5); // Calculates, caches, returns 25\nmemoizedCalc(5); // Returns 25 from cache\nmemoizedCalc(10); // Calculates, caches, returns 100\nmemoizedCalc(10); // Returns 100 from cache\n```\n\n**Benefits of Memoization**:\n\n1.  **Performance Optimization**: Significantly improves performance for 'pure' functions (functions that produce the same output for the same input and have no side effects) by avoiding redundant and computationally expensive calculations.\n2.  **Reduced Resource Usage**: Can reduce CPU cycles and sometimes memory usage (if the original computation involves heavy data manipulation) by reusing previous results.\n3.  **Predictability**: For idempotent functions, memoization ensures consistent results and behavior.\n\nIt's commonly used in dynamic programming, recursive algorithms, and rendering optimizations in UI frameworks (like React's `useMemo` hook, which uses a similar principle).",
          "options": [],
          "analysisPoints": [
            "Explains the role of the cache within the closure.",
            "Outlines the memoization logic (check cache, compute, store).",
            "Provides a conceptual code sketch.",
            "Lists and explains key benefits of memoization."
          ],
          "keyConcepts": [
            "memoization",
            "closures",
            "performance_optimization",
            "caching",
            "pure_functions",
            "higher_order_functions"
          ],
          "evaluationCriteria": [
            "Clear explanation of how closures enable memoization.",
            "Identification of `cache` as the closed-over variable.",
            "Accurate description of memoization benefits.",
            "Conceptual code example is helpful."
          ],
          "example": "```javascript\nfunction memoize(func) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache[key]) return cache[key];\n    const result = func.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n```",
          "tags": [
            "closures",
            "memoization",
            "performance",
            "optimization",
            "open-ended",
            "advanced_js"
          ],
          "prerequisites": [
            "advanced_closure_patterns_conceptual",
            "closures_basics",
            "higher_order_functions"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_object_getters_setters_1",
          "title": "Implement a `TemperatureConverter` Object with Getters and Setters",
          "description": "\nCreate a JavaScript object `temperatureConverter` that manages temperature in both Celsius and Fahrenheit.\n\nRequirements:\n1.  It should have an internal private-like property (e.g., `_celsius`) to store the temperature in Celsius.\n2.  Implement a `celsius` getter that returns the current temperature in Celsius.\n3.  Implement a `celsius` setter that takes a Celsius value, updates `_celsius`, and validates that the input is a number.\n4.  Implement a `fahrenheit` getter that calculates and returns the temperature in Fahrenheit based on `_celsius`.\n5.  Implement a `fahrenheit` setter that takes a Fahrenheit value, converts it to Celsius, and updates `_celsius`, also validating the input.\n\nConversion formulas:\n*   Celsius to Fahrenheit: `F = C * 9/5 + 32`\n*   Fahrenheit to Celsius: `C = (F - 32) * 5/9`\n",
          "difficulty": "medium",
          "startingCode": "const temperatureConverter = {\n  _celsius: 0, // Internal storage for Celsius\n\n  // Getter for Celsius\n  get celsius() {\n    // TODO: Implement getter for _celsius\n  },\n\n  // Setter for Celsius\n  set celsius(value) {\n    // TODO: Implement setter with number validation\n  },\n\n  // Getter for Fahrenheit\n  get fahrenheit() {\n    // TODO: Calculate and return Fahrenheit from _celsius\n  },\n\n  // Setter for Fahrenheit\n  set fahrenheit(value) {\n    // TODO: Convert Fahrenheit to Celsius and update _celsius, with validation\n  }\n};\n\n// --- Test Cases (You can uncomment and use these) ---\n// temperatureConverter.celsius = 25;\n// console.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 25\n// console.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 77\n\n// temperatureConverter.fahrenheit = 32;\n// console.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 0\n// console.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 32\n\n// temperatureConverter.celsius = 'abc'; // Should log validation error or handle gracefully\n// console.log(`Celsius after invalid set: ${temperatureConverter.celsius}`); // Should remain previous valid value\n",
          "solutionCode": "const temperatureConverter = {\n  _celsius: 0, // Internal storage for Celsius\n\n  get celsius() {\n    return this._celsius;\n  },\n\n  set celsius(value) {\n    if (typeof value === 'number') {\n      this._celsius = value;\n    } else {\n      console.error('Invalid input: Celsius value must be a number.');\n    }\n  },\n\n  get fahrenheit() {\n    return (this._celsius * 9/5) + 32;\n  },\n\n  set fahrenheit(value) {\n    if (typeof value === 'number') {\n      this._celsius = (value - 32) * 5/9;\n    } else {\n      console.error('Invalid input: Fahrenheit value must be a number.');\n    }\n  }\n};\n\n// Test Cases:\nconsole.log('--- Initial State ---');\nconsole.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 0\nconsole.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 32\n\nconsole.log('\\n--- Setting Celsius to 25 ---');\ntemperatureConverter.celsius = 25;\nconsole.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 25\nconsole.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 77\n\nconsole.log('\\n--- Setting Fahrenheit to 32 (freezing point) ---');\ntemperatureConverter.fahrenheit = 32;\nconsole.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 0\nconsole.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 32\n\nconsole.log('\\n--- Setting Celsius to 100 (boiling point) ---');\ntemperatureConverter.celsius = 100;\nconsole.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 100\nconsole.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 212\n\nconsole.log('\\n--- Attempting invalid Celsius set ---');\ntemperatureConverter.celsius = 'abc'; // Should log validation error\nconsole.log(`Celsius after invalid set: ${temperatureConverter.celsius}`); // Should remain 100\n\nconsole.log('\\n--- Attempting invalid Fahrenheit set ---');\ntemperatureConverter.fahrenheit = null; // Should log validation error\nconsole.log(`Fahrenheit after invalid set: ${temperatureConverter.fahrenheit}`); // Should calculate from 100C -> 212F\n",
          "testCases": [
            "Initial state: `celsius` should be 0, `fahrenheit` should be 32.",
            "Set `celsius` to 25: `celsius` should be 25, `fahrenheit` should be 77.",
            "Set `fahrenheit` to 32: `celsius` should be 0, `fahrenheit` should be 32.",
            "Set `celsius` to 100: `celsius` should be 100, `fahrenheit` should be 212.",
            "Attempt to set `celsius` with a non-numeric value (e.g., `'abc'`): It should handle gracefully (e.g., log an error) and `_celsius` should not change.",
            "Attempt to set `fahrenheit` with a non-numeric value (e.g., `null`): It should handle gracefully and `_celsius` should not change."
          ],
          "hints": [
            "Remember that `this` inside a getter/setter refers to the object itself.",
            "The internal `_celsius` property is a convention for indicating it's not meant for direct external manipulation, but it's still publicly accessible. This is the closest you get to 'private' properties in standard JS objects without closures or private class fields.",
            "For Fahrenheit conversion, ensure you perform the operation correctly `(F - 32) * 5 / 9` for Celsius conversion and `C * 9 / 5 + 32` for Fahrenheit conversion.",
            "Use `typeof` to validate if the input `value` is a `number`."
          ],
          "tags": [
            "getters",
            "setters",
            "objects",
            "data_transformation",
            "validation"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "object_getters_setters",
            "javascript_operators"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "data_encapsulation",
            "computed_properties",
            "object_modeling"
          ]
        },
        {
          "id": "task_equality_1",
          "title": "Implement a Flexible Equality Checker",
          "description": "\nCreate a JavaScript function `areEqual(a, b, strict)` that compares two values `a` and `b`.\n\nRequirements:\n1.  If the `strict` argument is `true`, it should use strict equality (`===`).\n2.  If the `strict` argument is `false`, it should use loose equality (`==`).\n3.  If `a` or `b` are objects (excluding `null`), and `strict` is `true`, special handling is required:\n    *   For arrays, perform a deep comparison (same length, all elements strictly equal). Handle nested arrays recursively.\n    *   For plain objects, perform a deep comparison (same keys, same values strictly equal for primitives, recursively for nested objects/arrays). Order of keys does not matter.\n4.  If `a` or `b` are `NaN`, it should correctly return `true` if both are `NaN` (as `NaN === NaN` is false, you'll need `Number.isNaN`).\n\nThis task requires you to build a more robust equality checker that goes beyond simple `==` and `===` for complex types, especially in strict mode.\n",
          "difficulty": "hard",
          "startingCode": "function areEqual(a, b, strict) {\n  if (strict) {\n    // TODO: Implement strict equality with deep comparison for objects/arrays and NaN handling\n  } else {\n    // TODO: Implement loose equality\n  }\n}\n\n// --- Test Cases (You can uncomment and use these) ---\n// console.log(areEqual(1, '1', false));          // Expected: true\n// console.log(areEqual(1, '1', true));           // Expected: false\n// console.log(areEqual(null, undefined, false)); // Expected: true\n// console.log(areEqual(null, undefined, true));  // Expected: false\n// console.log(areEqual(0, false, false));        // Expected: true\n// console.log(areEqual(0, false, true));         // Expected: false\n\n// console.log(areEqual([1, 2], [1, 2], true));            // Expected: true\n// console.log(areEqual([1, 2, [3, 4]], [1, 2, [3, 4]], true)); // Expected: true\n// console.log(areEqual([1, 2, [3, 4]], [1, 2, [3, '4']], true)); // Expected: false (due to '4')\n\n// console.log(areEqual({ a: 1, b: 2 }, { a: 1, b: 2 }, true)); // Expected: true\n// console.log(areEqual({ a: 1, b: { c: 3 } }, { a: 1, b: { c: 3 } }, true)); // Expected: true\n// console.log(areEqual({ b: 2, a: 1 }, { a: 1, b: 2 }, true)); // Expected: true (order doesn't matter)\n\n// console.log(areEqual(NaN, NaN, true));           // Expected: true\n// console.log(areEqual(NaN, 5, true));             // Expected: false\n",
          "solutionCode": "function areEqual(a, b, strict) {\n  // Handle NaN case first for strict comparison\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  }\n\n  if (strict) {\n    // Strict comparison for primitives and simple types\n    if (a === b) {\n      return true;\n    }\n\n    // Handle null explicitly, as typeof null is 'object'\n    if (a === null || b === null) {\n        return false; // Already handled null === null by a === b\n    }\n\n    // Deep comparison for objects and arrays\n    if (typeof a === 'object' && typeof b === 'object') {\n      // Array comparison\n      if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          // Recursively call areEqual for elements (deep comparison)\n          if (!areEqual(a[i], b[i], true)) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      // Plain object comparison\n      if (!Array.isArray(a) && !Array.isArray(b)) {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n\n        if (keysA.length !== keysB.length) {\n          return false;\n        }\n\n        for (let key of keysA) {\n          if (!keysB.includes(key) || !areEqual(a[key], b[key], true)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    \n    return false; // Default for strict if types or values don't match after specific checks\n\n  } else {\n    // Loose comparison for all types\n    return a == b;\n  }\n}\n\n// Test Cases:\nconsole.log('--- Loose Equality ---');\nconsole.log(`1 == '1' (false): ${areEqual(1, '1', false)}`);           // Expected: true\nconsole.log(`null == undefined (false): ${areEqual(null, undefined, false)}`); // Expected: true\nconsole.log(`0 == false (false): ${areEqual(0, false, false)}`);         // Expected: true\nconsole.log(`[] == 0 (false): ${areEqual([], 0, false)}`);             // Expected: true\nconsole.log(`{} == {} (false): ${areEqual({}, {}, false)}`);          // Expected: false (reference)\n\nconsole.log('\\n--- Strict Equality ---');\nconsole.log(`1 === '1' (true): ${areEqual(1, '1', true)}`);           // Expected: false\nconsole.log(`null === undefined (true): ${areEqual(null, undefined, true)}`); // Expected: false\nconsole.log(`0 === false (true): ${areEqual(0, false, true)}`);         // Expected: false\nconsole.log(`[] === [] (true): ${areEqual([], [], true)}`);             // Expected: true (deep, array)\nconsole.log(`{} === {} (true): ${areEqual({}, {}, true)}`);             // Expected: true (deep, object)\nconsole.log(`NaN === NaN (true): ${areEqual(NaN, NaN, true)}`);           // Expected: true (special NaN handling)\n\nconsole.log('\\n--- Strict Deep Array Equality ---');\nconsole.log(`[1, 2] vs [1, 2]: ${areEqual([1, 2], [1, 2], true)}`);           // Expected: true\nconsole.log(`[1, 2, [3, 4]] vs [1, 2, [3, 4]]: ${areEqual([1, 2, [3, 4]], [1, 2, [3, 4]], true)}`); // Expected: true\nconsole.log(`[1, 2, [3, 4]] vs [1, 2, [3, '4']]: ${areEqual([1, 2, [3, 4]], [1, 2, [3, '4']], true)}`); // Expected: false (type mismatch '4' vs 4)\nconsole.log(`[1, 2] vs [1, '2']: ${areEqual([1, 2], [1, '2'], true)}`);       // Expected: false (type mismatch '2' vs 2)\n\nconsole.log('\\n--- Strict Deep Object Equality ---');\nconsole.log(`{ a: 1, b: 2 } vs { a: 1, b: 2 }: ${areEqual({ a: 1, b: 2 }, { a: 1, b: 2 }, true)}`); // Expected: true\nconsole.log(`{ a: 1, b: { c: 3 } } vs { a: 1, b: { c: 3 } }: ${areEqual({ a: 1, b: { c: 3 } }, { a: 1, b: { c: 3 } }, true)}`); // Expected: true\nconsole.log(`{ b: 2, a: 1 } vs { a: 1, b: 2 }: ${areEqual({ b: 2, a: 1 }, { a: 1, b: 2 }, true)}`); // Expected: true (key order doesn't matter)\nconsole.log(`{ a: 1 } vs { a: '1' }: ${areEqual({ a: 1 }, { a: '1' }, true)}`); // Expected: false (type mismatch)\nconsole.log(`{ a: 1, b: [2] } vs { a: 1, b: [2] }: ${areEqual({ a: 1, b: [2] }, { a: 1, b: [2] }, true)}`); // Expected: true (nested array)\n",
          "testCases": [
            "Loose equality: `areEqual(1, '1', false)` should be `true`.",
            "Strict equality: `areEqual(1, '1', true)` should be `false`.",
            "Loose equality: `areEqual(null, undefined, false)` should be `true`.",
            "Strict equality: `areEqual(null, undefined, true)` should be `false`.",
            "Loose equality: `areEqual(0, false, false)` should be `true`.",
            "Strict equality: `areEqual(0, false, true)` should be `false`.",
            "`NaN` handling: `areEqual(NaN, NaN, true)` should be `true`.",
            "Deep array equality: `areEqual([1, 2, [3, 4]], [1, 2, [3, 4]], true)` should be `true`.",
            "Deep array inequality (different value type): `areEqual([1, 2, [3, 4]], [1, 2, [3, '4']], true)` should be `false`.",
            "Deep object equality: `areEqual({ a: 1, b: { c: 3 } }, { a: 1, b: { c: 3 } }, true)` should be `true`.",
            "Deep object equality (different key order): `areEqual({ b: 2, a: 1 }, { a: 1, b: 2 }, true)` should be `true`.",
            "Deep object inequality (different value type): `areEqual({ a: 1 }, { a: '1' }, true)` should be `false`."
          ],
          "hints": [
            "For `NaN` comparison, remember `Number.isNaN()`.",
            "For deep comparison of arrays and objects, you will need to use recursion.",
            "For object deep comparison, iterate over keys using `Object.keys()` and check if all keys exist in both objects and if their corresponding values are equal (recursively).",
            "Be careful with `typeof null` returning 'object'. Check for `null` explicitly before proceeding with object/array checks.",
            "Remember that `Object.keys()` doesn't guarantee order, so check for key existence in both directions or rely on `keysA.length === keysB.length` and then `keysB.includes(key)` for each key in `keysA`."
          ],
          "tags": [
            "equality",
            "deep_comparison",
            "recursion",
            "algorithms",
            "data_structures",
            "frontend_interview"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "equality_comparison",
            "strict_vs_loose_equality_deep_dive",
            "recursion",
            "arrays",
            "objects"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "utility_functions",
            "immutable_data",
            "testing"
          ]
        },
        {
          "id": "task_closures_basic_1",
          "title": "Create a Simple Logger Factory",
          "description": "\nImplement a JavaScript function `createLogger(prefix)` that acts as a factory for logger functions. The returned logger function should take a `message` and log it to the console, prefixed by the `prefix` provided when the logger was created.\n\nRequirements:\n1.  `createLogger` should accept a `prefix` string.\n2.  It should return a new function (the logger).\n3.  The returned logger function should take a `message` string.\n4.  The logger function should use the `prefix` (closed over) and the `message` to log `[PREFIX] message` to the console.\n\nDemonstrate by creating two different loggers, `infoLogger` (prefix 'INFO') and `errorLogger` (prefix 'ERROR'), and use them to log various messages.\n",
          "difficulty": "easy",
          "startingCode": "function createLogger(prefix) {\n  // TODO: Implement the logger factory using a closure\n  return function(message) {\n    // Log the message with the prefix\n  };\n}\n\n// --- Test Cases (You can uncomment and use these) ---\n// const infoLogger = createLogger('INFO');\n// const errorLogger = createLogger('ERROR');\n\n// infoLogger('Application started successfully.'); // Expected: [INFO] Application started successfully.\n// errorLogger('Failed to connect to database.'); // Expected: [ERROR] Failed to connect to database.\n",
          "solutionCode": "function createLogger(prefix) {\n  // The 'prefix' variable is part of the lexical environment\n  // that the returned function will close over.\n  return function(message) {\n    console.log(`[${prefix}] ${message}`);\n  };\n}\n\n// Demonstrate by creating two different loggers:\nconst infoLogger = createLogger('INFO');\nconst errorLogger = createLogger('ERROR');\nconst debugLogger = createLogger('DEBUG');\n\n// Use the loggers to log various messages:\nconsole.log('--- Info Messages ---');\ninfoLogger('User logged in successfully.');\ninfoLogger('Data fetched from API.');\n\nconsole.log('\\n--- Error Messages ---');\nerrorLogger('Failed to parse configuration file.');\nerrorLogger('Network timeout occurred.');\n\nconsole.log('\\n--- Debug Messages ---');\ndebugLogger('Variable x: 10');\ndebugLogger('Function foo called with arg: bar');\n",
          "testCases": [
            "Create `infoLogger` with prefix 'INFO' and log 'System ready.'. Expected: `[INFO] System ready.`",
            "Create `errorLogger` with prefix 'ERROR' and log 'Data corruption detected.'. Expected: `[ERROR] Data corruption detected.`",
            "Verify that `infoLogger` and `errorLogger` maintain independent prefixes.",
            "Log a message with an empty prefix string: `createLogger('')('Test')` should log `[] Test`."
          ],
          "hints": [
            "The inner function needs to 'remember' the `prefix` value passed to the `createLogger` function.",
            "Use template literals (backticks `` ` ``) for easy string interpolation."
          ],
          "tags": [
            "closures",
            "function_factory",
            "logging",
            "javascript_basics"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "closures_basics",
            "javascript_functions"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "higher_order_functions",
            "functional_programming"
          ]
        },
        {
          "id": "task_closures_advanced_1",
          "title": "Build a Simple EventEmitter with Closures",
          "description": "\nImplement a `createEventEmitter` function that returns an object acting as a simple event emitter. This emitter should allow functions to 'subscribe' to events and 'publish' events.\n\nRequirements:\n1.  The `createEventEmitter` function should have a private data structure (e.g., a `Map` or an object) to store event listeners. This structure should be accessible only via closures.\n2.  The returned object should expose two public methods:\n    *   `on(eventName, listener)`: Registers a `listener` function for a given `eventName`.\n    *   `emit(eventName, ...args)`: Calls all `listener` functions registered for the `eventName`, passing any additional arguments.\n3.  Ensure that `listener` functions are called with the correct `this` context (if applicable, though typically not strictly required for simple event emitters, `null` or `undefined` is fine, or explicitly bind). For this task, `this` context for listeners is not critical, just ensure arguments are passed.\n\nDemonstrate its usage by creating an emitter, registering listeners for different events, and then emitting those events.\n",
          "difficulty": "hard",
          "startingCode": "function createEventEmitter() {\n  const listeners = {}; // Private store for listeners. Example: { 'eventName': [func1, func2] }\n\n  return {\n    on: function(eventName, listener) {\n      // TODO: Implement event registration\n    },\n    emit: function(eventName, ...args) {\n      // TODO: Implement event publishing\n    }\n  };\n}\n\n// --- Test Cases (You can uncomment and use these) ---\n// const emitter = createEventEmitter();\n\n// emitter.on('userLoggedIn', (username) => {\n//   console.log(`User ${username} logged in!`);\n// });\n\n// emitter.on('dataReceived', (data) => {\n//   console.log('Received data:', data);\n// });\n\n// emitter.emit('userLoggedIn', 'Alice'); // Expected: User Alice logged in!\n// emitter.emit('dataReceived', { id: 1, value: 'test' }); // Expected: Received data: { id: 1, value: 'test' }\n// emitter.emit('unknownEvent'); // Should do nothing or handle gracefully\n",
          "solutionCode": "function createEventEmitter() {\n  // `listeners` is a private variable, encapsulated by the closure.\n  // It stores events as keys and arrays of listener functions as values.\n  const listeners = {}; \n\n  return {\n    /**\n     * Registers a listener function for a specific event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} listener - The function to call when the event is emitted.\n     */\n    on: function(eventName, listener) {\n      if (typeof listener !== 'function') {\n        console.error('Listener must be a function.');\n        return;\n      }\n      if (!listeners[eventName]) {\n        listeners[eventName] = [];\n      }\n      listeners[eventName].push(listener);\n      console.log(`Listener added for event: ${eventName}`);\n    },\n\n    /**\n     * Emits an event, calling all registered listeners with provided arguments.\n     * @param {string} eventName - The name of the event to emit.\n     * @param {...any} args - Arguments to pass to the listeners.\n     */\n    emit: function(eventName, ...args) {\n      const eventListeners = listeners[eventName];\n      if (eventListeners) {\n        console.log(`Emitting event: ${eventName} with args:`, args);\n        eventListeners.forEach(listener => {\n          listener(...args);\n        });\n      } else {\n        console.log(`No listeners registered for event: ${eventName}`);\n      }\n    },\n\n    /**\n     * (Optional, but good for completeness): Removes a specific listener for an event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} listenerToRemove - The specific listener function to remove.\n     */\n    off: function(eventName, listenerToRemove) {\n        if (listeners[eventName]) {\n            listeners[eventName] = listeners[eventName].filter(listener => listener !== listenerToRemove);\n            console.log(`Listener removed for event: ${eventName}`);\n        }\n    }\n  };\n}\n\n// Demonstrate usage:\nconst myEmitter = createEventEmitter();\n\n// Register listeners\nconst welcomeListener = (username) => {\n  console.log(`Welcome, ${username}!`);\n};\n\nconst notifyAdminListener = (username) => {\n  console.log(`Admin notified: ${username} logged in.`);\n};\n\nmyEmitter.on('userLoggedIn', welcomeListener);\nmyEmitter.on('userLoggedIn', notifyAdminListener);\n\nmyEmitter.on('paymentSuccessful', (amount, user) => {\n  console.log(`Payment of $${amount} successful for ${user}.`);\n});\n\n// Emit events\nconsole.log('\\n--- Emitting userLoggedIn ---');\nmyEmitter.emit('userLoggedIn', 'Alice');\n\nconsole.log('\\n--- Emitting paymentSuccessful ---');\nmyEmitter.emit('paymentSuccessful', 99.99, 'Bob');\n\nconsole.log('\\n--- Emitting unknown event ---');\nmyEmitter.emit('orderPlaced'); // No listeners, should log accordingly\n\nconsole.log('\\n--- Removing a listener ---');\nmyEmitter.off('userLoggedIn', notifyAdminListener);\n\nconsole.log('\\n--- Emitting userLoggedIn again after removal ---');\nmyEmitter.emit('userLoggedIn', 'Charlie'); // Only Welcome, Charlie! should be logged\n",
          "testCases": [
            "Register a listener for 'testEvent' and emit it with a message. Verify the listener is called with the message.",
            "Register multiple listeners for the same event and ensure all are called.",
            "Emit an event for which no listeners are registered. Ensure it handles gracefully (e.g., no errors, optional console message).",
            "Test with different types of arguments for `emit` (numbers, objects).",
            "Optional: Implement an `off` method to unsubscribe listeners and test it."
          ],
          "hints": [
            "Use an object or a `Map` to store listeners where keys are event names and values are arrays of functions.",
            "When `emit` is called, iterate through the array of listeners for that event and call each function.",
            "The rest parameter `...args` can be very useful for `emit` to pass variable arguments to listeners.",
            "Consider edge cases: what if no listeners for an event? What if `listener` is not a function?"
          ],
          "tags": [
            "closures",
            "event_emitter",
            "design_patterns",
            "data_privacy",
            "frontend_interview",
            "event_handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "practical_closures",
            "arrays",
            "objects",
            "functions",
            "rest_parameters"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "pub_sub_pattern",
            "observers",
            "custom_events",
            "asynchronous_javascript"
          ]
        }
      ]
    }
  },
  {
    "id": "89dacb29-049f-4c79-ab08-6c3bbbe8ea1f",
    "startLine": 2300,
    "endLine": 2399,
    "processedDate": "2025-06-17T08:19:53.789Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_currying",
          "title": "Currying and Partial Application",
          "content": "Currying is a functional programming technique where a function that takes multiple arguments is transformed into a sequence of functions, each taking a single argument. This transformation allows for partial application, where you fix a certain number of arguments to a function, producing another function with fewer arguments.\n\n## Key Concepts\n-   **Transformation**: A function `f(a, b, c)` becomes `f(a)(b)(c)`. Each nested function returns another function until all arguments are received, and then the final result is computed.\n-   **Closures**: Currying heavily relies on closures. Each inner function 'remembers' the arguments passed to its outer function's scope, even after the outer function has finished execution.\n-   **Partial Application**: A specific application of currying where you fix some arguments of a function, creating a new, specialized function. For example, if you have a `sum(a, b)` function and you curry it, you can create `addFive = sum(5)` which is a new function that always adds 5 to its argument.\n\n## Benefits\n-   **Reusability**: Create specialized, reusable functions from more general ones.\n-   **Function Composition**: Curried functions are easier to compose, as each function typically expects a single argument, fitting nicely into a pipeline of operations.\n-   **Readability**: Can sometimes make code more declarative and easier to understand, especially when creating specific versions of general-purpose functions.",
          "examples": [
            {
              "id": "example_currying_1",
              "title": "Simple Currying Example",
              "code": "function sum(a) {\n  return function(b) {\n    return a + b;\n  };\n}\n\nconsole.log(sum(1)(2)); // Output: 3\nconsole.log(sum(5)(-1)); // Output: 4",
              "explanation": "This example shows `sum` as a curried function. `sum(a)` returns an anonymous function that captures `a` in its closure. When this inner function is called with `b`, it can access `a` and perform the addition. This demonstrates the core mechanism of currying using closures.",
              "language": "javascript"
            },
            {
              "id": "example_currying_2",
              "title": "Practical Use Case: Partial Application for Discount Calculation",
              "code": "function discount(price) {\n  return function(percentage) {\n    return price * (1 - percentage / 100);\n  };\n}\n\n// Create a specialized function for a specific price\nconst tenPercentDiscountOn100 = discount(100);\nconsole.log(tenPercentDiscountOn100(10)); // Output: 90 (10% off 100)\nconsole.log(tenPercentDiscountOn100(20)); // Output: 80 (20% off 100)\n\n// Or, create a specialized function for a specific percentage\nfunction calculatePriceWithDiscount(percentage) {\n  return function(price) {\n    return price * (1 - percentage / 100);\n  };\n}\n\nconst twentyPercentOff = calculatePriceWithDiscount(20);\nconsole.log(twentyPercentOff(200)); // Output: 160 (20% off 200)\nconsole.log(twentyPercentOff(50));  // Output: 40 (20% off 50)",
              "explanation": "Here, the `discount` function is curried. By calling `discount(100)`, we create `tenPercentDiscountOn100`, which is a new function that always applies a discount to an initial price of 100. This is a clear example of partial application, allowing us to reuse the `discount` logic for a fixed `price` while varying the `percentage`. The second part of the example shows another way to partially apply, fixing the `percentage` first.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_currying_1",
            "question_currying_2",
            "question_currying_3",
            "question_currying_4",
            "question_currying_5"
          ],
          "relatedTasks": [
            "task_currying_1",
            "task_currying_2"
          ],
          "tags": [
            "functional-programming",
            "closures",
            "currying",
            "partial-application",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures",
            "functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced-functional-programming",
            "lodash-familiarity"
          ]
        },
        {
          "id": "theory_debounce",
          "title": "Debounce Implementation with Closures",
          "content": "Debouncing is a widely used technique in frontend development to control how often a function is executed. It ensures that a function is not called too frequently, particularly for events that fire rapidly (e.g., `keyup` on an input field, `resize` on a window, `scroll` events). The core idea is to delay the execution of a function until a certain amount of time has passed without any new events triggering it.\n\n## How Debounce Works\n1.  **Delay Execution**: When the debounced function is called, it doesn't execute immediately.\n2.  **Timer Management**: Instead, it sets a timer (using `setTimeout`).\n3.  **Reset on Subsequent Calls**: If the debounced function is called again *before* the timer expires, the previous timer is cleared (using `clearTimeout`), and a new timer is set. This effectively 'resets' the countdown.\n4.  **Execute on Inactivity**: The actual function (`fn`) only executes if no new calls to the debounced function occur within the specified `ms` delay.\n\n## Role of Closures\nClosures are crucial for debounce implementations. The `timer` variable is declared in the outer `debounce` function's scope and is captured by the returned inner function. This allows the inner function to maintain and manage the `timer` state across multiple invocations, ensuring that `clearTimeout` can always access and clear the *correct* previous timer ID.\n\n## Handling Context and Arguments\n-   `this` context: When the debounced function is called, it might be called in a specific context (e.g., `this` referring to a DOM element). To preserve this context for the original function `fn`, `fn.apply(this, args)` is typically used. `this` inside the returned function refers to the context in which the debounced function was called.\n-   Arguments: Similarly, any arguments passed to the debounced function need to be forwarded to the original function `fn`. This is achieved using the rest parameter `...args` and spreading them with `apply`.",
          "examples": [
            {
              "id": "example_debounce_1",
              "title": "Basic Debounce Implementation",
              "code": "function debounce(fn, ms) {\n  let timer = null; // 'timer' is captured by the closure\n  \n  return function(...args) {\n    const context = this; // Capture 'this' context\n\n    if (timer) {\n      clearTimeout(timer);\n    }\n    \n    timer = setTimeout(() => {\n      fn.apply(context, args); // Apply captured 'this' and arguments\n      timer = null; // Reset timer after execution (optional, but good practice)\n    }, ms);\n  };\n}\n\n// Usage example\nfunction handleSearch(query) {\n  console.log(`Searching for: ${query}`);\n  // Expensive API call would go here, e.g., fetch(`/api/search?q=${query}`)\n}\n\nconst debouncedSearch = debounce(handleSearch, 500);\n\nconsole.log('Typing simulation:');\ndebouncedSearch(\"a\");\ndebouncedSearch(\"ap\");\ndebouncedSearch(\"app\"); // Only this call will execute after 500ms of inactivity\n\n// To demonstrate the 500ms delay and final execution\nsetTimeout(() => {\n  debouncedSearch(\"apple\"); \n  console.log('--- 1 sec delay, then new search ---');\n}, 1000);",
              "explanation": "This code demonstrates the standard debounce implementation. The `timer` variable is created in the outer `debounce` scope and persists via closure. Each time `debouncedSearch` is called, it clears any pending `timer` and sets a new one. The `handleSearch` function (`fn`) is only invoked if the `ms` duration passes without another call to `debouncedSearch`. `fn.apply(context, args)` ensures that `handleSearch` receives the correct `this` context and arguments.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_debounce_1",
            "question_debounce_2",
            "question_debounce_3",
            "question_debounce_4",
            "question_debounce_5"
          ],
          "relatedTasks": [
            "task_debounce_1",
            "task_debounce_2"
          ],
          "tags": [
            "performance",
            "event-handling",
            "closures",
            "debounce",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures",
            "setTimeout",
            "clearTimeout",
            "this-keyword",
            "function.apply"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "frontend-performance-optimization",
            "react-hooks"
          ]
        },
        {
          "id": "theory_module_pattern",
          "title": "Module Pattern with Closures",
          "content": "The Module Pattern is a design pattern used in JavaScript to achieve encapsulation and create private state. It leverages closures to define private variables and functions that are not accessible from the outside, while exposing a public interface through a returned object.\n\n## Key Concepts\n-   **Immediately Invoked Function Expression (IIFE)**: The module pattern typically uses an IIFE `(function(){...})()` to create a private scope. Variables and functions defined within this IIFE are local to it.\n-   **Closures for Privacy**: Any variables or functions declared inside the IIFE but *not* returned in the public interface become private. The functions that *are* returned (the public interface) form closures over these private members, allowing them to access and modify the private state.\n-   **Public Interface**: The IIFE returns an object containing the public methods and properties that are accessible from outside the module. These public methods are the only way to interact with the module's internal (private) state.\n\n## Advantages\n-   **Encapsulation**: Hides internal implementation details and state, preventing accidental modification from external code.\n-   **Prevent Global Namespace Pollution**: All module-specific variables are contained within the IIFE's scope, avoiding the creation of global variables.\n-   **Maintainability**: Code is organized into self-contained units, making it easier to manage and debug.\n-   **Information Hiding**: Only expose what is necessary for external interaction.",
          "examples": [
            {
              "id": "example_module_pattern_1",
              "title": "Counter Module",
              "code": "const Counter = (function() {\n  // Private variables and functions\n  let privateCounter = 0; // This variable is private\n  \n  function changeBy(val) { // This function is private\n    privateCounter += val;\n  }\n  \n  // Public interface: returned object\n  return {\n    increment: function() {\n      changeBy(1); // Public method accesses private function\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCounter; // Public method accesses private variable\n    }\n  };\n})();\n\nCounter.increment();\nCounter.increment();\nconsole.log(Counter.value()); // Output: 2\nCounter.decrement();\nconsole.log(Counter.value()); // Output: 1\n\n// Attempting to access private members directly will fail:\n// console.log(Counter.privateCounter); // Undefined\n// Counter.changeBy(10); // Error: Counter.changeBy is not a function",
              "explanation": "This `Counter` module showcases the module pattern. `privateCounter` and `changeBy` are defined inside an IIFE, making them private. The returned object exposes `increment`, `decrement`, and `value` as public methods. These public methods form closures over the private members, allowing them to modify and read `privateCounter` without exposing it directly to the outside world.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_module_pattern_1",
            "question_module_pattern_2",
            "question_module_pattern_3",
            "question_module_pattern_4",
            "question_module_pattern_5"
          ],
          "relatedTasks": [
            "task_module_pattern_1",
            "task_module_pattern_2"
          ],
          "tags": [
            "design-patterns",
            "closures",
            "encapsulation",
            "privacy",
            "iife",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures",
            "iife",
            "objects"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "architectural-design",
            "javascript-design-patterns"
          ]
        },
        {
          "id": "theory_pure_functions_closures",
          "title": "Pure Functions and Closures",
          "content": "While closures enable many powerful patterns like currying, debouncing, and modules, it's important to understand how they relate to the concept of **pure functions**.\n\n## Pure Functions\nA pure function is a function that:\n1.  **Given the same input, always returns the same output.** (Determinism)\n2.  **Produces no side effects.** It doesn't modify any external state, nor does it perform I/O operations (like writing to console, making network requests, or modifying DOM).\n\nPure functions are highly desirable because they are:\n-   **Predictable**: Easy to reason about.\n-   **Testable**: Outputs are predictable for given inputs.\n-   **Composable**: Can be combined reliably without unexpected interactions.\n\n## Closures and Purity\nClosures can interact with pure functions in a few ways:\n\n-   **Enabling Purity**: A closure can capture *immutable* data from its lexical environment and use it to produce a new pure function. For example, a function factory that creates specialized pure functions.\n-   **Breaking Purity**: If a closure captures *mutable* state from its lexical environment and then modifies that state, the function (or the outer function that produces it) is no longer pure because it produces a side effect (modifying external state) or its output depends on mutable external state.\n\nIt's crucial to understand that a function that returns a closure can still be pure if the returned closure itself adheres to the pure function principles (no side effects, deterministic). However, often closures are used precisely to maintain state or manage side effects, which inherently makes the overall operation impure.",
          "examples": [
            {
              "id": "example_pure_functions_closures_1",
              "title": "Pure Function Returning a Closure (Pure Scenario)",
              "code": "function createMultiplier(factor) {\n  // The outer function is pure: given a factor, it always returns the same inner function\n  return function(number) {\n    // The inner function (closure) is also pure: \n    // - depends only on its arguments (number) and captured immutable state (factor)\n    // - produces no side effects\n    return number * factor;\n  };\n}\n\nconst multiplyByTwo = createMultiplier(2);\nconsole.log(multiplyByTwo(5)); // Output: 10\nconsole.log(multiplyByTwo(5)); // Output: 10 (always same output for same input)\n\nconst multiplyByThree = createMultiplier(3);\nconsole.log(multiplyByThree(4)); // Output: 12",
              "explanation": "In this example, `createMultiplier` is a pure function. It takes a `factor` and returns a new function (a closure). The returned inner function is also pure because it always returns the same output for the same input (`number` and captured `factor`), and it causes no side effects. The captured `factor` is treated as immutable within the closure's calculation.",
              "language": "javascript"
            },
            {
              "id": "example_pure_functions_closures_2",
              "title": "Closure Breaking Purity (Impure Scenario)",
              "code": "let totalSum = 0; // External, mutable state\n\nfunction createAccumulator() {\n  return function(value) {\n    totalSum += value; // Side effect: modifying external state\n    return totalSum;\n  };\n}\n\nconst accumulator = createAccumulator();\nconsole.log(accumulator(5)); // Output: 5 (totalSum is 5)\nconsole.log(accumulator(10)); // Output: 15 (totalSum is 15)\nconsole.log(accumulator(5)); // Output: 20 (not 5, because totalSum changed externally)",
              "explanation": "Here, `createAccumulator` returns a closure. However, the returned closure is *not* pure because it modifies the `totalSum` variable, which is external state (a side effect). This means calling `accumulator(5)` twice does not always return `5`; its output depends on the accumulated `totalSum`, which changes with each call, violating the determinism principle of pure functions.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_pure_functions_1",
            "question_pure_functions_2",
            "question_pure_functions_3",
            "question_pure_functions_4"
          ],
          "relatedTasks": [
            "task_pure_functions_1"
          ],
          "tags": [
            "functional-programming",
            "closures",
            "pure-functions",
            "side-effects",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures",
            "functional-programming-concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "functional-programming-patterns",
            "react-hooks-principles"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_currying_1",
          "topic": "Currying Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of currying a function?",
          "answer": "To transform a function that takes multiple arguments into a sequence of functions, each taking a single argument.",
          "options": [],
          "analysisPoints": [
            "Focuses on the definition of currying.",
            "Highlights the transformation of arguments."
          ],
          "keyConcepts": [
            "currying",
            "function transformation"
          ],
          "evaluationCriteria": [
            "Definition recall"
          ],
          "example": "",
          "tags": [
            "currying",
            "functional-programming",
            "definition"
          ],
          "prerequisites": [
            "basic-functions"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_currying_2",
          "topic": "Currying vs. Partial Application",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between currying and partial application. Provide a small code example to illustrate partial application.",
          "answer": "Currying transforms a function `f(a,b,c)` into `f(a)(b)(c)`, where each call accepts exactly one argument. Partial application, on the other hand, is the process of fixing a certain number of arguments to a function, producing another function with fewer arguments. It doesn't necessarily mean each call accepts only one argument, but rather that some arguments are pre-filled.\n\nExample of Partial Application:\n```javascript\nfunction multiply(a, b, c) {\n  return a * b * c;\n}\n\n// Partial application: fix the first argument 'a'\nconst multiplyByTen = multiply.bind(null, 10); // Using bind for partial application\nconsole.log(multiplyByTen(2, 3)); // Output: 60 (10 * 2 * 3)\n\n// Another example using a factory function for partial application\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction partialApplyAdd(a) {\n  return function(b) {\n    return add(a, b);\n  };\n}\n\nconst addFive = partialApplyAdd(5);\nconsole.log(addFive(3)); // Output: 8\n```",
          "options": [],
          "analysisPoints": [
            "Ability to differentiate between two related functional programming concepts.",
            "Correct use of `bind` or a factory function for partial application.",
            "Clarity of explanation and code example."
          ],
          "keyConcepts": [
            "currying",
            "partial-application",
            "functional-programming"
          ],
          "evaluationCriteria": [
            "Conceptual understanding",
            "Code example accuracy",
            "Clarity of explanation"
          ],
          "example": "",
          "tags": [
            "currying",
            "partial-application",
            "functional-programming",
            "javascript"
          ],
          "prerequisites": [
            "closures",
            "function-bind"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_currying_3",
          "topic": "Currying Output",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n```javascript\nfunction greet(greeting) {\n  return function(name) {\n    return `${greeting}, ${name}!`;\n  };\n}\n\nconst sayHello = greet('Hello');\nconst sayHiToJohn = sayHello('John');\n\nconsole.log(sayHiToJohn);\n```\nWhat will be the output of `console.log(sayHiToJohn)`?",
          "answer": "Hello, John!",
          "options": [
            "function(name) { return `${greeting}, ${name}!` }",
            "Hello",
            "Hello, John!",
            "undefined"
          ],
          "analysisPoints": [
            "Tests understanding of how curried functions execute.",
            "Checks comprehension of closure behavior and return values.",
            "Confirms the final string interpolation."
          ],
          "keyConcepts": [
            "currying",
            "closures",
            "function-execution",
            "string-interpolation"
          ],
          "evaluationCriteria": [
            "Correct output prediction",
            "Understanding of closure scope"
          ],
          "example": "The `greet` function is curried. `greet('Hello')` returns an inner function that captures 'Hello' in its closure. When `sayHello('John')` is called, 'John' is passed as `name` to this inner function, which then accesses the captured 'Hello' and returns the concatenated string 'Hello, John!'.",
          "tags": [
            "currying",
            "javascript",
            "closure",
            "mcq"
          ],
          "prerequisites": [
            "closures",
            "functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_currying_4",
          "topic": "Benefits of Currying",
          "level": "medium",
          "type": "flashcard",
          "question": "Name two key benefits of using currying in JavaScript.",
          "answer": "1.  **Increased Reusability**: By partially applying arguments, you can create specialized functions from more general ones.\n2.  **Easier Function Composition**: Curried functions, especially those taking one argument at a time, fit well into functional composition patterns.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of practical advantages of currying.",
            "Focuses on functional programming paradigms."
          ],
          "keyConcepts": [
            "currying",
            "reusability",
            "function-composition"
          ],
          "evaluationCriteria": [
            "Recall of benefits"
          ],
          "example": "",
          "tags": [
            "currying",
            "functional-programming",
            "benefits"
          ],
          "prerequisites": [
            "currying-basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_currying_5",
          "topic": "Currying Implementation Logic",
          "level": "hard",
          "type": "code",
          "question": "Implement a generic `curry` function in JavaScript that can curry any given function `fn`. The `curry` function should allow calling the curried function with any number of arguments until all expected arguments are provided, at which point the original function `fn` is executed.\n\nExample:\n```javascript\nconst add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\n\nconsole.log(curriedAdd(1)(2)(3)); // Should output 6\nconsole.log(curriedAdd(1, 2)(3));  // Should output 6\nconsole.log(curriedAdd(1)(2, 3));  // Should output 6\nconsole.log(curriedAdd(1, 2, 3));  // Should output 6\n\nconst sumTwo = (a, b) => a + b;\nconst curriedSumTwo = curry(sumTwo);\nconsole.log(curriedSumTwo(5)(5)); // Should output 10\n```",
          "answer": "```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) { // Check if enough arguments are gathered\n      return fn.apply(this, args);\n    } else {\n      return function(...nextArgs) {\n        return curried.apply(this, args.concat(nextArgs)); // Concatenate arguments and return new curried function\n      };\n    }\n  };\n}\n\n// Example Usage:\nconst add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\n\nconsole.log(curriedAdd(1)(2)(3));\nconsole.log(curriedAdd(1, 2)(3));\nconsole.log(curriedAdd(1)(2, 3));\nconsole.log(curriedAdd(1, 2, 3));\n\nconst sumTwo = (a, b) => a + b;\nconst curriedSumTwo = curry(sumTwo);\nconsole.log(curriedSumTwo(5)(5));\nconsole.log(curriedSumTwo(5, 5));\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the base case (enough arguments).",
            "Uses recursion or a loop to accumulate arguments.",
            "Correctly handles `this` context and arguments using `apply` and `concat` or spread.",
            "Understands `fn.length` to determine the arity of the original function.",
            "Ability to return a new function that captures previous arguments."
          ],
          "keyConcepts": [
            "currying",
            "closures",
            "recursion",
            "function.apply",
            "fn.length",
            "functional-programming"
          ],
          "evaluationCriteria": [
            "Correct implementation of generic curry",
            "Handles variable argument counts",
            "Preserves `this` context",
            "Efficiency"
          ],
          "example": "",
          "tags": [
            "currying",
            "functional-programming",
            "coding-challenge",
            "hard"
          ],
          "prerequisites": [
            "closures",
            "function.apply",
            "recursion"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_debounce_1",
          "topic": "Debounce Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main problem that debouncing aims to solve in frontend development?",
          "answer": "Debouncing aims to limit the frequency of function calls, especially for expensive operations triggered by rapid events (e.g., keystrokes, window resizing, scrolling), to improve performance and prevent unnecessary resource consumption.",
          "options": [],
          "analysisPoints": [
            "Focuses on the practical application and benefits.",
            "Highlights the types of events it targets."
          ],
          "keyConcepts": [
            "debounce",
            "performance",
            "event-handling"
          ],
          "evaluationCriteria": [
            "Definition recall",
            "Problem identification"
          ],
          "example": "",
          "tags": [
            "debounce",
            "performance",
            "event-handling",
            "definition"
          ],
          "prerequisites": [
            "basic-javascript"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_debounce_2",
          "topic": "Debounce Internal Mechanism",
          "level": "medium",
          "type": "mcq",
          "question": "In a typical `debounce` implementation, why is `clearTimeout(timer)` called at the beginning of the returned function?",
          "answer": "To prevent the previously set timeout from executing if the debounced function is called again before the delay expires.",
          "options": [
            "To immediately execute the function without any delay.",
            "To ensure the `timer` variable is always null.",
            "To prevent memory leaks by clearing old timers.",
            "To prevent the previously set timeout from executing if the debounced function is called again before the delay expires."
          ],
          "analysisPoints": [
            "Tests understanding of the core logic of debouncing.",
            "Highlights the role of `clearTimeout` in resetting the timer.",
            "Distinguishes between preventing execution and merely clearing for memory."
          ],
          "keyConcepts": [
            "debounce",
            "setTimeout",
            "clearTimeout",
            "timer-management"
          ],
          "evaluationCriteria": [
            "Correct understanding of debounce logic",
            "Reasoning for `clearTimeout`"
          ],
          "example": "The `clearTimeout(timer)` ensures that if `debounce` is called rapidly, the previous delayed execution is cancelled. This prevents the original function from firing multiple times unnecessarily and ensures it only fires *after* a period of inactivity. Without it, every call would set a new timer, leading to multiple executions.",
          "tags": [
            "debounce",
            "javascript",
            "closure",
            "mcq",
            "performance"
          ],
          "prerequisites": [
            "setTimeout",
            "clearTimeout"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_debounce_3",
          "topic": "Debounce Output Prediction",
          "level": "medium",
          "type": "code",
          "question": "Given the following `debounce` implementation and usage, what will be logged to the console and in what order?\n\n```javascript\nfunction debounce(fn, ms) {\n  let timer = null;\n  return function(...args) {\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, args);\n    }, ms);\n  };\n}\n\nfunction logValue(value) {\n  console.log('Value:', value);\n}\n\nconst debouncedLog = debounce(logValue, 100);\n\ndebouncedLog('A');\nsetTimeout(() => debouncedLog('B'), 50);\nsetTimeout(() => debouncedLog('C'), 200);\nsetTimeout(() => debouncedLog('D'), 280);\nsetTimeout(() => debouncedLog('E'), 400);\n```",
          "answer": "```text\nValue: B\nValue: D\nValue: E\n```\n\n**Explanation:**\n1.  `debouncedLog('A')` is called. A timer for 'A' is set for 100ms.\n2.  After 50ms, `debouncedLog('B')` is called. The timer for 'A' is cleared, and a new timer for 'B' is set for 100ms from this point (i.e., at 150ms from start).\n3.  At 150ms, the timer for 'B' expires. `logValue('B')` is executed. Output: `Value: B`.\n4.  After 200ms (from start), `debouncedLog('C')` is called. A timer for 'C' is set for 100ms from this point (i.e., at 300ms from start).\n5.  After 280ms (from start), `debouncedLog('D')` is called. The timer for 'C' is cleared, and a new timer for 'D' is set for 100ms from this point (i.e., at 380ms from start).\n6.  At 380ms, the timer for 'D' expires. `logValue('D')` is executed. Output: `Value: D`.\n7.  After 400ms (from start), `debouncedLog('E')` is called. A timer for 'E' is set for 100ms from this point (i.e., at 500ms from start).\n8.  At 500ms, the timer for 'E' expires. `logValue('E')` is executed. Output: `Value: E`.",
          "options": [],
          "analysisPoints": [
            "Ability to trace asynchronous calls and `setTimeout`/`clearTimeout` interactions.",
            "Understanding of how `debounce` delays and cancels execution.",
            "Correct prediction of which calls will ultimately execute."
          ],
          "keyConcepts": [
            "debounce",
            "asynchronous-javascript",
            "setTimeout",
            "clearTimeout",
            "event-loop"
          ],
          "evaluationCriteria": [
            "Correct sequence of outputs",
            "Detailed explanation of execution flow"
          ],
          "example": "",
          "tags": [
            "debounce",
            "javascript",
            "asynchronous",
            "coding-challenge",
            "prediction"
          ],
          "prerequisites": [
            "setTimeout",
            "clearTimeout",
            "event-loop-basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_debounce_4",
          "topic": "Debounce `this` Context",
          "level": "hard",
          "type": "open",
          "question": "In the `debounce` implementation provided, `fn.apply(this, args)` is used. Explain why `apply` is necessary and what problems might arise if it were simply `fn(...args)`.",
          "answer": "The `this` keyword's value in JavaScript depends on how a function is called (its execution context). When a debounced function is used as an event handler (e.g., `element.onkeyup = debouncedFunction`), the `this` context inside `debouncedFunction` would typically refer to the `element` that triggered the event.\n\nIf `fn(...args)` were used instead of `fn.apply(this, args)`:\n\n1.  **Loss of `this` context**: The `setTimeout` callback, which ultimately calls `fn`, executes in the global context (or `undefined` in strict mode) by default. This means `this` inside `fn` would no longer refer to the original context (e.g., the DOM element), but rather to the global object (window) or `undefined`. This can lead to errors if `fn` relies on `this` (e.g., `this.value`, `this.style`).\n\n`fn.apply(this, args)` solves this by:\n-   `this` (the first argument to `apply`): Captures the `this` value from the context in which the debounced function was originally called (`return function(...args)`). This ensures the original `this` context is preserved.\n-   `args` (the second argument to `apply`): Forwards all arguments passed to the debounced function to the original function `fn` as an array.\n\nThis makes the `debounce` function general-purpose and correctly handles scenarios where the original function `fn` depends on its `this` context and/or variable arguments.",
          "options": [],
          "analysisPoints": [
            "Demonstrates understanding of `this` binding rules in JavaScript.",
            "Explains the role of `apply` in context preservation.",
            "Identifies the specific problem `apply` solves in the debounce pattern.",
            "Discusses the implications of not preserving context."
          ],
          "keyConcepts": [
            "debounce",
            "this-keyword",
            "function.apply",
            "execution-context",
            "closures"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of `this` context",
            "Correctly identifies `apply`'s necessity",
            "Articulates potential issues"
          ],
          "example": "",
          "tags": [
            "debounce",
            "javascript",
            "this-keyword",
            "apply",
            "advanced"
          ],
          "prerequisites": [
            "this-keyword",
            "function.call-apply-bind"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_debounce_5",
          "topic": "Debounce vs. Throttle",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the key difference between debouncing and throttling?",
          "answer": "Debouncing executes a function *after* a period of inactivity (e.g., 'fire once the user stops typing'). Throttling executes a function *at most once* within a specified time period (e.g., 'fire at most once every 200ms while scrolling').",
          "options": [],
          "analysisPoints": [
            "Clearly distinguishes the timing behavior of each technique.",
            "Provides clear examples for each."
          ],
          "keyConcepts": [
            "debounce",
            "throttle",
            "event-handling",
            "performance"
          ],
          "evaluationCriteria": [
            "Accurate comparison",
            "Understanding of practical application"
          ],
          "example": "",
          "tags": [
            "debounce",
            "throttle",
            "performance",
            "comparison"
          ],
          "prerequisites": [
            "debounce-basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_module_pattern_1",
          "topic": "Module Pattern Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary goal of the JavaScript Module Pattern?",
          "answer": "To achieve encapsulation and create private variables and methods, while exposing a public interface.",
          "options": [],
          "analysisPoints": [
            "Focuses on the main purpose.",
            "Highlights encapsulation and privacy."
          ],
          "keyConcepts": [
            "module-pattern",
            "encapsulation",
            "privacy"
          ],
          "evaluationCriteria": [
            "Definition recall"
          ],
          "example": "",
          "tags": [
            "module-pattern",
            "design-patterns",
            "definition"
          ],
          "prerequisites": [
            "closures"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_module_pattern_2",
          "topic": "Module Pattern Privacy",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `Counter` module example:\n```javascript\nconst Counter = (function() {\n  let privateCounter = 0; \n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() { changeBy(1); },\n    value: function() { return privateCounter; }\n  };\n})();\n```\nWhich of the following statements is TRUE regarding `privateCounter`?",
          "answer": "`privateCounter` can only be accessed or modified by `increment` and `value` methods.",
          "options": [
            "`privateCounter` is accessible directly as `Counter.privateCounter`.",
            "`privateCounter` can be modified by any external code.",
            "`privateCounter` can only be accessed or modified by `increment` and `value` methods.",
            "`privateCounter` is a global variable."
          ],
          "analysisPoints": [
            "Tests understanding of privacy in the module pattern.",
            "Confirms that private members are only accessible via the public interface.",
            "Distinguishes between internal and external access."
          ],
          "keyConcepts": [
            "module-pattern",
            "privacy",
            "closures",
            "encapsulation"
          ],
          "evaluationCriteria": [
            "Correct identification of access scope",
            "Understanding of private state"
          ],
          "example": "The `privateCounter` is declared within the IIFE's scope. It's not returned as part of the public interface. The `increment` and `value` methods, being closures, have access to `privateCounter`, but external code cannot directly access `Counter.privateCounter`.",
          "tags": [
            "module-pattern",
            "javascript",
            "closure",
            "mcq"
          ],
          "prerequisites": [
            "closures",
            "iife"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_module_pattern_3",
          "topic": "Module Pattern Benefits",
          "level": "medium",
          "type": "open",
          "question": "Beyond encapsulation, what are two other significant benefits of using the Module Pattern in JavaScript development?",
          "answer": "1.  **Prevention of Global Namespace Pollution**: All variables and functions specific to the module are contained within its own scope (the IIFE), preventing them from polluting the global scope and causing naming conflicts.\n2.  **Improved Maintainability and Organization**: Code is logically grouped into self-contained units with clear public interfaces and hidden private implementations, making it easier to understand, manage, and debug specific parts of an application.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of broader architectural advantages.",
            "Focuses on practical benefits for larger codebases.",
            "Distinguishes from mere privacy."
          ],
          "keyConcepts": [
            "module-pattern",
            "global-namespace",
            "maintainability",
            "organization"
          ],
          "evaluationCriteria": [
            "Identification of valid benefits",
            "Clarity of explanation"
          ],
          "example": "",
          "tags": [
            "module-pattern",
            "design-patterns",
            "benefits"
          ],
          "prerequisites": [
            "module-pattern-basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_module_pattern_4",
          "topic": "Module Pattern vs. ES Modules",
          "level": "hard",
          "type": "flashcard",
          "question": "How does the traditional JavaScript Module Pattern relate to modern ES Modules (`import`/`export`)?",
          "answer": "The traditional Module Pattern achieves encapsulation and privacy using IIFEs and closures. ES Modules (`import`/`export`) provide a standardized, native way to achieve similar goals (encapsulation, no global pollution) with a clearer syntax and static analysis benefits. ES Modules are generally preferred in modern JavaScript, but the Module Pattern is a fundamental concept illustrating how module-like behavior was achieved before native support.",
          "options": [],
          "analysisPoints": [
            "Compares historical pattern with modern standard.",
            "Highlights the core similarities and differences (native vs. pattern).",
            "Mentions preference for modern approach."
          ],
          "keyConcepts": [
            "module-pattern",
            "es-modules",
            "encapsulation",
            "javascript-history"
          ],
          "evaluationCriteria": [
            "Accurate comparison",
            "Contextual understanding"
          ],
          "example": "",
          "tags": [
            "module-pattern",
            "es-modules",
            "comparison",
            "javascript-evolution"
          ],
          "prerequisites": [
            "module-pattern-basics",
            "es-modules-basics"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_module_pattern_5",
          "topic": "Module Pattern Implementation",
          "level": "medium",
          "type": "code",
          "question": "Create a `Logger` module using the Module Pattern. The `Logger` should have:\n-   A private variable `logCount` initialized to `0`.\n-   A private helper function `_logMessage(message)` that internally increments `logCount` and logs the message with a prefix `[LOG]: `.\n-   A public method `info(message)` that uses `_logMessage`.\n-   A public method `getLogCount()` that returns the current `logCount`.\n\nExample Usage:\n```javascript\nLogger.info('Application started.');\nLogger.info('User logged in.');\nconsole.log(Logger.getLogCount()); // Expected: 2\n// console.log(Logger.logCount); // Should be undefined\n// Logger._logMessage('Secret'); // Should throw an error or be inaccessible\n```",
          "answer": "```javascript\nconst Logger = (function() {\n  let logCount = 0; // Private variable\n  \n  function _logMessage(message) { // Private function\n    logCount++;\n    console.log(`[LOG]: ${message}`);\n  }\n  \n  return {\n    info: function(message) {\n      _logMessage(message);\n    },\n    getLogCount: function() {\n      return logCount;\n    }\n  };\n})();\n\nLogger.info('Application started.');\nLogger.info('User logged in.');\nconsole.log(Logger.getLogCount()); // Output: 2\n\n// Demonstrating privacy:\n// console.log(Logger.logCount); // undefined\n// try {\n//   Logger._logMessage('Secret'); // TypeError: Logger._logMessage is not a function\n// } catch (e) {\n//   console.log(e.message);\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses an IIFE to create a private scope.",
            "Properly defines private variables and functions.",
            "Exposes a public interface through the returned object.",
            "Demonstrates how public methods access private state via closures.",
            "Ensures private members are not directly accessible from outside."
          ],
          "keyConcepts": [
            "module-pattern",
            "closures",
            "iife",
            "encapsulation",
            "privacy",
            "javascript"
          ],
          "evaluationCriteria": [
            "Correct module structure",
            "Functionality as per requirements",
            "Privacy enforcement"
          ],
          "example": "",
          "tags": [
            "module-pattern",
            "design-patterns",
            "coding-challenge"
          ],
          "prerequisites": [
            "closures",
            "iife"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pure_functions_1",
          "topic": "Pure Functions Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two main characteristics of a pure function?",
          "answer": "1.  **Deterministic**: Given the same input, it always returns the same output.\n2.  **No Side Effects**: It does not cause any observable changes outside its own scope (e.g., modifying external variables, performing I/O).",
          "options": [],
          "analysisPoints": [
            "Tests recall of fundamental functional programming principles.",
            "Highlights the core properties."
          ],
          "keyConcepts": [
            "pure-functions",
            "functional-programming",
            "determinism",
            "side-effects"
          ],
          "evaluationCriteria": [
            "Definition recall"
          ],
          "example": "",
          "tags": [
            "pure-functions",
            "functional-programming",
            "definition"
          ],
          "prerequisites": [
            "functions-basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_pure_functions_2",
          "topic": "Pure Functions and Closures Interaction",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n```javascript\nlet counter = 0;\n\nfunction createIncrementer() {\n  return function() {\n    counter++; // Modifies external state\n    return counter;\n  };\n}\n\nconst increment = createIncrementer();\nincrement();\nconsole.log(increment());\n```\nWhy is the `increment` function (the closure) NOT considered a pure function?",
          "answer": "It modifies external state (`counter`), thus producing a side effect.",
          "options": [
            "It always returns a different value, which is not allowed for pure functions.",
            "It modifies external state (`counter`), thus producing a side effect.",
            "It doesn't take any arguments.",
            "It is created using a closure, and closures are inherently impure."
          ],
          "analysisPoints": [
            "Tests understanding of pure function criteria, specifically side effects.",
            "Clarifies that closures themselves aren't inherently impure, but how they use captured state determines purity.",
            "Distinguishes between return value changing due to internal logic vs. external state."
          ],
          "keyConcepts": [
            "pure-functions",
            "closures",
            "side-effects",
            "functional-programming"
          ],
          "evaluationCriteria": [
            "Correctly identifies violation of purity principle",
            "Understands 'side effect' concept"
          ],
          "example": "The `increment` function modifies the `counter` variable, which is declared outside its own scope. This modification is a side effect, as it changes something in the external environment. Therefore, `increment` is not a pure function.",
          "tags": [
            "pure-functions",
            "closures",
            "side-effects",
            "mcq"
          ],
          "prerequisites": [
            "pure-functions-basics",
            "closures"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pure_functions_3",
          "topic": "Benefits of Pure Functions",
          "level": "medium",
          "type": "open",
          "question": "List three advantages of writing pure functions in a codebase.",
          "answer": "1.  **Easier Testing**: Since pure functions are deterministic and have no side effects, testing them is straightforward. You only need to provide inputs and assert the output; no complex setup or teardown of external state is required.\n2.  **Improved Readability and Reasoning**: Pure functions are predictable and self-contained. Their behavior is solely determined by their inputs, making them easier to understand and reason about without needing to inspect external factors.\n3.  **Better Composability and Cacheability**: Pure functions are modular and independent, making them excellent candidates for function composition. Also, their deterministic nature allows for memoization (caching results for given inputs) to improve performance.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of practical benefits for development and maintenance.",
            "Covers aspects like testing, reasoning, and performance."
          ],
          "keyConcepts": [
            "pure-functions",
            "benefits",
            "testing",
            "composability",
            "readability",
            "caching"
          ],
          "evaluationCriteria": [
            "Identifies relevant advantages",
            "Explains each advantage clearly"
          ],
          "example": "",
          "tags": [
            "pure-functions",
            "functional-programming",
            "benefits"
          ],
          "prerequisites": [
            "pure-functions-basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pure_functions_4",
          "topic": "Pure Function Implementation",
          "level": "medium",
          "type": "code",
          "question": "Write a pure function `getDiscountedPrice` that takes an original `price` and a `discountPercentage` and returns the discounted price. Ensure it adheres to the principles of a pure function.\n\nThen, create a function factory `createDiscountCalculator` using a closure that takes a `fixedPercentage` and returns a pure function (closure) that applies this discount to any given price. Demonstrate its purity.",
          "answer": "```javascript\n// Pure function: getDiscountedPrice\nfunction getDiscountedPrice(price, discountPercentage) {\n  // Deterministic: same input -> same output\n  // No side effects: does not modify external state, no I/O\n  return price * (1 - discountPercentage / 100);\n}\n\nconsole.log('--- Pure Function `getDiscountedPrice` ---');\nconsole.log(getDiscountedPrice(100, 10)); // Output: 90\nconsole.log(getDiscountedPrice(200, 25)); // Output: 150\n\n\n// Function Factory using Closure (returns a pure function)\nfunction createDiscountCalculator(fixedPercentage) {\n  // Outer function is pure: returns a function based on input, no side effects\n  return function(price) {\n    // Inner function (closure) is pure:\n    // - depends only on its arguments (price) and captured immutable state (fixedPercentage)\n    // - produces no side effects\n    return price * (1 - fixedPercentage / 100);\n  };\n}\n\nconsole.log('\\n--- Pure Function Factory `createDiscountCalculator` ---');\nconst tenPercentOff = createDiscountCalculator(10);\nconsole.log(tenPercentOff(100)); // Output: 90\nconsole.log(tenPercentOff(250)); // Output: 225\n\n// Demonstrating purity of the returned function:\n// Calling with same input always yields same output\nconsole.log(tenPercentOff(100)); // Output: 90\n\nconst twentyPercentOff = createDiscountCalculator(20);\nconsole.log(twentyPercentOff(100)); // Output: 80\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implements a basic pure function.",
            "Successfully uses a closure to create a function factory.",
            "Ensures the function returned by the factory is also pure (captures immutable state).",
            "Demonstrates understanding of determinism and lack of side effects in both functions."
          ],
          "keyConcepts": [
            "pure-functions",
            "closures",
            "function-factory",
            "side-effects",
            "functional-programming"
          ],
          "evaluationCriteria": [
            "Correct implementation of pure function",
            "Correct implementation of pure function factory using closure",
            "Demonstration of purity"
          ],
          "example": "",
          "tags": [
            "pure-functions",
            "functional-programming",
            "coding-challenge",
            "closure"
          ],
          "prerequisites": [
            "pure-functions-basics",
            "closures"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_currying_1",
          "title": "Implement a Flexible Currying Utility",
          "description": "\nImplement a `curry` utility function that takes any JavaScript function `fn` and returns a curried version of it. The curried function should be flexible, allowing arguments to be passed one by one or in groups, until all arguments specified by `fn.length` are collected. Once all arguments are collected, the original function `fn` should be invoked with the accumulated arguments.\n\n**Requirements:**\n1.  The `curry` function should accept a single function `fn`.\n2.  The returned curried function should accept arguments flexibly (e.g., `curriedFn(a)(b)(c)` or `curriedFn(a, b)(c)`).\n3.  It should use `fn.length` to determine the number of arguments expected by the original function.\n4.  It must preserve the `this` context when the final function is called.\n5.  It should correctly pass all accumulated arguments to the original function.\n\n**Example:**\n```javascript\nconst sum = (a, b, c) => a + b + c;\nconst curriedSum = curry(sum);\n\nconsole.log(curriedSum(1)(2)(3)); // 6\nconsole.log(curriedSum(1, 2)(3)); // 6\nconsole.log(curriedSum(1)(2, 3)); // 6\nconsole.log(curriedSum(1, 2, 3)); // 6\n\nconst greet = (greeting, name, punctuation) => `${greeting}, ${name}${punctuation}`;\nconst curriedGreet = curry(greet);\nconsole.log(curriedGreet('Hello')('World')('!')); // \"Hello, World!\"\nconsole.log(curriedGreet('Hi', 'Alice')('?'));     // \"Hi, Alice?\"\n```\n",
          "difficulty": "hard",
          "startingCode": "function curry(fn) {\n  // TODO: Implement the currying logic here\n  // Hint: You'll need to accumulate arguments and check against fn.length.\n  // Consider using closures to store accumulated arguments and a recursive approach.\n  // Don't forget to handle `this` context and pass all arguments correctly.\n  \n  return function curried(...args) {\n    // Your implementation here\n  };\n}\n\n// Test cases (provided in description, copy and paste to verify)\n// const sum = (a, b, c) => a + b + c;\n// const curriedSum = curry(sum);\n// console.log(curriedSum(1)(2)(3));\n// console.log(curriedSum(1, 2)(3));\n// console.log(curriedSum(1)(2, 3));\n// console.log(curriedSum(1, 2, 3));\n// const greet = (greeting, name, punctuation) => `${greeting}, ${name}${punctuation}`;\n// const curriedGreet = curry(greet);\n// console.log(curriedGreet('Hello')('World')('!'));\n// console.log(curriedGreet('Hi', 'Alice')('?'));",
          "solutionCode": "function curry(fn) {\n  const expectedArgs = fn.length;\n\n  return function curried(...args) {\n    // Check if enough arguments have been collected\n    if (args.length >= expectedArgs) {\n      // If yes, execute the original function with collected arguments\n      return fn.apply(this, args);\n    } else {\n      // If not enough arguments, return a new function that will collect more\n      const self = this;\n      return function(...nextArgs) {\n        // Concatenate new arguments with previously collected ones\n        // Recursively call the curried function with all accumulated arguments\n        return curried.apply(self, args.concat(nextArgs));\n      };\n    }\n  };\n}",
          "testCases": [
            "curry((a, b, c) => a + b + c)(1)(2)(3) should return 6",
            "curry((a, b, c) => a + b + c)(1, 2)(3) should return 6",
            "curry((a, b, c) => a + b + c)(1)(2, 3) should return 6",
            "curry((a, b, c) => a + b + c)(1, 2, 3) should return 6",
            "curry((g, n, p) => `${g}, ${n}${p}`)('Hi')('There')('!') should return \"Hi, There!\"",
            "curry((a) => a * 2)(5) should return 10 (function with 1 argument)",
            "Test `this` context: `const obj = { value: 10, add: curry(function(a) { return this.value + a; }) }; console.log(obj.add(5)());` (should correctly use `obj.value`)"
          ],
          "hints": [
            "The `fn.length` property can tell you the number of arguments a function expects.",
            "You'll need a way to accumulate arguments across multiple calls. A closure can help here.",
            "The base case for your recursive function is when the accumulated arguments count meets `fn.length`.",
            "Remember to use `apply` to pass arguments and preserve the `this` context."
          ],
          "tags": [
            "currying",
            "functional-programming",
            "closures",
            "higher-order-functions",
            "javascript"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "closures",
            "function.apply",
            "recursion",
            "rest-spread-operators"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "partial-application",
            "higher-order-functions"
          ]
        },
        {
          "id": "task_currying_2",
          "title": "Curried Form Validator",
          "description": "\nCreate a set of curried validation functions that can be combined to validate user input for a form field. Each validator should take a specific rule (e.g., minimum length) and return a new function that takes the actual input value to validate. Finally, demonstrate how to use these curried validators.\n\n**Requirements:**\n1.  Implement a `minLen` curried validator:\n    `minLen(length: number): (value: string) => boolean`\n    Returns `true` if `value.length` is greater than or equal to `length`, `false` otherwise.\n2.  Implement a `maxLen` curried validator:\n    `maxLen(length: number): (value: string) => boolean`\n    Returns `true` if `value.length` is less than or equal to `length`, `false` otherwise.\n3.  Implement an `isEmail` validator:\n    `isEmail(): (value: string) => boolean` (no arguments for the first call)\n    Returns `true` if the `value` is a valid email format (simple regex check, e.g., `/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/`), `false` otherwise.\n4.  Demonstrate usage by creating specific validation functions (e.g., `validateUsername`, `validateEmail`) using these curried validators and testing them with various inputs.\n\n**Example Usage:**\n```javascript\n// Using your implemented curried validators\nconst validateUsername = minLen(3);\nconsole.log(validateUsername('')); // false\nconsole.log(validateUsername('abc')); // true\n\nconst validateEmailField = isEmail();\nconsole.log(validateEmailField('test@example.com')); // true\nconsole.log(validateEmailField('invalid-email')); // false\n```\n",
          "difficulty": "medium",
          "startingCode": "// Your curried validator implementations here\nfunction minLen(length) {\n  // TODO: Implement minLen\n}\n\nfunction maxLen(length) {\n  // TODO: Implement maxLen\n}\n\nfunction isEmail() {\n  // TODO: Implement isEmail\n}\n\n// Demonstrate usage with examples from description\n// const validateUsername = minLen(3);\n// console.log(validateUsername('')); \n// console.log(validateUsername('abc')); \n// const validateEmailField = isEmail();\n// console.log(validateEmailField('test@example.com'));\n// console.log(validateEmailField('invalid-email'));\n",
          "solutionCode": "function minLen(length) {\n  return function(value) {\n    return value.length >= length;\n  };\n}\n\nfunction maxLen(length) {\n  return function(value) {\n    return value.length <= length;\n  };\n}\n\nfunction isEmail() {\n  // A simple regex for demonstration. Real email validation is complex.\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return function(value) {\n    return emailRegex.test(value);\n  };\n}\n\n// --- Demonstration --- \nconsole.log('--- Username Validation (minLen(3)) ---');\nconst validateUsername = minLen(3);\nconsole.log(`'': ${validateUsername('')}`);     // false\nconsole.log(`'ab': ${validateUsername('ab')}`);   // false\nconsole.log(`'abc': ${validateUsername('abc')}`); // true\nconsole.log(`'abcd': ${validateUsername('abcd')}`); // true\n\nconsole.log('\\n--- Password Validation (minLen(6), maxLen(20)) ---');\nconst validatePasswordMin = minLen(6);\nconst validatePasswordMax = maxLen(20);\n\nconsole.log(`'pass': ${validatePasswordMin('pass')}`); // false\nconsole.log(`'password': ${validatePasswordMin('password')}`); // true\nconsole.log(`'passwordverylongpasswordverylong': ${validatePasswordMax('passwordverylongpasswordverylong')}`); // false\nconsole.log(`'short_password': ${validatePasswordMax('short_password')}`); // true\n\nconsole.log('\\n--- Email Validation (isEmail()) ---');\nconst validateEmailField = isEmail();\nconsole.log(`'test@example.com': ${validateEmailField('test@example.com')}`); // true\nconsole.log(`'invalid-email': ${validateEmailField('invalid-email')}`);     // false\nconsole.log(`'test@example': ${validateEmailField('test@example')}`);       // false\nconsole.log(`'user@sub.domain.co': ${validateEmailField('user@sub.domain.co')}`); // true\n",
          "testCases": [
            "minLen(5)('hello') should return true",
            "minLen(5)('hi') should return false",
            "maxLen(10)('short') should return true",
            "maxLen(10)('veryverylongstring') should return false",
            "isEmail()('valid@email.com') should return true",
            "isEmail()('invalid-email') should return false",
            "isEmail()('') should return false"
          ],
          "hints": [
            "Each curried function will simply return another function that takes the actual value.",
            "For `isEmail`, you'll capture the regex in the closure.",
            "Think about what value needs to be configured (curried) and what value is passed at the final execution."
          ],
          "tags": [
            "currying",
            "functional-programming",
            "validation",
            "closures",
            "frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "closures",
            "basic-functions"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "higher-order-functions",
            "form-validation"
          ]
        },
        {
          "id": "task_debounce_1",
          "title": "Implement a Debounced Input Search",
          "description": "\nImplement a `debounce` utility function and integrate it into a simulated search input scenario. The goal is to ensure that an expensive search function (simulated with `console.log`) is only called after the user has stopped typing for a specific delay.\n\n**Requirements:**\n1.  Implement a `debounce` function that takes a function `fn` and a `delay` (in milliseconds).\n2.  The `debounce` function should return a new function that, when called, delays the execution of `fn` until `delay` milliseconds have passed without any further calls to the debounced function.\n3.  The debounced function must correctly pass all arguments and preserve the `this` context to the original `fn`.\n4.  Simulate a series of rapid `input` events (e.g., calling `debouncedSearch` multiple times quickly) and verify that the `searchAPI` (your simulated expensive function) is called only once after the last simulated input.\n\n**Example Simulation:**\n```javascript\nconst searchAPI = (query) => console.log(`[API Call] Searching for: ${query}`);\nconst debouncedSearch = debounce(searchAPI, 300);\n\nconsole.log('--- Simulating rapid typing ---');\ndebouncedSearch('a');\ndebouncedSearch('ap');\ndebouncedSearch('app');\n// Expected: After ~300ms, only '[API Call] Searching for: app' should appear\n\nsetTimeout(() => {\n  console.log('\\n--- Simulating pause, then more typing ---');\n  debouncedSearch('apple');\n  setTimeout(() => debouncedSearch('apple pie'), 100);\n  setTimeout(() => debouncedSearch('apple pie recipe'), 200);\n  // Expected: After ~300ms from the last 'apple pie recipe' call, \n  // only '[API Call] Searching for: apple pie recipe' should appear\n}, 1000);\n```\n",
          "difficulty": "medium",
          "startingCode": "function debounce(fn, delay) {\n  let timerId = null; // This variable needs to be accessible by the inner function via closure\n  \n  return function(...args) {\n    const context = this; // Capture the 'this' context\n    \n    // TODO: Implement the debounce logic here\n    // 1. Clear any existing timer.\n    // 2. Set a new timer to call `fn` after `delay`.\n    // 3. Ensure `fn` is called with the correct `this` and arguments.\n\n  };\n}\n\n// Test functions (provided in description, copy and paste to verify)\n// const searchAPI = (query) => console.log(`[API Call] Searching for: ${query}`);\n// const debouncedSearch = debounce(searchAPI, 300);\n// console.log('--- Simulating rapid typing ---');\n// debouncedSearch('a');\n// debouncedSearch('ap');\n// debouncedSearch('app');\n// setTimeout(() => {\n//   console.log('\\n--- Simulating pause, then more typing ---');\n//   debouncedSearch('apple');\n//   setTimeout(() => debouncedSearch('apple pie'), 100);\n//   setTimeout(() => debouncedSearch('apple pie recipe'), 200);\n// }, 1000);",
          "solutionCode": "function debounce(fn, delay) {\n  let timerId = null;\n  \n  return function(...args) {\n    const context = this;\n    \n    // Clear any existing timer to reset the countdown\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    \n    // Set a new timer\n    timerId = setTimeout(() => {\n      // Execute the original function with the correct 'this' context and arguments\n      fn.apply(context, args);\n      timerId = null; // Optional: clear timerId after execution for cleaner state\n    }, delay);\n  };\n}\n\n// --- Test Case Simulation --- \nconst searchAPI = (query) => console.log(`[API Call] Searching for: ${query}`);\nconst debouncedSearch = debounce(searchAPI, 300);\n\nconsole.log('--- Simulating rapid typing for \"app\" ---');\ndebouncedSearch('a');\ndebouncedSearch('ap');\ndebouncedSearch('app');\n\n// Simulate a pause and then another round of typing\nsetTimeout(() => {\n  console.log('\\n--- Simulating pause, then more typing for \"apple pie recipe\" ---');\n  debouncedSearch('apple');\n  setTimeout(() => debouncedSearch('apple pie'), 100);\n  setTimeout(() => debouncedSearch('apple pie recipe'), 200);\n}, 1000);\n\n// Simulate immediate execution after the debounced period for a single call\nsetTimeout(() => {\n  console.log('\\n--- Simulating single immediate call after a long pause ---');\n  debouncedSearch('single search');\n}, 2000);\n",
          "testCases": [
            "Rapid calls: `d('a'); d('b'); d('c');` (delay 100ms) -> Only `fn('c')` executes after 100ms.",
            "Single call: `d('hello');` (delay 200ms) -> `fn('hello')` executes after 200ms.",
            "Multiple bursts: Ensure correct function calls after each burst of activity and inactivity.",
            "Context preservation: Verify `this` is correctly passed (e.g., `const obj = { val: 1, func: debounce(function() { console.log(this.val); }, 100) }; obj.func();` should log `1`).",
            "Argument preservation: Verify all arguments are passed (e.g., `debounce((a, b) => console.log(a, b), 100)(1, 2)` should log `1 2`)."
          ],
          "hints": [
            "The `timerId` variable needs to persist across calls to the debounced function; closures are key here.",
            "`setTimeout` returns a timer ID that `clearTimeout` can use.",
            "Remember to capture `this` from the invocation context of the returned function.",
            "`Function.prototype.apply()` is useful for setting `this` and passing an array of arguments."
          ],
          "tags": [
            "debounce",
            "performance",
            "event-handling",
            "closures",
            "javascript",
            "frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "closures",
            "setTimeout",
            "clearTimeout",
            "this-keyword",
            "function.apply"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "throttle",
            "event-listeners"
          ]
        },
        {
          "id": "task_debounce_2",
          "title": "Debounced Window Resize Handler",
          "description": "\nImplement a `debounce` function and apply it to a `window.onresize` event handler. The goal is to update some UI element (simulated with `console.log`) only after the user has finished resizing the window for a specified duration, preventing excessive re-renders or calculations.\n\n**Requirements:**\n1.  Re-use or re-implement the `debounce` function from `task_debounce_1`.\n2.  Create a function `updateLayout()` that simulates an expensive layout recalculation. It should log `\"Recalculating layout... New width: [width], New height: [height]\"` using `window.innerWidth` and `window.innerHeight`.\n3.  Attach a debounced version of `updateLayout` to the `window.onresize` event. The debounce delay should be 200 milliseconds.\n4.  Include clear console logs to demonstrate when the debounced function is attached and when `updateLayout` is actually invoked.\n\n**Considerations:**\n-   In a real browser environment, you would resize the window to observe the behavior.\n-   For a node.js environment, you can only demonstrate the setup and explain the expected behavior.\n",
          "difficulty": "medium",
          "startingCode": "function debounce(fn, delay) {\n  let timerId = null;\n  return function(...args) {\n    const context = this;\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(() => {\n      fn.apply(context, args);\n      timerId = null;\n    }, delay);\n  };\n}\n\nfunction updateLayout() {\n  // TODO: Simulate expensive layout calculation.\n  // Log the current window dimensions. This function should only be called once\n  // after resizing stops for the debounce delay.\n  console.log(`Recalculating layout... New width: ${window.innerWidth}, New height: ${window.innerHeight}`);\n}\n\n// TODO: Attach the debounced updateLayout to window.onresize.\n// console.log('Debounced resize handler attached.');",
          "solutionCode": "function debounce(fn, delay) {\n  let timerId = null;\n  return function(...args) {\n    const context = this;\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(() => {\n      fn.apply(context, args);\n      timerId = null;\n    }, delay);\n  };\n}\n\nfunction updateLayout() {\n  // In a real browser, window.innerWidth and window.innerHeight would reflect current dimensions.\n  // For Node.js or simulation, these values would be undefined or refer to a global mock.\n  console.log(`Recalculating layout... New width: ${typeof window !== 'undefined' ? window.innerWidth : 'N/A'}, New height: ${typeof window !== 'undefined' ? window.innerHeight : 'N/A'}`);\n}\n\nconst debouncedUpdateLayout = debounce(updateLayout, 200);\n\n// Attach to window.onresize (this part would only work in a browser environment)\nif (typeof window !== 'undefined') {\n  window.addEventListener('resize', debouncedUpdateLayout);\n  console.log('Debounced resize handler attached to window.resize. Try resizing your browser window.');\n} else {\n  console.log('Running in a non-browser environment. Cannot attach to window.resize.');\n  console.log('The debounce logic is implemented, but event triggering needs a browser.');\n  // Example of how you'd test the debounce part manually in Node for theoretical understanding:\n  console.log('\\nSimulating resize events in Node for demonstration:');\n  const mockWidths = [800, 810, 805, 820, 815];\n  let currentWidthIndex = 0;\n\n  const simulateResize = () => {\n    if (currentWidthIndex < mockWidths.length) {\n      // In a real browser, 'this' would be window, args would be event object.\n      // For simulation, we just call the debounced function directly.\n      // We'll log the 'mocked' width to show the effect.\n      console.log(`[Simulated Resize] Triggered with mock width: ${mockWidths[currentWidthIndex]}`);\n      // Temporarily mock window properties for the 'updateLayout' function if needed for full demo\n      global.window = { innerWidth: mockWidths[currentWidthIndex], innerHeight: 600 }; \n      debouncedUpdateLayout();\n      currentWidthIndex++;\n      setTimeout(simulateResize, 50); // Simulate rapid resizing\n    } else {\n      console.log('Simulated resize events finished.');\n    }\n  };\n  simulateResize();\n\n  setTimeout(() => {\n    console.log('\\nSimulating a final, delayed resize to trigger it once more:');\n    global.window = { innerWidth: 900, innerHeight: 700 }; \n    debouncedUpdateLayout();\n  }, 1000); // Trigger a single resize after a pause\n\n}\n\n\n",
          "testCases": [
            "In a browser: Rapidly resize the window for a few seconds, then stop. `updateLayout` should only be called once after you stop resizing for 200ms.",
            "In a browser: Resize, pause for >200ms, resize again. `updateLayout` should be called twice.",
            "Verify `updateLayout` receives correct `innerWidth` and `innerHeight` values (in browser).",
            "Verify no calls to `updateLayout` if resizing is continuous within the delay."
          ],
          "hints": [
            "Attach the debounced function directly to `window.onresize` or `window.addEventListener('resize', ...)`. The `debounce` function should be generic enough to handle this.",
            "The `this` context for `window.onresize` events is typically `window` itself. Ensure your `debounce` correctly passes this through.",
            "If you're running in a Node.js environment, you won't see actual window resizes. You'll need to mock `window.innerWidth` and `window.innerHeight` or just focus on the `debounce` logic and its console output.",
            "Make sure your `debounce` function clears existing timers on every call to reset the delay."
          ],
          "tags": [
            "debounce",
            "event-handling",
            "performance",
            "frontend",
            "javascript",
            "browser-api"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "debounce",
            "window.onresize",
            "event-listeners"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "throttling",
            "event-loop"
          ]
        },
        {
          "id": "task_module_pattern_1",
          "title": "Build a Simple State Manager Module",
          "description": "\nCreate a `StateManager` module using the Module Pattern. This module should allow you to store and retrieve a single piece of state data, but only through its public API, ensuring the internal state variable is truly private.\n\n**Requirements:**\n1.  The `StateManager` should be implemented as an IIFE returning an object.\n2.  It must have a private variable, `_stateData`, initialized to `null`.\n3.  It should expose a public method `set(data)` that updates `_stateData`.\n4.  It should expose a public method `get()` that returns the current `_stateData`.\n5.  It should expose a public method `clear()` that resets `_stateData` to `null`.\n6.  Demonstrate that `_stateData` is not directly accessible from outside the module.\n\n**Example Usage:**\n```javascript\nStateManager.set({ user: 'Alice', theme: 'dark' });\nconsole.log(StateManager.get()); // { user: 'Alice', theme: 'dark' }\n\n// Attempting to access private state directly (should be undefined/error)\n// console.log(StateManager._stateData);\n\nStateManager.clear();\nconsole.log(StateManager.get()); // null\n```\n",
          "difficulty": "medium",
          "startingCode": "const StateManager = (function() {\n  let _stateData = null; // Private variable\n  \n  // TODO: Implement public methods here\n  return {\n    // set, get, clear methods\n  };\n})();\n\n// Test cases (provided in description, copy and paste to verify)\n// StateManager.set({ user: 'Alice', theme: 'dark' });\n// console.log(StateManager.get()); \n// console.log(StateManager._stateData);\n// StateManager.clear();\n// console.log(StateManager.get());\n",
          "solutionCode": "const StateManager = (function() {\n  let _stateData = null; // Private state variable\n  \n  return {\n    set: function(data) {\n      _stateData = data;\n      console.log('State set to:', _stateData);\n    },\n    get: function() {\n      console.log('Getting state:', _stateData);\n      return _stateData;\n    },\n    clear: function() {\n      _stateData = null;\n      console.log('State cleared.');\n    }\n  };\n})();\n\n// --- Demonstration --- \nconsole.log('Initial state:', StateManager.get()); // null\n\nStateManager.set({ user: 'Alice', theme: 'dark' });\nconsole.log('Current state:', StateManager.get()); // { user: 'Alice', theme: 'dark' }\n\nStateManager.set({ notifications: ['new message', 'new alert'] });\nconsole.log('Updated state:', StateManager.get()); // { notifications: ['new message', 'new alert'] }\n\n// Attempting to access private state directly\nconsole.log('Attempting to access private state directly:', StateManager._stateData); // undefined\n\nStateManager.clear();\nconsole.log('State after clearing:', StateManager.get()); // null\n",
          "testCases": [
            "StateManager.get() should initially return null.",
            "StateManager.set({ key: 'value' }); StateManager.get() should return { key: 'value' }.",
            "StateManager.set(123); StateManager.get() should return 123.",
            "StateManager.set('hello'); StateManager.get() should return 'hello'.",
            "StateManager.clear(); StateManager.get() should return null.",
            "Attempting to access `StateManager._stateData` should return `undefined`."
          ],
          "hints": [
            "Use an Immediately Invoked Function Expression (IIFE) `(function() { ... })();` to create the module scope.",
            "Declare `_stateData` inside the IIFE, but outside the `return` object, to make it private.",
            "The public methods you return will form closures over `_stateData`, allowing them to access and modify it."
          ],
          "tags": [
            "module-pattern",
            "design-patterns",
            "encapsulation",
            "privacy",
            "closures",
            "javascript"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "closures",
            "iife",
            "objects"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "singleton-pattern",
            "information-hiding"
          ]
        },
        {
          "id": "task_module_pattern_2",
          "title": "Create a User Session Manager Module",
          "description": "\nDevelop a `SessionManager` module using the Module Pattern. This module should manage user session data (e.g., `isLoggedIn`, `username`, `token`) and provide methods to log in, log out, and check session status, all while keeping the actual session data private.\n\n**Requirements:**\n1.  Implement `SessionManager` as an IIFE returning a public interface.\n2.  It should have private variables: `_isLoggedIn` (boolean, default `false`), `_username` (string, default `null`), `_token` (string, default `null`).\n3.  Expose a public method `login(username, token)` that sets `_isLoggedIn` to `true` and updates `_username` and `_token`.\n4.  Expose a public method `logout()` that resets all private variables to their default (logged-out) states.\n5.  Expose a public method `getStatus()` that returns an object like `{ isLoggedIn: boolean, username: string | null }`.\n6.  Ensure `_token` remains strictly private and is never returned by `getStatus()` or accessible directly.\n\n**Example Usage:**\n```javascript\nconsole.log(SessionManager.getStatus()); // { isLoggedIn: false, username: null }\n\nSessionManager.login('john.doe', 'secret-jwt-token-123');\nconsole.log(SessionManager.getStatus()); // { isLoggedIn: true, username: 'john.doe' }\n\n// console.log(SessionManager._token); // Should be undefined\n\nSessionManager.logout();\nconsole.log(SessionManager.getStatus()); // { isLoggedIn: false, username: null }\n```\n",
          "difficulty": "medium",
          "startingCode": "const SessionManager = (function() {\n  let _isLoggedIn = false;\n  let _username = null;\n  let _token = null; // This should remain private\n\n  // TODO: Implement public methods\n  return {\n    // login, logout, getStatus methods\n  };\n})();\n\n// Test cases (provided in description, copy and paste to verify)\n// console.log(SessionManager.getStatus());\n// SessionManager.login('john.doe', 'secret-jwt-token-123');\n// console.log(SessionManager.getStatus());\n// console.log(SessionManager._token);\n// SessionManager.logout();\n// console.log(SessionManager.getStatus());\n",
          "solutionCode": "const SessionManager = (function() {\n  let _isLoggedIn = false; // Private\n  let _username = null;    // Private\n  let _token = null;       // Strictly private, never exposed\n\n  function _resetSession() { // Private helper for internal use\n    _isLoggedIn = false;\n    _username = null;\n    _token = null;\n  }\n  \n  return {\n    login: function(username, token) {\n      if (!username || !token) {\n        console.error('Login failed: username and token are required.');\n        return;\n      }\n      _isLoggedIn = true;\n      _username = username;\n      _token = token;\n      console.log(`User '${_username}' logged in.`);\n    },\n    logout: function() {\n      _resetSession();\n      console.log('User logged out.');\n    },\n    getStatus: function() {\n      return {\n        isLoggedIn: _isLoggedIn,\n        username: _username\n      };\n    },\n    // A method to simulate checking if a token is valid (could be used internally by other features)\n    _checkTokenValidity: function(inputToken) {\n        return inputToken === _token; // Private method for internal module use (though exposed here for testing)\n    }\n  };\n})();\n\n// --- Demonstration --- \nconsole.log('Initial Status:', SessionManager.getStatus()); // { isLoggedIn: false, username: null }\n\nSessionManager.login('alice.smith', 'my-super-secret-jwt-token');\nconsole.log('Status after login:', SessionManager.getStatus()); // { isLoggedIn: true, username: 'alice.smith' }\n\n// Attempt to access private token directly\nconsole.log('Attempting to access private token:', SessionManager._token); // undefined\n\n// Demonstrate internal usage of private helper (if made public for testing)\n// console.log('Is provided token valid (internal check):', SessionManager._checkTokenValidity('my-super-secret-jwt-token')); // true\n\nSessionManager.logout();\nconsole.log('Status after logout:', SessionManager.getStatus()); // { isLoggedIn: false, username: null }\n\n// Test invalid login\nSessionManager.login('bob', null); // Should log error and status remains logged out\nconsole.log('Status after failed login attempt:', SessionManager.getStatus());\n",
          "testCases": [
            "Initial `getStatus()` should return `{ isLoggedIn: false, username: null }`.",
            "`login('testuser', '123')` should set `isLoggedIn` to `true` and `username` to 'testuser'.",
            "`getStatus()` after login should reflect the new state correctly.",
            "`_token` should NOT be accessible via `SessionManager._token` (returns `undefined`).",
            "`logout()` should reset `isLoggedIn` to `false` and `username` to `null`.",
            "`getStatus()` after logout should return the initial state.",
            "Calling `login` with missing arguments (e.g., `login('user', null)`) should handle gracefully (e.g., log error, not change state)."
          ],
          "hints": [
            "Declare `_isLoggedIn`, `_username`, and `_token` within the IIFE's scope to make them private.",
            "Only expose `login`, `logout`, and `getStatus` in the returned object.",
            "Ensure `getStatus` explicitly omits the `_token` variable from its return value.",
            "Consider a private helper function for resetting state (`_resetSession`) to keep `logout` concise."
          ],
          "tags": [
            "module-pattern",
            "design-patterns",
            "authentication",
            "session-management",
            "encapsulation",
            "javascript"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "closures",
            "iife",
            "objects"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "information-hiding",
            "frontend-security-basics"
          ]
        },
        {
          "id": "task_pure_functions_1",
          "title": "Build a Pure Data Transformation Pipeline",
          "description": "\nCreate a set of pure functions and demonstrate how they can be composed to form a data transformation pipeline. The goal is to process an array of numbers through multiple steps, where each step is a pure function.\n\n**Requirements:**\n1.  **`map` function**: Implement a pure `map` function (similar to `Array.prototype.map`) that takes an array and a transformation function, and returns a new array with the transformed elements. (Do not use built-in `Array.prototype.map`).\n    `map(arr: number[], transformFn: (num: number) => number): number[]`\n2.  **`filter` function**: Implement a pure `filter` function (similar to `Array.prototype.filter`) that takes an array and a predicate function, and returns a new array with elements that satisfy the predicate. (Do not use built-in `Array.prototype.filter`).\n    `filter(arr: number[], predicateFn: (num: number) => boolean): number[]`\n3.  **Transformation Functions (Pure Closures)**:\n    *   `createMultiplier(factor: number): (num: number) => number` - A function factory that returns a pure function to multiply a number by a given `factor`.\n    *   `isEven(num: number): boolean` - A pure function that returns `true` if a number is even, `false` otherwise.\n4.  **Pipeline Construction**: Use these functions to create a pipeline that:\n    *   Takes an array of numbers.\n    *   Filters out odd numbers using `isEven`.\n    *   Multiplies the remaining numbers by 5 using `createMultiplier`.\n    *   Returns the final processed array.\n\nDemonstrate the purity of each function and the overall pipeline (i.e., inputs are not mutated, outputs are consistent for same inputs).\n\n**Example Usage:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Expected pipeline result:\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (filter isEven) -> [2, 4, 6, 8, 10]\n// [2, 4, 6, 8, 10] (map createMultiplier(5)) -> [10, 20, 30, 40, 50]\n\nconst processNumbers = (arr) => {\n  const evenNumbers = filter(arr, isEven);\n  const multiplyByFive = createMultiplier(5);\n  const result = map(evenNumbers, multiplyByFive);\n  return result;\n};\n\nconsole.log(processNumbers(numbers)); // Expected: [10, 20, 30, 40, 50]\nconsole.log(numbers); // Expected: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (original array unchanged)\n```\n",
          "difficulty": "hard",
          "startingCode": "function map(arr, transformFn) {\n  // TODO: Implement pure map function\n}\n\nfunction filter(arr, predicateFn) {\n  // TODO: Implement pure filter function\n}\n\nfunction createMultiplier(factor) {\n  // TODO: Implement pure function factory\n}\n\nfunction isEven(num) {\n  // TODO: Implement pure isEven function\n}\n\n// TODO: Construct the pipeline and demonstrate usage\n// const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n// const processNumbers = (arr) => {\n//   // ... pipeline steps ...\n// };\n// console.log(processNumbers(numbers));\n// console.log(numbers); // Should be unchanged\n",
          "solutionCode": "function map(arr, transformFn) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(transformFn(arr[i]));\n  }\n  return result; // Returns a new array, does not mutate original\n}\n\nfunction filter(arr, predicateFn) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (predicateFn(arr[i])) {\n      result.push(arr[i]);\n    }\n  }\n  return result; // Returns a new array, does not mutate original\n}\n\nfunction createMultiplier(factor) {\n  return function(num) {\n    return num * factor; // Pure: no side effects, deterministic\n  };\n}\n\nfunction isEven(num) {\n  return num % 2 === 0; // Pure: no side effects, deterministic\n}\n\n// --- Pipeline Construction and Demonstration ---\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nconsole.log('Original numbers:', numbers);\n\nconst processNumbers = (arr) => {\n  console.log('  Step 1: Filtering odd numbers...');\n  const evenNumbers = filter(arr, isEven); // Returns new array, original 'arr' unchanged\n  console.log('    Intermediate result (even numbers):', evenNumbers);\n\n  console.log('  Step 2: Creating multiplier function...');\n  const multiplyByFive = createMultiplier(5); // Pure function factory\n  \n  console.log('  Step 3: Multiplying even numbers by 5...');\n  const result = map(evenNumbers, multiplyByFive); // Returns new array, 'evenNumbers' unchanged\n  console.log('    Final result:', result);\n  \n  return result;\n};\n\nconsole.log('\\nRunning the pipeline:');\nconst finalResult = processNumbers(numbers);\nconsole.log('\\nFinal pipeline output:', finalResult);\n\nconsole.log('Original array after pipeline:', numbers); // Should be: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconsole.log('Is original array unchanged?', JSON.stringify(numbers) === JSON.stringify([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\n\n// Demonstrating purity by calling with same input again\nconsole.log('\\nRunning pipeline again with same input:');\nconst finalResult2 = processNumbers(numbers);\nconsole.log('Second pipeline output (should be same):', finalResult2);\nconsole.log('Are outputs consistent?', JSON.stringify(finalResult) === JSON.stringify(finalResult2));\n",
          "testCases": [
            "map([1, 2, 3], num => num * 2) should return [2, 4, 6] and not mutate original array.",
            "filter([1, 2, 3], num => num > 1) should return [2, 3] and not mutate original array.",
            "createMultiplier(10)(5) should return 50.",
            "isEven(4) should return true, isEven(7) should return false.",
            "The complete pipeline with `numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` should return `[10, 20, 30, 40, 50]`.",
            "The original `numbers` array should remain unchanged after pipeline execution.",
            "Running the pipeline multiple times with the same input should yield identical results."
          ],
          "hints": [
            "For `map` and `filter`, ensure you create a *new* array for the result, instead of modifying the input array. This is crucial for purity.",
            "`createMultiplier` will be a higher-order function that uses a closure to remember the `factor`.",
            "Think about how `isEven` inherently fits the definition of a pure function.",
            "The pipeline is simply a sequence of function calls, where the output of one becomes the input of the next."
          ],
          "tags": [
            "pure-functions",
            "functional-programming",
            "data-transformation",
            "closures",
            "higher-order-functions",
            "javascript"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "pure-functions",
            "closures",
            "array-methods-concept"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "function-composition",
            "immutability",
            "side-effects"
          ]
        }
      ]
    }
  },
  {
    "id": "f2eb5d98-8397-4336-a544-6545b075da2b",
    "startLine": 2400,
    "endLine": 2499,
    "processedDate": "2025-06-17T08:21:53.825Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_pure_functions_and_side_effects",
          "title": "Pure Functions and Side Effects",
          "content": "## Core Principles of Pure Functions\nPure functions are a fundamental concept in functional programming, offering significant benefits in terms of predictability, testability, and maintainability. A function is considered pure if it adheres to two strict rules:\n\n1.  **Determinism (Same Input, Same Output):** Given the same input arguments, a pure function will *always* produce the exact same output. It does not depend on any external state that might change between calls.\n2.  **No Side Effects:** A pure function does not cause any observable changes outside its local scope during its execution. This means it doesn't modify external variables, mutate data structures passed as arguments, perform I/O operations (like logging to console, network requests, or DOM manipulations), or trigger any other external state changes.\n\n### Understanding Side Effects\nSide effects are any actions a function performs that affect the world outside of itself. While necessary for real-world applications (e.g., displaying data, saving to a database), minimizing and isolating side effects is a key goal of functional programming. Examples of side effects include:\n*   Modifying a global variable or an object passed by reference.\n*   Logging to the console (`console.log`).\n*   Making network requests (e.g., `fetch`, `XMLHttpRequest`).\n*   Modifying the DOM.\n*   Writing to a database or file system.\n*   Throwing exceptions (if not handled internally).\n*   Getting the current time or a random number (as they are not deterministic).\n\n### Benefits of Pure Functions\n*   **Predictability:** Easier to reason about and understand, as their behavior is entirely determined by their inputs.\n*   **Testability:** Simple to test because they only require input arguments and produce predictable output. No complex setup or mocking of external states is needed.\n*   **Maintainability:** Less prone to bugs caused by unexpected interactions or hidden dependencies.\n*   **Cacheability (Memoization):** Their deterministic nature allows for caching results based on input, leading to performance optimizations.\n*   **Parallelization:** Can be run in parallel without fear of race conditions, as they don't share or modify mutable state.",
          "examples": [
            {
              "id": "example_pure_function_1",
              "title": "Pure Function Example",
              "code": "/**\n * A pure function that adds two numbers.\n * - Always returns the same result for the same inputs (e.g., add(2, 3) always returns 5).\n * - Has no side effects (doesn't modify external state or perform I/O).\n */\nfunction add(a, b) {\n  return a + b;\n}",
              "explanation": "This `add` function takes two numbers, `a` and `b`, and returns their sum. It's pure because it always produces the same output for the same inputs and doesn't modify anything outside its scope. It's perfectly predictable and easy to test.",
              "language": "javascript"
            },
            {
              "id": "example_impure_function_1",
              "title": "Impure Function Example (Relies on External State)",
              "code": "let c = 10;\n/**\n * An impure function that adds a number to an external variable 'c'.\n * - Its output depends on the external state of 'c', which can change.\n * - Modifies an external variable 'c' if it were to increment 'c' inside.\n */\nfunction addToC(x) {\n  return x + c; // Depends on external variable 'c'\n}\n\n// Demonstrating impurity:\nconsole.log(addToC(5)); // If c is 10, returns 15\nc = 20;\nconsole.log(addToC(5)); // If c is 20, returns 25 (different output for same input '5')",
              "explanation": "The `addToC` function is impure because its output depends on the external variable `c`. If `c` changes, the function's output will change even with the same input `x`. This violates the 'same input, same output' rule. If it were to modify `c` (e.g., `c += x;`), it would also have a side effect.",
              "language": "javascript"
            },
            {
              "id": "example_pure_function_closure_1",
              "title": "Creating a Pure Function using Closure (Currying Concept)",
              "code": "/**\n * A higher-order function that uses a closure to create a pure adder.\n * The returned inner function is pure because it only depends on its immediate inputs\n * and the 'a' value captured from its lexical environment, which remains constant.\n */\nfunction createPureAdder(a) {\n  // 'a' is captured in the closure. It acts as a fixed part of the inner function's context.\n  return function(b) {\n    return a + b; // 'a' is from the closure, 'b' is the explicit argument\n  };\n}\n\nconst add5 = createPureAdder(5);\nconsole.log(add5(10)); // Always returns 15 given input 10 (5 + 10)\nconsole.log(add5(20)); // Always returns 25 given input 20 (5 + 20)\n\nconst add10 = createPureAdder(10);\nconsole.log(add10(3)); // Always returns 13 given input 3 (10 + 3)",
              "explanation": "This example demonstrates how a closure can be used to create a pure function. `createPureAdder(a)` returns an inner function that 'remembers' the value of `a`. The inner function `(b) => a + b` is pure because for any given `b`, it will always produce the same result (since `a` is fixed by the closure), and it has no side effects. This pattern is related to currying, a functional programming technique.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "functional-programming",
            "pure-functions",
            "side-effects",
            "predictability",
            "testability",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "basic-functions",
            "scope",
            "closures"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react-hooks-principles",
            "redux-reducers",
            "functional-patterns"
          ]
        },
        {
          "id": "theory_closures_and_scope_in_loops",
          "title": "Closures and Scope in JavaScript: The `var` vs `let`/`const` Loop Problem",
          "content": "## Understanding Closures and Scope in Loops\nClosures allow a function to 'remember' and access variables from its lexical scope (the environment in which it was declared), even after that scope has closed. This behavior, when combined with JavaScript's different scoping rules for `var` and `let`/`const`, can lead to common pitfalls, especially in loops.\n\n### The `var` Problem in Loops\nWhen `var` is used to declare a loop counter (e.g., `for (var i = 0; i < 3; i++)`), `i` is function-scoped (or global if declared outside a function). This means there is only *one* `i` variable shared across all iterations of the loop. When functions are created inside such a loop and capture `i` in their closures, they all refer to this *single, shared* `i`. By the time these functions are executed later, the loop has already completed, and `i` will have its final value (e.g., 3 in a `for (var i = 0; i < 3; i++)` loop).\n\nThis leads to unexpected behavior where all functions logged `3` instead of `0, 1, 2`.\n\n### The `let`/`const` Solution\n`let` and `const` introduce block-scoping. When `let` (or `const`) is used as a loop counter (e.g., `for (let i = 0; i < 3; i++)`), a *new* lexical environment (and thus a new binding for `i`) is created for each iteration of the loop. This means that each function created inside the loop's body closes over a *distinct* `i` variable specific to that iteration's scope.\n\nConsequently, when these functions are executed, they correctly log the value of `i` from their respective iteration (0, 1, 2, etc.), as each closure 'remembers' its own `i`.",
          "examples": [
            {
              "id": "example_var_in_loop",
              "title": "Problem with `var` in Loops (Shared `i`)",
              "code": "// Problem with var in loops\nfunction createFunctions() {\n  var funcs = [];\n  \n  for (var i = 0; i < 3; i++) {\n    // Each function closes over the *same* 'i' variable.\n    // By the time these functions are called, 'i' is already 3.\n    funcs.push(function() {\n      console.log(i);\n    });\n  }\n  \n  return funcs;\n}\n\nconst functions = createFunctions();\nfunctions[0](); // Expected 0, but outputs 3\nfunctions[1](); // Expected 1, but outputs 3\nfunctions[2](); // Expected 2, but outputs 3",
              "explanation": "In this example, `i` is declared with `var`, making it function-scoped to `createFunctions`. All three anonymous functions created in the loop share the same binding to `i`. By the time `functions[0]()`, `functions[1]()`, and `functions[2]()` are called, the loop has completed, and `i` has incremented to `3`. Therefore, all functions log `3`.",
              "language": "javascript"
            },
            {
              "id": "example_let_in_loop",
              "title": "Solution using `let` (Block Scope per Iteration)",
              "code": "// Solution using let (block scope)\nfunction createFunctionsFixed() {\n  const funcs = [];\n  \n  for (let i = 0; i < 3; i++) {\n    // For each iteration, a *new* 'i' binding is created due to 'let's block scope.\n    // Each function closes over its own 'i' for that specific iteration.\n    funcs.push(function() {\n      console.log(i);\n    });\n  }\n  \n  return funcs;\n}\n\nconst fixedFunctions = createFunctionsFixed();\nfixedFunctions[0](); // Outputs 0\nfixedFunctions[1](); // Outputs 1\nfixedFunctions[2](); // Outputs 2",
              "explanation": "Here, `i` is declared with `let`, giving it block scope. Crucially, in a `for` loop, `let` creates a *new* lexical environment (and thus a new `i`) for each iteration. This means that each function in `funcs` closes over a *distinct* `i` value corresponding to its iteration (0, 1, and 2 respectively). When executed, each function logs its own captured `i`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "closures",
            "scope",
            "var",
            "let",
            "const",
            "hoisting",
            "loops",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "scope",
            "functions",
            "closures-basic"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "event-listeners-in-loops",
            "advanced-javascript-patterns"
          ]
        },
        {
          "id": "theory_closures_and_module_pattern",
          "title": "Closures: Data Privacy and the Module Pattern",
          "content": "## Closures for Data Privacy\nClosures are incredibly powerful for creating data privacy and encapsulation in JavaScript. They allow you to associate data with a function that operates on that data, effectively creating 'private' variables and functions that are not directly accessible from the outside world. This is a common pattern in object-oriented programming where objects encapsulate their state and expose methods to interact with it.\n\nBy leveraging closures, you can define variables and functions within an outer function's scope, and then return inner functions that have access to these 'private' members. The outer function's scope persists as long as the inner functions (which form the closure) are accessible.\n\n### The Module Pattern\nThe Module Pattern is a popular design pattern in JavaScript that takes advantage of closures to implement encapsulation, mimicking classes with private and public members before native class syntax was widespread (and still relevant for various reasons). It typically involves an Immediately Invoked Function Expression (IIFE) that returns an object containing public methods. These public methods, being closures, have access to the private variables and functions defined within the IIFE's scope.\n\n#### Key characteristics of the Module Pattern:\n*   **IIFE (Immediately Invoked Function Expression):** The outer function is an IIFE, which creates a private scope for variables and functions. It runs immediately and its scope is then closed.\n*   **Private Members:** Variables and functions declared inside the IIFE are not directly accessible from outside, acting as private members.\n*   **Public Interface:** The IIFE returns an object literal that exposes selected methods (functions) or properties. These returned methods form the public interface of the module.\n*   **Encapsulation:** The public methods have access to the private members via closure, allowing them to operate on the module's internal state without exposing that state globally.\n\nThis pattern helps avoid polluting the global namespace and promotes a cleaner, more organized codebase, making it easier to manage state and dependencies.",
          "examples": [
            {
              "id": "example_module_pattern_counter",
              "title": "Module Pattern: Counter Example",
              "code": "const Counter = (function() {\n  // privateCounter is a 'private' variable, accessible only within the IIFE's scope\n  let privateCounter = 0;\n  \n  // changeBy is a 'private' function, also only accessible within this scope\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  \n  // The IIFE returns an object, which becomes the public interface of the Counter module\n  return {\n    increment: function() {\n      // This public method accesses and modifies privateCounter via the changeBy private function\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      // This public method provides read-only access to privateCounter\n      return privateCounter;\n    }\n  };\n})(); // The () immediately invokes the function\n\n// Usage of the public interface:\nCounter.increment();\nCounter.increment();\nconsole.log(Counter.value()); // Outputs: 2\nCounter.decrement();\nconsole.log(Counter.value()); // Outputs: 1\n\n// Attempting to access private members directly fails:\n// console.log(Counter.privateCounter); // Undefined\n// Counter.changeBy(5); // TypeError: Counter.changeBy is not a function",
              "explanation": "This `Counter` example showcases the module pattern. The IIFE creates a closed-off scope where `privateCounter` and `changeBy` reside, making them private. The returned object exposes `increment`, `decrement`, and `value` as public methods. These public methods form closures over the private scope, allowing them to access and manipulate `privateCounter` without `privateCounter` itself being directly exposed to the global scope. This provides excellent encapsulation.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "closures",
            "module-pattern",
            "data-privacy",
            "IIFE",
            "encapsulation",
            "design-patterns",
            "javascript",
            "oop"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures-basic",
            "IIFE",
            "objects",
            "scope"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "javascript-design-patterns",
            "frontend-architecture",
            "state-management-concepts"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_pure_functions_mcq_1",
          "topic": "Pure Functions and Side Effects",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following functions is considered a pure function?",
          "answer": "Option A: `function sum(a, b) { return a + b; }`",
          "options": [
            "Option A: `function sum(a, b) { return a + b; }`",
            "Option B: `let count = 0; function increment() { count++; return count; }`",
            "Option C: `function logMessage(message) { console.log(message); return message; }`",
            "Option D: `function fetchData(url) { return fetch(url); }`"
          ],
          "analysisPoints": [
            "Identifies functions that always return the same output for the same input.",
            "Recognizes functions that have no side effects (e.g., modifying external state, I/O operations)."
          ],
          "keyConcepts": [
            "Pure functions",
            "Side effects",
            "Determinism"
          ],
          "evaluationCriteria": [
            "Understanding of pure function definition.",
            "Ability to distinguish between pure and impure functions based on side effects and determinism."
          ],
          "example": "Option A is a pure function because it only depends on its inputs `a` and `b` and produces a result without causing any external changes. Options B, C, and D all have side effects:\n- Option B modifies an external variable `count`.\n- Option C performs I/O by logging to the console.\n- Option D performs a network request (I/O).",
          "tags": [
            "pure-functions",
            "functional-programming",
            "side-effects",
            "mcq"
          ],
          "prerequisites": [
            "basic-functions"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_pure_functions_open_1",
          "topic": "Pure Functions and Side Effects",
          "level": "medium",
          "type": "open",
          "question": "Explain the two main characteristics that define a pure function. What are the primary benefits of using pure functions in software development?",
          "answer": "A pure function has two main characteristics:\n1.  **Determinism (Same Input, Same Output):** For the same set of input arguments, it will always produce the exact same output. It does not rely on any external, mutable state.\n2.  **No Side Effects:** It does not cause any observable changes outside its local scope. This means it doesn't modify external variables, perform I/O operations (like logging, network requests, DOM manipulation), or mutate its input arguments.\n\nPrimary benefits include:\n*   **Predictability:** Easier to reason about and understand, as their behavior is entirely determined by their inputs.\n*   **Testability:** Simple to test because they only require input arguments and produce predictable output. No complex setup or mocking of external states is needed.\n*   **Maintainability:** Less prone to bugs caused by unexpected interactions or hidden dependencies, leading to more robust and easier-to-debug code.\n*   **Cacheability (Memoization):** Their deterministic nature allows for caching results based on input, leading to performance optimizations.\n*   **Parallelization:** Can be run in parallel without fear of race conditions, as they don't share or modify mutable state.",
          "analysisPoints": [
            "Detailed explanation of determinism and no side effects.",
            "Comprehensive listing of benefits (at least 3-4)."
          ],
          "keyConcepts": [
            "Pure functions",
            "Side effects",
            "Determinism",
            "Testability",
            "Maintainability",
            "Memoization"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of definition.",
            "Ability to articulate practical advantages.",
            "Use of correct terminology."
          ],
          "example": "This question tests a candidate's theoretical understanding of pure functions and their practical implications in software design.",
          "tags": [
            "pure-functions",
            "functional-programming",
            "side-effects",
            "open-ended"
          ],
          "prerequisites": [
            "functional-programming-concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pure_functions_code_1",
          "topic": "Pure Functions and Side Effects",
          "level": "medium",
          "type": "code",
          "question": "The following function is impure. Refactor it to be a pure function. The goal is to calculate the total price including a sales tax. The original function relies on a global `taxRate` and modifies a global `totalSales` variable. Your pure function should take all necessary data as arguments and return the calculated total, without any side effects.",
          "answer": "```javascript\n// Original impure function (for context - not part of the pure solution)\nlet taxRate = 0.05; // Global state\nlet totalSales = 0; // Global state\n\nfunction calculateImpureTotalPrice(price) {\n  const taxedPrice = price * (1 + taxRate);\n  totalSales += taxedPrice; // Side effect: modifies global state\n  return taxedPrice;\n}\n\n// Pure function refactor:\nfunction calculatePureTotalPrice(price, rate) {\n  return price * (1 + rate);\n}\n\n// Example usage:\nconst itemPrice = 100;\nconst currentTaxRate = 0.08; // Passed as argument, not global\nconst finalPrice = calculatePureTotalPrice(itemPrice, currentTaxRate);\nconsole.log(finalPrice); // 108\n\n// Original global states remain untouched\n// console.log(taxRate); // 0.05\n// console.log(totalSales); // 0\n```",
          "options": [],
          "analysisPoints": [
            "Successfully identifies and removes reliance on global state.",
            "Eliminates side effects (e.g., modifying `totalSales`).",
            "Ensures all necessary inputs are passed as arguments.",
            "Returns the calculated value without altering external environment."
          ],
          "keyConcepts": [
            "Pure functions",
            "Side effects",
            "Function arguments",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Correct implementation of a pure function.",
            "Demonstrates understanding of functional programming principles.",
            "Code cleanliness and readability."
          ],
          "example": "This task requires the candidate to identify sources of impurity (global state dependency, global state modification) and refactor the function to strictly adhere to pure function principles by passing all dependencies as arguments and avoiding external state changes.",
          "tags": [
            "pure-functions",
            "refactoring",
            "code-challenge",
            "functional-programming"
          ],
          "prerequisites": [
            "javascript-functions",
            "variables"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pure_functions_flashcard_1",
          "topic": "Pure Functions and Side Effects",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a 'side effect' in the context of functions?",
          "answer": "A 'side effect' refers to any observable change to the state of a system outside the function's local scope, or any interaction with the outside world (e.g., I/O operations).",
          "options": [],
          "analysisPoints": [
            "Defines side effect concisely."
          ],
          "keyConcepts": [
            "Side effects",
            "Pure functions"
          ],
          "evaluationCriteria": [
            "Accurate definition recall."
          ],
          "example": "Examples of side effects include modifying global variables, logging to the console, making network requests, or altering the DOM.",
          "tags": [
            "pure-functions",
            "side-effects",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_closures_loops_mcq_1",
          "topic": "Closures and Scope in Loops",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n```javascript\nfunction createGreetingFunctions() {\n  const greetings = [];\n  for (var i = 0; i < 3; i++) {\n    greetings.push(function() {\n      console.log('Hello ' + i);\n    });\n  }\n  return greetings;\n}\n\nconst myGreetings = createGreetingFunctions();\nmyGreetings[0]();\nmyGreetings[1]();\nmyGreetings[2]();\n```\nWhat will be the output when `myGreetings[0](); myGreetings[1](); myGreetings[2]();` are executed?",
          "answer": "Option C: Three times 'Hello 3'",
          "options": [
            "Option A: 'Hello 0', 'Hello 1', 'Hello 2'",
            "Option B: 'Hello undefined', 'Hello undefined', 'Hello undefined'",
            "Option C: Three times 'Hello 3'",
            "Option D: 'Hello 0', 'Hello 0', 'Hello 0'"
          ],
          "analysisPoints": [
            "Understanding of `var`'s function scope.",
            "Understanding of how closures capture variables by reference, not by value, in the context of `var`.",
            "Knowledge that the loop variable `i` will have its final value when the functions are executed."
          ],
          "keyConcepts": [
            "Closures",
            "var scope",
            "Loop behavior",
            "Lexical environment"
          ],
          "evaluationCriteria": [
            "Correctly predicts the output based on `var` scoping rules.",
            "Demonstrates understanding of the 'common closure mistake' with `var`."
          ],
          "example": "The variable `i` is declared with `var`, which has function scope. There is only one `i` variable shared across all iterations. By the time `myGreetings[0]()`, `myGreetings[1]()`, and `myGreetings[2]()` are called, the loop has already completed, and `i` has been incremented to its final value of `3`. All three functions close over this same, final `i`, leading to 'Hello 3' being logged three times.",
          "tags": [
            "closures",
            "var",
            "scope",
            "loops",
            "javascript",
            "mcq"
          ],
          "prerequisites": [
            "scope",
            "closures-basic"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_closures_loops_open_1",
          "topic": "Closures and Scope in Loops",
          "level": "medium",
          "type": "open",
          "question": "Explain why using `var` for the loop counter in a `for` loop, when creating functions that close over that counter, leads to unexpected results (e.g., all functions logging the final value of the counter), and how using `let` resolves this issue. Provide a conceptual example.",
          "answer": "When `var` is used for a loop counter (e.g., `for (var i = 0; i < 3; i++)`), `i` is function-scoped (or global). This means there is only *one single instance* of `i` throughout the entire function's execution. When functions are created inside the loop and reference `i`, they form a closure over this *single shared `i` variable*. By the time these inner functions are actually called (after the loop has finished), `i` has already iterated to its final value (e.g., `3`). Consequently, all functions log this final value.\n\nUsing `let` (or `const`) resolves this because `let` has block scope. In the context of a `for` loop, `let` creates a *new lexical environment and a new binding for the loop variable for each iteration*. This means that each function created inside the loop's body closes over a *distinct, separate `i` variable* specific to its particular iteration. Therefore, when these functions are executed, they correctly access the `i` value from their own captured lexical environment, producing the expected sequence (0, 1, 2).\n\n**Conceptual Example:**\n`var`'s behavior is like handing out slips of paper to three people, all saying 'refer to the value in box X'. When box X is finally `3`, all three people will read `3`.\n`let`'s behavior is like handing out slips of paper to three people, each saying 'refer to the value in *your own personal* box X', and for each person, their box X contains a different, specific number (0, 1, or 2) from when their slip was created.",
          "analysisPoints": [
            "Clearly distinguishes `var` (function scope, single binding) from `let` (block scope, new binding per iteration).",
            "Explains how closures interact with these scoping rules.",
            "Provides a clear conceptual example to solidify understanding."
          ],
          "keyConcepts": [
            "Closures",
            "var",
            "let",
            "function scope",
            "block scope",
            "lexical environment",
            "loop behavior"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation regarding scoping.",
            "Clarity of the conceptual difference.",
            "Completeness of the answer."
          ],
          "example": "This question assesses the depth of understanding of JavaScript's scoping rules and closures, particularly a common interview scenario.",
          "tags": [
            "closures",
            "var",
            "let",
            "scope",
            "loops",
            "open-ended"
          ],
          "prerequisites": [
            "scope",
            "closures-basic"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_closures_loops_code_1",
          "topic": "Closures and Scope in Loops",
          "level": "easy",
          "type": "code",
          "question": "Modify the following code snippet to ensure that when `funcs[0]()`, `funcs[1]()`, and `funcs[2]()` are called, they output `0`, `1`, and `2` respectively, instead of `3` three times.",
          "answer": "```javascript\nfunction createFunctions() {\n  const funcs = [];\n  \n  for (let i = 0; i < 3; i++) { // Changed 'var' to 'let'\n    funcs.push(function() {\n      console.log(i);\n    });\n  }\n  \n  return funcs;\n}\n\nconst fixedFunctions = createFunctions();\nfixedFunctions[0](); // Expected: 0\nfixedFunctions[1](); // Expected: 1\nfixedFunctions[2](); // Expected: 2\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies `var` as the source of the problem.",
            "Applies `let` as the solution."
          ],
          "keyConcepts": [
            "Closures",
            "let",
            "block scope",
            "looping"
          ],
          "evaluationCriteria": [
            "Correct implementation.",
            "Efficiency of solution."
          ],
          "example": "The simplest and most modern solution is to change `var i` to `let i`. `let` creates a new `i` binding for each iteration of the loop, ensuring that each function closes over its unique `i` value.",
          "tags": [
            "closures",
            "let",
            "scope",
            "loops",
            "code-challenge"
          ],
          "prerequisites": [
            "var-let-const",
            "closures-basic"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_closures_loops_flashcard_1",
          "topic": "Closures and Scope in Loops",
          "level": "easy",
          "type": "flashcard",
          "question": "In a `for` loop, what is the primary difference in scoping behavior between `var i` and `let i` when a function is declared inside the loop and accesses `i`?",
          "answer": "`var i` creates a single, function-scoped `i` that all inner functions close over, leading to them all seeing the final value of `i`. `let i` creates a new, block-scoped `i` for each iteration of the loop, so each inner function closes over its own unique `i` from its specific iteration.",
          "options": [],
          "analysisPoints": [
            "Highlights the key difference: single shared `var` vs. new `let` per iteration."
          ],
          "keyConcepts": [
            "var",
            "let",
            "function scope",
            "block scope",
            "closures"
          ],
          "evaluationCriteria": [
            "Accurate and concise explanation."
          ],
          "example": "This is a common interview question to quickly gauge understanding of `var` vs. `let` with closures.",
          "tags": [
            "closures",
            "var",
            "let",
            "scope",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_module_pattern_mcq_1",
          "topic": "Closures and the Module Pattern",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following implementation of the Module Pattern:\n```javascript\nconst MyModule = (function() {\n  let secretData = 'Top Secret';\n\n  function revealSecret() {\n    return secretData;\n  }\n\n  return {\n    getSecret: function() {\n      return revealSecret();\n    },\n    changeSecret: function(newSecret) {\n      secretData = newSecret;\n    }\n  };\n})();\n\nconsole.log(MyModule.getSecret());\nMyModule.changeSecret('New Secret');\nconsole.log(MyModule.getSecret());\n// console.log(MyModule.secretData); // Will cause error or be undefined\n```\nWhich statement accurately describes `secretData` and `revealSecret` in this module?",
          "answer": "Option A: `secretData` and `revealSecret` are private members, accessible only via the public methods `getSecret` and `changeSecret`.",
          "options": [
            "Option A: `secretData` and `revealSecret` are private members, accessible only via the public methods `getSecret` and `changeSecret`.",
            "Option B: `secretData` is private, but `revealSecret` is public because it's a function.",
            "Option C: Both `secretData` and `revealSecret` are public and can be accessed directly using `MyModule.secretData` and `MyModule.revealSecret()`.",
            "Option D: `secretData` and `revealSecret` are global variables and functions."
          ],
          "analysisPoints": [
            "Understanding of the IIFE's role in creating a private scope.",
            "Identification of what constitutes 'private' vs. 'public' in the Module Pattern.",
            "Recognition of how closures enable public methods to access private data."
          ],
          "keyConcepts": [
            "Module Pattern",
            "Closures",
            "IIFE",
            "Encapsulation",
            "Private members",
            "Public interface"
          ],
          "evaluationCriteria": [
            "Correctly identifies private and public parts of a module.",
            "Demonstrates understanding of data encapsulation via closures."
          ],
          "example": "In the Module Pattern, variables and functions defined within the IIFE (like `secretData` and `revealSecret`) are encapsulated and remain private to that scope. They are not directly exposed to the outside. Only the methods returned in the public interface (like `getSecret` and `changeSecret`) can access them, leveraging closures.",
          "tags": [
            "module-pattern",
            "closures",
            "encapsulation",
            "design-patterns",
            "mcq"
          ],
          "prerequisites": [
            "closures-basic",
            "IIFE"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_module_pattern_open_1",
          "topic": "Closures and the Module Pattern",
          "level": "hard",
          "type": "open",
          "question": "Describe the JavaScript Module Pattern. How does it leverage closures to achieve encapsulation and data privacy? Discuss its main advantages and disadvantages compared to ES6 Modules or JavaScript classes.",
          "answer": "The **Module Pattern** is a JavaScript design pattern that provides a way to encapsulate 'private' variables and methods, while exposing a 'public' interface. It typically involves an Immediately Invoked Function Expression (IIFE) that returns an object containing public methods.\n\n**How it leverages Closures for Encapsulation:**\n1.  **Private Scope:** The IIFE creates a new function scope. Any variables (`let`, `const`, `var`) or functions declared inside this IIFE are private to that scope and cannot be directly accessed from outside the IIFE.\n2.  **Public Interface:** The IIFE returns an object (or a single function) that contains the methods and properties intended to be public.\n3.  **Closure:** The public methods returned by the IIFE are closures. They 'remember' and can access the variables and functions from their parent (the IIFE's) scope, even after the IIFE has finished executing. This allows the public methods to operate on the 'private' data while keeping that data hidden from external direct access, thereby achieving data privacy and encapsulation.\n\n**Advantages:**\n*   **Data Privacy/Encapsulation:** Excellent for hiding internal implementation details and preventing global namespace pollution.\n*   **Clear Separation:** Provides a clear distinction between private and public members.\n*   **No Global Variables:** Reduces the risk of naming conflicts.\n*   **Legacy Browser Support:** Works in older JavaScript environments without transpilation (unlike ES6 modules or classes).\n*   **Singletons:** Easily create a single instance of a module.\n\n**Disadvantages:**\n*   **Debugging:** Accessing private members in a debugger can be tricky.\n*   **Extensibility/Inheritance:** Not straightforward to extend or inherit from modules created this way compared to classes.\n*   **Readability (for new developers):** The IIFE syntax might be less intuitive than `class` or `import/export`.\n*   **No Private Methods (strictly):** While methods declared inside are 'private' in access, they are not strictly private in the same way `#private` fields in ES classes are.\n\n**Comparison to ES6 Modules/Classes:**\n*   **ES6 Modules (`import`/`export`):** Provide a native, standardized way for modularity. They inherently create a private scope for each module file. Unlike the Module Pattern's IIFE, ES6 modules are statically resolved (at compile time/parse time), enabling tree-shaking and better tooling. They don't require an IIFE, making syntax cleaner. The Module Pattern is primarily for browser environments without native module support or when creating a 'singleton' instance. ES6 Modules are the modern standard for modularity.\n*   **JavaScript Classes (`class` keyword):** Primarily focused on object-oriented programming with constructors, methods, and inheritance. While they provide encapsulation, their traditional private members were achieved through conventions (e.g., `_propertyName`) until recently with `#private` fields. The Module Pattern focuses on creating singleton instances or factories for related functionality, while classes are for creating multiple instances of objects with similar behavior. Classes are generally better for inheritance and defining blueprints for objects.",
          "analysisPoints": [
            "Comprehensive explanation of the Module Pattern and its components.",
            "Detailed explanation of how closures enable encapsulation.",
            "Thorough discussion of advantages and disadvantages.",
            "Clear comparison with ES6 Modules and Classes, highlighting key differences in purpose, syntax, and benefits."
          ],
          "keyConcepts": [
            "Module Pattern",
            "Closures",
            "IIFE",
            "Encapsulation",
            "Data privacy",
            "ES6 Modules",
            "JavaScript Classes",
            "Design patterns"
          ],
          "evaluationCriteria": [
            "Depth of understanding of all related concepts.",
            "Ability to articulate complex relationships and comparisons.",
            "Structure and clarity of explanation."
          ],
          "example": "This question tests advanced JavaScript knowledge, combining understanding of closures with design patterns and modern language features. It requires a nuanced answer.",
          "tags": [
            "module-pattern",
            "closures",
            "encapsulation",
            "design-patterns",
            "ES6-modules",
            "classes",
            "open-ended"
          ],
          "prerequisites": [
            "closures-advanced",
            "IIFE",
            "ES6-modules",
            "javascript-classes"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_module_pattern_code_1",
          "topic": "Closures and the Module Pattern",
          "level": "medium",
          "type": "code",
          "question": "Implement a `ShoppingCart` module using the Module Pattern. It should have:\n-   A private array `items` to store products (each product is an object `{ name: string, price: number }`).\n-   A private helper function `calculateTotal` that sums up the prices of all items.\n-   Public methods:\n    -   `addItem(product)`: Adds a product to the `items` array.\n    -   `removeItem(productName)`: Removes a product by name from the `items` array.\n    -   `getTotal()`: Returns the total price of all items using `calculateTotal`.\n    -   `getCartContents()`: Returns a copy of the `items` array to prevent external mutation.",
          "answer": "```javascript\nconst ShoppingCart = (function() {\n  let items = []; // Private array to store items\n\n  // Private helper function\n  function calculateTotal() {\n    return items.reduce((sum, item) => sum + item.price, 0);\n  }\n\n  return { // Public interface\n    addItem: function(product) {\n      if (product && typeof product.name === 'string' && typeof product.price === 'number') {\n        items.push(product);\n        console.log(`${product.name} added.`);\n      } else {\n        console.warn('Invalid product object.');\n      }\n    },\n    removeItem: function(productName) {\n      const initialLength = items.length;\n      items = items.filter(item => item.name !== productName);\n      if (items.length < initialLength) {\n        console.log(`${productName} removed.`);\n      } else {\n        console.log(`${productName} not found in cart.`);\n      }\n    },\n    getTotal: function() {\n      return calculateTotal();\n    },\n    getCartContents: function() {\n      // Return a copy to prevent external mutation of the private 'items' array\n      return [...items]; \n    }\n  };\n})();\n\n// Example usage:\nShoppingCart.addItem({ name: 'Laptop', price: 1200 });\nShoppingCart.addItem({ name: 'Mouse', price: 25 });\nShoppingCart.addItem({ name: 'Keyboard', price: 75 });\n\nconsole.log('Current cart:', ShoppingCart.getCartContents());\nconsole.log('Total:', ShoppingCart.getTotal()); // Expected: 1300\n\nShoppingCart.removeItem('Mouse');\nconsole.log('Current cart after removal:', ShoppingCart.getCartContents());\nconsole.log('New total:', ShoppingCart.getTotal()); // Expected: 1275\n\nShoppingCart.addItem({ name: 'Monitor', price: 300 });\nconsole.log('Final total:', ShoppingCart.getTotal()); // Expected: 1575\n\n// Attempt to access private members (will fail/be undefined):\n// console.log(ShoppingCart.items);\n// console.log(ShoppingCart.calculateTotal());\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses an IIFE to establish a private scope.",
            "Defines private variables and functions within the IIFE.",
            "Exposes public methods through the returned object.",
            "Public methods correctly access private members via closure.",
            "Handles data immutability for `getCartContents` by returning a copy.",
            "Includes basic input validation for `addItem`."
          ],
          "keyConcepts": [
            "Module Pattern",
            "Closures",
            "IIFE",
            "Encapsulation",
            "Data privacy",
            "Array methods (filter, reduce, spread)",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Adherence to the Module Pattern structure.",
            "Correct implementation of all required functionalities.",
            "Demonstrates understanding of data privacy and immutability.",
            "Cleanliness and robustness of code."
          ],
          "example": "This task tests the practical application of the Module Pattern to build a common frontend component, emphasizing data encapsulation and preventing direct manipulation of internal state.",
          "tags": [
            "module-pattern",
            "closures",
            "encapsulation",
            "data-structures",
            "code-challenge"
          ],
          "prerequisites": [
            "closures-basic",
            "IIFE",
            "array-methods"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_module_pattern_flashcard_1",
          "topic": "Closures and the Module Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the Immediately Invoked Function Expression (IIFE) in the JavaScript Module Pattern?",
          "answer": "The primary purpose of the IIFE in the Module Pattern is to create a private scope for variables and functions, preventing them from polluting the global namespace and ensuring they are not directly accessible from outside.",
          "options": [],
          "analysisPoints": [
            "Identifies IIFE's role in creating private scope.",
            "Mentions preventing global namespace pollution."
          ],
          "keyConcepts": [
            "IIFE",
            "Module Pattern",
            "Scope",
            "Global namespace"
          ],
          "evaluationCriteria": [
            "Accurate recall of IIFE's role."
          ],
          "example": "The IIFE creates a 'sandbox' where private logic resides, exposing only what is explicitly returned.",
          "tags": [
            "IIFE",
            "module-pattern",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_pure_functions_1",
          "title": "Implement a Pure Data Transformation Utility",
          "description": "\nImplement a `transformUserData` pure function that takes an array of raw user objects and a configuration object, and returns a new array of processed user objects. The function should perform the following transformations:\n\n1.  **Filter by Active Status**: Only include users where `isActive` is `true`.\n2.  **Add `fullName`**: Create a `fullName` property by concatenating `firstName` and `lastName`.\n3.  **Anonymize Email (optional)**: If `config.anonymizeEmail` is `true`, replace the `email` property with a placeholder like `'anonymized@example.com'`.\n4.  **Select Fields**: Only include the fields specified in `config.fieldsToInclude` (e.g., `['id', 'fullName', 'email']`).\n\n**Requirements:**\n*   The function must be **pure**: it should not modify the input `users` array or `config` object, and it should not have any side effects.\n*   Return a new array of objects.\n*   Handle cases where `config.anonymizeEmail` or `config.fieldsToInclude` might be missing or invalid.\n",
          "difficulty": "medium",
          "startingCode": "/**\n * Transforms an array of user data based on a configuration.\n * This function must be pure.\n * \n * @param {Array<Object>} users - An array of raw user objects.\n * @param {Object} config - Configuration object.\n * @param {boolean} [config.anonymizeEmail=false] - Whether to anonymize user emails.\n * @param {Array<string>} [config.fieldsToInclude=['id', 'firstName', 'lastName', 'email', 'isActive']] - Array of fields to include in the output objects.\n * @returns {Array<Object>} A new array of transformed user objects.\n */\nfunction transformUserData(users, config = {}) {\n  // TODO: Implement the required functionality\n  // 1. Filter by isActive\n  // 2. Add fullName\n  // 3. Anonymize email (conditionally)\n  // 4. Select fields\n\n  // Ensure config has default values if properties are missing\n  const effectiveConfig = {\n    anonymizeEmail: false,\n    fieldsToInclude: ['id', 'firstName', 'lastName', 'email', 'isActive'],\n    ...config\n  };\n\n  return []; // Replace with your implementation\n}\n",
          "solutionCode": "/**\n * Transforms an array of user data based on a configuration.\n * This function must be pure.\n * \n * @param {Array<Object>} users - An array of raw user objects.\n * @param {Object} config - Configuration object.\n * @param {boolean} [config.anonymizeEmail=false] - Whether to anonymize user emails.\n * @param {Array<string>} [config.fieldsToInclude=['id', 'firstName', 'lastName', 'email', 'isActive']] - Array of fields to include in the output objects.\n * @returns {Array<Object>} A new array of transformed user objects.\n */\nfunction transformUserData(users, config = {}) {\n  // Ensure config has default values and immutability\n  const effectiveConfig = {\n    anonymizeEmail: typeof config.anonymizeEmail === 'boolean' ? config.anonymizeEmail : false,\n    fieldsToInclude: Array.isArray(config.fieldsToInclude) ? [...config.fieldsToInclude] : ['id', 'firstName', 'lastName', 'email', 'isActive'],\n    // Deep copy other properties if needed, but for primitive config, spread is fine.\n    ...config\n  };\n\n  if (!Array.isArray(users)) {\n    return []; // Handle invalid input gracefully for purity\n  }\n\n  const processedUsers = users\n    .filter(user => user && user.isActive === true) // 1. Filter by Active Status\n    .map(user => {\n      // Create a new user object to avoid mutating the original\n      const newUser = { ...user };\n\n      // 2. Add fullName\n      if (newUser.firstName && newUser.lastName) {\n        newUser.fullName = `${newUser.firstName} ${newUser.lastName}`;\n      }\n\n      // 3. Anonymize Email (conditionally)\n      if (effectiveConfig.anonymizeEmail && newUser.email) {\n        newUser.email = 'anonymized@example.com';\n      }\n\n      return newUser;\n    })\n    .map(user => {\n      // 4. Select Fields\n      const selectedFieldsUser = {};\n      effectiveConfig.fieldsToInclude.forEach(field => {\n        if (user.hasOwnProperty(field)) {\n          selectedFieldsUser[field] = user[field];\n        }\n      });\n      return selectedFieldsUser;\n    });\n\n  return processedUsers;\n}\n\n",
          "testCases": [
            "Test Case 1: Basic filtering and full name generation\n   Input: `users = [{ id: 1, firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com', isActive: true }, { id: 2, firstName: 'Bob', lastName: 'Johnson', email: 'bob@example.com', isActive: false }]`, `config = {}`\n   Expected: `[{ id: 1, firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com', isActive: true, fullName: 'Alice Smith' }]`\n",
            "Test Case 2: Anonymize email and specific fields\n   Input: `users = [{ id: 1, firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com', isActive: true }]`, `config = { anonymizeEmail: true, fieldsToInclude: ['id', 'fullName', 'email'] }`\n   Expected: `[{ id: 1, fullName: 'Alice Smith', email: 'anonymized@example.com' }]`\n",
            "Test Case 3: Empty users array\n   Input: `users = []`, `config = {}`\n   Expected: `[]`\n",
            "Test Case 4: No active users\n   Input: `users = [{ id: 1, firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com', isActive: false }]`, `config = {}`\n   Expected: `[]`\n",
            "Test Case 5: Missing fields in input user objects\n   Input: `users = [{ id: 3, isActive: true, firstName: 'Charlie' }]`, `config = { fieldsToInclude: ['id', 'fullName', 'email'] }`\n   Expected: `[{ id: 3, fullName: 'Charlie undefined' }]` (or `null` for missing part of name, depending on desired robustness)\n",
            "Test Case 6: Invalid `fieldsToInclude` in config\n   Input: `users = [{ id: 1, firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com', isActive: true }]`, `config = { fieldsToInclude: null }`\n   Expected: `[{ id: 1, firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com', isActive: true, fullName: 'Alice Smith' }]` (should use default fields)\n"
          ],
          "hints": [
            "Remember to use non-mutating array methods like `filter` and `map`.",
            "When transforming objects, always create new objects (`{...user}`) to avoid side effects on the original data.",
            "Default parameter values or object destructuring with defaults can help handle missing configuration properties elegantly.",
            "Consider chaining `filter` and `map` operations for clarity."
          ],
          "tags": [
            "pure-functions",
            "functional-programming",
            "array-methods",
            "data-transformation",
            "immutability"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "pure-functions",
            "array-methods",
            "object-spread-syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "functional-programming-patterns",
            "data-immutability",
            "higher-order-functions"
          ]
        },
        {
          "id": "task_closures_loops_1",
          "title": "Create a Dynamic Click Handler Factory",
          "description": "\nImplement a function `createClickHandlers` that takes an array of `items` (strings). For each item, it should generate a click handler function. When a generated handler is invoked, it should `console.log` a message indicating which specific item it corresponds to. This task explicitly tests your understanding of closures in loops.\n\n**Requirements:**\n*   The `createClickHandlers` function should return an array of functions.\n*   Each function in the returned array, when called, must `console.log` the correct item name corresponding to its position in the original array (e.g., the first function logs the first item, the second logs the second, etc.).\n*   You *must* use a loop (e.g., `for` loop).\n*   Ensure the solution correctly uses closures to capture the correct `item` for each handler, similar to how `let` fixes the `var` loop problem.\n",
          "difficulty": "medium",
          "startingCode": "/**\n * Creates an array of click handler functions, each logging a specific item.\n * @param {Array<string>} items - An array of item names.\n * @returns {Array<Function>} An array of functions, where each function logs a specific item.\n */\nfunction createClickHandlers(items) {\n  const handlers = [];\n\n  for (let i = 0; i < items.length; i++) {\n    // TODO: Create a function that closes over the correct item for this iteration.\n    // Push this function into the 'handlers' array.\n  }\n\n  return handlers;\n}\n\n// Example Usage (for testing):\n// const productNames = ['Apple', 'Banana', 'Cherry'];\n// const productClickHandlers = createClickHandlers(productNames);\n// productClickHandlers[0](); // Should log: 'Clicked on: Apple'\n// productClickHandlers[1](); // Should log: 'Clicked on: Banana'\n// productClickHandlers[2](); // Should log: 'Clicked on: Cherry'\n",
          "solutionCode": "/**\n * Creates an array of click handler functions, each logging a specific item.\n * @param {Array<string>} items - An array of item names.\n * @returns {Array<Function>} An array of functions, where each function logs a specific item.\n */\nfunction createClickHandlers(items) {\n  const handlers = [];\n\n  for (let i = 0; i < items.length; i++) {\n    // Using 'let' ensures that a new 'i' (and thus a new 'item' lookup) is bound for each iteration,\n    // and the closure captures the 'item' value specific to that iteration.\n    const item = items[i]; // Explicitly capture item for clarity, though not strictly necessary with 'let i'\n    handlers.push(function() {\n      console.log(`Clicked on: ${item}`);\n    });\n  }\n\n  return handlers;\n}\n\n// Alternative using IIFE (older approach but demonstrates strong closure concept):\n/*\nfunction createClickHandlersIIFE(items) {\n  const handlers = [];\n  for (var i = 0; i < items.length; i++) {\n    (function(itemIndex) {\n      handlers.push(function() {\n        console.log(`Clicked on: ${items[itemIndex]}`);\n      });\n    })(i); // Pass 'i' into the IIFE to capture its value per iteration\n  }\n  return handlers;\n}\n*/\n",
          "testCases": [
            "Test Case 1: Standard usage with three items\n   Input: `items = ['Red', 'Green', 'Blue']`\n   Execution: `const handlers = createClickHandlers(items); handlers[0](); handlers[1](); handlers[2]();`\n   Expected Output: `Clicked on: Red`, `Clicked on: Green`, `Clicked on: Blue` (each on a new line)\n",
            "Test Case 2: Empty array\n   Input: `items = []`\n   Execution: `const handlers = createClickHandlers(items); console.log(handlers.length);`\n   Expected Output: `0`\n",
            "Test Case 3: Single item array\n   Input: `items = ['OnlyOne']`\n   Execution: `const handlers = createClickHandlers(items); handlers[0]();`\n   Expected Output: `Clicked on: OnlyOne`\n",
            "Test Case 4: Long array to check consistency\n   Input: `items = Array.from({length: 10}, (_, i) => `Item ${i}`);`\n   Execution: `const handlers = createClickHandlers(items); handlers[5](); handlers[9]();`\n   Expected Output: `Clicked on: Item 5`, `Clicked on: Item 9`\n"
          ],
          "hints": [
            "Recall the difference between `var` and `let` in loop contexts.",
            "How can you ensure that each function 'remembers' the `item` value from its specific iteration?",
            "Think about what variable `i` (or `item`) refers to at the moment the inner function is *defined* versus when it's *executed*."
          ],
          "tags": [
            "closures",
            "loops",
            "javascript",
            "event-handlers",
            "scope"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "closures-and-scope-in-loops",
            "arrays",
            "functions"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "lexical-scoping",
            "event-listeners",
            "dynamic-ui"
          ]
        },
        {
          "id": "task_module_pattern_1",
          "title": "Build a Theme Manager Module",
          "description": "\nCreate a `ThemeManager` module using the Module Pattern. This module should allow an application to manage its current theme (e.g., 'light', 'dark', 'contrast') while keeping the theme state private.\n\n**Requirements:**\n*   **Private `currentTheme`**: A private variable to store the current theme string, initialized to a default (e.g., 'light').\n*   **Private `validThemes`**: A private array of valid theme names (e.g., `['light', 'dark', 'contrast']`).\n*   **Public `getTheme()`**: A method that returns the `currentTheme`.\n*   **Public `setTheme(newTheme)`**: A method that updates `currentTheme` only if `newTheme` is present in `validThemes`. It should also `console.log` a message indicating if the theme was successfully set or if it's an invalid theme.\n*   **Public `getValidThemes()`**: A method that returns a *copy* of the `validThemes` array to prevent external mutation.\n*   **Public `toggleTheme()`**: A method that cycles through `validThemes`. If the current theme is 'light', it goes to 'dark'; if 'dark', it goes to 'contrast'; if 'contrast', it goes to 'light'. (This is a simplified toggle for a fixed set of 3 themes).\n",
          "difficulty": "medium",
          "startingCode": "/**\n * ThemeManager module for managing application themes.\n * Implemented using the Module Pattern.\n */\nconst ThemeManager = (function() {\n  // Private variables\n  let currentTheme = 'light'; // Default theme\n  const validThemes = ['light', 'dark', 'contrast'];\n\n  // Private helper functions (optional, but good practice)\n\n  return { // Public interface\n    // TODO: Implement getTheme, setTheme, getValidThemes, toggleTheme\n  };\n})();\n\n// Example Usage:\n// console.log(ThemeManager.getTheme()); // Should be 'light'\n// ThemeManager.setTheme('dark');\n// console.log(ThemeManager.getTheme()); // Should be 'dark'\n// ThemeManager.setTheme('invalid'); // Should log invalid message\n// console.log(ThemeManager.getValidThemes()); // Should return ['light', 'dark', 'contrast']\n// ThemeManager.toggleTheme(); // Should change to 'contrast'\n// console.log(ThemeManager.getTheme()); // Should be 'contrast'\n// ThemeManager.toggleTheme(); // Should change to 'light'\n// console.log(ThemeManager.getTheme()); // Should be 'light'\n",
          "solutionCode": "/**\n * ThemeManager module for managing application themes.\n * Implemented using the Module Pattern.\n */\nconst ThemeManager = (function() {\n  // Private variables\n  let currentTheme = 'light'; // Default theme\n  const validThemes = ['light', 'dark', 'contrast'];\n\n  // Private helper function to find the next theme in the cycle\n  function getNextThemeInCycle() {\n    const currentIndex = validThemes.indexOf(currentTheme);\n    const nextIndex = (currentIndex + 1) % validThemes.length;\n    return validThemes[nextIndex];\n  }\n\n  return { // Public interface\n    getTheme: function() {\n      return currentTheme;\n    },\n    setTheme: function(newTheme) {\n      if (validThemes.includes(newTheme)) {\n        currentTheme = newTheme;\n        console.log(`Theme set to: ${currentTheme}`);\n        return true;\n      } else {\n        console.warn(`Invalid theme: '${newTheme}'. Valid themes are: ${validThemes.join(', ')}`);\n        return false;\n      }\n    },\n    getValidThemes: function() {\n      // Return a copy to prevent external mutation\n      return [...validThemes]; \n    },\n    toggleTheme: function() {\n      currentTheme = getNextThemeInCycle();\n      console.log(`Theme toggled to: ${currentTheme}`);\n      return currentTheme;\n    }\n  };\n})();\n",
          "testCases": [
            "Test Case 1: Initial state and `getTheme()`\n   Execution: `console.log(ThemeManager.getTheme());`\n   Expected Output: `light`\n",
            "Test Case 2: `setTheme()` with valid theme\n   Execution: `ThemeManager.setTheme('dark'); console.log(ThemeManager.getTheme());`\n   Expected Output: `Theme set to: dark`, `dark`\n",
            "Test Case 3: `setTheme()` with invalid theme\n   Execution: `ThemeManager.setTheme('ocean'); console.log(ThemeManager.getTheme());`\n   Expected Output: `Invalid theme: 'ocean'. Valid themes are: light, dark, contrast`, (theme should remain 'dark' from previous test, or 'light' if run independently)\n",
            "Test Case 4: `getValidThemes()` returns a copy\n   Execution: `const themes = ThemeManager.getValidThemes(); themes.push('new'); console.log(ThemeManager.getValidThemes().length);`\n   Expected Output: `3` (original `validThemes` should be unaffected)\n",
            "Test Case 5: `toggleTheme()` functionality\n   Execution: `ThemeManager.setTheme('light'); ThemeManager.toggleTheme(); console.log(ThemeManager.getTheme()); ThemeManager.toggleTheme(); console.log(ThemeManager.getTheme()); ThemeManager.toggleTheme(); console.log(ThemeManager.getTheme());`\n   Expected Output: `Theme set to: light`, `Theme toggled to: dark`, `dark`, `Theme toggled to: contrast`, `contrast`, `Theme toggled to: light`, `light`\n"
          ],
          "hints": [
            "An IIFE is crucial for establishing the private scope.",
            "Ensure public methods returned by the IIFE are closures that can access the private state.",
            "Remember to return a *copy* of arrays or objects when exposing them publicly to maintain encapsulation.",
            "For `toggleTheme`, consider using `indexOf` and the modulo operator (`%`) to cycle through the `validThemes` array."
          ],
          "tags": [
            "module-pattern",
            "closures",
            "encapsulation",
            "state-management",
            "design-patterns",
            "frontend-architecture"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "closures-and-module-pattern",
            "arrays-basic",
            "IIFE"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "singleton-pattern",
            "factory-functions",
            "frontend-state"
          ]
        }
      ]
    }
  },
  {
    "id": "b7e9d11f-9e0b-4684-8674-c025b11e7b2e",
    "startLine": 2500,
    "endLine": 2599,
    "processedDate": "2025-06-17T08:23:13.847Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_js_object_methods",
          "title": "JavaScript Object Property Checks and Manipulation Methods",
          "content": "JavaScript provides a rich set of built-in methods and operators for interacting with objects, allowing developers to check for property existence, control object mutability, and transform objects. Understanding these methods is crucial for effective object management and data manipulation.\n\n## Property Existence Checks\n\n-   **`'property' in object` Operator:** This operator checks if a specified property exists in an object or anywhere along its prototype chain. It returns `true` if the property is found, `false` otherwise. This includes both own properties and inherited properties.\n\n-   **`object.hasOwnProperty('property')` Method:** This method checks if an object has a specified property as its *own* property, meaning it's directly defined on the object itself and not inherited from its prototype chain. It returns `true` if the property is an own property, `false` otherwise.\n\n## Object Mutability Control\n\nJavaScript offers methods to control the mutability (ability to be changed) of objects, which is particularly useful for creating immutable data structures or preventing accidental modifications.\n\n-   **`Object.freeze(obj)`:** This method makes an object immutable. It prevents new properties from being added to it, existing properties from being removed, existing properties from being changed, and the prototype from being changed. The values of existing properties also become immutable (shallow freeze). If you attempt to modify a frozen object, it will silently fail in non-strict mode and throw a `TypeError` in strict mode. `Object.freeze()` is shallow; it only freezes the top-level properties. If a property is an object itself, that nested object can still be modified unless explicitly frozen.\n\n-   **`Object.seal(obj)`:** This method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. This means you cannot delete existing properties or change their configurability (e.g., make them enumerable or writable). However, you *can* still change the values of existing writable properties. Like `Object.freeze()`, `Object.seal()` is shallow.\n\n## Object Cloning\n\nCloning objects involves creating a new object with the same properties and values as an existing one. There are two main types of cloning:\n\n-   **Shallow Clone:** Creates a new object, but any nested objects or arrays within the original object are still referenced by the new object. Changes to nested structures in the clone will affect the original, and vice-versa.\n    -   **`Object.assign({}, original)`:** Copies all enumerable own properties from one or more source objects to a target object. The first argument (`{}`) is the target, creating a new empty object to copy into.\n    -   **Spread Syntax (`{ ...original }`)**: A modern and concise way to perform a shallow clone. It copies all enumerable own properties from the `original` object into a new object.\n\n-   **Deep Clone:** Creates a new object where all nested objects and arrays are also new, distinct copies. Changes to the cloned object, including nested structures, will not affect the original.\n    -   **`JSON.parse(JSON.stringify(original))` (Basic Approach):** This is a common, simple way to achieve a deep clone for basic JSON-serializable objects. The object is first converted to a JSON string, then parsed back into a new JavaScript object. **Limitations**: This method fails for objects containing `Date` objects (converted to strings), `RegExp` objects (converted to empty objects), `Map`, `Set`, `function`, `undefined`, `Symbol`, `BigInt` (ignored or converted incorrectly), and circular references (throws an error).\n\n## Object Iteration and Transformation\n\nThese methods provide ways to extract parts of an object or construct a new object from key-value pairs.\n\n-   **`Object.keys(obj)`:** Returns an array of a given object's own enumerable string-keyed property names.\n\n-   **`Object.values(obj)`:** Returns an array of a given object's own enumerable string-keyed property values.\n\n-   **`Object.entries(obj)`:** Returns an array of a given object's own enumerable string-keyed property `[key, value]` pairs.\n\n-   **`Object.fromEntries(iterable)`:** Transforms a list of key-value pairs (an iterable, such as an array of `[key, value]` arrays) into a new object. This is essentially the inverse of `Object.entries()`.",
          "examples": [
            {
              "id": "example_object_methods_1",
              "title": "Property Existence and Immutability",
              "code": "const myObject = { a: 1, b: 2 };\nconst protoObject = { c: 3 };\nObject.setPrototypeOf(myObject, protoObject);\n\nconsole.log('a' in myObject); // true (own property)\nconsole.log('c' in myObject); // true (inherited property)\nconsole.log(myObject.hasOwnProperty('a')); // true\nconsole.log(myObject.hasOwnProperty('c')); // false\n\n// Freezing an object\nconst frozenObj = Object.freeze({ name: 'Alice', age: 25 });\n// frozenObj.name = 'Bob'; // Throws TypeError in strict mode, silent fail otherwise\n// delete frozenObj.age; // Throws TypeError in strict mode\nconsole.log(frozenObj.name); // Alice\n\n// Sealing an object\nconst sealedObj = Object.seal({ city: 'New York' });\nsealedObj.city = 'London'; // Works\n// sealedObj.country = 'USA'; // No effect (cannot add new properties)\n// delete sealedObj.city; // Throws TypeError in strict mode\nconsole.log(sealedObj.city); // London",
              "explanation": "This example demonstrates the difference between `in` operator and `hasOwnProperty` for checking property existence, including inherited properties. It also shows the effects of `Object.freeze()` and `Object.seal()` on an object's mutability, highlighting what modifications are allowed or prevented by each method.",
              "language": "javascript"
            },
            {
              "id": "example_object_methods_2",
              "title": "Object Cloning and Transformation",
              "code": "const original = { \n  id: 1,\n  details: { color: 'red', size: 'M' },\n  tags: ['new', 'sale'],\n  getFormattedName: function() { return `Item-${this.id}`; }\n};\n\n// Shallow clone using spread syntax\nconst shallowClone = { ...original };\nshallowClone.details.color = 'blue'; // Modifies original's nested object\nshallowClone.tags.push('popular'); // Modifies original's nested array\n\nconsole.log(original.details.color); // blue\nconsole.log(original.tags); // ['new', 'sale', 'popular']\n\n// Deep clone using JSON serialization (with limitations)\nconst deepCloneJSON = JSON.parse(JSON.stringify(original));\ndeepCloneJSON.details.color = 'green';\nconsole.log(original.details.color); // blue (original not affected)\nconsole.log(deepCloneJSON.getFormattedName); // undefined (function lost)\n\n// Object iteration and creation\nconst obj = { a: 1, b: 2, c: 3 };\nconsole.log(Object.keys(obj));   // ['a', 'b', 'c']\nconsole.log(Object.values(obj)); // [1, 2, 3]\nconsole.log(Object.entries(obj)); // [['a', 1], ['b', 2], ['c', 3]]\n\nconst entriesArray = [['x', 10], ['y', 20]];\nconst newObj = Object.fromEntries(entriesArray);\nconsole.log(newObj); // { x: 10, y: 20 }",
              "explanation": "This example illustrates shallow vs. deep cloning, demonstrating how changes to nested objects/arrays in a shallow clone affect the original. It also shows how `JSON.parse(JSON.stringify())` works for deep cloning but highlights its limitation by showing that the `getFormattedName` function is lost. Finally, it demonstrates how to extract keys, values, and entries from an object and reconstruct an object from entries.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "JavaScript",
            "Objects",
            "Mutability",
            "Cloning",
            "ES6"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "data_types"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_js_patterns",
            "react_state_management"
          ]
        },
        {
          "id": "theory_js_object_destructuring",
          "title": "JavaScript Object Destructuring",
          "content": "Object destructuring is an ECMAScript 6 (ES6) feature that allows you to extract properties from objects and bind them to variables. It provides a cleaner and more concise way to access data from objects, especially when dealing with complex or nested data structures. Destructuring can significantly improve code readability and reduce boilerplate.\n\n## Core Concepts\n\n-   **Basic Destructuring:** Extracts properties by their names directly into variables. If a variable with the same name as the property is declared, its value will be assigned the value of that property from the object.\n\n-   **Aliasing (Renaming Properties):** Sometimes you want to extract a property but assign its value to a variable with a different name. This is achieved using a colon (`:`) followed by the desired new variable name.\n\n-   **Nested Destructuring:** Allows you to extract properties from objects that are themselves properties of another object. You can drill down into nested structures to pull out specific values.\n\n-   **Default Values:** When destructuring, you can provide default values for properties. If the property does not exist on the object (or is `undefined`), the default value will be assigned to the variable instead.\n\n-   **Rest Pattern (`...rest`):** This pattern collects the remaining enumerable properties of an object that were not explicitly destructured into a new object. It must be the last element in the destructuring assignment.\n\n-   **Destructuring in Function Parameters:** Object destructuring is commonly used in function parameters to directly extract required properties from an object passed as an argument, making function signatures clearer and data access within the function body more direct.\n\nDestructuring works with both `const`, `let`, and `var` declarations.",
          "examples": [
            {
              "id": "example_object_destructuring_1",
              "title": "Basic and Aliased Destructuring",
              "code": "const user = {\n  firstName: 'Jane',\n  lastName: 'Doe',\n  email: 'jane.doe@example.com',\n  age: 28\n};\n\n// Basic destructuring\nconst { firstName, age } = user;\nconsole.log(firstName); // Jane\nconsole.log(age);       // 28\n\n// Destructuring with aliases (renaming)\nconst { firstName: givenName, lastName: familyName } = user;\nconsole.log(givenName);  // Jane\nconsole.log(familyName); // Doe",
              "explanation": "This example demonstrates the fundamental use of object destructuring to extract `firstName` and `age` into variables with the same names. It also shows how to rename properties during destructuring, assigning `firstName` to `givenName` and `lastName` to `familyName` for clearer variable naming.",
              "language": "javascript"
            },
            {
              "id": "example_object_destructuring_2",
              "title": "Nested, Default, Rest, and Function Parameter Destructuring",
              "code": "const product = {\n  id: 'PROD001',\n  name: 'Laptop Pro',\n  specs: {\n    processor: 'Intel i7',\n    ram: '16GB',\n    storage: '512GB SSD'\n  },\n  price: 1200\n};\n\n// Nested destructuring\nconst { specs: { processor, ram } } = product;\nconsole.log(processor); // Intel i7\nconsole.log(ram);       // 16GB\n\n// Destructuring with default values\nconst { category = 'Electronics', price, weight = '2kg' } = product;\nconsole.log(category); // Electronics (default value used)\nconsole.log(price);    // 1200\nconsole.log(weight);   // 2kg (default value used)\n\n// Rest pattern\nconst { name, specs, ...otherInfo } = product;\nconsole.log(otherInfo); // { id: 'PROD001', price: 1200 }\n\n// Destructuring in function parameters\nfunction displayProductInfo({ name, price, specs: { processor } }) {\n  console.log(`Product: ${name}`);\n  console.log(`Price: $${price}`);\n  console.log(`Processor: ${processor}`);\n}\n\ndisplayProductInfo(product);\n// Output:\n// Product: Laptop Pro\n// Price: $1200\n// Processor: Intel i7",
              "explanation": "This comprehensive example showcases various advanced destructuring techniques. It demonstrates how to extract `processor` and `ram` from the nested `specs` object, apply default values for `category` and `weight` (where `category` is used as it's missing, and `price` is taken from `product`). The rest pattern (`...otherInfo`) gathers `id` and `price`. Finally, it illustrates the powerful use of destructuring directly within function parameters to cleanly access specific properties from an object passed as an argument.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "JavaScript",
            "ES6",
            "Destructuring",
            "Objects",
            "Syntax",
            "Readability"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "variables"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_components",
            "functional_programming"
          ]
        },
        {
          "id": "theory_react_jsx",
          "title": "React JSX (JavaScript XML)",
          "content": "JSX, which stands for JavaScript XML, is a syntax extension for JavaScript primarily used with React to describe what the UI should look like. It allows developers to write HTML-like code directly within their JavaScript files, blending JavaScript logic with declarative UI descriptions. While JSX looks like HTML, it's not HTML; it's a syntactic sugar for `React.createElement()` calls.\n\n## Key Characteristics\n\n-   **Declarative UI:** JSX allows you to declare how your UI should look based on the current state and props, making your code easier to understand and debug.\n\n-   **Looks Like HTML/XML:** The syntax closely resembles standard HTML, which makes it intuitive for web developers.\n\n-   **Embedded JavaScript Expressions:** Within JSX, you can embed any valid JavaScript expression by wrapping it in curly braces `{}`. This enables dynamic content rendering, conditional logic, and mapping over arrays directly within your UI structure.\n\n-   **Transpilation Required:** Browsers do not understand JSX directly. It must be transformed (transpiled) into regular JavaScript (specifically, `React.createElement()` calls) before it can be executed by a browser. Tools like Babel are commonly used for this transpilation process.\n\n-   **Attributes vs. HTML Attributes:** JSX uses `camelCase` for most HTML attributes (e.g., `className` instead of `class`, `htmlFor` instead of `for`) because `class` and `for` are reserved keywords in JavaScript. `style` attribute expects a JavaScript object instead of a string of CSS rules.\n\n-   **Self-Closing Tags:** Elements without children can be self-closing (e.g., `<img />`, `<input />`).\n\n-   **Root Element:** A JSX expression must have exactly one root element. To return multiple elements, you can wrap them in a single parent element (like a `<div>`) or use a `React.Fragment` (short syntax `<></>`).\n\nJSX enhances developer experience by bringing the templating logic closer to the component logic, leading to more cohesive and maintainable codebases in React applications.",
          "examples": [
            {
              "id": "example_react_jsx_1",
              "title": "Basic JSX Structure and Expressions",
              "code": "// Basic JSX element\nconst welcomeMessage = <h1>Hello, React!</h1>;\n\n// JSX with an embedded JavaScript expression\nconst userName = 'Alice';\nconst greetingElement = <h2>Welcome, {userName}!</h2>;\n\n// JSX with a numeric expression and concatenation\nconst year = 2023;\nconst footer = <p>&copy; {year} My Company. All rights reserved.</p>;\n\n// JSX with a function call expression\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = { firstName: 'Bob', lastName: 'Johnson' };\nconst userDisplay = <p>User: {formatName(user)}</p>;\n\n// Rendering a list dynamically using map\nconst items = ['Apple', 'Banana', 'Cherry'];\nconst itemList = (\n  <ul>\n    {items.map((item, index) => (\n      <li key={index}>{item}</li>\n    ))}\n  </ul>\n);\n\n// Conditional rendering using ternary operator\nconst isLoggedIn = true;\nconst authStatus = (\n  <div>\n    {isLoggedIn ? <p>You are logged in.</p> : <button>Login</button>}\n  </div>\n);\n",
              "explanation": "This example demonstrates various ways to use JSX. It shows a simple `h1` element, how to embed a JavaScript variable (`userName`) within curly braces, and how to use more complex JavaScript expressions like `year` or `formatName(user)`. It also illustrates how to render dynamic lists using the `map` array method and how to implement conditional rendering directly within JSX using a ternary operator. The `key` prop in the list is crucial for React's reconciliation process.",
              "language": "javascript"
            },
            {
              "id": "example_react_jsx_2",
              "title": "JSX Attributes and Styling",
              "code": "// JSX with className attribute\nconst infoBox = <div className=\"info-card\">This is an informational box.</div>;\n\n// JSX with inline style (object)\nconst redText = <p style={{ color: 'red', fontSize: '16px' }}>This text is red and 16px.</p>;\n\n// JSX with an array of elements (must be wrapped or use Fragment)\nconst multipleElements = (\n  <>\n    <h1>Title</h1>\n    <p>Paragraph 1</p>\n    <p>Paragraph 2</p>\n  </>\n);\n\n// JSX with event handlers (camelCase)\nfunction handleClick() {\n  console.log('Button clicked!');\n}\n\nconst myButton = <button onClick={handleClick}>Click Me</button>;\n\nconsole.log(infoBox);\nconsole.log(redText);\nconsole.log(multipleElements);\nconsole.log(myButton);\n",
              "explanation": "This example focuses on how attributes are handled in JSX. It shows the use of `className` for CSS classes (instead of `class`), how to apply inline styles using a JavaScript object, and the necessity of wrapping multiple root elements in a `React.Fragment` (`<>...</>`) or a single parent tag. It also demonstrates how to attach event handlers using `camelCase` naming conventions directly within the JSX.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "JSX",
            "Frontend",
            "UI Development",
            "Transpilation",
            "JavaScript"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_basics",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "beginner",
          "requiredFor": [
            "react_component_development",
            "react_hooks"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_object_methods_1",
          "topic": "Object Property Existence Checks",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between the `'property' in object` operator and the `object.hasOwnProperty('property')` method?",
          "answer": "The `'property' in object` operator checks for properties in the object itself or anywhere in its prototype chain, while `object.hasOwnProperty('property')` checks only for properties directly owned by the object (not inherited).",
          "analysisPoints": [
            "Understanding of prototype chain.",
            "Distinction between own properties and inherited properties.",
            "Correct application of each method."
          ],
          "keyConcepts": [
            "in operator",
            "hasOwnProperty",
            "prototype chain",
            "own properties",
            "inherited properties"
          ],
          "evaluationCriteria": [
            "Accuracy of distinction",
            "Completeness of explanation"
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Objects",
            "Methods",
            "Prototypes"
          ],
          "prerequisites": [
            "javascript_objects",
            "prototype_chain"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_methods_2",
          "topic": "Object Mutability Control",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n\n```javascript\nconst myObj = { \n  data: { value: 10 }, \n  id: 1 \n};\n\nObject.freeze(myObj);\n\nmyObj.id = 2; \nmyObj.data.value = 20;\nmyObj.newProp = 'test';\n\nconsole.log(myObj.id);\nconsole.log(myObj.data.value);\nconsole.log(myObj.newProp);\n```\n\nAssuming strict mode is *not* enabled, what will be the output of the `console.log` statements?",
          "answer": "1\n20\nundefined",
          "options": [
            "1\n10\nundefined",
            "2\n20\nundefined",
            "1\n20\nundefined",
            "1\n10\n'test'"
          ],
          "analysisPoints": [
            "Understanding that `Object.freeze` is shallow.",
            "Knowing that `Object.freeze` prevents modification of top-level properties (like `id`) in non-strict mode.",
            "Knowing that `Object.freeze` prevents adding new properties.",
            "Understanding that nested objects are *not* frozen and their properties can still be modified."
          ],
          "keyConcepts": [
            "Object.freeze",
            "Shallow immutability",
            "Strict mode",
            "Object properties"
          ],
          "evaluationCriteria": [
            "Correctly identifying shallow nature of Object.freeze.",
            "Predicting silent failures in non-strict mode for direct property assignments.",
            "Predicting the successful modification of nested object properties."
          ],
          "example": "Explanation:\n1. `myObj.id = 2;` Fails silently because `myObj` is frozen. `id` remains `1`.\n2. `myObj.data.value = 20;` Succeeds because `Object.freeze` is shallow; only `myObj` itself is frozen, not the `data` object nested within it. So, `myObj.data` is a reference to the original object, which is still mutable.\n3. `myObj.newProp = 'test';` Fails silently because `myObj` is frozen and new properties cannot be added. `myObj.newProp` will be `undefined`.\n\nTherefore, the output is `1`, `20`, `undefined`.",
          "tags": [
            "JavaScript",
            "Objects",
            "Mutability",
            "Object.freeze"
          ],
          "prerequisites": [
            "javascript_objects",
            "object_references"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_methods_3",
          "topic": "Object Cloning",
          "level": "hard",
          "type": "code",
          "question": "Write a JavaScript function `isDeepEqual(obj1, obj2)` that performs a deep comparison between two JavaScript objects. The function should return `true` if the objects are deeply equal, and `false` otherwise. Consider primitive values, arrays, and nested objects. You do NOT need to handle functions, Dates, RegExp, Symbols, or circular references for this problem.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Handling primitive type comparisons.",
            "Recursively comparing nested objects.",
            "Iterating over object keys for comparison.",
            "Handling array comparisons (length and element-by-element deep comparison).",
            "Checking for same number of keys."
          ],
          "keyConcepts": [
            "Deep equality",
            "Recursion",
            "Object iteration",
            "Type checking"
          ],
          "evaluationCriteria": [
            "Correctness of recursive logic.",
            "Handling of different data types (primitives, objects, arrays).",
            "Efficiency (avoiding unnecessary iterations).",
            "Edge case handling (empty objects/arrays, null/undefined inputs)."
          ],
          "example": "```javascript\nfunction isDeepEqual(obj1, obj2) {\n  if (obj1 === obj2) return true; // Strict equality check for primitives and same object reference\n\n  if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {\n    return false; // If not objects or one is null, and not strictly equal, they are not deep equal\n  }\n\n  // Handle Arrays\n  if (Array.isArray(obj1) && Array.isArray(obj2)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqual(obj1[i], obj2[i])) return false;\n    }\n    return true;\n  }\n\n  // If one is array and other is not, they are not deep equal\n  if (Array.isArray(obj1) !== Array.isArray(obj2)) return false;\n\n  // Handle Objects\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) return false; // Different number of properties\n\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !isDeepEqual(obj1[key], obj2[key])) {\n      return false; // Key missing or values not deep equal\n    }\n  }\n\n  return true;\n}\n\n// Test cases\nconst objA = { a: 1, b: { c: 2, d: [3, 4] }, e: 'test' };\nconst objB = { a: 1, b: { c: 2, d: [3, 4] }, e: 'test' };\nconst objC = { a: 1, b: { c: 2, d: [3, 5] }, e: 'test' };\nconst objD = { a: 1, b: { c: 2 }, e: 'test' };\n\nconsole.log(isDeepEqual(objA, objB)); // true\nconsole.log(isDeepEqual(objA, objC)); // false\nconsole.log(isDeepEqual(objA, objD)); // false\nconsole.log(isDeepEqual(null, null)); // true\nconsole.log(isDeepEqual(1, 1));       // true\nconsole.log(isDeepEqual(1, '1'));     // false\nconsole.log(isDeepEqual({}, {}));     // true\nconsole.log(isDeepEqual([], []));     // true\nconsole.log(isDeepEqual([1, {a:1}], [1, {a:1}])); // true\nconsole.log(isDeepEqual([1, {a:1}], [1, {a:2}])); // false\n```",
          "tags": [
            "JavaScript",
            "Objects",
            "Comparison",
            "Algorithm",
            "Recursion"
          ],
          "prerequisites": [
            "javascript_objects",
            "recursion",
            "array_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_methods_4",
          "topic": "Object Iteration and Transformation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following methods would you use to get an array of `[key, value]` pairs from an object, and then transform that array back into a new object?",
          "answer": "Object.entries() followed by Object.fromEntries()",
          "options": [
            "Object.keys() followed by Array.prototype.reduce()",
            "Object.values() followed by new Map().forEach()",
            "Object.entries() followed by Object.fromEntries()",
            "Object.assign() followed by Object.keys()"
          ],
          "analysisPoints": [
            "Understanding the purpose of `Object.entries()` (key-value pairs).",
            "Understanding the purpose of `Object.fromEntries()` (creating object from entries).",
            "Recognizing other options are not directly designed for this specific transformation or are less direct."
          ],
          "keyConcepts": [
            "Object.entries",
            "Object.fromEntries",
            "Object iteration",
            "Object transformation"
          ],
          "evaluationCriteria": [
            "Correct identification of inverse methods for object-to-array and array-to-object conversion.",
            "Distinguishing between methods that return keys, values, or entries."
          ],
          "example": "```javascript\nconst myObject = { a: 1, b: 2 };\n\n// Get key-value pairs\nconst entries = Object.entries(myObject);\nconsole.log(entries); // [['a', 1], ['b', 2]]\n\n// Transform back into a new object\nconst newObject = Object.fromEntries(entries);\nconsole.log(newObject); // { a: 1, b: 2 }\n```",
          "tags": [
            "JavaScript",
            "Objects",
            "ES2019",
            "Iteration"
          ],
          "prerequisites": [
            "javascript_objects",
            "array_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_methods_5",
          "topic": "Shallow vs. Deep Copy",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between a shallow copy and a deep copy of an object?",
          "answer": "A shallow copy creates a new object and copies top-level properties. Nested objects are still referenced, meaning changes to nested properties in the copy will affect the original. A deep copy creates a completely independent copy, including all nested objects, so changes to the copy do not affect the original.",
          "analysisPoints": [
            "Understanding reference vs. value copy for nested structures.",
            "Impact of modification on original object for both types of copies."
          ],
          "keyConcepts": [
            "Shallow copy",
            "Deep copy",
            "Object reference",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Accuracy and clarity of distinction"
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Objects",
            "Cloning",
            "Memory Management"
          ],
          "prerequisites": [
            "javascript_objects",
            "object_references"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_destructuring_1",
          "topic": "Basic Object Destructuring",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using object destructuring in JavaScript?",
          "answer": "It provides a more concise and readable way to extract properties from objects and assign them to variables, reducing boilerplate code and making it clearer which properties are being used.",
          "analysisPoints": [
            "Conciseness.",
            "Readability.",
            "Reduction of boilerplate."
          ],
          "keyConcepts": [
            "Destructuring",
            "Readability",
            "Conciseness"
          ],
          "evaluationCriteria": [
            "Understanding of core benefit"
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "ES6",
            "Destructuring",
            "Readability"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_destructuring_2",
          "topic": "Object Destructuring Patterns",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following object:\n\n```javascript\nconst settings = {\n  theme: 'dark',\n  fontSize: 16,\n  user: {\n    id: 'user123',\n    name: 'Alice',\n    email: 'alice@example.com'\n  }\n};\n\nconst { \n  theme: currentTheme,\n  notifications = true,\n  user: { name: userName, status = 'active' },\n  ...restOfSettings\n} = settings;\n\nconsole.log(currentTheme);\nconsole.log(notifications);\nconsole.log(userName);\nconsole.log(status);\nconsole.log(restOfSettings);\n```\n\nWhat will be the output of the `console.log` statements?",
          "answer": "dark\ntrue\nAlice\nactive\n{ fontSize: 16 }",
          "options": [
            "dark\ntrue\nAlice\nactive\n{ fontSize: 16 }",
            "dark\nundefined\nAlice\nundefined\n{ fontSize: 16 }",
            "dark\ntrue\nundefined\nactive\n{ fontSize: 16, user: { ... } }",
            "dark\ntrue\nAlice\nundefined\n{ fontSize: 16 }"
          ],
          "analysisPoints": [
            "Correct application of aliasing (renaming) for `theme`.",
            "Correct application of default values for `notifications` and `status`.",
            "Correct application of nested destructuring for `user.name`.",
            "Correct application of the rest pattern (`...restOfSettings`).",
            "Understanding that `user` property is consumed by nested destructuring and not included in `restOfSettings`."
          ],
          "keyConcepts": [
            "Destructuring aliasing",
            "Default values",
            "Nested destructuring",
            "Rest pattern"
          ],
          "evaluationCriteria": [
            "Accuracy in applying multiple destructuring features simultaneously.",
            "Correctly identifying which properties are extracted and which remain in the rest object."
          ],
          "example": "Explanation:\n1. `theme: currentTheme`: `theme` property is destructured and assigned to `currentTheme`. Output: `dark`.\n2. `notifications = true`: `notifications` property does not exist in `settings`, so its default value `true` is used. Output: `true`.\n3. `user: { name: userName, status = 'active' }`: Nested destructuring extracts `name` from `user` and renames it to `userName`. `status` does not exist in `user`, so its default `active` is used. Output: `Alice`, `active`.\n4. `...restOfSettings`: Collects all remaining enumerable properties not explicitly destructured. `theme` and `user` were destructured. `fontSize` is the only remaining top-level property. Output: `{ fontSize: 16 }`.",
          "tags": [
            "JavaScript",
            "ES6",
            "Destructuring",
            "Syntax"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_destructuring_3",
          "topic": "Destructuring in Function Parameters",
          "level": "medium",
          "type": "open",
          "question": "Explain the advantages of using object destructuring in function parameters. Provide a small code example demonstrating its use for a function that expects a configuration object.",
          "answer": "Using object destructuring in function parameters provides several advantages:\n1.  **Readability:** It clearly indicates which properties the function expects from the input object, making the function's signature more expressive than just `(config)`. This acts as a form of self-documentation.\n2.  **Conciseness:** It directly assigns the object properties to variables, eliminating the need for repetitive `config.propertyName` access inside the function body.\n3.  **Flexibility with Defaults:** You can easily provide default values for optional parameters directly in the signature, simplifying error handling for missing properties.\n4.  **Order Independence:** Unlike positional arguments, the order of properties in the input object does not matter.\n\n```javascript\nfunction createUser({ id, name, email, role = 'user', isActive = true }) {\n  console.log(`Creating user:`);\n  console.log(`ID: ${id}`);\n  console.log(`Name: ${name}`);\n  console.log(`Email: ${email}`);\n  console.log(`Role: ${role}`);\n  console.log(`Active: ${isActive}`);\n}\n\n// Usage 1: All properties provided\ncreateUser({\n  id: 'u001',\n  name: 'John Doe',\n  email: 'john.doe@example.com',\n  role: 'admin'\n});\n\n// Usage 2: Some properties are missing, default values will be used\ncreateUser({\n  id: 'u002',\n  name: 'Jane Smith',\n  email: 'jane.smith@example.com'\n});\n```",
          "analysisPoints": [
            "Identification of readability as a key advantage.",
            "Explanation of conciseness and reduced boilerplate.",
            "Mention of default values for optional parameters.",
            "Discussion of order independence.",
            "Provision of a clear and correct code example."
          ],
          "keyConcepts": [
            "Destructuring",
            "Function parameters",
            "Readability",
            "Default values",
            "API design"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of explanation.",
            "Correctness and relevance of code example.",
            "Demonstration of practical benefits."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "ES6",
            "Destructuring",
            "Functions",
            "Best Practices"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_objects"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_jsx_1",
          "topic": "JSX Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What does JSX stand for, and what is its primary purpose in React?",
          "answer": "JSX stands for JavaScript XML. Its primary purpose in React is to allow developers to write HTML-like code within JavaScript, providing a declarative way to describe the user interface components.",
          "analysisPoints": [
            "Correct abbreviation.",
            "Understanding of its role as a syntax extension.",
            "Purpose of declarative UI."
          ],
          "keyConcepts": [
            "JSX",
            "React",
            "Declarative UI",
            "Syntax Extension"
          ],
          "evaluationCriteria": [
            "Accuracy of definition",
            "Clarity of purpose"
          ],
          "example": null,
          "tags": [
            "React",
            "JSX",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 10,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_jsx_2",
          "topic": "JSX Expressions and Transpilation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about JSX and JavaScript expressions is true?\n\n```jsx\nconst count = 5;\nconst isValid = true;\nconst myArray = ['A', 'B'];\n\nconst element = (\n  <div>\n    <p>Count: {count}</p>\n    <p>{isValid ? 'Valid' : 'Invalid'}</p>\n    <ul>\n      {myArray.map((item, index) => (\n        <li key={index}>{item}</li>\n      ))}\n    </ul>\n  </div>\n);\n```",
          "answer": "JavaScript expressions can be embedded within JSX using curly braces `{}`.",
          "options": [
            "JSX is directly understood by web browsers without any processing.",
            "Only primitive data types (strings, numbers) can be embedded within JSX using curly braces.",
            "JavaScript expressions can be embedded within JSX using curly braces `{}`.",
            "JSX elements are standard HTML elements and do not require a transpiler."
          ],
          "analysisPoints": [
            "Understanding that JSX requires transpilation (e.g., by Babel).",
            "Knowing that any valid JavaScript expression can be embedded in JSX using `{}`.",
            "Recognizing that `map` and ternary operators are valid expressions for dynamic content."
          ],
          "keyConcepts": [
            "JSX",
            "JavaScript expressions",
            "Transpilation",
            "Babel",
            "Dynamic content"
          ],
          "evaluationCriteria": [
            "Correctly identifying the mechanism for embedding JS in JSX.",
            "Dispelling common misconceptions about JSX processing and capabilities."
          ],
          "example": "Explanation:\n1.  JSX is *not* directly understood by browsers; it must be transpiled, typically by Babel, into `React.createElement()` calls.\n2.  Any valid JavaScript expression can be embedded, including complex logic like ternary operators, function calls, and array `map` methods, not just primitives.\n3.  The example clearly shows `count` (number), `isValid ? 'Valid' : 'Invalid'` (ternary expression), and `myArray.map(...)` (array method) all embedded within `{}`. This demonstrates that arbitrary JavaScript expressions can be used.\n4.  JSX elements are not standard HTML; they are a syntactic sugar that gets converted to JavaScript calls (`React.createElement`).",
          "tags": [
            "React",
            "JSX",
            "Transpilation",
            "Expressions"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_jsx_3",
          "topic": "JSX Attributes and Fragments",
          "level": "medium",
          "type": "open",
          "question": "When working with JSX, what are `className` and `htmlFor` used for, and why are they preferred over their HTML counterparts (`class`, `for`)? Additionally, explain why a React component's `render` method (or functional component return) often needs to return a single root element or use a `React.Fragment`.",
          "answer": "`className` and `htmlFor` are JSX attributes used in React to correspond to the HTML `class` and `for` attributes, respectively. They are preferred because `class` and `for` are reserved keywords in JavaScript. Since JSX is JavaScript, using these keywords directly would cause syntax errors. `className` maps to the `class` attribute for CSS styling, and `htmlFor` maps to the `for` attribute for associating labels with form controls.\n\nA React component's `render` method (or a functional component's return) needs to return a single root element (e.g., `<div>...</div>`) or use a `React.Fragment` (`<>...</>`) because:\n1.  **DOM Structure:** JSX compiles down to `React.createElement()` calls. A component's `render` method effectively returns a single JavaScript object representing the top-level element. If multiple top-level elements were returned, React wouldn't know which one to consider the root, leading to ambiguity in the DOM tree construction.\n2.  **Reconciliation:** React's reconciliation algorithm relies on comparing a single root node efficiently. Having multiple root nodes would complicate this process.\n3.  **Returning Arrays:** While it's technically possible to return an array of elements (each with a unique `key`), it's generally discouraged for top-level returns in favor of Fragments, as Fragments specifically address the need for a single parent without adding an extra DOM node.\n\n`React.Fragment` (or its shorthand `<></>`) is a special component that allows you to group multiple elements without adding an extra DOM node to the tree. This is useful when you want to return multiple elements without affecting the layout or styling with an unnecessary wrapper `div`.",
          "analysisPoints": [
            "Correctly identifying `className` and `htmlFor` as JSX attribute conventions.",
            "Explaining the reason for these conventions (reserved JS keywords).",
            "Explaining the single root element rule in React components.",
            "Relating the rule to underlying `React.createElement` calls and DOM structure.",
            "Explaining the purpose and benefit of `React.Fragment` (no extra DOM node)."
          ],
          "keyConcepts": [
            "JSX attributes",
            "className",
            "htmlFor",
            "React.Fragment",
            "Single root element",
            "DOM structure",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Thoroughness of explanation for attribute naming.",
            "Clarity of reasoning for the single root element rule.",
            "Accurate description of `React.Fragment`'s role."
          ],
          "example": null,
          "tags": [
            "React",
            "JSX",
            "Attributes",
            "Fragments",
            "DOM",
            "Best Practices"
          ],
          "prerequisites": [
            "react_basics",
            "html_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_object_methods_1",
          "title": "Create a Robust Object Transformation Utility",
          "description": "\nDevelop a JavaScript utility function `transformObject(inputObject, transformationMap)` that takes an `inputObject` and a `transformationMap` object. The function should:\n\n1.  Create a *new* object (a deep copy of `inputObject` if it contains nested objects/arrays, otherwise a shallow copy).\n2.  Apply transformations specified in `transformationMap`. Each key in `transformationMap` represents a property name from the `inputObject` that needs to be renamed or its value transformed.\n    *   If `transformationMap[key]` is a string, it means rename `key` to `transformationMap[key]`.\n    *   If `transformationMap[key]` is a function, it means transform the value of `key` using this function. The function receives the original value and should return the new value.\n    *   Properties not in `transformationMap` should be copied as is.\n\nConsider the following edge cases:\n*   `inputObject` might be empty.\n*   `transformationMap` might be empty.\n*   `transformationMap` might contain keys not present in `inputObject`.\n*   `inputObject` can have nested objects and arrays that need to be deeply cloned.\n\n**Note**: For deep cloning, you can use `JSON.parse(JSON.stringify())` for simplicity, but be aware of its limitations (functions, Dates etc. will not be copied correctly). For this task, assume objects contain only primitive values, arrays, and other plain objects (JSON-serializable data).\n",
          "difficulty": "hard",
          "startingCode": "function transformObject(inputObject, transformationMap) {\n  if (!inputObject || typeof inputObject !== 'object') {\n    return inputObject; // Return primitives or null/undefined as is\n  }\n\n  // Step 1: Create a deep copy of the inputObject\n  // For this task, we can use JSON serialization for simplicity given the constraints.\n  // A more robust solution for general deep copy would involve recursion.\n  const newObject = JSON.parse(JSON.stringify(inputObject));\n\n  const result = {};\n\n  // Step 2: Iterate over the copied object's entries or keys to apply transformations\n  // TODO: Implement transformation logic here\n\n  return result;\n}\n",
          "solutionCode": "function transformObject(inputObject, transformationMap) {\n  if (!inputObject || typeof inputObject !== 'object' || Array.isArray(inputObject)) {\n    // For simplicity, we'll only process plain objects. Arrays and primitives are returned as is.\n    // A full solution would recursively deep copy arrays as well.\n    return inputObject;\n  }\n\n  // Step 1: Create a deep copy of the inputObject.\n  // We use JSON.parse(JSON.stringify) for simplicity, aware of its limitations.\n  const clonedObject = JSON.parse(JSON.stringify(inputObject));\n\n  const result = {};\n\n  // Step 2: Iterate over the cloned object's own properties\n  for (const key in clonedObject) {\n    if (Object.prototype.hasOwnProperty.call(clonedObject, key)) {\n      const originalValue = clonedObject[key];\n      const transformRule = transformationMap[key];\n\n      if (transformRule) {\n        if (typeof transformRule === 'string') {\n          // Rename property\n          result[transformRule] = originalValue;\n        } else if (typeof transformRule === 'function') {\n          // Transform value\n          const newValue = transformRule(originalValue);\n          result[key] = newValue;\n        } else {\n          // If transformationMap[key] is neither string nor function, copy as is\n          result[key] = originalValue;\n        }\n      } else {\n        // Copy property as is if no transformation rule exists\n        result[key] = originalValue;\n      }\n    }\n  }\n\n  return result;\n}\n",
          "testCases": [
            "transformObject({ a: 1, b: 'hello' }, { a: 'newA', b: (val) => val.toUpperCase() }) should return { newA: 1, b: 'HELLO' }",
            "transformObject({ x: 10, y: { z: 20 } }, { x: 'newX' }) should return { newX: 10, y: { z: 20 } } (deep copy of y)",
            "transformObject({ count: 5 }, {}) should return { count: 5 }",
            "transformObject({}, { a: 'newA' }) should return {}",
            "transformObject({ price: 100 }, { price: (val) => val * 1.2 }) should return { price: 120 }",
            "transformObject({ id: 'abc', data: { value: 123 } }, { id: (val) => `ITEM_${val.toUpperCase()}`, data: 'info' }) should return { id: 'ITEM_ABC', info: { value: 123 } }"
          ],
          "hints": [
            "Start by creating a copy of the `inputObject`. Consider the nuances of shallow vs. deep copy.",
            "Iterate over the keys of the `inputObject` to decide whether to rename, transform, or simply copy each property.",
            "Use `hasOwnProperty` when iterating with `for...in` to ensure you're only processing own properties.",
            "Remember to create a *new* object for the `result` to ensure immutability of the original."
          ],
          "tags": [
            "JavaScript",
            "Objects",
            "Cloning",
            "Transformation",
            "Utility",
            "Immutability"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_objects",
            "object_methods",
            "deep_copy_concepts"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Object.assign",
            "Object.keys",
            "Object.entries",
            "hasOwnProperty",
            "JSON_serialization"
          ]
        },
        {
          "id": "task_object_destructuring_1",
          "title": "Process User Profile Data with Destructuring",
          "description": "\nWrite a JavaScript function `formatUserProfile(userProfile)` that takes a `userProfile` object as an argument. The function should use object destructuring (including nested destructuring, default values, and aliases if appropriate) to extract and format specific user information into a readable string. \n\n**Requirements:**\n1.  The `userProfile` object will have the following structure:\n    ```javascript\n    {\n      id: 'some-uuid',\n      personalInfo: {\n        firstName: 'John',\n        lastName: 'Doe',\n        email: 'john.doe@example.com'\n      },\n      contact: {\n        phone: '123-456-7890', // Optional\n        address: { // Optional\n          street: '123 Main St',\n          city: 'Anytown',\n          zip: '12345'\n        }\n      },\n      preferences: {\n        theme: 'light', // Optional, default to 'dark'\n        notifications: true // Optional, default to false\n      },\n      status: 'active' // Optional, default to 'unknown'\n    }\n    ```\n2.  Extract `firstName`, `lastName`, `email`, `phone`, `city`, `theme`, `notifications`, and `status`.\n3.  Rename `firstName` to `first`, and `lastName` to `last` during destructuring.\n4.  Provide default values:\n    *   `phone`: 'N/A'\n    *   `city`: 'Unknown City'\n    *   `theme`: 'dark'\n    *   `notifications`: `false`\n    *   `status`: 'unknown'\n5.  Return a formatted string in the following format:\n    `User: [first] [last] ([email]) | Phone: [phone] | Location: [city] | Theme: [theme] | Notifications: [notifications] | Status: [status]`\n",
          "difficulty": "medium",
          "startingCode": "function formatUserProfile(userProfile) {\n  // TODO: Use object destructuring to extract and rename properties, and set default values.\n  // const { ... } = userProfile;\n\n  // TODO: Construct the formatted string.\n  return `User: ...`;\n}\n\n// Example usage:\n// const profile1 = {\n//   id: 'user1',\n//   personalInfo: { firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com' },\n//   contact: { phone: '987-654-3210' },\n//   preferences: { theme: 'light' },\n//   status: 'active'\n// };\n// console.log(formatUserProfile(profile1));\n\n// const profile2 = {\n//   id: 'user2',\n//   personalInfo: { firstName: 'Bob', lastName: 'Johnson', email: 'bob@example.com' },\n//   // Missing contact, preferences, and status\n// };\n// console.log(formatUserProfile(profile2));",
          "solutionCode": "function formatUserProfile(userProfile) {\n  const {\n    personalInfo: { firstName: first, lastName: last, email },\n    contact: { phone = 'N/A', address: { city = 'Unknown City' } = {} } = {},\n    preferences: { theme = 'dark', notifications = false } = {},\n    status = 'unknown'\n  } = userProfile;\n\n  return `User: ${first} ${last} (${email}) | Phone: ${phone} | Location: ${city} | Theme: ${theme} | Notifications: ${notifications} | Status: ${status}`;\n}\n",
          "testCases": [
            "formatUserProfile({\n  id: 'user1',\n  personalInfo: { firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com' },\n  contact: { phone: '987-654-3210', address: { street: '1 Main', city: 'Metropolis', zip: '11111' } },\n  preferences: { theme: 'light', notifications: true },\n  status: 'active'\n}) should return 'User: Alice Smith (alice@example.com) | Phone: 987-654-3210 | Location: Metropolis | Theme: light | Notifications: true | Status: active'",
            "formatUserProfile({\n  id: 'user2',\n  personalInfo: { firstName: 'Bob', lastName: 'Johnson', email: 'bob@example.com' }\n  // Missing contact, preferences, and status\n}) should return 'User: Bob Johnson (bob@example.com) | Phone: N/A | Location: Unknown City | Theme: dark | Notifications: false | Status: unknown'",
            "formatUserProfile({\n  id: 'user3',\n  personalInfo: { firstName: 'Charlie', lastName: 'Brown', email: 'charlie@example.com' },\n  contact: {}, // Empty contact object\n  preferences: { notifications: true } // Missing theme, but notifications is present\n}) should return 'User: Charlie Brown (charlie@example.com) | Phone: N/A | Location: Unknown City | Theme: dark | Notifications: true | Status: unknown'",
            "formatUserProfile({}) should handle gracefully and return 'User: undefined undefined (undefined) | Phone: N/A | Location: Unknown City | Theme: dark | Notifications: false | Status: unknown'"
          ],
          "hints": [
            "Start with the outermost destructuring, then progressively move to nested objects.",
            "Remember to provide default values for both properties and entire nested objects that might be missing.",
            "For deeply nested optional properties (like `address`), you might need to use an empty object `{}` as a default value for the intermediate object (`contact`) to prevent errors when trying to destructure properties from it.",
            "Pay close attention to parentheses and curly braces when nesting default values with destructuring."
          ],
          "tags": [
            "JavaScript",
            "Destructuring",
            "ES6",
            "Objects",
            "Data Formatting",
            "Frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_objects",
            "object_destructuring"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Template Literals",
            "Optional Chaining"
          ]
        },
        {
          "id": "task_react_jsx_1",
          "title": "Create a Dynamic Product Card Component (JSX Concept)",
          "description": "\nImagine you are building a React application. Your task is to conceptualize and write the JSX for a `ProductCard` component. This component should display product information dynamically based on props it receives.\n\n**Requirements:**\n1.  The component should accept a `product` prop, which is an object with the following structure:\n    ```javascript\n    {\n      id: 'P123',\n      name: 'Wireless Headphones',\n      price: 129.99,\n      inStock: true,\n      imageUrl: 'https://example.com/headphones.jpg',\n      description: 'High-fidelity audio with noise cancellation.', // Optional\n      rating: 4.5 // Optional\n    }\n    ```\n2.  Render the product's `name` in an `<h2>` tag.\n3.  Display the `price` in a `<p>` tag, formatted as currency (e.g., '$129.99').\n4.  Conditionally render a 'SOLD OUT' `<span>` tag if `inStock` is `false`. Otherwise, render an 'Add to Cart' `<button>`.\n5.  Render the `imageUrl` as an `<img>` tag with `alt` text set to the product's `name`.\n6.  If `description` is provided, render it in a `<p>` tag. Otherwise, render nothing for the description.\n7.  If `rating` is provided, display it as 'Rating: [rating]/5' in a `<p>` tag.\n8.  The entire component should be wrapped in a single `div` with `className=\"product-card\"`.\n\nYour solution should only provide the JSX structure that would be returned by a functional React component, demonstrating how JavaScript expressions are embedded and how conditional rendering is handled within JSX.",
          "difficulty": "medium",
          "startingCode": "function ProductCard({ product }) {\n  // Assume 'product' object is destructured here\n  // const { id, name, price, inStock, imageUrl, description, rating } = product;\n\n  return (\n    // TODO: Implement the JSX structure here\n    // Remember the single root element rule and how to embed JS expressions.\n    <div>\n      {/* Product Name */}\n      {/* Price */}\n      {/* Stock Status / Add to Cart */}\n      {/* Image */}\n      {/* Description (conditional) */}\n      {/* Rating (conditional) */}\n    </div>\n  );\n}\n",
          "solutionCode": "function ProductCard({ product }) {\n  const { \n    name, \n    price, \n    inStock, \n    imageUrl, \n    description, \n    rating \n  } = product;\n\n  return (\n    <div className=\"product-card\">\n      <h2>{name}</h2>\n      <p>Price: ${price.toFixed(2)}</p>\n      \n      {inStock ? (\n        <button>Add to Cart</button>\n      ) : (\n        <span style={{ color: 'red', fontWeight: 'bold' }}>SOLD OUT</span>\n      )}\n\n      <img src={imageUrl} alt={name} style={{ maxWidth: '100px', height: 'auto' }} />\n      \n      {description && <p>{description}</p>}\n\n      {rating && <p>Rating: {rating}/5</p>}\n    </div>\n  );\n}\n\n// Conceptual usage for demonstration:\n// const sampleProduct1 = {\n//   id: 'P123',\n//   name: 'Wireless Headphones',\n//   price: 129.99,\n//   inStock: true,\n//   imageUrl: 'https://via.placeholder.com/150/0000FF/FFFFFF?text=Headphones',\n//   description: 'High-fidelity audio with noise cancellation.',\n//   rating: 4.5\n// };\n// console.log(ProductCard({ product: sampleProduct1 }));\n\n// const sampleProduct2 = {\n//   id: 'P456',\n//   name: 'Vintage Camera',\n//   price: 250.00,\n//   inStock: false,\n//   imageUrl: 'https://via.placeholder.com/150/FF0000/FFFFFF?text=Camera'\n//   // No description or rating\n// };\n// console.log(ProductCard({ product: sampleProduct2 }));\n",
          "testCases": [
            "ProductCard with full product data (inStock: true, description, rating) should render all elements correctly.",
            "ProductCard with product out of stock (inStock: false) should show 'SOLD OUT' and no 'Add to Cart' button.",
            "ProductCard with missing optional fields (description, rating) should not render paragraphs for those fields.",
            "ProductCard should wrap all content in a `div` with `className=\"product-card\"`.",
            "Price should be formatted to two decimal places.",
            "Image `alt` attribute should correctly use the product `name`."
          ],
          "hints": [
            "Use curly braces `{}` to embed JavaScript variables and expressions directly into your JSX.",
            "For conditional rendering, consider using the ternary operator (`condition ? <TrueComponent /> : <FalseComponent />`) or logical AND (`condition && <Component />`).",
            "Remember that attributes like `class` become `className` in JSX, and inline styles require a JavaScript object (e.g., `style={{ color: 'red' }}`).",
            "For optional props like `description` and `rating`, a simple `&&` operator is often sufficient to conditionally render an element only if the prop exists and is truthy."
          ],
          "tags": [
            "React",
            "JSX",
            "Components",
            "Conditional Rendering",
            "Props",
            "Frontend"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_jsx",
            "javascript_objects",
            "object_destructuring"
          ],
          "complexity": 6,
          "interviewRelevance": 10,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Functional Components",
            "Props",
            "Styling in React"
          ]
        }
      ]
    }
  },
  {
    "id": "b36e3e91-e1b7-4efb-b48d-563618570d6f",
    "startLine": 2600,
    "endLine": 2699,
    "processedDate": "2025-06-17T08:24:36.995Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_jsx_fundamentals",
          "title": "JSX Fundamentals and Differences from HTML",
          "content": "JSX (JavaScript XML) is a syntax extension for JavaScript, commonly used with React to describe what the UI should look like. It allows you to write HTML-like syntax directly within your JavaScript code, which then gets transpiled into standard JavaScript function calls.\n\n## Multiline JSX\nWhen writing JSX across multiple lines, it must be wrapped in parentheses `()` to prevent automatic semicolon insertion from breaking the code. This ensures the entire JSX structure is treated as a single expression.\n\n## JSX vs. HTML Differences\nWhile JSX appears similar to HTML, there are crucial differences, primarily due to JSX being JavaScript under the hood:\n\n1.  **Attribute Naming (camelCase):** HTML attributes like `class` and `onclick` are reserved keywords in JavaScript or conflict with JavaScript naming conventions. Therefore, JSX uses camelCase for most attributes, such as `className` instead of `class` for CSS classes, and `onClick` instead of `onclick` for event handlers. Event handlers in JSX receive a JavaScript function reference directly, not a string of code.\n\n2.  **Self-Closing Tags:** In HTML, some tags like `<img>`, `<input>`, `<br>` can be self-closing (e.g., `<img src=\"image.jpg\">`) or explicitly closed (e.g., `<img></img>`). In JSX, all tags that do not have children must be explicitly self-closed with a trailing slash (`/`) before the closing angle bracket (e.g., `<img src=\"image.jpg\" />`). This applies to custom components as well.\n\n3.  **Style Attribute:** Unlike HTML where the `style` attribute takes a string of CSS rules, in JSX, the `style` attribute expects a JavaScript object. CSS property names within this object are also written in camelCase (e.g., `fontSize` instead of `font-size`), and their values are typically strings (for units) or numbers.\n\nThese differences are essential for writing valid and functional React components using JSX.",
          "examples": [
            {
              "id": "example_jsx_fundamentals_1",
              "title": "Basic Multiline JSX and Attributes",
              "code": "const element = (\n  <div>\n    <h1>Hello!</h1>\n    <p className=\"welcome-text\" onClick={() => console.log('Welcome clicked!')}>\n      Welcome to React\n    </p>\n    <img src=\"logo.png\" alt=\"React Logo\" />\n  </div>\n);\n\n// Example of inline style object\nconst styledElement = <div style={{ color: 'blue', fontSize: '20px' }}>Styled Text Example</div>;",
              "explanation": "This example demonstrates several key JSX features: The `div` is a multiline JSX element, hence wrapped in parentheses. `className` is used instead of `class` for the `p` tag. `onClick` is used for the event handler, receiving a function. The `img` tag is self-closed with `/>`. Finally, an inline style is applied using a JavaScript object.",
              "language": "javascript"
            },
            {
              "id": "example_jsx_fundamentals_2",
              "title": "JSX Style Attribute with Variable",
              "code": "const primaryColor = 'red';\nconst headerFontSize = '24px';\n\nconst styles = {\n  color: primaryColor,\n  fontSize: headerFontSize,\n  backgroundColor: '#eee',\n  padding: '10px'\n};\n\nconst elementWithVariableStyles = <h2 style={styles}>Dynamically Styled Header</h2>;",
              "explanation": "This example shows how to define styles as a separate JavaScript object and then pass that object to the `style` attribute. This approach promotes readability and reusability of style definitions, especially when styles are complex or need to be conditionally applied. Note the camelCase for `backgroundColor`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_jsx_attributes_mcq_1",
            "question_jsx_self_closing_flashcard_1",
            "question_jsx_style_open_1",
            "question_jsx_conversion_code_1"
          ],
          "relatedTasks": [
            "task_html_to_jsx_conversion"
          ],
          "tags": [
            "JSX",
            "React",
            "Frontend",
            "Syntax",
            "Beginner"
          ],
          "technology": "React",
          "prerequisites": [
            "HTML_basics",
            "JavaScript_basics"
          ],
          "complexity": 3,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "react_components",
            "react_dom_rendering"
          ]
        },
        {
          "id": "theory_how_jsx_works",
          "title": "How JSX Works: Compilation to React.createElement()",
          "content": "While JSX provides a convenient and readable way to write UI structures, it is not directly understood by web browsers. Browsers only understand standard JavaScript. Therefore, JSX code must be transformed, or 'transpiled,' into regular JavaScript before it can be executed in a browser.\n\nThis transformation process is typically handled by a build tool like Babel. When Babel processes JSX, it converts each JSX element into a call to `React.createElement()`.\n\n## `React.createElement()` Function\n`React.createElement()` is the function that React uses internally to create virtual DOM elements. Its signature generally looks like this:\n\n```typescript\nReact.createElement(\n  type: string | Function | Class,\n  props?: object | null,\n  ...children: ReactNode[]\n): ReactElement;\n```\n\n-   **`type`**: This argument specifies the type of the HTML element as a string (e.g., `'div'`, `'h1'`) or a reference to a React component function/class.\n-   **`props`**: This argument is an object containing all the attributes (props) passed to the element. This includes `className`, `onClick`, `style`, etc.\n-   **`children`**: Subsequent arguments are considered the children of the element. These can be strings (for text content), other `React.createElement()` calls (for nested elements), or arrays of children.\n\nThis compilation step is crucial because it bridges the gap between the declarative JSX syntax and the imperative `React.createElement()` calls that React uses to build its Virtual DOM representation of the UI. Understanding this underlying mechanism helps in debugging and comprehending how React processes your UI code.",
          "examples": [
            {
              "id": "example_how_jsx_works_1",
              "title": "JSX to React.createElement() Transformation",
              "code": "// This JSX\nconst element = <h1 className=\"greeting\">Hello, world!</h1>;\n\n// Compiles to this JavaScript\nconst compiledElement = React.createElement(\n  'h1',\n  { className: 'greeting' },\n  'Hello, world!'\n);",
              "explanation": "This example clearly shows how a simple JSX `<h1>` element with a `className` prop and text content is transformed into a `React.createElement` call. The first argument is the element type (`'h1'`), the second is an object containing props (`{ className: 'greeting' }`), and the third is the child content (`'Hello, world!'`).",
              "language": "javascript"
            },
            {
              "id": "example_how_jsx_works_2",
              "title": "Nested JSX and Children Transformation",
              "code": "// This JSX with nesting\nconst nestedElement = (\n  <div>\n    <p>Paragraph text</p>\n    <span>Span text</span>\n  </div>\n);\n\n// Compiles to this JavaScript\nconst compiledNestedElement = React.createElement(\n  'div',\n  null, // No props on the div itself\n  React.createElement('p', null, 'Paragraph text'),\n  React.createElement('span', null, 'Span text')\n);",
              "explanation": "This example demonstrates how nested JSX elements are translated into nested `React.createElement()` calls. The children of the parent `div` (the `p` and `span` elements) become subsequent arguments to the parent `React.createElement` call.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_jsx_compilation_mcq_1",
            "question_babel_role_open_1",
            "question_create_element_flashcard_1",
            "question_jsx_vs_js_performance_open_1"
          ],
          "relatedTasks": [
            "task_manual_create_element"
          ],
          "tags": [
            "JSX",
            "React",
            "Compilation",
            "Babel",
            "Virtual DOM",
            "Core Concepts"
          ],
          "technology": "React",
          "prerequisites": [
            "JSX_fundamentals",
            "JavaScript_functions"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_architecture",
            "custom_renderers"
          ]
        },
        {
          "id": "theory_why_choose_react",
          "title": "Why Choose React? Key Advantages",
          "content": "React has become one of the most popular JavaScript libraries for building user interfaces due to several compelling advantages. These benefits contribute to efficient development, high performance, and scalable applications:\n\n1.  **Reusable Components:** React encourages a component-based architecture, allowing developers to build self-contained, independent, and reusable UI pieces. Each component manages its own state and logic, making it easy to compose complex UIs from smaller, manageable parts. This reusability significantly speeds up development and reduces code duplication.\n\n2.  **High Cohesion, Low Coupling:** Components in React are designed to have 'high cohesion,' meaning they encapsulate their functionality and related data within themselves. They maintain 'low coupling,' meaning they have minimal dependencies on other components. This separation of concerns leads to more maintainable, testable, and understandable codebases.\n\n3.  **Virtual DOM Performance:** React uses a lightweight JavaScript representation of the actual DOM, known as the Virtual DOM. When the state of a component changes, React first updates the Virtual DOM, then efficiently compares this updated version with the previous Virtual DOM (a process called 'diffing'). It then calculates the minimal set of changes needed to update the real DOM. This optimized update process minimizes direct DOM manipulation, which is often slow, leading to significant performance improvements and a smoother user experience.\n\n4.  **SEO Friendly (Server-Side Rendering - SSR):** React applications can be rendered on the server-side before being sent to the client. This technique, known as Server-Side Rendering (SSR), allows search engine crawlers to fully index the content of the page, as they receive a complete HTML document rather than an empty `div` that JavaScript would fill later. This greatly improves Search Engine Optimization (SEO).\n\n5.  **Predictable Application Behavior (Unidirectional Data Flow):** React enforces a unidirectional (one-way) data flow. Data flows down from parent components to child components via props. This makes it easier to reason about how changes in data affect the application's UI, leading to more predictable behavior and simpler debugging compared to bidirectional data flows.\n\n6.  **Developer Experience (JSX):** The JSX syntax, which combines JavaScript and HTML/XML, is highly intuitive for many developers. It allows for a declarative way to describe UI components, making them easy to understand and write. This improves developer productivity and reduces the cognitive load associated with separating logic from UI.\n\n7.  **Team Development:** The component-based structure of React naturally creates clear boundaries for team collaboration. Different team members or teams can work independently on different components, and these components can be easily integrated, facilitating parallel development and faster delivery.\n\n8.  **Hierarchical Components:** React's design inherently supports a hierarchical component structure. Components that are visually nested in the UI design are naturally represented as child components within their parent components in the React component tree. This mapping between UI design and code structure makes it easier to manage and visualize the application's layout.",
          "examples": [
            {
              "id": "example_why_choose_react_1",
              "title": "Reusable Component Example",
              "code": "function Button({ onClick, label }) {\n  return (\n    <button onClick={onClick}>\n      {label}\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <div>\n      <Button onClick={() => alert('Clicked A!')} label=\"Button A\" />\n      <Button onClick={() => console.log('Clicked B')} label=\"Button B\" />\n    </div>\n  );\n}",
              "explanation": "This example showcases component reusability. The `Button` component is defined once but can be used multiple times throughout the application with different `onClick` handlers and `label` props, demonstrating its self-contained nature and ability to be composed into larger UIs.",
              "language": "javascript"
            },
            {
              "id": "example_why_choose_react_2",
              "title": "Unidirectional Data Flow Concept",
              "code": "// Parent component\nfunction Parent() {\n  const [message, setMessage] = React.useState('Hello from Parent');\n\n  return (\n    <div>\n      <h2>Parent Component</h2>\n      <Child message={message} /> {/* Data flows down to Child */}\n    </div>\n  );\n}\n\n// Child component\nfunction Child({ message }) {\n  return (\n    <p>Child received: {message}</p>\n  );\n}",
              "explanation": "This code illustrates unidirectional data flow. The `message` state is defined in the `Parent` component and passed down to the `Child` component as a prop. The `Child` component can only read this `message` prop; it cannot directly modify it, ensuring predictable data flow and easier state management.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_virtual_dom_open_1",
            "question_react_advantages_mcq_1",
            "question_unidirectional_data_flow_flashcard_1",
            "question_seo_ssr_open_2"
          ],
          "relatedTasks": [
            "task_reusable_component_builder",
            "task_virtual_dom_concept_simulation"
          ],
          "tags": [
            "React",
            "Architecture",
            "Performance",
            "SEO",
            "Developer Experience",
            "Virtual DOM",
            "Component-Based"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_basics",
            "DOM_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "large_scale_applications",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_jsx_dynamic_rendering",
          "title": "Dynamic Rendering in JSX: Conditionals and Lists",
          "content": "JSX allows embedding JavaScript expressions within `{}`. This capability is fundamental for creating dynamic UIs that respond to data and logic. Two common patterns for dynamic rendering are conditional rendering and list rendering.\n\n## JSX with Conditional Rendering\nConditional rendering allows you to render different elements or components based on certain conditions. Common patterns include:\n\n1.  **Ternary Operator (`condition ? expression1 : expression2`):** This is useful for simple `if-else` scenarios, where you want to render one of two possible outputs based on a boolean condition.\n\n    ```javascript\n    {isLoggedIn ? <WelcomeMessage /> : <SignInPrompt />}\n    ```\n\n2.  **Logical `&&` Operator (`condition && expression`):** If you want to render something only when a condition is true, otherwise render nothing (or `null`), the logical AND operator is concise. In JavaScript, `true && expression` evaluates to `expression`, and `false && expression` evaluates to `false` (which React renders as `null` or nothing).\n\n    ```javascript\n    {hasUnreadMessages && <NotificationIcon />}\n    ```\n\n3.  **`if`/`else` Statements (outside JSX):** While you cannot use `if`/`else` directly inside JSX, you can use them in the JavaScript part of your component to return different JSX structures.\n\n    ```javascript\n    function MyComponent({ user }) {\n      if (!user) {\n        return <p>Please log in.</p>;\n      }\n      return <p>Welcome, {user.name}!</p>;\n    }\n    ```\n\n## JSX with Lists\nRendering lists of items dynamically is a very common requirement. In React, you typically use the JavaScript `Array.prototype.map()` method to transform an array of data into an array of JSX elements.\n\n### The `key` Prop\nWhen rendering lists, each item in the list **must** have a unique `key` prop. React uses this `key` prop to identify which items have changed, are added, or are removed. This helps React efficiently update the UI and maintain the state of list items, preventing potential bugs and improving performance.\n\n-   **Uniqueness:** Keys must be unique among siblings in the list. They don't need to be globally unique.\n-   **Stability:** Ideally, keys should be stable and predictable. Using item IDs from your data source is the best practice (e.g., `item.id`).\n-   **Avoid Index as Key:** Using the array index (`index`) as a `key` is generally discouraged unless the list items are static and will never be reordered, filtered, or added/removed. This is because if the order changes, React might reuse components incorrectly, leading to unexpected behavior or performance issues.",
          "examples": [
            {
              "id": "example_jsx_dynamic_rendering_1",
              "title": "Conditional Rendering Examples",
              "code": "function Greeting({ isLoggedIn }) {\n  return (\n    <div>\n      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign in.</h1>}\n    </div>\n  );\n}\n\nfunction Notification({ hasMessages }) {\n  return (\n    <div>\n      {hasMessages && <span>You have unread messages</span>}\n    </div>\n  );\n}\n\n// Usage example:\n// <Greeting isLoggedIn={true} /> // Renders Welcome back!\n// <Notification hasMessages={false} /> // Renders nothing inside the div",
              "explanation": "This example demonstrates both the ternary operator for an `if-else` type condition and the logical `&&` operator for rendering content only when a condition is true. These are common and concise ways to handle conditional display within JSX.",
              "language": "javascript"
            },
            {
              "id": "example_jsx_dynamic_rendering_2",
              "title": "List Rendering with Unique Keys",
              "code": "function NumberList({ numbers }) {\n  return (\n    <ul>\n      {numbers.map((number) => (\n        <li key={number.toString()}>{number}</li> // Assuming numbers are unique\n      ))}\n    </ul>\n  );\n}\n\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map((todo) => (\n        <li key={todo.id}>{todo.text}</li> // Using a stable unique ID\n      ))}\n    </ul>\n  );\n}\n\n// Usage example:\n// <NumberList numbers={[1, 2, 3, 4]} />\n// <TodoList todos={[{ id: 1, text: 'Buy milk' }, { id: 2, text: 'Walk dog' }]} />",
              "explanation": "This example shows how to render a list of items using `Array.prototype.map()`. Crucially, each `<li>` element is given a unique `key` prop. For numbers, `number.toString()` is used assuming the numbers themselves are unique. For more complex objects like todos, a stable `id` property from the data is the preferred choice for the key.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_conditional_rendering_mcq_1",
            "question_key_prop_importance_open_1",
            "question_list_rendering_code_1",
            "question_index_as_key_flashcard_1"
          ],
          "relatedTasks": [
            "task_dynamic_todo_list"
          ],
          "tags": [
            "JSX",
            "React",
            "Conditional Rendering",
            "List Rendering",
            "Key Prop",
            "Performance",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_arrays",
            "JavaScript_conditionals",
            "JSX_fundamentals"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "interactive_uis",
            "data_display_components"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_jsx_attributes_mcq_1",
          "topic": "JSX vs HTML Differences",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct way to apply a CSS class to a div element in JSX?",
          "answer": "<div className=\"my-class\">Hello</div>",
          "options": [
            "<div class=\"my-class\">Hello</div>",
            "<div class-name=\"my-class\">Hello</div>",
            "<div className=\"my-class\">Hello</div>",
            "<div cssClass=\"my-class\">Hello</div>"
          ],
          "analysisPoints": [
            "Understanding of `className` attribute in JSX.",
            "Distinguishing between HTML `class` and JSX `className`.",
            "Knowledge of camelCase convention in JSX attributes."
          ],
          "keyConcepts": [
            "JSX attributes",
            "camelCase",
            "className"
          ],
          "evaluationCriteria": [
            "Correct application of JSX syntax for attributes.",
            "Recognition of common JSX pitfalls."
          ],
          "example": "The `class` attribute in HTML is a reserved keyword in JavaScript. To avoid conflicts and adhere to JavaScript's camelCase convention for property names, JSX uses `className` instead of `class`.",
          "tags": [
            "JSX",
            "Attributes",
            "Syntax",
            "Beginner"
          ],
          "prerequisites": [
            "JSX_fundamentals"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_self_closing_flashcard_1",
          "topic": "JSX vs HTML Differences",
          "level": "easy",
          "type": "flashcard",
          "question": "True or False: In JSX, all tags that do not have children must be explicitly self-closed.",
          "answer": "True",
          "options": [],
          "analysisPoints": [
            "Understanding of self-closing tag requirements in JSX.",
            "Distinction from HTML's optional self-closing for some tags."
          ],
          "keyConcepts": [
            "Self-closing tags",
            "JSX syntax"
          ],
          "evaluationCriteria": [
            "Recall of fundamental JSX syntax rules."
          ],
          "example": "In JSX, `<img src=\"image.jpg\" />` is correct, whereas `<img src=\"image.jpg\">` would be an error because JSX requires explicit closure for all non-parent tags.",
          "tags": [
            "JSX",
            "Syntax",
            "Flashcard"
          ],
          "prerequisites": [
            "JSX_fundamentals"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_style_open_1",
          "topic": "JSX vs HTML Differences",
          "level": "medium",
          "type": "open",
          "question": "Explain how the `style` attribute in JSX differs from its HTML counterpart and provide a practical example of applying multiple styles.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Understanding that JSX `style` takes a JavaScript object.",
            "Knowledge of camelCase for CSS properties within the style object.",
            "Ability to provide a correct code example."
          ],
          "keyConcepts": [
            "JSX style attribute",
            "JavaScript objects",
            "Inline styles",
            "camelCase CSS properties"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation.",
            "Correctness and completeness of the code example.",
            "Demonstration of understanding of JSX-specific styling rules."
          ],
          "example": "In HTML, the `style` attribute takes a CSS string, e.g., `<div style=\"color: red; font-size: 16px;\"></div>`. In JSX, it takes a JavaScript object where CSS properties are camelCased and values are strings or numbers. For example:\n\n```javascript\nconst myStyles = {\n  color: 'blue',\n  backgroundColor: '#f0f0f0',\n  padding: '10px'\n};\n\nconst element = <div style={myStyles}>This is a styled div.</div>;\n```\n\nThis approach allows for dynamic styling using JavaScript variables and logic.",
          "tags": [
            "JSX",
            "Styling",
            "Attributes",
            "Open-Ended"
          ],
          "prerequisites": [
            "JSX_fundamentals",
            "JavaScript_objects"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jsx_conversion_code_1",
          "topic": "JSX Fundamentals",
          "level": "medium",
          "type": "code",
          "question": "Convert the following HTML snippet into valid JSX, paying attention to all JSX-specific rules:\n\n```html\n<div class=\"card\">\n  <h2 onclick=\"showAlert('Welcome')\">Product Title</h2>\n  <img src=\"product.jpg\" alt=\"Product Image\">\n  <p style=\"margin-top: 10px; color: grey;\">A short description.</p>\n</div>\n```",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Correctly replacing `class` with `className`.",
            "Converting `onclick` string to `onClick` with a function reference.",
            "Properly self-closing the `img` tag.",
            "Transforming inline `style` string to a JavaScript object with camelCase properties."
          ],
          "keyConcepts": [
            "JSX attributes",
            "Self-closing tags",
            "Event handlers in JSX",
            "Inline styles in JSX"
          ],
          "evaluationCriteria": [
            "Syntactic correctness of the JSX output.",
            "Adherence to all specified JSX transformation rules.",
            "Ability to identify and correct common HTML-to-JSX conversion errors."
          ],
          "example": "```javascript\nfunction ProductCard() {\n  const cardStyles = { marginTop: '10px', color: 'grey' };\n\n  return (\n    <div className=\"card\">\n      <h2 onClick={() => alert('Welcome')}>Product Title</h2>\n      <img src=\"product.jpg\" alt=\"Product Image\" />\n      <p style={cardStyles}>A short description.</p>\n    </div>\n  );\n}\n```",
          "tags": [
            "JSX",
            "Code Challenge",
            "Syntax",
            "Conversion"
          ],
          "prerequisites": [
            "JSX_fundamentals"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jsx_compilation_mcq_1",
          "topic": "How JSX Works",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JSX:\n\n```jsx\nconst myElement = <a href=\"/home\">Go Home</a>;\n```\n\nWhich of the following `React.createElement()` calls is the correct equivalent after JSX compilation?",
          "answer": "React.createElement('a', { href: '/home' }, 'Go Home')",
          "options": [
            "React.createElement('a', 'href=/home', 'Go Home')",
            "React.createElement('a', { 'href': '/home' }, 'Go Home')",
            "React.createElement('a', { href: '/home' }, 'Go Home')",
            "React.createElement('a', null, { href: '/home' }, 'Go Home')"
          ],
          "analysisPoints": [
            "Understanding the order of arguments in `React.createElement` (type, props, children).",
            "Recognizing that props are passed as a JavaScript object.",
            "Correctly identifying string literals for element type and text content."
          ],
          "keyConcepts": [
            "JSX compilation",
            "`React.createElement`",
            "Props object"
          ],
          "evaluationCriteria": [
            "Accuracy in translating JSX to `React.createElement`.",
            "Knowledge of the `React.createElement` signature."
          ],
          "example": "The `React.createElement` function takes three main arguments: the type of element (e.g., `'a'`, `'div'`, or a component), an object containing its props (attributes), and then any children (text content or other elements). Options A and D incorrectly format the props or children. Option B uses string literals for the keys which is technically valid but less common than direct property names.",
          "tags": [
            "JSX",
            "Compilation",
            "React.createElement",
            "Core Concepts"
          ],
          "prerequisites": [
            "How_JSX_Works"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_babel_role_open_1",
          "topic": "How JSX Works",
          "level": "medium",
          "type": "open",
          "question": "What is the primary role of a tool like Babel in a React project, specifically concerning JSX? Why is it necessary?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explaining that Babel transpiles JSX to `React.createElement` calls.",
            "Mentioning that browsers don't natively understand JSX.",
            "Highlighting that it converts modern JS features to older compatible versions (though not explicitly in provided text, it's a common Babel role and good to mention for completeness)."
          ],
          "keyConcepts": [
            "Babel",
            "Transpilation",
            "JSX",
            "Browser compatibility",
            "`React.createElement`"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of the explanation.",
            "Demonstration of understanding the compilation process."
          ],
          "example": "Babel's primary role in a React project is to transpile JSX syntax into regular JavaScript that web browsers can understand. Browsers do not natively interpret JSX; they only understand standard JavaScript. Therefore, Babel transforms JSX elements like `<p>Hello</p>` into `React.createElement('p', null, 'Hello')` calls. This process is necessary because it allows developers to use the more declarative and readable JSX syntax while ensuring the code remains executable in any browser environment.",
          "tags": [
            "Babel",
            "JSX",
            "Transpilation",
            "Build Tools",
            "Open-Ended"
          ],
          "prerequisites": [
            "How_JSX_Works"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_create_element_flashcard_1",
          "topic": "How JSX Works",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React function does JSX compile into?",
          "answer": "React.createElement()",
          "options": [],
          "analysisPoints": [
            "Direct recall of the core compilation target."
          ],
          "keyConcepts": [
            "JSX compilation",
            "`React.createElement`"
          ],
          "evaluationCriteria": [
            "Accuracy of recall."
          ],
          "example": "N/A",
          "tags": [
            "JSX",
            "Compilation",
            "Flashcard"
          ],
          "prerequisites": [
            "How_JSX_Works"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_vs_js_performance_open_1",
          "topic": "How JSX Works",
          "level": "hard",
          "type": "open",
          "question": "From a performance perspective, is it more efficient to write React components using raw `React.createElement()` calls or JSX? Justify your answer.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Understanding that performance is not significantly different at runtime.",
            "Acknowledging that JSX is syntactic sugar.",
            "Focusing on developer experience/readability as the main differentiator.",
            "Mentioning that optimization happens at the React reconciliation phase, not at the JSX compilation level."
          ],
          "keyConcepts": [
            "JSX",
            "`React.createElement`",
            "Performance",
            "Developer Experience",
            "Syntactic Sugar",
            "Virtual DOM"
          ],
          "evaluationCriteria": [
            "Logical reasoning.",
            "Accuracy of technical details.",
            "Ability to differentiate between development-time convenience and runtime performance."
          ],
          "example": "From a performance perspective, there is no significant difference between writing React components using raw `React.createElement()` calls and using JSX. JSX is merely syntactic sugar that gets transpiled into `React.createElement()` calls by build tools like Babel. The browser ultimately executes the same `React.createElement()` calls regardless of whether you wrote JSX or the raw function calls.\n\nThe performance of a React application is primarily determined by how React's reconciliation algorithm (which uses the Virtual DOM) efficiently updates the actual DOM, and not by the initial syntax used to define the UI structure. The choice between JSX and raw `createElement` is purely for developer convenience and readability. JSX generally leads to more readable and maintainable code, especially for complex UI structures, which indirectly improves development efficiency.",
          "tags": [
            "JSX",
            "Performance",
            "React.createElement",
            "Advanced",
            "Open-Ended"
          ],
          "prerequisites": [
            "How_JSX_Works",
            "Virtual_DOM"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_virtual_dom_open_1",
          "topic": "Why Choose React?",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of the Virtual DOM in React and how it contributes to performance.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Defining Virtual DOM as a lightweight JS representation of the real DOM.",
            "Describing the 'diffing' algorithm (comparison of current vs. previous Virtual DOM).",
            "Explaining that only necessary changes are applied to the real DOM.",
            "Highlighting that direct DOM manipulation is slow and the Virtual DOM minimizes it."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Real DOM",
            "Diffing algorithm",
            "Reconciliation",
            "Performance optimization"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of the explanation.",
            "Ability to articulate the performance benefits."
          ],
          "example": "The Virtual DOM is a lightweight JavaScript object copy of the actual browser DOM (Document Object Model). When the state of a React component changes, instead of directly manipulating the slow real DOM, React first updates its Virtual DOM representation. Then, it compares this updated Virtual DOM with the previous Virtual DOM (a process called 'diffing'). Based on this comparison, React calculates the minimal set of changes required to update the real DOM. Finally, it applies only these necessary changes to the real DOM in an optimized batch. This approach significantly improves performance because direct manipulation of the browser's real DOM is a computationally expensive operation. By minimizing the number of actual DOM updates, the Virtual DOM makes React applications fast and efficient.",
          "tags": [
            "Virtual DOM",
            "React",
            "Performance",
            "Core Concepts",
            "Open-Ended"
          ],
          "prerequisites": [
            "DOM_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_advantages_mcq_1",
          "topic": "Why Choose React?",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a primary advantage of using React for web development?",
          "answer": "Guaranteed minimal bundle size",
          "options": [
            "Reusable Components",
            "Virtual DOM Performance",
            "SEO Friendly",
            "Guaranteed minimal bundle size"
          ],
          "analysisPoints": [
            "Identifying the core advantages of React.",
            "Recognizing that while React apps can be optimized, a 'guaranteed minimal bundle size' is not an inherent advantage and depends on various factors."
          ],
          "keyConcepts": [
            "React advantages",
            "Reusable components",
            "Virtual DOM",
            "SEO",
            "Bundle size"
          ],
          "evaluationCriteria": [
            "Understanding of React's key selling points.",
            "Ability to differentiate inherent advantages from general development considerations."
          ],
          "example": "React promotes reusable components, offers performance benefits through the Virtual DOM, and can be SEO-friendly via server-side rendering. However, a 'guaranteed minimal bundle size' is not an inherent advantage of React itself. While React is relatively small, the final bundle size depends heavily on the application's overall code, included libraries, build configurations, and optimization efforts.",
          "tags": [
            "React",
            "Advantages",
            "MCQ"
          ],
          "prerequisites": [
            "Why_Choose_React"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_unidirectional_data_flow_flashcard_1",
          "topic": "Why Choose React?",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary direction of data flow in a typical React application?",
          "answer": "Unidirectional (one-way, parent to child)",
          "options": [],
          "analysisPoints": [
            "Recalling the concept of unidirectional data flow.",
            "Understanding how data passes from parent to child via props."
          ],
          "keyConcepts": [
            "Unidirectional data flow",
            "Props",
            "State management"
          ],
          "evaluationCriteria": [
            "Accuracy of recall.",
            "Understanding of a fundamental React principle."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Data Flow",
            "Flashcard"
          ],
          "prerequisites": [
            "Why_Choose_React"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_seo_ssr_open_2",
          "topic": "Why Choose React?",
          "level": "medium",
          "type": "open",
          "question": "How does React's capability to run on the server contribute to SEO-friendliness?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explaining Server-Side Rendering (SSR).",
            "Connecting SSR to how search engine crawlers interact with web pages.",
            "Contrasting with client-side rendering where content is loaded dynamically."
          ],
          "keyConcepts": [
            "SEO",
            "Server-Side Rendering (SSR)",
            "Client-Side Rendering (CSR)",
            "Search Engine Crawlers"
          ],
          "evaluationCriteria": [
            "Clear explanation of SSR.",
            "Understanding of SEO implications.",
            "Ability to compare CSR vs. SSR in the context of SEO."
          ],
          "example": "React's capability to run on the server is known as Server-Side Rendering (SSR). This means that the initial HTML of the application can be generated on the server before being sent to the browser. When a search engine crawler (like Googlebot) visits an SSR-enabled React application, it receives a fully pre-rendered HTML page with all its content already present. This is crucial for SEO because many older or simpler crawlers might not execute JavaScript, or might do so inefficiently, thus failing to see content that is dynamically loaded by client-side JavaScript. By providing a complete HTML document upfront, SSR ensures that all content is discoverable and indexable by search engines, greatly improving the application's SEO performance compared to purely client-side rendered applications.",
          "tags": [
            "React",
            "SEO",
            "SSR",
            "Open-Ended"
          ],
          "prerequisites": [
            "Why_Choose_React"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_conditional_rendering_mcq_1",
          "topic": "Dynamic Rendering in JSX",
          "level": "medium",
          "type": "mcq",
          "question": "You want to display a 'Login' button only if the user is NOT authenticated. Which JSX conditional rendering approach is most appropriate and concise for this scenario?",
          "answer": "{!isAuthenticated && <button>Login</button>}",
          "options": [
            "{isAuthenticated ? null : <button>Login</button>}",
            "{!isAuthenticated ? <button>Login</button> : null}",
            "{!isAuthenticated && <button>Login</button>}",
            "if (!isAuthenticated) { return <button>Login</button>; } else { return null; }"
          ],
          "analysisPoints": [
            "Understanding the common patterns for conditional rendering.",
            "Identifying the most concise pattern for rendering 'if true, render X, else render nothing'.",
            "Distinguishing between `&&` operator and ternary operator for specific use cases.",
            "Knowing that `if` statements cannot be directly inside JSX."
          ],
          "keyConcepts": [
            "Conditional rendering",
            "Logical && operator",
            "Ternary operator",
            "JSX expressions"
          ],
          "evaluationCriteria": [
            "Correct application of conditional rendering syntax.",
            "Choosing the most idiomatic React/JSX solution for the given condition."
          ],
          "example": "The logical `&&` operator is often the most concise way to render something conditionally when you only care about one branch (e.g., 'if condition is true, render this component, otherwise render nothing'). Option A and B use the ternary operator which is also correct but slightly more verbose when one branch is `null`. Option D is valid JavaScript but cannot be directly embedded within JSX. The correct answer uses `!isAuthenticated && <button>Login</button>`.",
          "tags": [
            "Conditional Rendering",
            "JSX",
            "Syntax",
            "MCQ"
          ],
          "prerequisites": [
            "JSX_dynamic_rendering"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_key_prop_importance_open_1",
          "topic": "Dynamic Rendering in JSX",
          "level": "hard",
          "type": "open",
          "question": "Explain the purpose and importance of the `key` prop when rendering lists in React. What are the potential issues if `key`s are not used or used incorrectly (e.g., using array index as key for mutable lists)?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Defining `key` as a unique identifier for list items.",
            "Explaining how React uses `key` for efficient reconciliation (diffing).",
            "Discussing performance benefits (minimal DOM updates).",
            "Detailing potential bugs: incorrect state, re-ordering issues, UI inconsistencies, performance degradation when keys are unstable or missing.",
            "Explaining why index as key is problematic for mutable lists."
          ],
          "keyConcepts": [
            "Key prop",
            "List rendering",
            "Reconciliation",
            "Virtual DOM",
            "Performance",
            "State preservation",
            "Array index as key"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of `key`'s role.",
            "Accurate description of issues arising from incorrect `key` usage.",
            "Clarity and depth of understanding."
          ],
          "example": "The `key` prop in React is a special string attribute that you need to include when creating lists of elements. React uses `key`s to identify each item in a list uniquely. This is crucial for React's reconciliation algorithm (the diffing process of the Virtual DOM).\n\n**Purpose and Importance:**\nWhen a list changes (items are added, removed, or reordered), React uses the `key` prop to efficiently determine which actual DOM elements need to be updated, reordered, or removed, rather than re-rendering the entire list. Without unique `key`s, React might struggle to identify individual items, leading to inefficient updates and potential bugs. `key`s help React maintain the identity and state of components across renders.\n\n**Issues with Missing or Incorrect Keys (e.g., using array index for mutable lists):**\n1.  **Performance Problems:** Without unique and stable keys, React might re-render more DOM elements than necessary, leading to performance degradation, especially in large lists.\n2.  **Incorrect Component State:** If a list item changes its position, and the `key` is based on its index, React might reuse a component instance at a new index, carrying over its old internal state (e.g., input values, checkboxes checked state) to a different data item. This leads to visual bugs and incorrect data.\n3.  **UI Glitches:** Animations, transitions, or focus management might behave unexpectedly as React struggles to correctly track elements.\n4.  **Debugging Difficulty:** Such issues can be very difficult to debug because the underlying data might be correct, but the UI misbehaves due to React's inability to correctly identify elements.\n\nUsing the array `index` as a `key` is problematic when the list can change (items added, removed, reordered) because the index is not stable; it changes if the array is modified. For stable lists, a unique ID from your data (e.g., `item.id`) is always the best practice.",
          "tags": [
            "Key Prop",
            "List Rendering",
            "Performance",
            "React Concepts",
            "Advanced",
            "Open-Ended"
          ],
          "prerequisites": [
            "JSX_dynamic_rendering",
            "React_components"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_list_rendering_code_1",
          "topic": "Dynamic Rendering in JSX",
          "level": "medium",
          "type": "code",
          "question": "Given an array of user objects, render an unordered list where each list item displays the user's name and email. Ensure proper handling of `key` props.\n\n```javascript\nconst users = [\n  { id: 101, name: 'Alice', email: 'alice@example.com' },\n  { id: 102, name: 'Bob', email: 'bob@example.com' },\n  { id: 103, name: 'Charlie', email: 'charlie@example.com' }\n];\n\n// Your React component should render this list\nfunction UserList({ users }) {\n  // Implement rendering logic here\n}\n```",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Correctly using `Array.prototype.map()` to transform data into JSX elements.",
            "Applying the `key` prop to each list item.",
            "Using a stable and unique identifier (`user.id`) for the `key`.",
            "Correctly accessing nested properties (name, email)."
          ],
          "keyConcepts": [
            "List rendering",
            "`map` method",
            "`key` prop",
            "JSX expressions"
          ],
          "evaluationCriteria": [
            "Syntactic correctness of the React component.",
            "Proper use of `key` prop.",
            "Accurate rendering of user data."
          ],
          "example": "```javascript\nfunction UserList({ users }) {\n  return (\n    <ul>\n      {users.map((user) => (\n        <li key={user.id}> {/* Using user.id as a stable unique key */}\n          <strong>{user.name}</strong> - {user.email}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// To use it:\n// function App() {\n//   const users = [\n//     { id: 101, name: 'Alice', email: 'alice@example.com' },\n//     { id: 102, name: 'Bob', email: 'bob@example.com' },\n//     { id: 103, name: 'Charlie', email: 'charlie@example.com' }\n//   ];\n//   return <UserList users={users} />;\n// }\n```",
          "tags": [
            "List Rendering",
            "Code Challenge",
            "JSX",
            "Key Prop"
          ],
          "prerequisites": [
            "JSX_dynamic_rendering",
            "JavaScript_arrays"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_index_as_key_flashcard_1",
          "topic": "Dynamic Rendering in JSX",
          "level": "medium",
          "type": "flashcard",
          "question": "When is it generally safe to use the array index as the `key` prop for list items in React?",
          "answer": "When the list is static and its items will never be reordered, filtered, or added/removed.",
          "options": [],
          "analysisPoints": [
            "Understanding the limitations of using index as key.",
            "Knowing the specific conditions under which it's acceptable."
          ],
          "keyConcepts": [
            "Key prop",
            "List rendering",
            "Array index",
            "Static lists"
          ],
          "evaluationCriteria": [
            "Accurate recall of the `key` prop best practices."
          ],
          "example": "N/A",
          "tags": [
            "Key Prop",
            "List Rendering",
            "Flashcard"
          ],
          "prerequisites": [
            "JSX_dynamic_rendering"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_html_to_jsx_conversion",
          "title": "HTML to JSX Conversion Challenge",
          "description": "\nConvert the following complex HTML structure into a valid React JSX component. Pay close attention to all JSX-specific rules, including attribute naming, self-closing tags, and inline styles.\n\n**HTML Snippet:**\n```html\n<div class=\"app-container\">\n  <header>\n    <h1 id=\"main-title\" onclick=\"console.log('Title Clicked!')\">My Awesome App</h1>\n    <nav>\n      <ul>\n        <li><a href=\"#home\">Home</a></li>\n        <li><a href=\"#about\">About</a></li>\n        <li><a href=\"#contact\">Contact</a></li>\n      </ul>\n    </nav>\n  </header>\n  <main>\n    <section style=\"background-color: #f0f0f0; padding: 20px;\">\n      <h2>Welcome Section</h2>\n      <p>This is a paragraph of text.</p>\n      <input type=\"text\" placeholder=\"Enter your name\" required>\n      <br>\n      <img src=\"./assets/banner.png\" alt=\"Banner Image\" width=\"500\" height=\"300\">\n    </section>\n    <footer style=\"font-size: 14px; text-align: center; color: #666;\">\n      &copy; 2023 My Company. All rights reserved.\n    </footer>\n  </main>\n</div>\n```\n\n**Requirements:**\n1.  Create a functional React component (e.g., `AppLayout`).\n2.  Ensure all HTML attributes are converted to their correct JSX counterparts (`class` to `className`, `onclick` to `onClick`).\n3.  All self-closing tags (`input`, `br`, `img`) must be correctly self-closed with a trailing slash.\n4.  Inline `style` attributes must be converted to JavaScript objects, with CSS properties in camelCase.\n5.  The entire JSX structure should be wrapped in parentheses if it spans multiple lines.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nfunction AppLayout() {\n  return (\n    // Your JSX code here\n    // Remember multiline JSX needs parentheses\n    // Pay attention to className, onClick, style, and self-closing tags\n    <div>\n      {/* Start your conversion here */}\n    </div>\n  );\n}\n\nexport default AppLayout;",
          "solutionCode": "import React from 'react';\n\nfunction AppLayout() {\n  const sectionStyles = {\n    backgroundColor: '#f0f0f0',\n    padding: '20px'\n  };\n\n  const footerStyles = {\n    fontSize: '14px',\n    textAlign: 'center',\n    color: '#666'\n  };\n\n  return (\n    <div className=\"app-container\">\n      <header>\n        <h1 id=\"main-title\" onClick={() => console.log('Title Clicked!')}>My Awesome App</h1>\n        <nav>\n          <ul>\n            <li><a href=\"#home\">Home</a></li>\n            <li><a href=\"#about\">About</a></li>\n            <li><a href=\"#contact\">Contact</a></li>\n          </ul>\n        </nav>\n      </header>\n      <main>\n        <section style={sectionStyles}>\n          <h2>Welcome Section</h2>\n          <p>This is a paragraph of text.</p>\n          <input type=\"text\" placeholder=\"Enter your name\" required={true} /> {/* 'required' can be a boolean */}\n          <br />\n          <img src=\"./assets/banner.png\" alt=\"Banner Image\" width=\"500\" height=\"300\" />\n        </section>\n        <footer style={footerStyles}>\n          &copy; 2023 My Company. All rights reserved.\n        </footer>\n      </main>\n    </div>\n  );\n}\n\nexport default AppLayout;",
          "testCases": [
            "The output JSX should compile without errors.",
            "The `div` element should have `className=\"app-container\"`.",
            "The `h1` element should have an `onClick` prop with a function.",
            "The `input`, `br`, and `img` tags must be self-closed (e.g., `<input ... />`).",
            "The `section` and `footer` elements must have their `style` attributes as JavaScript objects with camelCased properties (e.g., `backgroundColor`, `fontSize`).",
            "The `required` attribute on the input should be treated as a boolean prop `required={true}`."
          ],
          "hints": [
            "Remember that event handlers in JSX (`onClick`) expect a JavaScript function reference, not a string.",
            "Pay close attention to camelCasing for CSS properties like `background-color` becoming `backgroundColor`.",
            "Boolean attributes like `required` can be written as `required` or `required={true}` in JSX.",
            "Make sure the root JSX element (the `div.app-container`) and any other multiline JSX are properly wrapped in parentheses."
          ],
          "tags": [
            "JSX",
            "Conversion",
            "Syntax",
            "Frontend Interview",
            "React"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "JSX_fundamentals"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "JSX attributes",
            "Self-closing tags",
            "Inline styles",
            "Event handlers"
          ]
        },
        {
          "id": "task_manual_create_element",
          "title": "Manually Replicate JSX with React.createElement()",
          "description": "\nYour task is to rewrite a given JSX snippet using only `React.createElement()` calls. This exercise will deepen your understanding of how JSX is internally processed by React.\n\n**JSX Snippet:**\n```jsx\n<div className=\"wrapper\">\n  <h1>Welcome!</h1>\n  <p>Learn more <a href=\"/docs\">here</a>.</p>\n  <img src=\"logo.svg\" alt=\"Logo\" />\n</div>\n```\n\n**Requirements:**\n1.  Create a functional React component (e.g., `ManualElementCreator`).\n2.  Inside this component, construct the exact same UI structure as the provided JSX, but *without* using any JSX syntax. Use only `React.createElement()` calls.\n3.  Ensure all attributes (like `className`, `href`, `src`, `alt`) and child elements/text nodes are correctly passed as arguments to `React.createElement()`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nfunction ManualElementCreator() {\n  return (\n    // Your React.createElement() calls go here\n    // Hint: Start from the outermost element and nest inwards\n    // Example for a simple div: React.createElement('div', null, 'Hello')\n    null // Replace this with your implementation\n  );\n}\n\nexport default ManualElementCreator;",
          "solutionCode": "import React from 'react';\n\nfunction ManualElementCreator() {\n  return React.createElement(\n    'div',\n    { className: 'wrapper' },\n    React.createElement('h1', null, 'Welcome!'),\n    React.createElement(\n      'p',\n      null,\n      'Learn more ',\n      React.createElement('a', { href: '/docs' }, 'here'),\n      '.' // Text nodes after elements are separate children\n    ),\n    React.createElement('img', { src: 'logo.svg', alt: 'Logo' })\n  );\n}\n\nexport default ManualElementCreator;",
          "testCases": [
            "The component should render the exact same visual output as the original JSX.",
            "The rendered HTML structure should match (e.g., `div.wrapper > h1 + p + img`).",
            "All attributes should be correctly applied to their respective elements.",
            "No JSX syntax should be present in the solution code, only `React.createElement`."
          ],
          "hints": [
            "Remember the signature of `React.createElement(type, props, ...children)`.",
            "For nested elements, the child elements become subsequent arguments to the parent `React.createElement` call.",
            "Plain text content within an element is also treated as a child argument."
          ],
          "tags": [
            "React.createElement",
            "JSX",
            "Compilation",
            "Core Concepts",
            "Code Challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "How_JSX_Works"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "JSX compilation",
            "Virtual DOM",
            "React elements"
          ]
        },
        {
          "id": "task_reusable_component_builder",
          "title": "Building Reusable UI Components",
          "description": "\nYour task is to create a set of reusable React components to build a simple `ProductCard` UI. This exercise emphasizes component reusability, prop drilling, and maintaining clean boundaries.\n\n**Requirements:**\n1.  **`Button` Component:** Create a reusable `Button` component that accepts `onClick` and `label` props. It should render a simple HTML `<button>`.\n2.  **`ProductImage` Component:** Create a `ProductImage` component that accepts `src` and `alt` props. It should render an `<img>` tag.\n3.  **`ProductTitle` Component:** Create a `ProductTitle` component that accepts a `title` prop. It should render an `<h2>` tag.\n4.  **`ProductDescription` Component:** Create a `ProductDescription` component that accepts a `description` prop. It should render a `<p>` tag.\n5.  **`ProductCard` Component:** Create a `ProductCard` component that composes the above components (`ProductImage`, `ProductTitle`, `ProductDescription`) and also includes a `Button`. It should accept `product` object as a prop (containing `id`, `name`, `imageUrl`, `description`) and an `onAddToCart` function.\n6.  **`App` Component:** In the `App` component, render at least two `ProductCard` instances with different product data, demonstrating reusability.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// 1. Create a reusable Button component here\n// function Button({ onClick, label }) { ... }\n\n// 2. Create a ProductImage component here\n// function ProductImage({ src, alt }) { ... }\n\n// 3. Create a ProductTitle component here\n// function ProductTitle({ title }) { ... }\n\n// 4. Create a ProductDescription component here\n// function ProductDescription({ description }) { ... }\n\n// 5. Create a ProductCard component here, composing the above\n// function ProductCard({ product, onAddToCart }) { ... }\n\nfunction App() {\n  const productA = {\n    id: 'prod1',\n    name: 'Fancy Gadget',\n    imageUrl: 'https://via.placeholder.com/150/FF0000/FFFFFF?text=GadgetA',\n    description: 'A cutting-edge gadget for your daily needs.'\n  };\n\n  const productB = {\n    id: 'prod2',\n    name: 'Magic Widget',\n    imageUrl: 'https://via.placeholder.com/150/0000FF/FFFFFF?text=WidgetB',\n    description: 'Unlock new possibilities with this magic widget.'\n  };\n\n  const handleAddToCart = (productId) => {\n    console.log(`Adding product ${productId} to cart.`);\n    alert(`Product ${productId} added!`);\n  };\n\n  return (\n    <div className=\"app-container\">\n      <h1>Our Products</h1>\n      {/* Render ProductCard instances here */}\n      {/* Example: <ProductCard product={productA} onAddToCart={handleAddToCart} /> */}\n    </div>\n  );\n}\n\nexport default App;",
          "solutionCode": "import React from 'react';\n\n// 1. Button Component\nfunction Button({ onClick, label }) {\n  return (\n    <button onClick={onClick} style={{ padding: '8px 15px', cursor: 'pointer', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px' }}>\n      {label}\n    </button>\n  );\n}\n\n// 2. ProductImage Component\nfunction ProductImage({ src, alt }) {\n  return (\n    <img src={src} alt={alt} style={{ maxWidth: '100%', height: 'auto', display: 'block', marginBottom: '10px' }} />\n  );\n}\n\n// 3. ProductTitle Component\nfunction ProductTitle({ title }) {\n  return (\n    <h2 style={{ fontSize: '1.5em', marginBottom: '8px' }}>{title}</h2>\n  );\n}\n\n// 4. ProductDescription Component\nfunction ProductDescription({ description }) {\n  return (\n    <p style={{ fontSize: '0.9em', color: '#555', marginBottom: '15px' }}>{description}</p>\n  );\n}\n\n// 5. ProductCard Component\nfunction ProductCard({ product, onAddToCart }) {\n  const cardStyle = {\n    border: '1px solid #ddd',\n    borderRadius: '8px',\n    padding: '20px',\n    margin: '15px',\n    width: '250px',\n    boxShadow: '0 2px 4px rgba(0,0,0,0.1)',\n    display: 'inline-block',\n    verticalAlign: 'top'\n  };\n\n  return (\n    <div style={cardStyle}>\n      <ProductImage src={product.imageUrl} alt={product.name} />\n      <ProductTitle title={product.name} />\n      <ProductDescription description={product.description} />\n      <Button onClick={() => onAddToCart(product.id)} label=\"Add to Cart\" />\n    </div>\n  );\n}\n\nfunction App() {\n  const productA = {\n    id: 'prod1',\n    name: 'Fancy Gadget',\n    imageUrl: 'https://via.placeholder.com/150/FF0000/FFFFFF?text=GadgetA',\n    description: 'A cutting-edge gadget for your daily needs.'\n  };\n\n  const productB = {\n    id: 'prod2',\n    name: 'Magic Widget',\n    imageUrl: 'https://via.placeholder.com/150/0000FF/FFFFFF?text=WidgetB',\n    description: 'Unlock new possibilities with this magic widget.'\n  };\n\n  const handleAddToCart = (productId) => {\n    console.log(`Adding product ${productId} to cart.`);\n    alert(`Product ${productId} added!`);\n  };\n\n  return (\n    <div className=\"app-container\" style={{ fontFamily: 'Arial, sans-serif', textAlign: 'center' }}>\n      <h1>Our Products</h1>\n      <div style={{ display: 'flex', justifyContent: 'center', flexWrap: 'wrap' }}>\n        <ProductCard product={productA} onAddToCart={handleAddToCart} />\n        <ProductCard product={productB} onAddToCart={handleAddToCart} />\n      </div>\n    </div>\n  );\n}\n\nexport default App;",
          "testCases": [
            "All individual components (`Button`, `ProductImage`, `ProductTitle`, `ProductDescription`) should render correctly with their respective props.",
            "The `ProductCard` component should successfully compose and render all child components.",
            "The `ProductCard` component should correctly pass product data to its sub-components.",
            "Clicking the 'Add to Cart' button on a `ProductCard` should trigger the `onAddToCart` handler with the correct `productId`.",
            "The `App` component should render at least two distinct `ProductCard` instances.",
            "The code should demonstrate proper prop drilling where necessary."
          ],
          "hints": [
            "Break down the UI into the smallest reusable units first.",
            "Think about what props each component needs to be truly reusable.",
            "Remember that functional components receive props as their first argument (an object).",
            "Use inline styles for simplicity, but convert them to JavaScript objects as required by JSX.",
            "For the `onAddToCart` prop, you'll need to pass a function that takes the `productId`."
          ],
          "tags": [
            "React Components",
            "Reusability",
            "Props",
            "Component Composition",
            "Frontend Interview"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "Why_Choose_React",
            "JSX_fundamentals"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component-based architecture",
            "High Cohesion, Low Coupling",
            "Unidirectional Data Flow"
          ]
        },
        {
          "id": "task_dynamic_todo_list",
          "title": "Dynamic Todo List with Conditional and List Rendering",
          "description": "\nCreate a React component that manages and displays a dynamic list of todo items. This task will require you to use conditional rendering and list rendering with proper `key` management.\n\n**Requirements:**\n1.  **`TodoList` Component:**\n    *   Accepts a `todos` array (each todo object has `id`, `text`, `isCompleted` properties).\n    *   Renders an unordered list (`<ul>`) of todo items.\n    *   Each list item (`<li>`) should display the todo's `text`.\n    *   If `isCompleted` is `true`, the text should be strike-through (e.g., `<del>text</del>` or `text-decoration: line-through`).\n    *   **Crucially, each `<li>` must have a unique `key` prop using the `todo.id`.\n2.  **`EmptyStateMessage` Component:**\n    *   This component should simply display a message like \"No todos yet! Add some to get started.\"\n3.  **`App` Component:**\n    *   Manage a state variable for the `todos` array.\n    *   Render the `TodoList` component if there are todos.\n    *   Conditionally render the `EmptyStateMessage` component if the `todos` array is empty.\n    *   (Bonus) Include a button or input to add new todos and mark existing ones as complete/incomplete to demonstrate state changes affecting the list.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// TodoList component placeholder\n// function TodoList({ todos }) { ... }\n\n// EmptyStateMessage component placeholder\n// function EmptyStateMessage() { ... }\n\nfunction App() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'Learn React hooks', isCompleted: false },\n    { id: 2, text: 'Build a todo app', isCompleted: true },\n    { id: 3, text: 'Master conditional rendering', isCompleted: false },\n  ]);\n\n  // Bonus: Add handlers for adding/toggling todos here\n\n  return (\n    <div className=\"App\">\n      <h1>My Todo List</h1>\n      {/* Conditional rendering logic here */}\n      {/* Example: {todos.length > 0 ? <TodoList todos={todos} /> : <EmptyStateMessage />} */}\n    </div>\n  );\n}\n\nexport default App;",
          "solutionCode": "import React, { useState } from 'react';\n\n// TodoList component\nfunction TodoList({ todos, onToggleComplete }) {\n  return (\n    <ul style={{ listStyleType: 'none', padding: 0 }}>\n      {todos.map((todo) => (\n        <li\n          key={todo.id} // Essential for list rendering performance and correctness\n          onClick={() => onToggleComplete(todo.id)}\n          style={{\n            textDecoration: todo.isCompleted ? 'line-through' : 'none',\n            cursor: 'pointer',\n            padding: '8px',\n            margin: '5px 0',\n            border: '1px solid #eee',\n            borderRadius: '4px',\n            backgroundColor: todo.isCompleted ? '#f0f0f0' : 'white',\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center'\n          }}\n        >\n          <span>{todo.text}</span>\n          {todo.isCompleted && <span style={{ color: 'green', fontSize: '0.8em' }}>&#10003; Done</span>}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// EmptyStateMessage component\nfunction EmptyStateMessage() {\n  return (\n    <p style={{ color: '#888', fontStyle: 'italic' }}>No todos yet! Add some to get started.</p>\n  );\n}\n\nfunction App() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'Learn React hooks', isCompleted: false },\n    { id: 2, text: 'Build a todo app', isCompleted: true },\n    { id: 3, text: 'Master conditional rendering', isCompleted: false },\n  ]);\n\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newTodo = {\n      id: Date.now(), // Simple unique ID for demo\n      text: newTodoText.trim(),\n      isCompleted: false,\n    };\n    setTodos([...todos, newTodo]);\n    setNewTodoText('');\n  };\n\n  const handleToggleComplete = (id) => {\n    setTodos(todos.map(todo =>\n      todo.id === id ? { ...todo, isCompleted: !todo.isCompleted } : todo\n    ));\n  };\n\n  return (\n    <div className=\"App\" style={{ maxWidth: '500px', margin: '30px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px', fontFamily: 'Arial, sans-serif' }}>\n      <h1>My Todo List</h1>\n      <div style={{ marginBottom: '20px' }}>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add a new todo...\"\n          onKeyPress={(e) => { if (e.key === 'Enter') handleAddTodo(); }}\n          style={{ padding: '8px', marginRight: '10px', width: '70%', borderRadius: '4px', border: '1px solid #ddd' }}\n        />\n        <button onClick={handleAddTodo} style={{ padding: '8px 15px', borderRadius: '4px', border: 'none', backgroundColor: '#28a745', color: 'white', cursor: 'pointer' }}>Add Todo</button>\n      </div>\n\n      {todos.length > 0 ? (\n        <TodoList todos={todos} onToggleComplete={handleToggleComplete} />\n      ) : (\n        <EmptyStateMessage />\n      )}\n    </div>\n  );\n}\n\nexport default App;",
          "testCases": [
            "The `TodoList` should render all items from the `todos` array.",
            "Completed todos should have strike-through text.",
            "Each `<li>` element in `TodoList` must have a unique `key` prop, preferably using `todo.id`.",
            "When `todos` array is empty, `EmptyStateMessage` should be displayed.",
            "When `todos` array is not empty, `TodoList` should be displayed, and `EmptyStateMessage` should not.",
            "Adding a new todo via the input field should correctly update the list.",
            "Clicking on a todo item should toggle its `isCompleted` status and update its style."
          ],
          "hints": [
            "Use the `Array.prototype.map()` method to iterate over the `todos` array and return a new array of `<li>` elements.",
            "For conditional styling (strike-through), you can use a ternary operator within the `style` prop of the `<li>` element.",
            "The `key` prop is critical for performance and correctness in lists. Always use a stable, unique identifier for each item.",
            "For conditional rendering, consider using the ternary operator (`condition ? <ComponentA /> : <ComponentB />`) or the logical `&&` operator (`condition && <Component />`).",
            "The `useState` hook will be essential for managing the `todos` array and the input field value."
          ],
          "tags": [
            "React",
            "Conditional Rendering",
            "List Rendering",
            "Key Prop",
            "State Management",
            "Frontend Interview",
            "Dynamic UI"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "JSX_dynamic_rendering",
            "React_useState"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component state",
            "Props",
            "Event handling",
            "Unidirectional data flow"
          ]
        }
      ]
    }
  },
  {
    "id": "0df84cf5-e861-42ae-9360-8d0826784d37",
    "startLine": 2700,
    "endLine": 2799,
    "processedDate": "2025-06-17T08:27:45.590Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_jsx_fragments",
          "title": "JSX Fragments: Grouping Elements Without Extra DOM Nodes",
          "content": "JSX Fragments allow you to group multiple elements together without introducing an additional wrapper DOM node into the final rendered output. This is particularly useful when a component needs to return multiple elements, but you want to avoid affecting the component's layout or the overall DOM structure with unnecessary parent elements.\n\n## Syntax\nThere are two primary ways to use Fragments:\n\n1.  **Long Syntax**: Using `React.Fragment`\n    This explicit form is necessary when you need to pass a `key` prop to the Fragment, such as when rendering a list of fragments.\n\n    ```typescript\n    import React from 'react';\n\n    function ListItems() {\n      return (\n        <React.Fragment>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </React.Fragment>\n      );\n    }\n    ```\n\n2.  **Short Syntax (Shorthand)**: Using `<></>`\n    This is a more concise and commonly used syntax when a `key` is not required. It's essentially syntactic sugar for `React.Fragment`.\n\n    ```typescript\n    function ListItems() {\n      return (\n        <>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </>\n      );\n    }\n    ```\n\n## Benefits of Fragments Over Container Divs\nUsing Fragments instead of a `div` or other wrapper element to group children provides several significant advantages, especially in complex applications:\n\n1.  **Performance**: Fragments lead to slightly better performance and reduced memory consumption because they do not create an extra DOM node. While the impact might be negligible for small applications, it becomes noticeable in very large and deeply nested component trees where many components might otherwise introduce superfluous wrapper divs.\n\n2.  **CSS Layout Integrity**: Many CSS layout mechanisms, such as Flexbox and CSS Grid, rely on specific parent-child relationships. Introducing an extra `div` in the middle of these relationships can break the intended layout or make it more complicated to achieve. Fragments allow components to return multiple children directly, maintaining the integrity of the CSS layout.\n\n3.  **DOM Inspector Clarity**: When debugging with browser developer tools, the DOM Inspector remains cleaner and less cluttered. Without unnecessary wrapper `div`s, it's easier to inspect the actual structure and identify relevant elements.\n\n4.  **Semantic HTML**: Fragments help in maintaining proper semantic HTML structure. For example, a `<table>` must contain `<tbody>`, `<thead>`, `<tfoot>` directly, and `<tbody>` must contain `<tr>`. Introducing a `div` between these elements would create invalid HTML, potentially impacting accessibility and SEO. Fragments allow you to return valid HTML structures.",
          "examples": [
            {
              "id": "example_jsx_fragments_1",
              "title": "Basic Fragment Usage",
              "code": "import React from 'react';\n\nfunction GreetingList() {\n  return (\n    <>\n      <h1>Hello!</h1>\n      <p>Welcome to the example.</p>\n    </>\n  );\n}\n\n// This component, when rendered, will output directly:\n// <h1>Hello!</h1>\n// <p>Welcome to the example.</p>\n// without an enclosing div.",
              "explanation": "This example demonstrates the most common use case for Fragments: grouping a few sibling elements without adding an extra `div` wrapper. The shorthand syntax `<></>` is used for conciseness. When `GreetingList` is rendered, its output will directly become siblings in the DOM, preserving the desired layout and semantic structure.",
              "language": "typescript"
            },
            {
              "id": "example_jsx_fragments_2",
              "title": "Fragment with Key Prop in Lists",
              "code": "import React from 'react';\n\ninterface ItemProps {\n  id: number;\n  name: string;\n}\n\nfunction TableRows({ items }: { items: ItemProps[] }) {\n  return (\n    <React.Fragment>\n      {items.map(item => (\n        <React.Fragment key={item.id}>\n          <td>{item.id}</td>\n          <td>{item.name}</td>\n        </React.Fragment>\n      ))}\n    </React.Fragment>\n  );\n}\n\n// Usage example within a table body:\n// <tbody>\n//   <TableRows items={[{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }]} />\n// </tbody>\n// This will render directly:\n// <tbody>\n//   <td>1</td><td>Apple</td>\n//   <td>2</td><td>Banana</td>\n// </tbody>\n// (Note: This is a simplified example; typically, each row would be a <tr>, but this shows Fragment with keys.)",
              "explanation": "This example shows a more advanced use case where `React.Fragment` (the long syntax) is required because a `key` prop needs to be passed. When mapping over a list and each item needs to render multiple sibling elements (e.g., `<td>`s for a table row, if `<tr>` itself is not the wrapper for the entire row), you might need a fragment to group them. The `key` prop is crucial for React's reconciliation process to efficiently identify and update list items. Here, `React.Fragment` allows us to apply a unique `key` to each logical 'item' being rendered, even though it doesn't create a DOM node.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_jsx_fragments_1",
            "question_jsx_fragments_2",
            "question_jsx_fragments_3",
            "question_jsx_fragments_4",
            "question_jsx_fragments_5",
            "question_jsx_fragments_6"
          ],
          "relatedTasks": [
            "task_jsx_fragments_table_row"
          ],
          "tags": [
            "React",
            "JSX",
            "Fragments",
            "DOM",
            "Performance",
            "Semantic HTML",
            "Frontend"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "jsx_syntax"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_component_design",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_virtual_dom_reconciliation",
          "title": "Virtual DOM and Reconciliation in React",
          "content": "The Virtual DOM (VDOM) is a core concept and one of React's key optimization techniques. It is a lightweight JavaScript object representation of the actual browser DOM (Document Object Model). React uses the VDOM to efficiently update the user interface.\n\n## How Virtual DOM Works\nReact's rendering process involving the Virtual DOM follows these steps:\n\n1.  **Creation**: When a React component renders for the first time, or when its state or props change, React creates a new virtual DOM tree. This tree is a plain JavaScript object structure representing the desired UI state.\n\n    ```typescript\n    // React maintains a virtual representation of this DOM structure\n    <div className=\"app\">\n      <header>\n        <h1>Title</h1>\n      </header>\n      <main>\n        <ul>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </ul>\n      </main>\n    </div>\n    ```\n\n2.  **Diffing (Comparison)**: When an update occurs (e.g., state or props change), React doesn't directly update the real DOM. Instead, it creates another new virtual DOM tree (representing the new UI state) and then efficiently compares (diffs) this new virtual tree with the previous virtual tree.\n\n3.  **Reconciliation**: The diffing process identifies the minimal set of changes (updates, additions, deletions) required to make the real DOM reflect the new virtual DOM. This process is called reconciliation.\n\n4.  **Batching**: React batches multiple DOM updates together. Instead of applying each change individually to the real DOM, React collects all identified changes and applies them in a single, optimized batch operation. This minimizes direct manipulation of the expensive real DOM, leading to better performance.\n\n## Reconciliation Algorithm\nReact's reconciliation algorithm is optimized for speed, aiming for O(n) complexity where 'n' is the number of elements in the tree. It uses several heuristics (optimizations based on common scenarios) to achieve this:\n\n1.  **Different Element Types**: If the root elements of two compared trees have different types (e.g., `div` changes to `span`, or `ComponentA` changes to `ComponentB`), React tears down the old tree completely and builds a new one from scratch. This is because a change in element type implies a fundamental change in structure and behavior, making it more efficient to rebuild.\n\n2.  **Same Element Type**: If the root elements have the same type, React is able to keep the same underlying DOM node. It then recursively compares the attributes and children of these elements. Only the changed attributes are updated on the existing DOM node, and the reconciliation process continues for their children.\n\n3.  **Component Elements**: When a component updates, React first checks if the component instance is of the same type. If it is, React updates the component's props, calls its `render` method to get the new virtual DOM tree, and then applies the reconciliation algorithm recursively to compare the newly rendered tree with the previously rendered one.\n\n4.  **List Elements (Importance of `key` Prop)**: When dealing with lists of elements, React needs a way to identify which items have changed, been added, or been removed, even if their order changes. This is where the `key` prop becomes critical. A `key` is a special string attribute you need to include when creating lists of elements. React uses these keys to efficiently reconcile list items. Without stable, unique keys, React might re-render all items or perform inefficient updates when an item is added, removed, or reordered, potentially leading to performance issues or even incorrect UI state (e.g., issues with component state if React reuses components for different data).\n\n    *   **Bad Practice**: Using array `index` as `key` for dynamic lists.\n        ```typescript\n        // Without stable keys, React might re-render all items when one changes\n        // or behave unpredictably when items are added/removed/reordered.\n        // BAD PRACTICE for dynamic lists\n        {items.map((item, index) => <ListItem key={index} item={item} />)}\n        ```\n\n    *   **Good Practice**: Using a stable, unique ID from your data as `key`.\n        ```typescript\n        // With stable keys, React can efficiently identify which items changed,\n        // preserving component state and improving performance.\n        // GOOD PRACTICE: Use a stable unique ID\n        {items.map(item => <ListItem key={item.id} item={item} />)}\n        ```\n\n## Real DOM vs. Virtual DOM Comparison\n\n| Feature                       | Real DOM                                    | Virtual DOM                                      |\n| :---------------------------- | :------------------------------------------ | :----------------------------------------------- |\n| **Update Speed**              | Updates slowly, as direct manipulation is costly. | Updates faster due to in-memory representation.  |\n| **Direct HTML Update**        | Can directly update HTML elements.          | Cannot directly update HTML; it's a representation. |\n| **Element Update Mechanism**  | Creates a new DOM node if an element's structure or type changes significantly, or updates properties on existing nodes. | Updates the JSX (JavaScript representation) first, then diffs. |\n| **Manipulation Cost**         | DOM manipulation is very expensive due to browser layout, paint, and reflow operations. | DOM manipulation (in-memory) is very easy and cheap. |\n| **Memory Usage (Per Update)** | Can lead to high memory consumption and wastage due to frequent re-renders and re-creations of nodes. | Low memory wastage, as only a small, diffed patch is applied to the real DOM. |\n\nIn essence, the Virtual DOM acts as an intermediary layer that allows React to minimize direct interactions with the slow real DOM, leading to highly performant and responsive user interfaces.",
          "examples": [
            {
              "id": "example_virtual_dom_1",
              "title": "Virtual DOM Diffing Example",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  // When setCount is called:\n  // 1. React creates a new VDOM: <p>Count: 1</p>\n  // 2. Diffs it with old VDOM: <p>Count: 0</p>\n  // 3. Identifies only the text content within the <p> tag changed.\n  // 4. Updates ONLY that text content in the real DOM.\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n\n// Imagine the real DOM initially:\n// <div>\n//   <p>Count: 0</p>\n//   <button>Increment</button>\n// </div>",
              "explanation": "This example illustrates the Virtual DOM and reconciliation process. When the `Increment` button is clicked, `setCount` updates the component's state. React then creates a new Virtual DOM tree for the `Counter` component. It compares this new tree with the previous one. The diffing algorithm determines that only the text content within the `<p>` tag has changed. Instead of re-rendering the entire `div` or `p` element, React performs a precise update, only changing the `textContent` of the existing `<p>` DOM node. This granular update is significantly more efficient than direct DOM manipulation.",
              "language": "typescript"
            },
            {
              "id": "example_virtual_dom_2",
              "title": "Impact of Keys on List Reconciliation",
              "code": "import React, { useState } from 'react';\n\nfunction ItemList() {\n  const initialItems = [\n    { id: 'a', text: 'First' },\n    { id: 'b', text: 'Second' },\n    { id: 'c', text: 'Third' },\n  ];\n  const [items, setItems] = useState(initialItems);\n\n  const shuffleItems = () => {\n    setItems([...items].sort(() => Math.random() - 0.5));\n  };\n\n  const addItemAtBeginning = () => {\n    const newItemId = Math.random().toString(36).substring(7);\n    setItems([{ id: newItemId, text: 'New Item' }, ...items]);\n  };\n\n  return (\n    <div>\n      <button onClick={shuffleItems}>Shuffle Items</button>\n      <button onClick={addItemAtBeginning}>Add Item at Beginning</button>\n      <ul>\n        {items.map(item => (\n          <li key={item.id}>{item.text}</li> // Good: Using stable, unique ID as key\n          // <li key={index}>{item.text}</li> // Bad: Using index as key for dynamic list\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the critical role of `key` props in list reconciliation. The `ItemList` component renders a dynamic list. When items are shuffled or a new item is added at the beginning, React uses the `key` prop to identify specific list items. By using `item.id` (a stable, unique identifier) as the key, React can efficiently reorder existing DOM nodes or insert new ones at the correct positions. If `index` were used as the key for a dynamic list (as shown in the commented line), React might inefficiently update the content of existing nodes or remount components unnecessarily, leading to performance issues or loss of internal component state (e.g., input values in a form within a list item). Stable keys ensure that React can correctly map data items to their corresponding component instances and DOM elements.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_virtual_dom_1",
            "question_virtual_dom_2",
            "question_virtual_dom_3",
            "question_virtual_dom_4",
            "question_virtual_dom_5",
            "question_virtual_dom_6",
            "question_virtual_dom_7",
            "question_virtual_dom_8",
            "question_virtual_dom_9",
            "question_virtual_dom_10"
          ],
          "relatedTasks": [
            "task_virtual_dom_dynamic_list"
          ],
          "tags": [
            "React",
            "Virtual DOM",
            "DOM",
            "Reconciliation",
            "Performance",
            "Keys",
            "JavaScript",
            "Frontend"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_basics",
            "dom_manipulation",
            "react_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_performance_optimization",
            "complex_ui_development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_jsx_fragments_1",
          "topic": "JSX Fragments",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of JSX Fragments?",
          "answer": "To group multiple elements without adding an extra DOM node to the parent.",
          "options": [],
          "analysisPoints": [
            "Focus on 'grouping' and 'no extra DOM node'."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "DOM structure"
          ],
          "evaluationCriteria": [
            "Ability to recall basic definition."
          ],
          "example": "",
          "tags": [
            "JSX",
            "Fragments",
            "DOM"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_fragments_2",
          "topic": "JSX Fragments",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```typescript\nfunction ItemRow({ item }) {\n  return (\n    <>\n      <td>{item.id}</td>\n      <td>{item.name}</td>\n    </>\n  );\n}\n\n// If used inside a <table> like this:\n// <table>\n//   <tbody>\n//     <ItemRow item={{ id: 1, name: 'Apple' }} />\n//     <ItemRow item={{ id: 2, name: 'Banana' }} />\n//   </tbody>\n// </table>\n```\n\nWhich of the following statements about the rendered DOM output is TRUE?",
          "answer": "The `<td>` elements will be direct children of the `<tbody>`.",
          "options": [
            "The `<td>` elements will be wrapped inside an empty `div`.",
            "The `<td>` elements will be direct children of the `<tbody>`.",
            "The `ItemRow` component will throw an error because it returns multiple elements.",
            "The `<td>` elements will be wrapped inside a `React.Fragment` DOM node."
          ],
          "analysisPoints": [
            "Tests understanding of Fragment's core behavior: no extra DOM node.",
            "Reinforces that Fragments allow returning multiple elements without a single parent.",
            "Highlights the correct DOM structure for semantic HTML like tables."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "DOM structure",
            "Semantic HTML"
          ],
          "evaluationCriteria": [
            "Understanding of Fragment's effect on DOM.",
            "Knowledge of valid HTML table structure."
          ],
          "example": "JSX Fragments (`<></>` or `<React.Fragment>`) do not render any actual DOM element. They are a way to group elements in JSX without introducing an extra wrapper. Therefore, the `<td>` elements returned by `ItemRow` will effectively become direct children of the `<tbody>` element in the final HTML, which is crucial for maintaining valid table semantics (`<tbody>` should directly contain `<tr>` or `<td>`s for a simplified scenario like this, though typically `<tr>` is the direct child of `<tbody>` with `<td>`s inside `<tr>`). Option A and D are incorrect because Fragments add no DOM node. Option C is incorrect as Fragments specifically solve the problem of returning multiple elements.",
          "tags": [
            "JSX",
            "Fragments",
            "DOM",
            "MCQ"
          ],
          "prerequisites": [
            "jsx_syntax",
            "html_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jsx_fragments_3",
          "topic": "JSX Fragments",
          "level": "medium",
          "type": "open",
          "question": "Explain at least three benefits of using JSX Fragments over wrapping multiple JSX elements in a `div` element.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Performance: Fragments avoid creating an extra DOM node, leading to slightly faster rendering and less memory usage, especially in deep component trees.",
            "CSS Layout Integrity: Prevents breaking specific CSS layouts (like Flexbox or CSS Grid) that rely on direct parent-child relationships, as a `div` wrapper would introduce an unintended intermediate box.",
            "DOM Inspector Clarity: Keeps the browser's DOM inspector cleaner and less cluttered by avoiding unnecessary wrapper elements, making debugging easier.",
            "Semantic HTML: Allows components to return valid semantic HTML structures (e.g., `<td>` elements directly inside `<tr>`, or `<li>` elements directly inside `<ul>`) without introducing non-semantic wrappers that would invalidate the HTML or affect accessibility/SEO."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "Performance",
            "CSS Layout",
            "DOM Structure",
            "Semantic HTML",
            "Accessibility"
          ],
          "evaluationCriteria": [
            "Ability to articulate the core advantages.",
            "Detailing the 'why' behind each benefit (e.g., 'how' performance is affected).",
            "Providing clear examples or scenarios where each benefit applies."
          ],
          "example": "",
          "tags": [
            "JSX",
            "Fragments",
            "Performance",
            "CSS",
            "DOM",
            "Semantic HTML",
            "Open-ended"
          ],
          "prerequisites": [
            "jsx_syntax",
            "html_basics",
            "css_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jsx_fragments_4",
          "topic": "JSX Fragments",
          "level": "easy",
          "type": "flashcard",
          "question": "When is it mandatory to use the long syntax `<React.Fragment>` instead of the shorthand `<></>` for Fragments?",
          "answer": "When you need to pass a `key` prop to the Fragment, typically when rendering a list of fragments.",
          "options": [],
          "analysisPoints": [
            "Focus on the `key` prop requirement."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "key prop",
            "List rendering"
          ],
          "evaluationCriteria": [
            "Recall of specific syntax constraint."
          ],
          "example": "",
          "tags": [
            "JSX",
            "Fragments",
            "Key"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_fragments_5",
          "topic": "JSX Fragments",
          "level": "medium",
          "type": "mcq",
          "question": "You are building a React component that needs to render a list of table rows (`<tr>` elements) directly inside a `<tbody>`. Which of the following is the most appropriate way to achieve this using Fragments while ensuring proper list reconciliation if items can be reordered?",
          "answer": "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <React.Fragment>\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </React.Fragment>\n  );\n}\n```",
          "options": [
            "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <div>\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </div>\n  );\n}\n```",
            "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <>\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </>\n  );\n}\n```",
            "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <React.Fragment key=\"table-rows\">\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </React.Fragment>\n  );\n}\n```",
            "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <React.Fragment>\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </React.Fragment>\n  );\n}\n```"
          ],
          "analysisPoints": [
            "Option A: Incorrect, introduces an invalid `div` inside `<tbody>`.",
            "Option B: Incorrect, the outer `<></>` shorthand cannot accept a `key`.",
            "Option C: Incorrect, passing a `key` to the outer `React.Fragment` is not necessary or common here, as the `key` is applied to individual `<tr>` elements within the map. The outer fragment doesn't need a key unless it's part of a list of fragments itself.",
            "Option D: Correct. The outer `React.Fragment` (which could also be `<>`) correctly groups the `<tr>` elements without adding an extra DOM node. The `key={item.id}` is correctly applied to each `<tr>` within the `map` function, which is crucial for efficient list reconciliation.",
            "This question tests both Fragment usage and the critical role of `key` props in lists."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "Semantic HTML",
            "List Rendering",
            "Key Prop"
          ],
          "evaluationCriteria": [
            "Correct application of Fragments for semantic HTML.",
            "Understanding where and how to use `key` props.",
            "Distinguishing between long and short Fragment syntax implications."
          ],
          "example": "The goal is to render `<tr>` elements directly inside a `<tbody>`. Using a `div` (Option A) would create invalid HTML. The `<></>` shorthand (Option B) is fine if you don't need a key for the Fragment itself, but the correct application of `key` is on the `<tr>` elements. Option C attempts to put a key on the outer `React.Fragment`, which is not typically needed here as the `<tr>` elements are the dynamic ones. Option D correctly uses `React.Fragment` (or `<>`) to wrap the mapped `<tr>` elements, and critically, places the `key` prop on each individual `<tr>` element, which is where React needs it for efficient list reconciliation.",
          "tags": [
            "JSX",
            "Fragments",
            "HTML",
            "List",
            "Key",
            "MCQ"
          ],
          "prerequisites": [
            "react_components",
            "jsx_syntax",
            "html_tables"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_jsx_fragments_6",
          "topic": "JSX Fragments",
          "level": "hard",
          "type": "code",
          "question": "Refactor the `UserProfile` component below to use JSX Fragments efficiently. The component needs to render a user's name, email, and a list of hobbies. The final output should not have any unnecessary wrapping `div`s around the name and email, and the hobbies list should be a direct sibling of the name/email block.\n\n**Current Code (Inefficient/Suboptimal):**\n```typescript\nimport React from 'react';\n\ninterface UserData {\n  name: string;\n  email: string;\n  hobbies: string[];\n}\n\nfunction UserProfile({ user }: { user: UserData }) {\n  return (\n    <div>\n      <div>\n        <h2>{user.name}</h2>\n        <p>Email: {user.email}</p>\n      </div>\n      <h3>Hobbies:</h3>\n      <ul>\n        {user.hobbies.map((hobby, index) => (\n          <li key={index}>{hobby}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n**Requirements:**\n1.  Remove the outer `div` wrapping the entire component's content.\n2.  Remove the inner `div` wrapping `<h2>` and `<p>`.\n3.  Ensure the `<h2>` and `<p>` are direct siblings.\n4.  Ensure the `<h3>` and `<ul>` are direct siblings of the `<h2>` and `<p>`.\n5.  The `hobbies` list should still use appropriate keys for list items.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Uses `<>` for the main component return to remove the outermost `div`.",
            "Uses `<>` or `<React.Fragment>` for grouping `<h2>` and `<p>` to remove the inner `div`.",
            "Correctly places `key={index}` on `<li>` elements, acknowledging it's acceptable for static lists but better practice to use unique IDs if hobbies can be reordered/modified dynamically."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "Refactoring",
            "DOM Optimization",
            "Semantic HTML"
          ],
          "evaluationCriteria": [
            "Correct application of Fragments to eliminate unnecessary DOM nodes.",
            "Maintenance of correct element hierarchy and sibling relationships.",
            "Appropriate use of `key` prop for list rendering."
          ],
          "example": "```typescript\nimport React from 'react';\n\ninterface UserData {\n  name: string;\n  email: string;\n  hobbies: string[];\n}\n\nfunction UserProfile({ user }: { user: UserData }) {\n  return (\n    <>\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n      <h3>Hobbies:</h3>\n      <ul>\n        {user.hobbies.map((hobby, index) => (\n          <li key={hobby}>{hobby}</li> // Assuming hobby names are unique and stable for keys\n        ))}\n      </ul>\n    </>\n  );\n}\n```",
          "tags": [
            "JSX",
            "Fragments",
            "Code Challenge",
            "Refactoring",
            "Performance"
          ],
          "prerequisites": [
            "jsx_syntax",
            "react_components"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_1",
          "topic": "Virtual DOM and Reconciliation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the Virtual DOM?",
          "answer": "A lightweight JavaScript object representation of the actual browser DOM.",
          "options": [],
          "analysisPoints": [
            "Focus on 'JavaScript object' and 'representation of DOM'."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "DOM"
          ],
          "evaluationCriteria": [
            "Basic definition recall."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "React",
            "DOM"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_virtual_dom_2",
          "topic": "Virtual DOM and Reconciliation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following steps is NOT part of React's Virtual DOM process when state or props change?",
          "answer": "Directly updating the entire Real DOM with the new UI tree.",
          "options": [
            "Creating a new Virtual DOM tree based on the updated state/props.",
            "Diffing the new Virtual DOM tree with the previous one.",
            "Calculating the minimal set of changes needed for the Real DOM.",
            "Directly updating the entire Real DOM with the new UI tree."
          ],
          "analysisPoints": [
            "Option A, B, C are correct steps in the VDOM process.",
            "Option D is incorrect because React avoids direct full DOM updates; it only updates the minimal changes."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Reconciliation",
            "Diffing",
            "Batching"
          ],
          "evaluationCriteria": [
            "Understanding the steps involved in React's rendering process.",
            "Distinguishing between Virtual DOM operations and Real DOM updates."
          ],
          "example": "React's Virtual DOM process involves creating a new VDOM, diffing it against the old one, and then applying a minimal patch to the Real DOM. It never directly updates the entire Real DOM tree, as that would be inefficient. The efficiency comes from calculating precisely what changed and only modifying those specific parts of the actual DOM.",
          "tags": [
            "Virtual DOM",
            "Reconciliation",
            "React",
            "Performance",
            "MCQ"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_3",
          "topic": "Virtual DOM and Reconciliation",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of 'Reconciliation' in React and how it relates to the Virtual DOM and performance.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Define Reconciliation: The process by which React updates the actual DOM to match the desired state represented by the Virtual DOM.",
            "Role of Virtual DOM: Two VDOM trees are compared (old vs. new).",
            "Diffing Algorithm: Explain how React identifies differences (element types, attributes, children, keys for lists).",
            "Minimal Changes (Patching): React calculates the most efficient way (minimal operations) to update the real DOM.",
            "Performance Impact: By minimizing direct manipulation of the expensive real DOM, reconciliation significantly boosts performance, preventing unnecessary re-renders and layout thrashing."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Virtual DOM",
            "Diffing Algorithm",
            "Performance",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Clear definition of reconciliation.",
            "Accurate description of the diffing process.",
            "Connection between VDOM, reconciliation, and performance benefits.",
            "Understanding of 'minimal changes' concept."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "Reconciliation",
            "Performance",
            "Open-ended",
            "React"
          ],
          "prerequisites": [
            "virtual_dom_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_4",
          "topic": "Virtual DOM and Reconciliation",
          "level": "hard",
          "type": "code",
          "question": "You have a list of user comments that can be reordered by a user. Explain why using the array `index` as a `key` for list items in such a scenario is considered a bad practice and demonstrate with a simple code example how this could lead to issues. Then, provide the corrected code using a proper key.\n\n**Initial (Problematic) Code Snippet:**\n```typescript\nimport React, { useState } from 'react';\n\ninterface Comment {\n  id: string;\n  text: string;\n}\n\nfunction CommentList() {\n  const [comments, setComments] = useState<Comment[]>([\n    { id: '1', text: 'First comment' },\n    { id: '2', text: 'Second comment' },\n    { id: '3', text: 'Third comment' },\n  ]);\n\n  const reorderComments = () => {\n    // Simulate reordering by reversing the array\n    setComments([...comments].reverse());\n  };\n\n  return (\n    <div>\n      <button onClick={reorderComments}>Reorder Comments</button>\n      <ul>\n        {comments.map((comment, index) => (\n          <li key={index}> {/* PROBLEM HERE */}\n            <input type=\"text\" value={comment.text} readOnly />\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n**Tasks:**\n1.  Explain the problem with `key={index}` in this dynamic scenario.\n2.  Modify the `CommentList` component to fix the `key` issue.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explanation of `key={index}` problem: When items are reordered, added, or removed, the indices shift. React uses keys to identify unique components/elements. If keys are indices, React might think the component at index 0 is merely updated (when it's actually a different data item that moved to index 0) instead of recognizing a reorder. This can lead to incorrect UI updates, performance issues, or loss of internal component state (e.g., an input field retaining its value even if the associated data item changes).",
            "Corrected code should use `comment.id` as the key, assuming `id` is a stable and unique identifier for each comment.",
            "The example demonstrates why `input` field is important to show the 'loss of state' issue."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Key Prop",
            "List Rendering",
            "Performance",
            "State Preservation"
          ],
          "evaluationCriteria": [
            "Clear articulation of the `key={index}` pitfall.",
            "Correctly applying unique, stable keys.",
            "Demonstrating the problem with a relevant example.",
            "Understanding React's reconciliation strategy for lists."
          ],
          "example": "### Explanation of the Problem with `key={index}`:\nWhen `key={index}` is used for dynamic lists that can change order (like reordering comments), React's reconciliation algorithm becomes inefficient and problematic. React uses keys to identify list items across renders. If the order of items changes, but the keys are just their array indices, React doesn't see that the *data item* has moved; it only sees that the *index* has changed and tries to update the existing DOM element at that index with new data. This can lead to:\n\n1.  **Incorrect UI updates**: An input field might retain its old value even though the underlying data associated with that `<li>` has changed, because React reuses the `<li>` element but updates its `value` prop incorrectly or doesn't re-mount a nested component.\n2.  **Performance issues**: React might perform more DOM operations than necessary (e.g., updating content instead of simply reordering DOM nodes).\n3.  **Loss of component state**: If a list item contains stateful components (like an input with its own internal state), that state might be incorrectly transferred or lost when items are reordered because React believes the components are the same, just with updated props.\n\nIn the provided `CommentList` example, if you were to type into an input field (e.g., in the 'First comment' input) and then click 'Reorder Comments', the text you typed would stay in the input field that is now displaying 'Third comment', because React sees the input at `index=0` as the same DOM element, just with different data.\n\n### Corrected Code:\n```typescript\nimport React, { useState } from 'react';\n\ninterface Comment {\n  id: string;\n  text: string;\n}\n\nfunction CommentList() {\n  const [comments, setComments] = useState<Comment[]>([\n    { id: '1', text: 'First comment' },\n    { id: '2', text: 'Second comment' },\n    { id: '3', text: 'Third comment' },\n  ]);\n\n  const reorderComments = () => {\n    // Simulate reordering by reversing the array\n    setComments([...comments].reverse());\n  };\n\n  // To demonstrate the actual input value persistence issue, let's make the input editable.\n  const handleCommentChange = (id: string, newText: string) => {\n    setComments(comments.map(comment => \n      comment.id === id ? { ...comment, text: newText } : comment\n    ));\n  };\n\n  return (\n    <div>\n      <button onClick={reorderComments}>Reorder Comments</button>\n      <ul>\n        {comments.map((comment) => (\n          <li key={comment.id}> {/* FIX: Using comment.id as key */}\n            <input \n              type=\"text\" \n              value={comment.text} \n              onChange={(e) => handleCommentChange(comment.id, e.target.value)}\n            />\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n**Explanation of the Fix:**\nBy changing `key={index}` to `key={comment.id}`, we provide React with a stable and unique identifier for each comment item. Now, when `reorderComments` is called, React can precisely track each `Comment` object based on its `id`. If 'First comment' (id '1') moves from index 0 to index 2, React knows it's the same item '1' that has moved, rather than thinking the item at index 0 has simply changed its content. This allows React to correctly reorder the actual DOM elements and preserve any internal state (like user input in the `input` field) associated with that specific comment item.",
          "tags": [
            "React",
            "Virtual DOM",
            "Reconciliation",
            "Keys",
            "List Rendering",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_state_props",
            "list_rendering"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_virtual_dom_5",
          "topic": "Virtual DOM and Reconciliation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the Big O complexity of React's reconciliation algorithm?",
          "answer": "O(n), where 'n' is the number of elements in the tree.",
          "options": [],
          "analysisPoints": [
            "Recall of algorithm efficiency."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Algorithm Complexity",
            "Big O"
          ],
          "evaluationCriteria": [
            "Ability to recall specific efficiency metric."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "Reconciliation",
            "Performance"
          ],
          "prerequisites": [
            "data_structures_algorithms_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_6",
          "topic": "Virtual DOM and Reconciliation",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast Real DOM and Virtual DOM based on their update speed, manipulation cost, and memory usage.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Update Speed: Real DOM is slow due to browser reflow/repaint; Virtual DOM is fast (in-memory comparison).",
            "Manipulation Cost: Real DOM manipulation is expensive; Virtual DOM manipulation is cheap.",
            "Memory Usage: Real DOM can lead to wastage with frequent full updates; Virtual DOM is efficient as it only patches minimal changes.",
            "Direct HTML Update: Real DOM directly updates HTML; Virtual DOM is a JS representation, doesn't directly update HTML.",
            "Element Update Mechanism: Real DOM often re-creates if elements change; Virtual DOM updates JSX, then diffs."
          ],
          "keyConcepts": [
            "Real DOM",
            "Virtual DOM",
            "Performance",
            "Memory",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison across multiple dimensions.",
            "Accuracy of statements regarding each DOM type.",
            "Clear articulation of the advantages of Virtual DOM."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "Real DOM",
            "Comparison",
            "Performance",
            "Open-ended"
          ],
          "prerequisites": [
            "virtual_dom_basics",
            "dom_manipulation"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_7",
          "topic": "Virtual DOM and Reconciliation",
          "level": "hard",
          "type": "mcq",
          "question": "A React component renders a `MyCustomComponent` that has internal state. If `MyCustomComponent` is replaced by a `div` element on a subsequent render (i.e., its parent changes its type from `<MyCustomComponent />` to `<div>`), what will React's reconciliation algorithm do?",
          "answer": "Tear down `MyCustomComponent` and its entire subtree, then build a new `div` and its subtree from scratch, losing any internal state of `MyCustomComponent`.",
          "options": [
            "Keep the `MyCustomComponent` instance, update its props, and then convert it to a `div`.",
            "Tear down `MyCustomComponent` and its entire subtree, then build a new `div` and its subtree from scratch, losing any internal state of `MyCustomComponent`.",
            "Perform a deep comparison between `MyCustomComponent`'s internal structure and the `div`'s structure to apply minimal changes.",
            "Only update the DOM node type from a custom component to a `div`, preserving the child elements if they are identical."
          ],
          "analysisPoints": [
            "Tests understanding of the 'Different Element Types' heuristic in reconciliation.",
            "Emphasizes that a type change at the root of a subtree leads to a complete rebuild, not just an update.",
            "Highlights the consequence of losing internal state when a component is unmounted and remounted."
          ],
          "keyConcepts": [
            "Reconciliation Algorithm",
            "Different Element Types",
            "Component Lifecycle",
            "State Preservation"
          ],
          "evaluationCriteria": [
            "Accurate recall of reconciliation heuristics.",
            "Understanding of component unmounting/remounting implications.",
            "Ability to apply reconciliation rules to specific scenarios."
          ],
          "example": "React's reconciliation algorithm has a heuristic: if elements at the same position have different types (e.g., a custom component changes to a standard HTML element like `div`), React will tear down the old component and its children and build the new element and its children from scratch. This is because a change in type implies a complete structural change, making it more efficient to rebuild. Consequently, any internal state of `MyCustomComponent` would be lost as it's unmounted.",
          "tags": [
            "React",
            "Reconciliation",
            "Virtual DOM",
            "Component Lifecycle",
            "MCQ"
          ],
          "prerequisites": [
            "react_component_basics",
            "virtual_dom_reconciliation"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_virtual_dom_8",
          "topic": "Virtual DOM and Reconciliation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is 'Batching' in the context of React's DOM updates?",
          "answer": "React collects multiple DOM updates identified during reconciliation and applies them together in a single, optimized operation to the real DOM.",
          "options": [],
          "analysisPoints": [
            "Focus on 'collects multiple updates' and 'single operation'."
          ],
          "keyConcepts": [
            "Batching",
            "DOM Updates",
            "Performance"
          ],
          "evaluationCriteria": [
            "Recall of batching mechanism."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "Performance",
            "React"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_9",
          "topic": "Virtual DOM and Reconciliation",
          "level": "medium",
          "type": "open",
          "question": "Beyond the `key` prop, describe another specific heuristic React's reconciliation algorithm uses to optimize updates when elements have the 'Same Element Type'.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Identify the 'Same Element Type' heuristic.",
            "Explain that React keeps the same DOM node.",
            "Describe that React only updates changed attributes.",
            "Mention recursive comparison for children."
          ],
          "keyConcepts": [
            "Reconciliation Algorithm",
            "Same Element Type",
            "Attribute Updates",
            "Recursive Diffing"
          ],
          "evaluationCriteria": [
            "Accuracy in describing the specific heuristic.",
            "Detailing the actions React takes in this scenario.",
            "Understanding of the optimization benefit."
          ],
          "example": "When React encounters two elements of the 'Same Element Type' during reconciliation (e.g., both are `div`s), it assumes that the underlying DOM node can be reused. Instead of destroying and recreating the node, React preserves the existing DOM node. It then proceeds to compare the attributes of the old and new elements. Only the attributes that have actually changed (e.g., a `className`, `style` property, or event handler) are updated on the existing real DOM node. After updating attributes, React recursively applies the reconciliation algorithm to the children of these elements, ensuring that only necessary changes are made deep within the tree.",
          "tags": [
            "Virtual DOM",
            "Reconciliation",
            "Algorithm",
            "Performance",
            "Open-ended"
          ],
          "prerequisites": [
            "virtual_dom_reconciliation"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_10",
          "topic": "Virtual DOM and Reconciliation",
          "level": "hard",
          "type": "code",
          "question": "Imagine you have a `Tabs` component that renders different tab content based on a selected tab ID. Initially, Tab A (`<TabA />`) is rendered. When the user switches to Tab B (`<TabB />`), the component's `render` method changes from returning `<TabA />` to `<TabB />`.\n\nDescribe the exact steps React's reconciliation algorithm will take regarding `TabA` and `TabB` components, assuming both `TabA` and `TabB` are custom React components (not native HTML elements) and they each manage their own internal state (e.g., form inputs, toggles).\n\nProvide a simplified code structure to illustrate the scenario.\n\n```typescript\nimport React, { useState } from 'react';\n\ninterface TabContentProps {\n  // Assume some props here\n}\n\nconst TabA: React.FC<TabContentProps> = () => {\n  const [value, setValue] = useState('');\n  console.log('Rendering TabA');\n  return (\n    <div>\n      <h2>Tab A Content</h2>\n      <input type=\"text\" value={value} onChange={(e) => setValue(e.target.value)} placeholder=\"Tab A input\" />\n    </div>\n  );\n};\n\nconst TabB: React.FC<TabContentProps> = () => {\n  const [count, setCount] = useState(0);\n  console.log('Rendering TabB');\n  return (\n    <div>\n      <h2>Tab B Content</h2>\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n    </div>\n  );\n};\n\nfunction Tabs() {\n  const [activeTab, setActiveTab] = useState<'A' | 'B'>('A');\n\n  return (\n    <div>\n      <button onClick={() => setActiveTab('A')}>Show Tab A</button>\n      <button onClick={() => setActiveTab('B')}>Show Tab B</button>\n      <div style={{ border: '1px solid black', padding: '10px', marginTop: '10px' }}>\n        {activeTab === 'A' ? <TabA /> : <TabB />}\n      </div>\n    </div>\n  );\n}\n```",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Initial Render: `Tabs` renders `TabA`.",
            "State Change: `setActiveTab('B')` causes `Tabs` to re-render.",
            "Reconciliation Step 1 (Root Element Type Check): React compares `<TabA />` (from previous render) with `<TabB />` (from current render). Since `TabA` and `TabB` are different component types, this triggers the 'Different Element Types' heuristic.",
            "Reconciliation Step 2 (Teardown): React will unmount `TabA` and its entire subtree. This means `TabA`'s internal state (`value`) will be lost, and its `console.log('Rendering TabA')` will not be called again unless it is remounted.",
            "Reconciliation Step 3 (Build New Tree): React will then mount `TabB` and construct its entire subtree from scratch. `TabB` will initialize its own state (`count` to 0), and `console.log('Rendering TabB')` will be called.",
            "Consequence: Any user input or state within `TabA` is lost when switching to `TabB`, because `TabA` is completely replaced, not merely updated.",
            "This scenario is key to understanding why component unmounting/remounting occurs."
          ],
          "keyConcepts": [
            "Reconciliation Algorithm",
            "Different Element Types",
            "Component Lifecycle",
            "State Loss",
            "Mounting/Unmounting"
          ],
          "evaluationCriteria": [
            "Accurate description of the 'Different Element Types' heuristic.",
            "Clear explanation of unmounting and remounting consequences.",
            "Understanding of how internal component state is affected.",
            "Ability to trace the reconciliation steps for complex component changes."
          ],
          "example": "When the user switches from 'Tab A' to 'Tab B' by clicking the 'Show Tab B' button:\n\n1.  **`Tabs` component re-renders**: The `setActiveTab('B')` call triggers a re-render of the `Tabs` component.\n2.  **Virtual DOM comparison**: During the reconciliation process, React compares the previous virtual DOM tree for the content area (`<TabA />`) with the new virtual DOM tree (`<TabB />`).\n3.  **Different Element Types heuristic**: React identifies that the root element in that position has changed its type from `TabA` (a custom component type) to `TabB` (another custom component type). According to its reconciliation algorithm, if the root elements have different types, React considers them fundamentally different and opts for a complete teardown and rebuild.\n4.  **`TabA` unmounts**: React will unmount `TabA` and its entire subtree. This means `TabA`'s `useState` hook's value (`value`) will be completely reset and lost. Its `console.log('Rendering TabA')` will cease to be called unless `TabA` is mounted again.\n5.  **`TabB` mounts**: React will then mount `TabB` and build its entire subtree from scratch. `TabB`'s `useState` hook will be initialized, setting `count` to `0`, and `console.log('Rendering TabB')` will be called. Any state within `TabB` will start fresh.\n\n**Consequence**: If you type something into `TabA`'s input and then switch to `TabB` and back to `TabA`, the typed content in `TabA`'s input will be gone because `TabA` was unmounted and then re-mounted from scratch, resetting its state. This behavior is expected when component types change at the same position in the tree.",
          "tags": [
            "React",
            "Virtual DOM",
            "Reconciliation",
            "Component Lifecycle",
            "State Management",
            "Hard",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_state_props",
            "component_lifecycle"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_jsx_fragments_table_row",
          "title": "Build a Semantic Table Component with JSX Fragments",
          "description": "\nCreate a React component `UserTable` that renders a `<table>` containing user data. Inside the `<tbody>`, you should have a `TableRow` component responsible for rendering a single row's `<td>` elements. Crucially, the `TableRow` component itself should not add an extra wrapper `div` or similar element around its `<td>` children, to maintain semantic HTML table structure.\n\n**Requirements:**\n1.  `UserTable` component that accepts an array of user objects.\n2.  `TableRow` component that accepts a single user object.\n3.  `TableRow` must return multiple `<td>` elements using a JSX Fragment to avoid invalid HTML.\n4.  Ensure `key` props are correctly used for list items within `UserTable` to enable efficient reconciliation.\n5.  Include a header row (`<thead>`) in `UserTable` for columns like 'ID', 'Name', 'Email'.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface UserTableProps {\n  users: User[];\n}\n\n// TODO: Implement TableRow component using Fragments\n// interface TableRowProps {\n//   user: User;\n// }\n// const TableRow: React.FC<TableRowProps> = ({ user }) => {\n//   return (\n//     // Your fragment implementation here\n//   );\n// };\n\nconst UserTable: React.FC<UserTableProps> = ({ users }) => {\n  return (\n    <table border={1} style={{ width: '100%', borderCollapse: 'collapse' }}>\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>Name</th>\n          <th>Email</th>\n        </tr>\n      </thead>\n      <tbody>\n        {/* TODO: Render TableRow components here */}\n      </tbody>\n    </table>\n  );\n};\n\nexport default UserTable;\n",
          "solutionCode": "import React from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface UserTableProps {\n  users: User[];\n}\n\ninterface TableRowProps {\n  user: User;\n}\n\nconst TableRow: React.FC<TableRowProps> = ({ user }) => {\n  return (\n    <> {/* Using shorthand fragment to group <td> elements */}\n      <td>{user.id}</td>\n      <td>{user.name}</td>\n      <td>{user.email}</td>\n    </>\n  );\n};\n\nconst UserTable: React.FC<UserTableProps> = ({ users }) => {\n  return (\n    <table border={1} style={{ width: '100%', borderCollapse: 'collapse' }}>\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>Name</th>\n          <th>Email</th>\n        </tr>\n      </thead>\n      <tbody>\n        {users.map(user => (\n          <tr key={user.id}> {/* Key prop on the <tr> element */}\n            <TableRow user={user} />\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n};\n\nexport default UserTable;\n",
          "testCases": [
            "Render `UserTable` with an empty `users` array: Should render an empty table body with only headers.",
            "Render `UserTable` with a few user objects: Should correctly display rows with ID, Name, and Email.",
            "Inspect the DOM: Verify that `<td>` elements are direct children of `<tr>`, and `<tr>` elements are direct children of `<tbody>`, with no intermediate `div` wrappers from `TableRow` component."
          ],
          "hints": [
            "Remember that `<tbody>` expects `<tr>` as direct children, and `<tr>` expects `<td>` or `<th>` as direct children.",
            "The shorthand fragment `<></>` is typically sufficient unless you need to pass a `key` to the fragment itself (which is rare for a component directly returning `<td>`s)."
          ],
          "tags": [
            "React",
            "JSX",
            "Fragments",
            "Semantic HTML",
            "Tables",
            "DOM"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_components",
            "jsx_syntax",
            "html_tables"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "jsx_fragments",
            "list_rendering",
            "semantic_html"
          ]
        },
        {
          "id": "task_virtual_dom_dynamic_list",
          "title": "Implement a Dynamic Todo List with Correct Keys",
          "description": "\nCreate a React component `DynamicTodoList` that allows users to add, remove, and reorder todo items. This task specifically focuses on demonstrating the importance of stable `key` props for efficient Virtual DOM reconciliation.\n\n**Requirements:**\n1.  A stateful component `DynamicTodoList` that manages an array of todo items. Each todo item should have a unique `id` (e.g., using `Date.now()` or a UUID library for new items) and a `text` property.\n2.  An input field and a button to add new todo items to the beginning of the list.\n3.  A button to remove the first todo item from the list.\n4.  A button to reorder (e.g., shuffle or reverse) the existing todo items.\n5.  Each todo item displayed in the list (`<li>` or a separate `TodoItem` component) must contain an editable input field to demonstrate potential state loss if `key`s are misused.\n6.  **Crucially**: Ensure `key` props are correctly implemented using the `id` of the todo item to prevent reconciliation issues when items are added, removed, or reordered.\n7.  Add `console.log` statements inside the `TodoItem` component (if you create one) to track its mounting/unmounting behavior when keys are correctly used vs. when they might be incorrectly used (for self-observation).\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\ninterface TodoItem {\n  id: string;\n  text: string;\n}\n\nconst TodoItemComponent: React.FC<{ item: TodoItem }> = ({ item }) => {\n  const [currentText, setCurrentText] = useState(item.text);\n  console.log(`TodoItemComponent ${item.id} rendered`);\n  // Using effect to show mount/unmount\n  React.useEffect(() => {\n    console.log(`TodoItemComponent ${item.id} mounted`);\n    return () => {\n      console.log(`TodoItemComponent ${item.id} unmounted`);\n    };\n  }, []);\n\n  return (\n    <li>\n      <input\n        type=\"text\"\n        value={currentText}\n        onChange={(e) => setCurrentText(e.target.value)}\n      />\n    </li>\n  );\n};\n\nconst DynamicTodoList: React.FC = () => {\n  const [todos, setTodos] = useState<TodoItem[]>([\n    { id: 'a', text: 'Learn React' },\n    { id: 'b', text: 'Master Frontend' },\n    { id: 'c', text: 'Build Awesome Apps' },\n  ]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const addTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newId = String(Date.now()); // Simple unique ID\n    setTodos([{ id: newId, text: newTodoText }, ...todos]);\n    setNewTodoText('');\n  };\n\n  const removeFirstTodo = () => {\n    setTodos(todos.slice(1));\n  };\n\n  const shuffleTodos = () => {\n    setTodos([...todos].sort(() => Math.random() - 0.5));\n  };\n\n  return (\n    <div>\n      <h2>Dynamic Todo List</h2>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add new todo\"\n        />\n        <button onClick={addTodo}>Add Todo</button>\n      </div>\n      <div>\n        <button onClick={removeFirstTodo}>Remove First</button>\n        <button onClick={shuffleTodos}>Shuffle Todos</button>\n      </div>\n      <ul>\n        {/* TODO: Map over todos and render TodoItemComponent with correct key */}\n      </ul>\n    </div>\n  );\n};\n\nexport default DynamicTodoList;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface TodoItem {\n  id: string;\n  text: string;\n}\n\nconst TodoItemComponent: React.FC<{ item: TodoItem }> = ({ item }) => {\n  const [currentText, setCurrentText] = useState(item.text);\n  console.log(`TodoItemComponent ${item.id} rendered`);\n  // Using effect to show mount/unmount\n  React.useEffect(() => {\n    console.log(`TodoItemComponent ${item.id} mounted`);\n    return () => {\n      console.log(`TodoItemComponent ${item.id} unmounted`);\n    };\n  }, []);\n\n  return (\n    <li>\n      <input\n        type=\"text\"\n        value={currentText}\n        onChange={(e) => setCurrentText(e.target.value)}\n      />\n    </li>\n  );\n};\n\nconst DynamicTodoList: React.FC = () => {\n  const [todos, setTodos] = useState<TodoItem[]>([\n    { id: 'a', text: 'Learn React' },\n    { id: 'b', text: 'Master Frontend' },\n    { id: 'c', text: 'Build Awesome Apps' },\n  ]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const addTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newId = String(Date.now()); // Simple unique ID\n    setTodos([{ id: newId, text: newTodoText }, ...todos]);\n    setNewTodoText('');\n  };\n\n  const removeFirstTodo = () => {\n    setTodos(todos.slice(1));\n  };\n\n  const shuffleTodos = () => {\n    setTodos([...todos].sort(() => Math.random() - 0.5));\n  };\n\n  return (\n    <div>\n      <h2>Dynamic Todo List</h2>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add new todo\"\n        />\n        <button onClick={addTodo}>Add Todo</button>\n      </div>\n      <div>\n        <button onClick={removeFirstTodo}>Remove First</button>\n        <button onClick={shuffleTodos}>Shuffle Todos</button>\n      </div>\n      <ul>\n        {todos.map((todo) => (\n          <TodoItemComponent key={todo.id} item={todo} /> // Correctly using todo.id as key\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default DynamicTodoList;\n",
          "testCases": [
            "Initial render: Verify all default todos are displayed.",
            "Add a new todo: Add a new item. Verify it appears at the top. Check the console for `TodoItemComponent` mount/unmount logs (only the new item should mount).",
            "Type into an input field, then shuffle: Type some text into the second todo item's input. Click 'Shuffle Todos'. Verify the text you typed follows the original todo item, proving state preservation. Observe console logs to confirm no unnecessary remounts.",
            "Type into an input field, then remove first: Type some text into the second todo item's input. Click 'Remove First'. Verify the first item is removed and your typed text remains with its original todo item (which is now the first). Observe console logs for correct unmounting of only the removed item.",
            "Replace `key={todo.id}` with `key={index}` temporarily: Repeat the 'Type into input then shuffle' test. Observe that the typed text likely stays with the _position_ instead of the _original todo item_, demonstrating the issue with `key={index}`."
          ],
          "hints": [
            "The `key` prop should be placed on the element directly inside the `map()` callback. In this case, it's on `TodoItemComponent`.",
            "Ensure your `TodoItem`'s `key` is based on `item.id`, not the array `index`.",
            "Use `console.log` statements in the `TodoItemComponent` to observe how often it mounts/unmounts with different key strategies. This is a great way to visually confirm the reconciliation behavior.",
            "For unique IDs, `Date.now().toString()` is a simple solution for this example, but in production, UUID libraries (`uuid`) are preferred."
          ],
          "tags": [
            "React",
            "Virtual DOM",
            "Reconciliation",
            "Keys",
            "List Rendering",
            "State Management",
            "Performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_state_props",
            "list_rendering",
            "virtual_dom_reconciliation"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "virtual_dom_reconciliation",
            "keys_in_lists",
            "component_lifecycle"
          ]
        }
      ]
    }
  },
  {
    "id": "9b1a3405-fa73-4124-bedd-7912f9063ff8",
    "startLine": 2800,
    "endLine": 2899,
    "processedDate": "2025-06-17T08:30:48.444Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_virtual_dom",
          "title": "Virtual DOM vs. Real DOM and Performance Benefits",
          "content": "## Understanding the DOM (Document Object Model)\n\nThe **Real DOM** is a programming interface for HTML and XML documents. It represents the page structure as a tree of nodes, where each node is an element, attribute, or text. When an element on a webpage changes, the browser must re-render that specific element and its children, which can be computationally expensive, especially for complex UIs with frequent updates.\n\n### Real DOM Characteristics:\n- **Updates Slowly**: Direct manipulation of the Real DOM is slow because it involves recalculating CSS, layout, and painting for the entire subtree affected by the change.\n- **Direct Manipulation**: Allows direct manipulation of HTML elements.\n- **Full DOM Reconstruction**: When an element updates, the entire DOM might need to be re-evaluated or re-created, leading to performance bottlenecks.\n- **Expensive Manipulation**: Each DOM manipulation operation is costly.\n- **Higher Memory Consumption**: Requires more memory as it represents the live, rendered UI.\n\n## Introducing the Virtual DOM\n\nThe **Virtual DOM** is a concept implemented by libraries like React to optimize UI updates. It's a lightweight, in-memory representation of the Real DOM. When the state of a component changes, React first updates its Virtual DOM. It then compares the new Virtual DOM with the previous one (a process called 'diffing') to identify exactly what has changed.\n\n### Virtual DOM Characteristics:\n- **Updates Faster**: Changes are applied to the in-memory Virtual DOM, which is much quicker than directly manipulating the Real DOM.\n- **Indirect Manipulation**: Cannot directly manipulate HTML; it's an abstraction layer.\n- **Efficient Updates**: Updates only the JSX (React's syntax extension) representation, which then intelligently applies minimal changes to the Real DOM.\n- **Easy Manipulation**: DOM manipulation becomes abstracted and very efficient.\n- **Less Memory Consumption**: Generally uses less memory as it's a lightweight representation.\n\n### The Reconciliation Process:\n\nReact's reconciliation algorithm is the core mechanism behind the Virtual DOM's performance benefits. When a component's `render()` method returns a different React element tree, React will diff the new tree with the previous one. It then calculates the most efficient way to update the Real DOM to match the new tree. This process involves:\n1.  **Re-rendering the Component**: When a component's state or props change, React re-renders its `render()` method.\n2.  **Virtual DOM Creation**: A new Virtual DOM tree is created based on the updated component state.\n3.  **Diffing Algorithm**: React compares the new Virtual DOM tree with the previous one. This algorithm identifies the minimal set of changes needed.\n4.  **Batching Updates**: React batches multiple updates into a single re-render operation to minimize direct DOM manipulations.\n5.  **Real DOM Update**: Only the identified differences are then applied to the Real DOM.\n\n## Performance Benefits of Virtual DOM:\n\n1.  **Reduced DOM Operations**: By diffing the Virtual DOM, React minimizes the number of expensive direct DOM manipulations, only updating parts of the Real DOM that have actually changed.\n2.  **Batch Processing**: React groups multiple state updates together and applies them in a single batch to the Real DOM, avoiding redundant re-renders and improving efficiency.\n3.  **Cross-Platform**: The same reconciliation model and Virtual DOM concept can be applied across different rendering environments (e.g., web, mobile with React Native, desktop with Electron), providing a consistent development experience.\n4.  **Declarative API**: Developers describe the desired UI state, and React handles the complex imperative steps of updating the Real DOM to match that state. This simplifies development by abstracting away direct DOM manipulation concerns.\n\n**Image illustrating the Virtual DOM process:**\n\n![Virtual DOM Process](https://example.com/virtual-dom-flow.png) <!-- Placeholder, as no image was provided in the original content -->\n\nThis image visually explains how changes flow from component state to Virtual DOM diffing, and finally to the optimized Real DOM update."
        },
        {
          "id": "theory_component_types",
          "title": "React Component Types: Class vs. Functional Components",
          "content": "React applications are built using components, which are independent, reusable pieces of UI. Historically, React primarily used Class Components, but with the introduction of Hooks, Functional Components have become the preferred way to write new components.\n\n## Class Components\n\n**Class Components** are JavaScript ES6 classes that extend `React.Component`. They can hold and manage their own state (`this.state`) and have lifecycle methods (like `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`) that allow you to hook into different stages of a component's life cycle. They use a `render()` method to return JSX.\n\n### Characteristics of Class Components:\n-   **State Management**: Can have internal state (`this.state`) and update it using `this.setState()`. This makes them 'stateful' or 'container' components.\n-   **Lifecycle Methods**: Provide specific methods to run code at specific points in a component's lifecycle (e.g., when it mounts, updates, or unmounts).\n-   **`this` Context**: Require careful handling of `this` context, especially when passing methods as props.\n-   **More Boilerplate**: Generally require more code for setup and state management.\n\n## Functional Components\n\n**Functional Components** are plain JavaScript functions that accept props as an argument and return React elements (JSX). Before Hooks, they were primarily used for 'stateless' or 'presentational' components because they couldn't manage their own state or side effects.\n\nWith the introduction of **Hooks** (like `useState`, `useEffect`, `useContext`, etc.), Functional Components gained the ability to manage state, perform side effects, and access other React features, making them equally powerful as Class Components.\n\n### Characteristics of Functional Components:\n-   **Simpler Syntax**: More concise and easier to read.\n-   **No `this` Binding Issues**: Don't have `this` context issues common in class components.\n-   **Hooks for State & Lifecycle**: Use Hooks (`useState`, `useEffect`) to manage state and side effects, effectively replacing `this.state` and lifecycle methods.\n-   **Easier to Test**: Often easier to test due to their pure function nature (before Hooks) or clearer separation of concerns (with Hooks).\n-   **Better Performance (Potentially)**: While React optimizes both, functional components can sometimes lead to smaller bundle sizes and slightly better performance due to less overhead (no class instances, less inheritance chain).\n\n### Comparison Overview:\n\n| Feature           | Class Components                      | Functional Components (with Hooks)              |\n|-------------------|---------------------------------------|-------------------------------------------------|\n| Syntax            | ES6 Class extending `React.Component` | Plain JavaScript function                       |\n| State             | `this.state`, `this.setState()`       | `useState` Hook                                 |\n| Lifecycle         | Lifecycle methods (e.g., `componentDidMount`) | `useEffect` Hook                              |\n| `this` Context    | Present, requires binding             | Not present                                     |\n| Boilerplate       | More                                  | Less                                            |\n| Reusability       | Higher-Order Components (HOCs), Render Props | Hooks, Custom Hooks                             |\n\nBoth types of components can accomplish similar tasks, but functional components with Hooks are the modern standard in React development due to their simplicity, reusability, and improved readability.\n",
          "examples": [
            {
              "id": "example_class_component_1",
              "title": "Class Component Example (News Feed)",
              "code": "import React from 'react';\n\nclass News extends React.Component {\n  render() {\n    const newsTemplate = this.props.data.map(function(item) {\n      return (\n        <div key={item.id}>\n          <p className=\"news__author\">{item.author}:</p>\n          <p className=\"news__text\">{item.text}</p>\n        </div>\n      )\n    })\n    return (\n      <div className=\"news\">\n        {newsTemplate}\n      </div>\n    )\n  }\n}",
              "explanation": "This example shows a basic class component named `News`. It extends `React.Component` and contains a `render()` method which returns JSX. The component accesses its data via `this.props.data` and maps over it to display individual news items. Note the use of `function(item)` for mapping, which establishes its own `this` context (though not relevant here as `this` is not used inside the map callback for component properties).",
              "language": "javascript"
            },
            {
              "id": "example_functional_component_1",
              "title": "Functional Component Example (News Feed - Traditional)",
              "code": "import React from 'react';\n\nfunction News(props) {\n  const newsTemplate = props.data.map(item => (\n    <div key={item.id}>\n      <p className=\"news__author\">{item.author}:</p>\n      <p className=\"news__text\">{item.text}</p>\n    </div>\n  ));\n  \n  return (\n    <div className=\"news\">\n      {newsTemplate}\n    </div>\n  );\n}",
              "explanation": "This is the functional equivalent of the `News` component. It's a plain JavaScript function that receives `props` as its argument. It directly uses `props.data` to render the news items. This version is more concise and avoids the `this` keyword, making it simpler for presentation-only components.",
              "language": "javascript"
            },
            {
              "id": "example_functional_component_2",
              "title": "Functional Component Example (News Feed - Arrow Function with Destructuring)",
              "code": "import React from 'react';\n\nconst News = (props) => {\n  const { data } = props;\n  \n  return (\n    <div className=\"news\">\n      {data.map(item => (\n        <div key={item.id}>\n          <p className=\"news__author\">{item.author}:</p>\n          <p className=\"news__text\">{item.text}</p>\n        </div>\n      ))}\n    </div>\n  );\n}",
              "explanation": "This variant of the functional component uses an arrow function syntax, which is common in modern React. It also demonstrates destructuring `props` (`const { data } = props;`) for cleaner access to properties. This is syntactically equivalent to the previous functional component example but reflects a more contemporary coding style.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_class_functional_diff_1",
            "question_class_functional_hooks_2",
            "question_functional_state_3",
            "question_class_lifecycle_4",
            "question_functional_advantages_5",
            "question_convert_to_functional_code_1",
            "question_class_functional_flashcard_1"
          ],
          "relatedTasks": [
            "task_component_conversion",
            "task_stateful_vs_stateless_counter"
          ],
          "tags": [
            "React",
            "Components",
            "Class Components",
            "Functional Components",
            "Hooks",
            "JSX",
            "Props"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript ES6",
            "React Basics",
            "JSX"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "React Hooks",
            "State Management",
            "Component Architecture"
          ]
        },
        {
          "id": "theory_stateless_stateful",
          "title": "Stateless vs. Stateful React Components",
          "content": "In React, components can be broadly categorized based on their ability to manage internal state:\n\n## Stateless Components (Presentational Components)\n\n**Stateless Components** are typically pure JavaScript functions (or class components without `this.state`) that accept props and return React elements. Their primary responsibility is to render UI based on the props they receive. They do not have their own internal state, and therefore, their output is predictable given the same props.\n\n### Characteristics of Stateless Components:\n-   **Pure Functions**: Given the same props, they will always render the same output.\n-   **No Internal State**: They do not manage `this.state` or use `useState` hook.\n-   **Focus on UI (How things look)**: Their main purpose is to present data. They are often referred to as 'dumb' or 'presentational' components.\n-   **Easier to Test and Debug**: Due to their predictability and lack of side effects, they are simpler to test in isolation.\n-   **Better Performance (in some cases)**: Without state or lifecycle methods to process, they can sometimes lead to minor performance gains and are easier for React to optimize.\n-   **Ideal for Displaying Data**: Best used for presenting static data or UI elements based on props.\n\n## Stateful Components (Container Components)\n\n**Stateful Components** (also known as 'Container' or 'Smart' components) are responsible for managing data, state, and complex logic. They typically fetch data, perform computations, and then pass down data and callback functions as props to their stateless children for rendering.\n\n### Characteristics of Stateful Components:\n-   **Internal State Management**: They can manage internal state using `this.state` (in class components) or `useState` (in functional components).\n-   **Business Logic**: Contain the application's business logic, data fetching, and state manipulation.\n-   **Focus on Behavior (How things work)**: Their main purpose is to manage state and logic, passing processed data to presentational components.\n-   **Lifecycle Management**: Class components use lifecycle methods; functional components use `useEffect` for side effects like data fetching or subscriptions.\n-   **Less Reusable in Isolation**: Due to their specific logic and state, they are often less reusable than stateless components, but they compose stateless components to build complex UIs.\n-   **Act as Data Sources**: They often serve as data sources for their presentational descendants.\n\n### The Container/Presentational Pattern:\n\nThis pattern encourages a clear separation of concerns:\n-   **Containers (Stateful)**: Handle data, state, and logic. They often render other components (including presentational ones) and pass data to them.\n-   **Presentational (Stateless)**: Responsible solely for rendering UI based on the props they receive. They are unaware of how data is loaded or managed.\n\nThis separation leads to more maintainable, testable, and reusable code.",
          "examples": [
            {
              "id": "example_stateless_component_1",
              "title": "Stateless Functional Component (UserProfile)",
              "code": "import React from 'react';\n\nfunction UserProfile({ name, age, isActive, hobbies }) {\n  return (\n    <div className=\"profile\">\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>\n      {hobbies && hobbies.length > 0 && (\n        <div>\n          <h3>Hobbies:</h3>\n          <ul>\n            {hobbies.map((hobby, index) => <li key={index}>{hobby}</li>)}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n}",
              "explanation": "This `UserProfile` component is stateless. It receives all necessary data via props (`name`, `age`, `isActive`, `hobbies`) and simply renders them. It has no internal state and its output is solely determined by its input props, making it predictable and easy to test.",
              "language": "javascript"
            },
            {
              "id": "example_stateful_component_1",
              "title": "Stateful Functional Component (Counter)",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const decrement = () => {\n    setCount(prevCount => prevCount - 1);\n  };\n\n  return (\n    <div className=\"counter-container\">\n      <h3>Current Count: {count}</h3>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}",
              "explanation": "This `Counter` component is stateful because it manages its own internal `count` state using the `useState` hook. It also contains logic (the `increment` and `decrement` functions) to update this state. This makes it a 'smart' component responsible for managing its own behavior.",
              "language": "javascript"
            },
            {
              "id": "example_stateful_stateless_composition_1",
              "title": "Stateful Parent and Stateless Child Composition",
              "code": "import React, { useState } from 'react';\n\n// Stateless Child Component\nfunction DisplayCount({ count }) {\n  return (\n    <p>The current count is: <strong>{count}</strong></p>\n  );\n}\n\n// Stateful Parent Component\nfunction CounterApp() {\n  const [currentCount, setCurrentCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCurrentCount(prevCount => prevCount + 1);\n  };\n\n  const handleDecrement = () => {\n    setCurrentCount(prevCount => prevCount - 1);\n  };\n\n  return (\n    <div>\n      <h1>Counter Application</h1>\n      <DisplayCount count={currentCount} /> {/* Stateless child receives count as prop */}\n      <button onClick={handleIncrement}>Increase</button>\n      <button onClick={handleDecrement}>Decrease</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the container/presentational pattern. `CounterApp` is a stateful component that manages the `currentCount` state and the logic for incrementing/decrementing it. `DisplayCount` is a stateless component that simply receives the `count` as a prop and displays it. This separation makes `DisplayCount` highly reusable and simpler, while `CounterApp` manages the application's core logic.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_stateless_characteristics_1",
            "question_stateful_role_2",
            "question_presentational_container_3",
            "question_stateless_performance_4",
            "question_stateless_debug_5",
            "question_state_props_flashcard_1",
            "question_stateless_code_1"
          ],
          "relatedTasks": [
            "task_stateful_vs_stateless_counter"
          ],
          "tags": [
            "React",
            "Components",
            "State",
            "Props",
            "Stateless Components",
            "Stateful Components",
            "Presentational Components",
            "Container Components"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "Props",
            "State Management in React (useState)"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Component Architecture",
            "State Management Patterns",
            "Performance Optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_virtual_dom_speed_mcq_1",
          "topic": "Virtual DOM",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is a primary reason why Virtual DOM updates faster than Real DOM?",
          "answer": "It minimizes the number of direct DOM manipulations.",
          "options": [
            "It directly manipulates HTML.",
            "It minimizes the number of direct DOM manipulations.",
            "It creates a new DOM whenever an element updates.",
            "It consumes more memory, thus processing faster."
          ],
          "analysisPoints": [
            "The Virtual DOM is an in-memory representation, allowing fast comparisons.",
            "The 'diffing' algorithm identifies minimal changes needed.",
            "Batch processing groups multiple updates into one Real DOM update.",
            "Direct Real DOM manipulation is expensive due to re-layouts and re-paints."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Real DOM",
            "DOM Manipulation",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of Virtual DOM's core performance benefit.",
            "Ability to distinguish between efficient and inefficient DOM operations."
          ],
          "example": "The Virtual DOM first updates its own lightweight representation. Then, it compares this new version with the previous one. Only the identified differences are 'patched' to the actual Real DOM, reducing costly direct manipulations.",
          "tags": [
            "Virtual DOM",
            "Performance",
            "React",
            "DOM"
          ],
          "prerequisites": [
            "Basic DOM knowledge",
            "Understanding of UI rendering"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_real_dom_property_mcq_2",
          "topic": "Real DOM",
          "level": "easy",
          "type": "mcq",
          "question": "According to the provided content, which statement is true regarding the Real DOM?",
          "answer": "It can directly manipulate HTML.",
          "options": [
            "It updates faster than the Virtual DOM.",
            "It cannot directly manipulate HTML.",
            "It creates a new DOM when an element updates.",
            "DOM manipulation is very easy with it."
          ],
          "analysisPoints": [
            "The Real DOM is the actual browser DOM, allowing direct manipulation.",
            "Its updates are slow compared to Virtual DOM due to re-layouts/re-paints.",
            "Virtual DOM updates JSX, not the Real DOM directly.",
            "Real DOM manipulation is expensive and not 'easy' in terms of performance."
          ],
          "keyConcepts": [
            "Real DOM",
            "Virtual DOM",
            "DOM Manipulation",
            "Performance"
          ],
          "evaluationCriteria": [
            "Correct recall of Real DOM characteristics.",
            "Ability to differentiate Real DOM from Virtual DOM properties."
          ],
          "example": "The browser uses the Real DOM to render web pages. Developers can access and modify it directly using standard DOM APIs (e.g., `document.getElementById().innerHTML = 'new content'`). However, such direct modifications trigger expensive browser reflows and repaints.",
          "tags": [
            "Real DOM",
            "DOM",
            "HTML",
            "Browser"
          ],
          "prerequisites": [
            "Basic DOM knowledge"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_reconciliation_open_1",
          "topic": "Virtual DOM Reconciliation",
          "level": "medium",
          "type": "open",
          "question": "Explain the reconciliation process in React, detailing how the Virtual DOM contributes to efficient UI updates.",
          "answer": "The reconciliation process is React's algorithm for efficiently updating the browser's Real DOM. It involves three main steps:\n\n1.  **Re-rendering and Virtual DOM Creation**: When a component's state or props change, React re-executes its `render()` method, creating a new Virtual DOM tree (a React Element tree) that represents the updated UI.\n\n2.  **Diffing Algorithm**: React then compares this new Virtual DOM tree with the previous one. This 'diffing' algorithm works by comparing elements level by level. If two elements are of different types, React will tear down the old tree and build the new one from scratch. If they are of the same type, React looks at the attributes (props) and updates only the changed ones. For lists, it uses `keys` to identify which items have changed, been added, or removed.\n\n3.  **Batching and Real DOM Update**: After identifying the minimal set of changes (the 'diff'), React batches these updates together. Instead of making many small, individual changes to the Real DOM, it applies all changes in a single, optimized operation. This batching, combined with only updating the necessary parts of the Real DOM, significantly reduces expensive browser operations like layout calculation and painting, leading to faster and smoother UI updates.",
          "analysisPoints": [
            "Clarity in explaining the steps (render, diff, update).",
            "Understanding of the Virtual DOM's role as an intermediate step.",
            "Mention of diffing algorithm and its efficiency.",
            "Explanation of batching and its performance benefits."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Reconciliation",
            "Diffing Algorithm",
            "Batching",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Detailed explanation of the process flow.",
            "Accuracy in describing how Virtual DOM improves performance.",
            "Use of correct terminology."
          ],
          "example": "When a user clicks a 'Like' button, only the 'like count' text needs to change, not the entire comment section. React's Virtual DOM diffs the old and new component states, identifies just the text node change, and efficiently updates only that specific text node in the Real DOM, avoiding a full re-render of the parent comment.",
          "tags": [
            "React",
            "Virtual DOM",
            "Performance",
            "Reconciliation",
            "Interview Question"
          ],
          "prerequisites": [
            "Theory of Virtual DOM"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_flashcard_1",
          "topic": "Virtual DOM",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of the Virtual DOM in React?",
          "answer": "To provide an in-memory representation of the Real DOM, enabling efficient updates by minimizing direct DOM manipulations through a diffing algorithm.",
          "analysisPoints": [
            "Recall of Virtual DOM definition.",
            "Understanding of its purpose (efficiency)."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Efficiency",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition."
          ],
          "example": "N/A",
          "tags": [
            "Virtual DOM",
            "React",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_declarative_api_flashcard_1",
          "topic": "Declarative API",
          "level": "medium",
          "type": "flashcard",
          "question": "How does React's 'Declarative API' benefit developers in terms of DOM updates?",
          "answer": "Developers describe the desired UI state, and React handles the complex imperative steps of updating the Real DOM to match that state, abstracting away direct DOM manipulation concerns.",
          "analysisPoints": [
            "Understanding the concept of declarative programming.",
            "Relating it to React's approach to UI updates.",
            "Contrasting with imperative DOM manipulation."
          ],
          "keyConcepts": [
            "Declarative API",
            "React",
            "DOM Updates",
            "Abstraction"
          ],
          "evaluationCriteria": [
            "Ability to explain the benefit of declarative UI."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Declarative",
            "API",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_functional_diff_1",
          "topic": "Class vs Functional Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is a primary distinction between a React Class Component and a Functional Component (when Hooks are used in the latter)?",
          "answer": "Class components use `this.state` for state management, while functional components use the `useState` hook.",
          "options": [
            "Class components can manage state, but functional components cannot.",
            "Class components use `this.state` for state management, while functional components use the `useState` hook.",
            "Class components require `props` to be passed explicitly, while functional components receive them automatically.",
            "Functional components always have access to lifecycle methods, while class components do not."
          ],
          "analysisPoints": [
            "Functional components *can* manage state with `useState`.",
            "The core difference in state management syntax (`this.state` vs. `useState`).",
            "Both component types receive props automatically.",
            "Class components use lifecycle methods; functional components use `useEffect` (a Hook) to replicate similar behavior."
          ],
          "keyConcepts": [
            "Class Components",
            "Functional Components",
            "State Management",
            "Hooks",
            "useState"
          ],
          "evaluationCriteria": [
            "Correct identification of state management differences.",
            "Understanding of how Hooks enable state in functional components."
          ],
          "example": "```javascript\n// Class Component State\nclass MyClassComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n}\n\n// Functional Component State\nfunction MyFunctionComponent() {\n  const [count, setCount] = React.useState(0);\n}\n```",
          "tags": [
            "React",
            "Components",
            "Class Components",
            "Functional Components",
            "Hooks",
            "State"
          ],
          "prerequisites": [
            "React Basics",
            "Introduction to Hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_functional_hooks_2",
          "topic": "Class vs Functional Components",
          "level": "medium",
          "type": "open",
          "question": "Discuss the advantages of using Functional Components with Hooks over Class Components for modern React development.",
          "answer": "Functional Components with Hooks offer several advantages in modern React development:\n\n1.  **Simpler Syntax & Less Boilerplate**: Functional components are plain JavaScript functions, leading to more concise and readable code compared to the class syntax, which requires `extends React.Component`, `constructor`, `super(props)`, and the `render()` method.\n2.  **No `this` Binding Issues**: Functional components don't have their own `this` context, eliminating the common problem of `this` binding in class components' event handlers, which often required `.bind(this)` or arrow functions.\n3.  **Improved Reusability with Custom Hooks**: Hooks allow stateful logic to be extracted and reused across different components without altering the component hierarchy (unlike HOCs or render props patterns used with class components). This promotes cleaner, more modular code.\n4.  **Better Separation of Concerns**: `useEffect` allows grouping related logic (e.g., data fetching and cleanup) into a single hook, rather than scattering it across multiple lifecycle methods (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`) in class components. This improves code organization and readability.\n5.  **Easier to Test**: Being pure functions (initially) or functions that clearly define their dependencies and effects, functional components can sometimes be easier to test in isolation.\n6.  **Potential for Optimizations**: While React optimizes both, functional components can sometimes lead to smaller bundle sizes and potentially better performance due to less overhead (no class instances).\n\nIn summary, Hooks provide a more direct API to React features like state and lifecycle, making functional components powerful, flexible, and the preferred paradigm for new React development.",
          "analysisPoints": [
            "Covers syntax simplification.",
            "Addresses `this` binding problem.",
            "Explains reusability via custom hooks.",
            "Discusses separation of concerns with `useEffect`.",
            "Mentions testability and potential performance benefits."
          ],
          "keyConcepts": [
            "Functional Components",
            "Class Components",
            "React Hooks",
            "useState",
            "useEffect",
            "Code Reusability",
            "Separation of Concerns"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison of advantages.",
            "Clear explanation of how Hooks address class component limitations.",
            "Demonstration of in-depth React knowledge."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Components",
            "Hooks",
            "Best Practices",
            "Interview Question"
          ],
          "prerequisites": [
            "Knowledge of Class Components",
            "Knowledge of React Hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_functional_state_3",
          "topic": "Functional Components",
          "level": "easy",
          "type": "mcq",
          "question": "Consider the following functional component:\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n```\n\nWhat React Hook is used to manage the internal state `count` in this functional component?",
          "answer": "`useState`",
          "options": [
            "`useEffect`",
            "`useContext`",
            "`useReducer`",
            "`useState`"
          ],
          "analysisPoints": [
            "The question specifically asks about state management.",
            "`useState` is the primary hook for adding state to functional components.",
            "Other hooks (`useEffect`, `useContext`, `useReducer`) serve different purposes related to side effects, context, and complex state logic, respectively."
          ],
          "keyConcepts": [
            "Functional Components",
            "React Hooks",
            "useState",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correct identification of `useState` hook.",
            "Basic understanding of React Hooks functionality."
          ],
          "example": "The `useState` hook returns an array containing the current state value (`count`) and a function to update it (`setCount`). When `setCount` is called, React re-renders the component with the new state value.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Functional Components"
          ],
          "prerequisites": [
            "Basic React Hooks"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_lifecycle_4",
          "topic": "Class Components",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary method in a Class Component used to render JSX?",
          "answer": "The `render()` method.",
          "analysisPoints": [
            "Recall of Class Component structure.",
            "Understanding the purpose of the `render` method."
          ],
          "keyConcepts": [
            "Class Components",
            "render() method",
            "JSX"
          ],
          "evaluationCriteria": [
            "Accurate recall of Class Component methods."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Class Components",
            "JSX",
            "Flashcard"
          ],
          "prerequisites": [
            "Basic Class Components"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_advantages_5",
          "topic": "Functional Components",
          "level": "hard",
          "type": "code",
          "question": "Refactor the following Class Component into a Functional Component using React Hooks.\n\n```javascript\nimport React from 'react';\n\nclass DataFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      data: null,\n      loading: true,\n      error: null\n    };\n  }\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  async fetchData() {\n    try {\n      const response = await fetch(this.props.url);\n      const data = await response.json();\n      this.setState({ data, loading: false });\n    } catch (error) {\n      this.setState({ error, loading: false });\n    }\n  }\n\n  render() {\n    const { data, loading, error } = this.state;\n    if (loading) return <p>Loading data...</p>;\n    if (error) return <p>Error: {error.message}</p>;\n    return (\n      <div>\n        <h2>Fetched Data</h2>\n        <pre>{JSON.stringify(data, null, 2)}</pre>\n      </div>\n    );\n  }\n}\n```",
          "answer": "```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction DataFetcher({ url }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [url]); // Depend on 'url' so data refetches if URL changes\n\n  if (loading) return <p>Loading data...</p>;\n  if (error) return <p>Error: {error.message}</p>;\n\n  return (\n    <div>\n      <h2>Fetched Data</h2>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n}\n```",
          "analysisPoints": [
            "Correct use of `useState` for each piece of state (`data`, `loading`, `error`).",
            "Correct use of `useEffect` to replace `componentDidMount` for data fetching.",
            "Proper handling of asynchronous operations (async/await) within `useEffect`.",
            "Correct dependency array (`[url]`) for `useEffect` to manage re-fetching.",
            "Destructuring props directly in the functional component signature.",
            "Removal of `this` keyword and class-specific syntax."
          ],
          "keyConcepts": [
            "Class Components to Functional Components Conversion",
            "useState Hook",
            "useEffect Hook",
            "Asynchronous Operations in React",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Accuracy of state conversion.",
            "Correct implementation of `useEffect` for side effects.",
            "Robust error handling and loading state management.",
            "Adherence to functional component best practices."
          ],
          "example": "The `useState` hook is used for `data`, `loading`, and `error` states. The `useEffect` hook simulates `componentDidMount` by running once when the component mounts (or when `url` changes). The `async/await` pattern is used inside `useEffect` to handle the asynchronous nature of `fetch`. Cleanup logic (if any) would be returned from `useEffect`.",
          "tags": [
            "React",
            "Hooks",
            "Code Challenge",
            "Class Components",
            "Functional Components",
            "Data Fetching"
          ],
          "prerequisites": [
            "Advanced React Hooks",
            "JavaScript Async/Await"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_class_functional_flashcard_1",
          "topic": "Class vs Functional Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Do functional components require the `render()` method?",
          "answer": "No, functional components directly return JSX.",
          "analysisPoints": [
            "Recall of syntax differences.",
            "Understanding what functional components return."
          ],
          "keyConcepts": [
            "Functional Components",
            "render() method",
            "JSX"
          ],
          "evaluationCriteria": [
            "Concise and accurate answer about component structure."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Functional Components",
            "JSX",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_stateless_characteristics_1",
          "topic": "Stateless Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a characteristic of Stateless (Presentational) Components?",
          "answer": "They manage complex business logic and state.",
          "options": [
            "They accept props and return React elements.",
            "They focus on UI rendering (how things look).",
            "They are generally easier to test and debug.",
            "They manage complex business logic and state."
          ],
          "analysisPoints": [
            "Stateless components are pure functions based on props.",
            "Their main role is presentation, not logic or state management.",
            "Predictability makes them easy to test.",
            "State and complex logic are roles of stateful/container components."
          ],
          "keyConcepts": [
            "Stateless Components",
            "Presentational Components",
            "State Management",
            "Props",
            "Pure Functions"
          ],
          "evaluationCriteria": [
            "Accurate identification of stateless component properties.",
            "Ability to distinguish between stateless and stateful roles."
          ],
          "example": "A stateless `Button` component might receive `onClick` and `label` props and simply render a button. It doesn't know *what* happens when clicked, only *that* it can be clicked.",
          "tags": [
            "React",
            "Components",
            "Stateless Components",
            "Presentational"
          ],
          "prerequisites": [
            "Basic React Components",
            "Props"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_stateful_role_2",
          "topic": "Stateful Components",
          "level": "medium",
          "type": "open",
          "question": "Describe the primary role and characteristics of Stateful (Container) Components in React. How do they typically interact with Stateless (Presentational) Components?",
          "answer": "The primary role of **Stateful (Container) Components** is to manage the application's data, state, and business logic. They are responsible for 'how things work'.\n\n**Characteristics of Stateful Components:**\n-   **Internal State**: They hold and manage their own internal state (e.g., fetched data, form input values, UI flags).\n-   **Business Logic**: They contain the logic for data manipulation, fetching data from APIs, and handling events that change the application state.\n-   **Lifecycle Management**: They often perform side effects like data fetching on component mount or updates.\n-   **Not Always Reusable in Isolation**: Their specific logic and state make them less generic, though they enable reusability of their presentational children.\n\n**Interaction with Stateless Components:**\nStateful components typically act as data providers for stateless components. They fetch or generate data, process it, and then pass this data down to their stateless (presentational) children via `props`. They also pass down callback functions (e.g., event handlers) that stateless children can invoke to trigger state changes or actions in the stateful parent. This separation allows stateless components to remain 'dumb' and focused purely on rendering, while stateful components handle the 'smart' logic, promoting a clear separation of concerns and making both types of components more maintainable and testable within their respective roles.",
          "analysisPoints": [
            "Clear definition of stateful component's role.",
            "Detailed characteristics (state, logic, lifecycle).",
            "Accurate explanation of interaction with stateless components (props for data, callbacks for actions).",
            "Mention of separation of concerns (Container/Presentational pattern)."
          ],
          "keyConcepts": [
            "Stateful Components",
            "Container Components",
            "State Management",
            "Business Logic",
            "Stateless Components",
            "Presentational Components",
            "Props",
            "Separation of Concerns"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of roles and characteristics.",
            "Clear demonstration of the interaction model.",
            "Understanding of the Container/Presentational pattern."
          ],
          "example": "A `UserListContainer` (stateful) might fetch a list of users from an API and manage loading/error states. It then passes the `users` array to a `UserList` (stateless) component, which is only responsible for rendering each user item. If a `UserItem` has a 'delete' button, `UserListContainer` would pass a `onDeleteUser` callback to it.",
          "tags": [
            "React",
            "Components",
            "Stateful Components",
            "Container Components",
            "Presentational Components",
            "Architecture",
            "Interview Question"
          ],
          "prerequisites": [
            "Theory of Stateless Components",
            "Props and State"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_presentational_container_3",
          "topic": "Component Types",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple React application that displays a list of items. Your solution should demonstrate the concept of Stateful (Container) and Stateless (Presentational) components. The container component should manage the list data, and the presentational component should render individual list items.",
          "answer": "```javascript\nimport React, { useState, useEffect } from 'react';\n\n// Stateless/Presentational Component: Renders a single item\nfunction ListItem({ item, onSelect }) {\n  return (\n    <li\n      style={{ cursor: 'pointer', padding: '8px', borderBottom: '1px solid #eee' }}\n      onClick={() => onSelect(item.id)}\n    >\n      {item.name} ({item.category})\n    </li>\n  );\n}\n\n// Stateless/Presentational Component: Renders a list of items\nfunction ItemList({ items, onSelectItem }) {\n  if (!items || items.length === 0) {\n    return <p>No items to display.</p>;\n  }\n\n  return (\n    <ul>\n      {items.map(item => (\n        <ListItem key={item.id} item={item} onSelect={onSelectItem} />\n      ))}\n    </ul>\n  );\n}\n\n// Stateful/Container Component: Manages data fetching and state\nfunction ItemListContainer() {\n  const [items, setItems] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [selectedItemId, setSelectedItemId] = useState(null);\n\n  useEffect(() => {\n    const fetchItems = async () => {\n      try {\n        // Simulate API call\n        const response = await new Promise(resolve =>\n          setTimeout(() =>\n            resolve({\n              ok: true,\n              json: () => Promise.resolve([\n                { id: 1, name: 'Laptop', category: 'Electronics' },\n                { id: 2, name: 'Desk Chair', category: 'Furniture' },\n                { id: 3, name: 'Keyboard', category: 'Electronics' },\n              ]),\n            }),\n          1000\n          )\n        );\n\n        if (!response.ok) {\n          throw new Error('Failed to fetch items');\n        }\n        const data = await response.json();\n        setItems(data);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchItems();\n  }, []);\n\n  const handleSelectItem = (id) => {\n    setSelectedItemId(id);\n    console.log(`Selected Item ID: ${id}`);\n  };\n\n  if (loading) return <p>Loading items...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n\n  return (\n    <div>\n      <h1>Available Items</h1>\n      <ItemList items={items} onSelectItem={handleSelectItem} />\n      {selectedItemId && (\n        <p>You selected item with ID: <strong>{selectedItemId}</strong></p>\n      )}\n    </div>\n  );\n}\n\n// App entry point\n// function App() {\n//   return <ItemListContainer />;\n// }\n// export default App;\n```",
          "analysisPoints": [
            "Correctly identifies `ListItem` and `ItemList` as stateless/presentational components that receive data and callbacks via props.",
            "Correctly identifies `ItemListContainer` as a stateful/container component that manages data fetching, loading/error states, and the `selectedItemId`.",
            "Uses `useState` for state management and `useEffect` for data fetching in the container.",
            "Demonstrates passing data (`items`) and callback functions (`onSelectItem`) from container to presentational components.",
            "Clear separation of concerns between data/logic management and UI rendering."
          ],
          "keyConcepts": [
            "Stateful Components",
            "Stateless Components",
            "Container/Presentational Pattern",
            "Props",
            "State",
            "Hooks (useState, useEffect)",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Successful implementation of the component pattern.",
            "Correct use of React Hooks for state and side effects.",
            "Clear separation of responsibilities.",
            "Readability and maintainability of code."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Components",
            "Code Challenge",
            "State Management",
            "Architecture"
          ],
          "prerequisites": [
            "React Hooks",
            "Component Props",
            "Basic Data Fetching"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_stateless_performance_4",
          "topic": "Stateless Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Can a Stateless (Presentational) component have internal state?",
          "answer": "No, by definition, stateless components do not manage their own internal state. They rely solely on props for data.",
          "analysisPoints": [
            "Direct recall of stateless component definition.",
            "Understanding of the core principle of statelessness."
          ],
          "keyConcepts": [
            "Stateless Components",
            "State",
            "Props"
          ],
          "evaluationCriteria": [
            "Concise and accurate answer."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Components",
            "Stateless",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_stateless_debug_5",
          "topic": "Stateless Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is an advantage of Stateless Components concerning testing and debugging?",
          "answer": "They are easier to test and debug due to predictability and lack of side effects.",
          "options": [
            "They have complex internal logic, making them more robust.",
            "They can manage their own state, simplifying isolated testing.",
            "They are easier to test and debug due to predictability and lack of side effects.",
            "They have extensive lifecycle methods for debugging purposes."
          ],
          "analysisPoints": [
            "Complex logic and state make components harder to test in isolation.",
            "Stateless components by definition lack internal state.",
            "Their output is solely based on props, making them predictable ('pure').",
            "They lack lifecycle methods (or use `useEffect` for *controlled* side effects, not inherent complexity)."
          ],
          "keyConcepts": [
            "Stateless Components",
            "Testing",
            "Debugging",
            "Side Effects",
            "Predictability"
          ],
          "evaluationCriteria": [
            "Understanding of testability implications.",
            "Correctly associating statelessness with simplicity and predictability."
          ],
          "example": "A stateless component that just displays text is easy to test: provide it with a 'text' prop, and assert that it renders that text. There are no external dependencies or internal state changes to worry about.",
          "tags": [
            "React",
            "Components",
            "Stateless Components",
            "Testing",
            "Debugging"
          ],
          "prerequisites": [
            "Theory of Stateless Components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_props_flashcard_1",
          "topic": "State vs Props",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `props` and `state` in React?",
          "answer": "`Props` are immutable and passed from parent to child components, controlling what the component receives from outside. `State` is mutable and managed internally by a component, controlling what the component itself does or changes over time.",
          "analysisPoints": [
            "Distinction between internal (state) and external (props) data.",
            "Mutablility of state vs. immutability of props.",
            "Direction of data flow (props: parent to child; state: component internal)."
          ],
          "keyConcepts": [
            "Props",
            "State",
            "Immutability",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Clear and concise differentiation.",
            "Accuracy of properties for each concept."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "State",
            "Props",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_stateless_code_1",
          "topic": "Stateless Components",
          "level": "medium",
          "type": "code",
          "question": "Create a stateless functional component named `Greeting` that accepts two props: `name` (string) and `isLoggedIn` (boolean). If `isLoggedIn` is true, it should display 'Welcome back, [name]!'. Otherwise, it should display 'Please log in.'.",
          "answer": "```javascript\nimport React from 'react';\n\nfunction Greeting({ name, isLoggedIn }) {\n  return (\n    <div>\n      {isLoggedIn ? (\n        <h1>Welcome back, {name}!</h1>\n      ) : (\n        <h1>Please log in.</h1>\n      )}\n    </div>\n  );\n}\n\n// Example usage:\n// function App() {\n//   return (\n//     <div>\n//       <Greeting name=\"Alice\" isLoggedIn={true} />\n//       <Greeting name=\"Guest\" isLoggedIn={false} />\n//     </div>\n//   );\n// }\n// export default App;\n```",
          "analysisPoints": [
            "Correctly defines a functional component.",
            "Properly destructures props in the function signature.",
            "Uses conditional rendering based on the `isLoggedIn` prop.",
            "Displays the `name` prop when logged in."
          ],
          "keyConcepts": [
            "Stateless Components",
            "Functional Components",
            "Props",
            "Conditional Rendering",
            "JSX"
          ],
          "evaluationCriteria": [
            "Accurate implementation based on requirements.",
            "Demonstrates understanding of props and stateless nature.",
            "Clean and readable code."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Components",
            "Stateless",
            "Code Challenge",
            "Props"
          ],
          "prerequisites": [
            "Basic React Components",
            "Props"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_optimize_virtual_dom_updates",
          "title": "Simulate and Optimize Virtual DOM Updates",
          "description": "\nImplement a React component that displays a large list of items. The goal is to simulate how Virtual DOM updates work efficiently. Initially, render a list of 10,000 items. Then, implement a mechanism to update only a few specific items in the list and observe how React handles it.\n\n**Requirements:**\n1.  Render a list of 10,000 `ListItem` components, each displaying its index and a random number. Each `ListItem` should have a unique `key`.\n2.  Add a button labeled \"Update Random 10 Items\". When clicked, this button should randomly select 10 items from the list and change their random number.\n3.  Ensure that only the 10 updated `ListItem` components re-render, demonstrating the efficiency of React's Virtual DOM reconciliation.\n\n**Hint**: You can add a `console.log` inside the `ListItem` component's render output or use React Developer Tools to verify which components re-render.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useCallback, memo } from 'react';\n\n// Stateless/Presentational Component for a list item\nconst ListItem = memo(({ index, value }) => {\n  console.log(`Rendering ListItem ${index}`); // For observation\n  return (\n    <div style={{ padding: '2px 0' }}>\n      Item {index}: {value}\n    </div>\n  );\n});\n\nfunction LargeListApp() {\n  const initialItems = Array.from({ length: 10000 }, (_, i) => ({\n    id: i,\n    value: Math.floor(Math.random() * 1000)\n  }));\n\n  const [items, setItems] = useState(initialItems);\n\n  const updateRandomItems = useCallback(() => {\n    // TODO: Implement logic to update 10 random items.\n    // Make sure to create a NEW array for React to detect changes.\n    // Example of updating one item:\n    // const newItems = [...items];\n    // newItems[0] = { ...newItems[0], value: Math.floor(Math.random() * 1000) };\n    // setItems(newItems);\n\n  }, [items]);\n\n  return (\n    <div>\n      <h1>Large List Reconciliation Demo</h1>\n      <button onClick={updateRandomItems}>Update Random 10 Items</button>\n      <div style={{ height: '400px', overflowY: 'scroll', border: '1px solid #ccc' }}>\n        {items.map(item => (\n          <ListItem key={item.id} index={item.id} value={item.value} />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// export default LargeListApp;\n",
          "solutionCode": "import React, { useState, useCallback, memo } from 'react';\n\nconst ListItem = memo(({ index, value }) => {\n  console.log(`Rendering ListItem ${index}`);\n  return (\n    <div style={{ padding: '2px 0' }}>\n      Item {index}: {value}\n    </div>\n  );\n});\n\nfunction LargeListApp() {\n  const initialItems = Array.from({ length: 10000 }, (_, i) => ({\n    id: i,\n    value: Math.floor(Math.random() * 1000)\n  }));\n\n  const [items, setItems] = useState(initialItems);\n\n  const updateRandomItems = useCallback(() => {\n    const itemsToUpdate = new Set();\n    while (itemsToUpdate.size < 10) {\n      itemsToUpdate.add(Math.floor(Math.random() * items.length));\n    }\n\n    const newItems = items.map((item, index) => {\n      if (itemsToUpdate.has(index)) {\n        return { ...item, value: Math.floor(Math.random() * 1000) };\n      }\n      return item;\n    });\n    setItems(newItems);\n  }, [items]);\n\n  return (\n    <div>\n      <h1>Large List Reconciliation Demo</h1>\n      <button onClick={updateRandomItems}>Update Random 10 Items</button>\n      <div style={{ height: '400px', overflowY: 'scroll', border: '1px solid #ccc' }}>\n        {items.map(item => (\n          <ListItem key={item.id} index={item.id} value={item.value} />\n        ))}\n      </div>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: Verify 10,000 'Rendering ListItem' logs on first load.",
            "Update: Click 'Update Random 10 Items' button. Observe that only approximately 10 'Rendering ListItem' logs appear in the console, not 10,000.",
            "Data Change: Verify that the numbers for the updated items indeed change on screen."
          ],
          "hints": [
            "Remember to use `memo` for your `ListItem` component to prevent unnecessary re-renders of unchanged items. This helps observe the Virtual DOM's efficiency.",
            "When updating state for an array or object, always create a *new* array/object (e.g., using `map` or spread operator) instead of mutating the existing one. React relies on reference equality to detect changes.",
            "To select random unique indices, consider using a `Set`."
          ],
          "tags": [
            "React",
            "Virtual DOM",
            "Performance",
            "Optimization",
            "useState",
            "useCallback",
            "memo"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React State Management",
            "Functional Components",
            "React Hooks (`useState`, `useCallback`, `memo`)",
            "Basic JavaScript Array Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Reconciliation",
            "Component Re-rendering",
            "Pure Components"
          ]
        },
        {
          "id": "task_component_conversion",
          "title": "Convert Class Component to Functional Component with Hooks",
          "description": "\nConvert the provided React Class Component into an equivalent Functional Component using React Hooks.\n\n**Class Component to Convert:**\n```javascript\nimport React from 'react';\n\nclass Timer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  componentDidMount() {\n    this.timerId = setInterval(() => {\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerId);\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Class Timer: {this.state.count}</h2>\n        <p>Timer updates every second.</p>\n      </div>\n    );\n  }\n}\n```\n\n**Requirements:**\n1.  The functional component should have the same behavior: a counter that increments every second.\n2.  Use `useState` for managing the counter's state.\n3.  Use `useEffect` for setting up and tearing down the `setInterval`.\n4.  Ensure proper cleanup of the interval when the component unmounts.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// TODO: Convert the Class Timer component below to a Functional Component\n// class Timer extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { count: 0 };\n//   }\n//\n//   componentDidMount() {\n//     this.timerId = setInterval(() => {\n//       this.setState(prevState => ({ count: prevState.count + 1 }));\n//     }, 1000);\n//   }\n//\n//   componentWillUnmount() {\n//     clearInterval(this.timerId);\n//   }\n//\n//   render() {\n//     return (\n//       <div>\n//         <h2>Class Timer: {this.state.count}</h2>\n//         <p>Timer updates every second.</p>\n//       </div>\n//     );\n//   }\n// }\n\nfunction FunctionalTimer() {\n  // Implement state and effects here\n  \n  return (\n    <div>\n      <h2>Functional Timer: { /* Your state variable here */ }</h2>\n      <p>Timer updates every second.</p>\n    </div>\n  );\n}\n\n// export default FunctionalTimer;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction FunctionalTimer() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timerId = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n\n    // Cleanup function: runs when the component unmounts\n    return () => {\n      clearInterval(timerId);\n    };\n  }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount\n\n  return (\n    <div>\n      <h2>Functional Timer: {count}</h2>\n      <p>Timer updates every second.</p>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial Render: The timer should start displaying '0' (or initial value).",
            "Increment: The count should increase by 1 every second.",
            "Unmount (simulated by navigating away/conditional rendering): The console logs should indicate that the interval is cleared, preventing memory leaks (e.g., if you temporarily render the component and then remove it)."
          ],
          "hints": [
            "The `useState` hook returns a state variable and a setter function.",
            "The `useEffect` hook takes a callback function and an optional dependency array.",
            "To mimic `componentDidMount` and `componentWillUnmount`, use `useEffect` with an empty dependency array (`[]`) and return a cleanup function from the `useEffect` callback."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Class Components",
            "Functional Components",
            "Conversion",
            "Side Effects",
            "Cleanup"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "React Hooks (`useState`, `useEffect`)",
            "JavaScript `setInterval`"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Lifecycle",
            "State Management",
            "Side Effects in React"
          ]
        },
        {
          "id": "task_stateful_vs_stateless_counter",
          "title": "Build a Counter App: Stateful Parent, Stateless Child",
          "description": "\nCreate a React counter application that clearly separates concerns between a stateful (container) parent component and a stateless (presentational) child component.\n\n**Requirements:**\n1.  **Container Component (`CounterContainer`):**\n    *   Should manage the `count` state using `useState`.\n    *   Should contain functions to `increment` and `decrement` the count.\n    *   Should render the `CounterDisplay` component, passing the current `count` and the `increment`/`decrement` functions as props.\n2.  **Presentational Component (`CounterDisplay`):**\n    *   Should be a functional component.\n    *   Should receive `count`, `onIncrement`, and `onDecrement` as props.\n    *   Should display the current `count`.\n    *   Should have two buttons: 'Increment' and 'Decrement', which call the respective `onIncrement` and `onDecrement` props when clicked.\n    *   Should NOT manage any internal state.\n\nThis task demonstrates the 'Container/Presentational' pattern.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// TODO: Implement the CounterDisplay (stateless) component\nfunction CounterDisplay() {\n  // Props: count, onIncrement, onDecrement\n  return (\n    <div>\n      {/* Display count and buttons */}\n    </div>\n  );\n}\n\n// TODO: Implement the CounterContainer (stateful) component\nfunction CounterContainer() {\n  // Manage count state and logic here\n  // Render CounterDisplay\n  \n  return (\n    <div>\n      <h1>Counter App</h1>\n      {/* Render CounterDisplay here */}\n    </div>\n  );\n}\n\n// export default CounterContainer;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Presentational Component: CounterDisplay\nfunction CounterDisplay({ count, onIncrement, onDecrement }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '5px' }}>\n      <p style={{ fontSize: '2em', margin: '0 0 10px 0' }}>Count: {count}</p>\n      <button onClick={onIncrement} style={{ margin: '5px', padding: '10px 15px' }}>Increment</button>\n      <button onClick={onDecrement} style={{ margin: '5px', padding: '10px 15px' }}>Decrement</button>\n    </div>\n  );\n}\n\n// Container Component: CounterContainer\nfunction CounterContainer() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const handleDecrement = () => {\n    setCount(prevCount => prevCount - 1);\n  };\n\n  return (\n    <div>\n      <h1>Simple Counter Application</h1>\n      <CounterDisplay \n        count={count} \n        onIncrement={handleIncrement} \n        onDecrement={handleDecrement} \n      />\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial State: The counter should start at 0.",
            "Increment Functionality: Clicking 'Increment' should increase the count by 1.",
            "Decrement Functionality: Clicking 'Decrement' should decrease the count by 1.",
            "State Separation: Verify that `CounterDisplay` does not use `useState` and only relies on props."
          ],
          "hints": [
            "Remember that stateless components receive all their data and functions via `props`.",
            "The `useState` hook is crucial for adding state to your functional container component.",
            "When updating state based on the previous state (like incrementing a count), it's best practice to use the functional update form of `setCount` (`setCount(prevCount => prevCount + 1)`)."
          ],
          "tags": [
            "React",
            "Stateful Components",
            "Stateless Components",
            "Container Components",
            "Presentational Components",
            "Props",
            "useState",
            "Component Architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Functional Components",
            "useState Hook",
            "Props"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Composition",
            "Data Flow",
            "Separation of Concerns"
          ]
        }
      ]
    }
  },
  {
    "id": "fa1da733-f612-4535-bd59-00038b677ddd",
    "startLine": 2900,
    "endLine": 2999,
    "processedDate": "2025-06-17T08:35:17.335Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_presentational_components",
          "title": "Presentational Components (UI Components)",
          "content": "Presentational components, also known as UI components, are primarily concerned with how things look. They are typically pure functional components and are designed to be reusable and independent of the rest of the application's business logic or state management.\n\n## Key Characteristics:\n-   **Focus:** Primarily on presentation and UI rendering.\n-   **Independence:** Have no dependencies on the rest of the application's state or data fetching logic.\n-   **Data Flow:** Receive all data and callback functions exclusively via props.\n-   **State Management:** Do not manage their own state (unless it's purely UI-related state, like a toggle for a dropdown menu, but even then, it's often better managed by a container component or passed via props).\n-   **Composition:** Can contain other presentational components.\n-   **Reusability:** Highly reusable across different parts of an application or even different projects.\n\nThey are essential for building a consistent and modular user interface, making it easier to develop, test, and maintain UI elements.",
          "examples": [
            {
              "id": "example_presentational_button",
              "title": "Basic Presentational Button Component",
              "code": "const Button = ({ onClick, text, isDisabled = false }) => (\n  <button onClick={onClick} disabled={isDisabled}>\n    {text}\n  </button>\n);\n\n// Usage example:\n// <Button onClick={() => alert('Clicked!')} text=\"Click Me\" />\n// <Button onClick={() => console.log('Disabled')} text=\"Disabled Button\" isDisabled={true} />",
              "explanation": "This `Button` component is a classic example of a presentational component. It receives its text, click handler, and disabled state entirely through props. It has no internal state, no data fetching logic, and focuses solely on rendering a button based on the provided properties.",
              "language": "typescript"
            },
            {
              "id": "example_presentational_card",
              "title": "Presentational Hobby Card Component",
              "code": "import React from 'react';\n\ninterface HobbyCardProps {\n  title: string;\n  hobbies: string[];\n}\n\nfunction HobbyCard({ title, hobbies }: HobbyCardProps) {\n  return (\n    <div>\n      <h2>{title}</h2>\n      <ul>\n        {hobbies.map(hobby => <li key={hobby}>{hobby}</li>)}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This `HobbyCard` component renders a title and a list of hobbies. All the data it needs (`title` and `hobbies` array) is passed down via props. It doesn't fetch hobbies itself or manage any complex state, making it purely presentational and highly reusable for displaying different sets of hobbies.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Components",
            "Presentational",
            "UI",
            "Functional Components",
            "Props"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "javascript_es6_destructuring"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "container_components",
            "component_architecture"
          ]
        },
        {
          "id": "theory_container_components",
          "title": "Container Components (Stateful/Data Components)",
          "content": "Container components, also known as stateful or data components, are concerned with how things work. They manage and maintain their own state, handle data fetching, subscribe to external events, and often contain both presentational and other container components. They act as a bridge between the data layer and the UI layer, providing data and behavior to their child components.\n\n## Key Characteristics:\n-   **Focus:** Primarily on data, logic, and state management.\n-   **Data Management:** Responsible for fetching data, managing application state, and handling user interactions that modify state.\n-   **Data Provision:** Pass data and callback functions down to presentational (and sometimes other container) components via props.\n-   **Composition:** Can wrap multiple presentational components or other container components.\n-   **Implementation:** Can be implemented as class-based components (using `state` and lifecycle methods like `componentDidMount`) or functional components with Hooks (using `useState`, `useEffect`, `useContext`, etc.).\n-   **Separation of Concerns:** By separating concerns, presentational components remain 'dumb' and reusable, while container components handle the 'smart' logic.",
          "examples": [
            {
              "id": "example_container_dashboard_hooks",
              "title": "Stateful Component using Hooks (User Dashboard)",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Assuming UserList is a presentational component\n// const UserList = ({ users }) => (\n//   <ul>\n//     {users.map(user => <li key={user.id}>{user.name}</li>)}\n//   </ul>\n// );\n\nfunction UserDashboard() {\n  const [users, setUsers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    setIsLoading(true);\n    fetch('/api/users')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        setUsers(data);\n        setIsLoading(false);\n      })\n      .catch(err => {\n        setError(err.message);\n        setIsLoading(false);\n      });\n  }, []); // Empty dependency array means this effect runs once after the initial render\n  \n  if (isLoading) return <p>Loading users...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error}</p>;\n  \n  return (\n    <div>\n      <h1>User Dashboard</h1>\n      {/* UserList would be a presentational component */}\n      {/* <UserList users={users} /> */}\n      {users.length > 0 ? (\n        <ul>\n          {users.map(user => <li key={user.id}>{user.name}</li>)}\n        </ul>\n      ) : (\n        <p>No users found.</p>\n      )}\n    </div>\n  );\n}",
              "explanation": "This `UserDashboard` component demonstrates a container component using React Hooks. It manages the `users`, `isLoading`, and `error` states. The `useEffect` hook handles the data fetching logic when the component mounts. Based on the state, it renders different UI elements (loading, error, or the user list). It passes the fetched `users` data down to a hypothetical `UserList` (or renders them directly here for simplicity), which would be a presentational component.",
              "language": "typescript"
            },
            {
              "id": "example_container_list_class",
              "title": "Container Component using Class (UserListContainer)",
              "code": "import React from 'react';\n\n// Assuming UserList is a presentational component, e.g.:\n// const UserList = ({ users }) => (\n//   <ul>\n//     {users.map(user => <li key={user.id}>{user.name}</li>)}\n//   </ul>\n// );\n\nclass UserListContainer extends React.Component {\n  state = { users: [] };\n  \n  componentDidMount() {\n    // Simulate API call\n    fetch('/api/users')\n      .then(res => {\n        if (!res.ok) {\n          throw new Error(`HTTP error! status: ${res.status}`);\n        }\n        return res.json();\n      })\n      .then(users => this.setState({ users }))\n      .catch(error => console.error('Error fetching users:', error));\n  }\n  \n  render() {\n    // Here, UserList would be a presentational component\n    return (\n      <div>\n        <h2>Users from Container (Class-based)</h2>\n        {this.state.users.length > 0 ? (\n          <ul>\n            {this.state.users.map(user => <li key={user.id}>{user.name}</li>)}\n          </ul>\n        ) : (\n          <p>Loading users or no users available...</p>\n        )}\n        {/* <UserList users={this.state.users} /> */}\n      </div>\n    );\n  }\n}",
              "explanation": "This `UserListContainer` is a class-based container component. It initializes an empty `users` array in its `state`. The `componentDidMount` lifecycle method is used to fetch user data after the component has been inserted into the DOM. Once the data is fetched, the component's state is updated, which triggers a re-render. It would then typically pass this `users` data to a presentational `UserList` component for rendering.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Components",
            "Container",
            "Stateful",
            "Hooks",
            "Class Components",
            "Data Fetching",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "react_state",
            "react_lifecycle_methods",
            "react_hooks_usestate",
            "react_hooks_useeffect",
            "javascript_promises_fetch_api"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "component_architecture",
            "redux_integration",
            "context_api"
          ]
        },
        {
          "id": "theory_hoc",
          "title": "Higher-Order Components (HOCs)",
          "content": "Higher-Order Components (HOCs) are an advanced technique in React for reusing component logic. A HOC is a function that takes a component as an argument and returns a new component with enhanced capabilities or modified props. They are a pattern derived from higher-order functions in functional programming.\n\n## Key Characteristics:\n-   **Function as an Enhancer:** A HOC is not a component itself but a function that wraps a component.\n-   **Input/Output:** It takes a 'WrappedComponent' (a React component) as an input and returns a new React component.\n-   **Logic Reusability:** HOCs are used to abstract away common logic, such as data fetching, state management, authentication checks, or prop manipulation, that can be applied to multiple components.\n-   **Props Proxy:** The most common HOC pattern, where the HOC renders the wrapped component and passes props to it. It can add, remove, or modify props.\n-   **Inheritance Inversion:** Less common, where the HOC extends the `WrappedComponent` and gains access to its state and props, allowing for more control over the wrapped component's rendering.\n-   **Alternatives:** While powerful, HOCs can sometimes lead to wrapper hell or unclear prop origins. Hooks are often preferred in modern React for sharing stateful logic.\n\n## When to use HOCs:\n-   Sharing non-visual logic between multiple components.\n-   Authentication/Authorization logic.\n-   Conditional rendering based on external data.\n-   Performance optimizations (e.g., `shouldComponentUpdate`).",
          "examples": [
            {
              "id": "example_hoc_withuser",
              "title": "Basic HOC: withUser",
              "code": "import React from 'react';\n\n// Simulate a data fetching function\nconst fetchUser = () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ id: 1, name: 'John Doe', email: 'john.doe@example.com' });\n    }, 1000);\n  });\n};\n\nconst withUser = (WrappedComponent) => {\n  return class WithUser extends React.Component {\n    state = { user: null, isLoading: true, error: null };\n    \n    componentDidMount() {\n      this.setState({ isLoading: true });\n      fetchUser()\n        .then(user => this.setState({ user, isLoading: false }))\n        .catch(error => this.setState({ error: error.message, isLoading: false }));\n    }\n    \n    render() {\n      if (this.state.isLoading) {\n        return <p>Loading user data...</p>;\n      }\n      if (this.state.error) {\n        return <p>Error: {this.state.error}</p>;\n      }\n      // Pass the fetched user data and any other original props to the WrappedComponent\n      return <WrappedComponent user={this.state.user} {...this.props} />;\n    }\n  };\n};\n\n// Example of a component that needs user data\nconst UserProfile = ({ user, greeting }) => (\n  <div>\n    <h3>{greeting || 'Welcome'}, {user ? user.name : 'Guest'}</h3>\n    {user && <p>Email: {user.email}</p>}\n  </div>\n);\n\n// Enhance UserProfile with user data\nconst EnhancedUserProfile = withUser(UserProfile);\n\n// Usage in a parent component:\n// <EnhancedUserProfile greeting=\"Hello\" />",
              "explanation": "The `withUser` HOC fetches user data and passes it as a `user` prop to the `WrappedComponent`. It also handles loading and error states. `UserProfile` is a simple presentational component that expects a `user` prop. By wrapping `UserProfile` with `withUser`, `EnhancedUserProfile` automatically receives the user data without `UserProfile` needing to know about the fetching logic. This demonstrates how HOCs can inject props and manage shared logic.",
              "language": "typescript"
            },
            {
              "id": "example_hoc_withlogging",
              "title": "HOC for Logging Props",
              "code": "import React from 'react';\n\nconst withLogger = (WrappedComponent) => {\n  return class WithLogger extends React.Component {\n    componentDidMount() {\n      console.log(`Component ${WrappedComponent.displayName || WrappedComponent.name} mounted with props:`, this.props);\n    }\n\n    componentDidUpdate(prevProps) {\n      console.log(`Component ${WrappedComponent.displayName || WrappedComponent.name} updated. Old props:`, prevProps, 'New props:', this.props);\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n};\n\n// Example component\nconst MyButton = ({ label, onClick }) => <button onClick={onClick}>{label}</button>;\nMyButton.displayName = 'MyButton'; // Useful for HOCs\n\nconst LoggedButton = withLogger(MyButton);\n\n// Usage:\n// <LoggedButton label=\"Click Me\" onClick={() => console.log('Button clicked!')} />",
              "explanation": "The `withLogger` HOC adds logging capabilities to any wrapped component. It logs the props when the component mounts and when it updates. This is a simple example of how HOCs can inject cross-cutting concerns like logging or analytics without modifying the original component's code. It's an example of the 'Props Proxy' pattern where the HOC just passes all props through to the wrapped component while adding additional behavior.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "HOC",
            "Higher-Order Components",
            "Pattern",
            "Code Reusability",
            "Component Enhancement"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_props",
            "react_lifecycle_methods",
            "javascript_functions_as_first_class_citizens"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "custom_hooks",
            "component_design_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_presentational_vs_container_mcq_1",
          "topic": "Presentational vs. Container Components",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following best describes a Presentational Component?",
          "answer": "Focuses on how things look and receives data exclusively via props.",
          "options": [
            "Manages its own state and fetches data from APIs.",
            "Focuses on how things look and receives data exclusively via props.",
            "A function that takes a component and returns a new component.",
            "Responsible for routing and global state management."
          ],
          "analysisPoints": [
            "Tests understanding of the core definition of presentational components.",
            "Distinguishes between UI-focused (presentational) and logic-focused (container) components.",
            "Emphasizes the prop-based data flow for presentational components."
          ],
          "keyConcepts": [
            "Presentational Components",
            "Props",
            "Separation of Concerns",
            "UI Components"
          ],
          "evaluationCriteria": [
            "Ability to recall fundamental characteristics.",
            "Distinguishing between component types."
          ],
          "example": "The correct option highlights the primary role of presentational components: rendering UI based on props, without managing internal state or data logic.",
          "tags": [
            "Presentational Components",
            "UI",
            "Props",
            "Basic"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_container_vs_presentational_mcq_2",
          "topic": "Presentational vs. Container Components",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\ninterface UserListProps {\n  users: { id: number; name: string; }[];\n}\n\nconst UserList: React.FC<UserListProps> = ({ users }) => {\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => <li key={user.id}>{user.name}</li>)}\n      </ul>\n    </div>\n  );\n};\n\nfunction UserDashboard() {\n  const [users, setUsers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  \n  useEffect(() => {\n    setIsLoading(true);\n    fetch('/api/users')\n      .then(response => response.json())\n      .then(data => {\n        setUsers(data);\n        setIsLoading(false);\n      });\n  }, []);\n  \n  if (isLoading) return <p>Loading users...</p>;\n  \n  return <UserList users={users} />;\n}\n```\n\nWhich statement correctly identifies the types of `UserList` and `UserDashboard` components?",
          "answer": "`UserList` is presentational, and `UserDashboard` is container.",
          "options": [
            "`UserList` is container, and `UserDashboard` is presentational.",
            "Both `UserList` and `UserDashboard` are presentational.",
            "`UserList` is presentational, and `UserDashboard` is container.",
            "Both `UserList` and `UserDashboard` are container."
          ],
          "analysisPoints": [
            "Tests the ability to differentiate component types based on their code implementation.",
            "`UserList` receives data via props and focuses on rendering, indicating it's presentational.",
            "`UserDashboard` manages state (`useState`), performs data fetching (`useEffect`), and passes data, indicating it's a container.",
            "Reinforces the concept of separation of concerns in component design."
          ],
          "keyConcepts": [
            "Presentational Components",
            "Container Components",
            "React Hooks (useState, useEffect)",
            "Props",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Code analysis skills.",
            "Accurate classification of component roles."
          ],
          "example": "The `UserList` component only takes `users` as a prop and renders them, fulfilling the criteria of a presentational component. The `UserDashboard` component, on the other hand, manages its own state (`users`, `isLoading`) and handles data fetching, fitting the definition of a container component. It then passes the fetched data to `UserList`.",
          "tags": [
            "Presentational Components",
            "Container Components",
            "React Hooks",
            "Code Analysis"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_hooks_usestate",
            "react_hooks_useeffect"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_definition_flashcard_1",
          "topic": "Higher-Order Components (HOCs)",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a Higher-Order Component (HOC) in React?",
          "answer": "A function that takes a component as an argument and returns a new component with enhanced capabilities.",
          "analysisPoints": [
            "Focuses on the functional nature of HOCs.",
            "Highlights the core purpose: component enhancement."
          ],
          "keyConcepts": [
            "HOC",
            "Function",
            "Component Enhancement"
          ],
          "evaluationCriteria": [
            "Ability to recall core definitions."
          ],
          "example": "HOCs are not components themselves, but functions that operate on components to create new, more powerful components. Think of it like a decorator pattern for React components.",
          "tags": [
            "HOC",
            "Definition",
            "React Patterns"
          ],
          "prerequisites": [
            "react_components",
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoc_use_cases_open_1",
          "topic": "Higher-Order Components (HOCs)",
          "level": "medium",
          "type": "open",
          "question": "Describe scenarios where using a Higher-Order Component (HOC) would be an appropriate design choice in a React application. Provide at least two distinct use cases.",
          "answer": "HOCs are suitable for sharing common logic across multiple components without repeating code. Two distinct use cases are:\n\n1.  **Authentication/Authorization:** An `withAuth` HOC could check if a user is logged in or has specific permissions. If not, it could redirect or display a fallback UI, otherwise, it renders the wrapped component, possibly injecting user data as props.\n    Example: `const AuthenticatedDashboard = withAuth(Dashboard);`\n\n2.  **Data Fetching/Injection:** An `withData` HOC could encapsulate logic for fetching data from an API and then pass that data as props to the wrapped component. This allows presentational components to remain unaware of how data is sourced.\n    Example: `const UserProfileWithData = withUser(UserProfile);` (as seen in the theory example)\n\nOther use cases include logging, analytics tracking, performance optimizations (e.g., debouncing inputs), or prop manipulation.",
          "analysisPoints": [
            "Tests understanding of HOC's practical applications beyond just definition.",
            "Evaluates the ability to identify cross-cutting concerns that HOCs can address.",
            "Encourages thinking about code reusability and separation of concerns."
          ],
          "keyConcepts": [
            "HOC",
            "Code Reusability",
            "Authentication",
            "Data Fetching",
            "Cross-cutting Concerns"
          ],
          "evaluationCriteria": [
            "Relevance of use cases.",
            "Clarity and completeness of explanation.",
            "Demonstration of practical application knowledge."
          ],
          "example": null,
          "tags": [
            "HOC",
            "Use Cases",
            "React Architecture",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_hoc"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_container_component_state_management_flashcard_3",
          "topic": "Container Components",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary responsibility of a Container Component regarding data?",
          "answer": "To manage and maintain its own state, fetch data, and provide data to child components.",
          "analysisPoints": [
            "Reinforces the 'data' aspect of container components.",
            "Emphasizes active management roles like fetching and providing."
          ],
          "keyConcepts": [
            "Container Components",
            "State Management",
            "Data Fetching",
            "Data Provision"
          ],
          "evaluationCriteria": [
            "Quick recall of core responsibility."
          ],
          "example": null,
          "tags": [
            "Container Components",
            "State",
            "Data",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_container_components"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoc_disadvantages_open_2",
          "topic": "Higher-Order Components (HOCs)",
          "level": "hard",
          "type": "open",
          "question": "While Higher-Order Components (HOCs) offer a powerful way to reuse logic, they also come with certain disadvantages or complexities. Discuss at least two potential drawbacks of using HOCs and how modern React patterns (like Hooks) often address these.",
          "answer": "Two potential drawbacks of HOCs are:\n\n1.  **Wrapper Hell / Indirection:** When multiple HOCs are applied to a single component, it can lead to deeply nested component trees in React DevTools, making debugging and understanding the component hierarchy more difficult. The original component might be wrapped several times, leading to a 'wrapper hell' where it's hard to trace which HOC is providing which prop or behavior.\n2.  **Prop Name Collisions:** If multiple HOCs inject props with the same name, they can overwrite each other, leading to unexpected behavior. This requires careful naming conventions or prop remapping within HOCs, which adds complexity.\n\n**How Hooks Address These:**\nReact Hooks (e.g., `useState`, `useEffect`, `useContext`, and custom hooks) provide a way to reuse stateful logic without changing your component hierarchy. Instead of wrapping components, you directly use logic inside functional components:\n\n-   **No Wrapper Hell:** Hooks are functions that you call inside your component, they don't introduce new layers of components in the tree, making debugging simpler and the component hierarchy flatter.\n-   **No Prop Collisions (Directly):** When using custom hooks, you explicitly name the variables and functions returned by the hook, preventing automatic prop name collisions. For instance, two custom hooks can both manage a `loading` state, but you would destructure them as `const { loading: userLoading } = useUser();` and `const { loading: postLoading } = usePosts();`, avoiding conflicts.",
          "analysisPoints": [
            "Tests critical thinking about design patterns and their trade-offs.",
            "Requires knowledge of both HOCs and Hooks.",
            "Evaluates understanding of React's evolution and best practices.",
            "Assesses the ability to compare and contrast different architectural approaches."
          ],
          "keyConcepts": [
            "HOC",
            "React Hooks",
            "Wrapper Hell",
            "Prop Collisions",
            "Code Reusability",
            "Component Architecture"
          ],
          "evaluationCriteria": [
            "Depth of understanding of HOC limitations.",
            "Accuracy of comparison with Hooks.",
            "Clarity and structure of the explanation."
          ],
          "example": null,
          "tags": [
            "HOC",
            "Hooks",
            "React Architecture",
            "Advanced",
            "Trade-offs"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_hooks_custom_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_coding_1",
          "topic": "Higher-Order Components (HOCs)",
          "level": "medium",
          "type": "code",
          "question": "Write a Higher-Order Component (HOC) called `withToggle` that injects a `toggled` boolean state and a `toggle` function into a wrapped component. The `toggled` state should default to `false` and `toggle` should flip its value.\n\nThen, use this HOC to create a `TogglableText` component that displays 'Content is hidden' when `toggled` is `false` and 'Content is visible!' when `toggled` is `true`. The `TogglableText` component should also render a button that calls the `toggle` function.",
          "answer": "```typescript\nimport React from 'react';\n\n// HOC Definition\nconst withToggle = (WrappedComponent) => {\n  return class WithToggle extends React.Component {\n    state = {\n      toggled: false,\n    };\n\n    toggle = () => {\n      this.setState(prevState => ({\n        toggled: !prevState.toggled,\n      }));\n    };\n\n    render() {\n      return (\n        <WrappedComponent \n          toggled={this.state.toggled} \n          toggle={this.toggle} \n          {...this.props} \n        />\n      );\n    }\n  };\n};\n\n// Component to be wrapped\ninterface TogglableTextProps {\n  toggled: boolean;\n  toggle: () => void;\n}\n\nconst TogglableText: React.FC<TogglableTextProps> = ({ toggled, toggle }) => {\n  return (\n    <div>\n      <p>{toggled ? 'Content is visible!' : 'Content is hidden'}</p>\n      <button onClick={toggle}>Toggle Content</button>\n    </div>\n  );\n};\n\n// Applying the HOC\nconst EnhancedTogglableText = withToggle(TogglableText);\n\n// Example Usage (in a parent component):\n// function App() {\n//   return (\n//     <div>\n//       <h1>HOC Example</h1>\n//       <EnhancedTogglableText />\n//     </div>\n//   );\n// }\n// export default App;\n```",
          "analysisPoints": [
            "Tests the ability to implement a functional HOC.",
            "Checks understanding of how HOCs inject state and functions via props.",
            "Evaluates component composition using HOCs.",
            "Demonstrates state management within a HOC context."
          ],
          "keyConcepts": [
            "HOC",
            "State Management",
            "Props Injection",
            "Component Composition",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Correct implementation of HOC pattern.",
            "Proper state management within the HOC.",
            "Successful integration of the HOC with a presentational component.",
            "Code cleanliness and readability."
          ],
          "example": null,
          "tags": [
            "HOC",
            "Coding",
            "State",
            "Intermediate",
            "React Patterns"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_class_components_state"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_when_to_use_container_open_1",
          "topic": "Container Components",
          "level": "medium",
          "type": "open",
          "question": "Explain when it is appropriate to create a Container Component instead of a Presentational Component. Provide a concrete example.",
          "answer": "It is appropriate to create a Container Component when a component needs to handle data logic, manage application state, or interact with external services (like APIs or global state stores), rather than just focusing on UI rendering.\n\n**Example:**\nConsider an application that displays a list of products. A `ProductList` component whose sole responsibility is to render the `products` array passed to it would be a **Presentational Component**. It only cares about *how* the list looks.\n\nHowever, a `ProductListContainer` component would be responsible for:\n1.  Fetching the product data from an API.\n2.  Managing loading and error states during the fetch.\n3.  Potentially filtering or sorting the products.\n4.  Passing the processed `products` data (and perhaps an `isLoading` prop) down to the `ProductList` presentational component. \n\nThis separation allows `ProductList` to remain simple and reusable, while `ProductListContainer` encapsulates the complex data logic.",
          "analysisPoints": [
            "Tests understanding of the 'why' behind container components.",
            "Requires the ability to differentiate responsibilities.",
            "Asks for a practical, illustrative example.",
            "Highlights the separation of concerns principle."
          ],
          "keyConcepts": [
            "Container Components",
            "Presentational Components",
            "Separation of Concerns",
            "Data Fetching",
            "State Management"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Relevance and accuracy of the example.",
            "Demonstration of architectural thinking."
          ],
          "example": null,
          "tags": [
            "Container Components",
            "Presentational Components",
            "Architecture",
            "Design"
          ],
          "prerequisites": [
            "theory_container_components",
            "theory_presentational_components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_vs_hooks_flashcard_4",
          "topic": "HOCs vs. Hooks",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary advantage of Custom Hooks over HOCs for sharing stateful logic in modern React?",
          "answer": "Custom Hooks avoid 'wrapper hell' and allow direct access to React features within functional components without introducing extra layers in the component tree, making code flatter and easier to debug.",
          "analysisPoints": [
            "Compares two key patterns for logic reuse.",
            "Focuses on the structural advantage of Hooks.",
            "Highlights the 'wrapper hell' problem associated with HOCs."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "HOCs",
            "Logic Reusability",
            "Wrapper Hell",
            "Component Tree"
          ],
          "evaluationCriteria": [
            "Accurate comparison of patterns.",
            "Understanding of modern React best practices."
          ],
          "example": null,
          "tags": [
            "HOC",
            "Hooks",
            "Comparison",
            "Advanced"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_hooks_custom_hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_presentational_card",
          "title": "Implement a Reusable Presentational Card Component",
          "description": "\nCreate a versatile `Card` presentational component that displays content based solely on its props. The component should:\n\n1.  Accept `title` (string), `content` (ReactNode), and an optional `footer` (ReactNode) as props.\n2.  Render these elements in a visually distinct 'card' format (e.g., with a border or background).\n3.  Ensure it has no internal state or data fetching logic.\n4.  Be callable with just a title and content, or with all three props.\n\nYour solution should demonstrate proper prop typing for TypeScript.",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\ninterface CardProps {\n  title: string;\n  content: React.ReactNode; \n  footer?: React.ReactNode; // Optional footer\n}\n\nconst Card: React.FC<CardProps> = ({ title, content, footer }) => {\n  // TODO: Implement the Card component\n  // Consider styling for a distinct card look.\n  \n  return (\n    <div style={{ /* Add basic card styling here */ }}>\n      <h3>{title}</h3>\n      <div>\n        {content}\n      </div>\n      {footer && (\n        <div>\n          {footer}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <Card \n//         title=\"Basic Card\"\n//         content={<p>This is the content of the basic card.</p>}\n//       />\n//       <Card \n//         title=\"Card with Footer\"\n//         content={<ul><li>Item 1</li><li>Item 2</li></ul>}\n//         footer={<button>Learn More</button>}\n//       />\n//     </div>\n//   );\n// }\n// export default App;",
          "solutionCode": "import React from 'react';\n\ninterface CardProps {\n  title: string;\n  content: React.ReactNode; \n  footer?: React.ReactNode; \n}\n\nconst Card: React.FC<CardProps> = ({ title, content, footer }) => {\n  const cardStyle: React.CSSProperties = {\n    border: '1px solid #ccc',\n    borderRadius: '8px',\n    padding: '20px',\n    margin: '10px',\n    boxShadow: '0 2px 4px rgba(0,0,0,0.1)',\n    backgroundColor: '#fff',\n    maxWidth: '400px'\n  };\n\n  const headerStyle: React.CSSProperties = {\n    marginBottom: '15px',\n    color: '#333'\n  };\n\n  const contentStyle: React.CSSProperties = {\n    marginBottom: footer ? '15px' : '0',\n    color: '#555'\n  };\n\n  const footerStyle: React.CSSProperties = {\n    paddingTop: '10px',\n    borderTop: '1px solid #eee',\n    marginTop: '10px'\n  };\n\n  return (\n    <div style={cardStyle}>\n      <h3 style={headerStyle}>{title}</h3>\n      <div style={contentStyle}>\n        {content}\n      </div>\n      {footer && (\n        <div style={footerStyle}>\n          {footer}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center' }}>\n//       <Card \n//         title=\"Basic Information\"\n//         content={<p>This card presents some essential details without any complex logic. It simply renders what it's given.</p>}\n//       />\n//       <Card \n//         title=\"User Statistics\"\n//         content={\n//           <div>\n//             <p>Active Users: <strong>1,234</strong></p>\n//             <p>New Signups Today: <strong>25</strong></p>\n//           </div>\n//         }\n//         footer={<button onClick={() => alert('View all stats')}>View More Stats</button>}\n//       />\n//       <Card\n//         title=\"Empty Content Card\"\n//         content={null} // Example with null content, still renders title/footer if present\n//         footer={<small>No content available for this section.</small>}\n//       />\n//     </div>\n//   );\n// }\n// export default App;",
          "testCases": [
            "Render `Card` with only `title` and `content`.",
            "Render `Card` with `title`, `content`, and `footer`.",
            "Verify that the `footer` section is not rendered when `footer` prop is `undefined` or `null`.",
            "Ensure `content` can be any valid ReactNode (e.g., string, JSX, array of elements).",
            "Check for basic styling application (border, padding, etc.)."
          ],
          "hints": [
            "Use inline styles or a CSS module for the card's visual appearance.",
            "Remember that `React.ReactNode` type can include strings, numbers, elements, or arrays of these.",
            "Conditional rendering (`{footer && (...) }`) is key for optional props."
          ],
          "tags": [
            "Presentational Components",
            "UI Components",
            "Props",
            "TypeScript",
            "Styling"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_functional_components",
            "typescript_interfaces_types"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "component_composition",
            "props_drilling"
          ]
        },
        {
          "id": "task_implement_container_user_profile",
          "title": "Implement a User Profile Container Component with Loading/Error States",
          "description": "\nCreate a `UserProfileContainer` component that fetches user data from a mock API endpoint and manages its loading and error states. This container should then pass the fetched user data to a provided `UserProfilePresentational` component.\n\n**Requirements:**\n1.  `UserProfileContainer` should fetch user data (simulated with a `Promise`).\n2.  It must manage `isLoading` and `error` states.\n3.  Display a 'Loading user...' message when `isLoading` is true.\n4.  Display an 'Error: [error message]' when an error occurs.\n5.  Pass the `user` object to a `UserProfilePresentational` component once data is successfully fetched.\n6.  Create a simple `UserProfilePresentational` component that takes `user` as a prop and displays `user.name` and `user.email`.\n\nUse React Hooks (`useState`, `useEffect`) for state and side effects.",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// --- Mock API Call --- \nconst mockFetchUser = (userId: number) => {\n  return new Promise<{ id: number; name: string; email: string; } | null>((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 1) {\n        resolve({ id: 1, name: 'Alice Smith', email: 'alice.smith@example.com' });\n      } else if (userId === 2) {\n        reject(new Error('User with ID 2 not found.'));\n      } else {\n        resolve(null); // No user for other IDs\n      }\n    }, 1500);\n  });\n};\n\n// --- Presentational Component (DO NOT MODIFY) ---\ninterface UserProfileProps {\n  user: { id: number; name: string; email: string; } | null;\n}\n\nconst UserProfilePresentational: React.FC<UserProfileProps> = ({ user }) => {\n  if (!user) {\n    return <p>No user data available.</p>;\n  }\n  return (\n    <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '5px', margin: '10px' }}>\n      <h2>User Profile</h2>\n      <p><strong>Name:</strong> {user.name}</p>\n      <p><strong>Email:</strong> {user.email}</p>\n    </div>\n  );\n};\n\n// --- Your Container Component (Implement this) ---\ninterface UserProfileContainerProps {\n  userId: number;\n}\n\nconst UserProfileContainer: React.FC<UserProfileContainerProps> = ({ userId }) => {\n  // TODO: Implement state for user, isLoading, error\n  // TODO: Use useEffect to call mockFetchUser based on userId\n  // TODO: Handle loading, error, and data display\n\n  return (\n    <div>\n      {/* Render loading, error, or UserProfilePresentational based on state */}\n      <p>Container logic goes here...</p>\n      <UserProfilePresentational user={null} /> {/* Placeholder */}\n    </div>\n  );\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <h1>User Profile App</h1>\n//       <UserProfileContainer userId={1} />\n//       <UserProfileContainer userId={2} /> {/* This should show an error */}\n//       <UserProfileContainer userId={3} /> {/* This should show no user data */}\n//     </div>\n//   );\n// }\n// export default App;",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// --- Mock API Call --- \nconst mockFetchUser = (userId: number) => {\n  return new Promise<{ id: number; name: string; email: string; } | null>((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 1) {\n        resolve({ id: 1, name: 'Alice Smith', email: 'alice.smith@example.com' });\n      } else if (userId === 2) {\n        reject(new Error('User with ID 2 not found.'));\n      } else {\n        resolve(null); // No user for other IDs\n      }\n    }, 1500);\n  });\n};\n\n// --- Presentational Component (DO NOT MODIFY) ---\ninterface UserProfileProps {\n  user: { id: number; name: string; email: string; } | null;\n}\n\nconst UserProfilePresentational: React.FC<UserProfileProps> = ({ user }) => {\n  if (!user) {\n    return <p>No user data available.</p>;\n  }\n  return (\n    <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '5px', margin: '10px' }}>\n      <h2>User Profile</h2>\n      <p><strong>Name:</strong> {user.name}</p>\n      <p><strong>Email:</strong> {user.email}</p>\n    </div>\n  );\n};\n\n// --- Your Container Component (Implement this) ---\ninterface UserProfileContainerProps {\n  userId: number;\n}\n\nconst UserProfileContainer: React.FC<UserProfileContainerProps> = ({ userId }) => {\n  const [user, setUser] = useState<{ id: number; name: string; email: string; } | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    setIsLoading(true);\n    setError(null); // Clear previous errors\n    setUser(null); // Clear previous user data\n\n    mockFetchUser(userId)\n      .then(data => {\n        setUser(data);\n      })\n      .catch(err => {\n        setError(err.message);\n      })\n      .finally(() => {\n        setIsLoading(false);\n      });\n  }, [userId]); // Re-run effect if userId changes\n\n  if (isLoading) {\n    return <p>Loading user...</p>;\n  }\n\n  if (error) {\n    return <p style={{ color: 'red' }}>Error: {error}</p>;\n  }\n\n  return <UserProfilePresentational user={user} />;\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <h1>User Profile App</h1>\n//       <UserProfileContainer userId={1} />\n//       <UserProfileContainer userId={2} /> {/* This should show an error */}\n//       <UserProfileContainer userId={3} /> {/* This should show no user data (null user) */}\n//     </div>\n//   );\n// }\n// export default App;",
          "testCases": [
            "Verify 'Loading user...' message is displayed initially.",
            "Test with `userId={1}`: Ensure `UserProfilePresentational` receives and displays 'Alice Smith' and her email.",
            "Test with `userId={2}`: Ensure an error message 'Error: User with ID 2 not found.' is displayed.",
            "Test with `userId={3}`: Ensure 'No user data available.' is displayed (as `mockFetchUser` resolves with `null`).",
            "Change `userId` prop dynamically (e.g., with a button) to ensure the component re-fetches data and updates correctly.",
            "Ensure no memory leaks (e.g., setting state on unmounted component if not handled, though `useEffect` cleanup for `fetch` is often more complex for simple cases like this mock)."
          ],
          "hints": [
            "Initialize `isLoading` to `true` to show the loading state immediately.",
            "Use the `useEffect` hook for side effects like data fetching. Remember its dependency array.",
            "Handle both `then` (success) and `catch` (error) blocks of the `Promise`.",
            "The `finally` block in a Promise is useful for setting `isLoading` to `false` regardless of success or failure.",
            "Conditional rendering (`if (isLoading) return ...`) is crucial for displaying different UI states."
          ],
          "tags": [
            "Container Components",
            "React Hooks",
            "Data Fetching",
            "State Management",
            "Error Handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_hooks_usestate",
            "react_hooks_useeffect",
            "javascript_promises_fetch_api"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "component_architecture",
            "separation_of_concerns"
          ]
        },
        {
          "id": "task_implement_hoc_with_loading",
          "title": "Implement a `withLoading` HOC",
          "description": "\nCreate a Higher-Order Component (HOC) called `withLoading` that enhances any component by adding a loading state and displaying a loading indicator while a prop named `data` (or any other specified prop) is `null` or `undefined`.\n\n**Requirements:**\n1.  The `withLoading` HOC should accept `WrappedComponent` and an optional `dataPropName` (defaulting to 'data') as arguments.\n2.  If the specified data prop on the `WrappedComponent` is `null` or `undefined`, the HOC should render a 'Loading...' message.\n3.  Otherwise, it should render the `WrappedComponent` with all its original props.\n4.  Demonstrate its use by creating a `ProductList` component that expects a `products` prop, and then use `withLoading` to make it show a loading message when `products` is not yet available.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\n// --- Your HOC (Implement this) ---\nconst withLoading = (WrappedComponent: React.ComponentType<any>, dataPropName: string = 'data') => {\n  // TODO: Return a new component that manages loading logic\n  return (props: any) => {\n    // Check if the relevant data prop is missing\n    const data = props[dataPropName];\n\n    if (data === null || data === undefined) {\n      return <p>Loading...</p>;\n    }\n    \n    // Render the wrapped component with all its props\n    return <WrappedComponent {...props} />;\n  };\n};\n\n// --- Example Component to be Wrapped ---\ninterface ProductListProps {\n  products: { id: number; name: string; }[];\n  title: string;\n}\n\nconst ProductList: React.FC<ProductListProps> = ({ products, title }) => {\n  return (\n    <div>\n      <h3>{title}</h3>\n      {products.length > 0 ? (\n        <ul>\n          {products.map(product => <li key={product.id}>{product.name}</li>)}\n        </ul>\n      ) : (\n        <p>No products available.</p>\n      )}\n    </div>\n  );\n};\n\n// --- Usage Example (for testing) ---\n// const EnhancedProductList = withLoading(ProductList, 'products');\n\n// function App() {\n//   const [products, setProducts] = React.useState<any[] | null>(null);\n\n//   React.useEffect(() => {\n//     setTimeout(() => {\n//       setProducts([\n//         { id: 1, name: 'Laptop' },\n//         { id: 2, name: 'Keyboard' }\n//       ]);\n//     }, 2000);\n//   }, []);\n\n//   return (\n//     <div>\n//       <h1>HOC with Loading</h1>\n//       <EnhancedProductList products={products} title=\"Our Products\" />\n//     </div>\n//   );\n// }\n// export default App;",
          "solutionCode": "import React from 'react';\n\n// --- Your HOC (Implement this) ---\nconst withLoading = (WrappedComponent: React.ComponentType<any>, dataPropName: string = 'data') => {\n  // The HOC returns a new functional component\n  return (props: any) => {\n    // Check if the relevant data prop is missing\n    const data = props[dataPropName];\n\n    if (data === null || data === undefined) {\n      return <p>Loading...</p>;\n    }\n    \n    // Render the wrapped component with all its props\n    return <WrappedComponent {...props} />;\n  };\n};\n\n// --- Example Component to be Wrapped ---\ninterface ProductListProps {\n  products: { id: number; name: string; }[];\n  title: string;\n}\n\nconst ProductList: React.FC<ProductListProps> = ({ products, title }) => {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '5px', margin: '10px' }}>\n      <h3>{title}</h3>\n      {products.length > 0 ? (\n        <ul>\n          {products.map(product => <li key={product.id}>{product.name}</li>)}\n        </ul>\n      ) : (\n        <p>No products available.</p>\n      )}\n    </div>\n  );\n};\n\n// --- Usage Example (for testing) ---\nconst EnhancedProductList = withLoading(ProductList, 'products');\nconst EnhancedGenericComponent = withLoading(ProductList); // Using default 'data' prop name (will not work for ProductList)\n\n// This component demonstrates the usage:\n// function App() {\n//   const [products, setProducts] = React.useState<any[] | null>(null);\n//   const [otherData, setOtherData] = React.useState<string | null>(null);\n\n//   React.useEffect(() => {\n//     // Simulate data fetching for products\n//     setTimeout(() => {\n//       setProducts([\n//         { id: 1, name: 'Laptop' },\n//         { id: 2, name: 'Keyboard' }\n//       ]);\n//     }, 2000);\n\n//     // Simulate data fetching for otherData\n//     setTimeout(() => {\n//       setOtherData('Some other loaded data');\n//     }, 1000);\n//   }, []);\n\n//   return (\n//     <div>\n//       <h1>HOC with Loading</h1>\n//       <h2>Products List:</h2>\n//       <EnhancedProductList products={products} title=\"Available Electronics\" />\n\n//       <h2>Another Component (using default 'data' prop name):</h2>\n//       {/* This will show loading and then 'No products available.' because otherData is not named 'data' */}\n//       <EnhancedGenericComponent data={otherData} title=\"Generic Data Demo\" products={[]} />\n\n//       <h2>Component without HOC (always shows data if provided):</h2>\n//       <ProductList products={products || []} title=\"Raw Product List\" />\n//     </div>\n//   );\n// }\n// export default App;",
          "testCases": [
            "Render `EnhancedProductList` with `products={null}` initially: Should display 'Loading...'.",
            "After a delay, `products` is set to an array: Should display the list of products.",
            "Test with `dataPropName` explicitly set (e.g., `withLoading(MyComponent, 'items')`).",
            "Test with `dataPropName` not provided (default 'data'): Ensure it correctly checks for a prop named 'data'.",
            "Ensure all other props passed to the HOC are correctly forwarded to the `WrappedComponent`.",
            "Test with an empty array for data (e.g., `products=[]`): Should render the `WrappedComponent` (and it should show 'No products available.')."
          ],
          "hints": [
            "The HOC function itself returns a new functional component. This returned component is what will receive props.",
            "Use `props[dataPropName]` to dynamically access the prop that determines the loading state.",
            "Remember to pass all incoming props (`{...props}`) to the `WrappedComponent`.",
            "Consider the distinction between `null`/`undefined` (loading) and an empty array (loaded, but empty data)."
          ],
          "tags": [
            "HOC",
            "Higher-Order Components",
            "Loading State",
            "React Patterns",
            "Functional Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_hoc",
            "react_functional_components",
            "javascript_object_destructuring"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "component_enhancement",
            "props_proxy_pattern"
          ]
        }
      ]
    }
  },
  {
    "id": "134b0e16-02b4-4f7f-891c-05645559f4f0",
    "startLine": 3000,
    "endLine": 3099,
    "processedDate": "2025-06-17T08:36:30.313Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_hoc",
          "title": "Higher-Order Components (HOCs)",
          "content": "Higher-Order Components (HOCs) are an advanced technique in React for reusing component logic. A HOC is essentially a function that takes a component as an argument and returns a new component with enhanced props or behavior. They are used for cross-cutting concerns, meaning functionalities that are common across many components, such as data fetching, authentication, logging, or state management.\n\n## Key Concepts\n-   **Function Signature**: A HOC is a function with the signature `(WrappedComponent) => EnhancedComponent`.\n-   **Logic Reusability**: They promote the reuse of component logic without duplicating code.\n-   **Props Proxying**: The HOC renders the WrappedComponent, passing down props it received, potentially adding, modifying, or removing some.\n-   **Inheritance Inversion (less common)**: The HOC extends the WrappedComponent, allowing access to its state and props, but this is generally discouraged due to complexity and tight coupling.\n\n## How HOCs Work\nA HOC wraps an existing component and injects new props or behavior. It doesn't modify the component itself, nor does it use inheritance. Instead, a HOC composes the original component by wrapping it in a container component. This container component handles the shared logic (e.g., fetching data, providing context) and then passes the necessary data as props to the original component.\n\n## Advantages\n-   **Logic Reuse**: Centralize common logic, reducing code duplication.\n-   **Separation of Concerns**: Decouple presentational components from data-fetching or other non-UI logic.\n-   **Abstracting State and Props**: Can manage state or manipulate props before passing them down.\n\n## Disadvantages\n-   **Prop Collisions**: HOCs can unintentionally override props passed to the wrapped component if they use the same prop names.\n-   **Ref Forwarding Issues**: Refs don't automatically pass through HOCs to the wrapped component, requiring explicit `React.forwardRef`.\n-   **Wrapper Hell**: Too many HOCs can lead to a deeply nested component tree, making debugging harder and obscuring where props originate from.\n-   **Static Composition**: HOCs compose components statically, meaning the injected logic is fixed at render time, unlike Hooks or Render Props which offer more dynamic composition.\n\n## Usage Example\nIn the provided example, `withUser` would be a Higher-Order Component that injects `user` data into `UserProfile`. If `user` is not available (e.g., still loading), it might provide `null` or `undefined`, allowing `UserProfile` to render a loading state.\n",
          "examples": [
            {
              "id": "example_hoc_1",
              "title": "Basic HOC Implementation: withUser",
              "code": "import React, { useState, useEffect } from 'react';\n\n// A Higher-Order Component (HOC) to inject user data\nconst withUser = (WrappedComponent) => {\n  const WithUserComponent = (props) => {\n    const [user, setUser] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n      // Simulate fetching user data\n      setTimeout(() => {\n        const fetchedUser = { name: 'John Doe', id: 1 };\n        setUser(fetchedUser);\n        setLoading(false);\n      }, 1000);\n    }, []);\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n\n    return <WrappedComponent {...props} user={user} />;\n  };\n  WithUserComponent.displayName = `WithUser(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithUserComponent;\n};\n\n// Original Component to be wrapped\nconst UserProfile = ({ user, greeting }) => (\n  user ? <div>{greeting}, {user.name}!</div> : <div>Loading...</div>\n);\n\n// Applying the HOC\nconst UserProfileWithUser = withUser(UserProfile);\n\n// Usage in an App component\nfunction App() {\n  return <UserProfileWithUser greeting=\"Hello\" />;\n}\n",
              "explanation": "This example demonstrates a basic `withUser` HOC. It fetches user data asynchronously and then passes the `user` object as a prop to the `WrappedComponent` (`UserProfile`). It also handles a loading state. The `displayName` is set for easier debugging in React DevTools.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_hoc_1",
            "question_hoc_2",
            "question_hoc_3",
            "question_hoc_4",
            "question_hoc_5"
          ],
          "relatedTasks": [
            "task_hoc_auth_logger"
          ],
          "tags": [
            "React",
            "HOC",
            "Design Patterns",
            "Reusability",
            "Composition"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "react_state",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_react_patterns",
            "logic_reusability",
            "separation_of_concerns"
          ]
        },
        {
          "id": "theory_component_specialization",
          "title": "Component Specialization Pattern",
          "content": "Component specialization is a pattern where you create a more specialized component from a more generic one. This is achieved by creating a new component that renders the generic component with specific, pre-defined props. The main goal is to create reusable variations of a base component, simplifying its usage and ensuring consistency across an application.\n\n## Key Concepts\n-   **Generic Component**: A base component designed to be highly configurable via props, handling a wide range of use cases.\n-   **Specialized Component**: A wrapper component that renders the generic component, fixing certain props or applying specific styles/behaviors, thereby creating a more specific instance.\n-   **Encapsulation**: The specialized component encapsulates the specific configuration, hiding complexity from its consumers.\n\n## How Component Specialization Works\nThe pattern involves defining a generic component that accepts various props to control its appearance and behavior. Then, for common use cases or specific design requirements, you create new, simpler components that internally render this generic component, passing a fixed subset of props. These specialized components often have more semantic names, reflecting their specific purpose (e.g., `PrimaryButton`, `DangerButton`).\n\n## Advantages\n-   **Improved Readability and Semantics**: Specialized components have clear names that indicate their purpose, making code easier to understand.\n-   **Reduced Prop Boilerplate**: Consumers of specialized components don't need to pass the same set of props repeatedly for common variations.\n-   **Design Consistency**: Ensures that specific variations of a component (e.g., a primary button) always look and behave consistently throughout the application.\n-   **Enhanced Reusability**: While the generic component is reusable, specialized components make it easier to reuse specific configurations.\n\n## Disadvantages\n-   **File Sprawl**: Can lead to many small component files if every slight variation is specialized.\n-   **Over-abstraction**: For very simple cases, it might introduce unnecessary layers of abstraction.\n-   **Maintenance Overhead**: Managing many specialized components alongside the generic one can sometimes be more complex.\n",
          "examples": [
            {
              "id": "example_component_specialization_1",
              "title": "Generic Button and Specialized Variations",
              "code": "// Generic Button component\nfunction Button({ size, color, children, ...rest }) {\n  const sizeClass = size === 'large' ? 'text-lg px-6 py-3' : 'text-sm px-4 py-2';\n  const colorClass = {\n    primary: 'bg-blue-500 hover:bg-blue-600 text-white',\n    secondary: 'bg-gray-500 hover:bg-gray-600 text-white',\n    danger: 'bg-red-500 hover:bg-red-600 text-white',\n  }[color] || 'bg-gray-200 hover:bg-gray-300 text-black';\n  \n  return (\n    <button \n      className={`rounded font-medium ${sizeClass} ${colorClass}`}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n}\n\n// Specialized button components using component specialization pattern\nfunction PrimaryButton(props) {\n  return <Button color=\"primary\" {...props} />;\n}\n\nfunction DangerButton(props) {\n  return <Button color=\"danger\" {...props} />;\n}\n\nfunction LargeButton(props) {\n  return <Button size=\"large\" {...props} />;\n}\n\n// Usage\nfunction App() {\n  return (\n    <div>\n      <PrimaryButton onClick={() => console.log('Saved')}>Save</PrimaryButton>\n      <DangerButton onClick={() => console.log('Deleted')}>Delete</DangerButton>\n      <LargeButton color=\"secondary\">Secondary Large Button</LargeButton>\n      <Button color=\"primary\" size=\"large\">Big Primary</Button>\n    </div>\n  );\n}\n",
              "explanation": "This example showcases a generic `Button` component that accepts `size` and `color` props. Then, `PrimaryButton`, `DangerButton`, and `LargeButton` are created as specialized versions. They simply render the `Button` component with pre-set `color` or `size` props, while still allowing consumers to pass additional props like `onClick` or `children` via `...props`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_specialization_1",
            "question_specialization_2",
            "question_specialization_3",
            "question_specialization_4"
          ],
          "relatedTasks": [
            "task_input_specialization"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Component Design",
            "Reusability",
            "DRY"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "ui_library_design",
            "reusable_components"
          ]
        },
        {
          "id": "theory_render_props",
          "title": "Render Props Pattern",
          "content": "The Render Props pattern is a technique for sharing code and functionality between React components using a prop whose value is a function. The component with the render prop calls this function, passing it data or state, instead of implementing its own render logic directly. This allows for flexible and dynamic composition of UI and behavior.\n\n## Key Concepts\n-   **Function as a Prop**: Instead of rendering JSX directly, a component receives a function as a prop (often named `render` or even `children`).\n-   **Child Controls Rendering**: The component that *receives* the render prop is responsible for calling this function and rendering its return value. It passes its internal state or shared logic data as arguments to this function.\n-   **Decoupling Logic from UI**: The component implementing the render prop focuses solely on the logic/state, while the UI structure is entirely controlled by the consumer of the render prop.\n-   **Cross-Cutting Concerns**: Similar to HOCs, render props are excellent for sharing non-visual logic like mouse tracking, window size, authentication status, etc.\n\n## How Render Props Work\nImagine a component that tracks mouse position. Instead of rendering a specific UI element (like a `<div>` showing coordinates), it takes a `render` prop. When its internal mouse position state updates, it calls `this.props.render(this.state.mousePosition)` and renders whatever that function returns. This means the parent component (consumer of `MouseTracker`) dictates *what* gets rendered with the mouse position data.\n\n## Advantages\n-   **Highly Flexible Composition**: Offers dynamic composition at runtime, allowing consumers to fully control the rendering and incorporate the shared logic into any UI structure.\n-   **Clear Prop Origin**: It's very clear where the data comes from (it's passed as an argument to the render prop function).\n-   **No Prop Collisions**: Avoids the prop name collision issues sometimes encountered with HOCs.\n-   **No Wrapper Hell**: Does not introduce extra layers in the component tree just for logic sharing, making debugging simpler than deeply nested HOCs.\n\n## Disadvantages\n-   **Nesting (Indentation) Hell**: Can lead to deeply nested JSX if multiple render props are used, making code harder to read.\n-   **Performance Considerations**: If the render prop function creates new functions on every render, it can cause unnecessary re-renders for pure components (though `React.memo` or `useCallback` can mitigate this).\n-   **Learning Curve**: Can be less intuitive for beginners than simple prop passing.\n\n## Comparison to HOCs\nRender Props and HOCs are both patterns for code reuse. Render Props are generally preferred when you need more dynamic control over rendering and want to avoid prop collisions or wrapper hell. HOCs are useful for simpler, more static enhancements that don't require fine-grained UI control from the consumer.\n",
          "examples": [
            {
              "id": "example_render_props_1",
              "title": "Mouse Tracker with Render Props",
              "code": "import React from 'react';\n\n// A component that tracks mouse position and uses render props pattern\nclass MouseTracker extends React.Component {\n  state = { x: 0, y: 0 };\n  \n  handleMouseMove = (event) => {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  };\n  \n  render() {\n    return (\n      <div \n        style={{ height: '100vh', border: '1px solid black', display: 'flex', justifyContent: 'center', alignItems: 'center' }}\n        onMouseMove={this.handleMouseMove}\n      >\n        {/* The render prop: a function that returns a React element */}\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n\n// A simple Circle component to display position\nconst Circle = ({ position }) => (\n    <div style={{\n        position: 'absolute',\n        left: position.x,\n        top: position.y,\n        width: '50px',\n        height: '50px',\n        borderRadius: '50%',\n        background: 'blue',\n        transform: 'translate(-50%, -50%)'\n    }} />\n);\n\n// Using the render prop\nfunction App() {\n  return (\n    <MouseTracker \n      render={({ x, y }) => (\n        <div>\n          <h1>Move the mouse around!</h1>\n          <p>Current mouse position: {x}, {y}</p>\n          <Circle position={{ x, y }} />\n        </div>\n      )}\n    />\n  );\n}\n",
              "explanation": "This example defines `MouseTracker` which manages its own `x` and `y` state. Instead of directly rendering any UI, it calls `this.props.render` and passes its current state. The `App` component provides the `render` prop as a function, which receives `x` and `y` and uses them to display text and position a `Circle` component.",
              "language": "typescript"
            },
            {
              "id": "example_render_props_2",
              "title": "Children as a Render Prop",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Component using 'children' as a render prop\nfunction DataLoader({ url, children }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      try {\n        // Simulate API call\n        const response = await new Promise(resolve => setTimeout(() => {\n          if (url === '/api/users') resolve({ name: 'Jane Doe', email: 'jane@example.com' });\n          else if (url === '/api/products') resolve([{ id: 1, name: 'Laptop' }, { id: 2, name: 'Keyboard' }]);\n          else throw new Error('Not Found');\n        }, 500));\n        setData(response);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n\n  // 'children' is called as a function here\n  return children({ data, loading, error });\n}\n\n// Usage\nfunction UserDisplay() {\n  return (\n    <DataLoader url=\"/api/users\">\n      {({ data, loading, error }) => {\n        if (loading) return <div>Loading user...</div>;\n        if (error) return <div>Error: {error.message}</div>;\n        if (!data) return <div>No user data.</div>;\n        return (\n          <div>\n            <h2>User Profile</h2>\n            <p>Name: {data.name}</p>\n            <p>Email: {data.email}</p>\n          </div>\n        );\n      }}\n    </DataLoader>\n  );\n}\n\nfunction ProductList() {\n    return (\n      <DataLoader url=\"/api/products\">\n        {({ data, loading, error }) => {\n          if (loading) return <div>Loading products...</div>;\n          if (error) return <div>Error: {error.message}</div>;\n          if (!data || data.length === 0) return <div>No products.</div>;\n          return (\n            <div>\n              <h2>Product List</h2>\n              <ul>\n                {data.map(product => (\n                  <li key={product.id}>{product.name}</li>\n                ))}\n              </ul>\n            </div>\n          );\n        }}\n      </DataLoader>\n    );\n  }\n\nfunction App() {\n    return (\n        <div>\n            <UserDisplay />\n            <hr/>\n            <ProductList />\n        </div>\n    )\n}\n",
              "explanation": "This example uses the `children` prop as a render prop. `DataLoader` fetches data based on a URL and then passes `data`, `loading`, and `error` states to the function provided as `children`. This allows `UserDisplay` and `ProductList` to define their own UI based on the data loading status, demonstrating highly flexible data-driven UI rendering.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_render_props_1",
            "question_render_props_2",
            "question_render_props_3",
            "question_render_props_4",
            "question_render_props_5"
          ],
          "relatedTasks": [
            "task_theme_switcher"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Render Props",
            "Composition",
            "Reusability"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "react_state",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "advanced_react_patterns",
            "logic_reusability",
            "flexible_component_design"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_hoc_1",
          "topic": "Higher-Order Components (HOCs) Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a Higher-Order Component (HOC) in React?",
          "answer": "To reuse component logic across multiple components.",
          "options": [],
          "analysisPoints": [
            "Checks understanding of HOC core purpose.",
            "Distinguishes HOCs from simple utility functions or presentational components."
          ],
          "keyConcepts": [
            "HOC",
            "Logic Reusability",
            "React Patterns"
          ],
          "evaluationCriteria": [
            "Ability to recall core definition",
            "Understanding of HOC's main benefit"
          ],
          "example": "",
          "tags": [
            "HOC",
            "React",
            "Basics"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoc_2",
          "topic": "Higher-Order Components (HOCs) Structure",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the typical structure of a Higher-Order Component (HOC)?\n\n```javascript\n// Option A\nfunction withLogger() {\n  return function(Component) {\n    return class extends React.Component {\n      // ... logic\n    };\n  };\n}\n\n// Option B\nconst withLogger = (Component) => {\n  return (props) => {\n    // ... logic\n    return <Component {...props} />;\n  };\n};\n\n// Option C\nclass withLogger extends React.Component {\n  render() {\n    const { children: Component, ...props } = this.props;\n    // ... logic\n    return <Component {...props} />;\n  }\n}\n\n// Option D\nfunction withLogger(Component, props) {\n  // ... logic\n  return <Component {...props} />;\n}\n```",
          "answer": "Option B",
          "options": [
            "Option A",
            "Option B",
            "Option C",
            "Option D"
          ],
          "analysisPoints": [
            "Tests understanding of HOC signature (function returning a function/component).",
            "Distinguishes HOCs from render props (Option C) or simple functional components (Option D).",
            "Highlights the common pattern of accepting a component and returning a new component (either functional or class-based)."
          ],
          "keyConcepts": [
            "HOC Structure",
            "Functional Components",
            "Class Components",
            "React.Component"
          ],
          "evaluationCriteria": [
            "Ability to identify correct HOC signature",
            "Understanding of functional vs class HOCs"
          ],
          "example": "Option B represents the most common and idiomatic functional HOC structure: a function that takes a component and returns a new functional component that wraps the original. Option A is also a valid HOC, but it returns a class component which is less common for simple HOCs nowadays. Option C describes the render props pattern (using children as a function). Option D is just a regular functional component or helper, not a HOC.",
          "tags": [
            "HOC",
            "React",
            "Syntax",
            "Structure"
          ],
          "prerequisites": [
            "react_components",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_3",
          "topic": "Higher-Order Components (HOCs) Implementation",
          "level": "medium",
          "type": "code",
          "question": "Implement a Higher-Order Component named `withLoadingIndicator` that takes a `WrappedComponent`. If a `loading` prop passed to the `EnhancedComponent` is `true`, it should render a `<div>Loading...</div>`. Otherwise, it should render the `WrappedComponent` with all its original props. Ensure the `loading` prop is consumed by the HOC and not passed down to the `WrappedComponent`.",
          "answer": "```typescript\nimport React from 'react';\n\nconst withLoadingIndicator = (WrappedComponent) => {\n  const WithLoadingIndicator = ({ loading, ...restProps }) => {\n    if (loading) {\n      return <div>Loading...</div>;\n    }\n    return <WrappedComponent {...restProps} />;\n  };\n\n  WithLoadingIndicator.displayName = `WithLoadingIndicator(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithLoadingIndicator;\n};\n\n// Example Usage:\nconst MyComponent = ({ data }) => <div>Data: {data}</div>;\nconst MyComponentWithLoading = withLoadingIndicator(MyComponent);\n\nfunction App() {\n  return (\n    <div>\n      <MyComponentWithLoading loading={true} />\n      <MyComponentWithLoading loading={false} data=\"Hello World\" />\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to correctly define and implement a functional HOC.",
            "Ensures understanding of prop destructuring to consume specific props (`loading`) and pass others (`...restProps`).",
            "Verifies handling of conditional rendering based on HOC-managed logic."
          ],
          "keyConcepts": [
            "HOC",
            "Prop Manipulation",
            "Conditional Rendering",
            "React.memo"
          ],
          "evaluationCriteria": [
            "Correct HOC function signature",
            "Proper prop handling (passing through, consuming)",
            "Accurate conditional rendering logic",
            "Setting displayName for debugging"
          ],
          "example": "The solution demonstrates a functional HOC named `withLoadingIndicator`. It destructures the `loading` prop from the incoming props. If `loading` is true, it renders a loading message. Otherwise, it spreads the `restProps` (all props except `loading`) onto the `WrappedComponent`, ensuring `loading` is handled by the HOC itself and not passed down unnecessarily.",
          "tags": [
            "HOC",
            "React",
            "Coding Challenge",
            "Intermediate"
          ],
          "prerequisites": [
            "react_components",
            "react_props",
            "javascript_destructuring"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_4",
          "topic": "HOC vs. Hooks",
          "level": "hard",
          "type": "open",
          "question": "Discuss the advantages and disadvantages of using Higher-Order Components (HOCs) versus React Hooks for sharing reusable logic. Provide scenarios where one might be preferred over the other.",
          "answer": "### Advantages and Disadvantages:\n\n**Higher-Order Components (HOCs):**\n*   **Advantages:**\n    *   Good for cross-cutting concerns like authentication, logging, data subscription where the component itself doesn't need to directly manage the state or lifecycle.\n    *   Works well with class components and older React codebases.\n    *   Can be used to abstract away complex prop transformations.\n*   **Disadvantages:**\n    *   **Wrapper Hell / Indirection:** Can create multiple layers of components in the React DevTools, making debugging harder and obscuring the source of props.\n    *   **Prop Collisions:** Risk of prop name clashes if HOCs inject props with the same names as those expected by the wrapped component.\n    *   **Ref Forwarding:** Requires `React.forwardRef` to pass refs through the HOC, adding boilerplate.\n    *   **Static Composition:** Logic is 'baked in' at component definition time, less flexible for dynamic behavior.\n\n**React Hooks:**\n*   **Advantages:**\n    *   **Direct Logic Access:** Allows direct access to stateful logic from functional components without introducing new component layers.\n    *   **No Wrapper Hell:** Doesn't add extra nodes to the component tree, leading to flatter hierarchies and easier debugging.\n    *   **Flexible Composition:** Hooks can be composed dynamically and conditionally, allowing for more granular and flexible reuse of logic.\n    *   **Clear Prop Flow:** Logic is exposed directly in the component, making the data flow more explicit.\n    *   **No Ref Forwarding Issues:** `useRef` works naturally within functional components and hooks.\n*   **Disadvantages:**\n    *   **Rules of Hooks:** Must follow strict rules (call only at top level, only from React functions) which can be a learning curve.\n    *   **Not for Class Components:** Hooks can only be used with functional components.\n    *   **Can lead to large components:** If logic isn't properly abstracted into custom hooks, functional components can become very large.\n\n### Scenarios for Preference:\n\n*   **Prefer HOCs when:**\n    *   You are working with an existing large codebase primarily built with class components.\n    *   You need to manipulate or transform props in a generic way before passing them to a component.\n    *   The logic truly abstracts away a concern that doesn't need direct state/effect management within the consuming component, and you don't mind the wrapper. (e.g., `redux`'s `connect` HOC, `react-router`'s `withRouter` in older versions).\n\n*   **Prefer Hooks when:**\n    *   You are building new features or refactoring existing ones using functional components.\n    *   You need to share stateful logic that directly interacts with React's lifecycle (e.g., `useState`, `useEffect`, `useContext`).\n    *   You want to avoid prop drilling and wrapper hell.\n    *   You need more dynamic and granular control over logic composition within a single component. (e.g., `useAuth`, `useForm`, `useWindowSize`).\n\n**Conclusion:** While HOCs are still valid, React Hooks are generally the preferred modern approach for logic reuse in functional components due to their flexibility, directness, and ability to avoid many of the downsides of HOCs.",
          "options": [],
          "analysisPoints": [
            "Comprehensive understanding of both patterns.",
            "Ability to articulate specific advantages and disadvantages for each.",
            "Insight into practical application scenarios.",
            "Knowledge of common pitfalls (wrapper hell, prop collisions, rules of Hooks)."
          ],
          "keyConcepts": [
            "HOC",
            "React Hooks",
            "Logic Reuse",
            "Composition",
            "Prop Collisions",
            "Wrapper Hell",
            "Rules of Hooks"
          ],
          "evaluationCriteria": [
            "Depth of comparison for pros and cons",
            "Clarity of explanation for each point",
            "Relevance of usage scenarios",
            "Demonstration of advanced React knowledge"
          ],
          "example": "",
          "tags": [
            "HOC",
            "React Hooks",
            "Comparison",
            "Advanced",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_hooks_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_5",
          "topic": "HOC Debugging and Best Practices",
          "level": "medium",
          "type": "mcq",
          "question": "When developing a Higher-Order Component (HOC), which best practice helps improve debugging in React DevTools?\n\n```javascript\n// HOC snippet\nconst withData = (WrappedComponent) => {\n  const WithData = (props) => {\n    // ... data fetching logic\n    return <WrappedComponent {...props} data={fetchedData} />;\n  };\n  // Which line helps debugging?\n  // A) WithData.displayName = WrappedComponent.displayName || 'UnnamedComponent';\n  // B) WithData.name = 'DataComponent';\n  // C) console.log('HOC loaded');\n  // D) return React.memo(WithData);\n  return WithData;\n};\n```",
          "answer": "A) WithData.displayName = `WithData(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;",
          "options": [
            "A) WithData.displayName = `WithData(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;",
            "B) WithData.name = 'DataComponent';",
            "C) console.log('HOC loaded');",
            "D) return React.memo(WithData);"
          ],
          "analysisPoints": [
            "Tests knowledge of `displayName` property for debugging HOCs.",
            "Distinguishes between actual debugging aids and unrelated code practices.",
            "Highlights how component names appear in DevTools."
          ],
          "keyConcepts": [
            "HOC",
            "Debugging",
            "React DevTools",
            "displayName"
          ],
          "evaluationCriteria": [
            "Understanding of React's debugging features",
            "Correct identification of `displayName` purpose"
          ],
          "example": "Setting the `displayName` property on the returned component of an HOC is a common best practice. It helps improve the readability of the component tree in React DevTools by providing a meaningful name like `WithData(MyComponent)` instead of just `Component` or `Anonymous`. Options B sets the internal `name` property of the function, which is less directly used by React DevTools for display compared to `displayName`. Option C is basic logging, not component naming. Option D is for performance optimization, not directly for debugging display name.",
          "tags": [
            "HOC",
            "Debugging",
            "Best Practices",
            "React"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_components"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specialization_1",
          "topic": "Component Specialization Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "In React, what is the core idea behind the Component Specialization pattern?",
          "answer": "To create a more specific version of a generic component by pre-setting some of its props, making it simpler to use for common scenarios.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of the pattern's fundamental purpose.",
            "Focuses on the transformation from generic to specific."
          ],
          "keyConcepts": [
            "Component Specialization",
            "Reusability",
            "React Patterns"
          ],
          "evaluationCriteria": [
            "Ability to recall core definition",
            "Understanding of pattern's goal"
          ],
          "example": "",
          "tags": [
            "Component Specialization",
            "React",
            "Basics"
          ],
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_specialization_2",
          "topic": "Component Specialization Implementation",
          "level": "medium",
          "type": "mcq",
          "question": "Given a generic `Input` component:\n\n```javascript\nfunction Input({ type = 'text', placeholder, value, onChange, ...rest }) {\n  return (\n    <input \n      type={type} \n      placeholder={placeholder} \n      value={value} \n      onChange={onChange} \n      className=\"border p-2 rounded\" \n      {...rest} \n    />\n  );\n}\n```\n\nWhich of the following correctly implements a `PasswordInput` component using the Component Specialization pattern?",
          "answer": "```javascript\nfunction PasswordInput(props) {\n  return <Input type=\"password\" placeholder=\"Enter password\" {...props} />;\n}\n```",
          "options": [
            "```javascript\nfunction PasswordInput({ placeholder, ...props }) {\n  return <input type=\"password\" placeholder={placeholder || \"Enter password\"} {...props} />;\n}\n```",
            "```javascript\nfunction PasswordInput(props) {\n  return <Input type=\"password\" placeholder=\"Enter password\" {...props} />;\n}\n```",
            "```javascript\nconst PasswordInput = Input.bind(null, { type: 'password', placeholder: 'Enter password' });\n```",
            "```javascript\nfunction PasswordInput() {\n  return <Input type=\"password\" placeholder=\"Enter password\" />;\n}\n```"
          ],
          "analysisPoints": [
            "Tests understanding of how to pass fixed props and forward remaining props (`...props`).",
            "Ensures correct usage of the generic component within the specialized one.",
            "Differentiates between specialization and recreating component logic.",
            "Identifies common pitfalls like not forwarding `props`."
          ],
          "keyConcepts": [
            "Component Specialization",
            "Prop Forwarding",
            "Generic Components"
          ],
          "evaluationCriteria": [
            "Correct use of `...props` for forwarding",
            "Proper embedding of the generic component",
            "Adherence to the specialization pattern"
          ],
          "example": "The correct option creates a `PasswordInput` functional component that internally renders the generic `Input` component. It explicitly sets `type=\"password\"` and `placeholder=\"Enter password\"` for this specialized version. Crucially, it uses `{...props}` to forward any additional props (like `value`, `onChange`, `id`, `name`, etc.) that might be passed to `PasswordInput` down to the `Input` component, making it flexible.",
          "tags": [
            "Component Specialization",
            "React",
            "Code Example",
            "Pattern"
          ],
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specialization_3",
          "topic": "Component Specialization Use Cases",
          "level": "medium",
          "type": "open",
          "question": "Beyond simple UI elements like buttons, describe a more complex scenario where the Component Specialization pattern would be beneficial. Explain how it would simplify development and maintain consistency.",
          "answer": "A more complex scenario for Component Specialization would be creating different types of 'Card' components in a design system. Imagine a generic `Card` component that accepts props for `header`, `body`, `footer`, `image`, `actions`, `variant` (e.g., 'elevated', 'outlined'), `size` (e.g., 'small', 'medium', 'large'), etc.\n\n### Scenario: Different Card Types\nWe might need specific card types for different parts of an application:\n1.  **Product Card**: Displays product image, name, price, and an 'Add to Cart' button.\n2.  **User Profile Card**: Shows user avatar, name, email, and a 'View Profile' link.\n3.  **Information Alert Card**: A simple card with an icon, a title, and a descriptive message, often with a dismiss button.\n\n### How Specialization Helps:\nInstead of recreating the `Card` structure and styling for each type, we can specialize:\n\n```javascript\n// Generic Card component (simplified for example)\nfunction Card({ children, variant = 'elevated', className = '', ...rest }) {\n  const baseClasses = 'p-4 rounded-lg shadow-md';\n  const variantClasses = variant === 'outlined' ? 'border border-gray-300' : 'bg-white';\n  return (\n    <div className={`${baseClasses} ${variantClasses} ${className}`} {...rest}>\n      {children}\n    </div>\n  );\n}\n\n// Specialized ProductCard\nfunction ProductCard({ product, onAddToCart, ...rest }) {\n  return (\n    <Card className=\"w-64\" {...rest}>\n      <img src={product.imageUrl} alt={product.name} className=\"w-full h-40 object-cover mb-4\" />\n      <h3 className=\"text-lg font-bold mb-2\">{product.name}</h3>\n      <p className=\"text-gray-700 mb-4\">${product.price.toFixed(2)}</p>\n      <button onClick={() => onAddToCart(product.id)} className=\"bg-blue-500 text-white px-4 py-2 rounded\">Add to Cart</button>\n    </Card>\n  );\n}\n\n// Specialized InfoAlertCard\nfunction InfoAlertCard({ title, message, onDismiss, ...rest }) {\n    return (\n        <Card variant=\"outlined\" className=\"border-blue-400 bg-blue-50\" {...rest}>\n            <div className=\"flex items-center mb-2\">\n                <span className=\"text-blue-600 mr-2\">ℹ️</span>\n                <h4 className=\"font-semibold text-blue-800\">{title}</h4>\n            </div>\n            <p className=\"text-blue-700 text-sm mb-4\">{message}</p>\n            {onDismiss && <button onClick={onDismiss} className=\"text-blue-600 text-sm\">Dismiss</button>}\n        </Card>\n    );\n}\n```\n\n### Simplification and Consistency:\n-   **Simplification**: Developers using `ProductCard` don't need to know all the internal `Card` props or structure. They just pass `product` and `onAddToCart`. This simplifies the API for common card types.\n-   **Consistency**: All specialized cards automatically inherit the base styling and structure from the `Card` component. If the base `Card` styling changes (e.g., border-radius, shadow), all specialized cards update automatically. Specific visual treatments (like `InfoAlertCard`'s blue border) are encapsulated within their specialized component.\n-   **Maintainability**: Changes to the core card layout or default behaviors are made in one place (`Card`), propagating consistently across the application.\n-   **Reusability**: `Card` is reusable generically, and `ProductCard`, `InfoAlertCard` are reusable in their specific contexts.",
          "options": [],
          "analysisPoints": [
            "Ability to apply the pattern to a non-trivial, real-world scenario.",
            "Demonstrates understanding of benefits beyond simple prop reduction.",
            "Highlights aspects like consistency, maintainability, and API simplification."
          ],
          "keyConcepts": [
            "Component Specialization",
            "Design System",
            "Reusability",
            "API Design",
            "Consistency"
          ],
          "evaluationCriteria": [
            "Clarity and complexity of the chosen scenario",
            "Detailed explanation of how the pattern applies",
            "Articulation of specific benefits in the scenario"
          ],
          "example": "",
          "tags": [
            "Component Specialization",
            "Design Patterns",
            "Advanced",
            "System Design"
          ],
          "prerequisites": [
            "theory_component_specialization",
            "react_props"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_specialization_4",
          "topic": "Component Specialization vs. Direct Prop Usage",
          "level": "easy",
          "type": "mcq",
          "question": "Consider a `Button` component that accepts a `variant` prop ('primary', 'secondary', 'danger'). Why might you choose to create a `PrimaryButton` specialized component (e.g., `<PrimaryButton>Click</PrimaryButton>`) instead of always using `<Button variant=\"primary\">Click</Button>` directly?",
          "answer": "To improve readability, provide semantic meaning, and reduce repetitive prop passing for common button types.",
          "options": [
            "To improve performance by reducing rendering overhead.",
            "To enforce stricter type checking at compile time.",
            "To allow `PrimaryButton` to have entirely different internal logic.",
            "To improve readability, provide semantic meaning, and reduce repetitive prop passing for common button types."
          ],
          "analysisPoints": [
            "Tests understanding of the 'why' behind specialization.",
            "Distinguishes benefits like readability and reduced boilerplate from technical performance or type-checking aspects.",
            "Emphasizes developer experience improvements."
          ],
          "keyConcepts": [
            "Component Specialization",
            "Readability",
            "DRY Principle",
            "Semantic Components"
          ],
          "evaluationCriteria": [
            "Correct identification of the pattern's benefits",
            "Ability to differentiate from incorrect or unrelated advantages"
          ],
          "example": "The primary reasons for creating a specialized `PrimaryButton` are improved code readability and maintainability. It makes the intent clearer (`<PrimaryButton>` vs. `<Button variant=\"primary\">`) and reduces the amount of boilerplate props that need to be passed every time a primary button is used. It's not primarily for performance or type checking, nor does it imply completely different internal logic from the generic component.",
          "tags": [
            "Component Specialization",
            "Best Practices",
            "Readability",
            "DRY"
          ],
          "prerequisites": [
            "theory_component_specialization"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_props_1",
          "topic": "Render Props Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the defining characteristic of the Render Props pattern in React?",
          "answer": "A component uses a prop (often named `render` or `children`) whose value is a function, which it calls to render its content, passing internal state/data as arguments.",
          "options": [],
          "analysisPoints": [
            "Checks understanding of the pattern's core mechanism.",
            "Highlights the 'function as a prop' concept."
          ],
          "keyConcepts": [
            "Render Props",
            "Function as Prop",
            "React Patterns"
          ],
          "evaluationCriteria": [
            "Ability to recall core definition",
            "Understanding of render prop mechanism"
          ],
          "example": "",
          "tags": [
            "Render Props",
            "React",
            "Basics"
          ],
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_props_2",
          "topic": "Render Props Usage",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `WindowSize` component using the Render Props pattern:\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction WindowSize({ render }) {\n  const [size, setSize] = useState({ width: window.innerWidth, height: window.innerHeight });\n\n  useEffect(() => {\n    const handleResize = () => setSize({ width: window.innerWidth, height: window.innerHeight });\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return render(size);\n}\n```\n\nWhich code snippet correctly uses the `WindowSize` component to display the window's dimensions?",
          "answer": "```javascript\n<WindowSize\n  render={({ width, height }) => (\n    <div>\n      Window Width: {width}px, Height: {height}px\n    </div>\n  )}\n/>\n```",
          "options": [
            "```javascript\n<WindowSize>\n  {({ width, height }) => (\n    <div>\n      Window Width: {width}px, Height: {height}px\n    </div>\n  )}\n</WindowSize>\n```",
            "```javascript\n<WindowSize\n  render={({ width, height }) => (\n    <div>\n      Window Width: {width}px, Height: {height}px\n    </div>\n  )}\n/>\n```",
            "```javascript\n<WindowSize width=\"{width}\" height=\"{height}\" />\n```",
            "```javascript\nconst { width, height } = WindowSize();\n<div>Window Width: {width}px, Height: {height}px</div>\n```"
          ],
          "analysisPoints": [
            "Tests understanding of passing a function as a prop (`render`).",
            "Ensures correct destructuring of arguments passed by the render prop function.",
            "Differentiates between a named render prop and `children` as a render prop (Option A).",
            "Avoids common mistakes of passing strings or calling component as a hook."
          ],
          "keyConcepts": [
            "Render Props",
            "Prop Types",
            "Functional Components",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correct syntax for render prop usage",
            "Proper function argument destructuring",
            "Understanding of how the parent component receives data"
          ],
          "example": "The correct option explicitly passes a function to the `render` prop. This function receives the `size` object (destructured into `width` and `height`) as its argument, which is then used to render the desired UI. Option A would be correct if `WindowSize` component rendered `this.props.children(size)` instead of `this.props.render(size)`. Options C and D are incorrect ways to use the render props pattern.",
          "tags": [
            "Render Props",
            "React",
            "Usage",
            "Pattern"
          ],
          "prerequisites": [
            "theory_render_props",
            "react_hooks_useState_useEffect"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_props_3",
          "topic": "Render Props Implementation",
          "level": "medium",
          "type": "code",
          "question": "Create a React component called `VisibilitySensor` that uses the Render Props pattern. This component should track whether it's currently in the viewport. It should accept a `children` prop which is a function. This function should receive a boolean `isVisible` as an argument. Use the `IntersectionObserver` API to determine visibility.",
          "answer": "```typescript\nimport React, { useRef, useState, useEffect } from 'react';\n\nfunction VisibilitySensor({ children }) {\n  const [isVisible, setIsVisible] = useState(false);\n  const elementRef = useRef(null);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setIsVisible(entry.isIntersecting);\n      },\n      { threshold: 0.1 } // Trigger when 10% of the element is visible\n    );\n\n    if (elementRef.current) {\n      observer.observe(elementRef.current);\n    }\n\n    return () => {\n      if (elementRef.current) {\n        observer.unobserve(elementRef.current);\n      }\n      observer.disconnect();\n    };\n  }, []);\n\n  return (\n    <div ref={elementRef}>\n      {children(isVisible)}\n    </div>\n  );\n}\n\n// Example Usage:\nfunction App() {\n  return (\n    <div>\n      <p style={{ height: '100vh', background: '#eee' }}>Scroll down to see the sensor!</p>\n      <VisibilitySensor>\n        {(isVisible) => (\n          <div style={{ padding: '20px', border: '1px solid black', marginBottom: '20px' }}>\n            <h2>Visibility Status: {isVisible ? 'Visible' : 'Not Visible'}</h2>\n            {isVisible && <p>You can see me now!</p>}\n          </div>\n        )}\n      </VisibilitySensor>\n      <p style={{ height: '100vh', background: '#eee' }}>Scroll further!</p>\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to implement the Render Props pattern using `children` as a function.",
            "Requires knowledge of `useState`, `useEffect`, `useRef` hooks.",
            "Demonstrates practical application of `IntersectionObserver`.",
            "Ensures correct cleanup for `useEffect`."
          ],
          "keyConcepts": [
            "Render Props",
            "IntersectionObserver",
            "React Hooks",
            "Refs",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct `children` as render prop implementation",
            "Accurate `IntersectionObserver` setup and cleanup",
            "Proper state management for `isVisible`",
            "Effective use of `useRef` for DOM element reference"
          ],
          "example": "The solution implements `VisibilitySensor` which uses a `ref` to attach an `IntersectionObserver`. The observer updates the `isVisible` state. The component then calls `children(isVisible)`, passing the visibility status to its consumer. The `useEffect` hook ensures the observer is set up and cleaned up correctly.",
          "tags": [
            "Render Props",
            "React",
            "Coding Challenge",
            "IntersectionObserver",
            "Advanced"
          ],
          "prerequisites": [
            "theory_render_props",
            "react_hooks_useState_useEffect_useRef",
            "web_apis_intersection_observer"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_props_4",
          "topic": "Render Props vs. HOCs for Logic Reuse",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the Render Props pattern with Higher-Order Components (HOCs) specifically for the purpose of sharing reusable component logic. Discuss when you might choose one over the other, considering their respective strengths and weaknesses.",
          "answer": "### Comparison of Render Props vs. HOCs for Logic Reuse:\n\n**Higher-Order Components (HOCs):**\n*   **Concept**: A function that takes a component and returns a new component (a wrapper).\n*   **Logic Sharing**: Injects props or modifies existing props to the wrapped component.\n*   **Pros**: \n    *   Can simplify components by abstracting away data fetching or complex prop transformations.\n    *   Useful for static enhancements that apply generally.\n*   **Cons**: \n    *   **Wrapper Hell**: Creates extra layers in the component tree, making debugging harder.\n    *   **Prop Collisions**: Risk of name clashes if HOCs and wrapped components use same prop names.\n    *   **Ref Forwarding**: Requires `React.forwardRef` to pass refs.\n    *   **Static Composition**: Logic is applied at definition time, less flexible for runtime variations.\n    *   **Indirect Props**: Consumer might not immediately know where props come from.\n\n**Render Props Pattern:**\n*   **Concept**: A component receives a function as a prop (e.g., `render` or `children`), which it calls to render its content, passing its internal state/data as arguments.\n*   **Logic Sharing**: Provides data/state directly to a function (the render prop) which then controls the rendering.\n*   **Pros**: \n    *   **Highly Flexible/Dynamic Composition**: The consumer has full control over *what* gets rendered with the shared logic/data, allowing for dynamic UI changes.\n    *   **Clear Prop Origin**: It's obvious where the data comes from (arguments to the render prop function).\n    *   **No Prop Collisions**: Data is passed as function arguments, avoiding name clashes.\n    *   **No Wrapper Hell (in tree)**: Doesn't add unnecessary nested components to the React DevTools tree for logic sharing.\n*   **Cons**: \n    *   **Nesting (Indentation) Hell**: Can lead to deeply nested JSX if many render props are used, impacting readability.\n    *   **Performance Concerns**: If the render prop function is defined inline, it can cause unnecessary re-renders of child components if not properly memoized.\n    *   **Less Intuitive for Beginners**: The concept of 'function as a prop' might require more explanation for new developers.\n\n### When to Choose Which:\n\n*   **Choose HOCs when:**\n    *   You are providing a generic, consistent behavior that wraps a component (e.g., `withAuthentication`, `withAnalytics`).\n    *   The enhancement is relatively static and doesn't require the consumer to dynamically change the UI structure based on the shared logic's state.\n    *   You are integrating with older React contexts or libraries that heavily use HOCs (e.g., older Redux `connect`).\n    *   You need to abstract away complex prop transformations.\n\n*   **Choose Render Props when:**\n    *   You need extreme flexibility in how the shared logic's data is consumed and rendered. The consumer needs full control over the UI.\n    *   You want to avoid prop collisions and deeply nested component trees in the DevTools.\n    *   The logic involves dynamic data or state (like mouse position, window size, network status) that directly influences how the UI should render.\n    *   You are building a reusable library component that exposes its internal state in a flexible way (e.g., `react-router`'s `Route` component using `children` prop in older versions).\n\n**Modern Context (React Hooks):**\nIt's important to note that React Hooks (`useState`, `useEffect`, `useContext`, custom hooks) have become the modern, preferred approach for sharing reusable logic in functional components, largely addressing the pain points of both HOCs and Render Props (like wrapper hell, prop collisions, and verbose nesting) by allowing direct access to stateful logic within the component itself. However, understanding HOCs and Render Props is crucial for legacy codebases and for understanding the evolution of React patterns.",
          "options": [],
          "analysisPoints": [
            "Thorough understanding of both patterns' mechanisms.",
            "Detailed articulation of their specific advantages and disadvantages.",
            "Insightful discussion of appropriate use cases for each.",
            "Awareness of modern alternatives (Hooks) and historical context."
          ],
          "keyConcepts": [
            "Render Props",
            "HOC",
            "Logic Reuse",
            "Composition",
            "Flexibility",
            "Debugging",
            "Performance"
          ],
          "evaluationCriteria": [
            "Depth and clarity of the comparison points",
            "Accuracy of pros and cons for each pattern",
            "Thoughtfulness of scenario-based preferences",
            "Inclusion of modern context (Hooks)"
          ],
          "example": "",
          "tags": [
            "Render Props",
            "HOC",
            "Comparison",
            "Advanced",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_render_props",
            "theory_hoc",
            "react_hooks_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_props_5",
          "topic": "Render Props Performance",
          "level": "medium",
          "type": "mcq",
          "question": "When using the Render Props pattern, an inline function passed as the `render` prop can sometimes lead to unnecessary re-renders of the child component. Why does this happen, and what's a common React optimization technique to mitigate it?\n\n```javascript\n// Scenario:\n<DataFetcher\n  render={(data) => (\n    <DisplayComponent data={data} /> // This might re-render unnecessarily\n  )}\n/>\n\n// Assuming DisplayComponent is a functional component\n```",
          "answer": "Because the inline function creates a new function reference on every parent render, causing `DisplayComponent` to see a new prop even if `data` is the same. `React.memo` (or `useCallback` for the function itself) on `DisplayComponent` can prevent re-renders if its props haven't shallowly changed.",
          "options": [
            "Because the inline function creates a new function reference on every parent render, causing `DisplayComponent` to see a new prop even if `data` is the same. `React.memo` (or `useCallback` for the function itself) on `DisplayComponent` can prevent re-renders if its props haven't shallowly changed.",
            "Because the `render` prop is inherently slower due to function calls. Using a class component for `DisplayComponent` would solve this.",
            "It only happens if `data` itself is a new object on every render. `shouldComponentUpdate` on `DataFetcher` is needed.",
            "This is a misconception; React automatically optimizes inline functions for render props."
          ],
          "analysisPoints": [
            "Tests understanding of JavaScript reference equality.",
            "Connects function reference changes to React's re-render mechanism.",
            "Identifies `React.memo` (or `useCallback`) as the correct optimization.",
            "Dispels common myths or incorrect solutions."
          ],
          "keyConcepts": [
            "Render Props",
            "Performance Optimization",
            "React.memo",
            "useCallback",
            "Reference Equality",
            "Re-renders"
          ],
          "evaluationCriteria": [
            "Accurate explanation of the cause (new function reference)",
            "Correct identification of the mitigation technique",
            "Understanding of React's rendering lifecycle and optimizations"
          ],
          "example": "```typescript\nimport React, { useState, useEffect, memo, useCallback } from 'react';\n\n// Generic component using render props\nfunction DataFetcher({ render }) {\n  const [data, setData] = useState({ value: 'Initial' });\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // Simulate data changing, but sometimes to the same value\n      const newValue = Math.random() > 0.5 ? 'Updated' : 'Initial';\n      setData(prev => ({ ...prev, value: newValue }));\n    }, 1000);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return render(data);\n}\n\n// Wrapped component that should only re-render if its *actual data* changes\nconst DisplayComponent = memo(({ data }) => {\n  console.log('DisplayComponent re-rendered with data:', data.value);\n  return <div>Current Data: {data.value}</div>;\n});\n\n// Usage with memoized render prop function\nfunction App() {\n  // This useCallback ensures the render function itself is stable\n  const memoizedRenderProp = useCallback(\n    (data) => <DisplayComponent data={data} />,\n    [] // No dependencies, as DisplayComponent props only depend on `data` from DataFetcher\n  );\n\n  return (\n    <div>\n      <DataFetcher render={memoizedRenderProp} />\n    </div>\n  );\n}\n```\nThe `DisplayComponent` is wrapped with `React.memo`. If the `render` prop function were defined inline as `render={(data) => <DisplayComponent data={data} />}`, even if `data.value` remains 'Initial', `DisplayComponent` would re-render because the *function itself* (`(data) => ...`) is a new reference on every `DataFetcher` re-render. By using `useCallback` for the `render` prop function, we stabilize the function reference, allowing `React.memo` on `DisplayComponent` to effectively prevent unnecessary re-renders when `data` (specifically `data.value`) hasn't shallowly changed.",
          "tags": [
            "Render Props",
            "Performance",
            "React.memo",
            "useCallback",
            "Optimization"
          ],
          "prerequisites": [
            "theory_render_props",
            "react_hooks_useState_useEffect",
            "react_memo",
            "react_useCallback"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_hoc_auth_logger",
          "title": "Implement an Authentication and Logging HOC",
          "description": "\nImplement two Higher-Order Components (HOCs):\n\n1.  **`withAuth(WrappedComponent)`**: This HOC should check if a user is authenticated. It should receive a `isAuthenticated` boolean prop. If `isAuthenticated` is `false`, it should render a \"Please log in to view this content.\" message. Otherwise, it should render the `WrappedComponent` with all its original props (except `isAuthenticated`).\n2.  **`withLogger(WrappedComponent)`**: This HOC should log a message to the console every time the `WrappedComponent` mounts and unmounts. The message should include the `WrappedComponent`'s display name. Use `useEffect` for lifecycle logging within the HOC.\n\nThen, apply both HOCs to a simple `Dashboard` component. The `Dashboard` component should just display \"Welcome to the Dashboard!\".\n\n**Requirements:**\n-   `withAuth` consumes `isAuthenticated` prop.\n-   `withLogger` logs mount/unmount events.\n-   Both HOCs correctly forward other props.\n-   Set `displayName` for wrapped components for better debugging.\n-   Demonstrate nested HOC usage on the `Dashboard` component.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// 1. Implement withAuth HOC here\nconst withAuth = (WrappedComponent) => {\n  // Your implementation\n};\n\n// 2. Implement withLogger HOC here\nconst withLogger = (WrappedComponent) => {\n  // Your implementation\n};\n\n// Simple Dashboard component\nconst Dashboard = ({ userName }) => {\n  return <div>Welcome to the Dashboard, {userName}!</div>;\n};\n\n// Apply HOCs here and render in App\nfunction App() {\n  const [loggedIn, setLoggedIn] = useState(false);\n  const [showDashboard, setShowDashboard] = useState(false);\n\n  // Your component usage here\n  // const AuthLoggedDashboard = ???\n\n  return (\n    <div>\n      <h1>HOC Demo</h1>\n      <button onClick={() => setLoggedIn(!loggedIn)}>\n        {loggedIn ? 'Log Out' : 'Log In'}\n      </button>\n      <button onClick={() => setShowDashboard(!showDashboard)}>\n        {showDashboard ? 'Hide Dashboard' : 'Show Dashboard'}\n      </button>\n\n      {showDashboard && (\n        <div>\n          {/* Render your HOC-wrapped component here */}\n          {/* Example: <AuthLoggedDashboard isAuthenticated={loggedIn} userName=\"Guest\" /> */}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// 1. Implement withAuth HOC here\nconst withAuth = (WrappedComponent) => {\n  const WithAuthComponent = ({ isAuthenticated, ...restProps }) => {\n    if (!isAuthenticated) {\n      return <div>Please log in to view this content.</div>;\n    }\n    return <WrappedComponent {...restProps} />;\n  };\n  WithAuthComponent.displayName = `withAuth(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithAuthComponent;\n};\n\n// 2. Implement withLogger HOC here\nconst withLogger = (WrappedComponent) => {\n  const WithLoggerComponent = (props) => {\n    useEffect(() => {\n      const componentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n      console.log(`${componentName} mounted.`);\n      return () => {\n        console.log(`${componentName} unmounted.`);\n      };\n    }, []);\n\n    return <WrappedComponent {...props} />;\n  };\n  WithLoggerComponent.displayName = `withLogger(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithLoggerComponent;\n};\n\n// Simple Dashboard component\nconst Dashboard = ({ userName }) => {\n  return <div>Welcome to the Dashboard, {userName}!</div>;\n};\n\n// Apply HOCs here and render in App\nconst AuthLoggedDashboard = withAuth(withLogger(Dashboard));\n\nfunction App() {\n  const [loggedIn, setLoggedIn] = useState(false);\n  const [showDashboard, setShowDashboard] = useState(false);\n\n  return (\n    <div>\n      <h1>HOC Demo</h1>\n      <button onClick={() => setLoggedIn(!loggedIn)}>\n        {loggedIn ? 'Log Out' : 'Log In'}\n      </button>\n      <button onClick={() => setShowDashboard(!showDashboard)}>\n        {showDashboard ? 'Hide Dashboard' : 'Show Dashboard'}\n      </button>\n\n      {showDashboard && (\n        <div>\n          <AuthLoggedDashboard isAuthenticated={loggedIn} userName=\"Guest\" />\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "testCases": [
            "Initially, when `showDashboard` is true and `loggedIn` is false, it should display 'Please log in to view this content.'.",
            "When `loggedIn` becomes true, it should display 'Welcome to the Dashboard, Guest!'.",
            "Check console logs: When dashboard mounts (showDashboard true, loggedIn true), 'Dashboard mounted.' should appear. When it unmounts (showDashboard false or loggedIn false), 'Dashboard unmounted.' should appear.",
            "Ensure `userName` prop is correctly passed to `Dashboard` component."
          ],
          "hints": [
            "Remember that a HOC returns a new component, which receives the props that would normally go to the original component.",
            "Use prop destructuring (`{ propName, ...restProps }`) to easily consume specific props and pass the rest.",
            "For `withLogger`, `useEffect` with an empty dependency array (`[]`) and a cleanup function (`return () => ...`) is perfect for mount/unmount logging.",
            "Don't forget to set `displayName` for the returned HOC component for better debugging."
          ],
          "tags": [
            "HOC",
            "React",
            "Authentication",
            "Logging",
            "Composition"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_hoc",
            "react_hooks_useState_useEffect",
            "react_components",
            "javascript_destructuring"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "cross_cutting_concerns",
            "component_lifecycle",
            "prop_drilling"
          ]
        },
        {
          "id": "task_input_specialization",
          "title": "Create Specialized Input Components",
          "description": "\nImplement a generic `TextInput` component that accepts standard HTML input attributes (`type`, `placeholder`, `value`, `onChange`, `className`, etc.). Then, using the Component Specialization pattern, create the following specialized components:\n\n1.  **`EmailInput`**: An input pre-configured for email addresses (`type=\"email\"`, `placeholder=\"Enter your email\"`).\n2.  **`NumberInput`**: An input pre-configured for numerical values (`type=\"number\"`, `placeholder=\"Enter a number\"`).\n3.  **`SearchInput`**: An input pre-configured for search queries (`type=\"search\"`, `placeholder=\"Search...\"`, and a default `aria-label=\"Search input\"`).\n\nAll specialized components should correctly forward any additional props passed to them to the underlying `TextInput` component.\n\n**Requirements:**\n-   Generic `TextInput` is flexible.\n-   Specialized components use `TextInput` internally.\n-   Correctly set fixed props for each specialized component.\n-   All other props are forwarded using `...props`.\n-   Demonstrate usage of all components in an `App` component.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Generic TextInput component\nfunction TextInput({ type = 'text', className = '', ...rest }) {\n  return (\n    <input \n      type={type} \n      className={`border p-2 rounded ${className}`}\n      {...rest} \n    />\n  );\n}\n\n// 1. Implement EmailInput here\n// function EmailInput(props) { /* ... */ }\n\n// 2. Implement NumberInput here\n// function NumberInput(props) { /* ... */ }\n\n// 3. Implement SearchInput here\n// function SearchInput(props) { /* ... */ }\n\nfunction App() {\n  const [email, setEmail] = useState('');\n  const [quantity, setQuantity] = useState(0);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div className=\"p-4 space-y-4\">\n      <h2>Input Specialization Demo</h2>\n\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        {/* Use EmailInput here */}\n        {/* <EmailInput id=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} /> */}\n        <p>Value: {email}</p>\n      </div>\n\n      <div>\n        <label htmlFor=\"quantity\">Quantity:</label>\n        {/* Use NumberInput here */}\n        {/* <NumberInput id=\"quantity\" value={quantity} onChange={(e) => setQuantity(Number(e.target.value))} min=\"0\" max=\"100\" /> */}\n        <p>Value: {quantity}</p>\n      </div>\n\n      <div>\n        <label htmlFor=\"search\">Search:</label>\n        {/* Use SearchInput here */}\n        {/* <SearchInput id=\"search\" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} /> */}\n        <p>Value: {searchQuery}</p>\n      </div>\n\n      <div>\n        <h3>Generic Input Usage:</h3>\n        <TextInput placeholder=\"Any text\" />\n      </div>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Generic TextInput component\nfunction TextInput({ type = 'text', className = '', ...rest }) {\n  return (\n    <input \n      type={type} \n      className={`border p-2 rounded ${className}`}\n      {...rest} \n    />\n  );\n}\n\n// 1. Implement EmailInput here\nfunction EmailInput(props) {\n  return <TextInput type=\"email\" placeholder=\"Enter your email\" {...props} />;\n}\n\n// 2. Implement NumberInput here\nfunction NumberInput(props) {\n  return <TextInput type=\"number\" placeholder=\"Enter a number\" {...props} />;\n}\n\n// 3. Implement SearchInput here\nfunction SearchInput(props) {\n  return <TextInput type=\"search\" placeholder=\"Search...\" aria-label=\"Search input\" {...props} />;\n}\n\nfunction App() {\n  const [email, setEmail] = useState('');\n  const [quantity, setQuantity] = useState(0);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div className=\"p-4 space-y-4\">\n      <h2>Input Specialization Demo</h2>\n\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <EmailInput id=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} />\n        <p>Value: {email}</p>\n      </div>\n\n      <div>\n        <label htmlFor=\"quantity\">Quantity:</label>\n        <NumberInput id=\"quantity\" value={quantity} onChange={(e) => setQuantity(Number(e.target.value))} min=\"0\" max=\"100\" />\n        <p>Value: {quantity}</p>\n      </div>\n\n      <div>\n        <label htmlFor=\"search\">Search:</label>\n        <SearchInput id=\"search\" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} />\n        <p>Value: {searchQuery}</p>\n      </div>\n\n      <div>\n        <h3>Generic Input Usage:</h3>\n        <TextInput placeholder=\"Any text\" />\n      </div>\n    </div>\n  );\n}\n",
          "testCases": [
            "Verify `EmailInput`'s `type` attribute is 'email' in the DOM.",
            "Verify `NumberInput`'s `type` attribute is 'number' in the DOM.",
            "Verify `SearchInput`'s `type` attribute is 'search' and `aria-label` is 'Search input' in the DOM.",
            "Ensure `EmailInput` correctly updates `email` state on change.",
            "Ensure `NumberInput` correctly updates `quantity` state on change and respects `min`/`max` (if browser enforces).",
            "Ensure `SearchInput` correctly updates `searchQuery` state on change.",
            "Confirm that additional props like `id`, `value`, `onChange`, `min`, `max` are correctly passed through to the underlying `input` element for all specialized components."
          ],
          "hints": [
            "The specialized components should be simple functional components.",
            "Remember to pass all incoming props to the generic `TextInput` using the spread operator (`{...props}`).",
            "The fixed props (like `type` or `placeholder`) should be explicitly set on the `TextInput` when rendered by the specialized component."
          ],
          "tags": [
            "Component Specialization",
            "React",
            "Forms",
            "Reusability",
            "UI Components"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_component_specialization",
            "react_components",
            "react_props"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "DRY_principle",
            "design_systems",
            "semantic_html"
          ]
        },
        {
          "id": "task_theme_switcher",
          "title": "Build a Theme Switcher with Render Props",
          "description": "\nCreate a `ThemeContext` component using the Render Props pattern. This component should manage the current theme (e.g., 'light' or 'dark') and provide a way to toggle it.\n\n**Requirements:**\n1.  **`ThemeContext` Component**: \n    *   Manages a `theme` state ('light' initially).\n    *   Provides a `toggleTheme` function that switches between 'light' and 'dark'.\n    *   Uses the `children` prop as a render prop. The `children` function should receive an object `{ theme, toggleTheme }` as arguments.\n2.  **Usage in `App`**: \n    *   Wrap your main application content with `ThemeContext`.\n    *   Inside the `ThemeContext`'s `children` function, render a `ThemeDisplay` component and a `ThemeToggleButton` component.\n3.  **`ThemeDisplay` Component**: Displays the current `theme` (e.g., \"Current Theme: Light\"). Its styling should reflect the theme (e.g., light background for light theme, dark for dark).\n4.  **`ThemeToggleButton` Component**: A button that calls `toggleTheme` when clicked.\n\nThis task demonstrates how `ThemeContext` encapsulates the theme logic, while `ThemeDisplay` and `ThemeToggleButton` are responsible for UI, receiving the necessary data/functions via render props.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// 1. Implement ThemeContext component here\n// function ThemeContext({ children }) {\n//   const [theme, setTheme] = useState('light');\n//   const toggleTheme = () => {\n//     setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n//   };\n//   return children({ theme, toggleTheme });\n// }\n\n// 2. Implement ThemeDisplay component here\n// function ThemeDisplay({ theme }) { /* ... */ }\n\n// 3. Implement ThemeToggleButton component here\n// function ThemeToggleButton({ toggleTheme }) { /* ... */ }\n\nfunction App() {\n  return (\n    // Use ThemeContext here\n    // <ThemeContext>\n    //   {({ theme, toggleTheme }) => (\n    //     <div style={{ \n    //       background: theme === 'light' ? '#fff' : '#333',\n    //       color: theme === 'light' ? '#333' : '#fff',\n    //       minHeight: '100vh',\n    //       padding: '20px'\n    //     }}>\n    //       <h1>Theme Switcher Demo</h1>\n    //       {/* Render ThemeDisplay and ThemeToggleButton here */}\n    //     </div>\n    //   )}\n    // </ThemeContext>\n    <div>\n        <p>Starter code for App component</p>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// 1. Implement ThemeContext component here\nfunction ThemeContext({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  // children is the render prop function\n  return children({ theme, toggleTheme });\n}\n\n// 2. Implement ThemeDisplay component here\nfunction ThemeDisplay({ theme }) {\n  const displayStyle = {\n    padding: '10px',\n    border: '1px solid',\n    borderColor: theme === 'light' ? '#ccc' : '#666',\n    background: theme === 'light' ? '#f0f0f0' : '#444',\n    color: theme === 'light' ? '#333' : '#eee',\n    marginBottom: '10px'\n  };\n\n  return (\n    <div style={displayStyle}>\n      <h2>Current Theme: {theme.charAt(0).toUpperCase() + theme.slice(1)}</h2>\n      <p>This component's style reflects the current theme.</p>\n    </div>\n  );\n}\n\n// 3. Implement ThemeToggleButton component here\nfunction ThemeToggleButton({ toggleTheme }) {\n  return (\n    <button \n      onClick={toggleTheme} \n      style={{\n        padding: '10px 20px',\n        fontSize: '16px',\n        cursor: 'pointer',\n        background: '#007bff',\n        color: 'white',\n        border: 'none',\n        borderRadius: '5px'\n      }}\n    >\n      Toggle Theme\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <ThemeContext>\n      {({ theme, toggleTheme }) => (\n        <div style={{\n          background: theme === 'light' ? '#fff' : '#222',\n          color: theme === 'light' ? '#333' : '#fff',\n          minHeight: '100vh',\n          padding: '20px',\n          fontFamily: 'Arial, sans-serif'\n        }}>\n          <h1>Theme Switcher Demo</h1>\n          <ThemeDisplay theme={theme} />\n          <ThemeToggleButton toggleTheme={toggleTheme} />\n          <p style={{ marginTop: '20px' }}>\n            The background and text color of this page change with the theme.\n          </p>\n        </div>\n      )}\n    </ThemeContext>\n  );\n}\n",
          "testCases": [
            "Initial render: Background should be light, text dark. Theme display should show 'Current Theme: Light'.",
            "Click 'Toggle Theme' button: Background should switch to dark, text to light. Theme display should show 'Current Theme: Dark'.",
            "Click 'Toggle Theme' again: Should switch back to light theme.",
            "Ensure `ThemeDisplay` and `ThemeToggleButton` receive correct `theme` and `toggleTheme` props from the `ThemeContext`'s render prop."
          ],
          "hints": [
            "The `ThemeContext` component needs `useState` to manage the `theme`.",
            "The `children` prop in `ThemeContext` will be a function. Remember to call it and pass the `theme` and `toggleTheme` values.",
            "You can use inline styles or simple class names to make `ThemeDisplay` visually change with the theme.",
            "Ensure the `toggleTheme` function correctly flips between 'light' and 'dark'."
          ],
          "tags": [
            "Render Props",
            "React",
            "State Management",
            "UI/UX",
            "Theming"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_render_props",
            "react_hooks_useState",
            "react_components"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "context_api",
            "separation_of_concerns",
            "dynamic_ui"
          ]
        }
      ]
    }
  },
  {
    "id": "8267bb57-6695-4b81-a0bd-f1b1d911fd37",
    "startLine": 3100,
    "endLine": 3199,
    "processedDate": "2025-06-17T08:38:18.279Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_render_props",
          "title": "Render Props Pattern in React",
          "content": "The Render Props pattern in React refers to a technique where a component's `props` include a function that returns a React element. This function allows the component to share code (behavior or state) with other components without explicitly rendering anything itself. Instead, it delegates the rendering responsibility to the consumer component by calling the provided render prop with its internal state or logic.\n\nThis pattern is particularly useful for sharing non-visual logic, such as data fetching, mouse tracking, or form state management, across multiple components in a reusable manner. The core idea is that the 'render prop' (often named `render` or `children`) is a function that the component calls to determine what to render, passing along whatever data or state it needs to share.\n\n## Key Concepts\n*   **Render Prop**: A prop whose value is a function that a component calls to render something. It typically receives the component's internal state or computed values as arguments.\n*   **`children` as a Function**: A common variation where the `children` prop itself is used as the render prop. This leverages the special `children` prop, which can be any valid React node, including a function.\n*   **Sharing Behavior**: The component implementing the render prop pattern encapsulates specific behavior (e.g., mouse position tracking, data loading) and exposes it via the render function, allowing other components to consume this behavior and render their UI based on it.\n\n## Benefits of Render Props\n1.  **Composition**: Facilitates easy composition of behaviors without modifying existing components. You can wrap components with different render prop components to add new functionalities.\n2.  **Reusability**: Shared functionality (like stateful logic) can be used by multiple disparate components across your application, promoting a DRY (Don't Repeat Yourself) principle.\n3.  **Separation of Concerns**: Clearly separates the logic (what to do) from the UI (what to render). The component with the render prop handles the logic, while the consumer handles the rendering.\n4.  **Flexible Rendering**: Consumers decide exactly what gets rendered based on the data provided by the render prop component. This offers unparalleled flexibility compared to fixed UI components.\n5.  **No HOC Wrapper Hell**: Avoids the issue of deeply nested Higher-Order Components (HOCs) that can make debugging and understanding the component tree difficult (often referred to as 'wrapper hell' or 'pyramid of doom'). Render props typically result in a flatter component tree.\n\n## When to Use Render Props\n*   When you need to share non-visual behavior or state between components (e.g., mouse position, network status, authentication state).\n*   When you want to avoid duplicate code across components that need the same logic.\n*   When you need more flexibility in rendering the UI than a Higher-Order Component might provide, as the render prop offers direct control over the JSX output.\n\n## Relationship with Hooks\nWhile Hooks (introduced in React 16.8) have become the primary way to reuse stateful logic and reduce boilerplate, Render Props remain a valid and sometimes preferred pattern for specific scenarios, especially in older codebases or when working with libraries that still heavily rely on them. Hooks often provide a more concise and readable way to achieve similar results by extracting logic into custom hooks, but Render Props offer explicit JSX-level composition.",
          "examples": [
            {
              "id": "example_render_props_1",
              "title": "Mouse Tracking with Render Prop (named prop)",
              "code": "import React from 'react';\n\nclass MouseTracker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { x: 0, y: 0 };\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    // The `render` prop is a function that receives the state\n    return (\n      <div style={{ height: '100vh', border: '1px solid black' }} onMouseMove={this.handleMouseMove}>\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n\n// Usage of MouseTracker with a named `render` prop\nfunction App() {\n  return (\n    <div>\n      <h1>Move the mouse around!</h1>\n      <MouseTracker\n        render={({ x, y }) => (\n          <p>Current mouse position: ({x}, {y})</p>\n        )}\n      />\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the `MouseTracker` component using a named `render` prop. The `MouseTracker` component manages the mouse position state (`x`, `y`) internally. Instead of rendering a fixed UI, it calls `this.props.render(this.state)`, passing its current mouse coordinates to the function provided by its parent. The `App` component then defines how to render the mouse position using an arrow function passed to the `render` prop, making the `MouseTracker` reusable for displaying the mouse position in various ways.",
              "language": "javascript"
            },
            {
              "id": "example_render_props_2",
              "title": "Mouse Tracking with Render Prop (children as function)",
              "code": "import React from 'react';\n\nclass MouseTracker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { x: 0, y: 0 };\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n  }\n  \n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  \n  render() {\n    return (\n      <div style={{ height: '100vh', border: '1px solid blue' }} onMouseMove={this.handleMouseMove}>\n        {/* Using children as a function instead of a custom named prop */}\n        {this.props.children(this.state)}\n      </div>\n    );\n  }\n}\n\n// Usage of MouseTracker with children as a function\nfunction App() {\n  return (\n    <div>\n      <h1>Move the mouse around (children prop)!</h1>\n      <MouseTracker>\n        {({ x, y }) => (\n          <p>Current position: ({x}, {y})</p>\n        )}\n      </MouseTracker>\n    </div>\n  );\n}",
              "explanation": "This example shows the `MouseTracker` component using the `children` prop as a function, which is a common and idiomatic way to implement the Render Props pattern. The `MouseTracker` still manages the state, but instead of calling `this.props.render`, it calls `this.props.children(this.state)`. The consumer component then places the rendering logic directly inside the `MouseTracker`'s JSX tags, defining a function that receives the mouse coordinates. This approach often leads to cleaner and more readable JSX, especially when the render logic is simple.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_render_props_1",
            "question_render_props_2",
            "question_render_props_3",
            "question_render_props_4",
            "question_render_props_5",
            "question_render_props_6",
            "question_render_props_7",
            "question_render_props_8"
          ],
          "relatedTasks": [
            "task_render_props_data_fetcher"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Render Props",
            "Composition",
            "Reusability",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components",
            "React_State_and_Props",
            "Functional_Programming_Concepts"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced_React_Patterns",
            "Reusable_Logic_Components"
          ]
        },
        {
          "id": "theory_compound_components",
          "title": "Compound Components Pattern in React",
          "content": "The Compound Components pattern is a powerful React design pattern where multiple components work together to form a single, cohesive unit, sharing implicit state and behavior. It provides an expressive, declarative, and flexible API for complex component systems, such as `Tabs`, `Accordion`, `Select`, or `Dropdown`.\n\nInstead of managing all internal state and rendering logic within a single, monolithic component, the pattern breaks down the UI into smaller, specialized components that are used together. These sub-components are often rendered as children of a parent component and communicate through shared context.\n\n## Key Concepts\n*   **Shared Implicit State**: The parent component (e.g., `Tabs`) manages the overall state (e.g., `activeIndex`) and provides it to its nested children. This state is 'implicit' because children don't receive it directly via props from the parent; instead, they consume it from a shared context.\n*   **React Context API**: The `React.createContext` and `useContext` hooks are the primary tools for implementing shared implicit state in modern React applications. The parent component provides a context value, and child components consume it.\n*   **Declarative API**: The pattern results in a highly declarative API where the structure of the UI is clear from the JSX. For example, `<Tabs><Tabs.TabList>...</Tabs.TabList></Tabs>` clearly indicates the relationship between components.\n*   **Encapsulation**: While flexible, the pattern maintains encapsulation. The internal state management (e.g., how `activeIndex` changes) is hidden within the main `Tabs` component, and sub-components only interact with the provided context.\n*   **Flexible Composition**: Users of the compound component system can arrange the sub-components in various ways, add custom styling, or inject other components between them, without losing the shared behavior.\n\n## Benefits of Compound Components\n1.  **Expressive and Declarative API**: The way components are used in JSX (`<Tabs.TabList>`, `<Tabs.Tab>`) makes the structure and intent of the UI very clear and readable.\n2.  **Flexible Component Composition**: Allows consumers to arrange and style sub-components freely, enabling highly customizable layouts without resorting to prop drilling or complex prop configurations.\n3.  **Encapsulation of State Logic**: The shared state and its management logic are encapsulated within the main parent component (e.g., `Tabs`), keeping the sub-components simple and focused on their rendering responsibilities.\n4.  **Reduced Prop Drilling**: By using `React.Context`, the pattern avoids passing props down multiple levels of the component tree, making the code cleaner and easier to maintain.\n5.  **Improved Readability and Maintainability**: Breaking down complex UI into smaller, focused components improves code organization and makes it easier to understand, debug, and extend.\n\n## When to Use Compound Components\n*   When building complex UI widgets that consist of multiple related parts that need to share state and behavior (e.g., `Tabs`, `Accordion`, `Dropdown`, `Modal` with `Header`, `Body`, `Footer`).\n*   When you want to provide a highly declarative and flexible API for your components.\n*   When you need to share state implicitly among children without passing props manually through every level of the component tree.",
          "examples": [
            {
              "id": "example_compound_components_1",
              "title": "Tabs Component using Compound Components Pattern",
              "code": "import React, { createContext, useContext, useState } from 'react';\n\n// Create context for the Tabs component\nconst TabsContext = createContext(null);\n\n// Main Tabs component that manages state for all sub-components\nfunction Tabs({ children, defaultActiveIndex = 0 }) {\n  const [activeIndex, setActiveIndex] = useState(defaultActiveIndex);\n  \n  // Provide shared state to all children via context\n  return (\n    <TabsContext.Provider value={{ activeIndex, setActiveIndex }}>\n      <div className=\"tabs\">{children}</div>\n    </TabsContext.Provider>\n  );\n}\n\n// TabList component - container for Tab components\nTabs.TabList = function TabList({ children }) {\n  return <div className=\"tab-list\">{children}</div>;\n};\n\n// Individual Tab component\nTabs.Tab = function Tab({ children, index }) {\n  const { activeIndex, setActiveIndex } = useContext(TabsContext);\n  const isActive = activeIndex === index;\n  \n  return (\n    <div \n      className={`tab ${isActive ? 'active' : ''}`}\n      onClick={() => setActiveIndex(index)}\n      role=\"tab\"\n      aria-selected={isActive}\n      tabIndex={isActive ? 0 : -1}\n    >\n      {children}\n    </div>\n  );\n};\n\n// TabPanels component - container for TabPanel components\nTabs.TabPanels = function TabPanels({ children }) {\n  return <div className=\"tab-panels\">{children}</div>;\n};\n\n// Individual TabPanel component\nTabs.TabPanel = function TabPanel({ children, index }) {\n  const { activeIndex } = useContext(TabsContext);\n  const isActive = activeIndex === index;\n  \n  if (!isActive) return null; // Only render the active panel\n\n  return (\n    <div className=\"tab-panel\" role=\"tabpanel\" hidden={!isActive}>\n      {children}\n    </div>\n  );\n};\n\n// Example Usage:\nfunction App() {\n  return (\n    <Tabs defaultActiveIndex={0}>\n      <Tabs.TabList>\n        <Tabs.Tab index={0}>First Tab</Tabs.Tab>\n        <Tabs.Tab index={1}>Second Tab</Tabs.Tab>\n        <Tabs.Tab index={2}>Third Tab</Tabs.Tab>\n      </Tabs.TabList>\n      <Tabs.TabPanels>\n        <Tabs.TabPanel index={0}>Content for the first tab.</Tabs.TabPanel>\n        <Tabs.TabPanel index={1}>Content for the second tab.</Tabs.TabPanel>\n        <Tabs.TabPanel index={2}>Content for the third tab.</Tabs.TabPanel>\n      </Tabs.TabPanels>\n    </Tabs>\n  );\n}\n",
              "explanation": "This comprehensive example illustrates the Compound Components pattern using the React Context API to build a reusable `Tabs` component system. \n\n1.  **`TabsContext`**: A `React.createContext` instance is created to share `activeIndex` and `setActiveIndex` across all related components.\n2.  **`Tabs` (Parent)**: This component holds the `activeIndex` state and wraps its children with `TabsContext.Provider`, making the state and its setter available to all descendants.\n3.  **`Tabs.TabList`**: A simple container for `Tab` components.\n4.  **`Tabs.Tab`**: Each individual tab. It uses `useContext(TabsContext)` to read the `activeIndex` and `setActiveIndex`. It determines if it's active and sets itself active on click.\n5.  **`Tabs.TabPanels`**: A simple container for `TabPanel` components.\n6.  **`Tabs.TabPanel`**: Each individual content panel. It consumes `activeIndex` from the context and only renders its children if its `index` matches the `activeIndex`.\n\nThe consumer (e.g., `App` component) then composes these sub-components in a declarative way, and they automatically coordinate via the shared context.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_compound_components_1",
            "question_compound_components_2",
            "question_compound_components_3",
            "question_compound_components_4",
            "question_compound_components_5",
            "question_compound_components_6",
            "question_compound_components_7"
          ],
          "relatedTasks": [
            "task_compound_components_accordion"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Compound Components",
            "Context API",
            "Composition",
            "Encapsulation"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components",
            "React_Hooks",
            "React_Context_API",
            "Component_Composition"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced_React_Patterns",
            "Reusable_UI_Libraries",
            "Complex_Component_Design"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_render_props_1",
          "topic": "Render Props Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core idea behind the 'Render Props' pattern in React?",
          "answer": "The core idea is to share code (behavior or state) between React components using a prop whose value is a function that returns a React element.",
          "analysisPoints": [
            "Identifies the purpose of the pattern (sharing code).",
            "Recognizes the mechanism (prop as a function).",
            "Understands the output (returns a React element)."
          ],
          "keyConcepts": [
            "Render Props Definition",
            "Code Reusability"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles"
          ],
          "example": "A `MouseTracker` component passing `x, y` coordinates via a `render` prop function to a consumer component.",
          "tags": [
            "Render Props",
            "Definition",
            "Basics"
          ],
          "prerequisites": [
            "React_Props"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_props_2",
          "topic": "Render Props Implementation",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `DataProvider` component:\n\n```jsx\nclass DataProvider extends React.Component {\n  state = { data: [] };\n\n  componentDidMount() {\n    // Simulate data fetching\n    setTimeout(() => {\n      this.setState({ data: ['item1', 'item2', 'item3'] });\n    }, 1000);\n  }\n\n  render() {\n    // Which of the following best utilizes the render prop pattern?\n    // A. return <div>{this.props.children}</div>;\n    // B. return <div>{this.props.render()}</div>;\n    // C. return <div>{this.props.render(this.state.data)}</div>;\n    // D. return <div>{this.props.data(this.state.data)}</div>;\n  }\n}\n```\n\nWhich line inside the `render` method correctly implements the Render Props pattern to pass the `data` state to its consumer?",
          "answer": "C. return <div>{this.props.render(this.state.data)}</div>;",
          "options": [
            "A. return <div>{this.props.children}</div>;",
            "B. return <div>{this.props.render()}</div>;",
            "C. return <div>{this.props.render(this.state.data)}</div>;",
            "D. return <div>{this.props.data(this.state.data)}</div>;"
          ],
          "analysisPoints": [
            "Understands that the render prop is a function.",
            "Recognizes that the render prop function needs to be *called*.",
            "Identifies that the internal state/data should be *passed as an argument* to the render prop function.",
            "Distinguishes between a simple `children` prop and `children` as a function."
          ],
          "keyConcepts": [
            "Render Props Implementation",
            "Props as Functions",
            "State Sharing"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between similar concepts",
            "Application of best practices"
          ],
          "example": "Option C correctly demonstrates passing the component's internal state (`this.state.data`) as an argument to the function provided via the `render` prop. Options A and B either don't treat `children` as a function or don't pass data. Option D uses a non-standard prop name for a render prop and assumes it's a function.",
          "tags": [
            "Render Props",
            "Implementation",
            "MCQ",
            "State"
          ],
          "prerequisites": [
            "React_Components",
            "React_State_and_Props"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_props_3",
          "topic": "Render Props Benefits",
          "level": "medium",
          "type": "open",
          "question": "Explain at least three key benefits of using the Render Props pattern in React development.",
          "answer": "Three key benefits of using the Render Props pattern are:\n\n1.  **Reusability**: It allows developers to encapsulate and reuse stateful logic or behavior (e.g., mouse tracking, data fetching) across multiple components without duplicating code. The render prop component handles the logic, while different consumer components can use that logic to render diverse UIs.\n2.  **Composition and Flexibility**: It makes it very easy to compose different behaviors. A component can consume data from multiple render prop components, or a render prop component can be used in various parts of the application with different rendering outcomes. The consumer has full control over what to render and how to render it, based on the data provided by the render prop.\n3.  **Separation of Concerns**: It cleanly separates the 'what to do' (the logic/behavior within the render prop component) from the 'how to render' (the UI logic provided by the consumer). This improves code organization, readability, and maintainability.",
          "analysisPoints": [
            "Identifies core benefits like Reusability, Composition, and Separation of Concerns.",
            "Provides clear explanations for each benefit.",
            "Demonstrates understanding of why these benefits are important in React development."
          ],
          "keyConcepts": [
            "Render Props Benefits",
            "Reusability",
            "Composition",
            "Separation of Concerns"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to explain concepts clearly"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "Benefits",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_Patterns"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_props_4",
          "topic": "Render Props vs. HOCs",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast Render Props with Higher-Order Components (HOCs) in React. When might you prefer one over the other?",
          "answer": "Both Render Props and Higher-Order Components (HOCs) are patterns in React for code reuse and sharing stateful logic. However, they achieve this in different ways and have distinct advantages and disadvantages.\n\n**Render Props:**\n*   **Mechanism**: A component receives a function via a prop (e.g., `render` or `children`), and this function is called inside the component's `render` method, passing the internal state/logic as arguments.\n*   **Composition**: Achieved at the JSX level, often leading to a flatter component tree. Easier to see data flow.\n*   **Debugging**: Generally easier to debug as the component tree is more explicit and props are passed directly.\n*   **Flexibility**: High flexibility because the consumer directly defines the rendering logic.\n*   **Limitations**: Can sometimes lead to deeply nested JSX if multiple render prop components are used (though less problematic than HOC 'wrapper hell').\n\n**Higher-Order Components (HOCs):**\n*   **Mechanism**: A function that takes a component as an argument and returns a new component with enhanced props or behavior.\n*   **Composition**: Achieved at component definition time. Can lead to a deeply nested component tree (wrapper hell) in React DevTools.\n*   **Debugging**: Can be harder to debug due to implicit prop passing and the wrapped component's name not always being clear in DevTools.\n*   **Flexibility**: Less flexible in terms of rendering control compared to Render Props, as the HOC dictates the structure of the enhanced component.\n*   **Limitations**: Name collisions for props, 'wrapper hell', and difficulty in explicitly seeing the source of props.\n\n**When to prefer one over the other:**\n*   **Prefer Render Props when**: You need maximum flexibility in rendering, want to avoid deeply nested component trees in DevTools, or when the shared logic primarily provides data or handlers that dictate *how* to render a part of the UI. It's often clearer for component users to see what data they're receiving.\n*   **Prefer HOCs when**: You want to inject common cross-cutting concerns (like authentication, analytics, or global state) into many components without modifying their render logic, or when you're enhancing a component's capabilities without changing its fundamental rendering. HOCs can be cleaner for truly generic enhancements that don't involve the consumer's rendering choices.\n\nWith the advent of **React Hooks**, many use cases for both Render Props and HOCs can now be handled more cleanly and concisely using custom hooks, which often provide the best of both worlds.",
          "analysisPoints": [
            "Clearly defines both patterns.",
            "Highlights key differences in mechanism, composition, and debugging.",
            "Provides specific scenarios for preference.",
            "Mentions the impact of Hooks as a modern alternative."
          ],
          "keyConcepts": [
            "Render Props",
            "Higher-Order Components",
            "Pattern Comparison",
            "Code Reusability",
            "React Hooks"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between similar concepts",
            "Application of best practices",
            "Encourages critical thinking"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "HOCs",
            "Comparison",
            "Advanced",
            "Architecture"
          ],
          "prerequisites": [
            "React_Patterns",
            "React_Hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_props_5",
          "topic": "Render Props `children` vs. named prop",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the common convention for naming the 'render prop' function, and what is an alternative?",
          "answer": "The common convention is to use a prop named `render`, like `this.props.render(data)`. An equally common and often more idiomatic alternative is to use the `children` prop as a function, like `this.props.children(data)`.",
          "analysisPoints": [
            "Identifies `render` as a common name.",
            "Identifies `children` as a function as an alternative.",
            "Shows understanding of the flexibility in naming."
          ],
          "keyConcepts": [
            "Render Props Naming",
            "Children Prop"
          ],
          "evaluationCriteria": [
            "Quick recall/memory-based learning"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "Convention",
            "Basics"
          ],
          "prerequisites": [
            "React_Props"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_props_6",
          "topic": "Render Props and Performance",
          "level": "medium",
          "type": "open",
          "question": "When using Render Props, it's possible to encounter performance issues related to unnecessary re-renders. Explain why this might happen and how you would mitigate it.",
          "answer": "Performance issues with Render Props often arise because if the render prop function is defined inline in the consumer component's `render` method (e.g., `<MouseTracker render={({x,y}) => <p>{x},{y}</p>}/>`), a new function instance is created on every render of the consumer component. When this new function is passed as a prop to the `MouseTracker` (or similar render prop component), it will cause `MouseTracker` to re-render, even if its own internal state hasn't changed, because `props.render` is a new reference.\n\n**Mitigation Strategies:**\n\n1.  **Use `React.PureComponent` or `React.memo`**: The render prop component itself (e.g., `MouseTracker`) should be a `PureComponent` (for class components) or wrapped with `React.memo` (for functional components). This will prevent it from re-rendering unless its props (including the render prop function) or state actually change. However, this alone doesn't solve the issue if the inline function *itself* is changing.\n\n2.  **Define the render prop function outside the `render` method**: For class components, define the render prop function as an instance method. For functional components, use `useCallback` to memoize the function. This ensures the function reference remains stable across renders unless its dependencies change.\n\n    ```jsx\n    // Class Component Mitigation\n    class App extends React.Component {\n      renderMousePosition = ({ x, y }) => <p>Position: {x}, {y}</p>;\n\n      render() {\n        return <MouseTracker render={this.renderMousePosition} />;\n      }\n    }\n\n    // Functional Component Mitigation with useCallback\n    const App = () => {\n      const renderMousePosition = useCallback(({ x, y }) => <p>Position: {x}, {y}</p>, []);\n      return <MouseTracker render={renderMousePosition} />;\n    };\n    ```\n\nBy ensuring the render prop function's reference is stable, you prevent unnecessary re-renders of the render prop component when only the consumer component re-renders.",
          "analysisPoints": [
            "Identifies the root cause: inline function creation leading to new prop reference.",
            "Suggests `PureComponent` / `memo` for the render prop component.",
            "Provides correct mitigation for the inline function issue (instance method or `useCallback`).",
            "Includes code examples for mitigation."
          ],
          "keyConcepts": [
            "Render Props",
            "Performance Optimization",
            "Re-renders",
            "PureComponent",
            "React.memo",
            "useCallback"
          ],
          "evaluationCriteria": [
            "Understanding of common pitfalls",
            "Ability to propose practical solutions",
            "Application of best practices"
          ],
          "example": "```jsx\n// Example of the problem:\nfunction AppWithIssue() {\n  return (\n    <MouseTracker render={({ x, y }) => <p>Current: {x}, {y}</p>} />\n    // This inline function creates a new reference on every render of AppWithIssue\n  );\n}\n```",
          "tags": [
            "Render Props",
            "Performance",
            "Optimization",
            "Advanced"
          ],
          "prerequisites": [
            "React_Lifecycle",
            "React_Hooks_Performance",
            "Component_Re-rendering"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_props_7",
          "topic": "Render Props Use Case",
          "level": "easy",
          "type": "flashcard",
          "question": "Name one common use case where the Render Props pattern is beneficial.",
          "answer": "Sharing non-visual logic or state, such as mouse position tracking, keyboard input tracking, network status monitoring, or data fetching logic, between multiple components.",
          "analysisPoints": [
            "Provides a relevant and common use case."
          ],
          "keyConcepts": [
            "Render Props Use Cases",
            "Shared Logic"
          ],
          "evaluationCriteria": [
            "Quick recall/memory-based learning"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "Use Case",
            "Basics"
          ],
          "prerequisites": [
            "React_Patterns"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_props_8",
          "topic": "Render Props and Composition",
          "level": "medium",
          "type": "code",
          "question": "Implement a `Toggle` component using the Render Props pattern (specifically, using `children` as a function). The `Toggle` component should manage a boolean `on` state and provide a `toggle` function to its consumer. The consumer should then render a button that displays 'On' or 'Off' based on the `on` state, and toggles it when clicked.",
          "answer": "```jsx\nimport React, { useState } from 'react';\n\nfunction Toggle({ children }) {\n  const [on, setOn] = useState(false);\n\n  const toggle = () => setOn(prevOn => !prevOn);\n\n  // children is expected to be a function that receives { on, toggle }\n  return children({ on, toggle });\n}\n\n// Example Usage:\nfunction App() {\n  return (\n    <div>\n      <h1>Render Props Toggle Example</h1>\n      <Toggle>\n        {({ on, toggle }) => (\n          <button onClick={toggle}>\n            {on ? 'On' : 'Off'}\n          </button>\n        )}\n      </Toggle>\n      <Toggle>\n        {({ on, toggle }) => (\n          <label style={{ cursor: 'pointer', display: 'block', marginTop: '10px' }}>\n            <input type=\"checkbox\" checked={on} onChange={toggle} /> \n            Toggle Switch: {on ? 'Active' : 'Inactive'}\n          </label>\n        )}\n      </Toggle>\n    </div>\n  );\n}\n\n// To run this example, you would typically render the App component:\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implements the `Toggle` component with state and a toggle function.",
            "Uses `children` as a function to pass `on` and `toggle` to the consumer.",
            "Demonstrates a consumer using the provided `on` and `toggle` values to render UI.",
            "Shows understanding of state management within a render prop component."
          ],
          "keyConcepts": [
            "Render Props",
            "Children as Function",
            "State Management",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to implement the pattern",
            "Correct state management",
            "Correct use of `children` prop"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "Code Challenge",
            "Implementation",
            "Hooks"
          ],
          "prerequisites": [
            "React_Hooks",
            "React_Components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_1",
          "topic": "Compound Components Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary characteristic of the Compound Components pattern in React?",
          "answer": "It's a pattern where multiple components are designed to work together and share implicit state, often providing an expressive and declarative API.",
          "analysisPoints": [
            "Identifies key aspects: multiple components, working together, implicit state, declarative API."
          ],
          "keyConcepts": [
            "Compound Components Definition",
            "Shared State",
            "Declarative API"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Definition",
            "Basics"
          ],
          "prerequisites": [
            "React_Patterns"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_compound_components_2",
          "topic": "Compound Components and Context API",
          "level": "medium",
          "type": "mcq",
          "question": "Which React API is most commonly used to facilitate the sharing of implicit state between the parent and child components in the Compound Components pattern?",
          "answer": "React Context API (`createContext` and `useContext`)",
          "options": [
            "React Redux",
            "React Context API (`createContext` and `useContext`)",
            "React Portals",
            "React Refs"
          ],
          "analysisPoints": [
            "Identifies the correct and primary mechanism for implicit state sharing.",
            "Distinguishes Context API from other React features/libraries."
          ],
          "keyConcepts": [
            "Compound Components",
            "React Context API",
            "State Sharing"
          ],
          "evaluationCriteria": [
            "Recognition of key tools",
            "Understanding of pattern implementation"
          ],
          "example": "The `Tabs` component uses `TabsContext.Provider` to share `activeIndex` and `setActiveIndex`, while `Tabs.Tab` and `Tabs.TabPanel` use `useContext(TabsContext)` to consume them.",
          "tags": [
            "Compound Components",
            "Context API",
            "MCQ"
          ],
          "prerequisites": [
            "React_Context_API"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_3",
          "topic": "Compound Components Benefits",
          "level": "medium",
          "type": "open",
          "question": "Describe two significant advantages of using the Compound Components pattern for building complex UI widgets.",
          "answer": "Two significant advantages of using the Compound Components pattern are:\n\n1.  **Expressive and Declarative API**: The pattern results in a highly readable and intuitive API. For example, using `<Tabs.TabList><Tabs.Tab>...</Tabs.Tab></Tabs.TabList>` clearly communicates the structure and relationships of the components. This makes the code easier to understand, use, and maintain, even for new developers.\n2.  **Flexible Component Composition**: It allows consumers to arrange the sub-components in various ways and inject their own elements or logic between them, without losing the shared state and behavior. This provides great flexibility, enabling highly customized UI layouts and functionalities that would be difficult to achieve with a single monolithic component or by prop-drilling.",
          "analysisPoints": [
            "Identifies key benefits: Expressive API and Flexible Composition.",
            "Provides clear explanations for each advantage.",
            "Connects the benefits to real-world UI development challenges."
          ],
          "keyConcepts": [
            "Compound Components Benefits",
            "Declarative API",
            "Flexible Composition"
          ],
          "evaluationCriteria": [
            "Ability to explain concepts clearly",
            "Understanding of pattern advantages"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Benefits",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_Patterns"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_4",
          "topic": "Compound Components Implementation Detail",
          "level": "medium",
          "type": "code",
          "question": "In the Compound Components `Tabs` example, why is `if (!isActive) return null;` used inside the `Tabs.TabPanel` component?",
          "answer": "```javascript\n// Inside Tabs.TabPanel\nconst { activeIndex } = useContext(TabsContext);\nconst isActive = activeIndex === index;\n\nif (!isActive) return null; // This line\n\nreturn (\n  <div className=\"tab-panel\" role=\"tabpanel\" hidden={!isActive}>\n    {children}\n  </div>\n);\n```\n\nThis line `if (!isActive) return null;` is used to prevent the inactive `TabPanel` components from being rendered into the DOM. By returning `null`, React effectively unmounts that specific `TabPanel` and its children from the DOM when it's not the active one. This has several benefits:\n\n1.  **Performance**: It avoids rendering potentially complex UI elements and executing their associated logic (e.g., fetching data, running animations) if they are not currently visible.\n2.  **Resource Management**: Components that are `null` are not in the DOM, reducing the browser's workload.\n3.  **Correctness**: Ensures only the content of the currently active tab is displayed, which is the expected behavior for a tabs component.\n\nWhile a `hidden` HTML attribute could visually hide elements, returning `null` completely removes them, which is often preferred for dynamic content or performance reasons.",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the purpose of `return null` (conditional rendering/unmounting).",
            "Explains the benefits (performance, resource management, correctness).",
            "Differentiates from simply hiding with CSS/HTML attributes."
          ],
          "keyConcepts": [
            "Compound Components",
            "Conditional Rendering",
            "Performance",
            "React DOM"
          ],
          "evaluationCriteria": [
            "Understanding of React rendering lifecycle",
            "Ability to explain code functionality and implications"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Conditional Rendering",
            "Performance",
            "Code Explanation"
          ],
          "prerequisites": [
            "React_Rendering",
            "React_Conditional_Rendering"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_5",
          "topic": "Compound Components vs. Prop Drilling",
          "level": "hard",
          "type": "open",
          "question": "How does the Compound Components pattern, particularly when using React Context, alleviate the problem of 'prop drilling'?",
          "answer": "Prop drilling (or 'prop threading') is a common issue in React where props have to be passed down through multiple layers of nested components to reach a component that actually needs them, even if intermediate components don't directly use those props. This can make code harder to read, maintain, and refactor.\n\nThe Compound Components pattern, when implemented with the React Context API, directly addresses prop drilling by providing a centralized mechanism for sharing state and functions:\n\n1.  **Centralized State Management**: The main parent component (e.g., `Tabs`) manages the shared state (e.g., `activeIndex`) and the functions to update it (e.g., `setActiveIndex`).\n2.  **Context Provision**: This parent component wraps its children with a `Context.Provider`, making the shared state and functions available to *any* descendant component, regardless of how deep it is in the component tree.\n3.  **Direct Consumption**: Any sub-component (e.g., `Tabs.Tab`, `Tabs.TabPanel`) that needs access to this shared state or function can directly consume it using the `useContext` hook, without requiring it to be passed explicitly as a prop from its immediate parent.\n\nThis eliminates the need for intermediate components to receive and pass down props they don't care about, resulting in cleaner code, a more maintainable component structure, and a more focused API for the individual components within the compound system.",
          "analysisPoints": [
            "Defines prop drilling clearly.",
            "Explains how `Context.Provider` makes state available globally within the subtree.",
            "Details how `useContext` allows direct consumption.",
            "Highlights the benefits of avoiding prop drilling."
          ],
          "keyConcepts": [
            "Compound Components",
            "Prop Drilling",
            "React Context API",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of common React problems",
            "Ability to explain solutions provided by patterns",
            "Knowledge of Context API mechanism"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Context API",
            "Prop Drilling",
            "Advanced"
          ],
          "prerequisites": [
            "React_Context_API",
            "Component_Props"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_compound_components_6",
          "topic": "Compound Components Structure",
          "level": "easy",
          "type": "flashcard",
          "question": "How are sub-components typically exposed in the Compound Components pattern (e.g., for a `Tabs` component)?",
          "answer": "They are typically exposed as static properties of the main parent component, for example, `Tabs.TabList`, `Tabs.Tab`, `Tabs.TabPanels`, `Tabs.TabPanel`.",
          "analysisPoints": [
            "Identifies the common naming convention/structure."
          ],
          "keyConcepts": [
            "Compound Components Structure",
            "Static Properties"
          ],
          "evaluationCriteria": [
            "Quick recall/memory-based learning"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Structure",
            "Basics"
          ],
          "prerequisites": [
            "JavaScript_Object_Properties"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_compound_components_7",
          "topic": "Compound Components Use Case",
          "level": "medium",
          "type": "open",
          "question": "Imagine you need to build a complex `Dropdown` component with a trigger, a list of options, and individual option items. Explain how you would apply the Compound Components pattern to design its API and internal structure.",
          "answer": "To design a `Dropdown` component using the Compound Components pattern, you would break it down into several cooperating sub-components, managing its open/closed state and selected value implicitly via React Context.\n\n**API Design:**\n\n```jsx\n<Dropdown>\n  <Dropdown.Trigger>Click Me</Dropdown.Trigger>\n  <Dropdown.Menu>\n    <Dropdown.Item value=\"option1\">Option 1</Dropdown.Item>\n    <Dropdown.Item value=\"option2\">Option 2</Dropdown.Item>\n    <Dropdown.Item value=\"option3\">Option 3</Dropdown.Item>\n  </Dropdown.Menu>\n</Dropdown>\n```\n\n**Internal Structure and State Management (using React Context):**\n\n1.  **`DropdownContext`**: Create a `React.Context` to share the dropdown's `isOpen` state, a `toggle` function, and potentially the `selectedValue` and a function to update it (`setSelectedValue`).\n    ```jsx\n    const DropdownContext = createContext(null);\n    ```\n\n2.  **`Dropdown` (Parent Component)**:\n    *   Manages the `isOpen` (boolean) state to control menu visibility and `selectedValue` state.\n    *   Provides `isOpen`, `toggle` function, `selectedValue`, and `setSelectedValue` via `DropdownContext.Provider` to its children.\n    *   Renders its `children` within a container `div`.\n    ```jsx\n    function Dropdown({ children, onSelect }) {\n      const [isOpen, setIsOpen] = useState(false);\n      const [selectedValue, setSelectedValue] = useState(null);\n      const toggle = () => setIsOpen(prev => !prev);\n      const handleSelect = (value) => {\n        setSelectedValue(value);\n        setIsOpen(false); // Close menu on select\n        onSelect && onSelect(value);\n      };\n\n      const contextValue = { isOpen, toggle, selectedValue, handleSelect };\n\n      return (\n        <DropdownContext.Provider value={contextValue}>\n          <div className=\"dropdown\">{children}</div>\n        </DropdownContext.Provider>\n      );\n    }\n    ```\n\n3.  **`Dropdown.Trigger` (Sub-component)**:\n    *   Consumes `isOpen` and `toggle` from `DropdownContext`.\n    *   Renders a button or trigger element.\n    *   On click, it calls the `toggle` function to open/close the menu.\n    ```jsx\n    Dropdown.Trigger = function DropdownTrigger({ children }) {\n      const { toggle } = useContext(DropdownContext);\n      return <button onClick={toggle}>{children}</button>;\n    };\n    ```\n\n4.  **`Dropdown.Menu` (Sub-component)**:\n    *   Consumes `isOpen` from `DropdownContext`.\n    *   Conditionally renders its `children` (the menu list) based on `isOpen`.\n    *   Typically renders a `<ul>` or `<div>`.\n    ```jsx\n    Dropdown.Menu = function DropdownMenu({ children }) {\n      const { isOpen } = useContext(DropdownContext);\n      if (!isOpen) return null;\n      return <ul className=\"dropdown-menu\">{children}</ul>;\n    };\n    ```\n\n5.  **`Dropdown.Item` (Sub-component)**:\n    *   Consumes `handleSelect` from `DropdownContext`.\n    *   Renders an `<li>` or `<div>`.\n    *   On click, it calls `handleSelect` with its own `value` prop.\n    ```jsx\n    Dropdown.Item = function DropdownItem({ children, value }) {\n      const { handleSelect } = useContext(DropdownContext);\n      return <li onClick={() => handleSelect(value)}>{children}</li>;\n    };\n    ```\n\nThis structure provides a clean, declarative API for the `Dropdown`, allowing users to compose it flexibly while the internal state management remains encapsulated and implicit via Context.",
          "analysisPoints": [
            "Applies the pattern to a new complex UI component (Dropdown).",
            "Defines the declarative API structure for the dropdown.",
            "Explains how `React.Context` would be used to share state (`isOpen`, `toggle`, `selectedValue`).",
            "Details the responsibilities of each sub-component and how they interact with the context."
          ],
          "keyConcepts": [
            "Compound Components",
            "React Context API",
            "Declarative API",
            "Component Design",
            "State Management",
            "Use Cases"
          ],
          "evaluationCriteria": [
            "Ability to apply the pattern to a new problem",
            "Design thinking for component APIs",
            "Correct use of Context API"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Design",
            "Architecture",
            "Advanced",
            "Use Case"
          ],
          "prerequisites": [
            "React_Context_API",
            "Component_Design"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_render_props_data_fetcher",
          "title": "Implement a Data Fetcher using Render Props",
          "description": "\nImplement a `DataFetcher` component using the Render Props pattern (specifically, using `children` as a function). This component should encapsulate the logic for fetching data from a given URL and managing its loading and error states.\n\n**Requirements:**\n1.  The `DataFetcher` component should accept a `url` prop.\n2.  It should manage three states: `data` (fetched data), `loading` (boolean), and `error` (any error object).\n3.  It should perform data fetching when the component mounts and re-fetch if the `url` prop changes.\n4.  The `children` prop must be a function that receives an object `{ data, loading, error }`.\n5.  The component should set `loading` to `true` before fetching and `false` after fetching (or on error).\n6.  On successful fetch, `data` should be updated. On error, `error` should be updated.\n\nYour solution should be robust enough to handle basic fetching scenarios and clearly demonstrate the Render Props pattern.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction DataFetcher({ url, children }) {\n  // TODO: Implement state for data, loading, error\n  // TODO: Implement data fetching logic using useEffect\n  // TODO: Call children with the appropriate state\n\n  return null; // Replace with your implementation\n}\n\n// Example Usage (for testing):\nfunction App() {\n  return (\n    <div>\n      <h1>Data Fetcher Example</h1>\n      <DataFetcher url=\"https://jsonplaceholder.typicode.com/posts/1\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Loading data...</p>;\n          if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n          if (data) return (\n            <div>\n              <h2>Post Title: {data.title}</h2>\n              <p>{data.body}</p>\n            </div>\n          );\n          return <p>No data yet.</p>;\n        }}\n      </DataFetcher>\n\n      <hr />\n\n      <h2>Another Data Fetcher (simulated invalid URL)</h2>\n      <DataFetcher url=\"invalid-url\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Loading another...</p>;\n          if (error) return <p style={{ color: 'red' }}>Error fetching: {error.message}</p>;\n          return <p>Data received (if any): {JSON.stringify(data)}</p>;\n        }}\n      </DataFetcher>\n    </div>\n  );\n}\n\n// To run this in a React environment:\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction DataFetcher({ url, children }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      setData(null); // Clear previous data\n\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    if (url) {\n      fetchData();\n    } else {\n      // Handle case where URL might be initially empty or null\n      setLoading(false);\n      setError(new Error('URL not provided'));\n    }\n\n  }, [url]); // Re-run effect if URL changes\n\n  // children is expected to be a function that receives { data, loading, error }\n  return children({ data, loading, error });\n}\n\n// Example Usage:\nfunction App() {\n  return (\n    <div>\n      <h1>Data Fetcher Example</h1>\n      <DataFetcher url=\"https://jsonplaceholder.typicode.com/posts/1\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Loading data...</p>;\n          if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n          if (data) return (\n            <div>\n              <h2>Post Title: {data.title}</h2>\n              <p>{data.body}</p>\n            </div>\n          );\n          return <p>No data yet.</p>;\n        }}\n      </DataFetcher>\n\n      <hr />\n\n      <h2>Another Data Fetcher (simulated invalid URL)</h2>\n      <DataFetcher url=\"https://jsonplaceholder.typicode.com/invalid-path\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Loading another...</p>;\n          if (error) return <p style={{ color: 'red' }}>Error fetching: {error.message}</p>;\n          return <p>Data received (if any): {JSON.stringify(data)}</p>;\n        }}\n      </DataFetcher>\n\n      <hr />\n\n      <h2>Data Fetcher with no URL (should show error)</h2>\n      <DataFetcher url=\"\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Still loading, even without URL?</p>;\n          if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n          return <p>Should not get here.</p>;\n        }}\n      </DataFetcher>\n    </div>\n  );\n}",
          "testCases": [
            "Test with a valid API URL (e.g., `https://jsonplaceholder.typicode.com/posts/1`). Expect `loading` to be `true` initially, then `data` to be populated and `loading` to be `false`.",
            "Test with an invalid API URL (e.g., `https://jsonplaceholder.typicode.com/nonexistent`). Expect `loading` to be `true` initially, then `error` to be populated with an `Error` object and `loading` to be `false`.",
            "Test with `url` prop changing. Expect the component to re-fetch data based on the new URL.",
            "Test with an empty or `null` `url` prop initially. Expect `loading` to become `false` and `error` to indicate missing URL.",
            "Verify that `data` is cleared when a new fetch is initiated (e.g., on `url` change)."
          ],
          "hints": [
            "Use `useState` for `data`, `loading`, and `error` states.",
            "The `useEffect` hook is essential for performing side effects like data fetching. Remember to include `url` in its dependency array.",
            "Don't forget to handle both successful responses and errors during the fetch.",
            "Ensure that `loading` state is correctly managed (set `true` before fetch, `false` in `finally` block)."
          ],
          "tags": [
            "Render Props",
            "Data Fetching",
            "React Hooks",
            "Error Handling",
            "Loading State"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_Hooks",
            "JavaScript_Promises",
            "Fetch_API"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Render Props Pattern",
            "useEffect Hook",
            "useState Hook",
            "Asynchronous JavaScript"
          ]
        },
        {
          "id": "task_compound_components_accordion",
          "title": "Build an Accordion Component using Compound Components",
          "description": "\nImplement a reusable `Accordion` component system using the Compound Components pattern. The accordion should allow for one item to be open at a time.\n\n**Requirements:**\n1.  Create a main `Accordion` component that manages the `activeIndex` (the index of the currently open panel) state.\n2.  Expose sub-components as static properties of `Accordion`: `Accordion.Item`, `Accordion.Header`, `Accordion.Panel`.\n3.  Use the React Context API to share the `activeIndex` and a function to set it (`setActiveIndex`) implicitly down the component tree.\n4.  `Accordion.Item` should encapsulate an `Accordion.Header` and `Accordion.Panel`.\n5.  `Accordion.Header` should be clickable and, when clicked, should update the `activeIndex` in the parent `Accordion` to its own item's index. It should also indicate if its corresponding panel is active.\n6.  `Accordion.Panel` should only render its content if its corresponding item's index matches the `activeIndex`.\n7.  Ensure the API is declarative and flexible, similar to the `Tabs` example.\n\n",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useContext, useState } from 'react';\n\n// TODO: Create AccordionContext\n// TODO: Implement Accordion (main component)\n// TODO: Implement Accordion.Item\n// TODO: Implement Accordion.Header\n// TODO: Implement Accordion.Panel\n\n// Example Usage (for testing):\nfunction App() {\n  return (\n    <Accordion defaultIndex={0}>\n      <Accordion.Item index={0}>\n        <Accordion.Header>Section 1 Title</Accordion.Header>\n        <Accordion.Panel>\n          <p>Content for section 1.</p>\n          <ul>\n            <li>Item A</li>\n            <li>Item B</li>\n          </ul>\n        </Accordion.Panel>\n      </Accordion.Item>\n\n      <Accordion.Item index={1}>\n        <Accordion.Header>Section 2 Title</Accordion.Header>\n        <Accordion.Panel>\n          <p>This is the content for section 2. It could be quite long.</p>\n        </Accordion.Panel>\n      </Accordion.Item>\n\n      <Accordion.Item index={2}>\n        <Accordion.Header>Section 3 Title</Accordion.Header>\n        <Accordion.Panel>\n          <p>Final section content.</p>\n          <button>Click Me</button>\n        </Accordion.Panel>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n\n// To run this in a React environment:\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "solutionCode": "import React, { createContext, useContext, useState, useRef } from 'react';\n\n// Create AccordionContext\nconst AccordionContext = createContext(null);\n\n// Main Accordion component\nfunction Accordion({ children, defaultIndex = -1 }) {\n  const [activeIndex, setActiveIndex] = useState(defaultIndex);\n  \n  const contextValue = {\n    activeIndex,\n    setActiveIndex,\n  };\n\n  return (\n    <AccordionContext.Provider value={contextValue}>\n      <div className=\"accordion\">{children}</div>\n    </AccordionContext.Provider>\n  );\n}\n\n// Accordion.Item component\nAccordion.Item = function AccordionItem({ children, index }) {\n  // Pass the item's index down to its children (Header/Panel)\n  // This allows Header/Panel to know which item they belong to\n  const itemContext = useRef({ index }).current;\n\n  return (\n    <div className=\"accordion-item\">\n      <AccordionItemContext.Provider value={itemContext}>\n        {children}\n      </AccordionItemContext.Provider>\n    </div>\n  );\n};\n\n// New context for Accordion.Item to pass its index to Header/Panel\nconst AccordionItemContext = createContext(null);\n\n// Accordion.Header component\nAccordion.Header = function AccordionHeader({ children }) {\n  const { activeIndex, setActiveIndex } = useContext(AccordionContext);\n  const { index: myIndex } = useContext(AccordionItemContext);\n\n  const isActive = activeIndex === myIndex;\n\n  const handleClick = () => {\n    setActiveIndex(isActive ? -1 : myIndex); // Toggle logic\n  };\n\n  return (\n    <h2 \n      className={`accordion-header ${isActive ? 'active' : ''}`}\n      onClick={handleClick}\n      role=\"button\"\n      aria-expanded={isActive}\n      tabIndex={0}\n    >\n      {children}\n      <span className=\"accordion-icon\">{isActive ? '▼' : '►'}</span>\n    </h2>\n  );\n};\n\n// Accordion.Panel component\nAccordion.Panel = function AccordionPanel({ children }) {\n  const { activeIndex } = useContext(AccordionContext);\n  const { index: myIndex } = useContext(AccordionItemContext);\n\n  const isActive = activeIndex === myIndex;\n\n  if (!isActive) return null; // Hide if not active\n\n  return (\n    <div className=\"accordion-panel\" role=\"region\" hidden={!isActive}>\n      {children}\n    </div>\n  );\n};\n\n// Example Usage:\nfunction App() {\n  return (\n    <div style={{ maxWidth: '600px', margin: '20px auto', border: '1px solid #ccc', borderRadius: '5px' }}>\n      <h1 style={{ textAlign: 'center' }}>Simple Accordion</h1>\n      <Accordion defaultIndex={0}>\n        <Accordion.Item index={0}>\n          <Accordion.Header>Section One - What is React?</Accordion.Header>\n          <Accordion.Panel>\n            <p>React is a JavaScript library for building user interfaces. It lets you compose complex UIs from small and isolated pieces of code called 'components'.</p>\n            <p>React's core principle is declarative programming, making your code more predictable and easier to debug.</p>\n          </Accordion.Panel>\n        </Accordion.Item>\n\n        <Accordion.Item index={1}>\n          <Accordion.Header>Section Two - Why use Hooks?</Accordion.Header>\n          <Accordion.Panel>\n            <p>Hooks let you use state and other React features without writing a class. They make components easier to read, test, and compose.</p>\n            <p>Popular hooks include <code>useState</code>, <code>useEffect</code>, <code>useContext</code>, and <code>useCallback</code>.</p>\n          </Accordion.Panel>\n        </Accordion.Item>\n\n        <Accordion.Item index={2}>\n          <Accordion.Header>Section Three - Compound Components Benefit</Accordion.Header>\n          <Accordion.Panel>\n            <p>Compound components provide a flexible and declarative API, allowing users to arrange sub-components freely while sharing implicit state via React Context. This avoids prop drilling and enhances reusability.</p>\n            <button style={{ padding: '8px 15px', background: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Learn More</button>\n          </Accordion.Panel>\n        </Accordion.Item>\n      </Accordion>\n    </div>\n  );\n}\n\n// Add some basic CSS for visual feedback (optional for task, but good practice)\n/*\n.accordion-item {\n  border-bottom: 1px solid #eee;\n}\n.accordion-header {\n  padding: 15px;\n  background-color: #f8f8f8;\n  cursor: pointer;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  font-weight: bold;\n}\n.accordion-header.active {\n  background-color: #e0e0e0;\n}\n.accordion-panel {\n  padding: 15px;\n  background-color: #fff;\n}\n.accordion-icon {\n  margin-left: 10px;\n  font-size: 0.8em;\n}\n*/",
          "testCases": [
            "Initialize with `defaultIndex` 0: Expect the first panel to be open and others closed.",
            "Click on the second header: Expect the first panel to close and the second panel to open.",
            "Click on the currently open header: Expect the panel to close (allowing no panels to be open).",
            "Test multiple clicks on different headers to ensure correct active panel switching.",
            "Verify that only one panel is open at any given time.",
            "Test accessibility attributes (e.g., `role`, `aria-expanded`, `tabIndex`) for `Accordion.Header` and `Accordion.Panel`."
          ],
          "hints": [
            "You'll likely need two contexts: one for the main `Accordion` to share `activeIndex` and `setActiveIndex`, and another, temporary one, within `Accordion.Item` to pass the `index` down to its immediate children (`Header` and `Panel`).",
            "The `Accordion.Item` component itself doesn't need to consume the main context, but it's crucial for passing its `index` to its `Header` and `Panel` children.",
            "Inside `Accordion.Header`, determine `isActive` by comparing its own item's `index` with the `activeIndex` from the main context.",
            "Remember to conditionally render `Accordion.Panel` based on its `isActive` status.",
            "Consider `useRef` within `Accordion.Item` to create a stable object for the item's index that can be passed to its context provider, avoiding unnecessary re-renders."
          ],
          "tags": [
            "Compound Components",
            "React Context",
            "State Management",
            "Component Design",
            "UI Widget"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React_Context_API",
            "React_Hooks",
            "Component_Composition"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Compound Components Pattern",
            "React Context API",
            "useState Hook",
            "createContext Hook",
            "useContext Hook",
            "Conditional Rendering"
          ]
        }
      ]
    }
  },
  {
    "id": "813fc626-6d3d-42b0-a407-590768e8b398",
    "startLine": 3200,
    "endLine": 3299,
    "processedDate": "2025-06-17T08:39:40.482Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_compound_components",
          "title": "React Compound Components Pattern",
          "content": "Compound components are a design pattern in React where multiple components work together to form a complete UI widget, sharing implicit state and logic. Instead of passing many props down to deeply nested children, compound components allow developers to compose a complex UI by using child components as properties of a parent component. This pattern promotes flexibility, reusability, and separation of concerns.\n\n### Key Concepts\n-   **Declarative API**: They create a more readable, HTML-like component structure, making the component's intent clear from its usage.\n-   **Flexible Composition**: The consumer of the component can control the order and structure of the component parts, allowing for greater customization without modifying the core component logic.\n-   **Implicit State Sharing**: Component parts share state without explicit prop drilling. This is often achieved using React Context, allowing children to access the parent's state and methods.\n-   **Encapsulation**: Internal state logic is hidden from the consumer, providing a clean and intuitive API. Consumers only interact with the top-level components and their designated properties.\n-   **Intuitive API**: Developers can understand the relationship between components at a glance, as the nested structure visually represents the logical hierarchy.\n\n### Implementation Details\nTypically, the parent compound component (e.g., `Tabs`) manages the shared state (e.g., `activeIndex`). Its children (e.g., `Tabs.TabList`, `Tabs.Tab`, `Tabs.TabPanels`, `Tabs.TabPanel`) then consume this state, often using `React.Children.map` to iterate over children and `React.cloneElement` to inject props, or more commonly, React Context API for state distribution.",
          "examples": [
            {
              "id": "example_compound_components_1",
              "title": "Tabs Component Usage",
              "code": "import React from 'react';\n\n// Usage of the compound components\nfunction App() {\n  return (\n    <Tabs defaultActiveIndex={1}>\n      <Tabs.TabList>\n        <Tabs.Tab index={0}>Profile</Tabs.Tab>\n        <Tabs.Tab index={1}>Settings</Tabs.Tab>\n        <Tabs.Tab index={2}>Notifications</Tabs.Tab>\n      </Tabs.TabList>\n      \n      <Tabs.TabPanels>\n        <Tabs.TabPanel index={0}>\n          <h2>Profile Content</h2>\n          <p>User profile information goes here</p>\n        </Tabs.TabPanel>\n        <Tabs.TabPanel index={1}>\n          <h2>Settings Content</h2>\n          <p>User settings go here</p>\n        </Tabs.TabPanel>\n        <Tabs.TabPanel index={2}>\n          <h2>Notifications Content</h2>\n          <p>User notifications go here</p>\n        </Tabs.TabPanel>\n      </Tabs.TabPanels>\n    </Tabs>\n  );\n}",
              "explanation": "This example shows how a `Tabs` compound component is used. The `Tabs` component itself wraps `Tabs.TabList` and `Tabs.TabPanels`, which are components attached as properties of `Tabs`. `Tabs.Tab` and `Tabs.TabPanel` are children of their respective parent compound components. This structure allows the `Tabs` component to manage the active index state, which is then implicitly available to `Tabs.Tab` (for highlighting the active tab) and `Tabs.TabPanel` (for displaying the correct content). The consumer only needs to define the structure, and the state management is handled internally by the compound components.",
              "language": "typescript"
            },
            {
              "id": "example_compound_components_2",
              "title": "Conceptual Implementation of Tabs (Simplified)",
              "code": "import React, { useState, createContext, useContext } from 'react';\n\ninterface TabsContextType {\n  activeIndex: number;\n  setActiveIndex: (index: number) => void;\n}\n\nconst TabsContext = createContext<TabsContextType | undefined>(undefined);\n\nfunction useTabsContext() {\n  const context = useContext(TabsContext);\n  if (context === undefined) {\n    throw new Error('useTabsContext must be used within a TabsProvider');\n  }\n  return context;\n}\n\nexport function Tabs({ defaultActiveIndex, children }: { defaultActiveIndex: number; children: React.ReactNode }) {\n  const [activeIndex, setActiveIndex] = useState(defaultActiveIndex);\n\n  const contextValue = { activeIndex, setActiveIndex };\n\n  return (\n    <TabsContext.Provider value={contextValue}>\n      {children}\n    </TabsContext.Provider>\n  );\n}\n\nfunction TabList({ children }: { children: React.ReactNode }) {\n  return <div role=\"tablist\">{children}</div>;\n}\n\nfunction Tab({ index, children }: { index: number; children: React.ReactNode }) {\n  const { activeIndex, setActiveIndex } = useTabsContext();\n  const isActive = activeIndex === index;\n\n  return (\n    <button\n      role=\"tab\"\n      aria-selected={isActive}\n      onClick={() => setActiveIndex(index)}\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    >\n      {children}\n    </button>\n  );\n}\n\nfunction TabPanels({ children }: { children: React.ReactNode }) {\n  return <div>{children}</div>;\n}\n\nfunction TabPanel({ index, children }: { index: number; children: React.ReactNode }) {\n  const { activeIndex } = useTabsContext();\n  const isActive = activeIndex === index;\n\n  return isActive ? <div role=\"tabpanel\">{children}</div> : null;\n}\n\n// Attach child components to the parent Tabs component\nTabs.TabList = TabList;\nTabs.Tab = Tab;\nTabs.TabPanels = TabPanels;\nTabs.TabPanel = TabPanel;\n",
              "explanation": "This is a simplified conceptual implementation of the `Tabs` compound component using React Context API. The `Tabs` component creates a context (`TabsContext`) to share `activeIndex` and `setActiveIndex`. `Tab` and `TabPanel` components then consume this context using `useTabsContext` to get the necessary state and functions, allowing them to render conditionally or react to state changes without direct prop passing from `Tabs`. This demonstrates how implicit state sharing is achieved.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_compound_components_1",
            "question_compound_components_2",
            "question_compound_components_3",
            "question_compound_components_4",
            "question_compound_components_5",
            "question_compound_components_6"
          ],
          "relatedTasks": [
            "task_compound_components_1"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Component Composition",
            "Context API",
            "Frontend Architecture"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics",
            "react_context_api"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_ui_libraries",
            "reusable_component_design"
          ]
        },
        {
          "id": "theory_functional_components_hooks",
          "title": "React Functional Components with Hooks",
          "content": "Functional components are JavaScript functions that accept props as an argument and return React elements. Before the introduction of Hooks in React 16.8, functional components were primarily used for presentational purposes (stateless components). Hooks revolutionized functional components by allowing them to use state and other React features (like lifecycle methods, context) without writing a class.\n\n### Key Concepts\n-   **Simpler Syntax**: More concise and easier to read compared to class components, reducing boilerplate.\n-   **Reusability of Logic**: Hooks allow you to extract stateful logic from a component so it can be tested independently and reused. `useState`, `useEffect`, `useContext`, `useReducer`, `useCallback`, `useMemo`, `useRef` are some built-in hooks.\n-   **No `this` Binding Issues**: Functional components do not have `this` context issues, which simplifies event handler binding.\n-   **Improved Performance (Potentially)**: While not a direct performance gain, the simpler mental model and explicit dependency arrays in `useEffect`, `useCallback`, and `useMemo` can lead to more optimized renders if used correctly.\n\n### `useState` Hook\n`useState` is a Hook that lets you add React state to functional components. It returns a pair: the current state value and a function that lets you update it.\n```typescript\nconst [state, setState] = useState(initialState);\n```\n-   `state`: The current state value.\n-   `setState`: A function to update the state. When called, it queues a re-render of the component.\n-   `initialState`: The value used for the state's initial render. It can be a primitive value or a function that returns the initial state.\n\n### `useEffect` Hook\n`useEffect` is a Hook that lets you perform side effects in functional components. Side effects include data fetching, subscriptions, manually changing the DOM, and logging. It runs after every render of the component by default, but you can control when it runs by specifying a dependency array.\n```typescript\nuseEffect(() => {\n  // Side effect code here\n  return () => {\n    // Cleanup function (optional)\n  };\n}, [dependencies]); // Dependency array (optional)\n```\n-   The first argument is a function containing the side effect logic.\n-   The optional return function is a cleanup function, which runs before the component unmounts or before the effect re-runs.\n-   The second argument, the dependency array, controls when the effect re-runs:\n    -   `[]` (empty array): The effect runs once after the initial render and cleans up when the component unmounts (like `componentDidMount` and `componentWillUnmount`).\n    -   No dependency array: The effect runs after every render.\n    -   `[prop1, state2]`: The effect runs when any of the values in the array change (like `componentDidMount` and `componentDidUpdate`).",
          "examples": [
            {
              "id": "example_functional_components_hooks_1",
              "title": "Basic User Profile with `useState` and `useEffect`",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Mock API call\nconst fetchUser = async () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ name: 'John Doe', id: 1 });\n    }, 1000);\n  });\n};\n\nfunction UserProfile() {\n  const [user, setUser] = useState<{ name: string; id: number } | null>(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    fetchUser()\n      .then(data => {\n        setUser(data as { name: string; id: number });\n        setLoading(false);\n      })\n      .catch(error => {\n        console.error('Failed to fetch user:', error);\n        setLoading(false);\n      });\n  }, []); // Empty dependency array: runs once on mount\n  \n  if (loading) return <div>Loading user data...</div>;\n  if (!user) return <div>Failed to load user.</div>;\n  return <div>Hello, {user.name}! Your ID is {user.id}.</div>;\n}",
              "explanation": "This `UserProfile` functional component demonstrates the use of `useState` and `useEffect`. `useState` is used to manage `user` data and `loading` status. `useEffect` is used to perform the `fetchUser` side effect. The empty dependency array `[]` ensures that `fetchUser` is called only once after the initial render, mimicking `componentDidMount` behavior. The `loading` state provides feedback to the user while data is being fetched.",
              "language": "typescript"
            },
            {
              "id": "example_functional_components_hooks_2",
              "title": "Component with State and Props Dependencies",
              "code": "import React, { useState, useEffect } from 'react';\n\ninterface MessageDisplayProps {\n  messageId: number;\n}\n\n// Mock message fetch\nconst fetchMessage = async (id: number) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(`This is message number ${id}.`);\n    }, 500);\n  });\n};\n\nfunction MessageDisplay({ messageId }: MessageDisplayProps) {\n  const [message, setMessage] = useState<string>('');\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n\n  useEffect(() => {\n    setIsLoading(true);\n    fetchMessage(messageId).then(data => {\n      setMessage(data as string);\n      setIsLoading(false);\n    });\n    return () => {\n      // Cleanup if needed, e.g., cancel a fetch request\n    };\n  }, [messageId]); // Reruns when messageId prop changes\n\n  if (isLoading) return <div>Loading message {messageId}...</div>;\n  return <div>Message: {message}</div>;\n}\n\n// Usage in App component:\n// function App() {\n//   const [currentMessageId, setCurrentMessageId] = useState(1);\n//   return (\n//     <div>\n//       <MessageDisplay messageId={currentMessageId} />\n//       <button onClick={() => setCurrentMessageId(prevId => prevId + 1)}>Next Message</button>\n//     </div>\n//   );\n// }\n",
              "explanation": "This example shows `useEffect` with a dependency array containing a prop (`messageId`). The effect will re-run whenever `messageId` changes, fetching a new message. This demonstrates how effects can react to changes in props or state, similar to `componentDidUpdate`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_functional_components_1",
            "question_functional_components_2",
            "question_functional_components_3",
            "question_functional_components_4",
            "question_functional_components_5",
            "question_functional_components_6"
          ],
          "relatedTasks": [
            "task_functional_components_1"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Functional Components",
            "State Management",
            "Side Effects"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_functions",
            "react_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_react_development",
            "stateful_functional_components"
          ]
        },
        {
          "id": "theory_props_in_react",
          "title": "React Props (Properties)",
          "content": "Props (short for 'properties') are a mechanism for passing data from parent components to child components in React. They are read-only (immutable) within the receiving component, meaning a child component should never modify the props it receives directly. This immutability helps ensure a unidirectional data flow and predictable component behavior.\n\n### Key Characteristics\n-   **Unidirectional Data Flow**: Data flows down the component tree, from parent to child. This makes it easier to understand how data changes affect the application.\n-   **Read-Only**: Props are immutable within the component that receives them. If a child component needs to change data, it should communicate back to its parent (e.g., via a callback function passed as a prop).\n-   **Reusability**: Components are made more reusable by accepting props, allowing them to render different content or behave differently based on the data they receive.\n-   **Any Data Type**: Props can be of any JavaScript data type, including strings, numbers, booleans, objects, arrays, functions, and even other React elements.\n\n### Passing Props\nProps are passed to components using an HTML-like attribute syntax when rendering a component:\n```typescript\n<MyComponent propName={value} anotherProp=\"string_value\" />\n```\n\n### Receiving Props\n**In Functional Components:**\nFunctional components receive props as the first argument to the function. This argument is an object containing all the props passed to the component.\n\n**In Class Components:**\nClass components receive props via `this.props`. This is an instance property that holds the props object.",
          "examples": [
            {
              "id": "example_props_functional_1",
              "title": "Passing and Receiving Props in Functional Components",
              "code": "import React from 'react';\n\n// Passing props\nfunction App() {\n  return (\n    <UserProfile name=\"John\" age={25} isAdmin={true} />\n  );\n}\n\n// Receiving props using the props object\nfunction UserProfile(props: { name: string; age: number; isAdmin: boolean }) {\n  return (\n    <div>\n      <h2>User Profile: {props.name}</h2>\n      <p>Age: {props.age}</p>\n      {props.isAdmin && <p>Administrator</p>}\n    </div>\n  );\n}\n",
              "explanation": "The `App` component passes `name`, `age`, and `isAdmin` as props to `UserProfile`. The `UserProfile` functional component receives these as a single `props` object and accesses them using `props.name`, `props.age`, etc.",
              "language": "typescript"
            },
            {
              "id": "example_props_functional_2",
              "title": "Receiving Props with Destructuring in Functional Components",
              "code": "import React from 'react';\n\n// Passing props (same as above)\nfunction App() {\n  return (\n    <UserProfile name=\"Jane\" age={30} isAdmin={false} />\n  );\n}\n\n// Receiving props using destructuring\nfunction UserProfile({ name, age, isAdmin }: { name: string; age: number; isAdmin: boolean }) {\n  return (\n    <div>\n      <h2>User Profile: {name}</h2>\n      <p>Age: {age}</p>\n      {isAdmin && <p>Administrator</p>}\n    </div>\n  );\n}",
              "explanation": "This example shows a more common and cleaner way to receive props in functional components using ES6 object destructuring in the function signature. This directly extracts the `name`, `age`, and `isAdmin` properties from the `props` object, making the code more concise.",
              "language": "typescript"
            },
            {
              "id": "example_props_class_1",
              "title": "Receiving Props in Class Components",
              "code": "import React from 'react';\n\ninterface UserProfileProps {\n  name: string;\n  age: number;\n  isAdmin: boolean;\n}\n\nclass UserProfile extends React.Component<UserProfileProps> {\n  render() {\n    const { name, age, isAdmin } = this.props; // Access props via this.props\n    return (\n      <div>\n        <h2>User Profile: {name}</h2>\n        <p>Age: {age}</p>\n        {isAdmin && <p>Administrator</p>}\n      </div>\n    );\n  }\n}\n\n// Usage in App component:\n// function App() {\n//   return (\n//     <UserProfile name=\"Peter\" age={40} isAdmin={true} />\n//   );\n// }\n",
              "explanation": "In class components, props are accessed through `this.props`. Here, destructuring is used from `this.props` within the `render` method to make the usage of props cleaner.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_props_1",
            "question_props_2",
            "question_props_3",
            "question_props_4",
            "question_props_5"
          ],
          "relatedTasks": [
            "task_props_1"
          ],
          "tags": [
            "React",
            "Props",
            "Component Communication",
            "Data Flow",
            "Immutability"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "javascript_objects_destructuring"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "requiredFor": [
            "react_component_development",
            "data_passing"
          ]
        },
        {
          "id": "theory_state_in_react",
          "title": "React State Management",
          "content": "State in React refers to data that can change over time within a component and trigger re-renders. Unlike props, which are passed from parent to child and are immutable, state is managed internally by the component itself and is mutable. When state changes, React re-renders the component and its children to reflect the updated data.\n\n### Key Concepts\n-   **Internal Data**: State is private to its component (or managed by a state management solution like Redux/Context API for global state), enabling components to manage their own dynamic data.\n-   **Mutability**: State is designed to be updated. React provides mechanisms (`setState` in class components, `useState` hook in functional components) to update state, which then schedules a re-render.\n-   **Re-renders**: Changes to a component's state trigger a re-render of that component and its child components, ensuring the UI is always in sync with the data.\n-   **Local State**: State is typically local to the component that owns it. If state needs to be shared with siblings or distant descendants, it often needs to be 'lifted up' to a common ancestor or managed via Context API/global state management.\n\n### Managing State with `useState` Hook\nIn functional components, the `useState` Hook is the primary way to manage local component state. It allows you to declare a 'state variable' and a function to update it.\n\n```typescript\nconst [value, setValue] = useState(initialValue);\n```\n-   `value`: The current value of the state variable.\n-   `setValue`: A function that updates `value`. When called, it causes the component to re-render. It can accept a new value directly or a function that receives the previous state and returns the new state (useful for updates based on previous state).\n-   `initialValue`: The value used for the state's initial render. It is only used on the first render.\n\n### How State Differs from Props\n| Feature    | Props                                      | State                                      |\n| :--------- | :----------------------------------------- | :----------------------------------------- |\n| **Origin** | Passed from parent component               | Managed internally by the component        |\n| **Mutable**| Immutable (read-only) in child component   | Mutable (can be updated by the component)  |\n| **Usage**  | Configure component, pass data down        | Manage dynamic data, component's internal data |\n| **Impact** | Re-renders child if parent's prop changes  | Re-renders component and its children      |\n\nUnderstanding the distinction between props and state is fundamental to building dynamic React applications.",
          "examples": [
            {
              "id": "example_state_1",
              "title": "Basic Counter Component with `useState`",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1); // Updates state, triggers re-render\n  };\n\n  const decrement = () => {\n    setCount(prevCount => prevCount - 1); // Using functional update for safety\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}",
              "explanation": "This `Counter` component uses `useState` to manage a `count` variable. The `setCount` function is used to update `count`. Clicking the buttons triggers state updates, which in turn causes the component to re-render and display the new count. The `decrement` function uses a functional update (`prevCount => prevCount - 1`) which is preferred when the new state depends on the previous state, ensuring you're working with the most up-to-date value.",
              "language": "typescript"
            },
            {
              "id": "example_state_2",
              "title": "Toggle Component with Boolean State",
              "code": "import React, { useState } from 'react';\n\nfunction ToggleButton() {\n  const [isOn, setIsOn] = useState(false);\n\n  const toggle = () => {\n    setIsOn(prevIsOn => !prevIsOn);\n  };\n\n  return (\n    <div>\n      <button onClick={toggle}>\n        {isOn ? 'Turn Off' : 'Turn On'}\n      </button>\n      <p>Status: {isOn ? 'ON' : 'OFF'}</p>\n    </div>\n  );\n}",
              "explanation": "This component demonstrates managing a boolean state (`isOn`) to control UI elements. The `toggle` function flips the `isOn` state, which causes the button text and status paragraph to update accordingly. This is a common pattern for managing UI visibility or active states.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_state_1",
            "question_state_2",
            "question_state_3",
            "question_state_4",
            "question_state_5",
            "question_state_6"
          ],
          "relatedTasks": [
            "task_state_1"
          ],
          "tags": [
            "React",
            "State",
            "useState",
            "Data Management",
            "Component Lifecycle"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "javascript_variables"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "dynamic_ui_development",
            "interactive_components"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_compound_components_1",
          "topic": "Compound Components Benefits",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a direct benefit of using the Compound Components pattern in React?",
          "answer": "Increased prop drilling",
          "options": [
            "Declarative API",
            "Flexible Composition",
            "Implicit State Sharing",
            "Increased prop drilling"
          ],
          "analysisPoints": [
            "Compound components aim to *reduce* prop drilling by providing mechanisms like React Context for implicit state sharing, making 'Increased prop drilling' an incorrect benefit.",
            "Declarative API is achieved by providing a clear, HTML-like structure.",
            "Flexible Composition is a key advantage, allowing consumers to control the internal structure.",
            "Implicit State Sharing is a core feature, often enabled by Context API, avoiding explicit prop passing for shared state."
          ],
          "keyConcepts": [
            "Compound Components",
            "Declarative API",
            "Flexible Composition",
            "Implicit State Sharing",
            "Prop drilling"
          ],
          "evaluationCriteria": [
            "Understanding of compound component benefits",
            "Ability to identify anti-patterns related to component composition"
          ],
          "example": "The primary goal of compound components is to improve developer experience and flexibility, and they achieve implicit state sharing to avoid common issues like excessive prop drilling.",
          "tags": [
            "React",
            "Compound Components",
            "Design Patterns",
            "Prop Drilling"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_2",
          "topic": "Compound Components Structure",
          "level": "medium",
          "type": "open",
          "question": "Explain the typical structure of a React Compound Component pattern, specifically focusing on how the parent and child components interact to share state and logic without explicit prop drilling. Mention the common React API used for this purpose.",
          "answer": "A typical React Compound Component structure involves a main 'parent' component (e.g., `Tabs`) that serves as the entry point and holds the shared state. Its 'child' components (e.g., `Tabs.Tab`, `Tabs.TabList`, `Tabs.TabPanel`) are often attached as static properties to the parent component, allowing for a nested, HTML-like JSX syntax.\n\nThe interaction for state and logic sharing primarily relies on the **React Context API**. The parent component creates a Context Provider, wrapping its children and providing the shared state (e.g., `activeIndex`) and updater functions (e.g., `setActiveIndex`) to the context. The child components then consume this context using the `useContext` hook (in functional components) or `Context.Consumer` (in class components) to access the shared data and functions. This mechanism avoids prop drilling because components in the middle of the tree don't need to explicitly pass down props; instead, relevant children can 'reach up' and consume the necessary state from the context provider.",
          "analysisPoints": [
            "Identifies the parent-child relationship in terms of API structure (e.g., `Tabs.TabList`).",
            "Explains the role of shared state in the parent.",
            "Describes how state is implicitly shared (Context API).",
            "Mentions `useContext` hook as the primary mechanism.",
            "Highlights the benefit of avoiding prop drilling."
          ],
          "keyConcepts": [
            "Compound Components",
            "React Context API",
            "State Sharing",
            "Prop Drilling",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of the pattern's architecture",
            "Correct identification of key React APIs",
            "Clarity in explaining state sharing mechanisms"
          ],
          "tags": [
            "React",
            "Compound Components",
            "Context API",
            "State Management"
          ],
          "prerequisites": [
            "react_context_api",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_compound_components_3",
          "topic": "Compound Components Disadvantages",
          "level": "medium",
          "type": "mcq",
          "question": "While Compound Components offer great benefits, which of the following could be considered a potential disadvantage or complexity when implementing them?",
          "answer": "Increased complexity in state management for deeply nested or highly dynamic structures",
          "options": [
            "Reduced reusability due to tightly coupled parts",
            "Inability to share state between child components",
            "Increased bundle size due to redundant code",
            "Increased complexity in state management for deeply nested or highly dynamic structures"
          ],
          "analysisPoints": [
            "Compound components are designed for *increased* reusability, not reduced.",
            "They *enable* state sharing between child components via Context API.",
            "They don't inherently increase bundle size more than other patterns; redundant code is usually a sign of poor implementation, not the pattern itself.",
            "While they simplify state sharing in many cases, for very complex or deeply nested scenarios, managing the context and ensuring all parts react correctly can introduce its own set of complexities, especially if not designed carefully. Debugging can also be harder as state is implicit.",
            "The primary 'disadvantage' is often the initial setup complexity of the context and parent component, and potential difficulty in debugging implicit state flows if not well-documented."
          ],
          "keyConcepts": [
            "Compound Components",
            "State Management Complexity",
            "React Context"
          ],
          "evaluationCriteria": [
            "Critical thinking about design patterns",
            "Understanding of potential implementation challenges"
          ],
          "example": "While Compound Components simplify the consumer API, the internal implementation, especially managing context for many interdependent parts or highly dynamic scenarios, can become complex. For instance, if you have a `Tabs` component where tabs can be dynamically added/removed, ensuring context updates correctly and all panels respond can require careful handling of indices and state logic.",
          "tags": [
            "React",
            "Compound Components",
            "Design Patterns",
            "Challenges"
          ],
          "prerequisites": [
            "react_context_api"
          ],
          "complexity": 6,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_compound_components_4",
          "topic": "Compound Components vs. Prop Drilling",
          "level": "easy",
          "type": "flashcard",
          "question": "What common React issue do Compound Components help mitigate, and how?",
          "answer": "Compound Components help mitigate 'prop drilling' by allowing implicit state sharing between logically connected components, often through the React Context API.",
          "analysisPoints": [],
          "keyConcepts": [
            "Compound Components",
            "Prop Drilling",
            "React Context"
          ],
          "evaluationCriteria": [
            "Recall of core problem solved",
            "Understanding of solution mechanism"
          ],
          "tags": [
            "React",
            "Compound Components",
            "Prop Drilling"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_5",
          "topic": "Compound Components Code Analysis",
          "level": "medium",
          "type": "code",
          "question": "Consider the following incomplete React code for a `MenuItem` component that is part of a `Menu` compound component. The `Menu` component provides an `activeItem` state and a `setActiveItem` function via a Context. Complete the `MenuItem` component so that it highlights itself if it is the `activeItem` and updates the `activeItem` when clicked. Assume `MenuContext` and `useMenuContext` are already defined and provide `activeItem: string | null` and `setActiveItem: (id: string) => void`.",
          "answer": "```typescript\nimport React, { useContext } from 'react';\n\n// Assume these are defined elsewhere:\ninterface MenuContextType {\n  activeItem: string | null;\n  setActiveItem: (id: string) => void;\n}\n\nconst MenuContext = React.createContext<MenuContextType | undefined>(undefined);\n\nfunction useMenuContext() {\n  const context = useContext(MenuContext);\n  if (context === undefined) {\n    throw new Error('useMenuContext must be used within a MenuProvider');\n  }\n  return context;\n}\n\ninterface MenuItemProps {\n  id: string;\n  children: React.ReactNode;\n}\n\nfunction MenuItem({ id, children }: MenuItemProps) {\n  const { activeItem, setActiveItem } = useMenuContext();\n  const isActive = activeItem === id;\n\n  const handleClick = () => {\n    setActiveItem(id);\n  };\n\n  return (\n    <div\n      onClick={handleClick}\n      style={{ fontWeight: isActive ? 'bold' : 'normal', cursor: 'pointer' }}\n    >\n      {children}\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `useContext` to access shared state and updater function.",
            "Implements logic to determine `isActive` based on `activeItem` from context.",
            "Attaches an `onClick` handler that calls `setActiveItem` with its own `id`.",
            "Demonstrates conditional styling based on active state.",
            "Shows proper prop destructuring for `id` and `children`."
          ],
          "keyConcepts": [
            "Compound Components",
            "React Context",
            "useState",
            "Event Handling",
            "Conditional Rendering/Styling"
          ],
          "evaluationCriteria": [
            "Ability to consume context in a child component.",
            "Correct implementation of event handlers.",
            "Logical application of shared state to UI.",
            "Understanding of component responsibilities within a compound pattern."
          ],
          "example": "The provided solution correctly accesses the `activeItem` and `setActiveItem` from the `MenuContext`. It then uses `activeItem` to determine if the current `MenuItem` should be highlighted and `setActiveItem` to update the active item when clicked, demonstrating effective state sharing within the compound component pattern.",
          "tags": [
            "React",
            "Code Challenge",
            "Compound Components",
            "Context API",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_context_api"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_compound_components_6",
          "topic": "Compound Components vs. Render Props",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the Compound Components pattern with the Render Props pattern in React. When might you choose one over the other, and what are their respective strengths regarding flexibility and implicit state sharing?",
          "answer": "Both Compound Components and Render Props are patterns for sharing logic and state among components, but they achieve this differently.\n\n**Compound Components:**\n*   **Mechanism**: Relies on implicit state sharing, typically via React Context, where a parent component provides state and updater functions that child components (often attached as static properties) consume.\n*   **Flexibility**: Offers high flexibility in terms of *markup structure*. Consumers can freely interleave other HTML elements or components between the compound parts while maintaining the internal logic.\n*   **Implicit State Sharing**: Its main strength. State is shared 'behind the scenes' through context, reducing the need for explicit prop passing through intermediate components.\n*   **Readability**: Creates a very declarative, HTML-like API that is intuitive and easy to read.\n*   **Use Case**: Best for components that are *visually and logically coupled*, forming a single cohesive UI widget (e.g., `Tabs`, `Select`, `Modal`).\n\n**Render Props:**\n*   **Mechanism**: Involves a component that takes a `prop` (usually named `render` or `children`) which is a function that returns a React element. This function receives data/logic from the component, allowing the consumer to render anything based on that data.\n*   **Flexibility**: Offers high flexibility in terms of *rendering logic*. Consumers define exactly what gets rendered using the data provided by the render prop function.\n*   **Implicit State Sharing**: Does *not* inherently provide implicit state sharing. The data is explicitly passed to the render prop function.\n*   **Readability**: Can sometimes lead to deeply nested JSX, often referred to as 'callback hell', making it less readable than compound components for complex structures.\n*   **Use Case**: Best for sharing *behavior or stateful logic* across disparate components, especially when the visual output is highly variable (e.g., `Toggle`, `MouseTracker`).\n\n**When to choose which:**\n*   Choose **Compound Components** when you have a set of components that are logically a single unit and you want to provide a highly declarative and intuitive API for structuring the UI. It excels when the consumer needs control over the *structure* of the combined components.\n*   Choose **Render Props** when you need to share *reusable logic* and want the consumer to have full control over the *rendering* of that logic. It's ideal when the visual output varies greatly but the underlying behavior is consistent.\n\nIn summary, Compound Components provide structural flexibility with implicit state, while Render Props provide rendering flexibility with explicit state/logic passing.",
          "analysisPoints": [
            "Defines both patterns accurately.",
            "Compares their mechanisms (Context vs. function prop).",
            "Contrasts their flexibility (structural vs. rendering).",
            "Explains state sharing differences (implicit vs. explicit).",
            "Discusses readability implications.",
            "Provides clear use cases for each.",
            "Demonstrates a nuanced understanding of React design patterns."
          ],
          "keyConcepts": [
            "Compound Components",
            "Render Props",
            "Design Patterns",
            "Component Composition",
            "React Context",
            "State Sharing",
            "Flexibility"
          ],
          "evaluationCriteria": [
            "Depth of knowledge of React patterns",
            "Ability to articulate trade-offs",
            "Strategic thinking about component design"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Advanced React",
            "Compound Components",
            "Render Props"
          ],
          "prerequisites": [
            "react_context_api",
            "react_functional_components"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "expert"
        },
        {
          "id": "question_functional_components_1",
          "topic": "Functional Components Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between a functional component and a class component in React before Hooks?",
          "answer": "Before Hooks, functional components were stateless and couldn't use lifecycle methods, while class components could manage state and utilize lifecycle methods.",
          "analysisPoints": [],
          "keyConcepts": [
            "Functional Components",
            "Class Components",
            "State",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Basic recall of component types"
          ],
          "tags": [
            "React",
            "Functional Components",
            "Class Components"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_components_2",
          "topic": "Hooks Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What problem do React Hooks primarily solve for functional components?",
          "answer": "Allowing functional components to use state and lifecycle features.",
          "options": [
            "Eliminating the need for JSX.",
            "Allowing functional components to use state and lifecycle features.",
            "Replacing the Virtual DOM entirely.",
            "Enforcing strict type checking in JavaScript."
          ],
          "analysisPoints": [
            "Hooks were introduced to bridge the gap between functional components (simplicity) and class components (state/lifecycle capabilities).",
            "JSX is a syntax extension, unrelated to Hooks' primary purpose.",
            "Hooks operate within the Virtual DOM concept, not replacing it.",
            "Hooks don't enforce type checking; TypeScript does that."
          ],
          "keyConcepts": [
            "React Hooks",
            "Functional Components",
            "State Management",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Understanding of Hooks' core value proposition"
          ],
          "example": "Before Hooks, if you needed state or lifecycle methods in a component, you had to convert it to a class component. Hooks, like `useState` and `useEffect`, brought these capabilities directly to functional components, making them more powerful and reducing the need for class components.",
          "tags": [
            "React",
            "Hooks",
            "Functional Components"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_components_3",
          "topic": "`useEffect` Dependencies",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of the dependency array in the `useEffect` hook. Provide an example of how its absence, an empty array, and an array with values affect the execution of the effect and its cleanup.",
          "answer": "The dependency array (the second argument) in `useEffect` controls when the effect function re-runs and when its cleanup function (if provided) is executed. It tells React to re-run the effect only when values in this array change.\n\n1.  **No dependency array**: `useEffect(() => { /* effect */ });`\n    *   **Execution**: The effect runs after *every* render of the component.\n    *   **Cleanup**: The cleanup function (if any) runs before *every* re-execution of the effect and before the component unmounts.\n    *   **Use Case**: Very rarely used, often indicates a bug if not intentionally desired (e.g., logging every render).\n\n2.  **Empty dependency array**: `useEffect(() => { /* effect */ }, []);`\n    *   **Execution**: The effect runs only *once* after the initial render of the component.\n    *   **Cleanup**: The cleanup function runs only *once* when the component unmounts.\n    *   **Use Case**: Mimics `componentDidMount` and `componentWillUnmount` behavior, suitable for one-time setups like data fetching, subscriptions, or adding event listeners.\n\n3.  **Dependency array with values**: `useEffect(() => { /* effect */ }, [val1, val2]);`\n    *   **Execution**: The effect runs after the initial render, and then *only if any value in the `[val1, val2]` array changes* between renders.\n    *   **Cleanup**: The cleanup function runs before the effect re-runs (due to dependency change) and before the component unmounts.\n    *   **Use Case**: Mimics `componentDidMount` and `componentDidUpdate` (for specific props/state), suitable for effects that depend on dynamic values, like fetching data based on a user ID or reacting to prop changes.\n\nCorrectly using the dependency array is crucial for preventing infinite loops, optimizing performance, and avoiding stale closures in `useEffect`.",
          "analysisPoints": [
            "Clearly defines the purpose of the dependency array.",
            "Explains behavior for no array, empty array, and array with values.",
            "Provides analogy to class component lifecycle methods.",
            "Discusses cleanup function execution in each scenario.",
            "Mentions practical use cases for each scenario.",
            "Highlights the importance of correct usage."
          ],
          "keyConcepts": [
            "React Hooks",
            "useEffect",
            "Dependency Array",
            "Side Effects",
            "Component Lifecycle",
            "Cleanup Function"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of `useEffect` behavior",
            "Ability to explain implications of dependency array choices",
            "Knowledge of related lifecycle concepts"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Lifecycle"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_components_4",
          "topic": "`useState` Functional Updates",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React functional component and its state update logic:\n\n```typescript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1); // Line A\n    setCount(count + 1); // Line B\n    setCount(count + 1); // Line C\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment 3 Times</button>\n    </div>\n  );\n}\n```\n\nIf the current `count` is `0` and `handleClick` is called, what will be the value of `count` displayed after the component re-renders?",
          "answer": "1",
          "options": [
            "0",
            "1",
            "2",
            "3"
          ],
          "analysisPoints": [
            "React state updates are asynchronous and batched. When `setCount(count + 1)` is called multiple times within the same event loop, React batches these updates.",
            "Because `count` is a stale closure in each of these `setCount` calls (it refers to the `count` value *at the time the event handler was called*, i.e., `0`), all three calls will try to update `count` from `0` to `1`.",
            "Only the last update in the batch 'wins' if the new state depends on the previous state in an unbatched manner, but here, they all depend on the *same* initial `count` value. So, they all effectively try to set `count` to `0 + 1`.",
            "To correctly increment by 3, functional updates (`setCount(prevCount => prevCount + 1)`) should be used, as they guarantee access to the latest state."
          ],
          "keyConcepts": [
            "useState",
            "State Batching",
            "Asynchronous Updates",
            "Stale Closures",
            "Functional Updates"
          ],
          "evaluationCriteria": [
            "Understanding of React's state update mechanism",
            "Knowledge of state batching and stale closures"
          ],
          "example": "```typescript\n// Corrected handleClick using functional updates:\nconst handleClick = () => {\n  setCount(prevCount => prevCount + 1);\n  setCount(prevCount => prevCount + 1);\n  setCount(prevCount => prevCount + 1);\n};\n// With this correction, clicking the button would correctly update count to 3.\n```\nWhen `setCount(count + 1)` is called multiple times synchronously, React batches these updates. Each `setCount` call uses the `count` value from the closure of that render. If `count` is 0 when `handleClick` is invoked, all three `setCount` calls will effectively calculate `0 + 1 = 1`. React then processes these batched updates, resulting in `count` becoming `1` after the single re-render.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State Management",
            "Batching"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_components_5",
          "topic": "Functional Component Props",
          "level": "easy",
          "type": "flashcard",
          "question": "How do functional components receive props, and what's a common way to extract them for use?",
          "answer": "Functional components receive props as the first argument (an object). A common way to extract them for use is via ES6 object destructuring in the function signature.",
          "analysisPoints": [],
          "keyConcepts": [
            "Functional Components",
            "Props",
            "Destructuring"
          ],
          "evaluationCriteria": [
            "Recall of basic prop handling"
          ],
          "tags": [
            "React",
            "Props",
            "Functional Components"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_components_6",
          "topic": "When to use Functional vs. Class Components",
          "level": "hard",
          "type": "open",
          "question": "Given the widespread adoption of Hooks, discuss the current relevance of class components in modern React development. When might you still encounter or choose to use a class component over a functional component with Hooks, if at all?",
          "answer": "With the introduction of React Hooks, functional components have become the recommended and predominant way to write React components. They offer a simpler API, better reusability of stateful logic, and often lead to more concise code.\n\n**Current Relevance of Class Components:**\nWhile functional components with Hooks cover almost all use cases previously requiring class components, class components are not entirely deprecated. You will still encounter them in:\n\n1.  **Legacy Codebases**: Many existing large applications were built before Hooks were introduced. Migrating an entire codebase can be a massive undertaking, so new features might still be added using class components to maintain consistency, or new functional components might coexist with existing class components.\n2.  **Error Boundaries**: As of React 18, `componentDidCatch` and `static getDerivedStateFromError` lifecycle methods are still unique to class components for implementing Error Boundaries. There is no Hook equivalent for this specific feature.\n3.  **Older React Versions**: If working on a project using an older React version (pre-16.8), class components are necessary for stateful logic and lifecycle methods.\n4.  **Learning/Understanding History**: Understanding class components can be beneficial for debugging older code or appreciating the evolution of React's API.\n\n**When you *might* still choose a Class Component (very rare now):**\n*   **Error Boundaries**: This is the only legitimate and commonly cited reason today.\n*   **Specific edge cases or complex component logic** where a developer might find the class component's lifecycle methods more intuitive for a very particular setup, although this is becoming increasingly rare as developers become more proficient with `useEffect`.\n*   **Resistance to change / personal preference**: Some developers might prefer the mental model of class components, though this is generally discouraged for new development.\n\n**Conclusion:** For all new React development, functional components with Hooks are the **preferred choice**. Class components are primarily maintained for backward compatibility and the niche use case of Error Boundaries. Interviewers often ask this to gauge your understanding of React's evolution and best practices.",
          "analysisPoints": [
            "Acknowledges functional components with Hooks as the standard.",
            "Identifies key reasons for class component continued existence (legacy code, error boundaries).",
            "Explains the specific limitation of Hooks regarding error boundaries.",
            "Discusses other less common/valid reasons for using class components.",
            "Provides a clear conclusion on modern best practices.",
            "Demonstrates awareness of React's evolution."
          ],
          "keyConcepts": [
            "Functional Components",
            "Class Components",
            "React Hooks",
            "Error Boundaries",
            "Legacy Code",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "In-depth understanding of React component types.",
            "Knowledge of Hooks' capabilities and limitations.",
            "Awareness of current best practices and legacy considerations."
          ],
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Functional Components",
            "Error Boundaries"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_class_components_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_props_1",
          "topic": "Props Immutability",
          "level": "easy",
          "type": "mcq",
          "question": "Which statement accurately describes props in React?",
          "answer": "Props are immutable and flow from parent to child.",
          "options": [
            "Props are mutable and can be changed by the child component.",
            "Props are immutable and flow from parent to child.",
            "Props are used for internal component state management.",
            "Props are only used for passing primitive data types."
          ],
          "analysisPoints": [
            "Props are strictly read-only in the receiving component; they cannot be mutated directly by the child.",
            "Data flow in React is unidirectional, always from parent to child.",
            "Props are for external data from parents, while state is for internal, mutable data.",
            "Props can pass any JavaScript data type, including objects, arrays, functions, and React elements."
          ],
          "keyConcepts": [
            "Props",
            "Immutability",
            "Unidirectional Data Flow",
            "Component Communication"
          ],
          "evaluationCriteria": [
            "Fundamental understanding of props characteristics"
          ],
          "example": "If a child component needs to change data that originated as a prop, it should request the parent component to update its state, which then re-renders the child with new props. This strict immutability of props ensures predictable data flow and easier debugging.",
          "tags": [
            "React",
            "Props",
            "Immutability"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_props_2",
          "topic": "Passing Functions as Props",
          "level": "medium",
          "type": "open",
          "question": "Describe how you would pass a callback function from a parent component to a child component via props, and explain why this pattern is essential for communication back up the component tree in React.",
          "answer": "To pass a callback function, the parent component defines a function (e.g., `handleChildClick`) and then passes it as a prop to the child component:\n\n```typescript\n// ParentComponent.tsx\nimport React, { useState } from 'react';\nimport { ChildComponent } from './ChildComponent';\n\nfunction ParentComponent() {\n  const [message, setMessage] = useState('No message yet');\n\n  const handleChildClick = (dataFromChild: string) => {\n    setMessage(`Child says: ${dataFromChild}`);\n  };\n\n  return (\n    <div>\n      <p>{message}</p>\n      <ChildComponent onButtonClick={handleChildClick} />\n    </div>\n  );\n}\n\n// ChildComponent.tsx\nimport React from 'react';\n\ninterface ChildComponentProps {\n  onButtonClick: (data: string) => void;\n}\n\nexport function ChildComponent({ onButtonClick }: ChildComponentProps) {\n  return (\n    <button onClick={() => onButtonClick('Hello from child!')}>\n      Click me\n    </button>\n  );\n}\n```\n\nThis pattern is essential for **communication back up the component tree** (child to parent) because props themselves enforce a unidirectional data flow (parent to child). Since child components cannot directly modify props or their parent's state, passing a function as a prop provides a mechanism for the child to *inform* the parent that something has happened or that data needs to be updated. When the child invokes the callback function, the parent's function (and potentially its state) is updated, triggering a re-render of the parent and any affected children. This maintains React's philosophy of predictable data flow and a single source of truth for state.",
          "analysisPoints": [
            "Provides a clear code example of passing a function as a prop.",
            "Explains how the child uses the received function.",
            "Articulates *why* this pattern is necessary (unidirectional data flow, child-to-parent communication).",
            "Connects the concept to maintaining React's data flow principles."
          ],
          "keyConcepts": [
            "Props",
            "Callback Functions",
            "Unidirectional Data Flow",
            "Component Communication",
            "State Lifting"
          ],
          "evaluationCriteria": [
            "Practical understanding of prop usage for callbacks",
            "Theoretical grasp of React's data flow principles",
            "Ability to explain the 'why' behind the pattern"
          ],
          "tags": [
            "React",
            "Props",
            "Component Communication",
            "Callbacks"
          ],
          "prerequisites": [
            "react_basics",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_props_3",
          "topic": "Default Props",
          "level": "medium",
          "type": "mcq",
          "question": "You have a `Button` component that should display 'Click Me' by default if no `label` prop is provided. Which of the following is the most idiomatic way to achieve this in a modern functional React component?",
          "answer": "Using default parameter values in the functional component's destructuring.",
          "options": [
            "Checking `props.label` and setting a default inside the component's JSX.",
            "Using `Button.defaultProps = { label: 'Click Me' };` after the component definition.",
            "Using default parameter values in the functional component's destructuring.",
            "Implementing a `getDerivedStateFromProps` method to set default state."
          ],
          "analysisPoints": [
            "Option A works but is less concise and idiomatic.",
            "Option B (`defaultProps` static property) is a valid way, traditionally used with class components, and still supported but less common for functional components with ES6 default parameters.",
            "Option C (default parameters) is the most concise and modern way for functional components, leveraging native JavaScript features.",
            "Option D (`getDerivedStateFromProps`) is a class component lifecycle method and is used for specific state derivations, not for default props.",
            "The question specifically asks for the 'most idiomatic way in a *modern functional* React component'."
          ],
          "keyConcepts": [
            "Props",
            "Default Props",
            "Functional Components",
            "ES6 Destructuring"
          ],
          "evaluationCriteria": [
            "Knowledge of modern React practices for default props",
            "Understanding of ES6 features in React context"
          ],
          "example": "```typescript\nimport React from 'react';\n\ninterface ButtonProps {\n  label?: string;\n  onClick?: () => void;\n}\n\nfunction Button({ label = 'Click Me', onClick }: ButtonProps) {\n  return (\n    <button onClick={onClick}>\n      {label}\n    </button>\n  );\n}\n\n// Usage:\n// <Button /> // Displays 'Click Me'\n// <Button label=\"Submit\" /> // Displays 'Submit'\n```\nThis example demonstrates setting a default value for the `label` prop directly in the destructuring of the function parameters. If `label` is `undefined` when `Button` is rendered, it will default to `'Click Me'`. This is clean and leverages standard JavaScript.",
          "tags": [
            "React",
            "Props",
            "Default Props",
            "Functional Components"
          ],
          "prerequisites": [
            "javascript_es6",
            "react_functional_components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_props_4",
          "topic": "Prop Drilling",
          "level": "medium",
          "type": "flashcard",
          "question": "What is 'prop drilling' in React, and why is it considered an issue?",
          "answer": "'Prop drilling' (or 'props tunneling') is the process of passing data from a parent component down to a deeply nested child component by passing it through intermediate components that don't actually need the data themselves. It's considered an issue because it increases code complexity, makes components less reusable (as they become coupled to specific prop structures they just pass along), and makes debugging harder by obscuring where a prop actually originates or is used.",
          "analysisPoints": [],
          "keyConcepts": [
            "Prop Drilling",
            "Component Communication",
            "Code Maintainability"
          ],
          "evaluationCriteria": [
            "Recall of a common React anti-pattern",
            "Understanding of its negative impacts"
          ],
          "tags": [
            "React",
            "Prop Drilling",
            "Anti-patterns"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_props_5",
          "topic": "Props vs. Children Prop",
          "level": "hard",
          "type": "open",
          "question": "Explain the difference between passing data via named props (e.g., `<MyComponent data={value} />`) versus using the `children` prop (e.g., `<MyComponent>{value}</MyComponent>`). When would you prefer one over the other?",
          "answer": "Both named props and the `children` prop are ways to pass data or elements to a React component, but they serve different semantic purposes and are preferred in different scenarios.\n\n**Named Props (`<MyComponent data={value} />`):**\n*   **Purpose**: Used for passing discrete pieces of data, configuration options, or callbacks. They are typically key-value pairs.\n*   **Flexibility**: Good for clearly defining specific inputs the component expects.\n*   **Semantics**: Implies that the data is an 'attribute' or 'property' of the component, defining its behavior or content in a structured way.\n*   **Use Cases**: `name`, `age`, `isLoading`, `onClick`, `src`, `href`.\n\n**`children` Prop (`<MyComponent>{value}</MyComponent>`):**\n*   **Purpose**: Represents the content enclosed between the opening and closing tags of a component. It can be a string, number, array of elements, or another component.\n*   **Flexibility**: Extremely flexible, allowing for arbitrary content and complex nested structures within the component's body. The component itself becomes a 'container' or 'wrapper'.\n*   **Semantics**: Implies a parent-child relationship where the inner content is 'owned' or rendered by the component. It's often used for layout components or components that act as containers.\n*   **Use Cases**: Layout components (`<Card><Header /><Body /></Card>`), higher-order components (in a conceptual sense), or simple text content (`<Heading>My Title</Heading>`).\n\n**When to prefer one over the other:**\n*   **Choose Named Props** when the data is a distinct, specific value that describes an attribute or behavior of the component (e.g., a user's name, a toggle's initial state, a callback for an event). It's for when you want to define *how* the component should act or what specific pieces of data it needs.\n*   **Choose `children` Prop** when the component is primarily a container or wrapper, and its main purpose is to render the content passed inside its tags. This is ideal when the content's structure or type is highly variable, or when you want to create a semantic grouping of other elements (e.g., a `Modal` that wraps its entire content, a `Grid` that wraps its `GridItem`s). It's for when you want to define *what* the component contains or renders as its primary output.\n\nIn essence, named props are for *configuration*, while the `children` prop is for *composition*.",
          "analysisPoints": [
            "Clearly defines named props and the `children` prop.",
            "Explains their respective purposes and flexibilities.",
            "Distinguishes their semantic implications.",
            "Provides relevant use cases for each.",
            "Offers clear guidance on when to choose one over the other.",
            "Demonstrates a deep understanding of React's composition model."
          ],
          "keyConcepts": [
            "Props",
            "Children Prop",
            "Component Composition",
            "Component Design",
            "Flexibility",
            "Semantics"
          ],
          "evaluationCriteria": [
            "Advanced understanding of React component design.",
            "Ability to differentiate between similar concepts based on best practices.",
            "Strategic thinking about component API design."
          ],
          "tags": [
            "React",
            "Props",
            "Children",
            "Component Composition",
            "Advanced React"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_state_1",
          "topic": "State vs. Props Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the fundamental difference between 'props' and 'state' in React?",
          "answer": "Props (properties) are immutable data passed from parent to child, while state is mutable data managed internally by a component and can change over time.",
          "analysisPoints": [],
          "keyConcepts": [
            "Props",
            "State",
            "Immutability",
            "Mutability"
          ],
          "evaluationCriteria": [
            "Recall of basic definitions"
          ],
          "tags": [
            "React",
            "Props",
            "State"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_2",
          "topic": "State Updates and Re-renders",
          "level": "medium",
          "type": "mcq",
          "question": "When a component's state is updated using `useState`'s setter function, what is the immediate consequence in React?",
          "answer": "React schedules a re-render of the component and its children.",
          "options": [
            "The component immediately re-renders synchronously.",
            "React schedules a re-render of the component and its children.",
            "Only the specific part of the DOM affected by the state change is updated.",
            "The component's props are automatically updated from its parent."
          ],
          "analysisPoints": [
            "React's state updates are generally asynchronous and batched for performance, so it doesn't immediately re-render synchronously.",
            "Updating state (`setState` or `useState`'s setter) signals React that the component (and its children) might need to be re-rendered to reflect the new state. React then decides *when* to perform the actual render.",
            "While React's reconciliation process efficiently updates only necessary parts of the *actual* DOM, the *scheduling* consequence of a state update is a re-render of the component within React's virtual DOM.",
            "State updates are internal to the component and don't automatically update props from its parent; props are external data."
          ],
          "keyConcepts": [
            "React State",
            "useState",
            "Re-renders",
            "Asynchronous Updates",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Understanding of React's rendering process",
            "Knowledge of state update mechanisms"
          ],
          "example": "When you call `setCount(count + 1)` in a counter component, React doesn't instantaneously update the UI. Instead, it marks the component as 'dirty' and, at an opportune time (often after all synchronous code has run), it will trigger a re-render cycle where it compares the new Virtual DOM tree with the old one and efficiently updates the real DOM.",
          "tags": [
            "React",
            "State",
            "useState",
            "Rendering"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_3",
          "topic": "State Immutability Practices",
          "level": "medium",
          "type": "open",
          "question": "When dealing with state that is an object or an array in React, why is it crucial to update it immutably (i.e., create a new object/array instead of modifying the existing one)? Provide a simple code example demonstrating a correct immutable update for an array state.",
          "answer": "It is crucial to update state immutably (by creating a new object or array) for two main reasons:\n\n1.  **React's Change Detection**: React uses a shallow comparison to determine if a component needs to re-render. If you mutate the original state object or array directly, the reference to that object/array remains the same. React's shallow comparison will see the *same reference* and might not detect the change, thus failing to re-render the component and update the UI.\n2.  **Predictability and Debugging**: Immutability makes your application's state more predictable. Each state change results in a new version of the state, making it easier to track changes, debug issues (e.g., with time-travel debuggers), and implement features like undo/redo.\n\n**Correct Immutable Update for an Array State:**\n\n```typescript\nimport React, { useState } from 'react';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState(['Learn React', 'Write Code']);\n\n  const addTodo = (newTodo: string) => {\n    // INCORRECT: Mutates original array, React might not re-render\n    // todos.push(newTodo);\n    // setTodos(todos);\n\n    // CORRECT: Creates a new array using spread operator\n    setTodos([...todos, newTodo]);\n  };\n\n  const removeTodo = (indexToRemove: number) => {\n    // CORRECT: Creates a new array using filter\n    setTodos(todos.filter((_, index) => index !== indexToRemove));\n  };\n\n  return (\n    <div>\n      <ul>\n        {todos.map((todo, index) => (\n          <li key={index}>\n            {todo}\n            <button onClick={() => removeTodo(index)}>x</button>\n          </li>\n        ))}\n      </ul>\n      <button onClick={() => addTodo('Explore Hooks')}>Add 'Explore Hooks'</button>\n    </div>\n  );\n}\n```\n\nIn the `addTodo` example, `[...todos, newTodo]` creates a brand new array with all existing todos plus the new one. Similarly, `todos.filter(...)` returns a new array without the removed item. This ensures React detects the change and triggers a re-render.",
          "analysisPoints": [
            "Explains the two core reasons: React's shallow comparison and predictability.",
            "Provides a clear code example of an array state update.",
            "Demonstrates both adding and removing elements immutably.",
            "Contrasts correct immutable update with incorrect mutable one.",
            "Highlights the use of spread operator and `filter` for immutable array operations."
          ],
          "keyConcepts": [
            "React State",
            "Immutability",
            "Shallow Comparison",
            "Re-renders",
            "Array/Object Updates",
            "Spread Operator",
            "Filter Method"
          ],
          "evaluationCriteria": [
            "Understanding of React's rendering optimization principles.",
            "Practical knowledge of immutable data structures in JavaScript.",
            "Ability to write correct state update logic."
          ],
          "tags": [
            "React",
            "State",
            "Immutability",
            "useState"
          ],
          "prerequisites": [
            "react_basics",
            "javascript_array_methods",
            "javascript_objects"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_4",
          "topic": "Local vs. Global State",
          "level": "hard",
          "type": "open",
          "question": "When should you prefer managing state locally within a component using `useState` versus using a global state management solution (like React Context API or Redux)? Provide examples for both scenarios.",
          "answer": "The choice between local state (`useState`) and global state management depends on the scope and sharing requirements of the data.\n\n**1. Local State (`useState`):**\n*   **When to Use**: When the state is only relevant to a single component and does not need to be shared with distant components in the component tree (siblings, cousins, or deeply nested children). It's ideal for UI-specific data that doesn't affect other parts of the application or for component-internal logic.\n*   **Examples**: \n    *   A `ToggleButton`'s `isOn` state.\n    *   A `Counter` component's `count`.\n    *   The input value of a single `Form` field.\n    *   A `Modal` component's `isOpen` state.\n    *   `isLoading` state for a component fetching its own data.\n*   **Benefits**: Simple, lightweight, and easy to reason about. Encapsulates concerns within the component.\n\n**2. Global State Management (e.g., React Context API, Redux, Zustand):**\n*   **When to Use**: When state needs to be shared across multiple components that are not directly related (e.g., siblings, deeply nested children in different branches of the tree) or when the state represents application-wide data that affects many parts of the UI.\n*   **Examples**: \n    *   **User authentication status** (e.g., `isLoggedIn`, `currentUser` object) that needs to be accessible by navigation bars, profile pages, and protected routes.\n    *   **Shopping cart data** in an e-commerce application, accessed by product pages, cart summary, and checkout.\n    *   **Theme preferences** (e.g., dark/light mode) applied across the entire application.\n    *   **Application-wide notifications/toasts** that can be triggered from anywhere.\n    *   A **global filter/sort setting** that impacts multiple data displays.\n*   **Benefits**: Centralized data management, avoids prop drilling, easier debugging for shared state, better separation of concerns for application-level data.\n\n**Summary:**\nStart with local state. If a component's state needs to be passed down through many levels (prop drilling occurs), consider lifting state up to a common ancestor. If that ancestor is very high in the tree, or if the state is truly global and needed by many disparate components, then a global state management solution is appropriate.",
          "analysisPoints": [
            "Clearly defines use cases for local state.",
            "Provides concrete examples for local state scenarios.",
            "Clearly defines use cases for global state management.",
            "Provides concrete examples for global state scenarios.",
            "Discusses benefits of each approach.",
            "Offers a guideline for choosing between them (start local, then scale)."
          ],
          "keyConcepts": [
            "React State",
            "useState",
            "Global State Management",
            "React Context",
            "Redux",
            "Prop Drilling",
            "State Lifting",
            "Component Scope"
          ],
          "evaluationCriteria": [
            "Strategic understanding of state management.",
            "Ability to choose appropriate tools based on requirements.",
            "Knowledge of different state patterns in React."
          ],
          "tags": [
            "React",
            "State Management",
            "useState",
            "Context API",
            "Redux"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_context_api"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_state_5",
          "topic": "`useState` Initial State",
          "level": "easy",
          "type": "mcq",
          "question": "What happens if you provide a function as the initial state argument to `useState`?",
          "answer": "The function will be executed only once during the initial render to compute the initial state.",
          "options": [
            "The function will be executed on every re-render to compute the new state.",
            "The function will be executed only once during the initial render to compute the initial state.",
            "React will treat the function itself as the initial state value.",
            "An error will be thrown because `useState` expects a direct value, not a function."
          ],
          "analysisPoints": [
            "This is a common optimization for `useState`. If the initial state computation is expensive (e.g., reading from local storage, complex calculations), providing a function ensures it's only run once.",
            "If you pass a direct value, it's computed on every render, even if `useState` only uses it on the first.",
            "React distinguishes between a direct value and a function returning a value for initial state.",
            "It's a valid and recommended pattern, not an error."
          ],
          "keyConcepts": [
            "React State",
            "useState",
            "Initial State",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Knowledge of `useState` advanced usage",
            "Understanding of performance considerations"
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nconst heavyInitialComputation = () => {\n  console.log('Running heavy initial computation...');\n  let sum = 0;\n  for (let i = 0; i < 10000000; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\nfunction MyComponent() {\n  // This function only runs once on initial render\n  const [data, setData] = useState(heavyInitialComputation);\n\n  // ... rest of component\n  return <div>Data: {data}</div>;\n}\n```\nIf `heavyInitialComputation()` were passed directly (e.g., `useState(heavyInitialComputation())`), the function would execute on every re-render, even though `useState` only uses the result once. Passing it as a function `useState(heavyInitialComputation)` ensures it's only called on the first render for efficiency.",
          "tags": [
            "React",
            "State",
            "useState",
            "Performance"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_6",
          "topic": "Batching State Updates",
          "level": "hard",
          "type": "open",
          "question": "Explain React's concept of 'batching' state updates. Why is it important, and how does it relate to the behavior of multiple `setCount` calls in a single event handler (as seen in `question_functional_components_4`) versus calls made within asynchronous operations (e.g., `setTimeout` or `Promise.then`)?",
          "answer": "React's 'batching' is a performance optimization where multiple state updates (e.g., multiple calls to `setState` or `useState` setters) triggered in the same event loop cycle are grouped together into a single re-render. Instead of re-rendering the component immediately after each state update, React waits until all updates within the current event handler or browser event are processed, then performs a single render.\n\n**Importance of Batching:**\n1.  **Performance**: Reduces the number of re-renders, preventing unnecessary computation and DOM manipulations. This leads to a smoother and more responsive UI.\n2.  **Consistency**: Ensures that your UI reflects the final state after a series of updates, rather than flickering through intermediate states.\n\n**Batching in Event Handlers vs. Asynchronous Operations:**\n\n*   **Synchronous Event Handlers (e.g., `onClick`, `onChange`):**\n    *   **Behavior**: React **batches** updates. If you call `setCount(count + 1)` three times within a single `onClick` handler, React sees all three calls, but because they occur within the same synchronous event, it performs a single re-render at the end. However, each `setCount(count + 1)` call in this scenario uses the `count` value from the *initial render's closure* (the `count` value when the event handler was defined, or when the component last rendered). This is why if `count` is `0`, all three calls calculate `0 + 1`, and the final `count` becomes `1` (the last update wins, or rather, all resolve to the same value).\n    *   **Solution for Sequential Updates**: To ensure each update uses the *latest* state, you must use **functional updates** (e.g., `setCount(prevCount => prevCount + 1)`). This ensures the `prevCount` argument inside the updater function is always the most recent state value.\n\n*   **Asynchronous Operations (e.g., `setTimeout`, `Promise.then`, native DOM event handlers):**\n    *   **Behavior (Pre-React 18)**: Historically, React did *not* batch updates originating from asynchronous code or outside of React's own event system. Each `setCount` call in a `setTimeout` would trigger a separate re-render, leading to multiple, potentially inefficient, renders.\n    *   **Behavior (React 18+ / Automatic Batching)**: React 18 introduced **automatic batching** for all state updates, regardless of where they originate (event handlers, `setTimeout`, promises, etc.). Now, multiple `setCount` calls within *any* context will be batched into a single re-render by default. This makes the behavior more consistent and predictable.\n\n    *   **Example (React 18+):**\n        ```typescript\n        function MyComponent() {\n          const [countA, setCountA] = useState(0);\n          const [countB, setCountB] = useState(0);\n\n          const handleClick = () => {\n            setTimeout(() => {\n              setCountA(countA + 1); // Uses stale `countA` if not functional update\n              setCountB(countB + 1); // Uses stale `countB` if not functional update\n              // Both updates are batched into one re-render in React 18+\n            }, 0);\n          };\n\n          return <button onClick={handleClick}>Update Counts</button>;\n        }\n        ```\n        Even with automatic batching, using functional updates (`setCountA(prev => prev + 1)`) is still crucial for correctness when a new state depends on the previous state, especially with stale closures in asynchronous contexts.",
          "analysisPoints": [
            "Defines batching and its purpose (performance, consistency).",
            "Explains batching behavior in synchronous event handlers, including the issue of stale closures with direct values.",
            "Explains the solution for synchronous updates (functional updates).",
            "Discusses the historical (pre-React 18) and current (React 18+ automatic batching) behavior for asynchronous updates.",
            "Reinforces that functional updates are still important for correctness even with automatic batching.",
            "Demonstrates a deep understanding of React's internal rendering mechanisms."
          ],
          "keyConcepts": [
            "React State",
            "Batching",
            "Performance Optimization",
            "Asynchronous Updates",
            "Stale Closures",
            "Functional Updates",
            "React 18"
          ],
          "evaluationCriteria": [
            "Expert-level understanding of React rendering and state management.",
            "Knowledge of React versions and their impact on features.",
            "Ability to explain complex interactions between concepts."
          ],
          "tags": [
            "React",
            "State",
            "Batching",
            "Performance",
            "Hooks",
            "Advanced React"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "javascript_asynchronicity"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_compound_components_1",
          "title": "Build a Custom Accordion Compound Component",
          "description": "\nImplement a flexible `Accordion` compound component that can manage the open/closed state of multiple accordion items. The component should allow consumers to define the structure using sub-components.\n\n**Requirements:**\n1.  Create a main `Accordion` component.\n2.  Create sub-components: `Accordion.Item`, `Accordion.Header`, `Accordion.Panel`.\n3.  The `Accordion` component should manage the `activeItem` state (the ID of the currently open item, or `null` if none). It should support only one item being open at a time (like a standard accordion).\n4.  `Accordion.Header` should toggle the `Accordion.Panel` associated with its `Accordion.Item` when clicked. It should also indicate if its parent `Accordion.Item` is active (e.g., by changing text or adding a style).\n5.  `Accordion.Panel` should only be visible if its associated `Accordion.Item` is active.\n6.  Use React Context API for state sharing between `Accordion` and its sub-components.\n7.  Each `Accordion.Item` must have a unique `id` prop.\n\n**Example Usage:**\n```typescript\nfunction App() {\n  return (\n    <Accordion>\n      <Accordion.Item id=\"item-1\">\n        <Accordion.Header>Section 1</Accordion.Header>\n        <Accordion.Panel>\n          <p>Content for section 1.</p>\n        </Accordion.Panel>\n      </Accordion.Item>\n      <Accordion.Item id=\"item-2\">\n        <Accordion.Header>Section 2</Accordion.Header>\n        <Accordion.Panel>\n          <p>Content for section 2.</p>\n        </Accordion.Panel>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n```\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, createContext, useContext } from 'react';\n\n// 1. Define AccordionContext and useAccordionContext hook\ninterface AccordionContextType {\n  activeItem: string | null;\n  setActiveItem: (id: string | null) => void;\n  // Add any other shared state/functions here\n}\n\nconst AccordionContext = createContext<AccordionContextType | undefined>(undefined);\n\nfunction useAccordionContext() {\n  const context = useContext(AccordionContext);\n  if (context === undefined) {\n    throw new Error('useAccordionContext must be used within an AccordionProvider');\n  }\n  return context;\n}\n\n// 2. Implement the main Accordion component\nexport function Accordion({ children }: { children: React.ReactNode }) {\n  const [activeItem, setActiveItem] = useState<string | null>(null);\n\n  const contextValue: AccordionContextType = {\n    activeItem,\n    setActiveItem,\n  };\n\n  return (\n    <AccordionContext.Provider value={contextValue}>\n      <div className=\"accordion-container\">\n        {children}\n      </div>\n    </AccordionContext.Provider>\n  );\n}\n\n// 3. Implement Accordion.Item component\n//    This component needs to make its own ID available to its children\n//    Consider creating an inner context for the Item if Header/Panel need the ID.\n\n// Inner context for each Accordion.Item to pass its ID down\ninterface AccordionItemContextType {\n  id: string;\n}\nconst AccordionItemContext = createContext<AccordionItemContextType | undefined>(undefined);\n\nfunction useAccordionItemContext() {\n  const context = useContext(AccordionItemContext);\n  if (context === undefined) {\n    throw new Error('useAccordionItemContext must be used within an Accordion.Item');\n  }\n  return context;\n}\n\nAccordion.Item = function AccordionItem({ id, children }: { id: string; children: React.ReactNode }) {\n  // Implement logic to wrap children with AccordionItemContext.Provider\n  const { activeItem } = useAccordionContext(); // Access main accordion state to determine if this item is active\n  const isActive = activeItem === id;\n\n  const itemContextValue = { id };\n\n  return (\n    <AccordionItemContext.Provider value={itemContextValue}>\n      <div className={`accordion-item ${isActive ? 'active' : ''}`}>\n        {children}\n      </div>\n    </AccordionItemContext.Provider>\n  );\n};\n\n// 4. Implement Accordion.Header component\nAccordion.Header = function AccordionHeader({ children }: { children: React.ReactNode }) {\n  const { id } = useAccordionItemContext(); // Get item ID from item context\n  const { activeItem, setActiveItem } = useAccordionContext(); // Get main accordion state\n\n  const handleClick = () => {\n    // Toggle logic: If this item is active, close it (set activeItem to null).\n    // Otherwise, open this item (set activeItem to its id).\n    setActiveItem(activeItem === id ? null : id);\n  };\n\n  const isActive = activeItem === id;\n\n  return (\n    <div\n      className={`accordion-header ${isActive ? 'active' : ''}`}\n      onClick={handleClick}\n      style={{ cursor: 'pointer', padding: '10px', border: '1px solid #ccc', margin: '5px 0' }}\n    >\n      {children} {isActive ? '(Open)' : '(Closed)'}\n    </div>\n  );\n};\n\n// 5. Implement Accordion.Panel component\nAccordion.Panel = function AccordionPanel({ children }: { children: React.ReactNode }) {\n  const { id } = useAccordionItemContext(); // Get item ID from item context\n  const { activeItem } = useAccordionContext(); // Get main accordion state\n\n  const isActive = activeItem === id;\n\n  return isActive ? (\n    <div className=\"accordion-panel\" style={{ padding: '10px', border: '1px solid #eee' }}>\n      {children}\n    </div>\n  ) : null;\n};\n",
          "solutionCode": "import React, { useState, createContext, useContext } from 'react';\n\n// 1. Define AccordionContext and useAccordionContext hook\ninterface AccordionContextType {\n  activeItem: string | null;\n  setActiveItem: (id: string | null) => void;\n}\n\nconst AccordionContext = createContext<AccordionContextType | undefined>(undefined);\n\nfunction useAccordionContext() {\n  const context = useContext(AccordionContext);\n  if (context === undefined) {\n    throw new Error('useAccordionContext must be used within an AccordionProvider');\n  }\n  return context;\n}\n\n// Inner context for each Accordion.Item to pass its ID down\ninterface AccordionItemContextType {\n  id: string;\n}\nconst AccordionItemContext = createContext<AccordionItemContextType | undefined>(undefined);\n\nfunction useAccordionItemContext() {\n  const context = useContext(AccordionItemContext);\n  if (context === undefined) {\n    throw new Error('useAccordionItemContext must be used within an Accordion.Item');\n  }\n  return context;\n}\n\n// 2. Implement the main Accordion component\nexport function Accordion({ children }: { children: React.ReactNode }) {\n  const [activeItem, setActiveItem] = useState<string | null>(null);\n\n  const contextValue: AccordionContextType = {\n    activeItem,\n    setActiveItem,\n  };\n\n  return (\n    <AccordionContext.Provider value={contextValue}>\n      <div className=\"accordion-container\">\n        {children}\n      </div>\n    </AccordionContext.Provider>\n  );\n}\n\n// 3. Implement Accordion.Item component\nAccordion.Item = function AccordionItem({ id, children }: { id: string; children: React.ReactNode }) {\n  // activeItem and isActive check is done in Header and Panel\n  const itemContextValue = { id };\n\n  return (\n    <AccordionItemContext.Provider value={itemContextValue}>\n      <div className=\"accordion-item\">\n        {children}\n      </div>\n    </AccordionItemContext.Provider>\n  );\n};\n\n// 4. Implement Accordion.Header component\nAccordion.Header = function AccordionHeader({ children }: { children: React.ReactNode }) {\n  const { id } = useAccordionItemContext(); // Get item ID from item context\n  const { activeItem, setActiveItem } = useAccordionContext(); // Get main accordion state\n\n  const handleClick = () => {\n    // Toggle logic: If this item is active, close it (set activeItem to null).\n    // Otherwise, open this item (set activeItem to its id).\n    setActiveItem(activeItem === id ? null : id);\n  };\n\n  const isActive = activeItem === id;\n\n  return (\n    <div\n      className={`accordion-header ${isActive ? 'active' : ''}`}\n      onClick={handleClick}\n      style={{ cursor: 'pointer', padding: '10px', border: '1px solid #ccc', margin: '5px 0', background: isActive ? '#f0f0f0' : 'white' }}\n    >\n      {children} {isActive ? '▼' : '►'}\n    </div>\n  );\n};\n\n// 5. Implement Accordion.Panel component\nAccordion.Panel = function AccordionPanel({ children }: { children: React.ReactNode }) {\n  const { id } = useAccordionItemContext(); // Get item ID from item context\n  const { activeItem } = useAccordionContext(); // Get main accordion state\n\n  const isActive = activeItem === id;\n\n  return isActive ? (\n    <div className=\"accordion-panel\" style={{ padding: '10px', border: '1px solid #eee', borderTop: 'none' }}>\n      {children}\n    </div>\n  ) : null;\n};\n",
          "testCases": [
            "Render Accordion with two items: Only the first item should be collapsed by default.",
            "Clicking Header 1: Panel 1 should open. Clicking Header 1 again should close Panel 1.",
            "Clicking Header 1, then Header 2: Panel 1 should close, Panel 2 should open.",
            "Render with items having different content: Verify correct content is displayed when panel is active.",
            "Test with no items: Should render gracefully without errors.",
            "Test with only one item: Should function correctly (open/close)."
          ],
          "hints": [
            "Remember to create a separate context for the `Accordion.Item` to pass its `id` down to `Header` and `Panel`.",
            "The `activeItem` state in the main `Accordion` component should store the `id` of the currently open item.",
            "The `Header` component will be responsible for updating the `activeItem` in the main `Accordion` context when clicked.",
            "The `Panel` component should conditionally render its children based on whether its `id` matches the `activeItem` from the main `Accordion` context."
          ],
          "tags": [
            "React",
            "Compound Components",
            "Context API",
            "Hooks",
            "UI Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_context_api",
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Component Composition",
            "State Management",
            "Implicit State Sharing"
          ]
        },
        {
          "id": "task_functional_components_1",
          "title": "Create a Searchable Data Table with Debouncing",
          "description": "\nImplement a functional React component called `SearchableTable` that displays a list of users, allowing users to filter the list by a search query. The search functionality should be debounced to optimize performance.\n\n**Requirements:**\n1.  **`SearchableTable` Component**: This component should:\n    *   Take an initial `data` prop (an array of user objects: `{ id: number, name: string, email: string }`).\n    *   Display a search input field.\n    *   Display the filtered user data in a simple HTML table.\n2.  **Search Logic**: \n    *   Filter users by `name` or `email` based on the search query.\n    *   Case-insensitive matching.\n3.  **Debouncing**: \n    *   The actual filtering operation (which can be a heavy computation for large datasets) should only run after the user stops typing for a specific duration (e.g., 300ms).\n    *   Implement this debouncing using `useEffect` and `useState`.\n4.  **Loading State**: Display a 'Searching...' message while the debounced search is active.\n\n**User Data Example:**\n```typescript\nconst initialUsers = [\n  { id: 1, name: 'Alice Smith', email: 'alice@example.com' },\n  { id: 2, name: 'Bob Johnson', email: 'bob@example.com' },\n  { id: 3, name: 'Charlie Brown', email: 'charlie@example.com' },\n  { id: 4, name: 'David Lee', email: 'david@example.com' },\n  { id: 5, name: 'Eve Davis', email: 'eve@example.com' },\n];\n```\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface SearchableTableProps {\n  data: User[];\n}\n\nconst initialUsers: User[] = [\n  { id: 1, name: 'Alice Smith', email: 'alice@example.com' },\n  { id: 2, name: 'Bob Johnson', email: 'bob@example.com' },\n  { id: 3, name: 'Charlie Brown', email: 'charlie@example.com' },\n  { id: 4, name: 'David Lee', email: 'david@example.com' },\n  { id: 5, name: 'Eve Davis', email: 'eve@example.com' },\n  { id: 6, name: 'Frank White', email: 'frank@example.com' },\n  { id: 7, name: 'Grace Green', email: 'grace@example.com' },\n  { id: 8, name: 'Harry Black', email: 'harry@example.com' },\n  { id: 9, name: 'Ivy Blue', email: 'ivy@example.com' },\n  { id: 10, name: 'Jack Red', email: 'jack@example.com' },\n];\n\nexport function SearchableTable({ data }: SearchableTableProps) {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');\n  const [isSearching, setIsSearching] = useState(false);\n  const [filteredData, setFilteredData] = useState<User[]>(data);\n\n  // TODO: Implement debouncing logic using useEffect\n  // Hint: A useEffect can be used to update debouncedSearchTerm after a delay.\n  // Hint: Another useEffect can be used to filter data based on debouncedSearchTerm.\n\n  // Effect for debouncing searchTerm\n  useEffect(() => {\n    // Set a timer to update debouncedSearchTerm\n    // Clear the previous timer if searchTerm changes before the delay\n    // Set isSearching to true when searchTerm changes, and false after debouncedSearchTerm updates\n  }, [searchTerm]);\n\n  // Effect for filtering data based on debouncedSearchTerm\n  useEffect(() => {\n    // Perform the filtering logic here\n    // Update filteredData state\n    // Set isSearching to false once filtering is complete\n  }, [debouncedSearchTerm, data]); // data is a dependency because the original data might change\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search by name or email...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ width: '300px', padding: '8px', marginBottom: '15px' }}\n      />\n      {isSearching && <p>Searching...</p>}\n      <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n        <thead>\n          <tr style={{ background: '#f2f2f2' }}>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>ID</th>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>Name</th>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>Email</th>\n          </tr>\n        </thead>\n        <tbody>\n          {filteredData.length === 0 && !isSearching ? (\n            <tr>\n              <td colSpan={3} style={{ textAlign: 'center', padding: '10px' }}>No users found.</td>\n            </tr>\n          ) : (\n            filteredData.map(user => (\n              <tr key={user.id}>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.id}</td>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.name}</td>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.email}</td>\n              </tr>\n            ))\n          )}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\n// Usage in App.tsx (for testing):\n// function App() {\n//   return <SearchableTable data={initialUsers} />;\n// }\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface SearchableTableProps {\n  data: User[];\n}\n\nconst initialUsers: User[] = [\n  { id: 1, name: 'Alice Smith', email: 'alice@example.com' },\n  { id: 2, name: 'Bob Johnson', email: 'bob@example.com' },\n  { id: 3, name: 'Charlie Brown', email: 'charlie@example.com' },\n  { id: 4, name: 'David Lee', email: 'david@example.com' },\n  { id: 5, name: 'Eve Davis', email: 'eve@example.com' },\n  { id: 6, name: 'Frank White', email: 'frank@example.com' },\n  { id: 7, name: 'Grace Green', email: 'grace@example.com' },\n  { id: 8, name: 'Harry Black', email: 'harry@example.com' },\n  { id: 9, name: 'Ivy Blue', email: 'ivy@example.com' },\n  { id: 10, name: 'Jack Red', email: 'jack@example.com' },\n];\n\nconst DEBOUNCE_DELAY = 300; // milliseconds\n\nexport function SearchableTable({ data }: SearchableTableProps) {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');\n  const [isSearching, setIsSearching] = useState(false);\n  const [filteredData, setFilteredData] = useState<User[]>(data);\n\n  // Effect for debouncing searchTerm\n  useEffect(() => {\n    if (searchTerm !== '') {\n        setIsSearching(true); // Indicate searching as soon as input changes\n    }\n\n    const handler = setTimeout(() => {\n      setDebouncedSearchTerm(searchTerm);\n    }, DEBOUNCE_DELAY);\n\n    // Cleanup function to clear the timeout if searchTerm changes before delay\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [searchTerm]);\n\n  // Effect for filtering data based on debouncedSearchTerm\n  useEffect(() => {\n    const lowercasedDebouncedTerm = debouncedSearchTerm.toLowerCase();\n    const newFilteredData = data.filter(user =>\n      user.name.toLowerCase().includes(lowercasedDebouncedTerm) ||\n      user.email.toLowerCase().includes(lowercasedDebouncedTerm)\n    );\n    setFilteredData(newFilteredData);\n    setIsSearching(false); // Filtering complete\n  }, [debouncedSearchTerm, data]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search by name or email...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ width: '300px', padding: '8px', marginBottom: '15px' }}\n      />\n      {isSearching && <p>Searching...</p>}\n      <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n        <thead>\n          <tr style={{ background: '#f2f2f2' }}>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>ID</th>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>Name</th>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>Email</th>\n          </tr>\n        </thead>\n        <tbody>\n          {filteredData.length === 0 && !isSearching && debouncedSearchTerm !== '' ? (\n            <tr>\n              <td colSpan={3} style={{ textAlign: 'center', padding: '10px' }}>No users found for \"{debouncedSearchTerm}\".</td>\n            </tr>\n          ) : filteredData.length === 0 && debouncedSearchTerm === '' ? (\n            <tr>\n              <td colSpan={3} style={{ textAlign: 'center', padding: '10px' }}>Start typing to search users.</td>\n            </tr>\n          ) : (\n            filteredData.map(user => (\n              <tr key={user.id}>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.id}</td>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.name}</td>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.email}</td>\n              </tr>\n            ))\n          )}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: Table should display all users, 'Searching...' should not be visible.",
            "Type 'a' rapidly: 'Searching...' should appear. After 300ms pause, results for 'a' (Alice, Charlie, David, Grace, Harry, Jack) should appear. 'Searching...' should disappear.",
            "Type 'al': 'Searching...' should appear. After 300ms pause, results for 'al' (Alice) should appear.",
            "Type a non-matching query (e.g., 'xyz'): 'Searching...' should appear. After 300ms pause, 'No users found.' should appear.",
            "Clear input: Table should revert to showing all users. 'Searching...' should not be visible.",
            "Rapid typing and then clearing: Ensure no stale search results appear after clearing.",
            "Input change followed by immediate component unmount: Ensure `setTimeout` is cleared to prevent memory leaks."
          ],
          "hints": [
            "You'll need two `useEffect` hooks. One to manage the debounced search term and another to perform the actual filtering.",
            "The first `useEffect` (for debouncing) should have `searchTerm` in its dependency array and use `setTimeout` with a cleanup function (`clearTimeout`).",
            "The second `useEffect` (for filtering) should have `debouncedSearchTerm` and `data` in its dependency array.",
            "Manage the `isSearching` state carefully: set it to `true` when `searchTerm` changes, and `false` after `debouncedSearchTerm` is updated (i.e., after filtering completes)."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Debouncing",
            "Performance",
            "Frontend Logic"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_functional_components",
            "javascript_timers",
            "javascript_array_methods"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Side Effects",
            "State Management",
            "Performance Optimization",
            "User Experience"
          ]
        },
        {
          "id": "task_props_1",
          "title": "Build a Flexible Card Component with Props",
          "description": "\nCreate a `Card` functional component in React that is highly configurable through its props. The component should display content dynamically based on the props it receives.\n\n**Requirements:**\n1.  The `Card` component should accept the following props:\n    *   `title: string` (required): The main title of the card.\n    *   `description: string` (required): A brief description for the card.\n    *   `imageUrl?: string` (optional): URL for an image to display at the top of the card.\n    *   `buttonText?: string` (optional): Text for a call-to-action button. If not provided, no button should be rendered.\n    *   `onButtonClick?: () => void` (optional): A callback function to be executed when the button is clicked.\n    *   `children?: React.ReactNode` (optional): Allows passing arbitrary JSX content to be rendered at the bottom of the card content area, below the description and button.\n2.  Implement conditional rendering for the image, button, and children prop.\n3.  Ensure default text for the button, if provided, is 'Learn More' when `buttonText` is an empty string or just whitespace.\n4.  Style the card minimally to make its structure clear (e.g., border, padding).\n\n**Example Usage:**\n```typescript\nfunction App() {\n  return (\n    <div>\n      <Card\n        title=\"Welcome to Our Service\"\n        description=\"Discover amazing features and services offered to you.\"\n        imageUrl=\"https://via.placeholder.com/150\"\n        buttonText=\"Explore Now\"\n        onButtonClick={() => alert('Exploring!')}\n      />\n\n      <Card\n        title=\"About Us\"\n        description=\"Learn more about our mission and values.\"\n      >\n        <p>This is additional content from the children prop!</p>\n        <p>You can put anything here.</p>\n      </Card>\n\n      <Card\n        title=\"Simple Card\"\n        description=\"No image, no button, just content.\"\n      />\n    </div>\n  );\n}\n```\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\ninterface CardProps {\n  title: string;\n  description: string;\n  imageUrl?: string;\n  buttonText?: string;\n  onButtonClick?: () => void;\n  children?: React.ReactNode;\n}\n\nexport function Card({\n  title,\n  description,\n  imageUrl,\n  buttonText,\n  onButtonClick,\n  children,\n}: CardProps) {\n  // TODO: Implement conditional rendering for imageUrl, button, and children\n  // TODO: Handle default buttonText to 'Learn More' if provided but empty/whitespace\n\n  const displayButtonText = (buttonText && buttonText.trim() !== '') ? buttonText : 'Learn More';\n\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      borderRadius: '8px',\n      padding: '20px',\n      margin: '10px',\n      maxWidth: '300px',\n      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n    }}>\n      {/* Image rendering */}\n      {imageUrl && <img src={imageUrl} alt={title} style={{ width: '100%', height: '150px', objectFit: 'cover', borderRadius: '4px' }} />}\n      \n      <h3 style={{ margin: '15px 0 10px 0' }}>{title}</h3>\n      <p style={{ fontSize: '0.9em', color: '#555', marginBottom: '15px' }}>{description}</p>\n      \n      {/* Button rendering */}\n      {(buttonText || onButtonClick) && (\n        <button\n          onClick={onButtonClick}\n          style={{\n            padding: '10px 15px',\n            backgroundColor: '#007bff',\n            color: 'white',\n            border: 'none',\n            borderRadius: '5px',\n            cursor: 'pointer',\n            marginBottom: '15px'\n          }}\n        >\n          {displayButtonText}\n        </button>\n      )}\n\n      {/* Children rendering */}\n      {children && (\n        <div style={{ marginTop: '15px', borderTop: '1px dashed #eee', paddingTop: '15px' }}>\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React from 'react';\n\ninterface CardProps {\n  title: string;\n  description: string;\n  imageUrl?: string;\n  buttonText?: string;\n  onButtonClick?: () => void;\n  children?: React.ReactNode;\n}\n\nexport function Card({\n  title,\n  description,\n  imageUrl,\n  buttonText,\n  onButtonClick,\n  children,\n}: CardProps) {\n  // Determine button display text, defaulting to 'Learn More' if buttonText is provided but empty/whitespace\n  const finalButtonText = (buttonText !== undefined && buttonText.trim() !== '') ? buttonText : 'Learn More';\n\n  // Determine if the button should be rendered at all\n  const shouldRenderButton = (buttonText !== undefined || onButtonClick !== undefined);\n\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      borderRadius: '8px',\n      padding: '20px',\n      margin: '10px',\n      maxWidth: '300px',\n      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n    }}>\n      {imageUrl && (\n        <img src={imageUrl} alt={title} style={{ width: '100%', height: '150px', objectFit: 'cover', borderRadius: '4px' }} />\n      )}\n      \n      <h3 style={{ margin: '15px 0 10px 0' }}>{title}</h3>\n      <p style={{ fontSize: '0.9em', color: '#555', marginBottom: '15px' }}>{description}</p>\n      \n      {shouldRenderButton && (\n        <button\n          onClick={onButtonClick} // onClick will be undefined if no handler provided, which is fine\n          style={{\n            padding: '10px 15px',\n            backgroundColor: '#007bff',\n            color: 'white',\n            border: 'none',\n            borderRadius: '5px',\n            cursor: 'pointer',\n            marginBottom: '15px'\n          }}\n        >\n          {finalButtonText}\n        </button>\n      )}\n\n      {children && (\n        <div style={{ marginTop: '15px', borderTop: '1px dashed #eee', paddingTop: '15px' }}>\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "testCases": [
            "Card with `title`, `description`, `imageUrl`, `buttonText`, `onButtonClick`: All elements should render correctly and button should be clickable.",
            "Card with `title`, `description`, no `imageUrl`, no `buttonText`, no `onButtonClick`: Only title and description should render.",
            "Card with `title`, `description`, and `children` prop: Title, description, and children content should render.",
            "Card with `buttonText` as empty string `\"\"`: Button should render with 'Learn More' text.",
            "Card with `buttonText` as `\"   \"` (whitespace only): Button should render with 'Learn More' text.",
            "Card with `buttonText=\"Submit\"` but no `onButtonClick`: Button should render with 'Submit' text but be non-functional (or log a warning if clicked)."
          ],
          "hints": [
            "Use logical AND (`&&`) for conditional rendering of JSX elements (e.g., `imageUrl && <img ... />`).",
            "For the button, consider a boolean variable `shouldRenderButton` that combines the checks for `buttonText` and `onButtonClick` existence.",
            "For `buttonText` default, check if it's `undefined` or if its `.trim()` length is `0`."
          ],
          "tags": [
            "React",
            "Props",
            "Conditional Rendering",
            "Component Design",
            "Flexibility"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_functional_components",
            "javascript_conditional_logic"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Reusability",
            "Children Prop"
          ]
        },
        {
          "id": "task_state_1",
          "title": "Implement a Collapsible Panel Component",
          "description": "\nCreate a `CollapsiblePanel` functional component that manages its own open/closed state. The panel should display a header and a content area that can be toggled visible/hidden.\n\n**Requirements:**\n1.  The component should be named `CollapsiblePanel`.\n2.  It should accept `title: string` for the header and `children: React.ReactNode` for the content.\n3.  Use the `useState` hook to manage the `isOpen` (boolean) state, determining whether the panel's content is visible.\n4.  The header should be clickable and toggle the `isOpen` state.\n5.  The header should visually indicate the panel's state (e.g., by changing a symbol like '►' for closed and '▼' for open).\n6.  The content area should only be rendered when `isOpen` is `true`.\n7.  Apply minimal inline styles for clarity (border, padding, pointer cursor for header).\n\n**Example Usage:**\n```typescript\nfunction App() {\n  return (\n    <CollapsiblePanel title=\"My First Section\">\n      <p>This is the content of the first collapsible section.</p>\n      <ul>\n        <li>Item 1</li>\n        <li>Item 2</li>\n      </ul>\n    </CollapsiblePanel>\n  );\n}\n```\n",
          "difficulty": "easy",
          "startingCode": "import React, { useState } from 'react';\n\ninterface CollapsiblePanelProps {\n  title: string;\n  children: React.ReactNode;\n}\n\nexport function CollapsiblePanel({ title, children }: CollapsiblePanelProps) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const togglePanel = () => {\n    // TODO: Implement toggle logic for isOpen state\n  };\n\n  const indicator = isOpen ? '▼' : '►';\n\n  return (\n    <div style={{\n      border: '1px solid #ccc',\n      borderRadius: '4px',\n      margin: '10px 0',\n      width: '300px'\n    }}>\n      <div\n        onClick={togglePanel}\n        style={{\n          padding: '10px',\n          backgroundColor: '#f0f0f0',\n          cursor: 'pointer',\n          fontWeight: 'bold',\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center'\n        }}\n      >\n        {title} <span>{indicator}</span>\n      </div>\n      {/* TODO: Conditionally render children based on isOpen */}\n      {isOpen && (\n        <div style={{ padding: '10px', borderTop: '1px solid #eee' }}>\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface CollapsiblePanelProps {\n  title: string;\n  children: React.ReactNode;\n}\n\nexport function CollapsiblePanel({ title, children }: CollapsiblePanelProps) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const togglePanel = () => {\n    setIsOpen(prevIsOpen => !prevIsOpen); // Toggles the boolean state\n  };\n\n  const indicator = isOpen ? '▼' : '►';\n\n  return (\n    <div style={{\n      border: '1px solid #ccc',\n      borderRadius: '4px',\n      margin: '10px 0',\n      width: '300px'\n    }}>\n      <div\n        onClick={togglePanel}\n        style={{\n          padding: '10px',\n          backgroundColor: '#f0f0f0',\n          cursor: 'pointer',\n          fontWeight: 'bold',\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center'\n        }}\n      >\n        {title} <span>{indicator}</span>\n      </div>\n      {isOpen && (\n        <div style={{ padding: '10px', borderTop: '1px solid #eee' }}>\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: Panel content should be hidden, header should show '►'.",
            "Click header: Panel content should become visible, header should show '▼'.",
            "Click header again: Panel content should be hidden, header should show '►'.",
            "Render with different titles and children: Verify content and title are correctly displayed when open."
          ],
          "hints": [
            "Use `useState` with a boolean initial value (e.g., `false` for closed).",
            "The `togglePanel` function should use the functional update form of `setIsOpen` (`prevIsOpen => !prevIsOpen`) to ensure correct toggling, especially if updates are batched.",
            "Conditional rendering for the `children` can be achieved using a simple logical AND (`&&`) operator (`isOpen && <div...> {children} </div>`)."
          ],
          "tags": [
            "React",
            "State",
            "useState",
            "Conditional Rendering",
            "UI Components"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Component Reusability",
            "User Interface"
          ]
        }
      ]
    }
  },
  {
    "id": "019fc46f-d6dc-4e84-94c6-f7ff512f50ef",
    "startLine": 3300,
    "endLine": 3399,
    "processedDate": "2025-06-17T08:42:15.068Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_component_props_conditional_rendering",
          "title": "React Component Props and Conditional Rendering",
          "content": "## React Component Props\nProps (short for properties) are a mechanism for passing data from a parent component to a child component in React. They are read-only, meaning a child component should not modify the props it receives. This immutability helps in maintaining a unidirectional data flow, making applications easier to understand and debug.\n\n### Key Concepts:\n-   **Unidirectional Data Flow**: Data flows down from parent to child components via props.\n-   **Read-Only**: Components must treat props as immutable. They should not modify their own props.\n-   **Passing Data**: Props are passed as attributes in JSX, similar to HTML attributes.\n-   **Accessing Props**: Inside a functional component, props are received as the first argument (an object). In class components, they are accessed via `this.props`.\n\n## Conditional Rendering\nConditional rendering in React allows you to render different elements or components based on certain conditions. This is a powerful way to create dynamic UIs that respond to changes in application state or props.\n\n### Common Techniques:\n-   **`if` statements**: Can be used outside JSX to conditionally return different components or JSX trees.\n-   **Logical `&&` operator**: If the condition is `true`, the element after `&&` will be rendered. If `false`, React ignores and skips the element. This is often used for rendering a block or element only when a certain prop or state is true.\n-   **Ternary operator (`condition ? true_expression : false_expression`)**: Allows rendering one of two different elements based on a condition, useful for inline conditional rendering where you need an `else` branch.\n-   **Element Variables**: Store elements in variables and conditionally assign them, then render the variable.\n\n### Example Scenario:\nImagine a `UserProfile` component that displays user information. Some information, like 'Administrator' status, might only show if a specific condition (e.g., `isAdmin` prop) is met.",
          "examples": [
            {
              "id": "example_props_conditional_rendering_1",
              "title": "Functional Component with Props and Conditional Rendering",
              "code": "import React from 'react';\n\nfunction UserProfile({ name, age, isAdmin }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      {isAdmin && <p>Administrator</p>} {/* Conditional rendering using logical && */}\n    </div>\n  );\n}\n\n// Usage example:\n// <UserProfile name=\"Alice\" age={25} isAdmin={true} />\n// <UserProfile name=\"Bob\" age={30} isAdmin={false} />",
              "explanation": "This `UserProfile` functional component receives `name`, `age`, and `isAdmin` as props. It uses `isAdmin && <p>Administrator</p>` to conditionally display the 'Administrator' paragraph only if the `isAdmin` prop is `true`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_props_unidirectional_data_flow_1",
            "question_conditional_rendering_mcq_1",
            "question_props_class_vs_functional_1",
            "question_conditional_rendering_logical_and_flashcard_1",
            "question_jsx_conditional_rendering_open_1"
          ],
          "relatedTasks": [
            "task_user_profile_display",
            "task_dynamic_alert_component"
          ],
          "tags": [
            "React",
            "Props",
            "Conditional Rendering",
            "JSX",
            "Functional Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_basics",
            "javascript_es6_destructuring"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "react_component_composition"
          ]
        },
        {
          "id": "theory_prop_types_default_props",
          "title": "React PropTypes and Default Props",
          "content": "## PropTypes for Type Checking\n`PropTypes` is a library used for runtime type checking of props in React components. It helps in catching bugs early by ensuring that components receive props of the expected data type. While `PropTypes` are great for development, they are often replaced by TypeScript or Flow for static type checking in larger applications, which provide type safety during compilation.\n\n### Key Concepts:\n-   **Runtime Validation**: Checks prop types when the component runs, typically in development mode.\n-   **Error Reporting**: Throws a console warning if an invalid prop type is passed.\n-   **`isRequired`**: Specifies that a prop must be provided.\n-   **Common PropTypes**: `PropTypes.string`, `PropTypes.number`, `PropTypes.bool`, `PropTypes.array`, `PropTypes.object`, `PropTypes.func`, `PropTypes.node`, `PropTypes.element`, `PropTypes.instanceOf`, `PropTypes.oneOf`, `PropTypes.oneOfType`, `PropTypes.arrayOf`, `PropTypes.objectOf`, `PropTypes.shape`, `PropTypes.exact`.\n\n## Default Props\n`defaultProps` allows you to define default values for props. If a parent component does not pass a specific prop, the component will use its default value instead. This ensures that a component always has a value for certain props, preventing `undefined` errors and making components more robust and reusable.\n\n### Key Concepts:\n-   **Fallback Values**: Provides a default value if a prop is not explicitly passed.\n-   **Readability**: Makes component usage clearer by indicating optional props and their default behavior.\n-   **Usage**: Defined as a static property on the component (for class components) or directly on the function (for functional components).",
          "examples": [
            {
              "id": "example_prop_types_default_props_1",
              "title": "PropTypes and Default Props in Functional Components",
              "code": "import PropTypes from 'prop-types';\n\nfunction UserProfile({ name, age, isAdmin }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      {isAdmin && <p>Administrator</p>}\n    </div>\n  );\n}\n\n// PropTypes for type checking\nUserProfile.propTypes = {\n  name: PropTypes.string.isRequired, // 'name' must be a string and is required\n  age: PropTypes.number,           // 'age' should be a number, optional\n  isAdmin: PropTypes.bool          // 'isAdmin' should be a boolean, optional\n};\n\n// Default props\nUserProfile.defaultProps = {\n  age: 30,         // Default age is 30 if not provided\n  isAdmin: false   // Default isAdmin is false if not provided\n};\n\n// Usage examples:\n// <UserProfile name=\"John Doe\" /> // age will be 30, isAdmin will be false\n// <UserProfile name=\"Jane Smith\" age={28} isAdmin={true} />\n// <UserProfile name={123} /> // Console warning for invalid name type in development",
              "explanation": "This example demonstrates `PropTypes` and `defaultProps` for a functional component. `name` is required and must be a string. `age` and `isAdmin` are optional, with default values if not explicitly passed.",
              "language": "typescript"
            },
            {
              "id": "example_prop_types_default_props_2",
              "title": "PropTypes and Default Props in Class Components",
              "code": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nclass UserProfileClass extends React.Component {\n  static propTypes = {\n    name: PropTypes.string.isRequired,\n    age: PropTypes.number,\n    isAdmin: PropTypes.bool\n  };\n  \n  static defaultProps = {\n    age: 30,\n    isAdmin: false\n  };\n  \n  render() {\n    const { name, age, isAdmin } = this.props;\n    return (\n      <div>\n        <h2>{name}</h2>\n        <p>Age: {age}</p>\n        {isAdmin && <p>Administrator</p>}\n      </div>\n    );\n  }\n}\n\n// Usage example:\n// <UserProfileClass name=\"Mike\" />\n// <UserProfileClass name=\"Sarah\" age={22} isAdmin={true} />",
              "explanation": "In class components, `propTypes` and `defaultProps` are defined as static properties directly on the class. The functionality remains the same as with functional components.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_prop_types_purpose_1",
            "question_default_props_use_case_1",
            "question_prop_types_vs_typescript_1",
            "question_prop_types_isrequired_flashcard_1",
            "question_prop_types_mcq_1",
            "question_default_props_priority_1"
          ],
          "relatedTasks": [
            "task_user_profile_display",
            "task_button_component_with_props_defaults"
          ],
          "tags": [
            "React",
            "PropTypes",
            "DefaultProps",
            "Type Checking",
            "Component Props"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_basics",
            "javascript_objects"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_testing",
            "react_robust_components"
          ]
        },
        {
          "id": "theory_children_prop",
          "title": "React Children Prop for Content Composition",
          "content": "## React Children Prop\nThe `children` prop is a special prop in React that allows you to pass components, elements, or any content directly into the output of another component. This is a fundamental concept for component composition, enabling the creation of flexible and reusable wrapper or layout components.\n\n### Key Concepts:\n-   **Composition**: Enables components to act as generic 'boxes' that can encapsulate and render arbitrary content passed to them.\n-   **Wrapper Components**: Commonly used for layout components (e.g., `Card`, `Modal`, `Layout`), where the wrapper provides a structure and styling, and the `children` prop renders the inner content.\n-   **Accessing `children`**: Like other props, `children` is accessed via the `props` object in functional components or `this.props` in class components.\n-   **Type of `children`**: Can be a single React element, an array of React elements, a string, a number, a boolean, or `null`/`undefined`. React provides `React.Children` utilities (e.g., `React.Children.map`, `React.Children.forEach`) for processing `children` that might be an opaque data structure.",
          "examples": [
            {
              "id": "example_children_prop_1",
              "title": "Using the Children Prop",
              "code": "import React from 'react';\n\nfunction Card({ title, children }) {\n  return (\n    <div className=\"card\">\n      {title && <h2>{title}</h2>} {/* Optionally render title */}\n      <div className=\"card-content\">\n        {children} {/* Renders whatever is passed between <Card> tags */}\n      </div>\n    </div>\n  );\n}\n\n// Usage example:\n// <Card title=\"Welcome\">\n//   <p>This is the card content.</p>\n//   <button>Click me</button>\n//   <ul>\n//     <li>Item 1</li>\n//     <li>Item 2</li>\n//   </ul>\n// </Card>\n\n// Another usage example (no title):\n// <Card>\n//   <span>Only content here.</span>\n// </Card>",
              "explanation": "The `Card` component accepts a `title` prop and a `children` prop. The `children` prop is rendered inside the `card-content` div, allowing any JSX content to be placed within the `<Card>` tags when it's used.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_children_prop_purpose_1",
            "question_children_prop_type_1",
            "question_children_prop_flexibility_1",
            "question_children_prop_wrapper_flashcard_1",
            "question_children_prop_mcq_1"
          ],
          "relatedTasks": [
            "task_dynamic_card_component",
            "task_layout_wrapper_component"
          ],
          "tags": [
            "React",
            "Children Prop",
            "Component Composition",
            "JSX",
            "Wrapper Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_basics",
            "jsx_syntax"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_hoc",
            "react_render_props_pattern"
          ]
        },
        {
          "id": "theory_react_class_component_state",
          "title": "React State in Class Components",
          "content": "## React State\nState is a built-in object within a React component that is used to contain data or information about the component. Unlike props, which are passed from parent to child and are read-only, state is internal to a component and can be changed over time. When the state of a component changes, React re-renders the component to reflect the new state, along with its child components.\n\n### Key Characteristics of State:\n-   **Internal to a Component**: State is managed within the component itself.\n-   **Mutable**: State can be changed. However, it should only be modified using `setState()` (for class components) or state hooks (for functional components). Direct modification (`this.state.count = 5`) is a common pitfall and will not trigger a re-render.\n-   **Triggers Re-renders**: Any update to the state object causes the component and its children to re-render, ensuring the UI reflects the latest data.\n-   **Asynchronous Updates**: `setState()` calls are often asynchronous for performance optimizations. React may batch multiple `setState()` calls into a single update.\n\n### Initializing State in Class Components\nState in class components is typically initialized within the constructor or using class field syntax.\n\n1.  **Using `constructor(props)`**: The traditional way to initialize state. You must call `super(props)` before accessing `this` to ensure `this.props` is correctly initialized.\n2.  **Using Class Field Syntax**: A more modern and concise way to initialize state. This syntax allows you to declare state as a class property without needing a constructor, making the code cleaner and less verbose. This feature is enabled by Babel's class properties transform and is a popular pattern.",
          "examples": [
            {
              "id": "example_class_component_state_1",
              "title": "State Initialization in Class Components (Constructor)",
              "code": "import React from 'react';\n\nclass CounterWithConstructor extends React.Component {\n  constructor(props) {\n    super(props); // Must call super(props) before anything else\n    this.state = { // Initialize state object\n      count: 0\n    };\n  }\n  \n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        {/* State updates would typically use this.setState() */}\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <CounterWithConstructor />",
              "explanation": "This `CounterWithConstructor` class component initializes its state within the constructor. `this.state` is set to an object containing `count: 0`.",
              "language": "typescript"
            },
            {
              "id": "example_class_component_state_2",
              "title": "State Initialization in Class Components (Class Field Syntax)",
              "code": "import React from 'react';\n\nclass CounterWithClassField extends React.Component {\n  state = { // State initialized directly as a class property\n    count: 0\n  };\n  \n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        {/* State updates would typically use this.setState() */}\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <CounterWithClassField />",
              "explanation": "This `CounterWithClassField` component uses the more modern class field syntax to initialize its state. This avoids the need for a constructor and `super(props)`, resulting in more concise code.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_state_purpose_1",
            "question_state_vs_props_1",
            "question_state_initialization_methods_1",
            "question_state_immutability_flashcard_1",
            "question_state_re_render_mcq_1",
            "question_state_direct_modification_1"
          ],
          "relatedTasks": [
            "task_simple_counter_class_component",
            "task_toggle_visibility_class_component"
          ],
          "tags": [
            "React",
            "State",
            "Class Components",
            "Component Lifecycle",
            "Data Management"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_basics",
            "javascript_es6_classes"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_component_lifecycle",
            "react_hooks",
            "react_context_api"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_props_unidirectional_data_flow_1",
          "topic": "React Component Props",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary characteristic of React props regarding data flow?",
          "answer": "Props are read-only and enforce a unidirectional data flow (from parent to child).",
          "options": [],
          "analysisPoints": [
            "Tests understanding of core React data flow principles.",
            "Highlights the immutability of props from the child's perspective."
          ],
          "keyConcepts": [
            "Props",
            "Unidirectional Data Flow",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Ability to recall fundamental React principles."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "Props",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_mcq_1",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React component, what will be rendered if `user.isPremium` is `false`?\n\n```jsx\nfunction UserBadge({ user }) {\n  return (\n    <div>\n      {user.name}\n      {user.isPremium && <span> (Premium User)</span>}\n    </div>\n  );\n}\n```",
          "answer": "Only the user's name will be rendered.",
          "options": [
            "Only the user's name will be rendered.",
            "The user's name followed by `false`.",
            "An empty `div`.",
            "A JavaScript error will occur."
          ],
          "analysisPoints": [
            "Tests understanding of the logical `&&` operator in JSX for conditional rendering.",
            "Confirms knowledge that `false` (or `null`, `undefined`) values are not rendered by React."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "Logical && Operator",
            "JSX"
          ],
          "evaluationCriteria": [
            "Ability to interpret JSX conditional rendering.",
            "Knowledge of how React handles falsy values."
          ],
          "example": "The logical `&&` operator works such that if the left operand (`user.isPremium`) is `false`, the right operand (`<span> (Premium User)</span>`) is not evaluated or rendered. React implicitly handles `false`, `null`, `undefined` and `true` (if a boolean is rendered directly) by not rendering them in the DOM.",
          "tags": [
            "React",
            "Conditional Rendering",
            "JSX",
            "MCQ"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_props_class_vs_functional_1",
          "topic": "React Component Props",
          "level": "easy",
          "type": "open",
          "question": "How do you access props in a functional component versus a class component in React?",
          "answer": "In a functional component, props are received as the first argument to the function. Destructuring is commonly used for convenience. For example: `function MyComponent({ prop1, prop2 }) { ... }`.\n\nIn a class component, props are accessed via `this.props`. For example: `class MyComponent extends React.Component { render() { return <p>{this.props.prop1}</p>; } }`.",
          "options": [],
          "analysisPoints": [
            "Evaluates basic syntax knowledge for both component types.",
            "Checks understanding of `this` context in class components."
          ],
          "keyConcepts": [
            "Props",
            "Functional Components",
            "Class Components",
            "Destructuring"
          ],
          "evaluationCriteria": [
            "Correctly identifying prop access methods for both component types.",
            "Clarity of explanation."
          ],
          "example": null,
          "tags": [
            "React",
            "Props",
            "Functional vs Class",
            "Syntax"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_conditional_rendering_open_1",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "open",
          "question": "Describe at least three different methods for implementing conditional rendering in React JSX, providing a small code snippet for each.",
          "answer": "1.  **Logical `&&` Operator**: Used when you want to render something only if a condition is true.\n    ```jsx\n    {isLoggedIn && <p>Welcome back!</p>}\n    ```\n\n2.  **Ternary Operator**: Used when you need to render one of two different things based on a condition (an `if-else` equivalent).\n    ```jsx\n    {isLoading ? <p>Loading...</p> : <MyDataComponent data={data} />}\n    ```\n\n3.  **Immediately Invoked Function Expression (IIFE) or Helper Function**: For more complex conditions or when you want to encapsulate logic.\n    ```jsx\n    {(() => {\n      if (user.role === 'admin') {\n        return <AdminPanel />;\n      } else if (user.role === 'editor') {\n        return <EditorPanel />;\n      } else {\n        return <GuestView />;\n      }\n    })()}\n    ```\n    Or using a helper function:\n    ```jsx\n    function renderContent() {\n      if (user.role === 'admin') return <AdminPanel />;\n      if (user.role === 'editor') return <EditorPanel />;\n      return <GuestView />;\n    }\n    return <div>{renderContent()}</div>;\n    ```",
          "options": [],
          "analysisPoints": [
            "Evaluates knowledge of common React conditional rendering patterns.",
            "Checks ability to provide practical code examples.",
            "Assesses understanding of scenarios for each method."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "JSX",
            "Logical &&",
            "Ternary Operator",
            "IIFE"
          ],
          "evaluationCriteria": [
            "Accuracy and variety of methods provided.",
            "Correctness and clarity of code snippets.",
            "Demonstration of practical application."
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "JSX",
            "Best Practices"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prop_types_purpose_1",
          "topic": "PropTypes",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `PropTypes` in React?",
          "answer": "`PropTypes` are used for runtime type checking of props passed to React components, primarily in development mode, to help catch bugs related to incorrect data types.",
          "options": [],
          "analysisPoints": [
            "Tests recall of `PropTypes`' role.",
            "Emphasizes its development-time utility."
          ],
          "keyConcepts": [
            "PropTypes",
            "Type Checking",
            "Development Tools"
          ],
          "evaluationCriteria": [
            "Ability to define `PropTypes`' function succinctly."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "PropTypes",
            "Debugging"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_default_props_use_case_1",
          "topic": "Default Props",
          "level": "medium",
          "type": "open",
          "question": "When would you use `defaultProps` in a React component, and how does it improve component reusability?",
          "answer": "`defaultProps` are used when you want to provide fallback values for props that might not always be explicitly passed by the parent component. This makes the component more robust and less prone to errors (e.g., `undefined` values).\n\nIt improves reusability by:\n1.  **Reducing Boilerplate**: Users of the component don't need to pass common or optional props every time, simplifying usage.\n2.  **Ensuring Consistency**: Guarantees that certain props always have a value, leading to predictable behavior and rendering, even if a parent forgets to pass them.\n3.  **Clearer API**: The component's interface becomes clearer, as optional props and their default behaviors are explicitly defined.",
          "options": [],
          "analysisPoints": [
            "Explains the 'why' behind `defaultProps`.",
            "Connects `defaultProps` to software design principles like reusability and robustness."
          ],
          "keyConcepts": [
            "DefaultProps",
            "Component Reusability",
            "Robustness"
          ],
          "evaluationCriteria": [
            "Understanding of `defaultProps`' practical benefits.",
            "Ability to articulate improvements in reusability."
          ],
          "example": null,
          "tags": [
            "React",
            "DefaultProps",
            "Component Design",
            "Best Practices"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prop_types_vs_typescript_1",
          "topic": "PropTypes",
          "level": "hard",
          "type": "open",
          "question": "Discuss the advantages of using TypeScript (or Flow) for type checking React props compared to `PropTypes`.",
          "answer": "While `PropTypes` provide runtime type checking in development mode, TypeScript (or Flow) offer **static type checking** during development and compilation, providing several key advantages:\n\n1.  **Early Error Detection**: TypeScript catches type errors before the code even runs, often right in the IDE, reducing development time and preventing bugs from reaching production.\n2.  **Improved Developer Experience**: IDEs provide better autocompletion, refactoring tools, and inline documentation based on static types, making coding faster and more reliable.\n3.  **Enhanced Code Readability and Maintainability**: Type definitions serve as clear documentation for component APIs, making it easier for other developers (or your future self) to understand how to use a component and what data it expects.\n4.  **No Runtime Overhead**: Unlike `PropTypes`, which add some runtime overhead (even if only in development), static type checkers do their work at compile time and are stripped out in the final bundle, resulting in smaller, faster production code.\n5.  **Stronger Guarantees**: TypeScript offers a more comprehensive type system capable of expressing complex types (e.g., union types, intersection types, generics), leading to stronger type guarantees across the entire application, not just at component boundaries.",
          "options": [],
          "analysisPoints": [
            "Compares runtime vs. static type checking.",
            "Highlights benefits for DX, maintainability, and performance.",
            "Demonstrates understanding of modern frontend development practices."
          ],
          "keyConcepts": [
            "PropTypes",
            "TypeScript",
            "Static Type Checking",
            "Runtime Type Checking",
            "Developer Experience"
          ],
          "evaluationCriteria": [
            "Depth of comparison between two type-checking mechanisms.",
            "Ability to articulate specific advantages of static typing."
          ],
          "example": null,
          "tags": [
            "React",
            "PropTypes",
            "TypeScript",
            "Type Checking",
            "Comparison"
          ],
          "prerequisites": [
            "javascript_types",
            "typescript_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_prop_types_isrequired_flashcard_1",
          "topic": "PropTypes",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `.isRequired` signify when used with a `PropTypes` definition?",
          "answer": "It signifies that the corresponding prop must be provided to the component; if not, React will issue a console warning in development mode.",
          "options": [],
          "analysisPoints": [
            "Tests recall of a specific `PropTypes` modifier."
          ],
          "keyConcepts": [
            "PropTypes",
            "isRequired",
            "Prop Validation"
          ],
          "evaluationCriteria": [
            "Correctly identifies the purpose of `isRequired`."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "PropTypes",
            "Validation"
          ],
          "prerequisites": [
            "react_prop_types_default_props"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_prop_types_mcq_1",
          "topic": "PropTypes",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following `PropTypes` definitions correctly makes the `price` prop a required number and the `currency` prop an optional string?",
          "answer": "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.number.isRequired,\n  currency: PropTypes.string\n};\n```",
          "options": [
            "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.number.isRequired,\n  currency: PropTypes.string\n};\n```",
            "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.required.number,\n  currency: PropTypes.string.optional\n};\n```",
            "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.numeric.isRequired,\n  currency: PropTypes.text\n};\n```",
            "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.number,\n  currency: PropTypes.string.isRequired\n};\n```"
          ],
          "analysisPoints": [
            "Tests knowledge of `PropTypes` syntax.",
            "Confirms understanding of `.isRequired` placement and common prop types.",
            "Distinguishes correct `PropTypes` usage from incorrect or non-existent properties."
          ],
          "keyConcepts": [
            "PropTypes",
            "isRequired",
            "Syntax"
          ],
          "evaluationCriteria": [
            "Ability to correctly apply `PropTypes` syntax for specific requirements."
          ],
          "example": "The correct option shows `PropTypes.number.isRequired` for a required number and `PropTypes.string` for an optional string. The other options contain incorrect syntax or misinterpret the requirements.",
          "tags": [
            "React",
            "PropTypes",
            "MCQ",
            "Syntax"
          ],
          "prerequisites": [
            "react_prop_types_default_props"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_default_props_priority_1",
          "topic": "Default Props",
          "level": "medium",
          "type": "code",
          "question": "Consider the following component with `defaultProps`:\n\n```jsx\nfunction Button({ text, color }) {\n  return <button style={{ backgroundColor: color }}>{text}</button>;\n}\n\nButton.defaultProps = {\n  text: 'Click Me',\n  color: 'blue'\n};\n\n// How would you render this component so that it displays 'Submit' and has a red background?\n// What would be the background color if no `color` prop is passed, but `text` is 'Go'?\n```",
          "answer": "To display 'Submit' and have a red background:\n```jsx\n<Button text=\"Submit\" color=\"red\" />\n```\n\nIf no `color` prop is passed but `text` is 'Go':\n```jsx\n<Button text=\"Go\" />\n```\nIn this case, the background color would be **'blue'**. `defaultProps` only apply when a prop is `undefined`. If a prop is explicitly passed (even `null`), `defaultProps` are overridden.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of how `defaultProps` are overridden by explicit props.",
            "Confirms knowledge of the precedence of props over default values."
          ],
          "keyConcepts": [
            "DefaultProps",
            "Props Precedence",
            "Component Usage"
          ],
          "evaluationCriteria": [
            "Correctly demonstrating how to override default props.",
            "Accurately predicting behavior when a prop is omitted."
          ],
          "example": null,
          "tags": [
            "React",
            "DefaultProps",
            "Coding"
          ],
          "prerequisites": [
            "react_prop_types_default_props"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_children_prop_purpose_1",
          "topic": "Children Prop",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `children` prop in React?",
          "answer": "The `children` prop allows components to act as generic containers and render any content passed between their opening and closing JSX tags.",
          "options": [],
          "analysisPoints": [
            "Tests recall of the `children` prop's fundamental role.",
            "Emphasizes its use for content composition."
          ],
          "keyConcepts": [
            "Children Prop",
            "Component Composition",
            "JSX"
          ],
          "evaluationCriteria": [
            "Ability to explain the `children` prop's purpose concisely."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "Children Prop",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_children_prop_type_1",
          "topic": "Children Prop",
          "level": "medium",
          "type": "open",
          "question": "What types of content can be passed as `children` to a React component?",
          "answer": "The `children` prop can be:\n-   A **single React element**: e.g., `<MyWrapper><h1>Hello</h1></MyWrapper>`\n-   An **array of React elements**: e.g., `<MyList><li>One</li><li>Two</li></MyList>`\n-   A **string or number**: e.g., `<TextWrapper>Hello World</TextWrapper>` or `<DisplayValue>{123}</DisplayValue>`\n-   A **boolean, `null`, or `undefined`**: These are generally ignored and not rendered by React, useful for conditional rendering.\n-   A **function**: Though less common for simple content, the render props pattern uses functions as children for more advanced composition.",
          "options": [],
          "analysisPoints": [
            "Tests detailed knowledge of the `children` prop's flexibility.",
            "Covers various data types and their implications."
          ],
          "keyConcepts": [
            "Children Prop",
            "JSX",
            "Data Types",
            "Render Props"
          ],
          "evaluationCriteria": [
            "Comprehensive list of content types.",
            "Accuracy of descriptions for each type."
          ],
          "example": null,
          "tags": [
            "React",
            "Children Prop",
            "JSX",
            "Advanced Topics"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_children_prop_flexibility_1",
          "topic": "Children Prop",
          "level": "medium",
          "type": "code",
          "question": "You need to create a `Panel` component that can optionally display a header and always renders content passed into it. Implement this `Panel` component and show an example of its usage where it has a header and some paragraphs as children.",
          "answer": "```jsx\nimport React from 'react';\n\nfunction Panel({ header, children }) {\n  return (\n    <div style={{\n      border: '1px solid #ccc',\n      padding: '15px',\n      borderRadius: '5px'\n    }}>\n      {header && <h3 style={{ marginTop: 0, color: '#333' }}>{header}</h3>}\n      <div style={{ padding: '10px 0' }}>\n        {children}\n      </div>\n    </div>\n  );\n}\n\n// Usage Example:\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Panel header=\"My Awesome Panel\">\n        <p>This is the first paragraph of content.</p>\n        <p>And this is the second, demonstrating `children` flexibility.</p>\n        <ul>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </ul>\n        <button>Learn More</button>\n      </Panel>\n      <br/>\n      <Panel>\n        <p>This panel has no header, only children content.</p>\n      </Panel>\n    </div>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to correctly use and render the `children` prop.",
            "Demonstrates conditional rendering of the header.",
            "Shows practical component composition."
          ],
          "keyConcepts": [
            "Children Prop",
            "Conditional Rendering",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Correct implementation of the `Panel` component.",
            "Proper usage of `children` and `header` props.",
            "Clear and runnable usage example."
          ],
          "example": null,
          "tags": [
            "React",
            "Children Prop",
            "Coding",
            "Component Design"
          ],
          "prerequisites": [
            "react_component_basics",
            "conditional_rendering"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_children_prop_wrapper_flashcard_1",
          "topic": "Children Prop",
          "level": "easy",
          "type": "flashcard",
          "question": "When building a 'wrapper' component (e.g., a layout container or a modal), which prop is most commonly used to pass the inner content?",
          "answer": "The `children` prop.",
          "options": [],
          "analysisPoints": [
            "Tests direct recall of the common use case for `children`.",
            "Connects the concept to practical component design patterns."
          ],
          "keyConcepts": [
            "Children Prop",
            "Wrapper Components",
            "Component Patterns"
          ],
          "evaluationCriteria": [
            "Correctly identifies the `children` prop for wrapper components."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "Children Prop",
            "Design Patterns"
          ],
          "prerequisites": [
            "react_children_prop"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_children_prop_mcq_1",
          "topic": "Children Prop",
          "level": "medium",
          "type": "mcq",
          "question": "Given the `Layout` component:\n\n```jsx\nfunction Layout({ title, children }) {\n  return (\n    <div className=\"container\">\n      <h1>{title}</h1>\n      <main>{children}</main>\n    </div>\n  );\n}\n\n// Which of the following uses of the Layout component will correctly render a paragraph 'Welcome!' inside the <main> tag?\n```",
          "answer": "```jsx\n<Layout title=\"My Page\">\n  <p>Welcome!</p>\n</Layout>\n```",
          "options": [
            "```jsx\n<Layout title=\"My Page\" children={<p>Welcome!</p>} />\n```",
            "```jsx\n<Layout title=\"My Page\">\n  <p>Welcome!</p>\n</Layout>\n```",
            "```jsx\n<Layout title=\"My Page\" content={<p>Welcome!</p>} />\n```",
            "```jsx\n<Layout title=\"My Page\">'Welcome!'</Layout>\n```"
          ],
          "analysisPoints": [
            "Tests understanding of the syntactic way `children` are passed in JSX.",
            "Distinguishes between passing `children` as an explicit prop vs. nested JSX."
          ],
          "keyConcepts": [
            "Children Prop",
            "JSX Syntax",
            "Component Usage"
          ],
          "evaluationCriteria": [
            "Correctly identifies the standard way to pass `children` content in JSX."
          ],
          "example": "The `children` prop is special because its content is literally what's placed between the opening and closing tags of the component (`<Layout>...</Layout>`). Option A attempts to pass `children` as a named prop, which is not the idiomatic way for the `children` prop. Option C uses a different prop name (`content`). Option D passes a string, which would render correctly but specifically asks for a *paragraph*.",
          "tags": [
            "React",
            "Children Prop",
            "MCQ",
            "Syntax"
          ],
          "prerequisites": [
            "react_children_prop"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_state_purpose_1",
          "topic": "React State",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `state` in a React component?",
          "answer": "`State` is an internal, mutable object in a component that holds data that can change over time and triggers re-renders when updated, allowing components to be dynamic.",
          "options": [],
          "analysisPoints": [
            "Tests recall of state's definition and primary function.",
            "Highlights key characteristics: internal, mutable, re-render trigger."
          ],
          "keyConcepts": [
            "State",
            "Re-render",
            "Mutability",
            "Internal Data"
          ],
          "evaluationCriteria": [
            "Ability to define `state`'s purpose clearly."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "State",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_vs_props_1",
          "topic": "React State vs Props",
          "level": "medium",
          "type": "open",
          "question": "Explain the fundamental differences between `props` and `state` in React components.",
          "answer": "**Props (Properties):**\n-   **Purpose**: Used to pass data from a parent component to a child component.\n-   **Mutability**: Are read-only. A child component cannot modify the props it receives.\n-   **Scope**: External to the component; they are inputs from the parent.\n-   **Control**: Controlled by the parent component.\n-   **Data Flow**: Unidirectional (data flows down the component tree).\n\n**State:**\n-   **Purpose**: Used to manage data that is internal to a component and can change over time.\n-   **Mutability**: Is mutable, but should only be updated using `setState()` (class components) or state hooks (functional components). Direct modification (`this.state.x = y`) will not trigger a re-render.\n-   **Scope**: Internal to the component.\n-   **Control**: Controlled by the component itself.\n-   **Data Flow**: Managed within the component, affecting its own rendering.",
          "options": [],
          "analysisPoints": [
            "Compares purpose, mutability, scope, control, and data flow.",
            "Highlights the distinct roles of `props` and `state`."
          ],
          "keyConcepts": [
            "State",
            "Props",
            "Mutability",
            "Unidirectional Data Flow",
            "Component Data Management"
          ],
          "evaluationCriteria": [
            "Comprehensive and accurate comparison of `props` and `state` attributes."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Props",
            "Comparison",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_initialization_methods_1",
          "topic": "React State (Class Components)",
          "level": "medium",
          "type": "code",
          "question": "In a React class component, demonstrate two different ways to initialize `state` with an initial `count` of `0`.",
          "answer": "1.  **Using the `constructor` method:**\n    ```jsx\n    import React from 'react';\n\n    class CounterA extends React.Component {\n      constructor(props) {\n        super(props);\n        this.state = {\n          count: 0\n        };\n      }\n\n      render() {\n        return <p>Count: {this.state.count}</p>;\n      }\n    }\n    ```\n\n2.  **Using Class Field Syntax:**\n    ```jsx\n    import React from 'react';\n\n    class CounterB extends React.Component {\n      state = {\n        count: 0\n      };\n\n      render() {\n        return <p>Count: {this.state.count}</p>;\n      }\n    }\n    ```",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of state initialization patterns in class components.",
            "Demonstrates familiarity with both older (`constructor`) and newer (class fields) syntaxes."
          ],
          "keyConcepts": [
            "State Initialization",
            "Class Components",
            "Constructor",
            "Class Fields"
          ],
          "evaluationCriteria": [
            "Correctly implements both initialization methods.",
            "Proper React class component structure."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Class Components",
            "Coding"
          ],
          "prerequisites": [
            "javascript_es6_classes"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_immutability_flashcard_1",
          "topic": "React State",
          "level": "medium",
          "type": "flashcard",
          "question": "True or False: You should directly modify `this.state` in a React class component (e.g., `this.state.count = 5`).",
          "answer": "False. You should never directly modify `this.state`. Instead, use `this.setState()` to ensure the component re-renders and React can properly manage state updates.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of state immutability principles in React.",
            "Highlights a critical best practice and common mistake."
          ],
          "keyConcepts": [
            "State Immutability",
            "setState()",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Correctly identifies the best practice for state updates."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "State",
            "Best Practices",
            "Immutability"
          ],
          "prerequisites": [
            "react_class_component_state"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_re_render_mcq_1",
          "topic": "React State",
          "level": "medium",
          "type": "mcq",
          "question": "What is the consequence of calling `this.setState()` in a React class component?",
          "answer": "It queues a re-render of the component and its children.",
          "options": [
            "It immediately re-renders the component synchronously.",
            "It only updates the state object, but doesn't trigger a re-render.",
            "It queues a re-render of the component and its children.",
            "It only re-renders the component if the state value actually changes."
          ],
          "analysisPoints": [
            "Tests understanding of `setState()`'s effect on the component lifecycle.",
            "Distinguishes synchronous vs. asynchronous behavior.",
            "Clarifies that `setState` queues a re-render regardless of value comparison (though React might optimize if values are identical, the *queueing* is the direct effect)."
          ],
          "keyConcepts": [
            "State Updates",
            "setState()",
            "Re-rendering",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Accurately describes the primary effect of `setState()`."
          ],
          "example": "Calling `this.setState()` tells React that the component's state has changed, and it needs to update the UI. React then efficiently schedules and batches these updates, leading to a re-render of the component and its subtree.",
          "tags": [
            "React",
            "State",
            "setState",
            "MCQ",
            "Lifecycle"
          ],
          "prerequisites": [
            "react_class_component_state"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_direct_modification_1",
          "topic": "React State",
          "level": "hard",
          "type": "code",
          "question": "Analyze the following React class component. Explain why directly modifying `this.state.count++` is problematic and propose a corrected version using `this.setState()`.",
          "answer": "```jsx\nimport React from 'react';\n\nclass ProblematicCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // Problematic: Direct modification of state\n    this.state.count++; \n    console.log(this.state.count); // State *is* updated here\n    // BUT, React doesn't know about this change, so it won't re-render.\n    // The UI will not reflect the new count until another state update happens.\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n}\n```\n\n**Explanation of the problem:**\nDirectly modifying `this.state.count++` is problematic because React's change detection mechanism relies on `this.setState()` to know when to re-render the component. When you directly mutate `this.state`, React doesn't detect a change, and therefore the `render()` method is not called, and the UI does not update to reflect the new state value.\n\n**Corrected Version:**\n```jsx\nimport React from 'react';\n\nclass CorrectedCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // Correct: Use setState to update state and trigger re-render\n    this.setState(prevState => ({ // Using functional setState for reliable updates\n      count: prevState.count + 1\n    }));\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n}\n```\n\n**Reason for correction:**\nBy using `this.setState()`, we explicitly tell React that the state has changed. React then re-runs the `render()` method with the updated state, ensuring the UI is synchronized with the data. Using the functional form of `setState` (`prevState => ({ ... })`) is also best practice when the new state depends on the previous state, preventing issues with asynchronous updates.",
          "options": [],
          "analysisPoints": [
            "Identifies the core issue of direct state mutation.",
            "Explains *why* direct mutation is problematic (lack of re-render trigger).",
            "Provides a correct solution using `this.setState()`.",
            "Applies best practices for `setState` (functional update).",
            "Demonstrates understanding of React's rendering lifecycle."
          ],
          "keyConcepts": [
            "State Immutability",
            "setState()",
            "Re-rendering",
            "Class Components",
            "Functional setState"
          ],
          "evaluationCriteria": [
            "Accurate diagnosis of the problem.",
            "Correct and idiomatic solution.",
            "Clear explanation of cause and effect."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Best Practices",
            "Debugging",
            "Coding"
          ],
          "prerequisites": [
            "react_class_component_state"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_user_profile_display",
          "title": "Build a User Profile Card with Dynamic Content and Validation",
          "description": "\nCreate a `UserProfileCard` React functional component that displays user information. The component should meet the following requirements:\n\n1.  Accepts `name` (string, required), `age` (number, optional), and `status` (string, optional, default to 'Active') as props.\n2.  Display the user's name in an `<h2>` tag.\n3.  Display the user's age in a `<p>` tag, but only if the `age` prop is provided and is a positive number.\n4.  Display the user's `status` in a separate `<p>` tag.\n5.  Use `PropTypes` for prop validation and `defaultProps` for default values.\n6.  If `name` is missing or not a string, the component should log an error to the console (handled by PropTypes).\n\nYour solution should demonstrate proper use of props, conditional rendering, PropTypes, and defaultProps.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction UserProfileCard({ name, age, status }) {\n  // TODO: Implement the component logic here\n  // 1. Display name\n  // 2. Conditionally display age if valid\n  // 3. Display status\n  return (\n    <div style={{\n      border: '1px solid #eee',\n      padding: '15px',\n      margin: '10px',\n      borderRadius: '8px',\n      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n    }}>\n      {/* Your JSX here */}\n    </div>\n  );\n}\n\n// TODO: Add PropTypes and defaultProps here\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <UserProfileCard name=\"Alice Wonderland\" age={30} status=\"Admin\" />\n//       <UserProfileCard name=\"Bob The Builder\" age={-5} /> {/* Invalid age, should not display */}\n//       <UserProfileCard name=\"Charlie\" /> {/* Uses default age and status */}\n//       <UserProfileCard name={123} age={25} /> {/* Type error for name via PropTypes */}\n//       <UserProfileCard age={40} /> {/* Missing required name via PropTypes */}\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction UserProfileCard({ name, age, status }) {\n  return (\n    <div style={{\n      border: '1px solid #eee',\n      padding: '15px',\n      margin: '10px',\n      borderRadius: '8px',\n      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n    }}>\n      <h2>{name}</h2>\n      {age > 0 && <p>Age: {age}</p>} {/* Conditional rendering for age */}\n      <p>Status: {status}</p>\n    </div>\n  );\n}\n\nUserProfileCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n  status: PropTypes.string\n};\n\nUserProfileCard.defaultProps = {\n  age: 30, // Default age\n  status: 'Active' // Default status\n};\n\n// Example Usage:\n// function App() {\n//   return (\n//     <div>\n//       <UserProfileCard name=\"Alice Wonderland\" age={30} status=\"Admin\" />\n//       <UserProfileCard name=\"Bob The Builder\" age={-5} /> \n//       <UserProfileCard name=\"Charlie\" /> \n//       <UserProfileCard name={123} age={25} /> \n//       <UserProfileCard age={40} /> \n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "testCases": [
            "Render with all props: `UserProfileCard name=\"Alice\" age={25} status=\"Active\"` should display all details correctly.",
            "Render with missing optional props: `UserProfileCard name=\"Bob\"` should use default age (30) and status ('Active').",
            "Render with invalid age: `UserProfileCard name=\"Charlie\" age={-10}` should display name and status, but no age.",
            "Test `isRequired` for `name`: `UserProfileCard age={20}` should log a PropTypes warning for missing name.",
            "Test type mismatch for `name`: `UserProfileCard name={123}` should log a PropTypes warning for invalid name type."
          ],
          "hints": [
            "Remember to use the `&&` operator for conditional rendering of the age if it's positive.",
            "PropTypes and defaultProps are static properties on the functional component itself.",
            "Ensure the `age` prop check (`age > 0`) is robust enough for invalid number inputs as well as undefined."
          ],
          "tags": [
            "React",
            "Props",
            "Conditional Rendering",
            "PropTypes",
            "DefaultProps",
            "Component Design"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_component_basics",
            "jsx_syntax",
            "javascript_conditional_logic"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_component_props_conditional_rendering",
            "theory_prop_types_default_props"
          ]
        },
        {
          "id": "task_button_component_with_props_defaults",
          "title": "Create a Configurable Button Component",
          "description": "\nDevelop a `Button` functional component that is highly configurable using props and sensible defaults.\n\n1.  The button should accept `label` (string, required) for its text content.\n2.  It should accept `onClick` (function, optional) for an event handler.\n3.  It should accept `variant` (string, optional) which can be 'primary', 'secondary', or 'danger'. Default to 'primary'.\n4.  It should accept `disabled` (boolean, optional). Default to `false`.\n5.  Apply basic inline styles based on the `variant`:\n    *   'primary': blue background, white text\n    *   'secondary': gray background, black text\n    *   'danger': red background, white text\n6.  Apply styles for `disabled` state: lighter background, cursor `not-allowed`.\n7.  Use `PropTypes` for validation and `defaultProps` for default values.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst BUTTON_VARIANTS = {\n  primary: { backgroundColor: 'blue', color: 'white' },\n  secondary: { backgroundColor: 'lightgray', color: 'black' },\n  danger: { backgroundColor: 'red', color: 'white' }\n};\n\nconst DISABLED_STYLE = { opacity: 0.6, cursor: 'not-allowed' };\n\nfunction Button({ label, onClick, variant, disabled }) {\n  // TODO: Implement button logic and styling based on props\n  // 1. Determine base style based on variant\n  // 2. Apply disabled style if prop is true\n  // 3. Attach onClick handler if provided and not disabled\n  \n  const baseStyle = BUTTON_VARIANTS[variant] || BUTTON_VARIANTS.primary;\n  const buttonStyle = disabled ? { ...baseStyle, ...DISABLED_STYLE } : baseStyle;\n\n  return (\n    <button \n      style={{ padding: '10px 20px', borderRadius: '5px', border: 'none', ...buttonStyle }}\n      onClick={!disabled ? onClick : undefined} // Only attach onClick if not disabled\n      disabled={disabled}\n    >\n      {label}\n    </button>\n  );\n}\n\n// TODO: Add PropTypes and defaultProps\n\n// Example Usage (for testing):\n// function App() {\n//   const handleClick = () => alert('Button clicked!');\n//   return (\n//     <div>\n//       <Button label=\"Primary Button\" onClick={handleClick} />\n//       <Button label=\"Secondary\" variant=\"secondary\" />\n//       <Button label=\"Delete\" variant=\"danger\" onClick={handleClick} disabled={false} />\n//       <Button label=\"Disabled\" disabled={true} onClick={handleClick} />\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst BUTTON_VARIANTS = {\n  primary: { backgroundColor: 'blue', color: 'white' },\n  secondary: { backgroundColor: 'lightgray', color: 'black' },\n  danger: { backgroundColor: 'red', color: 'white' }\n};\n\nconst DISABLED_STYLE = { opacity: 0.6, cursor: 'not-allowed' };\n\nfunction Button({ label, onClick, variant, disabled }) {\n  const baseStyle = BUTTON_VARIANTS[variant] || BUTTON_VARIANTS.primary;\n  const buttonStyle = disabled ? { ...baseStyle, ...DISABLED_STYLE } : baseStyle;\n\n  return (\n    <button \n      style={{ padding: '10px 20px', borderRadius: '5px', border: 'none', ...buttonStyle }}\n      onClick={!disabled ? onClick : undefined}\n      disabled={disabled}\n    >\n      {label}\n    </button>\n  );\n}\n\nButton.propTypes = {\n  label: PropTypes.string.isRequired,\n  onClick: PropTypes.func,\n  variant: PropTypes.oneOf(Object.keys(BUTTON_VARIANTS)), // Restrict variant to defined keys\n  disabled: PropTypes.bool\n};\n\nButton.defaultProps = {\n  onClick: () => {},\n  variant: 'primary',\n  disabled: false\n};\n\n// Example Usage:\n// function App() {\n//   const handleClick = () => alert('Button clicked!');\n//   return (\n//     <div>\n//       <Button label=\"Primary Button\" onClick={handleClick} />\n//       <Button label=\"Secondary\" variant=\"secondary\" />\n//       <Button label=\"Delete\" variant=\"danger\" onClick={handleClick} disabled={false} />\n//       <Button label=\"Disabled\" disabled={true} onClick={handleClick} />\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "testCases": [
            "Render a default button: `Button label=\"Submit\"` should be blue, 'Click Me' text.",
            "Render a secondary button: `Button label=\"Cancel\" variant=\"secondary\"` should be gray.",
            "Render a disabled danger button: `Button label=\"Remove\" variant=\"danger\" disabled={true}` should be red (lighter), disabled, and not trigger `onClick`.",
            "Test `onClick` functionality for an enabled button.",
            "Test `PropTypes` for an invalid `variant` (e.g., `variant=\"unknown\"`) should log a warning.",
            "Test `PropTypes` for missing required `label`."
          ],
          "hints": [
            "Use `PropTypes.oneOf` to restrict the `variant` prop to a specific set of strings.",
            "The `disabled` HTML attribute automatically prevents `onClick` but also visually disables. You might also want to conditionally apply `onClick` based on the `disabled` prop.",
            "Remember to merge styles using the spread operator (`{...style1, ...style2}`) to apply both base and disabled styles."
          ],
          "tags": [
            "React",
            "Props",
            "DefaultProps",
            "PropTypes",
            "Styling",
            "Event Handling",
            "Component Design"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_component_basics",
            "jsx_syntax",
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_component_props_conditional_rendering",
            "theory_prop_types_default_props"
          ]
        },
        {
          "id": "task_dynamic_card_component",
          "title": "Create a Flexible Card Component with Children",
          "description": "\nImplement a React functional component named `DynamicCard` that uses the `children` prop to allow flexible content.\n\n1.  The component should accept a `title` (string, required) prop for the card's header.\n2.  It should accept an optional `footer` (React Node, optional) prop for content at the bottom of the card.\n3.  The main content area of the card should be rendered using the `children` prop.\n4.  Add basic inline styling for the card, header, content, and footer areas to visually distinguish them.\n5.  Demonstrate its usage with different types of children (e.g., paragraphs, lists, buttons) and with/without the `footer`.\n\nYour solution should showcase the power of the `children` prop for layout and composition.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction DynamicCard({ title, children, footer }) {\n  // TODO: Implement the card structure\n  // 1. Render title\n  // 2. Render children in a main content area\n  // 3. Conditionally render footer\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      borderRadius: '8px',\n      padding: '20px',\n      margin: '20px',\n      boxShadow: '0 4px 8px rgba(0,0,0,0.1)'\n    }}>\n      {/* Card Header */}\n      {/* Card Content (children) */}\n      {/* Card Footer */}\n    </div>\n  );\n}\n\nDynamicCard.propTypes = {\n  title: PropTypes.string.isRequired,\n  children: PropTypes.node.isRequired, // Children should typically be required for a card\n  footer: PropTypes.node\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <DynamicCard title=\"Product Details\">\n//         <p>This is a product description.</p>\n//         <ul>\n//           <li>Feature A</li>\n//           <li>Feature B</li>\n//         </ul>\n//         <button>Add to Cart</button>\n//       </DynamicCard>\n\n//       <DynamicCard title=\"Quick Info\" footer={<span>Last updated: Today</span>}>\n//         <p>Some quick information here.</p>\n//       </DynamicCard>\n\n//       <DynamicCard title=\"Empty Card\">\n//         {/* No children content explicitly */}\n//       </DynamicCard>\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction DynamicCard({ title, children, footer }) {\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      borderRadius: '8px',\n      padding: '20px',\n      margin: '20px',\n      boxShadow: '0 4px 8px rgba(0,0,0,0.1)',\n      display: 'flex',\n      flexDirection: 'column',\n      minWidth: '300px'\n    }}>\n      <h2 style={{ marginBottom: '15px', color: '#333' }}>{title}</h2>\n      <div style={{ flexGrow: 1, marginBottom: '15px', lineHeight: '1.6' }}>\n        {children}\n      </div>\n      {footer && (\n        <div style={{\n          borderTop: '1px solid #eee',\n          paddingTop: '10px',\n          marginTop: 'auto',\n          fontSize: '0.9em',\n          color: '#666'\n        }}>\n          {footer}\n        </div>\n      )}\n    </div>\n  );\n}\n\nDynamicCard.propTypes = {\n  title: PropTypes.string.isRequired,\n  children: PropTypes.node.isRequired,\n  footer: PropTypes.node\n};\n\n// Example Usage:\n// function App() {\n//   return (\n//     <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center' }}>\n//       <DynamicCard title=\"Product Details\">\n//         <p>This is a product description.</p>\n//         <ul>\n//           <li>Feature A</li>\n//           <li>Feature B</li>\n//         </ul>\n//         <button>Add to Cart</button>\n//       </DynamicCard>\n\n//       <DynamicCard title=\"Quick Info\" footer={<span>Last updated: Today</span>}>\n//         <p>Some quick information here.</p>\n//       </DynamicCard>\n\n//       <DynamicCard title=\"Empty Card\">\n//         <p>This card has minimal content.</p>\n//       </DynamicCard>\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "testCases": [
            "Render `DynamicCard` with paragraphs and a button as `children` and no `footer`.",
            "Render `DynamicCard` with a list as `children` and a `footer` string.",
            "Render `DynamicCard` with a function (e.g., `() => <p>Dynamic content</p>`) as `children` (ensure it renders).",
            "Test `isRequired` for `title` (missing title should log a PropTypes warning).",
            "Test rendering an empty `children` (e.g., `<DynamicCard title=\"Empty\"></DynamicCard>`) should render empty content area."
          ],
          "hints": [
            "The `children` prop is automatically available to components that have content between their opening and closing tags in JSX.",
            "You can render `footer` conditionally using the logical `&&` operator.",
            "Consider using `PropTypes.node` for `children` and `footer` as they can be various types of renderable content."
          ],
          "tags": [
            "React",
            "Children Prop",
            "Component Composition",
            "Layout",
            "Styling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_component_basics",
            "jsx_syntax",
            "css_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_children_prop",
            "theory_react_component_props_conditional_rendering"
          ]
        },
        {
          "id": "task_simple_counter_class_component",
          "title": "Implement a Basic Counter Class Component",
          "description": "\nCreate a React class component called `SimpleCounter` that maintains and updates a count.\n\n1.  Initialize the component's state with `count: 0` using the class field syntax.\n2.  Display the current `count` value in a `<p>` tag.\n3.  Add a 'Increment' button. When clicked, it should increase the `count` by 1.\n4.  Add a 'Decrement' button. When clicked, it should decrease the `count` by 1.\n5.  Ensure that updating the state correctly re-renders the component.\n\nYour solution should demonstrate proper state initialization and updates in a class component.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\nclass SimpleCounter extends React.Component {\n  // TODO: Initialize state using class field syntax\n  // state = { ... };\n\n  // TODO: Implement increment and decrement methods\n  // For example: handleIncrement = () => { ... };\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', margin: '20px' }}>\n        {/* Display count */}\n        {/* Increment button */}\n        {/* Decrement button */}\n      </div>\n    );\n  }\n}\n\n// Example Usage (for testing):\n// function App() {\n//   return <SimpleCounter />;\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\n\nclass SimpleCounter extends React.Component {\n  state = {\n    count: 0\n  };\n\n  handleIncrement = () => {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  handleDecrement = () => {\n    this.setState(prevState => ({\n      count: prevState.count - 1\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', margin: '20px' }}>\n        <h2>Counter: {this.state.count}</h2>\n        <button onClick={this.handleIncrement} style={{ margin: '5px' }}>Increment</button>\n        <button onClick={this.handleDecrement} style={{ margin: '5px' }}>Decrement</button>\n      </div>\n    );\n  }\n}\n\n// Example Usage:\n// function App() {\n//   return <SimpleCounter />;\n// }\n\n// export default App;\n",
          "testCases": [
            "Initial render: `count` should be 0.",
            "Click 'Increment' button once: `count` should be 1.",
            "Click 'Increment' button multiple times: `count` should increase correctly.",
            "Click 'Decrement' button once: `count` should be 0 (if started from 1).",
            "Click 'Decrement' button multiple times: `count` should decrease correctly, potentially going negative."
          ],
          "hints": [
            "Remember to use `this.setState()` to update the `count`.",
            "For updating state based on previous state, use the functional form of `setState` (`this.setState(prevState => ({ ... }))`).",
            "Ensure `this` context is correct for event handlers (e.g., using arrow functions for class methods or binding in the constructor)."
          ],
          "tags": [
            "React",
            "State",
            "Class Components",
            "Event Handling",
            "Basic UI"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_component_basics",
            "javascript_es6_classes"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_react_class_component_state"
          ]
        },
        {
          "id": "task_toggle_visibility_class_component",
          "title": "Create a Toggleable Content Class Component",
          "description": "\nDevelop a React class component named `ToggleContent` that allows a section of content to be shown or hidden.\n\n1.  Initialize the component's state with `isVisible: false`.\n2.  Display a button that toggles the `isVisible` state. The button's text should change between 'Show Content' and 'Hide Content' based on the state.\n3.  Conditionally render a `<div>` (containing a simple paragraph like 'This is the hidden content!') based on the `isVisible` state. The content should only be visible when `isVisible` is `true`.\n4.  Ensure that clicking the button updates the state and triggers the correct conditional rendering.\n\nYour solution should demonstrate managing boolean state and applying conditional rendering in a class component.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ToggleContent extends React.Component {\n  // TODO: Initialize state with isVisible: false\n\n  // TODO: Implement toggle method\n  // handleToggle = () => { ... };\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', margin: '20px' }}>\n        {/* Button to toggle visibility */}\n        {/* Conditionally rendered content */}\n      </div>\n    );\n  }\n}\n\n// Example Usage (for testing):\n// function App() {\n//   return <ToggleContent />;\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\n\nclass ToggleContent extends React.Component {\n  state = {\n    isVisible: false\n  };\n\n  handleToggle = () => {\n    this.setState(prevState => ({\n      isVisible: !prevState.isVisible\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', margin: '20px' }}>\n        <button onClick={this.handleToggle}>\n          {this.state.isVisible ? 'Hide Content' : 'Show Content'}\n        </button>\n        \n        {this.state.isVisible && (\n          <div style={{ marginTop: '15px', padding: '10px', backgroundColor: '#f9f9f9', border: '1px dashed #eee' }}>\n            <p>This is the hidden content!</p>\n            <p>It becomes visible when the button is clicked.</p>\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\n// Example Usage:\n// function App() {\n//   return <ToggleContent />;\n// }\n\n// export default App;\n",
          "testCases": [
            "Initial render: Content should be hidden, button text should be 'Show Content'.",
            "Click 'Show Content' button: Content should appear, button text should change to 'Hide Content'.",
            "Click 'Hide Content' button: Content should disappear, button text should change back to 'Show Content'.",
            "Repeated toggling should consistently show/hide content and change button text."
          ],
          "hints": [
            "Use the logical `&&` operator or a ternary operator for conditional rendering of the content `div`.",
            "The button's text can also be conditionally rendered based on `this.state.isVisible`.",
            "Remember to use the functional form of `setState` when toggling boolean states for reliability: `this.setState(prevState => ({ isVisible: !prevState.isVisible }))`."
          ],
          "tags": [
            "React",
            "State",
            "Class Components",
            "Conditional Rendering",
            "Event Handling",
            "UI Toggle"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_class_component_state",
            "react_component_props_conditional_rendering"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_class_component_state",
            "theory_react_component_props_conditional_rendering"
          ]
        }
      ]
    }
  }
]