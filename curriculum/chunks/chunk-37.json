[
  {
    "id": "8b3ad7cc-20bc-447e-a23a-d4157e939e65",
    "startLine": 7000,
    "endLine": 7099,
    "processedDate": "2025-06-17T10:12:39.458Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_use_effect_basics_and_cleanup",
          "title": "Introduction to useEffect and Cleanup Function",
          "content": "The `useEffect` hook in React allows you to perform side effects in functional components. Side effects are operations that interact with the outside world, such as data fetching, subscriptions, manually changing the DOM, or setting up event listeners. By default, `useEffect` runs after every render of the component, but its behavior can be controlled by a dependency array.\n\nThe `useEffect` hook takes two arguments: a function containing the side effect code and an optional dependency array.\n\n```typescript\nuseEffect(() => {\n  // Side effect code here\n\n  return () => {\n    // Cleanup function (optional)\n    // This runs before the component unmounts\n    // or before the effect re-runs (if dependencies change)\n  };\n}, [dependencies]); // Dependency array\n```\n\n### Cleanup Function\n\nThe cleanup function is an optional return from the effect callback. It is crucial for preventing memory leaks and unwanted behavior. The cleanup function runs in two main scenarios:\n\n1.  **Before the component unmounts:** When the component is removed from the DOM, the cleanup function for its last effect execution is invoked.\n2.  **Before the next effect re-runs:** If the effect is scheduled to run again due to a change in its dependencies, the cleanup function from the *previous* effect execution is run before the *new* effect is executed. This ensures that any subscriptions or event listeners from the previous render are properly disposed of before new ones are set up.\n\nCommon use cases for cleanup include:\n*   Unsubscribing from external data sources (e.g., websockets, RxJS observables).\n*   Clearing timers (e.g., `setTimeout`, `setInterval`).\n*   Removing event listeners.\n*   Canceling network requests.",
          "examples": [
            {
              "id": "example_use_effect_basics_1",
              "title": "Basic Subscription with Cleanup",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Assume these functions exist for demonstration\nconst subscribeToService = (callback) => {\n  console.log('Subscribing to service...');\n  const intervalId = setInterval(() => {\n    callback(Math.random());\n  }, 1000);\n  return {\n    unsubscribe: () => {\n      console.log('Unsubscribing from service...');\n      clearInterval(intervalId);\n    }\n  };\n};\n\nfunction SubscriptionComponent() {\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    // Subscribe to some service\n    const subscription = subscribeToService(data => {\n      setData(data);\n    });\n    \n    // Cleanup function - runs before component unmounts or before next effect runs\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, []); // Empty dependency array means this effect runs once on mount and cleanup on unmount\n  \n  return (\n    <div>\n      <h2>Subscription Data</h2>\n      <p>Data: {data !== null ? data.toFixed(4) : 'Loading...'}</p>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates how `useEffect` can be used to manage subscriptions. When `SubscriptionComponent` mounts, `subscribeToService` is called, and `setData` updates the component's state with new data. The `return` function acts as the cleanup, ensuring that `subscription.unsubscribe()` is called when the component unmounts (due to the empty dependency array `[]`), preventing memory leaks from the interval.",
              "language": "typescript"
            },
            {
              "id": "example_use_effect_basics_2",
              "title": "Setting Document Title with Cleanup",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction TitleUpdater() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const originalTitle = document.title;\n    document.title = `Count is ${count}`;\n\n    // Cleanup: Restore original title when component unmounts\n    return () => {\n      document.title = originalTitle;\n    };\n  }, [count]); // Re-run effect when count changes\n\n  return (\n    <div>\n      <h3>Title Updater</h3>\n      <p>Current count: {count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>Increment Count</button>\n      <p>Check your browser tab title!</p>\n    </div>\n  );\n}",
              "explanation": "This example shows a simple side effect (modifying the document title) with a cleanup function. The effect updates the title whenever `count` changes. The cleanup function ensures that when the component unmounts, the document title is reverted to its original value, preventing permanent modification of the browser title by this component.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Side Effects",
            "Cleanup",
            "Lifecycle"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_useState"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_component_lifecycle",
            "react_data_fetching"
          ]
        },
        {
          "id": "theory_use_effect_dependencies",
          "title": "Controlling Effect Re-runs with Dependency Arrays",
          "content": "The second argument to `useEffect` is an optional array known as the **dependency array**. This array plays a crucial role in controlling when the effect function re-runs. React will re-run the effect only if any of the values in the dependency array have changed between renders. This mechanism is essential for optimizing performance and preventing infinite loops or stale closures.\n\n### How Dependency Arrays Work:\n\n*   **No dependency array (omitted):** If the dependency array is not provided, the effect runs after *every* render of the component. This is rarely what you want for performance-sensitive operations like data fetching, as it will re-fetch data on every re-render.\n    ```typescript\n    useEffect(() => {\n      console.log('Runs on every render');\n    }); // No dependency array\n    ```\n\n*   **Empty dependency array (`[]`):** If an empty array is provided, the effect runs only once after the initial render (mount) and its cleanup function runs only once before the component unmounts. This is useful for setting up subscriptions or fetching data that doesn't depend on component props or state.\n    ```typescript\n    useEffect(() => {\n      console.log('Runs only on mount');\n      return () => console.log('Cleanup runs only on unmount');\n    }, []); // Empty dependency array\n    ```\n\n*   **Dependency array with values (`[dep1, dep2]`):** The effect will re-run if any of the values in the array (`dep1`, `dep2`, etc.) change between renders. React performs a shallow comparison of these values. If an effect uses a prop or state variable, that variable should typically be included in the dependency array. Failing to do so can lead to 'stale closures', where the effect uses an outdated value of a variable from a previous render.\n    ```typescript\n    useEffect(() => {\n      console.log('Runs when dep1 or dep2 changes');\n    }, [dep1, dep2]); // Dependencies listed\n    ```\n\n### Common Pitfalls:\n\n*   **Forgetting dependencies:** If an effect uses a variable from the component scope (props, state, or functions) but that variable is not included in the dependency array, the effect might operate on outdated values (stale closure). The React linter rule `exhaustive-deps` (part of `eslint-plugin-react-hooks`) helps identify and fix this.\n*   **Including unnecessary dependencies:** Adding dependencies that don't actually change or are stable (e.g., functions memoized with `useCallback`) can cause effects to re-run more often than necessary, impacting performance.\n*   **Object/Array dependencies:** `useEffect` performs a shallow comparison. If you include an object or array directly in the dependencies, and that object/array is re-created on every render (even if its contents are the same), the effect will re-run unnecessarily. For such cases, consider memoizing the object/array (`useMemo`) or comparing specific properties. primitives are compared by value, objects by reference.\n\nUnderstanding and correctly using dependency arrays is fundamental to writing efficient and bug-free React components.",
          "examples": [
            {
              "id": "example_use_effect_dependencies_1",
              "title": "Data Fetching with Dynamic Dependency",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Mock API call\nconst fetchUser = (userId) => {\n  console.log(`Fetching user with ID: ${userId}...`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ id: userId, name: `User ${userId}`, email: `user${userId}@example.com` });\n    }, 500);\n  });\n};\n\nfunction DataFetchingExample({ userId }) {\n  const [user, setUser] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    if (!userId) return; // Prevent fetching for undefined userId\n\n    setIsLoading(true);\n    setError(null);\n    setUser(null); // Clear previous user data\n\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n\n    fetchUser(userId)\n      .then(userData => {\n        if (isMounted) {\n          setUser(userData);\n        }\n      })\n      .catch(err => {\n        if (isMounted) {\n          setError(err);\n        }\n      })\n      .finally(() => {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      });\n\n    return () => {\n      isMounted = false; // Cleanup: Mark as unmounted\n      // In a real scenario, you might cancel the fetch request here\n    };\n  }, [userId]); // Only re-run the effect if userId changes\n  \n  if (isLoading) return <div>Loading user {userId}...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!user) return <div>No user selected or found.</div>;\n\n  return (\n    <div>\n      <h3>User Profile for ID: {userId}</h3>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}",
              "explanation": "This example showcases data fetching using `useEffect` where the `userId` prop is a dependency. The effect re-runs whenever `userId` changes, triggering a new API call. The `isMounted` flag within the effect's closure is a common pattern to prevent setting state on an unmounted component, which can lead to warnings or errors in development. The cleanup function sets `isMounted` to `false` when the component unmounts or the effect re-runs, ensuring asynchronous state updates are only performed if the component is still mounted.",
              "language": "typescript"
            },
            {
              "id": "example_use_effect_dependencies_2",
              "title": "Skipping Effects Based on Dependencies",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction SkipEffectExample() {\n  const [count, setCount] = useState(0);\n  const [isActive, setIsActive] = useState(false);\n\n  // This runs on every render (no dependency array)\n  useEffect(() => {\n    console.log('Effect 1: Runs on every render (no dependencies)');\n  });\n  \n  // This runs only on mount and cleanup on unmount (empty dependency array)\n  useEffect(() => {\n    console.log('Effect 2: Runs only on mount');\n    return () => console.log('Effect 2: Cleanup for empty dependencies');\n  }, []);\n  \n  // This runs only when count changes (specific dependency)\n  useEffect(() => {\n    console.log('Effect 3: Runs when count changes. Current count:', count);\n  }, [count]);\n\n  // This runs only when isActive changes\n  useEffect(() => {\n    console.log('Effect 4: Runs when isActive changes. Is Active:', isActive);\n  }, [isActive]);\n  \n  return (\n    <div>\n      <h3>Effect Dependency Showcase</h3>\n      <button onClick={() => setCount(count + 1)}>Click to Increment Count ({count})</button>\n      <button onClick={() => setIsActive(!isActive)}>Toggle Active State ({String(isActive)})</button>\n      <p>Open console to observe effect logs.</p>\n    </div>\n  );\n}",
              "explanation": "This component demonstrates the behavior of `useEffect` with different dependency array configurations. Effect 1 runs on every render, showing its lack of control. Effect 2 runs only once on mount and cleans up on unmount, ideal for one-time setups. Effects 3 and 4 run conditionally: Effect 3 only when `count` changes, and Effect 4 only when `isActive` changes, highlighting how specific dependencies optimize re-runs.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependencies",
            "Performance",
            "Stale Closures",
            "Shallow Comparison"
          ],
          "technology": "React",
          "prerequisites": [
            "react_useState",
            "javascript_closures",
            "react_component_lifecycle"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_optimization",
            "custom_hooks"
          ]
        },
        {
          "id": "theory_multiple_use_effects",
          "title": "Using Multiple useEffect Hooks",
          "content": "React functional components can use multiple `useEffect` hooks within a single component. This is a common and recommended practice for separating concerns. Instead of lumping all side effects into one large `useEffect`, you can logically split them based on what they do or what dependencies they respond to.\n\n### Benefits of Multiple Effects:\n\n1.  **Separation of Concerns:** Each `useEffect` can be responsible for one distinct side effect. For example, one effect might handle data fetching, another might manage document title updates, and yet another might set up event listeners. This makes your code more readable, maintainable, and easier to debug.\n2.  **Cleaner Dependency Management:** Each effect can have its own, specific set of dependencies. This prevents unnecessary re-runs of unrelated effects. If you had one large `useEffect` for all side effects, you might have to include all possible dependencies, causing the entire effect to re-run even if only one small part of it actually needed to.\n3.  **Improved Readability:** It's easier to understand the purpose of smaller, focused effects.\n\nBy embracing multiple `useEffect` hooks, you adhere to the principle of single responsibility, which is a cornerstone of good software design, especially in component-based architectures like React.",
          "examples": [
            {
              "id": "example_multiple_use_effects_1",
              "title": "Separating Concerns with Multiple Effects",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction MultipleEffectsExample() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n  \n  // Effect 1: Updates document title based on count\n  // This effect focuses solely on the 'count' state\n  useEffect(() => {\n    document.title = `Count: ${count}`;\n    console.log('Document title updated:', `Count: ${count}`);\n  }, [count]); // Only re-run when count changes\n  \n  // Effect 2: Logs name changes\n  // This effect focuses solely on the 'name' state\n  useEffect(() => {\n    // Log name changes\n    console.log('Name changed to:', name);\n  }, [name]); // Only re-run when name changes\n  \n  return (\n    <div>\n      <h3>Multiple Effects Example</h3>\n      <div>\n        <label>Name: </label>\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </div>\n      <div>\n        <button onClick={() => setCount(count + 1)}>Increment Count ({count})</button>\n      </div>\n      <p>Check console for name change logs and browser tab title.</p>\n    </div>\n  );\n}",
              "explanation": "This example clearly shows how multiple `useEffect` hooks are used. One effect is dedicated to updating the document title, depending only on `count`. The other effect is dedicated to logging name changes, depending only on `name`. This separation ensures that changing the `name` does not unnecessarily trigger the title update effect, and vice-versa, leading to more efficient rendering and clearer logic.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Code Structure",
            "Best Practices",
            "Separation of Concerns"
          ],
          "technology": "React",
          "prerequisites": [
            "react_useState",
            "react_useEffect_dependencies"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "custom_hooks",
            "complex_component_design"
          ]
        },
        {
          "id": "theory_data_fetching_with_use_effect",
          "title": "Robust Data Fetching with useEffect",
          "content": "Data fetching is one of the most common side effects performed in React applications. While `useEffect` can be used for this purpose, it's important to handle asynchronous operations carefully, considering loading states, errors, and race conditions, as well as cleanup.\n\n### Key Considerations for Data Fetching:\n\n1.  **Asynchronous Nature:** Network requests are asynchronous. You'll typically use `async/await` or `Promises`.\n2.  **Loading State:** Provide feedback to the user while data is being fetched (e.g., a 'Loading...' indicator).\n3.  **Error Handling:** Implement `try...catch` or `.catch()` to gracefully handle network errors or API failures.\n4.  **Cleanup for Aborting Requests:** If a component unmounts or its dependencies change (causing the effect to re-run) while a fetch request is still in progress, you might want to abort the previous request to prevent unnecessary work and potential 'state update on unmounted component' warnings. This often involves `AbortController`.\n5.  **Race Conditions:** If dependencies change rapidly, multiple fetch requests might be in flight. The order in which they complete might not match the order they were initiated, leading to displaying stale data. A common pattern to mitigate this is using a flag (e.g., `isMounted` or `ignore`) within the effect's closure to ensure only the latest request's data updates the state.\n\nWhile `useEffect` can handle data fetching, for more complex scenarios, custom data fetching hooks (e.g., using `React Query`, `SWR`, or building your own `useFetch` hook) are often preferred for reusability, caching, and better developer experience. However, understanding the raw `useEffect` implementation is fundamental.",
          "examples": [
            {
              "id": "example_data_fetching_use_effect_1",
              "title": "Basic Data Fetching with Loading and Error States",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Mock API function\nconst fetchSomeData = async (shouldFail = false) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldFail) {\n        reject(new Error('Failed to fetch data!'));\n      } else {\n        resolve({ message: 'Data fetched successfully!', timestamp: new Date().toISOString() });\n      }\n    }, 1500);\n  });\n};\n\nfunction DataFetchingExample() {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [fetchAttempt, setFetchAttempt] = useState(0);\n  \n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    const controller = new AbortController(); // For aborting fetch requests\n    const signal = controller.signal;\n\n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null);\n      setData(null);\n\n      try {\n        // In a real scenario, you'd use 'fetch' with { signal }\n        const fetchedData = await fetchSomeData(fetchAttempt % 2 !== 0); // Simulate error on odd attempts\n        if (isMounted && !signal.aborted) { // Check if component is still mounted and request not aborted\n          setData(fetchedData);\n        }\n      } catch (err) {\n        if (isMounted && !signal.aborted) {\n          setError(err);\n        }\n      } finally {\n        if (isMounted && !signal.aborted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () => {\n      isMounted = false; // Mark component as unmounted\n      controller.abort(); // Abort any ongoing fetch requests\n      console.log('Cleanup: Aborted fetch request or component unmounted.');\n    };\n  }, [fetchAttempt]); // Re-run effect when fetchAttempt changes\n  \n  return (\n    <div>\n      <h3>Data Fetching with useEffect</h3>\n      {isLoading && <p>Loading...</p>}\n      {error && <p style={{ color: 'red' }}>Error: {error.message}</p>}\n      {data && (\n        <div>\n          <p>Message: {data.message}</p>\n          <p>Timestamp: {data.timestamp}</p>\n        </div>\n      )}\n      <button onClick={() => setFetchAttempt(prev => prev + 1)} disabled={isLoading}>\n        {isLoading ? 'Fetching...' : 'Refetch Data (Simulate Error Every Other)'}\n      </button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates a more robust data fetching setup. It uses `useState` for `data`, `isLoading`, and `error` states. The `useEffect` hook triggers the `fetchData` function when `fetchAttempt` changes. Importantly, it includes:\n1.  An `isMounted` flag to prevent state updates on unmounted components.\n2.  `AbortController` for canceling in-flight requests during cleanup or re-runs.\n3.  `try...catch` for error handling.\n4.  `finally` to always set `isLoading` to false. \n\nThis structure helps prevent common issues associated with asynchronous operations in `useEffect`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Data Fetching",
            "Asynchronous",
            "Error Handling",
            "Loading States",
            "Cleanup",
            "Race Conditions",
            "AbortController"
          ],
          "technology": "React",
          "prerequisites": [
            "react_useState",
            "react_useEffect_dependencies",
            "javascript_async_await_promises"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "custom_hooks",
            "state_management",
            "performance_optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_use_effect_basics_1",
          "topic": "useEffect Basics and Cleanup",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useEffect` hook in React?",
          "answer": "To perform side effects (e.g., data fetching, subscriptions, DOM manipulation) in functional components.",
          "analysisPoints": [
            "Identifies the core utility of `useEffect`.",
            "Distinguishes `useEffect` from pure rendering logic."
          ],
          "keyConcepts": [
            "useEffect purpose",
            "Side effects"
          ],
          "evaluationCriteria": [
            "Basic understanding of React hooks."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Basics"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_effect_basics_2",
          "topic": "useEffect Cleanup Function",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `useEffect` hook:\n\n```typescript\nuseEffect(() => {\n  console.log('Effect ran');\n  const timer = setInterval(() => {\n    console.log('Interval tick');\n  }, 1000);\n  return () => {\n    clearInterval(timer);\n    console.log('Cleanup ran');\n  };\n}, []);\n```\n\nWhen will the `console.log('Cleanup ran');` message appear in the console?",
          "answer": "Before the component unmounts.",
          "options": [
            "Before the component unmounts.",
            "After every re-render of the component.",
            "Immediately after 'Effect ran' in the same render cycle.",
            "Only if an error occurs within the effect."
          ],
          "analysisPoints": [
            "Tests understanding of `useEffect` cleanup function timing.",
            "Highlights the behavior with an empty dependency array.",
            "Distinguishes between effect execution and cleanup execution."
          ],
          "keyConcepts": [
            "useEffect cleanup",
            "Dependency array",
            "Component lifecycle"
          ],
          "evaluationCriteria": [
            "Knowledge of `useEffect` lifecycle.",
            "Understanding of cleanup mechanism.",
            "Ability to interpret code snippets."
          ],
          "example": "The cleanup function returned by `useEffect` (when an empty dependency array `[]` is provided) runs only once when the component unmounts from the DOM. If there were dependencies, it would also run before the effect re-runs due to a dependency change.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup",
            "Lifecycle",
            "MCQ"
          ],
          "prerequisites": [
            "react_useEffect_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_effect_dependencies_1",
          "topic": "Effect Dependencies",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the second argument to `useEffect` (the dependency array)?",
          "answer": "To control when the effect function re-runs, based on changes to the values within the array.",
          "analysisPoints": [
            "Defines the role of the dependency array.",
            "Explains its impact on effect execution."
          ],
          "keyConcepts": [
            "useEffect dependencies",
            "Effect re-runs"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useEffect` configuration."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependencies",
            "Basics"
          ],
          "prerequisites": [
            "react_useEffect_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_effect_dependencies_2",
          "topic": "Effect Dependencies",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React component:\n\n```typescript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect with count:', count);\n  }, [count]);\n\n  useEffect(() => {\n    console.log('Effect without dependencies');\n  });\n\n  return (\n    <button onClick={() => setCount(prev => prev + 1)}>\n      Count: {count}\n    </button>\n  );\n}\n```\n\nIf the button is clicked, incrementing `count` from 0 to 1, which `console.log` statements will be executed in the next render cycle?",
          "answer": "Both 'Effect with count: 1' and 'Effect without dependencies'.",
          "options": [
            "Only 'Effect with count: 1'.",
            "Only 'Effect without dependencies'.",
            "Both 'Effect with count: 1' and 'Effect without dependencies'.",
            "Neither will be executed."
          ],
          "analysisPoints": [
            "Tests understanding of different dependency array behaviors.",
            "Explains that omitting dependencies causes re-execution on every render.",
            "Clarifies that `[dep]` effects re-execute when `dep` changes."
          ],
          "keyConcepts": [
            "useEffect dependency array",
            "No dependency array",
            "Component re-render"
          ],
          "evaluationCriteria": [
            "Detailed understanding of `useEffect` execution flow.",
            "Ability to predict side effects based on dependencies."
          ],
          "example": "The `useEffect` without a dependency array always runs after every render. The `useEffect` with `[count]` as a dependency runs only when `count` changes. Since `count` changes from 0 to 1, both effects will run.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependencies",
            "MCQ",
            "Behavior"
          ],
          "prerequisites": [
            "react_useState",
            "react_useEffect_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_effect_dependencies_3",
          "topic": "Effect Dependencies and Stale Closures",
          "level": "hard",
          "type": "open",
          "question": "Explain the concept of 'stale closures' in the context of `useEffect` and how dependency arrays help mitigate them. Provide a code example demonstrating a stale closure and its fix.",
          "answer": "",
          "analysisPoints": [
            "Defines stale closures accurately.",
            "Explains *why* they occur with `useEffect` (capture of older state/props).",
            "Describes how dependency arrays ensure fresh values are captured.",
            "Provides a clear code example for demonstration.",
            "Presents the correct fix using dependency arrays."
          ],
          "keyConcepts": [
            "Stale closures",
            "useEffect",
            "Dependency array",
            "Closures",
            "State management"
          ],
          "evaluationCriteria": [
            "Deep understanding of JavaScript closures and React's rendering model.",
            "Ability to diagnose and fix common React bugs.",
            "Communicates technical concepts clearly with examples."
          ],
          "example": "A 'stale closure' occurs when a function (like the one passed to `useEffect`) 'closes over' or captures variables from its surrounding scope at the time it was defined, but those variables later change in subsequent renders, leading the function to operate on outdated values.\n\n**Example of Stale Closure:**\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction StaleClosureExample() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // This 'count' will always be 0 because it was captured from the initial render\n      // when the effect first ran, and the effect never re-runs.\n      console.log('Stale count (every 2s):', count);\n    }, 2000);\n\n    return () => clearInterval(intervalId);\n  }, []); // Empty array means this effect (and its closure) only runs once\n\n  return (\n    <div>\n      <h3>Stale Closure Demo</h3>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <p>Check console for 'Stale count' messages.</p>\n    </div>\n  );\n}\n```\nIn this example, `count` inside `setInterval` will always be `0` because `useEffect` only runs once due to `[]`. The `setInterval` callback 'sees' the `count` value from the very first render.\n\n**Fixing Stale Closure with Dependency Array:**\nTo fix this, `count` must be added to the dependency array. This tells React to re-run the `useEffect` whenever `count` changes, creating a new `setInterval` with a fresh `count` value (and cleaning up the old one).\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction FixedClosureExample() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // This 'count' will now be up-to-date because the effect re-runs\n      // when count changes, re-creating the interval.\n      console.log('Up-to-date count (every 2s):', count);\n    }, 2000);\n\n    return () => clearInterval(intervalId);\n  }, [count]); // <--- Added count to dependency array\n\n  return (\n    <div>\n      <h3>Fixed Closure Demo</h3>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <p>Check console for 'Up-to-date count' messages.</p>\n    </div>\n  );\n}\n```\nAlternatively, for state updates that depend on previous state, you can use the functional update form of `setCount` to avoid putting `count` in the dependency array (if `setInterval` didn't need the actual `count` value, just to increment it):\n\n```typescript\nuseEffect(() => {\n  const intervalId = setInterval(() => {\n    setCount(prevCount => prevCount + 1); // Functional update\n  }, 2000);\n\n  return () => clearInterval(intervalId);\n}, []); // Empty array is now fine, as setCount doesn't depend on 'count'\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Stale Closures",
            "Dependencies",
            "Interview Question",
            "Advanced"
          ],
          "prerequisites": [
            "javascript_closures",
            "react_useState",
            "react_useEffect_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_multiple_effects_1",
          "topic": "Multiple useEffect Hooks",
          "level": "medium",
          "type": "open",
          "question": "What are the benefits of using multiple `useEffect` hooks within a single component instead of consolidating all side effects into one large `useEffect`?",
          "answer": "",
          "analysisPoints": [
            "Highlights separation of concerns as a primary benefit.",
            "Explains how it leads to cleaner dependency management.",
            "Mentions improved readability and maintainability.",
            "Connects it to the single responsibility principle."
          ],
          "keyConcepts": [
            "Multiple useEffects",
            "Separation of concerns",
            "Dependency management",
            "Code organization"
          ],
          "evaluationCriteria": [
            "Understanding of React best practices.",
            "Ability to articulate design principles.",
            "Knowledge of `useEffect` usage patterns."
          ],
          "example": "Using multiple `useEffect` hooks within a single component offers several key benefits:\n\n1.  **Separation of Concerns:** Each `useEffect` can be dedicated to a single, distinct side effect. For example, one effect handles data fetching, another manages document title updates, and a third might deal with event listeners. This makes the code modular and easier to understand, as each block has a clear, isolated purpose.\n\n2.  **Cleaner Dependency Management:** Each effect can have its own precise set of dependencies. If an effect only depends on `userId`, it will only re-run when `userId` changes. If you combine multiple effects into one, you might end up with a large dependency array that causes the entire block of code to re-run unnecessarily, even if only one small part of it actually needed to. This leads to more efficient re-renders and better performance.\n\n3.  **Improved Readability and Maintainability:** Smaller, focused `useEffect` blocks are easier to read, understand, and debug. When a bug occurs related to a specific side effect, you can quickly locate the relevant `useEffect` hook without sifting through a large, complex block of code.\n\n4.  **Aligns with Single Responsibility Principle:** This approach adheres to the Single Responsibility Principle, a fundamental software design principle that states a module or component should have only one reason to change. Each `useEffect` hook becomes a 'reason to change' for a specific side effect.\n\nIn essence, using multiple `useEffect` hooks helps you write more organized, efficient, and maintainable React components.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Best Practices",
            "Architecture",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_useEffect_dependencies"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_data_fetching_1",
          "topic": "Data Fetching with useEffect",
          "level": "medium",
          "type": "mcq",
          "question": "When performing data fetching inside `useEffect`, why is it recommended to include a cleanup mechanism, such as using an `isMounted` flag or `AbortController`?",
          "answer": "To prevent state updates on an unmounted component and to cancel in-flight network requests, avoiding memory leaks and race conditions.",
          "options": [
            "To ensure the data is cached for future requests.",
            "To prevent state updates on an unmounted component and to cancel in-flight network requests, avoiding memory leaks and race conditions.",
            "To re-fetch data automatically when the component re-renders.",
            "To handle synchronous errors during data processing."
          ],
          "analysisPoints": [
            "Tests understanding of common pitfalls in `useEffect` data fetching.",
            "Explains the problem of setting state on unmounted components.",
            "Highlights the importance of cancelling requests.",
            "Mentions memory leaks and race conditions as consequences."
          ],
          "keyConcepts": [
            "Data fetching",
            "useEffect cleanup",
            "Race conditions",
            "Memory leaks",
            "AbortController",
            "isMounted flag"
          ],
          "evaluationCriteria": [
            "Knowledge of robust data fetching patterns in React.",
            "Understanding of asynchronous pitfalls.",
            "Ability to identify correct solutions for common issues."
          ],
          "example": "When a component initiates a data fetch but unmounts before the fetch completes, attempting to update its state (`setData`, `setIsLoading`, `setError`) can lead to warnings (in development) or even memory leaks in larger applications. An `isMounted` flag (set to `false` in cleanup) prevents these state updates. For long-running requests, `AbortController` allows you to cancel the network request itself, saving bandwidth and server resources, and preventing the promise from resolving/rejecting after the component is gone. This is crucial for preventing race conditions, where an older, slower request might resolve after a newer, faster one, overwriting the correct data with stale data.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Data Fetching",
            "Cleanup",
            "Race Conditions",
            "Memory Leaks",
            "MCQ"
          ],
          "prerequisites": [
            "react_useEffect_basics",
            "javascript_async_await_promises"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_code_identify_issue_1",
          "topic": "useEffect Dependency Array Misuse",
          "level": "hard",
          "type": "code",
          "question": "Identify the potential issue in the following React component regarding the `useEffect` hook and suggest a fix. Describe the problem (what might go wrong) and explain why your fix resolves it.\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction ProductDisplay({ productId }) {\n  const [product, setProduct] = useState(null);\n  const [viewCount, setViewCount] = useState(0);\n\n  // Assume fetchProduct simulates an API call\n  const fetchProduct = async (id) => {\n    console.log(`Fetching product ${id}`);\n    return new Promise(resolve => setTimeout(() => {\n      resolve({ id: id, name: `Product ${id}`, price: id * 10 });\n    }, 500));\n  };\n\n  useEffect(() => {\n    fetchProduct(productId).then(data => {\n      setProduct(data);\n      // This is the problematic line\n      setViewCount(viewCount + 1);\n    });\n  }, [productId]);\n\n  return (\n    <div>\n      {product ? (\n        <div>\n          <h2>{product.name}</h2>\n          <p>Price: ${product.price}</p>\n          <p>Views: {viewCount}</p>\n        </div>\n      ) : (\n        <p>Loading product...</p>\n      )}\n    </div>\n  );\n}\n```",
          "answer": "The potential issue is a 'stale closure' concerning `viewCount`. The `useEffect` hook depends only on `productId`. When `productId` changes, the effect re-runs and calls `fetchProduct`. Inside the `.then()` block, `setViewCount(viewCount + 1)` uses the `viewCount` value that was captured when this specific `useEffect` function was created. If `productId` changes rapidly, or if the user interacts with something else that causes `ProductDisplay` to re-render without `productId` changing, `viewCount` might increment based on an old value.\n\n**Problem Explanation:**\nSuppose `viewCount` is 0. `productId` changes, `useEffect` runs, `fetchProduct` is called. While `fetchProduct` is pending, `viewCount` might be updated externally (e.g., another unrelated state change re-renders the component). When `fetchProduct` resolves, `viewCount` inside the closure is still `0`, so `setViewCount(0 + 1)` makes `viewCount` 1, even if it had already been incremented by another part of the component to 2 or 3. This leads to incorrect `viewCount` values, always lagging behind or resetting.\n\n**Fix:**\nThere are two primary ways to fix this:\n\n1.  **Add `viewCount` to the dependency array:** This ensures that the `useEffect` re-runs whenever `viewCount` changes, so the closure always captures the latest `viewCount`.\n    ```typescript\n    useEffect(() => {\n      fetchProduct(productId).then(data => {\n        setProduct(data);\n        setViewCount(viewCount + 1); // This now uses the fresh viewCount\n      });\n    }, [productId, viewCount]); // <--- FIX: Added viewCount\n    ```\n    *Explanation:* This is a valid fix, but it might lead to unnecessary re-fetches if `viewCount` changes for reasons *other than* `productId` changing. This is generally less desirable as `fetchProduct` should ideally only run when `productId` changes.\n\n2.  **Use functional update for `setViewCount`:** This is the **preferred solution** when updating state based on its previous value, especially within `useEffect` or asynchronous callbacks, because it eliminates the dependency on the `viewCount` variable itself.\n    ```typescript\n    useEffect(() => {\n      fetchProduct(productId).then(data => {\n        setProduct(data);\n        // FIX: Use functional update to always get the latest state\n        setViewCount(prevCount => prevCount + 1);\n      });\n    }, [productId]); // <--- FIX: No longer needs viewCount here\n    ```\n    *Explanation:* By using `prevCount => prevCount + 1`, `setViewCount` receives the most up-to-date `viewCount` from React's state queue at the time of the update, regardless of what `viewCount` was when the effect was initially created. This keeps the `useEffect` dependent solely on `productId`, which is the correct semantic dependency for fetching a product, while correctly incrementing the view count.",
          "analysisPoints": [
            "Accurately identifies the stale closure issue.",
            "Explains the root cause (outdated variable capture).",
            "Provides two valid solutions (adding dependency, functional update).",
            "Clearly explains the pros and cons/preference for functional update.",
            "Demonstrates strong understanding of React state and `useEffect`."
          ],
          "keyConcepts": [
            "Stale closure",
            "useEffect",
            "Dependency array",
            "Functional state update",
            "Race conditions in state updates",
            "React state management"
          ],
          "evaluationCriteria": [
            "Ability to debug React state issues.",
            "Knowledge of `useEffect` best practices.",
            "Understanding of functional state updates.",
            "Clarity of explanation and solution."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Stale Closures",
            "Code Challenge",
            "Debugging",
            "Hard"
          ],
          "prerequisites": [
            "react_useState",
            "react_useEffect_dependencies",
            "javascript_async_await_promises"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_flashcard_cleanup_timing",
          "topic": "useEffect Cleanup",
          "level": "easy",
          "type": "flashcard",
          "question": "When does the cleanup function of a `useEffect` run?",
          "answer": "Before the component unmounts, and/or before the effect re-runs (if its dependencies change).",
          "analysisPoints": [
            "Covers both scenarios for cleanup execution.",
            "Emphasizes the 'before re-run' aspect."
          ],
          "keyConcepts": [
            "useEffect cleanup",
            "Component lifecycle",
            "Dependency changes"
          ],
          "evaluationCriteria": [
            "Quick recall of `useEffect` lifecycle."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup",
            "Flashcard"
          ],
          "prerequisites": [
            "react_useEffect_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_empty_deps",
          "topic": "useEffect Dependencies",
          "level": "easy",
          "type": "flashcard",
          "question": "What does an empty dependency array (`[]`) for `useEffect` signify?",
          "answer": "The effect will run only once after the initial render (component mount), and its cleanup function will run only once before the component unmounts.",
          "analysisPoints": [
            "Clearly states the 'mount-only' and 'unmount-only' behavior.",
            "Distinguishes it from no dependency array."
          ],
          "keyConcepts": [
            "useEffect empty dependency array",
            "Component mount",
            "Component unmount"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useEffect` dependency control."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependencies",
            "Flashcard"
          ],
          "prerequisites": [
            "react_useEffect_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_open_when_to_use_deps",
          "topic": "useEffect Dependency Strategies",
          "level": "medium",
          "type": "open",
          "question": "Describe the three common scenarios for `useEffect` dependency arrays (no array, empty array, array with dependencies) and provide a suitable real-world use case for each.",
          "answer": "",
          "analysisPoints": [
            "Accurately describes the behavior of each dependency array type.",
            "Provides clear and distinct real-world examples for each scenario.",
            "Demonstrates understanding of when to apply each strategy.",
            "Explains the implications (e.g., performance, side effects) of each choice."
          ],
          "keyConcepts": [
            "useEffect dependency array scenarios",
            "No dependency array",
            "Empty dependency array",
            "Specific dependencies",
            "Use cases"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of `useEffect` flexibility.",
            "Ability to apply theoretical knowledge to practical situations.",
            "Clarity and completeness of explanations."
          ],
          "example": "**1. No Dependency Array (omitted): `useEffect(() => { /* ... */ });`**\n*   **Behavior:** The effect runs after *every* render of the component.\n*   **Use Case:** This is generally **discouraged** for performance-sensitive operations or operations with cleanup, as it can lead to infinite loops or unnecessary re-runs. It's rare to need this. A very niche example might be logging component re-renders for debugging purposes, where you explicitly want to see something happen on every update.\n    ```typescript\n    useEffect(() => {\n      // Very rarely useful, perhaps for pure debugging logs\n      console.log('Component re-rendered!');\n    });\n    ```\n\n**2. Empty Dependency Array (`[]`): `useEffect(() => { /* ... */ }, []);`**\n*   **Behavior:** The effect runs only once after the initial render (component mount), and its cleanup function runs only once before the component unmounts.\n*   **Use Case:** Ideal for setting up subscriptions, initializing third-party libraries, or fetching data that only needs to be loaded once throughout the component's lifecycle and doesn't depend on any props or state that change during its lifetime. \n    *Example:* Setting up a WebSocket connection.\n    ```typescript\n    useEffect(() => {\n      const socket = new WebSocket('ws://localhost:8080');\n      socket.onmessage = (event) => console.log('Received:', event.data);\n      return () => socket.close(); // Close connection on unmount\n    }, []); // Runs once on mount, cleans up on unmount\n    ```\n\n**3. Dependency Array with Values (`[dep1, dep2]`): `useEffect(() => { /* ... */ }, [dep1, dep2]);`**\n*   **Behavior:** The effect re-runs only if any of the values in the dependency array change between renders. The cleanup function for the *previous* effect runs before the *new* effect is executed.\n*   **Use Case:** This is the most common and versatile scenario. It's used when your side effect depends on specific props, state variables, or functions that might change over time. \n    *Example:* Fetching user data based on a `userId` prop.\n    ```typescript\n    useEffect(() => {\n      if (!userId) return; // Prevent fetch if userId is null/undefined\n      console.log(`Fetching user ${userId}...`);\n      // fetchUser(userId).then(data => setUser(data));\n      // (Add cleanup and error handling for production code)\n    }, [userId]); // Re-runs whenever userId changes\n    ```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependencies",
            "Use Cases",
            "Interview Question"
          ],
          "prerequisites": [
            "react_useEffect_basics",
            "react_useEffect_cleanup"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_timer_with_cleanup",
          "title": "Implement a Countdown Timer with Proper Cleanup",
          "description": "\nCreate a React component `CountdownTimer` that displays a countdown from a given initial time down to 0. The timer should update every second. Crucially, the component must properly clean up the interval when it unmounts to prevent memory leaks.\n\n**Requirements:**\n1.  The component should accept an `initialSeconds` prop (number).\n2.  Display the remaining time in seconds.\n3.  Decrement the time every second.\n4.  Stop the countdown when it reaches 0.\n5.  Implement `useEffect` to manage the `setInterval`.\n6.  Ensure the `setInterval` is cleared when the component unmounts or if `initialSeconds` changes (though for this specific task, assume `initialSeconds` only sets the starting point on mount).\n7.  Display 'Time's up!' when the countdown finishes.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction CountdownTimer({ initialSeconds }) {\n  const [seconds, setSeconds] = useState(initialSeconds);\n\n  useEffect(() => {\n    // TODO: Implement the countdown logic\n    // 1. Set up an interval that decrements 'seconds' every 1000ms.\n    // 2. Clear the interval when 'seconds' reaches 0 or when the component unmounts.\n\n    return () => {\n      // TODO: Implement cleanup\n    };\n  }, [/* TODO: Add necessary dependencies */]);\n\n  return (\n    <div>\n      <h2>Countdown Timer</h2>\n      {seconds > 0 ? (\n        <p>Time remaining: {seconds} seconds</p>\n      ) : (\n        <p>Time's up!</p>\n      )}\n    </div>\n  );\n}\n\n// Example usage:\n// function App() {\n//   return <CountdownTimer initialSeconds={10} />;\n// }\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction CountdownTimer({ initialSeconds }) {\n  const [seconds, setSeconds] = useState(initialSeconds);\n\n  useEffect(() => {\n    if (seconds <= 0) return; // Prevent setting interval if already 0 or less\n\n    const intervalId = setInterval(() => {\n      setSeconds(prevSeconds => {\n        if (prevSeconds <= 1) {\n          // If the next second would be 0 or less, clear interval and set to 0\n          clearInterval(intervalId);\n          return 0;\n        }\n        return prevSeconds - 1;\n      });\n    }, 1000);\n\n    // Cleanup function: clear the interval when component unmounts\n    // or when the effect re-runs (e.g., if initialSeconds were a dependency).\n    return () => {\n      console.log('Cleanup: Clearing interval', intervalId);\n      clearInterval(intervalId);\n    };\n  }, [initialSeconds]); // Dependency on initialSeconds to reset timer if prop changes\n\n  useEffect(() => {\n    // A separate effect to handle stopping the timer when seconds reach 0\n    // This ensures cleanup happens even if the component doesn't unmount\n    // but the timer completes naturally.\n    if (seconds === 0) {\n      console.log('Countdown finished naturally.');\n    }\n  }, [seconds]);\n\n  return (\n    <div>\n      <h2>Countdown Timer</h2>\n      {seconds > 0 ? (\n        <p>Time remaining: {seconds} seconds</p>\n      ) : (\n        <p>Time's up!</p>\n      )}\n    </div>\n  );\n}\n",
          "testCases": [
            "Renders with initial time: `initialSeconds={5}` should show `Time remaining: 5 seconds`.",
            "Decrements correctly: After 1 second, `initialSeconds={3}` should show `Time remaining: 2 seconds`.",
            "Stops at zero: `initialSeconds={2}` should show `Time's up!` after 2 seconds.",
            "Cleans up on unmount: Verify `clearInterval` is called when the `CountdownTimer` component is removed from the DOM (e.g., by conditionally rendering it).",
            "Handles `initialSeconds={0}`: Should immediately show `Time's up!` and not start an interval."
          ],
          "hints": [
            "Remember that `setInterval` returns an ID that you need to use with `clearInterval`.",
            "The `return` function inside `useEffect` is where you put your cleanup logic.",
            "Consider using a functional update for `setSeconds` to avoid `seconds` in the dependency array, making the interval always use the latest state.",
            "Think about what should happen when `seconds` reaches `0`  should the interval still be running?"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup",
            "Timers",
            "State Management"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_useState",
            "react_useEffect_basics",
            "react_useEffect_cleanup",
            "javascript_timers"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "component_lifecycle",
            "memory_management"
          ]
        },
        {
          "id": "task_user_profile_refetch",
          "title": "Dynamic User Profile Fetcher",
          "description": "\nCreate a React component `UserProfile` that fetches and displays user details. The component should re-fetch user data whenever the `userId` prop changes. Handle loading and error states appropriately.\n\n**Requirements:**\n1.  The component accepts a `userId` prop (string or number).\n2.  It should display 'Loading...' while fetching data.\n3.  If an error occurs during fetching, display an error message.\n4.  Once data is fetched, display the user's name and email.\n5.  Use `useEffect` for data fetching, ensuring it re-runs only when `userId` changes.\n6.  Implement a cleanup mechanism to prevent setting state on an unmounted component or if a new fetch is initiated before the previous one completes (race condition).\n\n**Mock API:**\n```typescript\n// Simulate an API call\nconst mockFetchUser = (id) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id === 'error') {\n        reject(new Error('Failed to load user data.'));\n      } else if (id === null || id === undefined || id === '') {\n        resolve(null); // No user found for null/empty ID\n      } else {\n        resolve({ id: id, name: `User ${id}`, email: `user${id}@example.com` });\n      }\n    }, 700);\n  });\n};\n```\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nconst mockFetchUser = (id) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id === 'error') {\n        reject(new Error('Failed to load user data.'));\n      } else if (id === null || id === undefined || id === '') {\n        resolve(null); \n      } else {\n        resolve({ id: id, name: `User ${id}`, email: `user${id}@example.com` });\n      }\n    }, 700);\n  });\n};\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // TODO: Implement data fetching logic\n    // 1. Set loading state.\n    // 2. Clear previous error/data.\n    // 3. Handle cases where userId is invalid/empty (no fetch needed).\n    // 4. Call mockFetchUser and update state with result.\n    // 5. Handle errors and loading completion.\n    // 6. Implement cleanup for race conditions (e.g., isMounted flag).\n\n    return () => {\n      // TODO: Implement cleanup\n    };\n  }, [/* TODO: Add dependencies */]);\n\n  if (isLoading) {\n    return <div>Loading user {userId}...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (!user) {\n    return <div>No user selected or found.</div>;\n  }\n\n  return (\n    <div>\n      <h3>User Profile (ID: {userId})</h3>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}\n\n// Example usage in parent component:\n// function App() {\n//   const [currentUserId, setCurrentUserId] = useState('1');\n//   return (\n//     <div>\n//       <button onClick={() => setCurrentUserId('1')}>Load User 1</button>\n//       <button onClick={() => setCurrentUserId('2')}>Load User 2</button>\n//       <button onClick={() => setCurrentUserId('error')}>Load Error User</button>\n//       <button onClick={() => setCurrentUserId('')}>Clear User</button>\n//       <UserProfile userId={currentUserId} />\n//     </div>\n//   );\n// }\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nconst mockFetchUser = (id) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id === 'error') {\n        reject(new Error('Failed to load user data.'));\n      } else if (id === null || id === undefined || id === '') {\n        resolve(null); \n      } else {\n        resolve({ id: id, name: `User ${id}`, email: `user${id}@example.com` });\n      }\n    }, 700);\n  });\n};\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    // In a real scenario, you'd use AbortController here for fetch API\n\n    const fetchData = async () => {\n      // Don't fetch if userId is effectively empty\n      if (!userId) {\n        if (isMounted) {\n          setUser(null);\n          setIsLoading(false);\n          setError(null);\n        }\n        return;\n      }\n\n      setIsLoading(true);\n      setError(null);\n      setUser(null); // Clear previous user data while loading new one\n\n      try {\n        const userData = await mockFetchUser(userId);\n        if (isMounted) { // Only update state if component is still mounted\n          setUser(userData);\n        }\n      } catch (err) {\n        if (isMounted) {\n          setError(err);\n        }\n      } finally {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () => {\n      isMounted = false; // Set flag to false when component unmounts or effect re-runs\n      console.log(`Cleanup for userId: ${userId} - isMounted set to false`);\n      // In a real fetch, you would controller.abort() here\n    };\n  }, [userId]); // Re-run effect only when userId changes\n\n  if (isLoading) {\n    return <div>Loading user {userId}...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (!user) {\n    return <div>No user selected or found.</div>;\n  }\n\n  return (\n    <div>\n      <h3>User Profile (ID: {userId})</h3>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}\n",
          "testCases": [
            "Renders 'Loading...' initially for `userId='1'`.",
            "Displays User 1's data after loading completes for `userId='1'`.",
            "Switches to 'Loading...' and then User 2's data when `userId` changes from '1' to '2'.",
            "Displays an error message for `userId='error'`.",
            "Displays 'No user selected or found.' for `userId=''` or `userId={null}`.",
            "Verify cleanup prevents state update warnings when `userId` changes rapidly (simulated by quickly clicking buttons that change `userId`)."
          ],
          "hints": [
            "The `userId` prop should be in the dependency array of `useEffect`.",
            "Inside the effect, set `isLoading` to true before fetching and false after (in a `finally` block).",
            "Clear `error` and `user` state before a new fetch to show loading state correctly.",
            "Use an `isMounted` boolean flag inside the effect's closure to prevent state updates on unmounted components. Set it to `false` in the cleanup function.",
            "For a real API, consider `AbortController` in the cleanup for cancelling in-flight requests."
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Data Fetching",
            "Asynchronous",
            "Loading States",
            "Error Handling",
            "Cleanup",
            "Race Conditions"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_useState",
            "react_useEffect_dependencies",
            "javascript_async_await_promises"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "api_integration",
            "custom_hooks",
            "error_boundaries"
          ]
        },
        {
          "id": "task_component_dashboard",
          "title": "Interactive Dashboard with Multiple Effects",
          "description": "\nBuild a `Dashboard` component that showcases the use of multiple `useEffect` hooks for different concerns: document title updates, logging user interactions, and fetching a configuration.\n\n**Requirements:**\n1.  **Count Feature:** Implement a counter that increments on a button click.\n    *   Use a `useEffect` to update the document title to `Dashboard - Count: [current_count]` whenever the count changes.\n2.  **User Input Logging:** Implement an input field for a 'User Name'.\n    *   Use a separate `useEffect` to `console.log` the new name whenever the 'User Name' input changes.\n3.  **Initial Configuration Fetch:** Simulate fetching a configuration object (`{ theme: 'dark', itemsPerPage: 10 }`) once when the component mounts.\n    *   Use another `useEffect` for this, ensuring it runs only once and handles loading/error states.\n    *   Display the fetched configuration details.\n\nDemonstrate clear separation of concerns in your `useEffect` implementations.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nconst mockFetchConfig = () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ theme: 'dark', itemsPerPage: 10, greeting: 'Welcome to the Dashboard!' });\n    }, 800);\n  });\n};\n\nfunction Dashboard() {\n  const [count, setCount] = useState(0);\n  const [userName, setUserName] = useState('');\n  const [config, setConfig] = useState(null);\n  const [isConfigLoading, setIsConfigLoading] = useState(true);\n  const [configError, setConfigError] = useState(null);\n\n  // TODO: Effect for updating document title based on count\n  useEffect(() => {\n    // Implement title update logic here\n  }, [/* dependencies */]);\n\n  // TODO: Effect for logging user name changes\n  useEffect(() => {\n    // Implement logging logic here\n  }, [/* dependencies */]);\n\n  // TODO: Effect for fetching initial configuration\n  useEffect(() => {\n    // Implement config fetching logic here\n  }, [/* dependencies */]);\n\n  return (\n    <div>\n      <h1>My Dashboard</h1>\n\n      {/* Count Feature */}\n      <section>\n        <h2>Count Feature</h2>\n        <p>Current Count: {count}</p>\n        <button onClick={() => setCount(prev => prev + 1)}>Increment Count</button>\n        <p>Check browser tab title.</p>\n      </section>\n\n      {/* User Input Logging */}\n      <section>\n        <h2>User Input Logger</h2>\n        <label>User Name: </label>\n        <input \n          type=\"text\" \n          value={userName} \n          onChange={(e) => setUserName(e.target.value)} \n          placeholder=\"Enter your name\"\n        />\n        <p>Check browser console for name logs.</p>\n      </section>\n\n      {/* Initial Configuration */}\n      <section>\n        <h2>Dashboard Configuration</h2>\n        {isConfigLoading && <p>Loading configuration...</p>}\n        {configError && <p style={{ color: 'red' }}>Error: {configError.message}</p>}\n        {config && (\n          <div>\n            <p>Theme: {config.theme}</p>\n            <p>Items per page: {config.itemsPerPage}</p>\n            <p>Greeting: {config.greeting}</p>\n          </div>\n        )}\n      </section>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nconst mockFetchConfig = () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ theme: 'dark', itemsPerPage: 10, greeting: 'Welcome to the Dashboard!' });\n    }, 800);\n  });\n};\n\nfunction Dashboard() {\n  const [count, setCount] = useState(0);\n  const [userName, setUserName] = useState('');\n  const [config, setConfig] = useState(null);\n  const [isConfigLoading, setIsConfigLoading] = useState(true);\n  const [configError, setConfigError] = useState(null);\n\n  // Effect 1: Updates document title based on count\n  useEffect(() => {\n    const originalTitle = document.title; // Capture original title for cleanup\n    document.title = `Dashboard - Count: ${count}`;\n    console.log('Document title updated:', `Dashboard - Count: ${count}`);\n\n    return () => {\n      document.title = originalTitle; // Cleanup: restore original title on unmount\n    };\n  }, [count]); // Re-run when count changes\n\n  // Effect 2: Logs user name changes\n  useEffect(() => {\n    // Prevent logging on initial render if userName is empty\n    if (userName) {\n      console.log('User Name changed to:', userName);\n    }\n  }, [userName]); // Re-run when userName changes\n\n  // Effect 3: Fetches initial configuration once on mount\n  useEffect(() => {\n    let isMounted = true; // Flag for preventing state updates on unmounted component\n    setIsConfigLoading(true);\n    setConfigError(null);\n\n    mockFetchConfig()\n      .then(fetchedConfig => {\n        if (isMounted) {\n          setConfig(fetchedConfig);\n        }\n      })\n      .catch(err => {\n        if (isMounted) {\n          setConfigError(err);\n        }\n      })\n      .finally(() => {\n        if (isMounted) {\n          setIsConfigLoading(false);\n        }\n      });\n\n    return () => {\n      isMounted = false; // Cleanup: mark component as unmounted\n      // In a real scenario, you'd abort the fetch request here\n    };\n  }, []); // Empty dependency array: runs only once on mount\n\n  return (\n    <div>\n      <h1>My Dashboard</h1>\n\n      {/* Count Feature */}\n      <section style={{ border: '1px solid #ccc', padding: '15px', margin: '10px 0' }}>\n        <h2>Count Feature</h2>\n        <p>Current Count: {count}</p>\n        <button onClick={() => setCount(prev => prev + 1)}>Increment Count</button>\n        <p style={{ fontSize: '0.9em', color: '#666' }}>Check browser tab title.</p>\n      </section>\n\n      {/* User Input Logging */}\n      <section style={{ border: '1px solid #ccc', padding: '15px', margin: '10px 0' }}>\n        <h2>User Input Logger</h2>\n        <label>User Name: </label>\n        <input \n          type=\"text\" \n          value={userName} \n          onChange={(e) => setUserName(e.target.value)} \n          placeholder=\"Enter your name\"\n        />\n        <p style={{ fontSize: '0.9em', color: '#666' }}>Check browser console for name logs.</p>\n      </section>\n\n      {/* Initial Configuration */}\n      <section style={{ border: '1px solid #ccc', padding: '15px', margin: '10px 0' }}>\n        <h2>Dashboard Configuration</h2>\n        {isConfigLoading && <p>Loading configuration...</p>}\n        {configError && <p style={{ color: 'red' }}>Error: {configError.message}</p>}\n        {config && (\n          <div>\n            <p>Theme: <strong>{config.theme}</strong></p>\n            <p>Items per page: <strong>{config.itemsPerPage}</strong></p>\n            <p>Greeting: <em>{config.greeting}</em></p>\n          </div>\n        )}\n      </section>\n    </div>\n  );\n}\n",
          "testCases": [
            "Document title updates: When 'Increment Count' button is clicked, the browser tab title should reflect the new count.",
            "Name logging: Typing into the 'User Name' input field should produce `console.log` messages in the browser console for each change.",
            "Config loading: Upon initial render, 'Loading configuration...' should be displayed.",
            "Config display: After a short delay, the fetched configuration details (theme, items per page, greeting) should be displayed.",
            "Interactions are independent: Changing the count should not trigger the name logging effect, and changing the name should not trigger the title update effect."
          ],
          "hints": [
            "Remember that each `useEffect` can have its own dependency array, making them independent.",
            "For updating the document title, the `document.title` property can be directly manipulated.",
            "For initial data fetching, an empty dependency array (`[]`) is appropriate.",
            "Don't forget to handle the cleanup for the document title to restore it when the component unmounts (or a different title is set).",
            "Consider an `isMounted` flag for the configuration fetch to prevent errors if the component unmounts before the fetch completes."
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Multiple Effects",
            "Separation of Concerns",
            "Data Fetching",
            "State Management",
            "Best Practices"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_useState",
            "react_useEffect_basics",
            "react_useEffect_dependencies",
            "javascript_async_await_promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "component_design",
            "application_architecture",
            "custom_hooks"
          ]
        }
      ]
    }
  },
  {
    "id": "b1122714-e010-4527-9dbe-583fbd983829",
    "startLine": 7100,
    "endLine": 7199,
    "processedDate": "2025-06-17T10:15:15.574Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_async_data_fetching_react",
          "title": "Asynchronous Data Fetching and State Management in React",
          "content": "## Core Concepts of Asynchronous Operations in React\n\nWhen building dynamic web applications with React, interacting with external APIs to fetch or send data is a common requirement. These operations are asynchronous, meaning they don't block the main thread and their results are not immediately available. Proper state management is crucial to provide a good user experience by showing loading indicators, displaying fetched data, and gracefully handling errors.\n\n### Essential States for Asynchronous Operations\nTo manage the lifecycle of an asynchronous request, it's standard practice to maintain at least three pieces of state:\n\n*   `isLoading` (or `loading`): A boolean flag indicating whether an asynchronous operation is currently in progress. This is used to display a loading spinner or message.\n*   `data` (or specific data name like `news`, `users`): Holds the successfully fetched data. Initially null or an empty array/object.\n*   `error`: Stores any error message or object if the request fails. Initially null.\n\nThese states allow for conditional rendering of different UI elements based on the current status of the data fetching process.\n\n### Data Fetching with the `fetch` API\n\nThe `fetch` API is a modern, promise-based JavaScript interface for making network requests. It's built into most browsers and is commonly used in React applications. The `fetch` function returns a `Promise` that resolves to the `Response` object representing the response to your request. \n\nKey aspects of `fetch`:\n*   **Promise-based**: `fetch` returns a Promise. You handle its resolution or rejection using `.then()` and `.catch()`, or with `async/await`.\n*   **`Response.ok`**: The `response.ok` property is a boolean indicating whether the HTTP status code is in the 200-299 range. It's crucial to check this, as `fetch` *does not* reject the promise on HTTP error statuses (like 404 or 500) unless there's a network error or a malformed request. You must explicitly throw an error if `response.ok` is false.\n*   **`response.json()`**: To extract the JSON body content from the `Response` object, you call `response.json()`. This also returns a Promise that resolves with the parsed JSON data.\n\n### Asynchronous Data Fetching in Functional Components with `useEffect`\n\nFunctional components utilize the `useEffect` hook to perform side effects, such as data fetching. The `useEffect` hook accepts two arguments: a function containing the effect logic and an optional dependency array. When the dependency array is empty (`[]`), the effect runs only once after the initial render, mimicking `componentDidMount`.\n\n`async/await` syntax provides a more synchronous-looking way to write asynchronous code, making it easier to read and debug compared to deeply nested `.then()` chains. It must be used inside an `async` function. Since `useEffect`'s callback cannot be directly `async`, an `async` function is typically defined inside the effect and then called immediately.\n\n**Lifecycle Flow (Functional Component):**\n1.  Component mounts.\n2.  `useEffect` runs.\n3.  `setIsLoading(true)`.\n4.  `fetch` request is initiated.\n5.  **Success Path**: `response.ok` is true. `response.json()` is parsed. `setData(result)` and `setError(null)` are called. `finally` block executes `setIsLoading(false)`.\n6.  **Error Path**: `response.ok` is false or a network error occurs. The `catch` block executes. `setError(err.message)` and `setData(null)` are called. `finally` block executes `setIsLoading(false)`.\n7.  Component re-renders as state changes.\n\n### Asynchronous Data Fetching in Class Components with `componentDidMount`\n\nClass components use lifecycle methods to manage side effects. `componentDidMount()` is specifically designed for effects that should run once after the component has been mounted to the DOM. This is the ideal place to initiate API calls.\n\nPromises (`.then()`, `.catch()`) are used to handle the asynchronous nature of `fetch` in class components. The `.then()` method is called when the Promise resolves (success), and `.catch()` is called when the Promise rejects (error).\n\n**Lifecycle Flow (Class Component):**\n1.  Component mounts.\n2.  `componentDidMount` runs.\n3.  `this.setState({ isLoading: true })`.\n4.  `fetch` request is initiated.\n5.  **Success Path**: The first `.then()` checks `response.ok` and parses JSON. The second `.then()` updates `this.state` with `news: data` and `isLoading: false`.\n6.  **Error Path**: If `!response.ok` or a network error, the `.catch()` block executes. `this.setState` updates `error: error.message` and `isLoading: false`.\n7.  Component re-renders as state changes.\n\n### Conditional Rendering\nBoth component types use conditional rendering to display different UI based on the state. The order of conditions is important:\n1.  `isLoading`: Display loading state first.\n2.  `error`: Display error message if an error occurred.\n3.  `!data` (or `data.length === 0`): Display no data message if no data was retrieved or it's empty.\n4.  `data`: Render the actual data when available.\n\nThis ensures a clear and predictable user experience during data fetching.\n\n### Image References\nNone in the provided markdown.",
          "examples": [
            {
              "id": "example_functional_fetch_data",
              "title": "Functional Component Data Fetching with useEffect and async/await",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction FetchDataComponent() {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setIsLoading(true);\n      try {\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n        setError(null);\n      } catch (err) {\n        setError(err.message);\n        setData(null);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, []); // Empty dependency array means this effect runs once on mount\n  \n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!data) return <div>No data found</div>; // Check for null or empty data\n  \n  return (\n    <div>\n      <h2>Data:</h2>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates fetching data in a functional React component using the `useEffect` hook and `async/await` syntax. The `useState` hook manages `data`, `isLoading`, and `error` states. The `useEffect` with an empty dependency array ensures the data is fetched only once when the component mounts. The `try...catch...finally` block handles successful data retrieval, errors, and ensures the loading state is reset regardless of the outcome. Conditional rendering displays different UI based on the `isLoading`, `error`, and `data` states.",
              "language": "typescript"
            },
            {
              "id": "example_class_fetch_data",
              "title": "Class Component Data Fetching with componentDidMount and Promises",
              "code": "import React from 'react';\n\nclass NewsContainer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      news: [],      // Will hold the data from the API\n      isLoading: false, // Tracks if a request is in progress\n      error: null   // Stores any error that occurs\n    };\n  }\n  \n  componentDidMount() {\n    this.setState({ isLoading: true });\n    \n    fetch('https://api.example.com/news')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({\n          news: data,\n          isLoading: false\n        });\n      })\n      .catch(error => {\n        this.setState({\n          error: error.message,\n          isLoading: false\n        });\n      });\n  }\n  \n  render() {\n    const { news, isLoading, error } = this.state;\n    \n    if (isLoading) {\n      return <div className=\"loading-spinner\">Loading news...</div>;\n    }\n    \n    if (error) {\n      return <div className=\"error-message\">Error loading news: {error}</div>;\n    }\n    \n    if (news.length === 0) {\n      return <div className=\"empty-message\">No news available</div>;\n    }\n    \n    return (\n      <div className=\"news-container\">\n        <h2>Latest News</h2>\n        <ul>\n          {news.map(item => (\n            <li key={item.id}>{item.title}</li> // Assuming 'item' has an 'id' and 'title'\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}",
              "explanation": "This example illustrates data fetching within a class-based React component. The `constructor` initializes the component's state, including `news`, `isLoading`, and `error`. The `componentDidMount` lifecycle method is where the `fetch` API call is initiated. Promises (`.then()` and `.catch()`) are used to handle the asynchronous response and update the component's state accordingly. The `render` method performs conditional rendering to display loading, error, empty, or data states based on the component's current state.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Data Fetching",
            "Fetch API",
            "useEffect",
            "componentDidMount",
            "State Management",
            "Async/Await",
            "Promises",
            "Error Handling",
            "Conditional Rendering"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Promises",
            "ES6+ async/await",
            "React Basics (components, state, props)"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Custom Hooks",
            "Context API for Global State",
            "Optimistic Updates"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_async_data_fetching_1",
          "topic": "React State Management for Async Operations",
          "level": "easy",
          "type": "flashcard",
          "question": "What three common states should be managed when performing an asynchronous data fetch in a React component?",
          "answer": "`isLoading` (or `loading`), `data` (or specific data name), and `error`.",
          "analysisPoints": [
            "Identifies the fundamental state variables for managing async UI.",
            "Shows understanding of basic React component responsibilities."
          ],
          "keyConcepts": [
            "State Management",
            "Asynchronous Operations",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Correct identification of all three state types."
          ],
          "example": null,
          "tags": [
            "React",
            "State Management",
            "Basics"
          ],
          "prerequisites": [
            "React State"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_data_fetching_2",
          "topic": "useEffect for Data Fetching",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `useEffect` hook for data fetching:\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n  const [data, setData] = useState(null);\n  // ... other states\n\n  useEffect(() => {\n    const fetchData = async () => {\n      // ... fetch logic\n      setData(fetchedData);\n    };\n    fetchData();\n  }, []);\n\n  // ... render logic\n}\n```\n\nWhat is the purpose of the empty dependency array `[]` in this `useEffect` call?",
          "answer": "It ensures the `fetchData` function runs only once after the initial render, similar to `componentDidMount` in class components.",
          "options": [
            "It tells React to re-run the effect every time `data` changes.",
            "It prevents the component from re-rendering after data is fetched.",
            "It ensures the `fetchData` function runs only once after the initial render, similar to `componentDidMount` in class components.",
            "It specifies that the effect should only run when the component unmounts."
          ],
          "analysisPoints": [
            "Tests understanding of `useEffect` dependencies.",
            "Distinguishes between different dependency array behaviors.",
            "Relates `useEffect` to class component lifecycle methods."
          ],
          "keyConcepts": [
            "React Hooks",
            "useEffect",
            "Dependency Array",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct understanding of `useEffect` with empty dependency array.",
            "Ability to differentiate from other dependency array effects."
          ],
          "example": "The empty array `[]` as the second argument to `useEffect` signifies that the effect has no dependencies that would cause it to re-run. Therefore, it executes only once after the initial render. If the array were omitted, it would run on every render. If it contained variables, it would run when those variables changed.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Lifecycle",
            "MCQ"
          ],
          "prerequisites": [
            "React Hooks",
            "Component Lifecycle"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_data_fetching_3",
          "topic": "Fetch API Error Handling",
          "level": "medium",
          "type": "mcq",
          "question": "When using the `fetch` API, why is it important to explicitly check `response.ok` (e.g., `if (!response.ok) throw new Error(...)`) after receiving a response?",
          "answer": "`fetch` only rejects the Promise on network errors or request failures, not on HTTP error status codes (like 404 or 500).",
          "options": [
            "Because `fetch` automatically throws an error for any non-200 status code.",
            "To ensure the response body is always parsed as JSON.",
            "`fetch` only rejects the Promise on network errors or request failures, not on HTTP error status codes (like 404 or 500).",
            "It's a best practice for security, preventing cross-site scripting."
          ],
          "analysisPoints": [
            "Tests knowledge of `fetch` API's promise rejection behavior.",
            "Highlights a common pitfall in `fetch` error handling.",
            "Emphasizes the distinction between network errors and HTTP response errors."
          ],
          "keyConcepts": [
            "Fetch API",
            "Promises",
            "Error Handling",
            "HTTP Status Codes"
          ],
          "evaluationCriteria": [
            "Understanding of `fetch`'s specific error handling mechanism.",
            "Ability to articulate why `response.ok` check is necessary."
          ],
          "example": "```typescript\nasync function fetchData() {\n  try {\n    const response = await fetch('https://api.example.com/nonexistent'); // This might return a 404\n    if (!response.ok) {\n      // Without this check, the 'catch' block below wouldn't run for a 404.\n      // 'response.ok' would be false, but the promise itself would still resolve.\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Fetch error:', error.message); // This will catch the thrown error.\n  }\n}\nfetchData();\n```\nThis example shows that `fetch` itself won't throw an error for a 404 status. The `response` will still be received, but `response.ok` will be false. To correctly handle such scenarios in the `catch` block, an explicit `throw new Error` is required.",
          "tags": [
            "Fetch API",
            "Error Handling",
            "JavaScript",
            "Promises"
          ],
          "prerequisites": [
            "JavaScript Promises",
            "HTTP Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_data_fetching_4",
          "topic": "Class vs. Functional Component Data Fetching",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast asynchronous data fetching in React using `componentDidMount` in a class component versus `useEffect` in a functional component. Discuss their similarities, differences, and when you might prefer one approach over the other for data fetching.",
          "answer": "This is an open-ended question.",
          "options": [],
          "analysisPoints": [
            "Identifies `componentDidMount` and `useEffect` as primary hooks/lifecycle methods for side effects.",
            "Compares their execution timing (after initial render).",
            "Discusses state management differences (`this.setState` vs. `useState`).",
            "Compares `Promise.then().catch()` vs. `async/await` syntax.",
            "Highlights `useEffect`'s dependency array for re-running effects and cleanup, which `componentDidMount` doesn't directly offer for repeated effects.",
            "Mentions functional components with hooks as the modern and often preferred approach due to readability, composability, and avoiding `this` binding issues.",
            "Acknowledges that class components are still valid for legacy codebases.",
            "Discusses cleanup for `useEffect` to prevent memory leaks, which is handled by `componentWillUnmount` in class components (not explicitly in the prompt, but good to mention for completeness)."
          ],
          "keyConcepts": [
            "React Class Components",
            "React Functional Components",
            "Lifecycle Methods",
            "React Hooks",
            "useEffect",
            "componentDidMount",
            "State Management",
            "Asynchronous JavaScript",
            "Code Organization"
          ],
          "evaluationCriteria": [
            "Depth of understanding of both paradigms.",
            "Ability to articulate similarities and differences clearly.",
            "Insight into practical considerations and best practices.",
            "Discussion of `useEffect` cleanup (optional but highly valued)."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Comparison",
            "Data Fetching",
            "Advanced"
          ],
          "prerequisites": [
            "React Class Components",
            "React Functional Components",
            "React Hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_data_fetching_5",
          "topic": "Conditional Rendering for UI States",
          "level": "medium",
          "type": "code",
          "question": "You are building a React component that fetches user data. Complete the `render` method (for a class component) or the JSX return (for a functional component) to display the correct UI based on the `isLoading`, `error`, and `users` states. Prioritize rendering: loading, then error, then 'no users', then the actual user list.\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction UserList() {\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [users, setUsers] = useState([]);\n\n  useEffect(() => {\n    // Assume data fetching logic is here, which updates isLoading, error, users\n    // For this problem, assume successful fetch sets users to ['Alice', 'Bob']\n    // Assume error case sets error to 'Failed to fetch users'\n    // Assume empty case sets users to []\n    // For demonstration:\n    setTimeout(() => {\n      // Simulate a successful fetch\n      setIsLoading(false);\n      setUsers([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);\n      // To test error: setError('Failed to fetch users'); setIsLoading(false);\n      // To test no data: setUsers([]); setIsLoading(false);\n    }, 1000);\n  }, []);\n\n  // TODO: Implement the conditional rendering logic here\n  // Your code will go below this comment\n\n}\n```",
          "answer": "```typescript\nfunction UserList() {\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [users, setUsers] = useState([]);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setIsLoading(false);\n      setUsers([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);\n      // Example for error case:\n      // setError('Failed to fetch users'); setIsLoading(false);\n      // Example for no data case:\n      // setUsers([]); setIsLoading(false);\n    }, 1000);\n  }, []);\n\n  if (isLoading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error}</div>;\n  }\n\n  if (users.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly orders the conditional rendering checks (loading -> error -> empty/no data -> data).",
            "Uses `if` statements or ternary operators effectively for conditional UI.",
            "Demonstrates understanding of how to display different UI based on state."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "React State",
            "User Experience",
            "UI/UX"
          ],
          "evaluationCriteria": [
            "Correct implementation of conditional rendering logic.",
            "Proper ordering of conditions.",
            "Syntactically correct React JSX."
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "State Management",
            "Code Challenge"
          ],
          "prerequisites": [
            "React Basics",
            "Conditional Logic"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_data_fetching_6",
          "topic": "Async/Await vs Promises",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary benefit of using `async/await` over traditional `.then().catch()` chains for asynchronous operations in JavaScript/React?",
          "answer": "`async/await` makes asynchronous code look and behave more like synchronous code, improving readability, maintainability, and error handling with `try...catch` blocks.",
          "analysisPoints": [
            "Focuses on improved readability and maintainability.",
            "Mentions `try/catch` for error handling which mirrors synchronous error handling."
          ],
          "keyConcepts": [
            "Async/Await",
            "Promises",
            "Asynchronous JavaScript",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Clearly states the main advantage of `async/await`.",
            "Demonstrates understanding beyond just syntax."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Async/Await",
            "Promises",
            "Best Practices"
          ],
          "prerequisites": [
            "JavaScript Promises"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_data_fetching_7",
          "topic": "Class Component Lifecycle",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React class component lifecycle method is best suited for initiating an API call that should run only once after the component is mounted?",
          "answer": "`componentDidMount()`",
          "analysisPoints": [
            "Identifies the correct lifecycle method for initial data fetching.",
            "Demonstrates basic knowledge of class component lifecycles."
          ],
          "keyConcepts": [
            "React Class Components",
            "Lifecycle Methods",
            "componentDidMount"
          ],
          "evaluationCriteria": [
            "Correctly names the lifecycle method."
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Basics"
          ],
          "prerequisites": [
            "React Class Components"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_data_fetching_8",
          "topic": "State Update in Class Components",
          "level": "medium",
          "type": "mcq",
          "question": "In a React class component, after successfully fetching data, which method should be used to update the `news` and `isLoading` states?",
          "answer": "`this.setState({ news: data, isLoading: false });`",
          "options": [
            "`this.state.news = data; this.state.isLoading = false;`",
            "`setState({ news: data, isLoading: false });`",
            "`this.setState({ news: data, isLoading: false });`",
            "`updateState({ news: data, isLoading: false });`"
          ],
          "analysisPoints": [
            "Tests knowledge of `this.setState` for updating component state.",
            "Highlights the immutable nature of `this.state` and the need for `setState`.",
            "Checks understanding of batching state updates."
          ],
          "keyConcepts": [
            "React Class Components",
            "State Updates",
            "setState"
          ],
          "evaluationCriteria": [
            "Correct syntax and method for updating class component state.",
            "Awareness of direct state modification issues."
          ],
          "example": "Directly modifying `this.state` (e.g., `this.state.news = data;`) will not trigger a re-render of the component, leading to inconsistencies between the UI and the actual state. `this.setState()` is the correct way to inform React that the state has changed and a re-render is needed. It also allows React to batch multiple state updates for performance.",
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "MCQ"
          ],
          "prerequisites": [
            "React Class Components",
            "State Management"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_data_fetching_9",
          "topic": "Try/Catch/Finally Block",
          "level": "medium",
          "type": "flashcard",
          "question": "In an `async/await` block for data fetching, what is the purpose of the `finally` block?",
          "answer": "The `finally` block's code will execute regardless of whether the `try` block completes successfully or throws an error. It's often used for cleanup, such as setting `isLoading` to `false`.",
          "analysisPoints": [
            "Explains the unconditional execution of `finally`.",
            "Provides a practical use case (loading state cleanup)."
          ],
          "keyConcepts": [
            "Async/Await",
            "Error Handling",
            "Try/Catch/Finally",
            "Cleanup"
          ],
          "evaluationCriteria": [
            "Accurate description of `finally`'s behavior.",
            "Relevant example of its application in data fetching."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Error Handling",
            "Async/Await"
          ],
          "prerequisites": [
            "JavaScript Async/Await"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_data_fetching_10",
          "topic": "Preventing Multiple Fetches on Re-renders",
          "level": "easy",
          "type": "mcq",
          "question": "In the `FetchDataComponent` example, what mechanism ensures that the `fetchData()` call inside `useEffect` runs only once, not on every re-render?",
          "answer": "The empty dependency array `[]` passed as the second argument to `useEffect`.",
          "options": [
            "The `async` keyword on the `fetchData` function.",
            "The `useState` hook managing the `isLoading` state.",
            "The empty dependency array `[]` passed as the second argument to `useEffect`.",
            "React's automatic memoization of `useEffect` callbacks."
          ],
          "analysisPoints": [
            "Reinforces the role of `useEffect`'s dependency array.",
            "Distinguishes core React features from ancillary syntax."
          ],
          "keyConcepts": [
            "React Hooks",
            "useEffect",
            "Dependency Array",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Correctly identifies the mechanism for single-run effects.",
            "Avoids common misconceptions about React rendering."
          ],
          "example": "The `useEffect` hook, by default, runs after every render if no dependency array is provided. If an empty array `[]` is provided, it means the effect has no dependencies, and therefore, it will only run once after the initial render of the component. This is critical for preventing infinite loops or unnecessary API calls when fetching data.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "MCQ"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_functional_api_fetch",
          "title": "Implement a Functional Component for User Data Fetching",
          "description": "\nCreate a React functional component named `UserDataFetcher` that fetches a list of users from a public API. The component should manage its loading, error, and data states properly and display different UI elements accordingly.\n\n**Requirements:**\n1.  Use `useState` to manage `users` (array), `isLoading` (boolean), and `error` (string or null) states.\n2.  Use `useEffect` to initiate the data fetching when the component mounts. The fetch should only run once.\n3.  Use `async/await` syntax within the `useEffect` for cleaner asynchronous code.\n4.  Fetch data from `https://jsonplaceholder.typicode.com/users`.\n5.  Implement proper error handling: if `response.ok` is false, throw an error with an informative message. Catch any network or HTTP errors.\n6.  Ensure `isLoading` is set to `true` before the fetch and `false` in a `finally` block (or equivalent, ensuring it always resets).\n7.  Conditionally render the following:\n    *   \"Loading users...\" when `isLoading` is true.\n    *   \"Error: [error message]\" when `error` is not null.\n    *   \"No users found.\" if `users` array is empty after loading and no error occurred.\n    *   A list (e.g., `<ul>`) displaying each user's `name` property from the fetched data, along with their `id` as the `key`.\n\n**Bonus:** Add a button to refetch the data, which should reset the states and re-initiate the fetch.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction UserDataFetcher() {\n  // TODO: Initialize state variables: users, isLoading, error\n\n  // TODO: Implement useEffect for data fetching\n  useEffect(() => {\n    const fetchUsers = async () => {\n      // TODO: Set loading state\n      try {\n        // TODO: Fetch data from API\n        // TODO: Check response.ok and throw error if not ok\n        // TODO: Parse JSON response\n        // TODO: Set data and clear error state\n      } catch (err) {\n        // TODO: Set error state and clear data\n      } finally {\n        // TODO: Reset loading state\n      }\n    };\n    fetchUsers();\n  }, []); // Ensure it runs only once on mount\n\n  // TODO: Implement conditional rendering based on isLoading, error, users\n  // Order: Loading -> Error -> No Data -> Display Data\n\n  return (\n    <div>\n      {/* Your rendering logic here */}\n    </div>\n  );\n}\n\nexport default UserDataFetcher;",
          "solutionCode": "import React, { useState, useEffect, useCallback } from 'react';\n\nfunction UserDataFetcher() {\n  const [users, setUsers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const fetchUsers = useCallback(async () => {\n    setIsLoading(true);\n    setError(null); // Clear previous errors on refetch\n    setUsers([]);   // Clear previous data on refetch\n\n    try {\n      const response = await fetch('https://jsonplaceholder.typicode.com/users');\n      if (!response.ok) {\n        throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n      const data = await response.json();\n      setUsers(data);\n    } catch (err) {\n      setError(err.message);\n      setUsers([]);\n    } finally {\n      setIsLoading(false);\n    }\n  }, []); // fetchUsers itself has no dependencies that would change it\n\n  useEffect(() => {\n    fetchUsers();\n  }, [fetchUsers]); // Run once on mount, and if fetchUsers callback somehow changed (unlikely with useCallback([]))\n\n  if (isLoading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error}</div>;\n  }\n\n  if (users.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>Users List</h2>\n      <button onClick={fetchUsers} disabled={isLoading}>\n        {isLoading ? 'Fetching...' : 'Refetch Users'}\n      </button>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <strong>{user.name}</strong> ({user.email})\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default UserDataFetcher;",
          "testCases": [
            "Initial render: Should display 'Loading users...' then 'Users List' with data.",
            "Simulate network error (e.g., change URL to an invalid one): Should display 'Error: ...'.",
            "Simulate empty data (e.g., mock API to return `[]`): Should display 'No users found.'.",
            "Test refetch button: Clicking it should re-initiate loading, then display data.",
            "Test refetch button when loading: Button should be disabled."
          ],
          "hints": [
            "Remember to define an `async` function inside `useEffect` and call it.",
            "Use `try...catch...finally` for robust error handling and loading state management.",
            "The order of conditional rendering `if` statements matters for user experience.",
            "For the bonus, wrap your fetch function with `useCallback` to prevent unnecessary re-creations, and add it to `useEffect`'s dependency array if needed, or simply call it on button click."
          ],
          "tags": [
            "React",
            "Hooks",
            "Data Fetching",
            "Fetch API",
            "State Management",
            "Error Handling",
            "Conditional Rendering"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Hooks",
            "JavaScript Async/Await",
            "Fetch API"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useEffect",
            "useState",
            "async/await",
            "Promises",
            "Error Handling"
          ]
        },
        {
          "id": "task_class_api_fetch",
          "title": "Implement a Class Component for Product Data Fetching",
          "description": "\nCreate a React class component named `ProductFetcher` that fetches a list of products from an API. It should handle loading, error, and data states, similar to the functional component task, but using class component features.\n\n**Requirements:**\n1.  Use `this.state` to manage `products` (array), `isLoading` (boolean), and `error` (string or null) states.\n2.  Initiate the data fetching in `componentDidMount`.\n3.  Use the `fetch` API with `.then()` and `.catch()` for asynchronous operations.\n4.  Fetch data from `https://api.escuelajs.co/api/v1/products` (use this public API or a similar one if this is unreliable).\n5.  Implement proper error handling: if `response.ok` is false, throw an error. Handle network/HTTP errors in the `.catch()` block.\n6.  Ensure `isLoading` is set to `true` at the start of the fetch and `false` in both `.then()` and `.catch()` blocks.\n7.  Conditionally render the following:\n    *   \"Loading products...\" when `isLoading` is true.\n    *   \"Error: [error message]\" when `error` is not null.\n    *   \"No products available.\" if `products` array is empty after loading and no error occurred.\n    *   A list (`<ul>`) displaying each product's `title` property, using their `id` as the `key`.\n\n**Bonus:** Implement `componentWillUnmount` to potentially clean up any ongoing fetch requests (e.g., using `AbortController`) if the component unmounts before the fetch completes, to prevent memory leaks.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ProductFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    // TODO: Initialize state: products, isLoading, error\n  }\n\n  componentDidMount() {\n    // TODO: Set loading state\n    // TODO: Make API call using fetch().then().catch()\n    // Inside .then(): Check response.ok, parse JSON, update products and isLoading\n    // Inside .catch(): Update error and isLoading\n  }\n\n  // TODO: Implement componentWillUnmount for cleanup (Bonus)\n\n  render() {\n    // TODO: Destructure state variables\n    // TODO: Implement conditional rendering logic\n    // Order: Loading -> Error -> No Data -> Display Data\n    return (\n      <div>\n        {/* Your rendering logic here */}\n      </div>\n    );\n  }\n}\n\nexport default ProductFetcher;",
          "solutionCode": "import React from 'react';\n\nclass ProductFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      products: [],\n      isLoading: false,\n      error: null\n    };\n    this.abortController = new AbortController(); // For bonus cleanup\n  }\n\n  componentDidMount() {\n    this.setState({ isLoading: true, error: null, products: [] });\n\n    fetch('https://api.escuelajs.co/api/v1/products', {\n      signal: this.abortController.signal // Link AbortController to fetch\n    })\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({\n          products: data,\n          isLoading: false\n        });\n      })\n      .catch(error => {\n        // Only set error if it's not an abort signal (component unmounted)\n        if (error.name === 'AbortError') {\n          console.log('Fetch aborted by component unmount');\n        } else {\n          this.setState({\n            error: error.message,\n            isLoading: false\n          });\n        }\n      });\n  }\n\n  componentWillUnmount() {\n    this.abortController.abort(); // Abort any pending fetch requests\n  }\n\n  render() {\n    const { products, isLoading, error } = this.state;\n\n    if (isLoading) {\n      return <div>Loading products...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error}</div>;\n    }\n\n    if (products.length === 0) {\n      return <div>No products available.</div>;\n    }\n\n    return (\n      <div>\n        <h2>Product List</h2>\n        <ul>\n          {products.map(product => (\n            <li key={product.id}>\n              <strong>{product.title}</strong> - ${product.price}\n            </li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default ProductFetcher;",
          "testCases": [
            "Initial render: Should display 'Loading products...' then 'Product List' with data.",
            "Simulate network error: Should display 'Error: ...'.",
            "Simulate empty data: Should display 'No products available.'.",
            "Component unmount during fetch (difficult to test directly in simple setup, but conceptually): Fetch should be aborted without state update errors."
          ],
          "hints": [
            "Initialize state in the `constructor`.",
            "`componentDidMount` is the correct place to start initial API calls.",
            "Use `this.setState()` to update the component's state.",
            "For the bonus, research `AbortController` and `fetch`'s `signal` option. Remember to call `abort()` in `componentWillUnmount` and handle `AbortError` in `.catch()`."
          ],
          "tags": [
            "React",
            "Class Components",
            "Data Fetching",
            "Fetch API",
            "State Management",
            "Error Handling",
            "Conditional Rendering",
            "Lifecycle Methods"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Class Components",
            "JavaScript Promises",
            "Fetch API"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "componentDidMount",
            "componentWillUnmount",
            "this.state",
            "setState",
            "Promises"
          ]
        }
      ]
    }
  },
  {
    "id": "e4724474-f6ad-4077-b33e-5eddbd5efbeb",
    "startLine": 7200,
    "endLine": 7299,
    "processedDate": "2025-06-17T10:16:12.793Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_async_best_practices",
          "title": "Best Practices for Asynchronous Operations in React",
          "content": "Asynchronous operations are fundamental in modern web applications, especially for data fetching. In React, managing the state of these operations effectively is crucial for a good user experience and preventing bugs like race conditions or memory leaks.\n\n### Key Principles for Async Operations:\n\n1.  **Always Track Three States**: For any asynchronous operation, especially data fetching, it's essential to manage at least three distinct states in your component's local state or a state management solution:\n    *   **Loading**: Indicates that the request is currently in progress. This state is useful for displaying loading spinners or placeholders to the user.\n    *   **Success**: Represents that the request completed successfully, and data is available. This is when you render the fetched data.\n    *   **Error**: Signifies that the request failed. This state is used to display error messages to the user, providing feedback on what went wrong.\n\n2.  **Set Loading State Before the Request Starts**: To prevent race conditions and ensure the UI immediately reflects the pending operation, the `isLoading` state should be set to `true` right before the asynchronous call is initiated.\n\n3.  **Use `try/catch` or Promise `.catch()` for Error Handling**: Robust error handling is paramount. Wrap your asynchronous code in a `try...catch` block (for `async/await`) or chain a `.catch()` method (for Promises) to gracefully handle network issues, API errors, or other exceptions that might occur during the request. This prevents unhandled promise rejections and allows you to display user-friendly error messages.\n\n4.  **Clean Up Pending Requests (Cancellation)**: When a component that initiated an asynchronous request unmounts before the request completes, attempting to update its state can lead to memory leaks and errors (e.g., \"Can't perform a React state update on an unmounted component\"). It's crucial to cancel any in-flight requests when the component unmounts. Techniques like `AbortController` (for `fetch`) or cancellable tokens (for libraries like Axios) are used for this purpose.\n\n5.  **Add Conditional Rendering**: Your component's `render` method (or JSX in functional components) should conditionally render different UI elements based on the current state of the asynchronous operation (loading, error, success, or no data yet). This ensures the user always sees appropriate feedback.\n\n6.  **Use a Consistent Pattern**: Applying a standardized pattern for handling asynchronous operations throughout your application improves code readability, maintainability, and reduces cognitive load for developers.\n\nThese practices collectively lead to more reliable, performant, and user-friendly applications by addressing common pitfalls associated with asynchronous programming in React.",
          "examples": [
            {
              "id": "example_async_basic_class_component",
              "title": "Basic Async Data Fetching (Class Component)",
              "code": "import React from 'react';\n\nclass DataFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      data: null,\n      isLoading: false,\n      error: null\n    };\n  }\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  async fetchData() {\n    this.setState({ isLoading: true, error: null }); // Reset error on new fetch\n    try {\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ data, isLoading: false });\n    } catch (error) {\n      this.setState({ error: error.message, isLoading: false });\n    }\n  }\n\n  render() {\n    const { data, isLoading, error } = this.state;\n    \n    if (isLoading) return <p>Loading data...</p>;\n    if (error) return <p>Error: {error}</p>;\n    if (!data) return <p>No data available yet. Please wait.</p>;\n    \n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <p>Title: {data.title}</p>\n        <p>Body: {data.body}</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates the core principles of managing `isLoading`, `data`, and `error` states in a class component. The `isLoading` state is set before the `fetch` call, and `try...catch` is used for error handling. Conditional rendering ensures the UI updates based on the current state.",
              "language": "typescript"
            },
            {
              "id": "example_async_axios_functional_component",
              "title": "Async Data Fetching with Axios and `useEffect` (Functional Component)",
              "code": "import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nfunction ArticleFetcher() {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null); // Reset error on new fetch\n      try {\n        const result = await axios('http://hn.algolia.com/api/v1/search?query=react');\n        setData(result.data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []); // Empty dependency array means this runs once on mount\n\n  if (isLoading) return <p>Loading articles...</p>;\n  if (error) return <p>Error: {error}</p>;\n  if (!data || !data.hits) return <p>No articles found.</p>;\n\n  return (\n    <div>\n      <h2>React Articles:</h2>\n      <ul>\n        {data.hits.map(item => (\n          <li key={item.objectID}>\n            <a href={item.url} target=\"_blank\" rel=\"noopener noreferrer\">{item.title}</a>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example shows the same best practices applied in a functional component using `useState` and `useEffect`. `axios` is used for fetching, and the `finally` block ensures `isLoading` is set to `false` regardless of success or failure. The `useEffect` hook with an empty dependency array makes the data fetching happen once, similar to `componentDidMount`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Asynchronous Operations",
            "State Management",
            "Error Handling",
            "Data Fetching",
            "Best Practices",
            "Functional Components",
            "Class Components",
            "useEffect",
            "useState",
            "Axios",
            "Fetch API"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Promises",
            "Async/Await",
            "React Component Lifecycle",
            "React Hooks (useState, useEffect)"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Robust Data Management",
            "Building Interactive UIs"
          ]
        },
        {
          "id": "theory_cancelling_requests",
          "title": "Cancelling In-flight Requests on Component Unmount",
          "content": "A crucial best practice for asynchronous operations in React is to cancel any pending requests when the component that initiated them unmounts. This prevents a common class of bugs related to state updates on unmounted components and avoids potential memory leaks.\n\n### Why Cancel Requests?\n\nWhen a component unmounts, its lifecycle ends. If an asynchronous operation (like a network request) initiated by that component is still in progress, and it attempts to update the component's state upon completion, React will issue a warning:\n\n`Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix this, cancel all subscriptions and asynchronous tasks in a componentWillUnmount callback.`\n\nCancelling requests addresses this by ensuring that the callback that would update the state is never executed or that the state update is guarded against if the component is no longer mounted.\n\n### `AbortController` for `fetch` API:\n\n`AbortController` is a Web API interface that allows you to abort one or more Web requests as and when desired. It provides an `AbortSignal` object, which can be passed to the `fetch()` method. When the `abort()` method on the `AbortController` instance is called, the `fetch` request is cancelled.\n\nUpon cancellation, the `fetch` Promise will reject with an `AbortError`. It's important to specifically check for this error type in your `catch` block to distinguish it from other network or server errors, and typically, you would simply `return` early without updating state if an `AbortError` occurs.\n\n**Key Steps:**\n1.  **Create `AbortController`**: Instantiate `new AbortController()` in the component's constructor (for class components) or using `useRef` in functional components to maintain a stable reference.\n2.  **Pass Signal to `fetch`**: Provide `this.abortController.signal` to the `signal` option of the `fetch` call.\n3.  **Call `abort()` on Unmount**: In `componentWillUnmount` (for class components) or within the cleanup function of `useEffect` (for functional components), call `this.abortController.abort()`.\n4.  **Handle `AbortError`**: In the `catch` block, check `if (error.name === 'AbortError')` and return to avoid state updates.\n\n### Example (Class Component):",
          "examples": [
            {
              "id": "example_cancelling_requests_class",
              "title": "Cancelling Requests with `AbortController` (Class Component)",
              "code": "import React from 'react';\n\nclass DataFetcherWithCancellation extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      data: null,\n      isLoading: false,\n      error: null\n    };\n    // Create an AbortController instance\n    this.abortController = new AbortController();\n  }\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    // Cancel any pending requests when component unmounts\n    console.log('Component unmounting, aborting fetch request.');\n    this.abortController.abort();\n  }\n\n  async fetchData() {\n    this.setState({ isLoading: true, error: null });\n    try {\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts/2', {\n        signal: this.abortController.signal  // Pass the signal to fetch\n      });\n      if (!response.ok) throw new Error('Network response was not ok');\n      const data = await response.json();\n      this.setState({ data, isLoading: false });\n    } catch (error) {\n      // Don't update state if the request was aborted (component unmounted)\n      if (error.name === 'AbortError') {\n        console.log('Fetch aborted due to component unmount.');\n        return; // Important: prevent state update\n      }\n      this.setState({ error: error.message, isLoading: false });\n    }\n  }\n\n  render() {\n    const { data, isLoading, error } = this.state;\n    \n    if (isLoading) return <p>Loading data with cancellation...</p>;\n    if (error) return <p>Error: {error}</p>;\n    if (!data) return <p>No data available</p>;\n    \n    return (\n      <div>\n        <h2>Fetched Data (Cancellable):</h2>\n        <p>Title: {data.title}</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This is the complete `DataFetcher` component from the markdown, demonstrating how to use `AbortController` to cancel `fetch` requests. The `AbortController` is initialized in the constructor, its `signal` is passed to `fetch`, and `abort()` is called in `componentWillUnmount`. The `catch` block specifically checks for `AbortError` to prevent state updates after unmount.",
              "language": "typescript"
            },
            {
              "id": "example_cancelling_requests_functional",
              "title": "Cancelling Requests with `AbortController` (`useEffect` Hook)",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction DataFetcherFunctionalWithCancellation() {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    \n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null);\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/posts/3', {\n          signal: abortController.signal\n        });\n        if (!response.ok) throw new Error('Network response was not ok');\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        if (err.name === 'AbortError') {\n          console.log('Fetch aborted.');\n          return;\n        }\n        setError(err.message);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function: runs on unmount or before re-running effect\n    return () => {\n      console.log('Cleaning up effect, aborting fetch.');\n      abortController.abort();\n    };\n  }, []); // Empty dependency array means effect runs once on mount\n\n  if (isLoading) return <p>Loading data with cancellation (functional)...</p>;\n  if (error) return <p>Error: {error}</p>;\n  if (!data) return <p>No data available</p>;\n\n  return (\n    <div>\n      <h2>Fetched Data (Cancellable Functional):</h2>\n      <p>Title: {data.title}</p>\n    </div>\n  );\n}",
              "explanation": "This demonstrates the `AbortController` pattern in a functional component using the `useEffect` hook. The `AbortController` is created inside `useEffect`, and its `abort()` method is called in the cleanup function returned by `useEffect`. This ensures the request is cancelled when the component unmounts or the effect re-runs (though not in this case due to `[]`).",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Component Lifecycle",
            "ComponentDidMount",
            "ComponentWillUnmount",
            "useEffect",
            "Cleanup",
            "AbortController",
            "Fetch API",
            "Memory Leaks",
            "Error Handling",
            "Asynchronous Operations",
            "Best Practices"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Promises",
            "Async/Await",
            "Web APIs",
            "React Component Lifecycle",
            "React Hooks (useEffect)"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Optimized React Applications",
            "Preventing Memory Leaks"
          ]
        },
        {
          "id": "theory_use_context",
          "title": "React Context API and `useContext` Hook",
          "content": "The React Context API provides a way to pass data through the component tree without having to pass props down manually at every level. This is particularly useful for 'global' data that many components in an application might need, such as authenticated user information, theme settings, or locale preferences.\n\n### Problem Solved: Prop Drilling\n\nBefore Context, sharing data deep within the component tree often led to 'prop drilling' or 'prop chaining', where props are passed down through many layers of components that don't actually need the data themselves, just to get it to a deeply nested child component. This makes code harder to read, maintain, and refactor.\n\n### Context API Flow:\n\n![React Context API Flow](images/context_1.png)\n\n1.  **Create Context**: You create a Context object using `React.createContext()`. This object comes with a `Provider` and a `Consumer` component.\n2.  **Provide Value**: The `Provider` component is used higher up in the component tree. It accepts a `value` prop, which is the data you want to make available to all its descendant components.\n3.  **Consume Value**: Descendant components, regardless of how deep they are, can 'consume' this value using either:\n    *   `Context.Consumer` (a render prop pattern, generally less common with hooks).\n    *   `useContext` hook (the modern, preferred way for functional components).\n\n### Context API Usage:\n\n![React Context API Usage](images/context_2.png)\n\n#### `React.createContext`\n\n```typescript\nconst MyContext = React.createContext(defaultValue);\n```\n\n*   `defaultValue` is used when a component consumes context without a matching Provider above it in the tree. It can be useful for testing components in isolation without wrapping them in a Provider.\n\n#### `Context.Provider`\n\n```typescript\n<MyContext.Provider value={/* some value */}>\n  {/* Components that need access to the context value */}\n</MyContext.Provider>\n```\n\n*   Every `MyContext.Provider` component that wraps your components makes the `value` prop available to all consuming components that are descendants of this Provider.\n\n#### `useContext` Hook\n\n```typescript\nimport React, { useContext } from 'react';\n\nfunction MyComponent() {\n  const value = useContext(MyContext); // Pass the Context object itself\n  // ... use value ...\n}\n```\n\n*   The `useContext` hook accepts a context object (the value returned from `React.createContext`) and returns the current context value for that context.\n*   The current context value is determined by the `value` prop of the nearest `MyContext.Provider` above the calling component in the tree.\n*   When the Provider's `value` changes, `useContext` will trigger a re-render with the new value.\n\n### Context API Benefits:\n\n1.  **Avoid Prop Drilling**: Significantly reduces the need to pass props down through intermediary components, making the component tree cleaner and easier to manage.\n2.  **Share Global Data**: Provides an efficient mechanism to share data that can be considered 'global' for a certain part of the component tree, or even the entire application.\n\n### When to Use Context?\n\nContext is designed to share data that can be considered 'global' for a tree of React components, such as the current authenticated user, theme, or preferred language. It's not a replacement for local component state or prop-based communication for frequently changing data or highly coupled data flows.\n\nFor more complex global state management with frequent updates or cross-cutting concerns, libraries like Redux or Zustand might be more appropriate. Context is best for less frequently changing data or where the data flow is straightforward.",
          "examples": [
            {
              "id": "example_use_context_basic",
              "title": "Basic `useContext` Implementation",
              "code": "import React, { createContext, useContext, useState } from 'react';\n\n// 1. Create a Context\nconst ThemeContext = createContext('light'); // default value 'light'\n\n// A component that consumes the context\nfunction ThemedButton() {\n  // 3. Consume the context using useContext hook\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#000' }}>\n      I am a {theme} button\n    </button>\n  );\n}\n\n// A parent component that provides the context\nfunction ThemeApp() {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');\n  };\n\n  return (\n    // 2. Provide the context value\n    <ThemeContext.Provider value={theme}>\n      <div style={{ padding: '20px', background: theme === 'dark' ? '#111' : '#eee', color: theme === 'dark' ? '#eee' : '#111' }}>\n        <h1>Context API Example</h1>\n        <p>Current Theme: {theme}</p>\n        <button onClick={toggleTheme}>Toggle Theme</button>\n        <ThemedButton />\n        <Toolbar />\n      </div>\n    </ThemeContext.Provider>\n  );\n}\n\n// Another component that needs the theme, without prop drilling\nfunction Toolbar() {\n  return (\n    <div style={{ marginTop: '10px' }}>\n      <ThemedButton />\n    </div>\n  );\n}",
              "explanation": "This example illustrates the complete flow of the Context API with `useContext`. `ThemeContext` is created. `ThemeApp` acts as the `Provider`, setting the current `theme` value. `ThemedButton` and `Toolbar` (which contains another `ThemedButton`) are consumers. They use `useContext(ThemeContext)` to access the `theme` value directly, without needing `theme` to be passed as a prop from `ThemeApp` to `Toolbar`, and then from `Toolbar` to `ThemedButton`, thereby avoiding prop drilling.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Context API",
            "useContext",
            "Prop Drilling",
            "Global State",
            "State Management",
            "Hooks",
            "Component Communication"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "React Props",
            "React State",
            "React Hooks (useState)"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Building Scalable React Apps",
            "Managing Global State"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_async_states_1",
          "topic": "Async Operations Best Practices",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the three essential states to track for asynchronous operations in React?",
          "answer": "Loading, success, and error.",
          "analysisPoints": [
            "Identifies the fundamental states for managing async UI feedback."
          ],
          "keyConcepts": [
            "Async State Management",
            "Loading State",
            "Success State",
            "Error State"
          ],
          "evaluationCriteria": [
            "Recall of core async states"
          ],
          "example": "",
          "tags": [
            "React",
            "Async",
            "Best Practices",
            "State Management"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_loading_state_placement_2",
          "topic": "Async Operations Best Practices",
          "level": "medium",
          "type": "mcq",
          "question": "When should the loading state be set to `true` for an asynchronous operation in a React component?",
          "answer": "Immediately before the asynchronous request starts.",
          "options": [
            "After the asynchronous request completes successfully.",
            "Immediately before the asynchronous request starts.",
            "Only if an error occurs during the request.",
            "After the component renders the initial UI."
          ],
          "analysisPoints": [
            "Understanding the importance of setting loading state early.",
            "Preventing race conditions where UI might not reflect pending state.",
            "Ensuring immediate user feedback."
          ],
          "keyConcepts": [
            "Loading State",
            "Race Conditions",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Knowledge of state management timing",
            "Understanding of UX implications"
          ],
          "example": "Setting loading state before the fetch call ensures the UI can show a spinner or message immediately, indicating to the user that something is happening.\n\n```typescript\nasync fetchData() {\n  this.setState({ isLoading: true }); // Set loading state here\n  try {\n    const response = await fetch('...');\n    // ... rest of the logic\n  } catch (error) {\n    // ... error handling\n  }\n}\n```",
          "tags": [
            "React",
            "Async",
            "State Management",
            "Best Practices",
            "UX"
          ],
          "prerequisites": [
            "React State"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_error_handling_3",
          "topic": "Async Operations Best Practices",
          "level": "easy",
          "type": "flashcard",
          "question": "What common JavaScript construct should always be used to handle errors in `async/await` operations?",
          "answer": "try/catch block.",
          "analysisPoints": [
            "Recalls the primary mechanism for synchronous and asynchronous error handling in JS."
          ],
          "keyConcepts": [
            "Error Handling",
            "Async/Await",
            "Try/Catch"
          ],
          "evaluationCriteria": [
            "Basic JavaScript error handling knowledge"
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Async",
            "Error Handling"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_cleanup_why_4",
          "topic": "Cancelling Requests",
          "level": "medium",
          "type": "open",
          "question": "Explain why it's important to clean up (cancel) pending asynchronous requests when a React component unmounts. What issues can arise if you don't?",
          "answer": "It's important to cancel pending asynchronous requests when a React component unmounts to prevent state updates on an unmounted component, which can lead to memory leaks and runtime errors. If not cancelled, a completed request might try to call `setState` on a component that no longer exists in the DOM, leading to the warning `Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.` and potentially unexpected behavior or crashes in more complex scenarios.",
          "analysisPoints": [
            "Identifies the core problem: state updates on unmounted components.",
            "Explains the consequences: memory leaks and warnings/errors.",
            "Connects cleanup to component lifecycle."
          ],
          "keyConcepts": [
            "Component Unmount",
            "Memory Leaks",
            "State Updates",
            "Component Lifecycle",
            "Asynchronous Tasks"
          ],
          "evaluationCriteria": [
            "Understanding of React lifecycle issues",
            "Ability to articulate consequences of unhandled async tasks"
          ],
          "example": "",
          "tags": [
            "React",
            "Async",
            "Memory Leaks",
            "Cleanup",
            "Best Practices",
            "Component Lifecycle"
          ],
          "prerequisites": [
            "React Component Lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_abortcontroller_usage_5",
          "topic": "Cancelling Requests",
          "level": "medium",
          "type": "code",
          "question": "You have a functional React component that fetches data using the `fetch` API. Modify the `useEffect` hook to use `AbortController` to cancel the request if the component unmounts before the fetch operation completes. Ensure `AbortError` is handled gracefully.",
          "answer": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction CancellableDataFetcher() {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    \n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null);\n      try {\n        const response = await fetch('https://api.example.com/long-running-data', {\n          signal: abortController.signal // Pass the signal here\n        });\n        if (!response.ok) throw new Error('Network response was not ok');\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        // Handle AbortError specifically\n        if (err.name === 'AbortError') {\n          console.log('Fetch request aborted.');\n          return; // Prevent state update if aborted\n        }\n        setError(err.message);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function: aborts the request on unmount\n    return () => {\n      console.log('Component unmounted, aborting request.');\n      abortController.abort();\n    };\n  }, []); // Empty dependency array means effect runs once on mount\n\n  if (isLoading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error}</p>;\n  if (!data) return <p>No data available</p>;\n\n  return (\n    <div>\n      <h2>Data:</h2>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n}\n```",
          "analysisPoints": [
            "Correct initialization of `AbortController` within `useEffect`.",
            "Passing `abortController.signal` to `fetch` options.",
            "Calling `abortController.abort()` in `useEffect`'s cleanup function.",
            "Handling `AbortError` in the `catch` block to prevent state updates."
          ],
          "keyConcepts": [
            "AbortController",
            "Fetch API",
            "useEffect Hook",
            "Component Lifecycle",
            "Cleanup",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Correct application of `AbortController`",
            "Understanding of `useEffect` cleanup",
            "Proper error handling for `AbortError`"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Async",
            "Cleanup",
            "AbortController",
            "Fetch API",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React Hooks",
            "Fetch API",
            "JavaScript Promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_abortcontroller_name_6",
          "topic": "Cancelling Requests",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the `error.name` property value for an error thrown when a `fetch` request is cancelled by an `AbortController`?",
          "answer": "`'AbortError'`.",
          "analysisPoints": [
            "Recalls the specific error name for fetch cancellations."
          ],
          "keyConcepts": [
            "AbortController",
            "Error Handling",
            "Fetch API"
          ],
          "evaluationCriteria": [
            "Knowledge of specific Web API error types"
          ],
          "example": "",
          "tags": [
            "Fetch API",
            "AbortController",
            "Error Handling"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_7",
          "topic": "Async Operations Best Practices",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following component state for an async operation:\n\n```typescript\ninterface MyComponentState {\n  data: any | null;\n  isLoading: boolean;\n  error: string | null;\n}\n```\n\nWhich of the following conditional rendering sequences is best practice for displaying UI based on these states?",
          "answer": "A. `if (isLoading) return <Loading />; if (error) return <Error />; if (!data) return <NoData />; return <DataView data={data} />;`",
          "options": [
            "A. `if (isLoading) return <Loading />; if (error) return <Error />; if (!data) return <NoData />; return <DataView data={data} />;`",
            "B. `if (data) return <DataView data={data} />; if (isLoading) return <Loading />; if (error) return <Error />;`",
            "C. `if (error) return <Error />; if (data) return <DataView data={data} />; if (isLoading) return <Loading />;`",
            "D. `if (!isLoading && !error && data) return <DataView data={data} />; else if (isLoading) return <Loading />; else if (error) return <Error />;`"
          ],
          "analysisPoints": [
            "Prioritizes the `isLoading` state first, as it indicates an ongoing operation that should take precedence.",
            "Handles `error` next, as it's a terminal state requiring immediate user feedback.",
            "Checks for `!data` or an empty state before rendering the actual data, ensuring a 'no data' message can be shown.",
            "The order ensures a logical flow and avoids rendering partial or incorrect UI states."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "UI State",
            "Async Operations",
            "Best Practices",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Understanding of logical rendering flow",
            "Application of best practices in UI state management"
          ],
          "example": "The best practice is to check for `isLoading` first, then `error`, then `!data`, and finally render the data. This ensures the user sees the most relevant state first (e.g., 'Loading...' while fetching, or 'Error!' if it failed, rather than potentially stale data or nothing at all).\n\n```typescript\nrender() {\n  const { data, isLoading, error } = this.state;\n  \n  if (isLoading) return <p>Loading...</p>; // Highest priority\n  if (error) return <p>Error: {error}</p>; // Next priority for failures\n  if (!data) return <p>No data available</p>; // Handles empty successful response or initial state\n  \n  return <div>{/* Render your data */}</div>; // Only render data when all checks pass\n}\n```",
          "tags": [
            "React",
            "UI",
            "Conditional Rendering",
            "Best Practices",
            "Async"
          ],
          "prerequisites": [
            "React State",
            "Conditional Logic"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_purpose_8",
          "topic": "React Context API",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary problem that React's Context API aims to solve?",
          "answer": "Prop drilling (or prop chaining).",
          "analysisPoints": [
            "Directly identifies the main pain point Context addresses."
          ],
          "keyConcepts": [
            "Context API",
            "Prop Drilling"
          ],
          "evaluationCriteria": [
            "Recall of Context API's main purpose"
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Prop Drilling"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_context_global_data_9",
          "topic": "React Context API",
          "level": "medium",
          "type": "open",
          "question": "Describe two main benefits of using the React Context API.",
          "answer": "The two main benefits of using the React Context API are:\n\n1.  **Avoiding Prop Drilling**: It allows data to be passed down through the component tree without manually passing props at every intermediate level. This makes the code cleaner, more readable, and easier to refactor, especially for deeply nested components.\n2.  **Sharing Global Data**: It provides a way to share data that can be considered 'global' for a certain part of the component tree or the entire application. Examples include themes, user authentication status, or locale preferences, which might be needed by many components at various depths without being tightly coupled.",
          "analysisPoints": [
            "Clearly defines prop drilling and how Context alleviates it.",
            "Explains the concept of global data sharing.",
            "Provides relevant examples for global data."
          ],
          "keyConcepts": [
            "Context API",
            "Prop Drilling",
            "Global State",
            "Component Communication"
          ],
          "evaluationCriteria": [
            "Ability to explain Context benefits",
            "Understanding of use cases"
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Prop Drilling",
            "Global State",
            "Benefits"
          ],
          "prerequisites": [],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_components_10",
          "topic": "React Context API",
          "level": "medium",
          "type": "mcq",
          "question": "When creating a Context in React using `React.createContext()`, which two components are provided by the Context object to facilitate data sharing?",
          "answer": "Provider and Consumer",
          "options": [
            "Creator and Listener",
            "Provider and Consumer",
            "Emitter and Receiver",
            "Sender and Getter"
          ],
          "analysisPoints": [
            "Identifies the core components that make up the Context API pattern.",
            "Distinguishes between providing and consuming roles."
          ],
          "keyConcepts": [
            "Context API",
            "Provider Component",
            "Consumer Component",
            "React.createContext"
          ],
          "evaluationCriteria": [
            "Knowledge of Context API's core components"
          ],
          "example": "The `React.createContext()` function returns an object containing two components: `Provider` and `Consumer`.\n\n```typescript\nconst MyContext = React.createContext('default');\n\n// Usage:\n<MyContext.Provider value={someValue}>...</MyContext.Provider>\n<MyContext.Consumer>{value => <ChildComponent value={value} />}</MyContext.Consumer>\n```",
          "tags": [
            "React",
            "Context API",
            "Components"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usecontext_parameters_11",
          "topic": "React Context API",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the expected argument when calling the `useContext` hook?",
          "answer": "The Context object itself (e.g., `MyContext` from `React.createContext(defaultValue)`).",
          "analysisPoints": [
            "Clarifies the correct input for `useContext`.",
            "Distinguishes it from the context value itself."
          ],
          "keyConcepts": [
            "useContext Hook",
            "Context Object"
          ],
          "evaluationCriteria": [
            "Correct usage of `useContext`"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useContext",
            "Context API"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_when_to_use_12",
          "topic": "React Context API",
          "level": "hard",
          "type": "open",
          "question": "Context API is often compared to global state management libraries like Redux. When is Context API generally sufficient for state management, and when might a more robust library like Redux be preferable?",
          "answer": "Context API is generally sufficient when:\n\n*   **Data is less frequently updated**: For static or infrequently changing data (e.g., theme, user authentication status).\n*   **Data is truly 'global' and non-cascading**: When a value needs to be accessible by many components throughout the tree, but the updates don't involve complex logic, side effects, or a need for a centralized reducer pattern.\n*   **Simple data flow**: When the data flow is straightforward, and you don't need features like middleware, time-travel debugging, or extensive tooling for state changes.\n\nRedux (or similar robust libraries) might be preferable when:\n\n*   **Complex, frequently updated state**: For applications with large, constantly changing state that requires a predictable state container.\n*   **Complex state transitions/business logic**: When state updates involve complex sequences of actions, asynchronous operations, or dependencies between different parts of the state.\n*   **Debugging and predictability**: When you need advanced debugging tools, a strict unidirectional data flow, and a clear, explicit history of state changes.\n*   **Scalability**: For very large applications where managing state across many features and developers becomes challenging without a more opinionated and structured approach.\n*   **Performance optimization**: While Context can cause re-renders, complex Redux setups often provide more granular control over re-renders for large applications through memoization and selectors.",
          "analysisPoints": [
            "Compares Context to Redux based on update frequency and complexity.",
            "Highlights Context's suitability for 'global' but simpler data.",
            "Outlines Redux's strengths for complex logic, debugging, and scalability.",
            "Demonstrates nuanced understanding of state management patterns."
          ],
          "keyConcepts": [
            "Context API",
            "Redux",
            "Global State Management",
            "Prop Drilling",
            "State Complexity",
            "Scalability",
            "Middleware"
          ],
          "evaluationCriteria": [
            "Deep understanding of state management paradigms",
            "Ability to evaluate trade-offs between tools",
            "Knowledge of common use cases"
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Redux",
            "State Management",
            "Architecture",
            "Design Patterns"
          ],
          "prerequisites": [
            "React State Management Concepts"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_async_data_fetcher",
          "title": "Build a Robust Data Fetcher Component",
          "description": "\nImplement a React functional component named `RobustDataFetcher` that fetches data from a given URL and adheres to the best practices for asynchronous operations:\n\n1.  **State Management**: Track `data` (fetched content), `isLoading` (boolean), and `error` (string or null).\n2.  **Initial Load**: Set `isLoading` to `true` before fetching and `false` after completion (success or error).\n3.  **Error Handling**: Use `try/catch` to handle potential network or API errors. Display an informative error message if `error` state is not null.\n4.  **Conditional Rendering**: Display 'Loading...', 'Error: [message]', or 'No data available' based on the respective states. Only display the fetched data when it's available and there are no loading or error states.\n5.  **Data Display**: If data is successfully fetched, display it (e.g., in a `pre` tag for JSON).\n6.  **Cleanup**: Implement cleanup using `AbortController` to cancel the `fetch` request if the component unmounts while the request is in progress. Handle `AbortError` gracefully without updating state.\n\nUse the `useEffect` hook for data fetching and cleanup.\n\n**API Endpoint to use:** `https://jsonplaceholder.typicode.com/posts/1`\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction RobustDataFetcher() {\n  // TODO: Initialize states for data, isLoading, error\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // TODO: Create AbortController\n    // TODO: Define fetchData async function\n    //   - Set isLoading to true\n    //   - Reset error\n    //   - Use try/catch for fetch\n    //   - Pass signal to fetch\n    //   - Handle AbortError specifically\n    //   - Update data, isLoading, error states accordingly\n    // TODO: Call fetchData\n\n    // TODO: Return cleanup function to abort the request\n  }, []); // Ensure it runs only on mount\n\n  // TODO: Implement conditional rendering for loading, error, no data, and data display\n  if (isLoading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error}</p>;\n  if (!data) return <p>No data available</p>;\n\n  return (\n    <div>\n      <h2>Fetched Data:</h2>\n      {/* Display fetched data here */}\n    </div>\n  );\n}\n\nexport default RobustDataFetcher;",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction RobustDataFetcher() {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    \n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null); // Clear previous errors\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1', {\n          signal: abortController.signal  // Pass the signal to fetch\n        });\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        if (err.name === 'AbortError') {\n          console.log('Fetch request aborted due to component unmount.');\n          return; // Prevent state update if aborted\n        }\n        setError(err.message);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function: runs on unmount or before effect re-runs\n    return () => {\n      console.log('Cleaning up RobustDataFetcher, aborting fetch request.');\n      abortController.abort();\n    };\n  }, []); // Empty dependency array means effect runs once on mount/cleanup on unmount\n\n  if (isLoading) return <p>Loading data...</p>;\n  if (error) return <p>Error: {error}</p>;\n  if (!data) return <p>No data available. Please wait or check network.</p>;\n\n  return (\n    <div>\n      <h2>Fetched Post:</h2>\n      <h3>{data.title}</h3>\n      <p>{data.body}</p>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n}\n\nexport default RobustDataFetcher;",
          "testCases": [
            "Renders 'Loading...' initially.",
            "Renders fetched data correctly after successful fetch (e.g., 'Post Title', 'Post Body').",
            "Renders 'Error: [message]' if the fetch fails (e.g., simulating network error by changing URL).",
            "Does NOT update state if component unmounts during fetch (verify with console logs for 'Fetch request aborted').",
            "Renders 'No data available' if `data` is null after loading and no error (e.g. if API returns empty array, although not applicable for this specific API).",
            "Ensure `isLoading` is correctly set to `false` in `finally` block."
          ],
          "hints": [
            "Remember to use `useState` for each piece of state (data, isLoading, error).",
            "The `useEffect` hook's return function is crucial for cleanup, specifically for calling `abortController.abort()`.",
            "Don't forget to check `error.name === 'AbortError'` in your `catch` block to distinguish between aborted requests and actual errors."
          ],
          "tags": [
            "React",
            "Hooks",
            "Asynchronous",
            "Data Fetching",
            "State Management",
            "Error Handling",
            "Cleanup",
            "AbortController",
            "Best Practices"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Hooks",
            "Fetch API",
            "JavaScript Promises",
            "Async/Await"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_async_best_practices",
            "theory_cancelling_requests"
          ]
        },
        {
          "id": "task_refactor_prop_drilling_to_context",
          "title": "Refactor Prop Drilling with React Context API",
          "description": "\nYou are given a small React application that uses prop drilling to pass a 'theme' (light/dark) down through several nested components. Your task is to refactor this application to use the React Context API and the `useContext` hook to manage the theme state, thereby eliminating prop drilling.\n\n**Requirements:**\n1.  Create a `ThemeContext` using `React.createContext`.\n2.  Create a `ThemeProvider` component that wraps the `ThemeContext.Provider` and manages the `theme` state (e.g., 'light' or 'dark'). It should also provide a function to toggle the theme.\n3.  Modify `App.js` to use `ThemeProvider` to wrap the `Toolbar` component.\n4.  Modify `Toolbar.js` and `ThemedButton.js` to consume the theme and the toggle function directly from the `ThemeContext` using the `useContext` hook, removing the need for `theme` and `toggleTheme` props.\n5.  Ensure the button correctly toggles the theme, and the theme is applied to the button and some background element (e.g., in `App.js`).\n\n**Provided Initial Structure (simulate files):**\n\n`App.js`\n```typescript\nimport React, { useState } from 'react';\n\nfunction Toolbar({ theme, toggleTheme }) {\n  return (\n    <div>\n      <ThemedButton theme={theme} toggleTheme={toggleTheme} />\n    </div>\n  );\n}\n\nfunction ThemedButton({ theme, toggleTheme }) {\n  const buttonStyle = {\n    background: theme === 'dark' ? '#333' : '#fff',\n    color: theme === 'dark' ? '#fff' : '#000',\n    padding: '10px 20px',\n    border: 'none',\n    borderRadius: '5px',\n    cursor: 'pointer'\n  };\n  return (\n    <button style={buttonStyle} onClick={toggleTheme}>\n      Current Theme: {theme}\n    </button>\n  );\n}\n\nfunction App() {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  const appStyle = {\n    background: theme === 'dark' ? '#222' : '#f0f0f0',\n    color: theme === 'dark' ? '#f0f0f0' : '#222',\n    minHeight: '100vh',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center'\n  };\n\n  return (\n    <div style={appStyle}>\n      <h1>Theme App (Prop Drilling)</h1>\n      <Toolbar theme={theme} toggleTheme={toggleTheme} />\n    </div>\n  );\n}\n\nexport default App;\n```\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// --- App.js (Initial) ---\n// This section simulates the initial App.js content\nfunction Toolbar({ theme, toggleTheme }) {\n  return (\n    <div>\n      <ThemedButton theme={theme} toggleTheme={toggleTheme} />\n    </div>\n  );\n}\n\nfunction ThemedButton({ theme, toggleTheme }) {\n  const buttonStyle = {\n    background: theme === 'dark' ? '#333' : '#fff',\n    color: theme === 'dark' ? '#fff' : '#000',\n    padding: '10px 20px',\n    border: 'none',\n    borderRadius: '5px',\n    cursor: 'pointer'\n  };\n  return (\n    <button style={buttonStyle} onClick={toggleTheme}>\n      Current Theme: {theme}\n    </button>\n  );\n}\n\nfunction App() {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  const appStyle = {\n    background: theme === 'dark' ? '#222' : '#f0f0f0',\n    color: theme === 'dark' ? '#f0f0f0' : '#222',\n    minHeight: '100vh',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center'\n  };\n\n  return (\n    <div style={appStyle}>\n      <h1>Theme App (Prop Drilling)</h1>\n      <Toolbar theme={theme} toggleTheme={toggleTheme} />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState, createContext, useContext } from 'react';\n\n// 1. Create a ThemeContext\nconst ThemeContext = createContext({\n  theme: 'light',\n  toggleTheme: () => {}\n});\n\n// 2. Create a ThemeProvider component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  const contextValue = { theme, toggleTheme };\n\n  return (\n    <ThemeContext.Provider value={contextValue}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// Toolbar component (no props needed anymore)\nfunction Toolbar() {\n  return (\n    <div>\n      <ThemedButton /> {/* No props passed */}\n    </div>\n  );\n}\n\n// ThemedButton component (consumes context)\nfunction ThemedButton() {\n  // 4. Consume the context using useContext hook\n  const { theme, toggleTheme } = useContext(ThemeContext);\n\n  const buttonStyle = {\n    background: theme === 'dark' ? '#333' : '#fff',\n    color: theme === 'dark' ? '#fff' : '#000',\n    padding: '10px 20px',\n    border: 'none',\n    borderRadius: '5px',\n    cursor: 'pointer'\n  };\n  return (\n    <button style={buttonStyle} onClick={toggleTheme}>\n      Current Theme: {theme}\n    </button>\n  );\n}\n\nfunction App() {\n  // 5. Apply theme to App's background and text\n  const { theme } = useContext(ThemeContext); // Also consume theme for App's style\n\n  const appStyle = {\n    background: theme === 'dark' ? '#222' : '#f0f0f0',\n    color: theme === 'dark' ? '#f0f0f0' : '#222',\n    minHeight: '100vh',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center'\n  };\n\n  return (\n    // 3. Wrap the application with ThemeProvider\n    <ThemeProvider>\n      <div style={appStyle}>\n        <h1>Theme App (Context API)</h1>\n        <Toolbar /> {/* No props passed */}\n      </div>\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Initial render displays 'light' theme.",
            "Clicking the button toggles the theme to 'dark' and updates button style and background.",
            "Clicking again toggles theme back to 'light' and updates styles.",
            "Verify `Toolbar` and `ThemedButton` no longer receive `theme` or `toggleTheme` as props (by inspecting component props or static analysis of the solution code).",
            "Ensure no prop drilling occurs for theme-related data in the final structure."
          ],
          "hints": [
            "Start by defining your Context object. Remember it needs a default value, even if it's an empty object with expected shapes.",
            "The `ThemeProvider` component will be a simple functional component that uses `useState` internally for the theme and wraps its `children` with `ThemeContext.Provider`.",
            "The `useContext` hook takes the Context *object* itself as an argument, not the value from the provider.",
            "Don't forget to import `createContext` and `useContext` from 'react'."
          ],
          "tags": [
            "React",
            "Context API",
            "useContext",
            "Prop Drilling",
            "State Management",
            "Refactoring"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React State",
            "React Props",
            "React Hooks"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_use_context"
          ]
        }
      ]
    }
  }
]