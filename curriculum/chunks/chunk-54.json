[
  {
    "id": "135b9b5c-1aa9-4283-a8ee-0df0fb5b6daf",
    "startLine": 11000,
    "endLine": 11099,
    "processedDate": "2025-06-17T11:58:35.402Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_web_storage_event_listener",
          "title": "Web Storage: The 'storage' Event Listener",
          "content": "The `storage` event in web browsers allows different browser windows or tabs from the same origin to react to changes made in `localStorage` or `sessionStorage` by another window/tab. This event is *only* triggered when a storage item is changed, added, or removed by *another* window/tab from the same origin. It does not fire for changes made within the same window that initiated the change. It's a powerful mechanism for synchronizing state across multiple browser contexts.\n\n## Event Properties\nWhen the `storage` event fires, the event object provides several useful properties:\n- `key`: The key of the storage item that was changed.\n- `oldValue`: The old value of the key, or `null` if the key was newly added.\n- `newValue`: The new value of the key, or `null` if the key was removed.\n- `url`: The URL of the document whose storage changed.\n- `storageArea`: The `Storage` object (`localStorage` or `sessionStorage`) that was affected.\n\nThis event is crucial for building real-time collaboration features or ensuring data consistency across multiple open tabs of a web application without needing server-side communication.",
          "examples": [
            {
              "id": "example_storage_event_1",
              "title": "Listening for localStorage Changes",
              "code": "// Listen for changes to localStorage from other windows/tabs\nwindow.addEventListener('storage', (event) => {\n  console.log('Storage changed:');\n  console.log('  Key:', event.key);\n  console.log('  Old Value:', event.oldValue);\n  console.log('  New Value:', event.newValue);\n  console.log('  Source URL:', event.url);\n  console.log('  Storage Area:', event.storageArea === localStorage ? 'localStorage' : 'sessionStorage');\n\n  if (event.key === 'theme' && event.newValue) {\n    document.documentElement.setAttribute('data-theme', event.newValue);\n    console.log(`Theme updated to: ${event.newValue}`);\n  }\n});\n\n// To simulate a change from another tab, open this page in two tabs\n// and in one tab's console, run:\n// localStorage.setItem('theme', 'dark');\n// localStorage.removeItem('theme');",
              "explanation": "This example demonstrates how to set up a `storage` event listener. When a change occurs in `localStorage` or `sessionStorage` from another browser tab/window of the same origin, this callback will execute, logging the details of the change. A practical application is shown where a 'theme' change propagates across tabs.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_storage_event_1",
            "question_storage_event_2",
            "question_storage_event_3",
            "question_storage_event_4"
          ],
          "relatedTasks": [
            "task_storage_event_sync"
          ],
          "tags": [
            "web-storage",
            "browser-api",
            "event-listener",
            "frontend",
            "synchronization"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "web_storage_basics",
            "event_listeners"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "realtime_web_apps",
            "state_management_frontend"
          ]
        },
        {
          "id": "theory_web_security_storage_cookies",
          "title": "Web Security: Storage Mechanisms and Cookies",
          "content": "When dealing with client-side data storage, it's paramount to understand the security implications. Various mechanisms like `localStorage`, `sessionStorage`, and cookies have different security profiles and vulnerabilities.\n\n## Security Considerations for Web Storage (`localStorage`, `sessionStorage`)\n- **Sensitive Data**: Neither `localStorage` nor `sessionStorage` are suitable for storing sensitive data such as user passwords, authentication tokens (especially long-lived ones), or personal identifiable information (PII). This is because they are easily accessible via JavaScript in the browser.\n- **XSS Vulnerabilities**: Cross-Site Scripting (XSS) attacks can directly expose data stored in `localStorage` and `sessionStorage`. If an attacker injects malicious JavaScript into your page (e.g., via unfiltered user input), that script can read, modify, or delete any data in these storage areas and potentially transmit it to a malicious server. For instance, an XSS payload `alert(localStorage.getItem('userToken'))` could steal a user's session token if stored in `localStorage`.\n\n## Security Considerations for Cookies\nCookies are often used for session management and can be more securely configured than web storage for certain use cases. They offer specific flags to mitigate common attacks:\n- **HttpOnly Flag**: This flag prevents client-side JavaScript from accessing the cookie. If an `HttpOnly` cookie is set, `document.cookie` will not show its value, significantly mitigating XSS attacks that attempt to steal cookies. The cookie will only be sent with HTTP requests.\n- **Secure Flag**: This flag ensures that the cookie is only sent over encrypted HTTPS connections. This prevents man-in-the-middle attacks from intercepting the cookie data when transmitted over an insecure network (HTTP).\n- **SameSite Attribute**: This attribute helps prevent Cross-Site Request Forgery (CSRF) attacks by controlling when cookies are sent with cross-site requests. It has three main values:\n    - `Lax`: Cookies are sent with top-level navigations and same-site requests. Most common and recommended default.\n    - `Strict`: Cookies are only sent with same-site requests, providing the strongest protection.\n    - `None`: Cookies are sent with all requests, including cross-site requests. Requires the `Secure` flag to be set.\n    \nBy properly configuring these flags, cookies can be a more secure option for storing authentication tokens or session IDs, especially when combined with robust server-side validation.",
          "examples": [
            {
              "id": "example_cookie_security_1",
              "title": "Setting Secure Cookies (Server-side Node.js)",
              "code": "const express = require('express');\nconst app = express();\n\napp.get('/login', (req, res) => {\n  // After successful authentication, set a session cookie\n  res.cookie('sessionToken', 'your_secure_jwt_token', {\n    httpOnly: true, // Prevent JavaScript access\n    secure: true,   // Only send over HTTPS\n    sameSite: 'Lax', // Protect against CSRF\n    maxAge: 3600000 // Cookie valid for 1 hour (in ms)\n  });\n  res.send('Logged in successfully!');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
              "explanation": "This Node.js (Express) example demonstrates how to set a cookie with critical security flags: `httpOnly`, `secure`, and `sameSite`. This configuration prevents JavaScript access to the cookie, ensures it's only sent over HTTPS, and provides CSRF protection, making it significantly more secure for authentication tokens than `localStorage`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_security_storage_1",
            "question_security_storage_2",
            "question_security_storage_3",
            "question_security_storage_4",
            "question_security_storage_5"
          ],
          "relatedTasks": [
            "task_secure_cookie_implementation"
          ],
          "tags": [
            "web-security",
            "cookies",
            "local-storage",
            "session-storage",
            "xss",
            "csrf",
            "httponly",
            "secure-flag",
            "samesite"
          ],
          "technology": "Web",
          "prerequisites": [
            "web_storage_basics",
            "http_basics",
            "browser_security_fundamentals"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "secure_web_applications",
            "backend_api_development"
          ]
        },
        {
          "id": "theory_web_security_cors",
          "title": "Web Security: Cross-Origin Resource Sharing (CORS)",
          "content": "CORS (Cross-Origin Resource Sharing) is a browser security mechanism that allows web applications running at one domain (origin) to make controlled requests to resources at another domain. It's an essential part of modern web security, enabling safe cross-origin data transfer while upholding the **Same-Origin Policy (SOP)**.\n\n## Same-Origin Policy (SOP)\nBy default, web browsers enforce the Same-Origin Policy. This policy restricts a web page from making requests to a different origin (a different protocol, domain, or port) than the one from which the page was loaded. This prevents malicious scripts on one site from accessing sensitive data on another site (e.g., banking sites).\n\n## How CORS Works\nCORS extends the SOP by using special HTTP headers to allow servers to explicitly specify which origins are permitted to access their resources. When a browser detects a cross-origin request, it checks for these CORS headers in the server's response. If the headers indicate that the origin is allowed, the browser proceeds with the request; otherwise, it blocks it.\n\n### Simple vs. Non-Simple Requests\n- **Simple Requests**: These requests do not trigger a CORS preflight. They must meet all of the following conditions:\n    - Method: GET, POST, or HEAD only.\n    - Headers: Only 'Accept', 'Accept-Language', 'Content-Language', 'Content-Type' (with specific values like `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`).\n- **Non-Simple Requests**: Any request that does not meet the criteria for a simple request (e.g., PUT, DELETE, PATCH methods, or custom headers like `Authorization`). These requests trigger a **Preflight Request**.\n\n### Preflight Requests (`OPTIONS` Method)\nFor non-simple requests, the browser first sends an `OPTIONS` HTTP request (the 'preflight') to the resource on the other origin. This preflight request asks the server for permission to send the actual request. The server's response to the `OPTIONS` request contains CORS headers indicating whether the actual request is allowed (e.g., which methods or headers are permitted). If the preflight succeeds, the browser sends the actual request; otherwise, it blocks it.\n\n## Common CORS Headers\nServers use specific HTTP response headers to control CORS behavior:\n- `Access-Control-Allow-Origin`: Specifies which origins (domains) are allowed to access the resource. Can be a specific origin (e.g., `https://trusted-domain.com`) or `*` (allowing any origin, generally not recommended for production APIs).\n- `Access-Control-Allow-Methods`: Specifies which HTTP methods (e.g., GET, POST, PUT, DELETE) are allowed for the resource.\n- `Access-Control-Allow-Headers`: Specifies which HTTP request headers (e.g., `Content-Type`, `Authorization`, `X-Custom-Header`) are allowed.\n- `Access-Control-Allow-Credentials`: Indicates whether the browser should expose the response to the frontend JavaScript code when the request's credentials mode is `include`. This is necessary for requests that involve cookies, HTTP authentication, or client-side SSL certificates. If set to `true`, `Access-Control-Allow-Origin` cannot be `*`.\n- `Access-Control-Expose-Headers`: Specifies which headers, besides the six simple response headers, are safe to expose to the API of a `XMLHttpRequest` or `Fetch` response.\n- `Access-Control-Max-Age`: Indicates how long the results of a preflight request can be cached by the browser, reducing the number of `OPTIONS` requests.",
          "examples": [
            {
              "id": "example_cors_server_1",
              "title": "Server-side CORS Header Example (Node.js/Express)",
              "code": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  // Allow requests from a specific trusted origin\n  res.header('Access-Control-Allow-Origin', 'https://trusted-domain.com');\n  // Allow common methods\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n  // Allow common headers, including custom ones like Authorization\n  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Custom-Header');\n  // Allow credentials (cookies, HTTP auth) to be sent\n  res.header('Access-Control-Allow-Credentials', 'true');\n  // Cache preflight results for 1 hour (3600 seconds)\n  res.header('Access-Control-Max-Age', '3600');\n\n  // Handle preflight OPTIONS requests\n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(204); // No content, just headers\n  }\n\n  next();\n});\n\napp.get('/data', (req, res) => {\n  res.json({ message: 'Data from server!' });\n});\n\napp.listen(4000, () => console.log('CORS-enabled server running on port 4000'));",
              "explanation": "This Node.js (Express) example demonstrates how to configure CORS headers on the server. It allows a specific origin (`https://trusted-domain.com`) to make requests, defines allowed methods and headers, and enables credential support. It also includes handling for preflight `OPTIONS` requests, which are essential for non-simple cross-origin requests.",
              "language": "javascript"
            },
            {
              "id": "example_cors_client_1",
              "title": "Client-side Cross-Origin Fetch Request",
              "code": "async function fetchDataFromApi() {\n  try {\n    // Example of a simple GET request\n    const response = await fetch('http://localhost:4000/data');\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    console.log('Received data (simple request):', data);\n\n    // Example of a non-simple POST request with custom header and credentials\n    const postResponse = await fetch('http://localhost:4000/data', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer my_token_123'\n      },\n      body: JSON.stringify({ item: 'new item' }),\n      credentials: 'include' // Important for sending cookies/auth across origins\n    });\n    if (!postResponse.ok) {\n      throw new Error(`HTTP error! status: ${postResponse.status}`);\n    }\n    const postData = await postResponse.json();\n    console.log('Received data (non-simple request):', postData);\n\n  } catch (error) {\n    console.error('CORS or fetch error:', error);\n  }\n}\n\n// Call the function to test\n// fetchDataFromApi();",
              "explanation": "This client-side JavaScript example shows how to make cross-origin `fetch` requests. The first `GET` request is a simple request. The second `POST` request is a non-simple request because of its `Content-Type` and `Authorization` header, and it explicitly includes `credentials` to send cookies (if allowed by the server's CORS configuration). If the server does not have appropriate CORS headers, these requests will be blocked by the browser.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_cors_1",
            "question_cors_2",
            "question_cors_3",
            "question_cors_4",
            "question_cors_5",
            "question_cors_6",
            "question_cors_7"
          ],
          "relatedTasks": [
            "task_cors_implementation",
            "task_debug_cors"
          ],
          "tags": [
            "web-security",
            "cors",
            "same-origin-policy",
            "http-headers",
            "preflight",
            "frontend",
            "backend",
            "networking"
          ],
          "technology": "Web",
          "prerequisites": [
            "http_basics",
            "network_requests"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "api_integration",
            "fullstack_development",
            "troubleshooting_web_issues"
          ]
        },
        {
          "id": "theory_script_loading_strategies",
          "title": "Script Loading Strategies: Regular, Async, and Defer",
          "content": "The way JavaScript files are included and loaded in an HTML document significantly impacts page rendering performance and user experience. Modern browsers offer several attributes for the `<script>` tag to control script fetching and execution behavior: `async` and `defer`.\n\n## 1. Regular Script Tag\n`<script src=\"script.js\"></script>` or inline `<script>`\n\n- **Blocking Behavior**: When the browser encounters a regular `<script>` tag, it pauses HTML parsing. It then fetches the script, executes it, and only after execution is complete does it resume HTML parsing. This can lead to a noticeable delay in page rendering, especially for large scripts or slow networks.\n- **Execution Order**: Scripts are executed in the order they appear in the HTML.\n- **DOM Dependency**: If placed in the `<head>`, these scripts will execute before the DOM is fully parsed and available.\n\n**When to use**: When the script's execution must happen at exactly that point in the page's parsing, e.g., for polyfills or scripts that dynamically alter the HTML content before it's rendered, or when blocking is acceptable for small, critical scripts.\n\n## 2. Async Script Tag\n`<script async src=\"script.js\"></script>`\n\n- **Parallel Download**: The `async` attribute tells the browser to download the script in parallel with HTML parsing. HTML parsing continues while the script is being fetched.\n- **Independent Execution**: The script executes as soon as it's downloaded, without waiting for HTML parsing to complete or for other scripts. This means script execution can interrupt HTML parsing.\n- **Execution Order**: The execution order of multiple `async` scripts is *not guaranteed*. They execute as soon as they finish downloading.\n- **DOM Dependency**: Should not be used for scripts that depend on the full DOM structure being available.\n\n**When to use**: Best for independent scripts that don't rely on other scripts or the full DOM structure. Common use cases include analytics scripts (e.g., Google Analytics), ad scripts, or third-party widgets, where their immediate availability is less critical than page render speed.\n\n## 3. Defer Script Tag\n`<script defer src=\"script.js\"></script>`\n\n- **Parallel Download**: Similar to `async`, `defer` also downloads the script in parallel with HTML parsing.\n- **Deferred Execution**: The key difference is that `defer` scripts execute *only after* HTML parsing is completely finished (just before the `DOMContentLoaded` event). They do not interrupt HTML parsing.\n- **Execution Order**: The execution order of multiple `defer` scripts *is guaranteed* to be the same as their order in the HTML document.\n- **DOM Dependency**: Ideal for scripts that depend on the full DOM structure and need to execute after it's ready.\n\n**When to use**: Best for scripts that depend on the full DOM structure (e.g., manipulating elements, event listeners) and/or require maintaining execution order with other scripts. This is often the preferred strategy for most application-specific JavaScript.",
          "examples": [
            {
              "id": "example_script_loading_1",
              "title": "Demonstrating Script Loading Behavior",
              "code": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Script Loading Example</title>\n  \n  <!-- Regular Script (blocking) -->\n  <script>\n    console.log('1. Inline regular script (executed immediately, blocks parsing)');\n    // Simulate heavy computation\n    let i = 0; while (i < 100000000) { i++; }\n    console.log('1. Inline regular script finished');\n  </script>\n  \n  <!-- Async Script -->\n  <script async src=\"async-script.js\"></script>\n  \n  <!-- Defer Script -->\n  <script defer src=\"defer-script.js\"></script>\n</head>\n<body>\n  <h1>Script Loading Demo</h1>\n  <div id=\"app\"></div>\n  \n  <!-- Regular Script (blocking, after content) -->\n  <script>\n    console.log('4. Inline regular script at body end (executed after some HTML parsing)');\n    const appDiv = document.getElementById('app');\n    if (appDiv) appDiv.textContent = 'Content from body-end script';\n  </script>\n</body>\n</html>\n\n<!-- async-script.js -->\nconsole.log('2. Async script (downloaded in parallel, executes when ready)');\n// Simulate network delay and execution\nsetTimeout(() => {\n  console.log('2. Async script finished after delay');\n}, 10);\n\n<!-- defer-script.js -->\nconsole.log('3. Defer script (downloaded in parallel, executes after HTML parsing)');\n// Simulate network delay and execution\nsetTimeout(() => {\n  console.log('3. Defer script finished after delay');\n  const appDiv = document.getElementById('app');\n  if (appDiv) appDiv.textContent = 'Content from defer script';\n}, 5);\n",
              "explanation": "This set of files demonstrates the different script loading behaviors. The inline regular script in the head blocks parsing. The `async` script downloads in parallel and executes as soon as it's ready (potentially before `defer` or even before all HTML is parsed). The `defer` script also downloads in parallel but waits until HTML parsing is complete before executing, ensuring DOM availability and preserving relative execution order among other deferred scripts. The regular script at the end of the body executes after the preceding HTML is parsed.",
              "language": "html"
            }
          ],
          "relatedQuestions": [
            "question_script_loading_1",
            "question_script_loading_2",
            "question_script_loading_3",
            "question_script_loading_4",
            "question_script_loading_5",
            "question_script_loading_6"
          ],
          "relatedTasks": [
            "task_optimize_script_loading"
          ],
          "tags": [
            "performance",
            "script-loading",
            "async",
            "defer",
            "html-parsing",
            "dom-content-loaded",
            "frontend-optimization"
          ],
          "technology": "HTML",
          "prerequisites": [
            "html_structure",
            "javascript_basics",
            "browser_rendering_process"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "web_performance_optimization",
            "large_scale_frontend_apps"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_storage_event_1",
          "topic": "Web Storage 'storage' Event",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `storage` event in JavaScript?",
          "answer": "To notify other browser windows/tabs from the same origin about changes made to `localStorage` or `sessionStorage`.",
          "options": [],
          "analysisPoints": [
            "Checks understanding of the `storage` event's core function.",
            "Distinguishes its purpose from direct `localStorage` operations."
          ],
          "keyConcepts": [
            "storage-event",
            "localStorage",
            "sessionStorage",
            "cross-tab-communication"
          ],
          "evaluationCriteria": [
            "Direct recall of event purpose"
          ],
          "example": "",
          "tags": [
            "web-storage",
            "browser-api",
            "event-listener",
            "flashcard"
          ],
          "prerequisites": [
            "web_storage_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_storage_event_2",
          "topic": "Web Storage 'storage' Event Behavior",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code executed in a browser tab:\n```javascript\nwindow.addEventListener('storage', (event) => {\n  console.log('Storage event fired!');\n});\n\nlocalStorage.setItem('myData', 'value1');\nconsole.log('Item set in localStorage.');\n```\nWhen this code runs, what will be logged to the console?\n\nA) 'Storage event fired!' and 'Item set in localStorage.'\nB) Only 'Storage event fired!'\nC) Only 'Item set in localStorage.'\nD) Nothing will be logged related to the storage event, only 'Item set in localStorage.' will appear.",
          "answer": "C) Only 'Item set in localStorage.'",
          "options": [
            "A) 'Storage event fired!' and 'Item set in localStorage.'",
            "B) Only 'Storage event fired!'",
            "C) Only 'Item set in localStorage.'",
            "D) Nothing will be logged related to the storage event, only 'Item set in localStorage.' will appear."
          ],
          "analysisPoints": [
            "Tests understanding that the `storage` event does not fire in the same window that initiated the change.",
            "Distinguishes between local actions and cross-window events."
          ],
          "keyConcepts": [
            "storage-event",
            "event-triggering",
            "localStorage",
            "same-window"
          ],
          "evaluationCriteria": [
            "Accurate prediction of event behavior",
            "Understanding of event scope"
          ],
          "example": "The `storage` event is designed for *cross-window* communication. If `localStorage.setItem` is called in the same window that has the `storage` event listener, the event listener will *not* be triggered in that window. It would only be triggered in *other* open tabs or windows of the same origin.",
          "tags": [
            "web-storage",
            "browser-api",
            "event-listener",
            "mcq"
          ],
          "prerequisites": [
            "web_storage_basics",
            "event_listeners"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_storage_event_3",
          "topic": "Web Storage 'storage' Event Properties",
          "level": "medium",
          "type": "open",
          "question": "Imagine you are building a real-time collaborative document editor where changes made in one tab need to be reflected in another tab instantly. Explain how the `storage` event can be leveraged for this functionality. Specifically, describe which properties of the `event` object you would utilize to understand and apply the changes.",
          "answer": "The `storage` event is perfect for this scenario. When a user in one tab makes a change (e.g., saves content to `localStorage`), that tab would call `localStorage.setItem('documentContent', newContent)`. Simultaneously, all *other* tabs for the same document (same origin) would have a `storage` event listener active.\n\nWhen the `storage` event fires in these other tabs, the `event` object would provide the necessary information:\n- `event.key`: This would be `'documentContent'`, indicating that the content of the document has changed.\n- `event.newValue`: This would contain the `newContent` string, which is the updated version of the document from the tab that made the change.\n- `event.oldValue`: This would contain the previous state of the document, useful for comparing changes or implementing undo/redo functionality if needed.\n- `event.url`: Could be used to identify which specific URL initiated the change, though often less critical for direct content synchronization.\n- `event.storageArea`: Would confirm it's `localStorage` being used for persistent storage.\n\nThe listening tabs would then take `event.newValue` and update their respective UI elements (e.g., the `textarea` or display div) to reflect the new document content, effectively synchronizing the editor's state across all open tabs.",
          "options": [],
          "analysisPoints": [
            "Assesses ability to apply the `storage` event to a practical use case.",
            "Verifies knowledge of specific event object properties (`key`, `newValue`, `oldValue`).",
            "Encourages thinking about real-time synchronization challenges."
          ],
          "keyConcepts": [
            "storage-event",
            "real-time-sync",
            "localStorage",
            "event-object-properties",
            "collaborative-apps"
          ],
          "evaluationCriteria": [
            "Clarity of explanation",
            "Correct use of event properties",
            "Realistic application scenario"
          ],
          "example": "",
          "tags": [
            "web-storage",
            "browser-api",
            "event-listener",
            "open-ended",
            "system-design"
          ],
          "prerequisites": [
            "web_storage_basics",
            "event_listeners"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_storage_event_4",
          "topic": "Web Storage Limitations",
          "level": "hard",
          "type": "code",
          "question": "Implement a simplified cross-tab communication mechanism using `localStorage` and the `storage` event. The goal is to create a 'message board' where a message typed in one tab's input field appears in a `div` on all other open tabs. The message should *not* appear in the tab where it was originally typed (it should only appear in `div`s on *other* tabs).\n\nProvide the HTML and JavaScript code.",
          "answer": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Cross-Tab Message Board</title>\n</head>\n<body>\n    <h1>Cross-Tab Message Board</h1>\n    <input type=\"text\" id=\"messageInput\" placeholder=\"Type a message...\">\n    <button id=\"sendMessageBtn\">Send Message</button>\n    <h2>Received Messages:</h2>\n    <div id=\"messageDisplay\" style=\"border: 1px solid #ccc; padding: 10px; min-height: 50px;\">No messages yet.</div>\n\n    <script>\n        const messageInput = document.getElementById('messageInput');\n        const sendMessageBtn = document.getElementById('sendMessageBtn');\n        const messageDisplay = document.getElementById('messageDisplay');\n        const MESSAGE_KEY = 'cross_tab_message';\n\n        // Listener for changes made by *other* tabs\n        window.addEventListener('storage', (event) => {\n            if (event.key === MESSAGE_KEY && event.newValue !== null) {\n                // Only update if the message has a new value (not deleted)\n                messageDisplay.textContent = `New message: \"${event.newValue}\"`;\n                console.log(`Received message in this tab from another tab: ${event.newValue}`);\n            } else if (event.key === MESSAGE_KEY && event.newValue === null) {\n                // Handle message deletion/clearing\n                messageDisplay.textContent = 'Message cleared by another tab.';\n                console.log('Message cleared by another tab.');\n            }\n        });\n\n        // Event handler for sending a message\n        sendMessageBtn.addEventListener('click', () => {\n            const message = messageInput.value.trim();\n            if (message) {\n                // Set the item in localStorage, which will trigger the 'storage' event in other tabs\n                localStorage.setItem(MESSAGE_KEY, message);\n                console.log(`Message sent from this tab: \"${message}\"`);\n                messageInput.value = ''; // Clear input after sending\n            }\n        });\n\n        // Optional: Clear message when the tab is closed or reloaded (for a fresh start)\n        window.addEventListener('beforeunload', () => {\n            // You might choose to clear or not clear depending on desired persistence\n            // localStorage.removeItem(MESSAGE_KEY);\n        });\n\n        // Initial check if there's an existing message when a new tab opens\n        const initialMessage = localStorage.getItem(MESSAGE_KEY);\n        if (initialMessage) {\n            messageDisplay.textContent = `Initial message: \"${initialMessage}\"`;\n        }\n\n    </script>\n</body>\n</html>\n```",
          "options": [],
          "analysisPoints": [
            "Tests practical implementation of `storage` event.",
            "Confirms understanding that the `storage` event does not fire in the originator tab.",
            "Assesses ability to handle event properties (`key`, `newValue`).",
            "Evaluates proper use of `localStorage.setItem` to trigger the event."
          ],
          "keyConcepts": [
            "storage-event",
            "localStorage",
            "cross-tab-communication",
            "event-listeners",
            "dom-manipulation"
          ],
          "evaluationCriteria": [
            "Correct use of `addEventListener` for `storage`.",
            "Proper handling of `event.key` and `event.newValue`.",
            "Successful demonstration of cross-tab sync without self-triggering.",
            "Clear and runnable code."
          ],
          "example": "To test this code:\n1.  Save the code as `index.html`.\n2.  Open `index.html` in your browser.\n3.  Duplicate the tab (or open a new tab/window to the same URL).\n4.  Type a message in the input field of one tab and click 'Send Message'.\n5.  Observe that the message appears in the 'Received Messages' div of the *other* tab, but not in the tab where you typed it.",
          "tags": [
            "web-storage",
            "browser-api",
            "event-listener",
            "coding-challenge",
            "hard"
          ],
          "prerequisites": [
            "web_storage_basics",
            "event_listeners",
            "dom_manipulation"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_security_storage_1",
          "topic": "Web Security: Storage & Cookies",
          "level": "easy",
          "type": "flashcard",
          "question": "Why are `localStorage` and `sessionStorage` generally not suitable for sensitive data like authentication tokens?",
          "answer": "Because they are easily accessible via client-side JavaScript, making them vulnerable to XSS attacks.",
          "options": [],
          "analysisPoints": [
            "Tests basic security knowledge regarding client-side storage.",
            "Highlights the primary vulnerability of Web Storage."
          ],
          "keyConcepts": [
            "localStorage",
            "sessionStorage",
            "security",
            "xss",
            "sensitive-data"
          ],
          "evaluationCriteria": [
            "Direct recall of security risk"
          ],
          "example": "",
          "tags": [
            "web-security",
            "local-storage",
            "flashcard"
          ],
          "prerequisites": [
            "web_storage_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_security_storage_2",
          "topic": "Web Security: Cookies",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following cookie flags is used to prevent client-side JavaScript from accessing the cookie, thereby mitigating certain XSS attack vectors?\n\nA) `Secure`\nB) `SameSite`\nC) `HttpOnly`\nD) `Expires`",
          "answer": "C) `HttpOnly`",
          "options": [
            "A) `Secure`",
            "B) `SameSite`",
            "C) `HttpOnly`",
            "D) `Expires`"
          ],
          "analysisPoints": [
            "Tests specific knowledge of cookie security attributes.",
            "Distinguishes `HttpOnly` from other flags like `Secure` and `SameSite`."
          ],
          "keyConcepts": [
            "cookies",
            "httponly",
            "xss",
            "security-flags"
          ],
          "evaluationCriteria": [
            "Correct identification of the `HttpOnly` flag's purpose"
          ],
          "example": "The `HttpOnly` flag ensures that the cookie is not accessible through `document.cookie` in JavaScript. This means that even if an XSS vulnerability allows an attacker to inject malicious scripts, they cannot read and exfiltrate `HttpOnly` cookies. The cookie will still be sent with HTTP requests.",
          "tags": [
            "web-security",
            "cookies",
            "mcq"
          ],
          "prerequisites": [
            "http_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_security_storage_3",
          "topic": "Web Security: Cookies and HTTPS",
          "level": "easy",
          "type": "flashcard",
          "question": "Which cookie flag ensures that a cookie is only sent over encrypted HTTPS connections?",
          "answer": "`Secure`",
          "options": [],
          "analysisPoints": [
            "Tests basic recall of cookie security flags.",
            "Connects a flag to network security (HTTPS)."
          ],
          "keyConcepts": [
            "cookies",
            "secure-flag",
            "https",
            "network-security"
          ],
          "evaluationCriteria": [
            "Direct recall of specific flag"
          ],
          "example": "",
          "tags": [
            "web-security",
            "cookies",
            "flashcard"
          ],
          "prerequisites": [
            "http_basics",
            "https_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_security_storage_4",
          "topic": "Web Security: SameSite Cookie Attribute",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of the `SameSite` cookie attribute and discuss the differences between its `Lax`, `Strict`, and `None` values in the context of preventing CSRF attacks.",
          "answer": "The `SameSite` cookie attribute is a security measure designed to prevent Cross-Site Request Forgery (CSRF) attacks. It controls when cookies are sent with cross-site requests, meaning requests originating from a different site than the one the cookie belongs to. By default, browsers no longer send cookies with all cross-site requests, relying on `SameSite` to dictate this behavior.\n\nHere are the differences between its values:\n\n1.  **`SameSite=Lax` (Default)**:\n    *   **Behavior**: Cookies are sent with same-site requests and with cross-site top-level navigations (e.g., clicking a link that leads to another site, or a `GET` form submission) that change the URL in the address bar. They are *not* sent with cross-site requests initiated by embedded content (like `<img>` tags, `<iframe>`s, `XHR`/`fetch` requests) unless they are top-level navigations.\n    *   **CSRF Protection**: Provides a good balance between security and user experience. It offers strong protection against most common CSRF vectors, as typical CSRF attacks involve non-top-level cross-site requests.\n    *   **Use Case**: Recommended default for most cookies.\n\n2.  **`SameSite=Strict`**:\n    *   **Behavior**: Cookies are *only* sent with same-site requests. They are never sent with any cross-site requests, even if they are top-level navigations.\n    *   **CSRF Protection**: Provides the strongest protection against CSRF, as it entirely prevents cookies from being sent cross-site.\n    *   **Use Case**: Suitable for cookies holding highly sensitive information (e.g., bank session cookies) where strict security is prioritized over user convenience (e.g., user might have to log in again if they click a link from an external site).\n\n3.  **`SameSite=None`**:\n    *   **Behavior**: Cookies are sent with all requests, both same-site and cross-site. This effectively reverts to the older, less secure default behavior.\n    *   **Requirement**: When `SameSite=None` is used, the `Secure` attribute *must* also be set, meaning the cookie will only be sent over HTTPS connections. If `Secure` is not set, `SameSite=None` will be ignored by browsers.\n    *   **CSRF Protection**: Offers *no* CSRF protection on its own. It's used when legitimate cross-site requests require cookies (e.g., third-party widgets, embedded content that needs authentication).\n    *   **Use Case**: Required for cross-site purposes like embedded iframes, certain OAuth flows, or third-party analytics that rely on cookies.\n\nIn summary, `SameSite` is a crucial defense against CSRF, with `Lax` being a good default, `Strict` for maximum security, and `None` (with `Secure`) for specific cross-site functionality.",
          "options": [],
          "analysisPoints": [
            "Tests comprehensive understanding of `SameSite` attribute.",
            "Requires differentiation between `Lax`, `Strict`, and `None`.",
            "Connects attribute to CSRF prevention.",
            "Highlights the `Secure` flag requirement for `SameSite=None`."
          ],
          "keyConcepts": [
            "cookies",
            "samesite",
            "csrf",
            "security-flags",
            "http"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions",
            "Clarity of differences",
            "Correct linkage to CSRF",
            "Completeness of explanation"
          ],
          "example": "",
          "tags": [
            "web-security",
            "cookies",
            "open-ended"
          ],
          "prerequisites": [
            "http_basics",
            "csrf_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_security_storage_5",
          "topic": "Web Security: XSS vs. CSRF",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements most accurately describes the primary difference between how `HttpOnly` and `SameSite` cookie attributes protect against attacks?\n\nA) `HttpOnly` prevents CSRF attacks, while `SameSite` prevents XSS attacks.\nB) `HttpOnly` prevents JavaScript access to cookies (mitigating XSS), while `SameSite` restricts cross-site cookie sending (mitigating CSRF).\nC) Both `HttpOnly` and `SameSite` primarily prevent XSS attacks by restricting cookie visibility.\nD) Both `HttpOnly` and `SameSite` primarily prevent CSRF attacks by ensuring cookies are only sent over HTTPS.",
          "answer": "B) `HttpOnly` prevents JavaScript access to cookies (mitigating XSS), while `SameSite` restricts cross-site cookie sending (mitigating CSRF).",
          "options": [
            "A) `HttpOnly` prevents CSRF attacks, while `SameSite` prevents XSS attacks.",
            "B) `HttpOnly` prevents JavaScript access to cookies (mitigating XSS), while `SameSite` restricts cross-site cookie sending (mitigating CSRF).",
            "C) Both `HttpOnly` and `SameSite` primarily prevent XSS attacks by restricting cookie visibility.",
            "D) Both `HttpOnly` and `SameSite` primarily prevent CSRF attacks by ensuring cookies are only sent over HTTPS."
          ],
          "analysisPoints": [
            "Tests ability to differentiate the specific attack vectors addressed by `HttpOnly` and `SameSite`.",
            "Ensures clear understanding of XSS (client-side script injection) vs. CSRF (unauthorized requests from user's browser)."
          ],
          "keyConcepts": [
            "httponly",
            "samesite",
            "xss",
            "csrf",
            "security-flags"
          ],
          "evaluationCriteria": [
            "Correctly associates each flag with its primary defense mechanism"
          ],
          "example": "`HttpOnly` makes cookies inaccessible to client-side scripts, protecting against attackers stealing cookies via XSS. `SameSite` dictates when cookies are sent with cross-site requests, specifically preventing an attacker from tricking a user's browser into making an unwanted request to a legitimate site while logged in (CSRF).",
          "tags": [
            "web-security",
            "cookies",
            "xss",
            "csrf",
            "mcq"
          ],
          "prerequisites": [
            "xss_basics",
            "csrf_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cors_1",
          "topic": "CORS Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of CORS?",
          "answer": "CORS (Cross-Origin Resource Sharing) is a security mechanism that allows web applications running at one domain to make controlled requests to resources at another domain, safely bypassing the Same-Origin Policy.",
          "options": [],
          "analysisPoints": [
            "Tests basic definition and purpose of CORS.",
            "Connects CORS to the Same-Origin Policy."
          ],
          "keyConcepts": [
            "cors",
            "same-origin-policy",
            "web-security"
          ],
          "evaluationCriteria": [
            "Direct recall of CORS definition"
          ],
          "example": "",
          "tags": [
            "web-security",
            "cors",
            "flashcard"
          ],
          "prerequisites": [
            "http_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_cors_2",
          "topic": "Same-Origin Policy",
          "level": "medium",
          "type": "open",
          "question": "Describe the Same-Origin Policy (SOP) and explain why it is a fundamental security concept in web browsers. How does CORS relate to or modify the SOP?",
          "answer": "The **Same-Origin Policy (SOP)** is a critical security mechanism built into web browsers. It dictates that a web page can only interact (read, write, or make requests) with resources that originate from the same 'origin'. An origin is defined by the combination of protocol (e.g., `http`, `https`), host (domain name, e.g., `example.com`), and port (e.g., `80`, `443`). If any of these three components differ, the origins are considered different.\n\n**Why it's fundamental for security**: The SOP prevents malicious websites from accessing sensitive data loaded from other websites in the user's browser. Without SOP, a malicious script embedded on `evil.com` could, for instance, make an AJAX request to `yourbank.com` while you're logged in, read your account balance, and send it to the attacker's server. SOP effectively sandboxes web content, isolating documents from different origins to prevent such data theft.\n\n**How CORS relates to SOP**: CORS (Cross-Origin Resource Sharing) does not 'disable' the SOP; rather, it provides a controlled, secure way to *relax* it for legitimate cross-origin communication. While SOP *by default* blocks cross-origin requests, CORS introduces a mechanism for servers to explicitly grant permissions to specific origins. Servers use special HTTP response headers (like `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods`, etc.) to inform the browser that a particular cross-origin request is permissible. The browser, acting as the enforcer of SOP, will then allow the request to proceed if the server's CORS headers indicate permission, otherwise, it will block the request and raise a CORS error. This allows APIs to be consumed by different frontend applications while maintaining security.",
          "options": [],
          "analysisPoints": [
            "Tests deep understanding of SOP definition and purpose.",
            "Explains the security rationale behind SOP.",
            "Clearly articulates how CORS works as an intentional relaxation of SOP.",
            "Mentions the key components of an 'origin'."
          ],
          "keyConcepts": [
            "same-origin-policy",
            "web-security",
            "cors",
            "browser-security",
            "origin-definition"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation",
            "Accuracy of security implications",
            "Clarity of CORS-SOP relationship"
          ],
          "example": "",
          "tags": [
            "web-security",
            "cors",
            "open-ended"
          ],
          "prerequisites": [
            "http_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cors_3",
          "topic": "CORS Request Types",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following requests would typically *not* trigger a CORS preflight (`OPTIONS`) request?\n\nA) A `PUT` request with `Content-Type: application/json`.\nB) A `GET` request with a custom header `X-Auth-Token`.\nC) A `POST` request with `Content-Type: text/plain`.\nD) A `DELETE` request to a different origin.",
          "answer": "C) A `POST` request with `Content-Type: text/plain`.",
          "options": [
            "A) A `PUT` request with `Content-Type: application/json`.",
            "B) A `GET` request with a custom header `X-Auth-Token`.",
            "C) A `POST` request with `Content-Type: text/plain`.",
            "D) A `DELETE` request to a different origin."
          ],
          "analysisPoints": [
            "Tests knowledge of simple vs. non-simple requests in CORS.",
            "Requires recalling the specific conditions for a simple request (methods and headers)."
          ],
          "keyConcepts": [
            "cors",
            "preflight-request",
            "simple-request",
            "non-simple-request"
          ],
          "evaluationCriteria": [
            "Correctly identifies the simple request scenario"
          ],
          "example": "Simple requests are typically `GET`, `POST`, or `HEAD` with specific `Content-Type` headers (`application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`) and no custom headers. Options A, B, and D are all non-simple: `PUT` and `DELETE` are non-simple methods, and a custom header (`X-Auth-Token`) makes a `GET` request non-simple.",
          "tags": [
            "web-security",
            "cors",
            "mcq"
          ],
          "prerequisites": [
            "http_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cors_4",
          "topic": "CORS Headers",
          "level": "easy",
          "type": "flashcard",
          "question": "Which CORS header is used by the server to specify which origins are allowed to access the resource?",
          "answer": "`Access-Control-Allow-Origin`",
          "options": [],
          "analysisPoints": [
            "Tests recall of the most fundamental CORS header.",
            "Connects header to its specific function."
          ],
          "keyConcepts": [
            "cors",
            "access-control-allow-origin",
            "http-headers"
          ],
          "evaluationCriteria": [
            "Direct recall of header name"
          ],
          "example": "",
          "tags": [
            "web-security",
            "cors",
            "flashcard"
          ],
          "prerequisites": [
            "http_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_cors_5",
          "topic": "CORS Credentials",
          "level": "medium",
          "type": "open",
          "question": "When making a cross-origin `fetch` request that needs to include cookies (or HTTP authentication), what specific client-side `fetch` option and server-side CORS header are required for this to work correctly? Explain why both are necessary.",
          "answer": "To include credentials (like cookies or HTTP authentication) in a cross-origin `fetch` request, both client-side and server-side configurations are required:\n\n1.  **Client-side `fetch` option**: You must set `credentials: 'include'` in the `fetch` request options. For example:\n    ```javascript\n    fetch('https://api.example.com/data', {\n      method: 'GET',\n      credentials: 'include'\n    });\n    ```\n    By default, `fetch` requests with cross-origin URLs do not send cookies or HTTP authentication headers. Setting `credentials: 'include'` explicitly tells the browser to send them.\n\n2.  **Server-side CORS header**: The server must respond with the `Access-Control-Allow-Credentials: true` header. For example:\n    ```\n    Access-Control-Allow-Origin: https://your-frontend-domain.com\n    Access-Control-Allow-Credentials: true\n    ```\n    This header tells the browser that the server is willing to accept requests that include credentials from the specified `Access-Control-Allow-Origin`. **Important**: If `Access-Control-Allow-Credentials` is `true`, then `Access-Control-Allow-Origin` *cannot* be the wildcard `*`; it must be a specific origin.\n\n**Why both are necessary**: The browser acts as a security gatekeeper. The `credentials: 'include'` option signals to the browser that *you intend* to send credentials with this cross-origin request. However, the browser will *only* send them if the server explicitly grants permission via `Access-Control-Allow-Credentials: true` in its response. This two-way consent mechanism ensures that credentials are not inadvertently leaked to unapproved third-party servers, upholding the principle of least privilege and enhancing security.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of `fetch` API `credentials` option.",
            "Tests knowledge of `Access-Control-Allow-Credentials` header.",
            "Explains the necessity of both client and server configuration.",
            "Highlights the restriction of `Access-Control-Allow-Origin` when `Credentials` is true."
          ],
          "keyConcepts": [
            "cors",
            "fetch-api",
            "credentials",
            "access-control-allow-credentials",
            "http-headers",
            "web-security"
          ],
          "evaluationCriteria": [
            "Accuracy of required configurations",
            "Clarity of explanation for mutual necessity",
            "Correctly identifies `*` restriction"
          ],
          "example": "",
          "tags": [
            "web-security",
            "cors",
            "open-ended",
            "fetch-api"
          ],
          "prerequisites": [
            "fetch_api_basics",
            "http_headers"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_cors_6",
          "topic": "CORS Troubleshooting",
          "level": "hard",
          "type": "code",
          "question": "You are building a React frontend application hosted on `http://localhost:3000` and it needs to communicate with a Node.js API server running on `http://localhost:5000`. Your `fetch` request from the React app looks like this:\n\n```javascript\nfetch('http://localhost:5000/api/data', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Auth-Token': 'mysecuretoken'\n  },\n  body: JSON.stringify({ item: 'new item' })\n})\n.then(response => response.json())\n.then(data => console.log(data))\n.catch(error => console.error('Fetch error:', error));\n```\n\nWhen you try to run this, you encounter a CORS error in the browser console. Provide the minimum necessary Node.js (Express) server-side CORS configuration using `app.use()` that would resolve this specific error, allowing the `POST` request to succeed. Explain why each header you add is necessary.",
          "answer": "```javascript\nconst express = require('express');\nconst app = express();\n\napp.use(express.json()); // To parse JSON request bodies\n\napp.use((req, res, next) => {\n  // 1. Access-Control-Allow-Origin: Required because request is from a different origin (port 3000 vs 5000)\n  //    Specify the exact origin of the frontend application.\n  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');\n\n  // 2. Access-Control-Allow-Methods: Required because this is a non-simple request (POST with custom headers).\n  //    The browser will send an OPTIONS preflight request first, which needs to be allowed.\n  //    Include POST, and critically, OPTIONS for the preflight.\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n\n  // 3. Access-Control-Allow-Headers: Required because the request includes non-simple headers\n  //    ('Content-Type: application/json' and 'X-Auth-Token').\n  //    These headers must be explicitly allowed by the server for the browser to permit the request.\n  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Auth-Token');\n\n  // Handle preflight OPTIONS requests immediately after setting headers\n  // The browser sends an OPTIONS request to check permissions before the actual POST.\n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(204); // Respond with 204 No Content for successful preflight\n  }\n\n  next();\n});\n\n// Example POST endpoint to receive data\napp.post('/api/data', (req, res) => {\n  console.log('Received data:', req.body);\n  res.json({ message: 'Data received successfully!', received: req.body });\n});\n\napp.listen(5000, () => {\n  console.log('API server listening on port 5000');\n});\n```\n\n**Explanation of headers:**\n\n1.  **`Access-Control-Allow-Origin: 'http://localhost:3000'`**: This is fundamental. The frontend (`http://localhost:3000`) is trying to access a resource on a different origin (`http://localhost:5000`). The server *must* explicitly tell the browser that requests from `http://localhost:3000` are permitted. Using `*` is generally not recommended for production APIs when specific origins are known, as it allows *any* origin to access the resource.\n\n2.  **`Access-Control-Allow-Methods: 'GET, POST, PUT, DELETE, OPTIONS'`**: The client is making a `POST` request. Since this is a non-simple request (due to `Content-Type: application/json` and the custom header `X-Auth-Token`), the browser first sends an `OPTIONS` preflight request. Both `POST` and `OPTIONS` methods must be explicitly allowed by the server in its response to the preflight.\n\n3.  **`Access-Control-Allow-Headers: 'Content-Type, Authorization, X-Auth-Token'`**: The client's request includes two non-simple headers: `Content-Type: application/json` and `X-Auth-Token`. For the browser to allow these headers in a cross-origin request, the server must explicitly list them in the `Access-Control-Allow-Headers` response header during the preflight. `Authorization` is included because `X-Auth-Token` effectively serves a similar purpose and `Authorization` is a common header to allow.",
          "options": [],
          "analysisPoints": [
            "Tests ability to identify the root causes of CORS errors based on client-side request details.",
            "Requires knowledge of preflight requests and their impact on method and header allowances.",
            "Assesses practical implementation of CORS headers in a common backend framework (Express).",
            "Evaluates the ability to explain the purpose of each header in context."
          ],
          "keyConcepts": [
            "cors",
            "preflight-request",
            "access-control-allow-origin",
            "access-control-allow-methods",
            "access-control-allow-headers",
            "http-headers",
            "troubleshooting",
            "backend"
          ],
          "evaluationCriteria": [
            "Correct and complete server-side configuration.",
            "Accurate explanation for each header's necessity.",
            "Demonstrates understanding of simple vs. non-simple requests and preflights.",
            "Code is runnable and directly addresses the problem."
          ],
          "example": "",
          "tags": [
            "web-security",
            "cors",
            "coding-challenge",
            "hard",
            "backend"
          ],
          "prerequisites": [
            "http_basics",
            "node_express_basics",
            "fetch_api_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_cors_7",
          "topic": "CORS - Wildcard Origin Security",
          "level": "medium",
          "type": "flashcard",
          "question": "Is it always safe to use `Access-Control-Allow-Origin: *` in production? Explain why or why not.",
          "answer": "No, it is generally *not* safe to use `Access-Control-Allow-Origin: *` in production unless your API is truly public and does not handle any sensitive user data or requires authentication. The reason is that `*` allows *any* origin to access your resources, removing the origin-based security provided by CORS. This can be problematic if your API uses cookies or HTTP authentication, as `Access-Control-Allow-Credentials: true` cannot be used in conjunction with `Access-Control-Allow-Origin: *`.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of the security implications of wildcard origin.",
            "Highlights the restriction with `Access-Control-Allow-Credentials`.",
            "Encourages critical thinking about API access control."
          ],
          "keyConcepts": [
            "cors",
            "access-control-allow-origin",
            "security-risks",
            "wildcard",
            "authentication"
          ],
          "evaluationCriteria": [
            "Correctly identifies security risk",
            "Explains the `Credentials` interaction"
          ],
          "example": "",
          "tags": [
            "web-security",
            "cors",
            "flashcard",
            "best-practices"
          ],
          "prerequisites": [
            "cors_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_script_loading_1",
          "topic": "Script Loading Strategies",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main drawback of using a regular `<script>` tag without `async` or `defer` in the `<head>` of an HTML document?",
          "answer": "It blocks HTML parsing and rendering until the script is downloaded and executed, which can delay page load time and user experience.",
          "options": [],
          "analysisPoints": [
            "Tests basic knowledge of blocking behavior.",
            "Connects script loading to page performance."
          ],
          "keyConcepts": [
            "script-loading",
            "blocking",
            "html-parsing",
            "performance"
          ],
          "evaluationCriteria": [
            "Direct recall of drawback"
          ],
          "example": "",
          "tags": [
            "performance",
            "script-loading",
            "flashcard"
          ],
          "prerequisites": [
            "html_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_script_loading_2",
          "topic": "Script Loading Strategies: Async vs. Defer",
          "level": "medium",
          "type": "mcq",
          "question": "You have two external JavaScript files: `analytics.js` (for tracking, does not modify DOM) and `main.js` (initializes your UI after DOM is ready). Which combination of script loading attributes is generally best for optimal performance and correct functionality?\n\nA) `<script defer src=\"analytics.js\"></script>` and `<script async src=\"main.js\"></script>`\nB) `<script async src=\"analytics.js\"></script>` and `<script defer src=\"main.js\"></script>`\nC) `<script src=\"analytics.js\"></script>` and `<script src=\"main.js\"></script>`\nD) `<script defer src=\"analytics.js\"></script>` and `<script defer src=\"main.js\"></script>`",
          "answer": "B) `<script async src=\"analytics.js\"></script>` and `<script defer src=\"main.js\"></script>`",
          "options": [
            "A) `<script defer src=\"analytics.js\"></script>` and `<script async src=\"main.js\"></script>`",
            "B) `<script async src=\"analytics.js\"></script>` and `<script defer src=\"main.js\"></script>`",
            "C) `<script src=\"analytics.js\"></script>` and `<script src=\"main.js\"></script>`",
            "D) `<script defer src=\"analytics.js\"></script>` and `<script defer src=\"main.js\"></script>`"
          ],
          "analysisPoints": [
            "Tests understanding of the practical use cases for `async` and `defer`.",
            "Distinguishes between scripts that depend on DOM and those that are independent.",
            "Considers performance implications.",
            "The relative order of `async` and `defer` in the HTML doesn't strictly matter for their *execution* order relative to HTML parsing, but the choice of attribute does."
          ],
          "keyConcepts": [
            "async-script",
            "defer-script",
            "performance",
            "dom-ready",
            "script-execution-order"
          ],
          "evaluationCriteria": [
            "Correctly applies attributes based on script dependencies and impact"
          ],
          "example": "`async` is ideal for `analytics.js` because it's independent and won't block parsing, executing as soon as it's ready. `defer` is ideal for `main.js` because it depends on the DOM being ready and will execute after HTML parsing, ensuring elements are available. Option D would also work correctly if `analytics.js` doesn't *need* to run *immediately* as it downloads, but `async` offers potentially earlier execution if `analytics.js` finishes downloading very quickly.",
          "tags": [
            "performance",
            "script-loading",
            "async",
            "defer",
            "mcq"
          ],
          "prerequisites": [
            "html_basics",
            "browser_rendering_process"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_script_loading_3",
          "topic": "Script Loading Execution Order",
          "level": "medium",
          "type": "open",
          "question": "You have an HTML file with the following script tags in the `<head>`:\n\n```html\n<script async src=\"scriptA.js\"></script>\n<script defer src=\"scriptB.js\"></script>\n<script async src=\"scriptC.js\"></script>\n<script src=\"scriptD.js\"></script>\n```\n\nAssume all scripts are external and of similar size, and network conditions are typical. Describe the likely order of execution for these scripts relative to each other and to the HTML parsing. What considerations might alter this order?",
          "answer": "Here's the likely order of execution:\n\n1.  **`scriptD.js` (Regular script)**: This script will block HTML parsing. It will be fetched and executed as soon as the browser encounters it. HTML parsing will pause until `scriptD.js` finishes execution.\n\n2.  **`scriptA.js` and `scriptC.js` (Async scripts)**: These scripts will be downloaded in parallel with HTML parsing (which is paused by `scriptD.js` currently, but will resume after `scriptD.js` completes). They will execute as soon as they finish downloading, *regardless* of their order in the HTML or other scripts. Therefore, the execution order between `scriptA.js` and `scriptC.js` is *not guaranteed* and depends on which one finishes downloading first.\n\n3.  **`scriptB.js` (Defer script)**: This script will also be downloaded in parallel with HTML parsing. However, it will *only* execute after the entire HTML document has been parsed and the DOM is ready (just before `DOMContentLoaded` event). If there were multiple `defer` scripts, their relative execution order would be guaranteed based on their appearance in the HTML.\n\n**Likely Execution Order Summary (Conceptual):**\n1.  `scriptD.js` (blocks, executes when ready)\n2.  HTML parsing resumes/continues.\n3.  `scriptA.js` or `scriptC.js` (whichever downloads first) executes.\n4.  The other of `scriptA.js` or `scriptC.js` executes.\n5.  HTML parsing completes.\n6.  `scriptB.js` executes.\n\n**Considerations that might alter this order:**\n-   **Network Latency and Script Size**: The actual download time for `async` and `defer` scripts heavily influences their execution timing. A smaller `async` script on a fast CDN might execute much earlier than a larger `async` script on a slow server.\n-   **Browser Cache**: If a script is cached, it will execute much faster, potentially altering the perceived order relative to un-cached scripts.\n-   **HTTP/2 Multiplexing**: While scripts are downloaded in parallel, actual download speeds can vary.\n-   **Blocking by other resources**: If other critical resources (like CSS in the head) block rendering, it could indirectly affect when the browser prioritizes script execution.\n-   **Inline scripts**: Any inline `<script>` tags encountered during parsing will block parsing and execute immediately, potentially interspersing with `async` downloads and before `defer` execution.",
          "options": [],
          "analysisPoints": [
            "Tests comprehensive understanding of all three script loading types.",
            "Requires knowledge of execution order guarantees and non-guarantees.",
            "Assesses understanding of blocking vs. non-blocking behavior.",
            "Considers practical factors that influence actual timing (network, cache).",
            "Demonstrates ability to reason about complex browser behavior."
          ],
          "keyConcepts": [
            "script-loading",
            "async",
            "defer",
            "blocking-script",
            "html-parsing",
            "execution-order",
            "performance"
          ],
          "evaluationCriteria": [
            "Accurate description of each script's behavior.",
            "Correctly identifies guaranteed vs. non-guaranteed order.",
            "Thorough explanation of influencing factors."
          ],
          "example": "",
          "tags": [
            "performance",
            "script-loading",
            "open-ended",
            "hard"
          ],
          "prerequisites": [
            "browser_rendering_process",
            "html_structure"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_script_loading_4",
          "topic": "Script Loading - DOMContentLoaded",
          "level": "medium",
          "type": "flashcard",
          "question": "Which script loading attribute, `async` or `defer`, is guaranteed to execute before the `DOMContentLoaded` event fires?",
          "answer": "Neither `async` nor `defer` scripts are guaranteed to execute before `DOMContentLoaded`. `async` scripts execute as soon as they finish downloading (which could be before or after `DOMContentLoaded`), while `defer` scripts execute *just before* `DOMContentLoaded` but *after* HTML parsing is complete.",
          "options": [],
          "analysisPoints": [
            "Tests precise understanding of `async` and `defer` execution timing relative to `DOMContentLoaded`.",
            "Corrects common misconception about `async` always being after `DOMContentLoaded`."
          ],
          "keyConcepts": [
            "async-script",
            "defer-script",
            "dom-content-loaded",
            "execution-order"
          ],
          "evaluationCriteria": [
            "Accurate comparison of timing",
            "Correct identification of event relationship"
          ],
          "example": "",
          "tags": [
            "performance",
            "script-loading",
            "flashcard"
          ],
          "prerequisites": [
            "dom_events",
            "browser_rendering_process"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_script_loading_5",
          "topic": "Script Loading - Best Practices",
          "level": "medium",
          "type": "open",
          "question": "For a typical modern web application that heavily relies on JavaScript for interactivity and DOM manipulation, what is generally the recommended strategy for placing and loading your main application JavaScript bundle (`app.bundle.js`)? Justify your choice by explaining the benefits of this approach over alternatives.",
          "answer": "For a typical modern web application with heavy JavaScript reliance on DOM manipulation, the recommended strategy for loading the main application bundle (`app.bundle.js`) is generally to use `<script defer src=\"app.bundle.js\"></script>` and place it in the `<head>` or just before the closing `</body>` tag.\n\n**Justification for `defer`:**\n1.  **Non-blocking HTML Parsing**: The `defer` attribute allows the browser to download `app.bundle.js` in parallel with HTML parsing. This means the browser can continue rendering the HTML structure to the user without waiting for the large JavaScript file to be downloaded and executed, significantly improving perceived performance (Time to First Contentful Paint - FCP).\n2.  **Guaranteed DOM Readiness**: `defer` scripts execute only after the entire HTML document has been parsed. This is crucial for applications that heavily interact with or manipulate the DOM, as it ensures that all necessary HTML elements are available when the script runs, avoiding 'null' errors for missing elements. This happens just before the `DOMContentLoaded` event.\n3.  **Guaranteed Execution Order**: If you have multiple deferred scripts (e.g., `vendor.js` and `app.bundle.js` where `app.bundle.js` depends on `vendor.js`), `defer` guarantees that they execute in the order they appear in the HTML. This is vital for managing dependencies.\n\n**Why `defer` over alternatives:**\n-   **Over Regular `<script>` (blocking)**: A regular script would block HTML parsing and rendering for the entire duration of its download and execution. For a large `app.bundle.js`, this would lead to a blank page or significantly delayed rendering, providing a very poor user experience.\n-   **Over `async`**: While `async` also downloads in parallel, it executes as soon as it's downloaded. This means `app.bundle.js` could execute before the DOM is fully parsed, leading to errors if it tries to manipulate elements that don't exist yet. Also, `async` doesn't guarantee execution order, which can be problematic for interdependent application modules.\n-   **Placement (Head vs. Body End)**: While `defer` makes placement in the `head` safe (since it waits for DOM parsing anyway), placing it just before `</body>` *without* `defer` is a common old practice to avoid blocking. However, `defer` in the `head` is generally superior as it starts the download earlier. When using `defer`, the exact position (head vs. body end) matters less for execution timing relative to DOMContentLoaded, but placing it earlier helps initiate download sooner.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of best practices for large JS bundles.",
            "Requires detailed comparison of `defer` benefits against `async` and regular scripts.",
            "Connects script loading to core web performance metrics (FCP, DOMContentLoaded).",
            "Justifies the choice based on typical application needs (DOM interaction, dependencies)."
          ],
          "keyConcepts": [
            "script-loading",
            "defer-script",
            "performance-optimization",
            "dom-manipulation",
            "bundle-loading",
            "frontend-architecture"
          ],
          "evaluationCriteria": [
            "Clear recommendation and strong justification",
            "Accurate comparison of attributes",
            "Understanding of performance implications"
          ],
          "example": "",
          "tags": [
            "performance",
            "script-loading",
            "open-ended",
            "best-practices"
          ],
          "prerequisites": [
            "web_performance_basics",
            "browser_rendering_process"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_script_loading_6",
          "topic": "Script Loading: Async vs Defer",
          "level": "medium",
          "type": "code",
          "question": "You have a webpage with the following structure:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Script Test</title>\n    <script async src=\"script1.js\"></script>\n    <script defer src=\"script2.js\"></script>\n    <script>\n        console.log(\"Inline script 1: HTML parsed.\");\n    </script>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script>\n        console.log(\"Inline script 2: Body loaded.\");\n        document.addEventListener('DOMContentLoaded', () => {\n            console.log(\"DOMContentLoaded fired.\");\n        });\n    </script>\n    <script async src=\"script3.js\"></script>\n    <script defer src=\"script4.js\"></script>\n</body>\n</html>\n```\n\nAnd the content of the external scripts:\n\n`script1.js`:\n```javascript\nconsole.log(\"script1.js executed (async, head).\");\n```\n\n`script2.js`:\n```javascript\nconsole.log(\"script2.js executed (defer, head).\");\n```\n\n`script3.js`:\n```javascript\nconsole.log(\"script3.js executed (async, body end).\");\n```\n\n`script4.js`:\n```javascript\nconsole.log(\"script4.js executed (defer, body end).\");\n```\n\nPredict the *most likely* order of console logs. Assume negligible network latency and that `script1.js` and `script3.js` finish downloading slightly faster than `script2.js` and `script4.js` respectively. Explain your reasoning.",
          "answer": "The most likely order of console logs will be:\n\n1.  `Inline script 1: HTML parsed.` (from `<head>` inline script)\n2.  `script1.js` executed (async, head).\n3.  `Inline script 2: Body loaded.` (from inline script at `</body>` end)\n4.  `script3.js` executed (async, body end).\n5.  `script2.js` executed (defer, head).\n6.  `script4.js` executed (defer, body end).\n7.  `DOMContentLoaded fired.`\n\n**Reasoning:**\n\n1.  **`Inline script 1`**: This is a regular inline script in the `<head>`. The browser encounters it, pauses HTML parsing, and executes it immediately. Thus, it's the first log.\n2.  **`script1.js` (async)**: This script is in the `<head>` with `async`. It starts downloading in parallel with parsing. Since we assume negligible latency and it finishes downloading slightly faster, it executes as soon as it's ready, *before* the browser reaches the `<body>` or `DOMContentLoaded`.\n3.  **`Inline script 2`**: This is a regular inline script placed just before `</body>`. The browser pauses HTML parsing to execute it once it reaches this point. At this point, the HTML before it (including the `#root` div) has been parsed.\n4.  **`script3.js` (async)**: This script is also `async` and placed at the end of the `<body>`. It downloaded in parallel with the HTML. Given it finished downloading slightly faster, it executes as soon as it's ready, which would be after `Inline script 2` and before `DOMContentLoaded`.\n5.  **`script2.js` (defer)**: This script is in the `<head>` with `defer`. It downloads in parallel, but its execution is *deferred* until HTML parsing is complete. All `defer` scripts execute in order of appearance just before `DOMContentLoaded`.\n6.  **`script4.js` (defer)**: This script is at the end of the `<body>` with `defer`. Similar to `script2.js`, it waits for HTML parsing to complete. Since `defer` scripts maintain their relative order, `script4.js` executes after `script2.js`.\n7.  **`DOMContentLoaded fired.`**: This event fires after the HTML document has been completely loaded and parsed, and all `defer` scripts have executed. It also fires after all `async` scripts that happened to finish downloading before it.\n\n**Note on `async` execution**: The relative order between `script1.js` and `script3.js` and any inline scripts is not strictly guaranteed and depends on download times. However, based on the assumption that `script1.js` is in the head and finishes downloading fast, it's likely to execute earlier than `script3.js` which is placed later. The key is that `async` scripts do not wait for HTML parsing to complete and do not block it, executing whenever they are ready. `defer` scripts, conversely, wait for HTML parsing to complete and execute *in order* before `DOMContentLoaded`.",
          "options": [],
          "analysisPoints": [
            "Tests intricate understanding of `async`, `defer`, and regular script loading behaviors.",
            "Evaluates knowledge of execution order rules, especially regarding parallel downloads and deferred execution.",
            "Assesses comprehension of `DOMContentLoaded` timing relative to script types.",
            "Requires careful parsing of HTML structure and script attributes."
          ],
          "keyConcepts": [
            "script-loading",
            "async-script",
            "defer-script",
            "blocking-script",
            "html-parsing",
            "execution-order",
            "dom-content-loaded",
            "browser-rendering"
          ],
          "evaluationCriteria": [
            "Correct prediction of the most likely execution order.",
            "Accurate reasoning for each script's behavior.",
            "Demonstrates a nuanced understanding of browser loading processes."
          ],
          "example": "",
          "tags": [
            "performance",
            "script-loading",
            "coding-challenge",
            "hard"
          ],
          "prerequisites": [
            "browser_rendering_process",
            "html_structure"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_storage_event_sync",
          "title": "Cross-Tab Theme Synchronization",
          "description": "\nImplement a feature where users can change their preferred theme (e.g., 'light' or 'dark') in one browser tab, and this change should immediately reflect in all other open tabs or windows of the same web application. Use `localStorage` to persist the theme and the `storage` event to synchronize changes across tabs.\n\n**Requirements:**\n1.  Create a simple HTML page with a button to toggle between 'light' and 'dark' themes. You can apply a CSS class to the `<body>` or `<html>` element to change the theme.\n2.  Store the current theme preference in `localStorage`.\n3.  When the theme is changed in one tab, the `storage` event should propagate this change to other tabs.\n4.  Other tabs should listen for the `storage` event and update their theme based on the new value from `localStorage`.\n5.  The tab that initiated the change should update its own theme directly (it won't receive the `storage` event). Ensure consistency across all tabs.\n6.  On initial page load, the theme should be loaded from `localStorage`.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Theme Sync Demo</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            transition: background-color 0.3s, color 0.3s;\n        }\n        body.light-theme {\n            background-color: #f0f0f0;\n            color: #333;\n        }\n        body.dark-theme {\n            background-color: #333;\n            color: #f0f0f0;\n        }\n    </style>\n</head>\n<body class=\"light-theme\">\n    <h1>Cross-Tab Theme Synchronizer</h1>\n    <p>Current Theme: <span id=\"currentThemeDisplay\">Light</span></p>\n    <button id=\"toggleThemeBtn\">Toggle Theme</button>\n\n    <script>\n        const THEME_KEY = 'appTheme';\n        const body = document.body;\n        const toggleBtn = document.getElementById('toggleThemeBtn');\n        const themeDisplay = document.getElementById('currentThemeDisplay');\n\n        function applyTheme(theme) {\n            body.className = ''; // Clear existing classes\n            if (theme === 'dark') {\n                body.classList.add('dark-theme');\n                themeDisplay.textContent = 'Dark';\n            } else {\n                body.classList.add('light-theme');\n                themeDisplay.textContent = 'Light';\n            }\n        }\n\n        // TODO: Implement initial theme load from localStorage\n        // TODO: Implement toggle theme logic (update localStorage and applyTheme)\n        // TODO: Implement storage event listener for cross-tab sync\n\n        // Initial load\n        const storedTheme = localStorage.getItem(THEME_KEY);\n        if (storedTheme) {\n            applyTheme(storedTheme);\n        } else {\n            // Default theme if nothing in storage\n            applyTheme('light');\n            localStorage.setItem(THEME_KEY, 'light');\n        }\n\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Theme Sync Demo</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            transition: background-color 0.3s, color 0.3s;\n        }\n        body.light-theme {\n            background-color: #f0f0f0;\n            color: #333;\n        }\n        body.dark-theme {\n            background-color: #333;\n            color: #f0f0f0;\n        }\n    </style>\n</head>\n<body class=\"light-theme\">\n    <h1>Cross-Tab Theme Synchronizer</h1>\n    <p>Current Theme: <span id=\"currentThemeDisplay\">Light</span></p>\n    <button id=\"toggleThemeBtn\">Toggle Theme</button>\n\n    <script>\n        const THEME_KEY = 'appTheme';\n        const body = document.body;\n        const toggleBtn = document.getElementById('toggleThemeBtn');\n        const themeDisplay = document.getElementById('currentThemeDisplay');\n\n        function applyTheme(theme) {\n            body.className = ''; // Clear existing classes\n            if (theme === 'dark') {\n                body.classList.add('dark-theme');\n                themeDisplay.textContent = 'Dark';\n            } else {\n                body.classList.add('light-theme');\n                themeDisplay.textContent = 'Light';\n            }\n        }\n\n        // Initial theme load\n        const storedTheme = localStorage.getItem(THEME_KEY);\n        if (storedTheme) {\n            applyTheme(storedTheme);\n        } else {\n            // Default theme if nothing in storage\n            applyTheme('light');\n            localStorage.setItem(THEME_KEY, 'light');\n        }\n\n        // Toggle theme logic\n        toggleBtn.addEventListener('click', () => {\n            const currentTheme = localStorage.getItem(THEME_KEY);\n            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\n            localStorage.setItem(THEME_KEY, newTheme); // This triggers the 'storage' event in other tabs\n            applyTheme(newTheme); // Update current tab directly\n        });\n\n        // Storage event listener for cross-tab sync\n        window.addEventListener('storage', (event) => {\n            if (event.key === THEME_KEY && event.storageArea === localStorage) {\n                const newTheme = event.newValue;\n                if (newTheme) {\n                    applyTheme(newTheme);\n                    console.log(`Theme updated by another tab: ${newTheme}`);\n                } else {\n                    // Handle case where theme might be cleared (e.g., localStorage.clear() in another tab)\n                    applyTheme('light'); // Revert to default\n                    console.log('Theme cleared by another tab, reverting to default.');\n                }\n            }\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "1. Open the HTML file in one tab, then duplicate it to a second tab.\n2. In the first tab, click 'Toggle Theme'. Verify the theme changes in *both* tabs.\n3. In the second tab, click 'Toggle Theme'. Verify the theme changes in *both* tabs.\n4. Close all tabs, then open a new tab. Verify the last set theme is loaded initially.\n5. Manually clear localStorage in one tab's console (`localStorage.clear()`). Observe how other tabs react (they should revert to default or handle the null value).",
            "Test with multiple tabs (>2) open to ensure broadcast functionality."
          ],
          "hints": [
            "Remember that the `storage` event only fires for changes initiated by *other* windows/tabs.",
            "The tab making the change needs to update its own UI explicitly.",
            "Use `event.key` and `event.newValue` from the `storage` event object.",
            "Ensure `localStorage.setItem()` is used to trigger the event."
          ],
          "tags": [
            "web-storage",
            "event-listener",
            "frontend",
            "dom-manipulation",
            "synchronization",
            "cross-browser"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "web_storage_basics",
            "event_listeners",
            "dom_manipulation"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "local_storage",
            "event_bubbling",
            "state_management"
          ]
        },
        {
          "id": "task_secure_cookie_implementation",
          "title": "Implement Secure Cookie Setup (Node.js/Express)",
          "description": "\nDesign and implement a basic Node.js (Express) server that sets an authentication cookie upon a successful 'login' (a mock `/login` endpoint). The cookie should be configured with best practices for security.\n\n**Requirements:**\n1.  Create a simple Express application.\n2.  Define a `/login` endpoint that responds to `POST` requests.\n3.  When a `POST` request is received at `/login` (no actual authentication logic needed, just simulate success), set a cookie named `authToken`.\n4.  The `authToken` cookie must be configured with the `HttpOnly`, `Secure`, and `SameSite=Lax` attributes.\n5.  Include a `maxAge` for the cookie (e.g., 1 hour).\n6.  Add a simple `/dashboard` endpoint that checks for the `authToken` cookie. If present, it should respond with 'Welcome to the dashboard!'; otherwise, 'Unauthorized'.\n\n**Note**: You will need to install `express` and `cookie-parser` (`npm install express cookie-parser`).\n",
          "difficulty": "medium",
          "startingCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.json()); // To parse JSON request bodies\napp.use(cookieParser()); // To parse incoming cookies\n\napp.post('/login', (req, res) => {\n  // TODO: Simulate successful login\n  // TODO: Set the authToken cookie with HttpOnly, Secure, SameSite=Lax, and maxAge\n  // res.cookie('authToken', 'your_jwt_token', { /* options */ });\n  res.send('Login successful, cookie set!');\n});\n\napp.get('/dashboard', (req, res) => {\n  // TODO: Check if the authToken cookie is present\n  // if (req.cookies.authToken) {\n  //   res.send('Welcome to the dashboard!');\n  // } else {\n  //   res.status(401).send('Unauthorized');\n  // }\n  res.send('Dashboard endpoint placeholder.');\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});\n",
          "solutionCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.json()); // To parse JSON request bodies\napp.use(cookieParser()); // To parse incoming cookies\n\n// Mock login endpoint\napp.post('/login', (req, res) => {\n  // In a real app, you'd validate credentials here\n  const mockAuthToken = 'mock-secure-jwt-12345';\n\n  // Set the authToken cookie with secure flags\n  res.cookie('authToken', mockAuthToken, {\n    httpOnly: true, // Prevents client-side JavaScript access\n    secure: true,   // Only send over HTTPS (important for production)\n    sameSite: 'Lax', // Protects against most CSRF attacks\n    maxAge: 3600000 // Cookie expires in 1 hour (in milliseconds)\n  });\n\n  res.status(200).json({ message: 'Login successful, authentication cookie set!' });\n});\n\n// Dashboard endpoint requiring authentication\napp.get('/dashboard', (req, res) => {\n  if (req.cookies.authToken) {\n    res.status(200).send('Welcome to the protected dashboard! Your auth token is present (server-side).');\n  } else {\n    res.status(401).send('Unauthorized: No authentication token found.');\n  }\n});\n\n// Client-side access test (should NOT show HttpOnly cookie)\napp.get('/client-test', (req, res) => {\n  res.send(`\n    <!DOCTYPE html>\n    <html>\n    <body>\n        <h1>Client-Side Cookie Access Test</h1>\n        <p>Check console for document.cookie:</p>\n        <script>\n            console.log('document.cookie:', document.cookie);\n            // This should NOT show the 'authToken' if HttpOnly is true\n            document.body.innerHTML += '<p>document.cookie result in console.</p>';\n        </script>\n    </body>\n    </html>\n  `);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n  console.log('Try: POST http://localhost:3000/login (e.g., with empty JSON body)');\n  console.log('Then: GET http://localhost:3000/dashboard');\n  console.log('Then: GET http://localhost:3000/client-test');\n});\n",
          "testCases": [
            "1. Start the server.\n2. Use a tool like Postman, curl, or a simple HTML form/fetch request to send a `POST` request to `http://localhost:3000/login`.\n3. Verify in your browser's developer tools (Application -> Cookies) that the `authToken` cookie is set for `localhost:3000` with `HttpOnly`, `Secure` (if using HTTPS, otherwise this flag will be ignored by browser), and `SameSite=Lax`.\n4. Send a `GET` request to `http://localhost:3000/dashboard`. Verify you receive 'Welcome to the dashboard!'.\n5. Clear your browser cookies for `localhost`.\n6. Send a `GET` request to `http://localhost:3000/dashboard` again. Verify you receive 'Unauthorized'.\n7. Navigate to `http://localhost:3000/client-test` and check the browser console. Verify that `document.cookie` does *not* show the `authToken` (demonstrates `HttpOnly`).",
            "Test that the cookie expires after `maxAge` (requires waiting or changing system time)."
          ],
          "hints": [
            "The `res.cookie()` method in Express is used to set cookies.",
            "Options for `res.cookie()` are provided as an object.",
            "Remember that the `Secure` flag only works when accessed over HTTPS. For local development, browsers might sometimes allow it over HTTP for `localhost`, but it's best practice to test with HTTPS in mind.",
            "`req.cookies` object (provided by `cookie-parser`) is where you'll find parsed incoming cookies."
          ],
          "tags": [
            "web-security",
            "cookies",
            "backend",
            "node",
            "express",
            "authentication"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "node_basics",
            "express_basics",
            "http_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "authentication",
            "session_management",
            "server_side_rendering"
          ]
        },
        {
          "id": "task_cors_implementation",
          "title": "Configure Basic CORS for a Node.js API",
          "description": "\nImplement a Node.js (Express) server and a simple HTML client to demonstrate CORS. The client should attempt to fetch data from the server across different origins.\n\n**Requirements for Server (Node.js/Express):**\n1.  Create an Express server listening on `http://localhost:4000`.\n2.  Implement a `GET /api/message` endpoint that returns a JSON message.\n3.  Configure CORS headers on this endpoint to allow requests *only* from `http://localhost:3000`.\n4.  Allow `GET` and `POST` methods, and `Content-Type` and `Authorization` headers.\n5.  Handle preflight `OPTIONS` requests appropriately.\n\n**Requirements for Client (HTML/JavaScript):**\n1.  Create a simple HTML page with an `index.html` file that will run on `http://localhost:3000`.\n2.  Use `fetch` to make a `GET` request to `http://localhost:4000/api/message`.\n3.  Display the fetched message on the page.\n4.  Add a button to make a `POST` request to the same endpoint with a custom `X-Custom-Header` and `Content-Type: application/json`.\n5.  Log any CORS errors to the console if configuration is incorrect (for debugging purposes).\n\n**Testing:**\n-   First, run both server and client with incorrect or missing CORS settings to observe the CORS error.\n-   Then, apply the correct CORS settings on the server and verify both GET and POST requests succeed.\n",
          "difficulty": "medium",
          "startingCode": "```javascript\n// server.js (Node.js Express)\nconst express = require('express');\nconst app = express();\nconst PORT = 4000;\n\napp.use(express.json()); // For parsing application/json\n\n// TODO: Implement CORS middleware here\n/*\napp.use((req, res, next) => {\n  // Set CORS headers\n  // res.header('Access-Control-Allow-Origin', '...');\n  // res.header('Access-Control-Allow-Methods', '...');\n  // res.header('Access-Control-Allow-Headers', '...');\n  // Handle OPTIONS preflight\n  // if (req.method === 'OPTIONS') { ... }\n  next();\n});\n*/\n\napp.get('/api/message', (req, res) => {\n  res.json({ message: 'Hello from API!' });\n});\n\napp.post('/api/message', (req, res) => {\n  console.log('POST request body:', req.body);\n  res.json({ message: 'POST request received!', data: req.body });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});\n```\n\n```html\n<!-- index.html (client-side) -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CORS Client</title>\n</head>\n<body>\n    <h1>CORS Client Demo</h1>\n    <p>Message from API: <span id=\"apiMessage\">Loading...</span></p>\n    <button id=\"fetchGetBtn\">Fetch GET Data</button>\n    <button id=\"fetchPostBtn\">Fetch POST Data</button>\n\n    <script>\n        const apiMessageSpan = document.getElementById('apiMessage');\n        const fetchGetBtn = document.getElementById('fetchGetBtn');\n        const fetchPostBtn = document.getElementById('fetchPostBtn');\n        const API_URL = 'http://localhost:4000/api/message';\n\n        async function fetchGetData() {\n            try {\n                const response = await fetch(API_URL);\n                const data = await response.json();\n                apiMessageSpan.textContent = data.message;\n                console.log('GET success:', data);\n            } catch (error) {\n                console.error('GET Fetch error:', error);\n                apiMessageSpan.textContent = 'Error fetching GET data.';\n            }\n        }\n\n        async function fetchPostData() {\n            try {\n                const response = await fetch(API_URL, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': 'Bearer abcdef123',\n                        'X-Custom-Header': 'my-value'\n                    },\n                    body: JSON.stringify({ key: 'value', client: 'frontend-app' })\n                });\n                const data = await response.json();\n                console.log('POST success:', data);\n                alert('POST response: ' + data.message);\n            } catch (error) {\n                console.error('POST Fetch error:', error);\n                alert('Error sending POST data. Check console for CORS errors.');\n            }\n        }\n\n        fetchGetBtn.addEventListener('click', fetchGetData);\n        fetchPostBtn.addEventListener('click', fetchPostData);\n\n        // Initial fetch\n        fetchGetData();\n    </script>\n</body>\n</html>\n```\n",
          "solutionCode": "```javascript\n// server.js (Node.js Express)\nconst express = require('express');\nconst app = express();\nconst PORT = 4000;\n\napp.use(express.json()); // For parsing application/json\n\n// CORS middleware\napp.use((req, res, next) => {\n  // 1. Allow requests from http://localhost:3000\n  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');\n  \n  // 2. Allow specific methods (GET, POST, and OPTIONS for preflight)\n  res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n  \n  // 3. Allow specific headers (Content-Type, Authorization, X-Custom-Header)\n  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Custom-Header');\n  \n  // 4. Handle preflight OPTIONS requests\n  // When the browser sends an OPTIONS request for a non-simple request, \n  // it only needs the headers, no actual content.\n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(204); // Send 204 No Content status for successful preflight\n  }\n  \n  next();\n});\n\napp.get('/api/message', (req, res) => {\n  res.json({ message: 'Hello from API! (GET request)' });\n});\n\napp.post('/api/message', (req, res) => {\n  console.log('POST request body received:', req.body);\n  res.json({ message: 'POST request received successfully!', data: req.body });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});\n```\n\n```html\n<!-- index.html (client-side) -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CORS Client</title>\n</head>\n<body>\n    <h1>CORS Client Demo</h1>\n    <p>Message from API: <span id=\"apiMessage\">Loading...</span></p>\n    <button id=\"fetchGetBtn\">Fetch GET Data</button>\n    <button id=\"fetchPostBtn\">Fetch POST Data</button>\n\n    <script>\n        const apiMessageSpan = document.getElementById('apiMessage');\n        const fetchGetBtn = document.getElementById('fetchGetBtn');\n        const fetchPostBtn = document.getElementById('fetchPostBtn');\n        const API_URL = 'http://localhost:4000/api/message';\n\n        async function fetchGetData() {\n            try {\n                const response = await fetch(API_URL);\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n                const data = await response.json();\n                apiMessageSpan.textContent = data.message;\n                console.log('GET success:', data);\n            } catch (error) {\n                console.error('GET Fetch error:', error);\n                apiMessageSpan.textContent = 'Error fetching GET data. Check console.';\n            }\n        }\n\n        async function fetchPostData() {\n            try {\n                const response = await fetch(API_URL, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': 'Bearer abcdef123',\n                        'X-Custom-Header': 'my-value' // This makes it a non-simple request\n                    },\n                    body: JSON.stringify({ key: 'value', client: 'frontend-app' })\n                });\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n                const data = await response.json();\n                console.log('POST success:', data);\n                alert('POST response: ' + data.message);\n            } catch (error) {\n                console.error('POST Fetch error:', error);\n                alert('Error sending POST data. Check console for CORS errors.');\n            }\n        }\n\n        fetchGetBtn.addEventListener('click', fetchGetData);\n        fetchPostBtn.addEventListener('click', fetchPostData);\n\n        // Initial fetch on page load\n        fetchGetData();\n    </script>\n</body>\n</html>\n```\n",
          "testCases": [
            "1. Start the Node.js server (`node server.js`).\n2. Serve the `index.html` file using a simple HTTP server (e.g., `npx serve .` if you have `serve` installed, or open directly if your browser allows it, but `localhost:3000` setup is better). Make sure it runs on `http://localhost:3000`.\n3. Open `http://localhost:3000/index.html` in your browser.\n4. Observe the console. Initially, the `GET` request should succeed and display the message.\n5. Click 'Fetch POST Data'. Observe the console. The `POST` request should succeed, and you should see the `POST success` log and an alert with the response.",
            "Modify `Access-Control-Allow-Origin` on the server to `http://localhost:3001` (a different port) and test again. Both requests should fail with CORS errors.\n",
            "Remove `Authorization` from `Access-Control-Allow-Headers` on the server and test the POST request. It should fail with a CORS error related to the missing header.",
            "Remove `OPTIONS` from `Access-Control-Allow-Methods` on the server and test the POST request. It should fail with a CORS error related to method not allowed for preflight."
          ],
          "hints": [
            "Remember that the `Access-Control-Allow-Origin` header must exactly match the origin of your client-side application (including protocol and port).",
            "Non-simple requests (like `POST` with `application/json` or custom headers) trigger an `OPTIONS` preflight request. Your server must respond correctly to this `OPTIONS` request and include the necessary `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers`.",
            "For `OPTIONS` requests, it's common to respond with `res.sendStatus(204)` after setting the headers."
          ],
          "tags": [
            "web-security",
            "cors",
            "backend",
            "frontend",
            "http-headers",
            "networking",
            "express",
            "fetch-api"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "http_basics",
            "node_basics",
            "express_basics",
            "fetch_api_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "same_origin_policy",
            "preflight_requests",
            "api_integration"
          ]
        },
        {
          "id": "task_debug_cors",
          "title": "Debugging a CORS Error Scenario",
          "description": "\nYou are given a React frontend app and a simple Node.js backend. The frontend is trying to make a `PUT` request to update user data, but it's constantly failing with a CORS error.\n\n**Frontend (`App.js` simplified):**\n```javascript\nimport React from 'react';\n\nfunction App() {\n  const updateUserData = async () => {\n    const userData = { name: 'John Doe', email: 'john.doe@example.com' };\n    try {\n      const response = await fetch('http://localhost:5000/api/user/123',\n        {\n          method: 'PUT',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': 'Bearer some_jwt_token',\n            'X-Request-ID': 'unique-id-123'\n          },\n          body: JSON.stringify(userData)\n        }\n      );\n      const data = await response.json();\n      console.log('Update successful:', data);\n    } catch (error) {\n      console.error('Error updating user:', error);\n    }\n  };\n\n  return (\n    <div>\n      <h1>User Management</h1>\n      <button onClick={updateUserData}>Update User</button>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n**Backend (`server.js` simplified):**\n```javascript\nconst express = require('express');\nconst app = express();\nconst PORT = 5000;\n\napp.use(express.json());\n\n// Initial (incomplete) CORS configuration\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');\n  res.header('Access-Control-Allow-Methods', 'GET, POST');\n  res.header('Access-Control-Allow-Headers', 'Content-Type');\n  next();\n});\n\napp.put('/api/user/:id', (req, res) => {\n  console.log(`Updating user ${req.params.id} with data:`, req.body);\n  res.json({ message: `User ${req.params.id} updated successfully.`, updatedData: req.body });\n});\n\napp.listen(PORT, () => {\n  console.log(`Backend running on http://localhost:${PORT}`);\n});\n```\n\n**Task:** Identify the specific reasons for the CORS error based on the provided code, and then modify the `server.js` file's CORS configuration to resolve the issue, allowing the `PUT` request to succeed. Explain your changes.\n",
          "difficulty": "hard",
          "startingCode": "```javascript\n// server.js (Node.js Express)\nconst express = require('express');\nconst app = express();\nconst PORT = 5000;\n\napp.use(express.json());\n\n// Initial (incomplete) CORS configuration\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');\n  res.header('Access-Control-Allow-Methods', 'GET, POST');\n  res.header('Access-Control-Allow-Headers', 'Content-Type');\n  next();\n});\n\napp.put('/api/user/:id', (req, res) => {\n  console.log(`Updating user ${req.params.id} with data:`, req.body);\n  res.json({ message: `User ${req.params.id} updated successfully.`, updatedData: req.body });\n});\n\napp.listen(PORT, () => {\n  console.log(`Backend running on http://localhost:${PORT}`);\n});\n```",
          "solutionCode": "```javascript\n// server.js (Node.js Express) - RESOLVED\nconst express = require('express');\nconst app = express();\nconst PORT = 5000;\n\napp.use(express.json());\n\n// Corrected CORS configuration\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');\n  \n  // FIX 1: Add 'PUT' method and 'OPTIONS' for preflight requests\n  // The frontend uses PUT, and PUT is a non-simple request, requiring an OPTIONS preflight.\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS'); \n  \n  // FIX 2: Add 'Authorization' and 'X-Request-ID' to allowed headers\n  // The frontend sends these custom headers, which must be explicitly allowed.\n  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Request-ID');\n  \n  // FIX 3: Handle OPTIONS preflight requests\n  // Browsers send an OPTIONS request before non-simple requests to check CORS permissions.\n  // The server must respond with 204 No Content and the correct CORS headers.\n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(204); \n  }\n  \n  next();\n});\n\napp.put('/api/user/:id', (req, res) => {\n  console.log(`Updating user ${req.params.id} with data:`, req.body);\n  res.json({ message: `User ${req.params.id} updated successfully.`, updatedData: req.body });\n});\n\napp.listen(PORT, () => {\n  console.log(`Backend running on http://localhost:${PORT}`);\n});\n```\n\n**Explanation of Changes:**\n\n1.  **`Access-Control-Allow-Methods`**: The original configuration only allowed `GET, POST`. The frontend is attempting a `PUT` request. `PUT` is a non-simple HTTP method and therefore requires explicit permission. Additionally, any non-simple request (which `PUT` is) will trigger an `OPTIONS` preflight request. The `OPTIONS` method must also be explicitly allowed in this header for the preflight to succeed.\n\n2.  **`Access-Control-Allow-Headers`**: The original configuration only allowed `Content-Type`. The frontend's `PUT` request includes two custom headers: `Authorization` and `X-Request-ID`. Any custom headers sent in a cross-origin request must be explicitly listed in the `Access-Control-Allow-Headers` response header. Otherwise, the browser will block the request.\n\n3.  **Preflight `OPTIONS` Request Handling**: While not strictly a 'header' fix, it's a critical part of CORS configuration for non-simple requests. The browser first sends an `OPTIONS` request. The server must respond to this `OPTIONS` request with a `204 No Content` status and include all the relevant `Access-Control-*` headers. The `if (req.method === 'OPTIONS') { return res.sendStatus(204); }` block ensures that the preflight request is properly handled before the actual `PUT` request is sent.",
          "testCases": [
            "1. Start the Node.js backend with the *initial* code.\n2. Run the React frontend (e.g., `npm start`).\n3. Click the 'Update User' button. Observe the CORS error in the browser console, specifically noting messages about `PUT` method not allowed or specific headers not allowed.\n4. Replace the backend's CORS configuration with the *solution* code.\n5. Restart the Node.js backend.\n6. Click 'Update User' again in the React app. Verify that the request now succeeds, and you see 'Update successful:' in the browser console and 'Updating user...' in the backend console."
          ],
          "hints": [
            "Pay close attention to the HTTP method (`PUT`) and any non-standard or non-simple headers (`Authorization`, `X-Request-ID`) being sent by the frontend.",
            "Remember that `PUT` requests are considered 'non-simple' and trigger a preflight (`OPTIONS`) request.",
            "Ensure all methods and headers used by the frontend request are explicitly listed in the server's CORS configuration."
          ],
          "tags": [
            "web-security",
            "cors",
            "debugging",
            "backend",
            "frontend",
            "http-headers",
            "interview-challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "cors_basics",
            "http_methods",
            "http_headers",
            "node_express_basics"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "preflight_requests",
            "fetch_api",
            "react_basics"
          ]
        },
        {
          "id": "task_optimize_script_loading",
          "title": "Optimize Script Loading for a Fictional E-commerce Page",
          "description": "\nYou are tasked with optimizing the loading performance of a simple e-commerce product page. The page has several JavaScript dependencies with different roles.\n\n**Given Scripts:**\n1.  `polyfill.js`: Contains polyfills for older browser compatibility. Must run very early.\n2.  `analytics.js`: For user tracking. Should not block rendering but needs to load quickly.\n3.  `product-gallery.js`: Initializes a dynamic image gallery. Requires the DOM to be fully loaded and interacts with specific elements.\n4.  `add-to-cart.js`: Handles adding items to the cart. Also requires DOM interaction and might depend on `product-gallery.js` being loaded, or at least run after the gallery elements exist.\n5.  `reviews-widget.js`: A third-party script for displaying product reviews. It's independent of your core app logic but might take some time to load.\n\n**Task:**\nCreate an `index.html` file and insert these scripts using the most appropriate loading strategies (`async`, `defer`, or regular) and placement (head or body) to achieve:\n\n1.  **Maximum perceived performance**: HTML content should display as quickly as possible.\n2.  **Correct functionality**: Scripts that rely on the DOM or other scripts execute at the right time.\n3.  **Minimal blocking**: Avoid blocking HTML parsing for non-critical scripts.\n\nProvide the `index.html` structure with the script tags and brief comments explaining your choices for each script.",
          "difficulty": "medium",
          "startingCode": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>E-commerce Product Page</title>\n    <!-- Assume some basic CSS here -->\n</head>\n<body>\n    <header>\n        <h1>Product Name</h1>\n    </header>\n    <main>\n        <section id=\"product-details\">\n            <div id=\"gallery\">\n                <!-- Image gallery elements -->\n            </div>\n            <p>Product description...</p>\n            <button id=\"add-to-cart-btn\">Add to Cart</button>\n        </section>\n        <section id=\"reviews\">\n            <h2>Customer Reviews</h2>\n            <div id=\"reviews-widget\">\n                <!-- Reviews content will be injected by JS -->\n            </div>\n        </section>\n    </main>\n    <footer>\n        <p>&copy; 2023 E-commerce Store</p>\n    </footer>\n\n    <!-- Script Tags - TO BE FILLED IN -->\n    <!-- polyfill.js -->\n    <!-- analytics.js -->\n    <!-- product-gallery.js -->\n    <!-- add-to-cart.js -->\n    <!-- reviews-widget.js -->\n\n</body>\n</html>\n```",
          "solutionCode": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>E-commerce Product Page</title>\n    <!-- Assume some basic CSS here -->\n\n    <!-- 1. polyfill.js: Must run very early to ensure compatibility for subsequent scripts. -->\n    <!-- Placed as a regular script in the head to ensure it executes before other scripts are parsed/executed. -->\n    <script src=\"polyfill.js\"></script>\n\n    <!-- 2. analytics.js: Independent, non-blocking, and doesn't affect DOM rendering. -->\n    <!-- 'async' allows it to download in parallel and execute as soon as ready, without blocking HTML. -->\n    <script async src=\"analytics.js\"></script>\n\n    <!-- 5. reviews-widget.js: Third-party, independent, no DOM dependency on initial load from *our* app. -->\n    <!-- 'async' is suitable as it runs when ready and doesn't block critical path. -->\n    <script async src=\"reviews-widget.js\"></script>\n\n</head>\n<body>\n    <header>\n        <h1>Product Name</h1>\n    </header>\n    <main>\n        <section id=\"product-details\">\n            <div id=\"gallery\">\n                <!-- Image gallery elements -->\n            </div>\n            <p>Product description...</p>\n            <button id=\"add-to-cart-btn\">Add to Cart</button>\n        </section>\n        <section id=\"reviews\">\n            <h2>Customer Reviews</h2>\n            <div id=\"reviews-widget\">\n                <!-- Reviews content will be injected by JS -->\n            </div>\n        </section>\n    </main>\n    <footer>\n        <p>&copy; 2023 E-commerce Store</p>\n    </footer>\n\n    <!-- 3. product-gallery.js: Requires DOM elements to be ready. -->\n    <!-- 'defer' ensures it downloads in parallel but executes only after HTML parsing is complete. -->\n    <script defer src=\"product-gallery.js\"></script>\n\n    <!-- 4. add-to-cart.js: Requires DOM elements (button) and potentially depends on other core JS. -->\n    <!-- 'defer' ensures DOM readiness and maintains execution order relative to other 'defer' scripts (like product-gallery.js). -->\n    <script defer src=\"add-to-cart.js\"></script>\n\n</body>\n</html>\n```\n\n**Explanation of Choices:**\n\n1.  **`polyfill.js` (Regular script in `<head>`)**: Polyfills are often required before any other JavaScript runs to ensure modern features are available for older browsers. Placing it as a regular script in the `<head>` ensures it's the first script parsed and executed, even though it's blocking. Its critical nature for subsequent scripts outweighs the minor blocking for what's typically a small file.\n\n2.  **`analytics.js` (`async` in `<head>`)**: Analytics scripts are generally non-critical for initial page rendering or user interaction. They can be downloaded in parallel with HTML parsing and executed as soon as they are ready, without blocking. `async` is perfect here as execution order isn't important relative to other scripts.\n\n3.  **`reviews-widget.js` (`async` in `<head>`)**: Similar to analytics, a third-party reviews widget is typically independent of the core application logic and can load asynchronously. Using `async` allows it to fetch and execute without delaying other critical processes.\n\n4.  **`product-gallery.js` (`defer` at `</body>` end)**: This script explicitly requires the DOM to be fully loaded (`#gallery` element). `defer` is ideal because it downloads in parallel with HTML parsing but waits to execute until the DOM is ready. Placing it before `add-to-cart.js` (if `add-to-cart.js` had a dependency on it) also benefits from `defer`'s guaranteed execution order.\n\n5.  **`add-to-cart.js` (`defer` at `</body>` end)**: This script also manipulates DOM elements (like `#add-to-cart-btn`) and is part of the core application functionality. `defer` ensures it runs after the DOM is ready and maintains its relative order with other `defer` scripts, which is crucial for application logic dependencies. Placing it at the end of the `<body>` also ensures that the HTML for these elements is parsed before the script attempts to interact with them.\n\nThis configuration prioritizes rendering HTML quickly by offloading most JavaScript downloads to the background, while ensuring critical polyfills run first and DOM-dependent scripts run only when the DOM is ready, maintaining a good balance of performance and correctness.",
          "testCases": [
            "1. Create dummy `*.js` files (e.g., `touch polyfill.js analytics.js product-gallery.js add-to-cart.js reviews-widget.js`).\n2. Add `console.log()` statements inside each dummy file to indicate when they 'execute'.\n3. Use `setTimeout` within `async` and `defer` scripts to simulate network/processing delays and observe how they print relative to each other and to 'DOMContentLoaded' event.\n4. Open the `index.html` file in a browser and check the console logs to confirm the expected order based on `async`, `defer`, and regular script behavior."
          ],
          "hints": [
            "Consider what each script *needs* to function (e.g., DOM elements, other scripts) and what its *impact* on initial page load is.",
            "Think about 'blocking' vs. 'non-blocking' and 'execution timing' relative to HTML parsing and `DOMContentLoaded`.",
            "`async` is for independent scripts that can run at any time after download.",
            "`defer` is for scripts that depend on the DOM and need to run after parsing, in order.",
            "Regular scripts (`<script src>`) block parsing."
          ],
          "tags": [
            "performance",
            "script-loading",
            "html",
            "frontend-optimization",
            "best-practices",
            "browser-internals"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "html_structure",
            "javascript_basics",
            "browser_rendering_process"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "web_performance",
            "fcp",
            "dom_content_loaded",
            "script_execution"
          ]
        }
      ]
    }
  }
]