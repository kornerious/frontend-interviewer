[
  {
    "id": "a0930fb8-7690-4c3d-a834-760c9a8c7cc2",
    "startLine": 4500,
    "endLine": 4599,
    "processedDate": "2025-06-17T09:10:46.603Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_mounting_phase",
          "title": "React Component Mounting Phase",
          "content": "The Mounting Phase in React refers to the stage where an instance of your component is being created and inserted into the DOM. Understanding this phase is crucial for initializing component state, performing initial data fetching, and setting up necessary DOM interactions. The methods in this phase are called in a specific, predictable order:\n\n1.  `constructor(props)`\n2.  `static getDerivedStateFromProps(props, state)`\n3.  `render()`\n4.  `componentDidMount()`\n\nEach method serves a distinct purpose and has specific guidelines regarding what operations should and should not be performed within it.\n\n## Key Concepts\n-   **Initialization**: Setting up initial state and binding methods.\n-   **Side Effects**: Operations that interact with the outside world (e.g., API calls, subscriptions, direct DOM manipulation).\n-   **Purity of `render`**: Ensuring the `render` method is idempotent and only returns JSX.\n-   **DOM Insertion**: The point at which the component's output is actually placed into the browser's DOM.\n\n## Method Details\n\n### constructor(props)\n-   **Purpose**: Called before the component is mounted to the DOM. Its primary uses are to initialize local state by assigning an object to `this.state` and to bind event handler methods to the instance.\n-   **Execution**: It's the first method called in the mounting lifecycle.\n-   **Important Notes**: \n    -   Always call `super(props)` as the first statement, otherwise, `this.props` will be `undefined` in the constructor and potential other issues.\n    -   This is the *only* place where you can directly assign `this.state`. In all other methods, you must use `this.setState()`.\n    -   **Avoid** causing side effects (like API calls or subscriptions) in the constructor. It should be a pure function that sets up the initial state.\n\n### static getDerivedStateFromProps(props, state)\n-   **Purpose**: Called right before calling the `render` method, both on initial mount and on subsequent updates. Its purpose is to enable a component to update its internal state based on changes in props. It should return an object to update the state, or `null` to indicate that no state update is needed.\n-   **Execution**: Called after `constructor` (on mount) and before `render` (on mount and update).\n-   **Important Notes**:\n    -   It is a `static` method, which means it doesn't have access to the component instance (`this`). It operates purely on its `props` and `state` arguments.\n    -   It exists for rare use cases where the state *must* depend on changes in props over time (e.g., when a component needs to reset some of its internal state when a specific prop changes).\n    -   **Avoid** side effects in this method. It should be a pure function for derived state calculation.\n    -   It replaced deprecated lifecycle methods like `componentWillReceiveProps`.\n\n### render()\n-   **Purpose**: The only required method in a React class component. It reads `this.props` and `this.state` and returns React elements that will eventually be rendered to the DOM. It describes what should be rendered.\n-   **Execution**: Called after `static getDerivedStateFromProps` and before `componentDidMount`.\n-   **Important Notes**:\n    -   **Purity**: The `render()` method should be pure. It means it should not modify component state, perform side effects, or interact directly with the browser DOM. Given the same props and state, it should always return the same output.\n    -   **Return Types**: Can return React elements (JSX), arrays and fragments (must have a single parent key if an array), portals, strings, numbers, booleans (which render nothing), or `null` (renders nothing).\n    -   If returning arrays or fragments, they must have unique `key` props for each child element.\n\n### componentDidMount()\n-   **Purpose**: Called immediately after the component is mounted (i.e., inserted into the DOM tree). This is the ideal place to perform operations that require the component to be in the DOM.\n-   **Execution**: This is the last method called in the mounting sequence.\n-   **Important Notes**:\n    -   **Side Effects**: This is the best place to cause side effects such as:\n        -   Making network requests (API calls) to fetch data.\n        -   Setting up subscriptions (e.g., to an external data source or an event listener).\n        -   Directly manipulating the DOM (e.g., initializing a third-party library that needs DOM access, working with canvas or maps).\n    -   You *can* call `setState()` immediately in this method, but be aware that it will trigger an extra re-rendering. While this extra rendering isn't visible to the user (because it happens before the browser updates the screen), it might affect performance. It's generally preferred to initialize state in the constructor unless there's a specific reason to derive it from props or external sources *after* mount.",
          "examples": [
            {
              "id": "example_mounting_component",
              "title": "Basic Mounting Lifecycle Component",
              "code": "import React from 'react';\n\nclass LifecycleComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null, message: 'Loading...' };\n    console.log('1. Constructor: Initializing state and binding methods.');\n    this.handleClick = this.handleClick.bind(this);\n  }\n  \n  static getDerivedStateFromProps(props, state) {\n    console.log('2. getDerivedStateFromProps: Checking for prop changes to update state.');\n    // Example: If a prop 'reset' changes, reset internal message.\n    if (props.resetMessage && state.message !== 'Message Reset!') {\n        return { message: 'Message Reset!' };\n    }\n    return null; // No state update needed from props\n  }\n  \n  componentDidMount() {\n    console.log('4. componentDidMount: Component mounted to DOM. Performing side effects.');\n    // Best place for API calls, subscriptions, DOM manipulations\n    fetch('https://jsonplaceholder.typicode.com/todos/1') // Example API call\n      .then(response => response.json())\n      .then(json => {\n        console.log('API data fetched:', json);\n        this.setState({ data: json.title, message: 'Data loaded!' });\n      })\n      .catch(error => console.error('Error fetching data:', error));\n\n    // Example of adding an event listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    console.log('ComponentWillUnmount: Cleaning up event listener.');\n    window.removeEventListener('resize', this.handleResize);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({ message: prevState.message + ' Clicked!' }));\n  }\n\n  handleResize = () => {\n    console.log('Window resized!');\n  };\n  \n  render() {\n    console.log('3. render: Rendering component JSX.');\n    return (\n      <div>\n        <h2>Mounting Phase Demo</h2>\n        <p>Data: {this.state.data || 'No data yet'}</p>\n        <p>Message: {this.state.message}</p>\n        <button onClick={this.handleClick}>Click Me</button>\n      </div>\n    );\n  }\n}\n\nexport default LifecycleComponent;",
              "explanation": "This example demonstrates the core methods of the mounting phase. The `constructor` initializes the state and binds `handleClick`. `getDerivedStateFromProps` checks for a `resetMessage` prop to update the state. The `render` method simply displays the current state. `componentDidMount` is used to fetch data from an API and set up a window resize event listener, showcasing appropriate side effects. `componentWillUnmount` is included for completeness to show where to clean up `componentDidMount` effects. Console logs clearly show the order of execution.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_mounting_order_mcq",
            "question_constructor_purpose_mcq",
            "question_gDSFP_role_open",
            "question_render_purity_mcq",
            "question_CDM_side_effects_open",
            "question_side_effects_flashcard",
            "question_constructor_vs_setState_flashcard",
            "question_gDSFP_static_flashcard"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_dynamic_form_fields"
          ],
          "tags": [
            "React",
            "Lifecycle Methods",
            "Mounting",
            "Class Components",
            "State",
            "Props",
            "Side Effects"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "javascript_classes",
            "promises_and_fetch"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_hooks_lifecycle_equivalents",
            "performance_optimization_react"
          ]
        },
        {
          "id": "theory_updating_phase",
          "title": "React Component Updating Phase",
          "content": "The Updating Phase occurs when a component is being re-rendered as a result of changes to either its props or state. This phase is crucial for ensuring the component reflects the latest data, optimizing performance, and handling transitions smoothly. Understanding the order and purpose of these methods allows for efficient updates and prevents unnecessary re-renders.\n\n## Key Concepts\n-   **Re-rendering**: The process of updating the component's output due to changes in props or state.\n-   **Performance Optimization**: Preventing unnecessary re-renders to improve application responsiveness.\n-   **DOM Inspection/Snapshot**: Capturing current DOM state before an update to potentially restore it later.\n\n## Method Details\n\n### shouldComponentUpdate(nextProps, nextState)\n-   **Purpose**: Called before re-rendering when new props or state are received. It allows you to control whether a component should update or not. This is primarily used for performance optimization.\n-   **Execution**: Called first in the updating sequence, after new props/state are received but before `getDerivedStateFromProps` and `render`.\n-   **Important Notes**:\n    -   It must return a boolean value:\n        -   `true` (default): React proceeds with the update (calling `render`, etc.).\n        -   `false`: React skips the rendering process and all subsequent lifecycle methods in the update phase (i.e., `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`) for that specific update.\n    -   **Avoid** causing side effects in this method. It should be a pure function that compares `this.props` with `nextProps` and `this.state` with `nextState`.\n    -   Using `React.PureComponent` or `memo` (for functional components) automatically implements a shallow comparison in `shouldComponentUpdate`, often eliminating the need to write it manually.\n    -   Be careful when using this method, as premature optimization can lead to bugs if the component fails to update when it should.\n\n### static getDerivedStateFromProps(props, state)\n-   **Purpose**: As in the mounting phase, this method is called right before the `render` method, on both initial mount and updates. In the updating phase, its purpose is to update the component's internal state based on changes in incoming props.\n-   **Execution**: Called after `shouldComponentUpdate` (if it returns `true`) and before `render`.\n-   **Important Notes**: \n    -   It is `static` and does not have access to `this`.\n    -   It returns an object to update the state, or `null` if no state update is needed.\n    -   Its use case is specific: when state needs to be derived from props, and these props might change over time, requiring the state to be re-synchronized.\n    -   **Avoid** side effects.\n\n### render()\n-   **Purpose**: The `render()` method is called again during the updating phase to calculate the new React elements based on the updated props and state. React then diffs this new output with the previous one to determine the minimal changes needed in the actual DOM.\n-   **Execution**: Called after `static getDerivedStateFromProps` (if it returns an update) and before `getSnapshotBeforeUpdate`.\n-   **Important Notes**:\n    -   It must remain pure and free of side effects.\n    -   It should reflect the current state of the component's UI based on `this.props` and `this.state`.\n\n### getSnapshotBeforeUpdate(prevProps, prevState)\n-   **Purpose**: Invoked right before the changes from `render()` are committed to the DOM. This method allows your component to capture some information from the DOM (e.g., scroll position) before it is potentially changed by the update. The value returned by this method will be passed as the third parameter to `componentDidUpdate`.\n-   **Execution**: Called after `render` but before the DOM is actually updated.\n-   **Important Notes**:\n    -   This method is useful in scenarios like chat applications where you want to maintain scroll position even after new messages arrive.\n    -   It is rarely used, primarily for reading DOM properties just before an update.\n    -   It must return either a snapshot value (any type) or `null`.\n    -   **Avoid** side effects in this method. It should only read from the DOM.\n\n### componentDidUpdate(prevProps, prevState, snapshot)\n-   **Purpose**: Called immediately after updating occurs. This method is primarily used for performing side effects after a component has re-rendered and the DOM has been updated based on the new props and state. It is a good place to make network requests as long as you compare the current props to previous props.\n-   **Execution**: The last method called in the updating sequence, after the DOM has been updated.\n-   **Important Notes**:\n    -   You receive `prevProps`, `prevState`, and `snapshot` (the value returned from `getSnapshotBeforeUpdate`).\n    -   **Side Effects**: This is the ideal place for side effects triggered by updates, such as:\n        -   Making network requests (e.g., fetching new data if a prop like `userId` changes).\n        -   Interacting with the DOM that reflects the updated state (e.g., updating a D3 chart).\n        -   Calling `setState()` *conditionally* (e.g., inside an `if` statement that compares `prevProps` or `prevState` to current props/state) to avoid an infinite loop of re-renders. If `setState()` is called unconditionally, it will immediately trigger another update, leading to a loop.\n    -   Always compare `prevProps` and `prevState` with current props and state to avoid unnecessary re-renders or API calls.",
          "examples": [
            {
              "id": "example_updating_component",
              "title": "Basic Updating Lifecycle Component",
              "code": "import React from 'react';\n\nclass UpdatingComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0, showMore: false };\n    console.log('Constructor: Initializing state.');\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    console.log('getDerivedStateFromProps (Update): Deriving state from props.');\n    // Example: Reset count if a specific prop changes\n    if (props.resetCount && state.count !== 0) {\n      return { count: 0 };\n    }\n    return null;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate: Deciding whether to re-render.');\n    // Optimize: Only re-render if count or showMore state changes, or prop 'value' changes.\n    return (\n      nextProps.value !== this.props.value ||\n      nextState.count !== this.state.count ||\n      nextState.showMore !== this.state.showMore\n    );\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate: Capturing DOM info before update.');\n    // Example: Capture scroll position before list updates\n    if (this.props.list.length < prevProps.list.length) {\n        const list = document.getElementById('my-list');\n        if (list) {\n            return list.scrollHeight - list.scrollTop; // Amount of scrollable content below the visible part\n        }\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('componentDidUpdate: Component updated in DOM. Performing side effects.');\n    // Example: Fetch new data if 'value' prop changes\n    if (this.props.value !== prevProps.value) {\n      console.log(`Value prop changed from ${prevProps.value} to ${this.props.value}. Fetching new data...`);\n      // fetch(`/api/data?value=${this.props.value}`).then(...);\n    }\n\n    // Example: Use snapshot to adjust scroll position\n    if (snapshot !== null) {\n        console.log('Snapshot captured:', snapshot);\n        const list = document.getElementById('my-list');\n        if (list) {\n            list.scrollTop = list.scrollHeight - snapshot;\n        }\n    }\n\n    // Example: Conditionally update state (CAUTION: avoid infinite loops)\n    if (this.state.count < 5 && prevState.count === 0) {\n        // this.setState({ count: 1 }); // Would cause an extra re-render on initial update\n    }\n  }\n\n  handleClick = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  toggleShowMore = () => {\n    this.setState(prevState => ({ showMore: !prevState.showMore }));\n  };\n\n  render() {\n    console.log('render (Update): Rendering component JSX with updated props/state.');\n    return (\n      <div>\n        <h2>Updating Phase Demo</h2>\n        <p>Prop Value: {this.props.value}</p>\n        <p>State Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment Count</button>\n        <button onClick={this.toggleShowMore}>Toggle More Info</button>\n        {this.state.showMore && <p>More info is visible now!</p>}\n        <div id=\"my-list\" style={{ height: '100px', overflowY: 'scroll', border: '1px solid black' }}>\n          {this.props.list.map((item, index) => <p key={index}>{item}</p>)}\n        </div>\n      </div>\n    );\n  }\n}\n\n// Example usage from a parent component:\n/*\nclass App extends React.Component {\n  state = { dataValue: 'initial', listItems: ['Item 1', 'Item 2'] };\n\n  componentDidMount() {\n    setTimeout(() => this.setState({ dataValue: 'updated' }), 2000);\n    setTimeout(() => this.setState(prevState => ({ listItems: [...prevState.listItems, 'New Item'] })), 3000);\n  }\n\n  render() {\n    return <UpdatingComponent value={this.state.dataValue} list={this.state.listItems} />;\n  }\n}\n*/",
              "explanation": "This example showcases the methods involved in the updating phase. `shouldComponentUpdate` demonstrates a basic optimization strategy. `getDerivedStateFromProps` is present to illustrate its role if prop-derived state is needed. `render` re-evaluates the UI. `getSnapshotBeforeUpdate` captures scroll information from a simulated list before new items are potentially added and the DOM updates. Finally, `componentDidUpdate` uses the captured snapshot to adjust scroll position and checks for prop changes to simulate fetching new data, emphasizing the importance of conditional state updates/side effects.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_updating_order_mcq",
            "question_SCU_purpose_open",
            "question_snapshot_purpose_mcq",
            "question_CDU_setState_loop_open",
            "question_SCU_return_type_flashcard",
            "question_lifecycle_diagram_open",
            "question_gDSFP_update_mcq"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_optimizing_list_rendering",
            "task_chat_scroll_component"
          ],
          "tags": [
            "React",
            "Lifecycle Methods",
            "Updating",
            "Performance",
            "State",
            "Props",
            "Side Effects",
            "DOM Manipulation"
          ],
          "technology": "React",
          "prerequisites": [
            "react_mounting_phase",
            "react_state_management",
            "javascript_comparison"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_optimization_react",
            "complex_ui_interactions",
            "custom_hooks_implementation"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_mounting_order_mcq",
          "topic": "Mounting Phase Order",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct order of lifecycle methods called during the **Mounting Phase** of a React class component?",
          "answer": "constructor, static getDerivedStateFromProps, render, componentDidMount",
          "options": [
            "render, constructor, componentDidMount, static getDerivedStateFromProps",
            "constructor, static getDerivedStateFromProps, render, componentDidMount",
            "componentDidMount, constructor, render, static getDerivedStateFromProps",
            "constructor, render, componentDidMount, static getDerivedStateFromProps"
          ],
          "analysisPoints": [
            "Tests basic knowledge of React lifecycle method execution order.",
            "Highlights the initial setup (`constructor`), state derivation (`getDerivedStateFromProps`), rendering (`render`), and post-mount operations (`componentDidMount`)."
          ],
          "keyConcepts": [
            "Mounting Phase",
            "Lifecycle Order",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Ability to recall fundamental lifecycle order.",
            "Understanding of the sequence of component creation and DOM insertion."
          ],
          "example": "The mounting order is fixed and critical for understanding where to perform specific operations (e.g., state initialization in `constructor`, API calls in `componentDidMount`).",
          "tags": [
            "React",
            "Lifecycle",
            "Mounting",
            "Basic"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_constructor_purpose_mcq",
          "topic": "Constructor Method Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the `constructor(props)` method in a React class component?",
          "answer": "To initialize local state and bind event handler methods.",
          "options": [
            "To perform API calls and set up subscriptions.",
            "To update the DOM directly after component mounts.",
            "To initialize local state and bind event handler methods.",
            "To render JSX and return React elements."
          ],
          "analysisPoints": [
            "Tests understanding of the constructor's specific role.",
            "Distinguishes between state initialization/binding and side effects/rendering.",
            "Emphasizes that `this.state` can be directly assigned only here."
          ],
          "keyConcepts": [
            "Constructor",
            "State Initialization",
            "Method Binding",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Correctly identifies the core functions of the constructor.",
            "Avoids common misconceptions about side effects in constructor."
          ],
          "example": "```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 }; // Initialize state\n    this.handleClick = this.handleClick.bind(this); // Bind method\n  }\n  handleClick() { /* ... */ }\n  render() { return <button onClick={this.handleClick}>Click</button>; }\n}\n```\nThis example shows the correct use of the constructor for state initialization and method binding.",
          "tags": [
            "React",
            "Constructor",
            "State",
            "Binding",
            "Easy"
          ],
          "prerequisites": [
            "react_basics",
            "javascript_classes"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_gDSFP_role_open",
          "topic": "getDerivedStateFromProps Purpose",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of `static getDerivedStateFromProps(props, state)` and when you would typically use it. What are its key limitations?",
          "answer": "The `static getDerivedStateFromProps(props, state)` method is called right before calling the `render` method, both on initial mount and on subsequent updates. Its purpose is to enable a component to update its internal state based on changes in props. It should return an object to update the state, or `null` to indicate that no state update is needed.\n\nYou would typically use it for rare cases where the state *must* depend on changes in props over time. For example, if a component displays external data loaded via a `userId` prop, and if `userId` changes, the component's internal state (e.g., `loading` status or even the fetched data itself) might need to be reset or derived from the new `userId`.\n\nKey limitations include:\n1.  **Static Method**: Being static, it does not have access to the component instance (`this`). This means you cannot perform side effects, access other instance methods, or read from the DOM within this method.\n2.  **Pure Function**: It must be a pure function that only calculates and returns an object to update state. It should not cause any side effects (like API calls, subscriptions, or direct DOM manipulation).\n3.  **Specific Use Case**: It's meant for very specific scenarios where state *must* be a derivation of props. Often, `componentDidUpdate` (for side effects) or `setState` callbacks are more appropriate for handling prop changes.",
          "analysisPoints": [
            "Tests understanding of a less frequently used but important lifecycle method.",
            "Requires explaining its purpose, appropriate use cases, and strict limitations.",
            "Differentiates it from other lifecycle methods by highlighting its static nature and purity."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Derived State",
            "Static Methods",
            "Purity",
            "Limitations"
          ],
          "evaluationCriteria": [
            "Clear and accurate explanation of the method's purpose.",
            "Identification of valid use cases.",
            "Comprehensive listing of its limitations (static, no side effects)."
          ],
          "example": "A scenario where `getDerivedStateFromProps` might be used is a `Carousel` component that has `activeIndex` in its state. If a new `activeImageId` prop is passed, `getDerivedStateFromProps` could ensure `activeIndex` is reset or updated to reflect the new active image, assuming a mapping exists between ID and index. However, even this often has better solutions.",
          "tags": [
            "React",
            "Lifecycle",
            "Props",
            "State",
            "Medium"
          ],
          "prerequisites": [
            "react_props_state",
            "javascript_classes"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_purity_mcq",
          "topic": "Render Method Purity",
          "level": "medium",
          "type": "mcq",
          "question": "The `render()` method in a React class component should be 'pure'. What does 'pure' mean in this context?",
          "answer": "It should not modify component state, perform side effects, or interact directly with the browser DOM, and given the same props and state, it should always return the same output.",
          "options": [
            "It can only return primitive data types like strings or numbers.",
            "It must return a single root JSX element.",
            "It should only be called once during the component's lifetime.",
            "It should not modify component state, perform side effects, or interact directly with the browser DOM, and given the same props and state, it should always return the same output."
          ],
          "analysisPoints": [
            "Defines the concept of purity in the context of React's render method.",
            "Distinguishes between what `render` *does* (return JSX) and what it *should not do* (side effects, state mutation).",
            "Emphasizes the deterministic nature of pure functions."
          ],
          "keyConcepts": [
            "Render Method",
            "Purity",
            "Side Effects",
            "State Mutation",
            "Determinism"
          ],
          "evaluationCriteria": [
            "Accurate understanding of the 'purity' principle in React.",
            "Knowledge of restrictions on the `render` method."
          ],
          "example": "```javascript\nclass PureComponent extends React.Component {\n  render() {\n    // GOOD: Pure rendering based on props/state\n    return <div>Hello, {this.props.name}! Count: {this.state.count}</div>;\n  }\n}\n\nclass ImpureComponent extends React.Component {\n  render() {\n    // BAD: Modifying state directly in render (side effect)\n    // this.state.count++; // DO NOT DO THIS\n    \n    // BAD: Making an API call in render\n    // fetch('/api/data'); // DO NOT DO THIS\n    \n    return <div>Component Content</div>;\n  }\n}\n```\nThis example contrasts a pure `render` method with an impure one, demonstrating what to avoid.",
          "tags": [
            "React",
            "Render",
            "Purity",
            "Best Practices",
            "Medium"
          ],
          "prerequisites": [
            "react_basics",
            "functional_programming_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_CDM_side_effects_open",
          "topic": "componentDidMount for Side Effects",
          "level": "medium",
          "type": "open",
          "question": "Why is `componentDidMount()` considered the best place to perform side effects like API calls and subscriptions in a React class component?",
          "answer": "`componentDidMount()` is called immediately after a component is mounted (i.e., inserted into the DOM tree). This timing is crucial for several reasons:\n\n1.  **DOM Availability**: By the time `componentDidMount` is executed, the component's output has been rendered to the DOM. This means you have access to the actual DOM elements, which is essential for operations that interact directly with the DOM (e.g., initializing a D3 chart, setting up a map, measuring element dimensions).\n2.  **One-time Execution (on mount)**: For actions that should only occur once when the component first appears on the screen (like initial data fetching or setting up global event listeners), `componentDidMount` ensures they run precisely at that moment, avoiding unnecessary re-executions on updates.\n3.  **Avoiding Server-Side Issues**: When using server-side rendering (SSR), `componentDidMount` is not called on the server. This prevents side effects that depend on a browser environment (like DOM manipulation or fetching data via `window.fetch`) from running in a non-existent environment, which could lead to errors.\n4.  **No Blocking Render**: Performing API calls or other asynchronous operations here doesn't block the initial rendering of the component. The component can render a loading state first, and then update once the data is available, providing a better user experience.",
          "analysisPoints": [
            "Tests understanding of the practical implications of `componentDidMount`'s timing.",
            "Covers why specific operations (API, DOM, subscriptions) are suited for this method.",
            "Addresses concepts like DOM availability, one-time execution, and SSR compatibility."
          ],
          "keyConcepts": [
            "componentDidMount",
            "Side Effects",
            "API Calls",
            "DOM Manipulation",
            "Subscriptions",
            "SSR"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `componentDidMount`'s advantages for side effects.",
            "Demonstrates understanding of the React lifecycle's interaction with the browser environment."
          ],
          "example": "```javascript\nclass DataFetcher extends React.Component {\n  componentDidMount() {\n    // This is the ideal place for fetching data\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => this.setState({ data }))\n      .catch(error => console.error(error));\n\n    // Or setting up a resize listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    // Cleanup for componentDidMount effects\n    window.removeEventListener('resize', this.handleResize);\n  }\n}\n```",
          "tags": [
            "React",
            "Lifecycle",
            "Side Effects",
            "API",
            "DOM",
            "Medium",
            "Best Practices"
          ],
          "prerequisites": [
            "react_basics",
            "promises_and_fetch"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_side_effects_flashcard",
          "topic": "Side Effects in Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React lifecycle method is the primary place for performing side effects like API calls and setting up subscriptions during the mounting phase?",
          "answer": "componentDidMount()",
          "analysisPoints": [
            "Quick recall of method for side effects."
          ],
          "keyConcepts": [
            "Side Effects",
            "componentDidMount",
            "Mounting Phase"
          ],
          "evaluationCriteria": [
            "Ability to quickly identify the correct lifecycle method."
          ],
          "example": "Think of `componentDidMount` as the 'component is ready' signal, making it safe for external interactions.",
          "tags": [
            "React",
            "Lifecycle",
            "Side Effects",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_constructor_vs_setState_flashcard",
          "topic": "State Assignment",
          "level": "easy",
          "type": "flashcard",
          "question": "In a React class component, in which lifecycle method is it permissible to directly assign to `this.state` (e.g., `this.state = { key: value }`)?",
          "answer": "constructor(props)",
          "analysisPoints": [
            "Recalls the rule about direct state assignment."
          ],
          "keyConcepts": [
            "State Management",
            "Constructor",
            "setState"
          ],
          "evaluationCriteria": [
            "Correctly identifies the unique method for direct state assignment."
          ],
          "example": "Everywhere else, `this.setState()` is required to ensure React re-renders the component.",
          "tags": [
            "React",
            "State",
            "Constructor",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "react_state_management"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_gDSFP_static_flashcard",
          "topic": "Static getDerivedStateFromProps",
          "level": "medium",
          "type": "flashcard",
          "question": "True or False: `static getDerivedStateFromProps` has access to `this` (the component instance).",
          "answer": "False",
          "analysisPoints": [
            "Tests understanding of `static` methods in class components."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Static Methods",
            "Component Instance"
          ],
          "evaluationCriteria": [
            "Correctly identifies the static nature of the method."
          ],
          "example": "Because it's `static`, it operates only on its arguments (`props` and `state`) and cannot access `this.props` or `this.state` directly, nor other instance methods.",
          "tags": [
            "React",
            "Lifecycle",
            "Static",
            "Flashcard",
            "Medium"
          ],
          "prerequisites": [
            "javascript_classes"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_updating_order_mcq",
          "topic": "Updating Phase Order",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following sequences correctly represents the order of lifecycle methods called during the **Updating Phase** of a React class component, assuming `shouldComponentUpdate` returns `true`?",
          "answer": "shouldComponentUpdate, static getDerivedStateFromProps, render, getSnapshotBeforeUpdate, componentDidUpdate",
          "options": [
            "render, shouldComponentUpdate, componentDidUpdate, static getDerivedStateFromProps, getSnapshotBeforeUpdate",
            "shouldComponentUpdate, componentDidUpdate, render, static getDerivedStateFromProps, getSnapshotBeforeUpdate",
            "shouldComponentUpdate, static getDerivedStateFromProps, render, getSnapshotBeforeUpdate, componentDidUpdate",
            "static getDerivedStateFromProps, shouldComponentUpdate, render, componentDidUpdate, getSnapshotBeforeUpdate"
          ],
          "analysisPoints": [
            "Tests comprehensive knowledge of the updating lifecycle order.",
            "Crucial for understanding where optimizations and post-update logic fit.",
            "Includes less common methods like `getSnapshotBeforeUpdate`."
          ],
          "keyConcepts": [
            "Updating Phase",
            "Lifecycle Order",
            "shouldComponentUpdate",
            "getDerivedStateFromProps",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate"
          ],
          "evaluationCriteria": [
            "Accurate recall of the entire updating lifecycle flow.",
            "Understanding of the conditional nature introduced by `shouldComponentUpdate`."
          ],
          "example": "This order ensures React first determines if an update is needed, then prepares state based on new props, renders the new virtual DOM, captures pre-DOM update info, and finally performs post-DOM update effects.",
          "tags": [
            "React",
            "Lifecycle",
            "Updating",
            "Medium"
          ],
          "prerequisites": [
            "react_mounting_phase"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_SCU_purpose_open",
          "topic": "shouldComponentUpdate Purpose",
          "level": "medium",
          "type": "open",
          "question": "Describe the purpose of `shouldComponentUpdate(nextProps, nextState)` in React class components. When would you typically implement it, and what are the potential pitfalls?",
          "answer": "`shouldComponentUpdate(nextProps, nextState)` is a lifecycle method called before a component is re-rendered due to new props or state. Its primary purpose is **performance optimization**. It must return a boolean value:\n-   `true` (default): React will proceed with the re-rendering process (i.e., call `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`).\n-   `false`: React will skip the entire re-rendering process for this component and its children for that specific update.\n\nYou would typically implement it when you observe performance bottlenecks caused by unnecessary re-renders of a component. This often happens when a parent component re-renders, causing all its children to re-render, even if the child's props or state haven't effectively changed.\n\n**Potential Pitfalls:**\n1.  **Premature Optimization**: Don't implement `shouldComponentUpdate` unless you have identified an actual performance problem. It adds complexity and can sometimes be slower than React's default reconciliation if your comparison logic is inefficient.\n2.  **Bugs due to Incorrect Comparisons**: If your comparison logic is flawed (e.g., shallow comparison when a deep comparison is needed, or missing a prop/state change), the component might fail to update when it should, leading to stale UI. This is a common source of subtle bugs.\n3.  **Side Effects**: Like `render` and `getDerivedStateFromProps`, `shouldComponentUpdate` should be a pure function. Performing side effects within it can lead to unpredictable behavior and hard-to-debug issues.\n\nIn modern React, `React.PureComponent` (which implements a shallow `shouldComponentUpdate`) or `React.memo` (for functional components) are often preferred as they handle common optimization scenarios automatically.",
          "analysisPoints": [
            "Tests understanding of performance optimization in React.",
            "Covers the method's role, use cases, and critical considerations.",
            "Highlights the trade-offs and potential issues with manual implementation."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Re-rendering",
            "PureComponent",
            "React.memo",
            "Pitfalls"
          ],
          "evaluationCriteria": [
            "Clear explanation of purpose and return value.",
            "Identification of appropriate use cases (performance bottlenecks).",
            "Comprehensive listing and explanation of common pitfalls."
          ],
          "example": "```javascript\nclass OptimizedComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'value' prop changes or 'isActive' state changes.\n    // This is a shallow comparison; for nested objects/arrays, deep comparison or immutability is needed.\n    return nextProps.value !== this.props.value || nextState.isActive !== this.state.isActive;\n  }\n\n  render() {\n    console.log('OptimizedComponent rendered');\n    return <div>Value: {this.props.value}, Active: {this.state.isActive ? 'Yes' : 'No'}</div>;\n  }\n}\n```",
          "tags": [
            "React",
            "Lifecycle",
            "Performance",
            "Optimization",
            "Medium",
            "Best Practices"
          ],
          "prerequisites": [
            "react_props_state"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_snapshot_purpose_mcq",
          "topic": "getSnapshotBeforeUpdate Purpose",
          "level": "hard",
          "type": "mcq",
          "question": "What is the primary purpose of `getSnapshotBeforeUpdate(prevProps, prevState)` in the React lifecycle?",
          "answer": "To capture information from the DOM (e.g., scroll position) immediately before it is updated.",
          "options": [
            "To perform asynchronous data fetching before the component updates.",
            "To decide whether the component should re-render or not.",
            "To capture information from the DOM (e.g., scroll position) immediately before it is updated.",
            "To initialize component state based on new props."
          ],
          "analysisPoints": [
            "Tests knowledge of a less common but powerful lifecycle method.",
            "Distinguishes its role (pre-DOM update snapshot) from other methods (data fetching, re-render decision, state initialization).",
            "Emphasizes its synchronous nature and return value."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "DOM Manipulation",
            "Updating Phase",
            "Snapshot"
          ],
          "evaluationCriteria": [
            "Accurate identification of the specific purpose of the method.",
            "Understanding its position in the lifecycle relative to DOM updates."
          ],
          "example": "```javascript\nclass ChatBox extends React.Component {\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Are we adding new items?\n    if (this.props.messages.length > prevProps.messages.length) {\n      const list = this.listRef.current;\n      // Capture scroll height if user is near the bottom\n      if (list && list.scrollTop + list.clientHeight >= list.scrollHeight - 50) {\n        return list.scrollHeight;\n      }\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // If we received a snapshot, it means we were near the bottom, so maintain scroll\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      if (list) {\n        list.scrollTop = list.scrollHeight - snapshot;\n      }\n    }\n  }\n  render() {\n    return <div ref={this.listRef}>...messages...</div>;\n  }\n}\n```\nThis example shows how `getSnapshotBeforeUpdate` is used to capture the scroll position before new messages are rendered, allowing `componentDidUpdate` to adjust the scroll so the user stays at the bottom.",
          "tags": [
            "React",
            "Lifecycle",
            "DOM",
            "Advanced",
            "Hard"
          ],
          "prerequisites": [
            "react_updating_phase"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_CDU_setState_loop_open",
          "topic": "componentDidUpdate and setState",
          "level": "hard",
          "type": "open",
          "question": "Can you call `setState()` inside `componentDidUpdate()`? If so, what precautions must you take, and why?",
          "answer": "Yes, you can call `setState()` inside `componentDidUpdate()`, but you must do so **conditionally**. If `setState()` is called unconditionally in `componentDidUpdate()`, it will immediately trigger another update cycle for the component, leading to an **infinite loop** of re-renders.\n\n**Precautions to take:**\n1.  **Always wrap `setState()` in a condition**: The condition must compare the current props (`this.props`) or state (`this.state`) with the previous props (`prevProps`) or state (`prevState`) that were passed as arguments to `componentDidUpdate()`. For example, `if (this.props.userId !== prevProps.userId) { this.setState({ ... }); }`.\n2.  **Ensure the condition eventually evaluates to `false`**: The condition must ensure that the `setState` call will eventually stop. If the `setState` call itself causes the condition to remain true, you'll still have an infinite loop.\n\n**Why these precautions?**\n-   `componentDidUpdate()` is called *after* every re-render (triggered by props or state changes). If `setState()` is called without a condition, it will trigger a new re-render, which in turn calls `componentDidUpdate()` again, creating a continuous loop. This quickly exhausts the browser's resources and crashes the application.\n-   By comparing `prevProps` and `prevState`, you ensure that `setState()` is only called when there's a *meaningful* change that requires a subsequent state update, thus breaking the potential loop and ensuring predictable behavior.",
          "analysisPoints": [
            "Tests advanced understanding of lifecycle methods and state management.",
            "Requires knowledge of potential pitfalls (infinite loops) and how to prevent them.",
            "Emphasizes conditional logic for safe state updates."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "setState",
            "Infinite Loop",
            "Conditional Rendering",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Clear explanation of `setState`'s permissibility.",
            "Accurate identification and explanation of infinite loop risk.",
            "Detailed guidance on necessary conditional checks."
          ],
          "example": "```javascript\nclass UserProfile extends React.Component {\n  state = { userData: null, loading: false };\n\n  componentDidUpdate(prevProps) {\n    // CORRECT: Only fetch data if userId prop has changed\n    if (this.props.userId !== prevProps.userId) {\n      this.setState({ loading: true });\n      fetch(`/api/users/${this.props.userId}`)\n        .then(res => res.json())\n        .then(data => this.setState({ userData: data, loading: false }))\n        .catch(error => console.error(error));\n    }\n  }\n\n  render() {\n    if (this.state.loading) return <div>Loading user data...</div>;\n    return <div>{this.state.userData ? `User: ${this.state.userData.name}` : 'No user selected'}</div>;\n  }\n}\n```\nThis example correctly uses `setState` within `componentDidUpdate` by checking if `userId` has changed, preventing an infinite loop.",
          "tags": [
            "React",
            "Lifecycle",
            "State",
            "API",
            "Hard",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "react_state_management",
            "react_updating_phase"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_SCU_return_type_flashcard",
          "topic": "shouldComponentUpdate Return Value",
          "level": "easy",
          "type": "flashcard",
          "question": "What data type must `shouldComponentUpdate(nextProps, nextState)` return?",
          "answer": "Boolean",
          "analysisPoints": [
            "Quick recall of method return type."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Return Type",
            "Performance"
          ],
          "evaluationCriteria": [
            "Correctly identifies the required return type."
          ],
          "example": "Returning `true` means re-render, `false` means skip re-render.",
          "tags": [
            "React",
            "Lifecycle",
            "Performance",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_diagram_open",
          "topic": "React Class Component Lifecycle",
          "level": "hard",
          "type": "open",
          "question": "Draw or describe a complete diagram of the React class component lifecycle, including both mounting and updating phases. For each method, briefly state its purpose and whether side effects are allowed.",
          "answer": "```mermaid\ngraph TD\n    A[Constructor] --> B{static getDerivedStateFromProps}\n    B --> C[render]\n    C --> D[componentDidMount]\n\n    D --> E[Props/State Change]\n    E --> F{shouldComponentUpdate}\n    F -- returns false --> I[No Re-render]\n    F -- returns true --> B2{static getDerivedStateFromProps}\n    B2 --> G[render]\n    G --> H[getSnapshotBeforeUpdate]\n    H --> J[componentDidUpdate]\n\n    J --> E\n\n    D --> K[componentWillUnmount]\n    K --> L[Component Unmounted]\n\n    subgraph Mounting\n        A\n        B\n        C\n        D\n    end\n\n    subgraph Updating\n        E\n        F\n        B2\n        G\n        H\n        J\n    end\n\n    subgraph Unmounting\n        K\n        L\n    end\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n    style D fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n    style J fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n    style K fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n\n    classDef sideEffectMethods fill:#ffe,stroke:#333,stroke-width:2px,color:#000\n    class D,J,K sideEffectMethods\n\n    %% Method Details\n    note over A: Purpose: Initialize state, bind methods. Side Effects: NO.\n    note over B: Purpose: Derive state from props. Side Effects: NO.\n    note over C: Purpose: Return JSX. Side Effects: NO (pure).\n    note over D: Purpose: First place component is in DOM. Side Effects: YES (API calls, subscriptions).\n\n    note over E: Event: Props or state change.\n    note over F: Purpose: Optimize re-renders. Return boolean. Side Effects: NO (pure).\n    note over B2: Purpose: (Same as mount) Derive state from props. Side Effects: NO.\n    note over G: Purpose: (Same as mount) Return new JSX. Side Effects: NO (pure).\n    note over H: Purpose: Capture DOM info before update. Side Effects: NO (read only).\n    note over J: Purpose: After DOM update. Side Effects: YES (conditional API calls, DOM manipulation based on new state/props).\n\n    note over K: Purpose: Cleanup (remove event listeners, cancel subscriptions). Side Effects: YES.\n\n```\n\n**Brief Purpose and Side Effect Allowance:**\n\n**Mounting Phase:**\n1.  `constructor(props)`: Initializes state and binds methods. **NO** side effects.\n2.  `static getDerivedStateFromProps(props, state)`: Updates state based on prop changes. **NO** side effects (must be pure).\n3.  `render()`: Returns JSX to be rendered. **NO** side effects (must be pure).\n4.  `componentDidMount()`: Called after component is in DOM. Ideal for API calls, subscriptions, DOM manipulation. **YES** side effects.\n\n**Updating Phase:**\n1.  `static getDerivedStateFromProps(props, state)`: (Same as Mounting) Updates state based on prop changes. **NO** side effects.\n2.  `shouldComponentUpdate(nextProps, nextState)`: Determines if component should re-render. Returns boolean. **NO** side effects (must be pure).\n3.  `render()`: (Same as Mounting) Returns new JSX. **NO** side effects.\n4.  `getSnapshotBeforeUpdate(prevProps, prevState)`: Captures DOM information just before update. **NO** side effects (read-only).\n5.  `componentDidUpdate(prevProps, prevState, snapshot)`: Called after DOM update. Ideal for conditional API calls based on prop/state changes, DOM manipulation. **YES** side effects (with caution for `setState`).\n\n**Unmounting Phase:**\n1.  `componentWillUnmount()`: Called before component unmounts. Ideal for cleanup (remove listeners, cancel subscriptions). **YES** side effects (cleanup related).",
          "analysisPoints": [
            "Tests a holistic understanding of the entire class component lifecycle.",
            "Requires recalling the precise order and purpose of each method.",
            "Challenges the ability to differentiate where side effects are appropriate and where they are forbidden."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Mounting",
            "Updating",
            "Unmounting",
            "Side Effects",
            "Purity",
            "Order of Execution"
          ],
          "evaluationCriteria": [
            "Completeness and accuracy of the lifecycle diagram/description.",
            "Correct identification of purpose and side effect allowance for each method.",
            "Clarity of explanation and organization."
          ],
          "example": "Visualizing the lifecycle helps in understanding the flow of data and execution within a React component.",
          "tags": [
            "React",
            "Lifecycle",
            "Diagram",
            "Advanced",
            "Hard",
            "Theory"
          ],
          "prerequisites": [
            "react_mounting_phase",
            "react_updating_phase"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_gDSFP_update_mcq",
          "topic": "getDerivedStateFromProps in Update Phase",
          "level": "medium",
          "type": "mcq",
          "question": "In the Updating Phase, when `static getDerivedStateFromProps(props, state)` is called, what is its primary responsibility?",
          "answer": "To update the component's state based on changes in its props.",
          "options": [
            "To perform API calls if props have changed.",
            "To decide whether the component should re-render or not.",
            "To update the component's state based on changes in its props.",
            "To capture a snapshot of the DOM before rendering."
          ],
          "analysisPoints": [
            "Reinforces the understanding of `getDerivedStateFromProps`'s role across both mounting and updating.",
            "Differentiates its specific purpose from other methods (API calls, re-render decision, DOM snapshot).",
            "Emphasizes that it's about state derivation from props, not side effects."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Updating Phase",
            "Derived State",
            "Props",
            "State"
          ],
          "evaluationCriteria": [
            "Correctly identifies the function of `getDerivedStateFromProps` in the update phase.",
            "Avoids confusing it with methods for side effects or rendering control."
          ],
          "example": "If a component receives a new `itemId` prop, `getDerivedStateFromProps` could set a `loading` state to `true` if the `itemId` has changed, indicating that new data needs to be fetched based on the new prop.",
          "tags": [
            "React",
            "Lifecycle",
            "Updating",
            "Props",
            "State",
            "Medium"
          ],
          "prerequisites": [
            "react_mounting_phase"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_data_fetching_component",
          "title": "Implement a Data Fetching Component",
          "description": "\nCreate a React class component named `PostViewer` that fetches data from a public API and displays it. This task focuses on utilizing the **Mounting Phase** lifecycle methods correctly.\n\n**Requirements:**\n1.  The component should fetch a single post from `https://jsonplaceholder.typicode.com/posts/1`.\n2.  Initialize the component's state to manage `postData` (initially `null`) and `loading` (initially `true`).\n3.  Use the `constructor` to initialize the state and bind any necessary methods.\n4.  Use `componentDidMount` to perform the API call.\n5.  After the data is fetched successfully, update the `postData` state and set `loading` to `false`.\n6.  Display a 'Loading...' message while data is being fetched.\n7.  Once loaded, display the post's title and body.\n8.  Include basic error handling (e.g., `console.error`) for the fetch request.\n\n**Bonus:** Implement a `componentWillUnmount` to simulate cleanup, e.g., logging a message or clearing a hypothetical timer.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass PostViewer extends React.Component {\n  // TODO: Initialize state in constructor\n  // TODO: Fetch data in componentDidMount\n  // TODO: Implement render method to display loading/data\n  \n  constructor(props) {\n    super(props);\n    this.state = {\n      postData: null,\n      loading: true,\n      error: null\n    };\n    console.log('PostViewer: Constructor called');\n  }\n\n  // static getDerivedStateFromProps(props, state) { return null; }\n\n  componentDidMount() {\n    console.log('PostViewer: componentDidMount called. Fetching data...');\n    // TODO: Perform API call here\n    // fetch('https://jsonplaceholder.typicode.com/posts/1')\n    //   .then(response => response.json())\n    //   .then(data => this.setState({ postData: data, loading: false }))\n    //   .catch(error => this.setState({ error: error, loading: false }));\n  }\n\n  // Bonus: Add componentWillUnmount\n  // componentWillUnmount() {\n  //   console.log('PostViewer: componentWillUnmount called. Cleaning up...');\n  // }\n\n  render() {\n    console.log('PostViewer: render called');\n    const { postData, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading post...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div>\n        <h3>{postData.title}</h3>\n        <p>{postData.body}</p>\n      </div>\n    );\n  }\n}\n\nexport default PostViewer;",
          "solutionCode": "import React from 'react';\n\nclass PostViewer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      postData: null,\n      loading: true,\n      error: null\n    };\n    console.log('PostViewer: Constructor called');\n  }\n\n  componentDidMount() {\n    console.log('PostViewer: componentDidMount called. Fetching data...');\n    fetch('https://jsonplaceholder.typicode.com/posts/1')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({ postData: data, loading: false });\n        console.log('PostViewer: Data fetched successfully.');\n      })\n      .catch(error => {\n        this.setState({ error: error, loading: false });\n        console.error('PostViewer: Error fetching data:', error);\n      });\n  }\n\n  componentWillUnmount() {\n    console.log('PostViewer: componentWillUnmount called. Cleaning up any subscriptions/timers.');\n    // For example, if you had a WebSocket connection or a timer, you'd close/clear it here.\n  }\n\n  render() {\n    console.log('PostViewer: render called');\n    const { postData, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading post...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '8px' }}>\n        <h3>{postData.title}</h3>\n        <p>{postData.body}</p>\n      </div>\n    );\n  }\n}\n\nexport default PostViewer;",
          "testCases": [
            "Initial render displays 'Loading post...'.",
            "After fetch completes successfully, component displays post title and body.",
            "In case of a fetch error (e.g., network down or invalid URL), an error message is displayed.",
            "Console logs verify the order of `constructor`, `componentDidMount`, and `render`.",
            "(`componentWillUnmount` bonus) A message is logged to the console when the component is unmounted from the DOM (e.g., by conditional rendering in a parent component)."
          ],
          "hints": [
            "Remember to call `super(props)` in the `constructor`.",
            "`fetch` returns a Promise, so use `.then()` and `.catch()`.",
            "Update state using `this.setState()` once data is received.",
            "The `loading` state helps manage what to display before and after data arrives."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Mounting",
            "Data Fetching",
            "API",
            "State Management"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_basics",
            "promises_and_fetch",
            "theory_mounting_phase"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "componentDidMount",
            "constructor",
            "render",
            "setState"
          ]
        },
        {
          "id": "task_optimizing_list_rendering",
          "title": "Optimize List Re-rendering with shouldComponentUpdate",
          "description": "\nCreate a React class component named `OptimizedListItem` that represents an individual item in a list. This component should only re-render if its `itemData` prop or `isSelected` prop actually changes. This task focuses on utilizing the `shouldComponentUpdate` method for performance optimization in the **Updating Phase**.\n\n**Requirements:**\n1.  Create a `ListItem` class component that accepts `itemData` (an object with `id` and `text`) and `isSelected` (a boolean) as props.\n2.  Implement a `render` method that displays the `itemData.text` and visually indicates if `isSelected` is `true` (e.g., by changing background color or adding a border).\n3.  Implement `shouldComponentUpdate(nextProps, nextState)` to prevent unnecessary re-renders. The component should only re-render if:\n    *   `nextProps.itemData.id` is different from `this.props.itemData.id`\n    *   `nextProps.itemData.text` is different from `this.props.itemData.text`\n    *   `nextProps.isSelected` is different from `this.props.isSelected`\n4.  Add `console.log` statements inside `render` and `shouldComponentUpdate` to verify when they are called.\n5.  (Optional but recommended for testing): Create a parent component `App` that renders a list of `OptimizedListItem` components. Implement logic in `App` to periodically update some `itemData` or `isSelected` props for *some* items, and also trigger parent re-renders that *don't* change props for other items, to demonstrate the optimization working.\n\n**Hint:** A simple shallow comparison of primitive props is sufficient for `shouldComponentUpdate` in this case, but remember that for complex nested objects, a deeper comparison or immutability might be needed in real-world scenarios.",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass OptimizedListItem extends React.Component {\n  // TODO: Implement shouldComponentUpdate\n  // shouldComponentUpdate(nextProps, nextState) {\n  //   // Return true if re-render is needed, false otherwise\n  //   return false; \n  // }\n\n  render() {\n    console.log(`Rendering ListItem: ${this.props.itemData.id}`);\n    const { itemData, isSelected } = this.props;\n    const style = {\n      padding: '10px',\n      margin: '5px 0',\n      border: '1px solid #ddd',\n      backgroundColor: isSelected ? '#e6ffe6' : 'white'\n    };\n    return (\n      <div style={style}>\n        ID: {itemData.id} - {itemData.text}\n        {isSelected && ' (Selected)'}\n      </div>\n    );\n  }\n}\n\n// Parent component for testing (optional, but useful)\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      items: [\n        { id: 1, text: 'First item' },\n        { id: 2, text: 'Second item' },\n        { id: 3, text: 'Third item' }\n      ],\n      selectedId: 1,\n      // A dummy state to trigger parent re-renders without changing child props\n      dummyRenderTrigger: 0\n    };\n  }\n\n  componentDidMount() {\n    // Simulate updates\n    setInterval(() => {\n      this.setState(prevState => ({\n        // Change selected item periodically\n        selectedId: prevState.selectedId === 3 ? 1 : prevState.selectedId + 1,\n        // Update dummy state to trigger App's re-render\n        dummyRenderTrigger: prevState.dummyRenderTrigger + 1\n      }));\n    }, 2000);\n\n    // Simulate a text update for a specific item\n    setTimeout(() => {\n      this.setState(prevState => ({\n        items: prevState.items.map(item => \n          item.id === 2 ? { ...item, text: 'Second item - UPDATED!' } : item\n        )\n      }));\n    }, 4000);\n  }\n\n  render() {\n    console.log('App (Parent) rendering');\n    const { items, selectedId } = this.state;\n    return (\n      <div>\n        <h2>Optimized List Demo (Parent renders {this.state.dummyRenderTrigger} times without prop changes for all children)</h2>\n        {items.map(item => (\n          <OptimizedListItem\n            key={item.id}\n            itemData={item}\n            isSelected={item.id === selectedId}\n          />\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\n\nclass OptimizedListItem extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Log for demonstration purposes\n    console.log(`shouldComponentUpdate for ListItem ${this.props.itemData.id}`);\n    console.log(`  nextProps.itemData.id: ${nextProps.itemData.id} vs this.props.itemData.id: ${this.props.itemData.id}`);\n    console.log(`  nextProps.itemData.text: ${nextProps.itemData.text} vs this.props.itemData.text: ${this.props.itemData.text}`);\n    console.log(`  nextProps.isSelected: ${nextProps.isSelected} vs this.props.isSelected: ${this.props.isSelected}`);\n\n    // Only re-render if specific props have changed\n    if (nextProps.itemData.id !== this.props.itemData.id) {\n      return true;\n    }\n    if (nextProps.itemData.text !== this.props.itemData.text) {\n      return true;\n    }\n    if (nextProps.isSelected !== this.props.isSelected) {\n      return true;\n    }\n    \n    console.log(`  ListItem ${this.props.itemData.id} will NOT re-render.`);\n    return false; // No relevant prop changes, so skip re-render\n  }\n\n  render() {\n    console.log(`Rendering ListItem: ${this.props.itemData.id} - RENDERED!`);\n    const { itemData, isSelected } = this.props;\n    const style = {\n      padding: '10px',\n      margin: '5px 0',\n      border: '1px solid #ddd',\n      backgroundColor: isSelected ? '#e6ffe6' : 'white',\n      transition: 'background-color 0.3s ease'\n    };\n    return (\n      <div style={style}>\n        ID: {itemData.id} - {itemData.text}\n        {isSelected && ' (Selected)'}\n      </div>\n    );\n  }\n}\n\n// Parent component for testing\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      items: [\n        { id: 1, text: 'First item' },\n        { id: 2, text: 'Second item' },\n        { id: 3, text: 'Third item' },\n        { id: 4, text: 'Fourth item' } // Added an extra item to show untouched behavior\n      ],\n      selectedId: 1,\n      dummyRenderTrigger: 0\n    };\n  }\n\n  componentDidMount() {\n    // Simulate updates\n    setInterval(() => {\n      this.setState(prevState => ({\n        selectedId: prevState.selectedId === 4 ? 1 : prevState.selectedId + 1,\n        dummyRenderTrigger: prevState.dummyRenderTrigger + 1\n      }));\n    }, 1500); // Faster interval to see more frequent App re-renders\n\n    // Simulate a text update for a specific item\n    setTimeout(() => {\n      this.setState(prevState => ({\n        items: prevState.items.map(item => \n          item.id === 2 ? { ...item, text: 'Second item - TEXT UPDATED!' } : item\n        )\n      }));\n    }, 4000);\n\n    // Simulate another text update for a different item\n    setTimeout(() => {\n        this.setState(prevState => ({\n            items: prevState.items.map(item => \n                item.id === 3 ? { ...item, text: 'Third item - NEW TEXT!' } : item\n            )\n        }));\n    }, 7000);\n  }\n\n  render() {\n    console.log('App (Parent) rendering - Dummy Trigger:', this.state.dummyRenderTrigger);\n    const { items, selectedId } = this.state;\n    return (\n      <div style={{ fontFamily: 'Arial, sans-serif' }}>\n        <h2>Optimized List Demo (App Render Count: {this.state.dummyRenderTrigger})</h2>\n        <p>This demo shows how <code>shouldComponentUpdate</code> prevents individual list items from re-rendering unless their specific props change.</p>\n        {items.map(item => (\n          <OptimizedListItem\n            key={item.id}\n            itemData={item}\n            isSelected={item.id === selectedId}\n          />\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default App;",
          "testCases": [
            "Initially, all `OptimizedListItem` components render once.",
            "When `App`'s `selectedId` state changes, only the `OptimizedListItem` components whose `isSelected` prop changed (from true to false, or false to true) should have their `render` method called. Others should not.",
            "When `App`'s `dummyRenderTrigger` state changes (causing `App` to re-render), but no `OptimizedListItem`'s props change, no `OptimizedListItem`'s `render` method should be called.",
            "When an `itemData.text` property for a specific item changes, only that `OptimizedListItem` should re-render.",
            "Console logs clearly demonstrate when `shouldComponentUpdate` returns `true` (leading to a `render`) and when it returns `false` (skipping `render`)."
          ],
          "hints": [
            "Remember that `shouldComponentUpdate` receives `nextProps` and `nextState`.",
            "You need to compare `nextProps` with `this.props` for each relevant prop.",
            "Return `true` if any relevant prop has changed, `false` otherwise.",
            "For object props like `itemData`, you'll need to compare their individual properties (`id`, `text`) since `itemData !== nextProps.itemData` would likely always be true for new objects created during updates, defeating the purpose."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Updating",
            "Performance Optimization",
            "shouldComponentUpdate"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_props_state",
            "theory_updating_phase"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "shouldComponentUpdate",
            "PureComponent",
            "Re-rendering",
            "Performance"
          ]
        },
        {
          "id": "task_chat_scroll_component",
          "title": "Implement a Chat Message Scroller with Snapshot",
          "description": "\nCreate a React class component named `ChatMessageList` that displays a list of chat messages. The component should maintain scroll position when new messages are added, specifically by keeping the user at the bottom of the list if they were already near the bottom, otherwise preserving their current scroll position.\n\nThis task focuses on utilizing `getSnapshotBeforeUpdate` and `componentDidUpdate` in the **Updating Phase** for managing DOM state during updates.\n\n**Requirements:**\n1.  The `ChatMessageList` component should accept a `messages` prop (an array of strings).\n2.  Render the messages in a scrollable `div` with a fixed height and `overflow-y: auto`.\n3.  Implement `getSnapshotBeforeUpdate(prevProps, prevState)` to capture the scroll position before the DOM updates.\n    *   Specifically, if new messages are being added (i.e., `this.props.messages.length > prevProps.messages.length`), check if the user's current scroll position is within a small buffer (e.g., 50px) of the bottom of the scroll container.\n    *   If they are near the bottom, return the `scrollHeight` of the container.\n    *   Otherwise, return `null`.\n4.  Implement `componentDidUpdate(prevProps, prevState, snapshot)` to adjust the scroll position.\n    *   If a `snapshot` value was returned from `getSnapshotBeforeUpdate`, it means the user was near the bottom, so adjust `scrollTop` to maintain their position relative to the bottom (i.e., new `scrollTop` = new `scrollHeight` - old `scrollHeight` from snapshot).\n    *   If `snapshot` is `null`, do nothing, preserving the user's manual scroll position.\n5.  (Optional but recommended for testing): Create a parent `App` component that periodically adds new messages to the `ChatMessageList`'s `messages` prop to simulate a chat. Include buttons to manually scroll and observe behavior.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\nclass ChatMessageList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef(); // Create a ref to access the DOM element\n    console.log('ChatMessageList: Constructor');\n  }\n\n  // TODO: Implement getSnapshotBeforeUpdate\n  // getSnapshotBeforeUpdate(prevProps, prevState) {\n  //   if (this.props.messages.length > prevProps.messages.length) {\n  //     const list = this.listRef.current;\n  //     if (list) {\n  //       // Check if user is scrolled to bottom or near bottom\n  //       const isScrolledToBottom = list.scrollTop + list.clientHeight >= list.scrollHeight - 50; // 50px buffer\n  //       if (isScrolledToBottom) {\n  //         return list.scrollHeight; // Return scrollHeight from before update\n  //       }\n  //     }\n  //   }\n  //   return null; // No snapshot needed\n  // }\n\n  // TODO: Implement componentDidUpdate\n  // componentDidUpdate(prevProps, prevState, snapshot) {\n  //   if (snapshot !== null) {\n  //     const list = this.listRef.current;\n  //     if (list) {\n  //       // Adjust scroll to maintain position relative to bottom\n  //       list.scrollTop = list.scrollHeight - snapshot;\n  //     }\n  //   }\n  // }\n\n  render() {\n    console.log('ChatMessageList: Render');\n    const { messages } = this.props;\n    return (\n      <div\n        ref={this.listRef}\n        style={{\n          height: '250px',\n          border: '1px solid #ccc',\n          overflowY: 'auto',\n          padding: '10px',\n          fontFamily: 'monospace',\n          whiteSpace: 'pre-wrap'\n        }}\n      >\n        {messages.map((msg, index) => (\n          <div key={index} style={{ marginBottom: '5px' }}>{msg}</div>\n        ))}\n      </div>\n    );\n  }\n}\n\n// Parent for testing\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      messages: [\n        \"Hello!\",\n        \"Welcome to the chat.\",\n        \"This is an initial message.\",\n        \"Scroll down to see more.\",\n        \"More messages will appear automatically.\",\n        \"This is message 6\", \"This is message 7\", \"This is message 8\", \"This is message 9\", \"This is message 10\", \"This is message 11\", \"This is message 12\", \"This is message 13\", \"This is message 14\", \"This is message 15\", \"This is message 16\", \"This is message 17\", \"This is message 18\", \"This is message 19\", \"This is message 20\", \"This is message 21\", \"This is message 22\", \"This is message 23\", \"This is message 24\", \"This is message 25\"\n      ]\n    };\n  }\n\n  componentDidMount() {\n    this.messageInterval = setInterval(() => {\n      this.setState(prevState => ({\n        messages: [...prevState.messages, `New message ${prevState.messages.length + 1}`]\n      }));\n    }, 1000); // Add a new message every second\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.messageInterval);\n  }\n\n  render() {\n    return (\n      <div style={{ padding: '20px' }}>\n        <h2>Chat Application</h2>\n        <ChatMessageList messages={this.state.messages} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\n\nclass ChatMessageList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef();\n    console.log('ChatMessageList: Constructor');\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('ChatMessageList: getSnapshotBeforeUpdate');\n    // Are we adding new messages?\n    if (this.props.messages.length > prevProps.messages.length) {\n      const list = this.listRef.current;\n      if (list) {\n        // Check if the user was scrolled to the bottom (or very near the bottom)\n        const isScrolledToBottom = list.scrollTop + list.clientHeight >= list.scrollHeight - 20; // 20px buffer\n        if (isScrolledToBottom) {\n          return list.scrollHeight; // Return the current scrollHeight BEFORE the DOM update\n        }\n      }\n    }\n    return null; // If not adding messages or not at bottom, no snapshot needed\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('ChatMessageList: componentDidUpdate');\n    // If a snapshot was returned, it means we were scrolled to the bottom before the update\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      if (list) {\n        // Adjust scroll position to keep the user at the new bottom\n        // new scrollTop = current scrollHeight - (old scrollHeight from snapshot)\n        list.scrollTop = list.scrollHeight - snapshot;\n        console.log(`ChatMessageList: Adjusted scroll to new bottom. New scrollTop: ${list.scrollTop}`);\n      }\n    } else {\n        console.log('ChatMessageList: No snapshot, preserving user scroll position.');\n    }\n  }\n\n  render() {\n    console.log('ChatMessageList: Render');\n    const { messages } = this.props;\n    return (\n      <div\n        ref={this.listRef}\n        style={{\n          height: '250px',\n          border: '1px solid #ccc',\n          overflowY: 'auto',\n          padding: '10px',\n          fontFamily: 'monospace',\n          whiteSpace: 'pre-wrap',\n          display: 'flex',\n          flexDirection: 'column-reverse' // Optional: Renders messages from bottom up\n        }}\n      >\n        {[...messages].reverse().map((msg, index) => (\n          <div key={index} style={{ marginBottom: '5px' }}>{msg}</div>\n        ))}\n      </div>\n    );\n  }\n}\n\n// Parent for testing\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            messages: [\n                \"Hello!\",\n                \"Welcome to the chat.\",\n                \"This is an initial message.\",\n                \"Scroll down to see more.\",\n                \"More messages will appear automatically.\",\n                \"This is message 6\", \"This is message 7\", \"This is message 8\", \"This is message 9\", \"This is message 10\", \"This is message 11\", \"This is message 12\", \"This is message 13\", \"This is message 14\", \"This is message 15\", \"This is message 16\", \"This is message 17\", \"This is message 18\", \"This is message 19\", \"This is message 20\", \"This is message 21\", \"This is message 22\", \"This is message 23\", \"This is message 24\", \"This is message 25\"\n            ]\n        };\n        this.addMessageManually = this.addMessageManually.bind(this);\n    }\n\n    componentDidMount() {\n        this.messageInterval = setInterval(() => {\n            this.setState(prevState => ({\n                messages: [...prevState.messages, `Auto message ${prevState.messages.length + 1}`]\n            }));\n        }, 1000); // Add a new message every second\n    }\n\n    componentWillUnmount() {\n        clearInterval(this.messageInterval);\n    }\n\n    addMessageManually() {\n        this.setState(prevState => ({\n            messages: [...prevState.messages, `Manual message ${prevState.messages.length + 1}`]\n        }));\n    }\n\n    render() {\n        return (\n            <div style={{ padding: '20px' }}>\n                <h2>Chat Application</h2>\n                <button onClick={this.addMessageManually} style={{ marginBottom: '10px', padding: '10px' }}>Add Manual Message</button>\n                <ChatMessageList messages={this.state.messages} />\n                <p style={{ marginTop: '10px', fontSize: '0.9em', color: '#666' }}>Scroll to the bottom, and new messages will keep you there. Scroll up, and new messages won't disrupt your view.</p>\n            </div>\n        );\n    }\n}\n\nexport default App;\n",
          "testCases": [
            "Initial load: The list should be scrolled to the bottom automatically (if messages fill the container).",
            "Auto-add messages: If the user is scrolled to the very bottom, new messages should appear, and the scroll position should remain at the new bottom.",
            "Auto-add messages (scrolled up): If the user scrolls up in the list, new messages should be added at the bottom, but the user's scroll position should NOT change.",
            "Manual message add: The behavior should be consistent whether messages are added automatically or via a button click.",
            "Console logs should verify when `getSnapshotBeforeUpdate` and `componentDidUpdate` are called, and whether a `snapshot` was used."
          ],
          "hints": [
            "Use `React.createRef()` in the constructor and attach it to the scrollable `div` to access its DOM properties.",
            "Relevant DOM properties for scrolling are `scrollHeight`, `clientHeight`, and `scrollTop`.",
            "The condition `list.scrollTop + list.clientHeight >= list.scrollHeight - [BUFFER]` is key to checking if the user is near the bottom.",
            "The `snapshot` value returned from `getSnapshotBeforeUpdate` is passed directly as the third argument to `componentDidUpdate`.",
            "To maintain scroll position when new content is added to the bottom, the `scrollTop` needs to be adjusted by the difference between the new and old `scrollHeight`."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Updating",
            "DOM Manipulation",
            "UX",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "react_refs",
            "theory_updating_phase"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "Refs",
            "DOM manipulation",
            "Scroll behavior"
          ]
        }
      ]
    }
  }
]