[
  {
    "id": "490712d0-c1e6-4e05-a990-a4acc94397b7",
    "startLine": 4300,
    "endLine": 4399,
    "processedDate": "2025-06-17T09:06:43.622Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_component_lifecycle_overview",
          "title": "React Component Lifecycle Overview and Phases",
          "content": "React components undergo a series of phases throughout their existence in the DOM, collectively known as their lifecycle. Understanding these phases and their associated methods is crucial for building robust and efficient React applications. Each phase provides specific 'hooks' where developers can execute code.\n\n## Component Lifecycle Phases\nThere are three primary phases in a React component's lifecycle:\n\n1.  **Mounting:** This is the phase when an instance of a component is being created and inserted into the DOM. This happens for the very first time a component is rendered.\n\n2.  **Updating:** This phase occurs when a component is being re-rendered due to changes in its props or state. This is the most frequently occurring phase in an active application.\n\n3.  **Unmounting:** This is the final phase when a component is being removed from the DOM. This happens when the component is no longer needed or its parent decides to unmount it.\n\nEach phase has a specific set of lifecycle methods that are called in a predictable order, allowing developers to manage side effects, optimize performance, and interact with the DOM at appropriate times.\n\n## React Component Rendering Process\nReact's rendering process is carefully designed to be efficient and predictable. It involves:\n*   **Reconciliation:** React builds a 'virtual DOM' representation of the UI. When state or props change, React creates a new virtual DOM tree and compares it with the previous one. This comparison process is called reconciliation.\n*   **Diffing Algorithm:** React uses a diffing algorithm to identify the minimal set of changes needed to update the actual DOM, rather than re-rendering the entire tree. This makes updates very fast.\n*   **Batching:** React often batches multiple state updates into a single re-render for performance, especially when updates happen within the same event loop tick.",
          "examples": [],
          "relatedQuestions": [
            "question_lifecycle_phases_1",
            "question_lifecycle_flashcard_1",
            "question_lifecycle_open_1"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "lifecycle",
            "fundamentals",
            "rendering"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "dom_manipulation"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "component_optimization",
            "side_effects"
          ]
        },
        {
          "id": "theory_legacy_lifecycle_methods",
          "title": "Legacy (Deprecated) React Lifecycle Methods",
          "content": "Before React v16.3, certain lifecycle methods were commonly used but later deprecated due to potential misuse leading to bugs, performance issues, or hindering future React features like async rendering. While they can still be used with the `UNSAFE_` prefix, it is strongly advised to migrate away from them as they will be removed in future major versions of React.\n\n## Deprecated Lifecycle Methods in React v16\n\n1.  `componentWillMount()` / `UNSAFE_componentWillMount()`\n    *   **Problem:** This method was often misused for side effects like data fetching or subscriptions that should occur *after* the component has mounted and is present in the DOM (`componentDidMount`). Running side effects here meant they could be executed multiple times if React paused, aborted, or restarted a render, leading to inconsistencies.\n    *   **Replacement:** For initialization logic or setting initial state, the `constructor()` is suitable. For side effects that require DOM access or subscriptions, `componentDidMount()` is the correct place.\n\n2.  `componentWillReceiveProps(nextProps)` / `UNSAFE_componentWillReceiveProps()`\n    *   **Problem:** This method was frequently misused for updating state based on prop changes. Its frequent calling (even if props hadn't *semantically* changed) often led to bugs, infinite loops, and made reasoning about state updates difficult. It was also called before `render`, meaning it could trigger an unnecessary re-render.\n    *   **Replacement:** `static getDerivedStateFromProps(props, state)` is the recommended replacement for deriving state from props. For side effects triggered by prop changes (e.g., fetching new data), `componentDidUpdate()` should be used.\n\n3.  `componentWillUpdate(nextProps, nextState)` / `UNSAFE_componentWillUpdate()`\n    *   **Problem:** This method was often misused for pre-render calculations or DOM manipulations *before* the update. Like `componentWillMount`, it could be called multiple times before an actual commit, leading to wasted work or inconsistent state.\n    *   **Replacement:** `getSnapshotBeforeUpdate(prevProps, prevState)` is used for reading DOM properties right before an update, and `componentDidUpdate(prevProps, prevState, snapshot)` for post-update side effects and DOM manipulations.\n\nUsing the `UNSAFE_` prefix serves as a warning that these methods are unsafe for async React and encourages developers to refactor their code.",
          "examples": [
            {
              "id": "example_deprecated_willmount",
              "title": "Misuse of componentWillMount (Deprecated)",
              "code": "class DeprecatedComponent extends React.Component {\n  // Bad practice: Side effect in componentWillMount\n  // This can run multiple times and might not be useful before mount\n  UNSAFE_componentWillMount() {\n    console.log('Component will mount - fetching data (bad practice)');\n    // This is problematic if fetching data here causes state updates\n    // that are then discarded by React's async rendering\n  }\n\n  componentDidMount() {\n    console.log('Component did mount - fetching data (good practice)');\n    // Good practice: Fetch data here as component is in DOM\n    this.fetchInitialData();\n  }\n\n  fetchInitialData() {\n    // Simulate API call\n    setTimeout(() => {\n      this.setState({ data: 'Loaded data' });\n    }, 500);\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Deprecated Method Example</h2>\n        <p>{this.state.data || 'Loading...'}</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This example shows the `UNSAFE_componentWillMount` method being used. While it might seem to work in some synchronous React versions, it's problematic in modern React due to potential for multiple executions before commit or being called when an async render is aborted. The `componentDidMount` is the correct place for initial data fetching and subscriptions because it guarantees the component is mounted in the DOM and ready for side effects.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_deprecated_methods_1",
            "question_deprecated_methods_open_1",
            "question_deprecated_methods_mcq_1",
            "question_deprecated_methods_flashcard_1"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "lifecycle",
            "deprecated",
            "migration",
            "async_rendering"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "component_lifecycle_overview"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_react_development",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_modern_lifecycle_react163",
          "title": "Modern React Lifecycle Methods (React 16.3+)",
          "content": "React 16.3 introduced significant changes to the component lifecycle to better support new features like async rendering and to promote more robust and predictable component behavior. The changes primarily involved replacing problematic legacy methods with safer alternatives and clarifying the different phases of rendering.\n\n## React 16.3+ Lifecycle Phases Diagram\n![React 16.3+ Lifecycle Methods Diagram](images/phases16.3.jpg)\n\n## Lifecycle Division into Phases:\nEach lifecycle can be divided into three logical parts:\n\n1.  **Render Phase:**\n    *   This phase involves methods that are **pure** and **have no side effects**. They should only calculate the next state or JSX to be rendered.\n    *   React may **pause, abort, or restart** this phase multiple times before committing the changes to the DOM, especially with concurrent mode features.\n    *   Methods in this phase: `constructor()`, `static getDerivedStateFromProps()`, `render()`.\n\n2.  **Pre-commit Phase:**\n    *   This phase occurs right before React commits the changes to the actual DOM.\n    *   Methods in this phase can **read the DOM**, allowing you to capture information from the DOM (e.g., scroll position) before React potentially changes it.\n    *   Method in this phase: `getSnapshotBeforeUpdate()`.\n\n3.  **Commit Phase:**\n    *   This phase is where React **works with the actual DOM**, applying all calculated changes.\n    *   Methods here can **run side effects**, such as network requests, subscriptions, or direct DOM manipulations.\n    *   These methods are guaranteed to be called only once per update cycle and only after the DOM has been updated.\n    *   Methods in this phase: `componentDidMount()`, `componentDidUpdate()`, `componentWillUnmount()`, `componentDidCatch()`.\n\n## Key New and Modified Lifecycle Methods:\n\n*   `static getDerivedStateFromProps(props, state)`:\n    *   **Purpose:** A static method called right before `render()` on both initial mount and subsequent updates.\n    *   **Usage:** Its primary purpose is to update state based on prop changes. It should return an object to update the state, or `null` to indicate no state change is needed.\n    *   **Benefit:** Being static, it doesn't have access to the component instance (`this`), preventing side effects. It encourages a clear separation of concerns: deriving state from props vs. performing side effects.\n    *   **Replaces:** `componentWillReceiveProps()` for state derivation.\n\n*   `getSnapshotBeforeUpdate(prevProps, prevState)`:\n    *   **Purpose:** Called right before the changes from `render()` are committed to the DOM.\n    *   **Usage:** It allows your component to capture some information from the DOM (e.g., scroll position) *before* it is potentially changed by the update.\n    *   **Return Value:** The value returned by `getSnapshotBeforeUpdate` will be passed as the third argument to `componentDidUpdate`.\n    *   **Replaces:** `componentWillUpdate()` for pre-render DOM reads.\n\n*   Error Boundaries (`static getDerivedStateFromError()` and `componentDidCatch()`):\n    *   **Purpose:** These methods are used to create Error Boundaries, which are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application.\n    *   `static getDerivedStateFromError(error)`: A static method called after an error is thrown by a descendant component. It should return an object to update the state, which will then trigger a re-render with the fallback UI.\n    *   `componentDidCatch(error, info)`: Called after an error has been caught. It's used for side effects like logging the error information.\n\nThese changes encourage more explicit and safer ways to manage state and side effects, making components more resilient and easier to debug.",
          "examples": [
            {
              "id": "example_getderivedstatefromprops",
              "title": "Using static getDerivedStateFromProps",
              "code": "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      count: props.initialCount || 0,\n      lastPropsCount: props.initialCount || 0 \n    };\n  }\n\n  // This method is called on every render, both on mount and update.\n  // It should return an object to update state, or null.\n  static getDerivedStateFromProps(props, state) {\n    // Only update state if the initialCount prop has changed\n    if (props.initialCount !== state.lastPropsCount) {\n      return {\n        count: props.initialCount,\n        lastPropsCount: props.initialCount\n      };\n    }\n    return null; // No state update needed\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState(prevState => ({ count: prevState.count + 1 }))}>\n          Increment Internal Count\n        </button>\n        <p>Prop Initial Count: {this.props.initialCount}</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates `static getDerivedStateFromProps`. It's used to synchronize the component's internal `count` state with the `initialCount` prop *only when the prop actually changes*. This prevents the common bug where prop changes don't update internal state correctly, while allowing internal state to be mutated independently (e.g., by the increment button). The `lastPropsCount` in state is used to compare with the new `props.initialCount` to avoid infinite loops or unnecessary updates.",
              "language": "typescript"
            },
            {
              "id": "example_getsnapshotbeforeupdate",
              "title": "Using getSnapshotBeforeUpdate and componentDidUpdate for Scroll Position",
              "code": "class ScrollableList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef();\n    this.state = { messages: [] };\n  }\n\n  componentDidMount() {\n    // Simulate initial message load\n    this.setState({ messages: Array.from({ length: 20 }, (_, i) => `Message ${i + 1}`) });\n  }\n\n  // Called right before the DOM is updated\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // If we're adding new messages, capture scroll position\n    if (prevState.messages.length < this.state.messages.length) {\n      const list = this.listRef.current;\n      // Return scrollHeight - scrollTop to maintain bottom position\n      return list.scrollHeight - list.scrollTop;\n    }\n    return null;\n  }\n\n  // Called after the DOM is updated\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // If a snapshot was returned (meaning new messages were added)\n    // and the user was at the bottom, maintain scroll position at the bottom\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      list.scrollTop = list.scrollHeight - snapshot;\n    }\n  }\n\n  addMessage = () => {\n    this.setState(prevState => ({\n      messages: [...prevState.messages, `New Message ${prevState.messages.length + 1}`]\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <div\n          ref={this.listRef}\n          style={{ height: '200px', overflowY: 'scroll', border: '1px solid gray' }}\n        >\n          {this.state.messages.map((msg, index) => (\n            <p key={index}>{msg}</p>\n          ))}\n        </div>\n        <button onClick={this.addMessage}>Add New Message</button>\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates `getSnapshotBeforeUpdate` in conjunction with `componentDidUpdate`. `getSnapshotBeforeUpdate` is used to capture the current scroll height and scroll position *before* the new messages are added and the DOM is updated. This 'snapshot' value is then passed to `componentDidUpdate`, allowing us to restore the scroll position such that the user remains at the bottom of the list when new messages are added, providing a better user experience for chat-like interfaces.",
              "language": "typescript"
            },
            {
              "id": "example_error_boundary",
              "title": "Implementing an Error Boundary",
              "code": "class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  // This static method is called when an error is thrown in a child component.\n  // It should return an object to update the state.\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true };\n  }\n\n  // This method is called after an error has been caught.\n  // It's used for side effects like logging the error.\n  componentDidCatch(error, errorInfo) {\n    console.error(\"Error caught by Error Boundary:\", error, errorInfo);\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return (\n        <div>\n          <h1>Something went wrong.</h1>\n          {this.props.showDetails && this.state.error && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              {this.state.error && this.state.error.toString()}\n              <br />\n              {this.state.errorInfo.componentStack}\n            </details>\n          )}\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage of the ErrorBoundary\nfunction FaultyComponent() {\n  throw new Error('I crashed!');\n  return <p>This will not be rendered.</p>;\n}\n\n// Example: Wrap a potentially faulty component with the ErrorBoundary\n// class App extends React.Component {\n//   render() {\n//     return (\n//       <ErrorBoundary showDetails={true}>\n//         <FaultyComponent />\n//       </ErrorBoundary>\n//     );\n//   }\n// }",
              "explanation": "This example demonstrates how to create an Error Boundary component using `static getDerivedStateFromError` and `componentDidCatch`. `getDerivedStateFromError` is used to update the component's state to `hasError: true` when a child component throws an error, which then triggers a re-render of the fallback UI. `componentDidCatch` is used for side effects, such as logging the error to an analytics service. This pattern prevents the entire application from crashing due to errors in a sub-tree.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_modern_lifecycle_1",
            "question_modern_lifecycle_open_1",
            "question_modern_lifecycle_mcq_1",
            "question_modern_lifecycle_mcq_2",
            "question_modern_lifecycle_flashcard_1",
            "question_modern_lifecycle_flashcard_2"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_scroll_position_sync",
            "task_error_boundary_implementation"
          ],
          "tags": [
            "react",
            "lifecycle",
            "react16.3",
            "getDerivedStateFromProps",
            "getSnapshotBeforeUpdate",
            "error_boundaries",
            "side_effects"
          ],
          "technology": "React",
          "prerequisites": [
            "component_lifecycle_overview",
            "legacy_lifecycle_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_react",
            "performance_optimization",
            "error_handling"
          ]
        },
        {
          "id": "theory_specific_lifecycle_methods_detailed",
          "title": "Detailed Breakdown of React Lifecycle Methods",
          "content": "This section provides a more granular look at the individual lifecycle methods, their purpose, and when they are invoked within the three main phases of a React component's existence.\n\n## Mounting Phase Methods\nThese methods are called in sequence when an instance of a component is being created and inserted into the DOM:\n\n*   **`constructor(props)`**\n    *   **Purpose:** The very first method called when a component is initialized. Used for initializing local state by assigning an object to `this.state` and for binding event handler methods.\n    *   **Important:** `super(props)` must be called. Do not cause side effects or subscriptions here.\n\n*   **`static getDerivedStateFromProps(props, state)`**\n    *   **Purpose:** Called right before `render()` on both initial mount and subsequent updates. It's a static method, so it doesn't have access to `this`.\n    *   **Usage:** Should return an object to update the state, or `null` to indicate no state change is needed. Its sole purpose is to derive state from props.\n\n*   **`render()`**\n    *   **Purpose:** The only required method in a class component. It reads `this.props` and `this.state` and returns JSX (React elements) that React will render to the DOM.\n    *   **Important:** Must be a pure function; it should not modify component state, interact with the DOM, or perform side effects. It should return elements, fragments, portals, strings, or numbers, or `null`/`false` for nothing.\n\n*   **`componentDidMount()`**\n    *   **Purpose:** Called immediately after the component is mounted (i.e., inserted into the DOM tree).\n    *   **Usage:** Ideal for performing side effects that require DOM nodes (e.g., integrating with third-party libraries that need DOM, setting up subscriptions, fetching initial data from an API). You can call `setState()` here, but it will trigger an extra render.\n    *   **Diagram:** ![React Mounting Phase](images/react_mounting.png)\n\n## Updating Phase Methods\nThese methods are called when a component is being re-rendered as a result of changes to its props or state:\n\n*   **`static getDerivedStateFromProps(props, state)`**\n    *   **Purpose:** (As described above) Called on every update before `render()` to potentially update state based on new props.\n\n*   **`shouldComponentUpdate(nextProps, nextState)`**\n    *   **Purpose:** Called before `render()` when new props or state are received. It's used for performance optimization.\n    *   **Usage:** Returns a `boolean` value. If `false`, React will skip calling `render()` and `componentDidUpdate()` for this update cycle. Default is `true`.\n    *   **Important:** Should be a pure function and not cause side effects.\n\n*   **`render()`**\n    *   **Purpose:** (As described above) Called again to determine what to display based on updated props and state.\n\n*   **`getSnapshotBeforeUpdate(prevProps, prevState)`**\n    *   **Purpose:** Called right before the most recently rendered output is committed to the DOM. Allows capturing information from the DOM (e.g., scroll position) before it's potentially changed.\n    *   **Usage:** Returns a value that will be passed as the third argument to `componentDidUpdate()`. Return `null` if nothing is needed.\n\n*   **`componentDidUpdate(prevProps, prevState, snapshot)`**\n    *   **Purpose:** Called immediately after updating occurs.\n    *   **Usage:** Ideal for performing side effects related to updates, such as network requests (e.g., fetching new data when a prop changes), DOM manipulation based on new state/props, or interacting with third-party libraries. This is also where you would use the `snapshot` returned by `getSnapshotBeforeUpdate`.\n    *   **Important:** You can call `setState()` here, but it must be wrapped in a condition (e.g., `if (nextProps.something !== this.props.something)`) to prevent an infinite loop.\n    *   **Diagram:** ![React Updating Phase](images/react_updating.png)\n\n## Unmounting Phase Method\nThis method is called when a component is being removed from the DOM:\n\n*   **`componentWillUnmount()`**\n    *   **Purpose:** Called immediately before a component is unmounted and destroyed.\n    *   **Usage:** Perform necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions created in `componentDidMount()`.\n    *   **Important:** Do not call `setState()` here as the component will not be re-rendered.\n    *   **Diagram:** ![React Unmounting Phase](images/react_unmounting.png)\n\n## Error Handling Methods (Error Boundaries)\nThese methods are used to catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI.\n\n*   **`static getDerivedStateFromError(error)`**\n    *   **Purpose:** Called after an error is thrown by a descendant component. It's static and used to update state (e.g., `hasError: true`) to trigger a re-render with a fallback UI.\n\n*   **`componentDidCatch(error, info)`**\n    *   **Purpose:** Called after an error has been caught. Used for side effects like logging error information to an error reporting service.\n\nIt is crucial to use the appropriate lifecycle method for each task to ensure component predictability, performance, and correctness.",
          "examples": [
            {
              "id": "example_componentdidmount",
              "title": "Using componentDidMount for Data Fetching",
              "code": "class DataFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null, loading: true, error: null };\n  }\n\n  // Called once after the component is mounted\n  componentDidMount() {\n    console.log('ComponentDidMount: Fetching data...');\n    this.fetchData();\n  }\n\n  async fetchData() {\n    try {\n      const response = await fetch('https://api.example.com/data'); // Replace with a real API if needed\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ data, loading: false });\n    } catch (error) {\n      this.setState({ error, loading: false });\n    }\n  }\n\n  render() {\n    if (this.state.loading) {\n      return <p>Loading data...</p>;\n    }\n    if (this.state.error) {\n      return <p>Error: {this.state.error.message}</p>;\n    }\n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <pre>{JSON.stringify(this.state.data, null, 2)}</pre>\n      </div>\n    );\n  }\n}",
              "explanation": "This example uses `componentDidMount` to perform an asynchronous data fetch when the component is first rendered and inserted into the DOM. This is the recommended place for API calls because the component is guaranteed to be available in the DOM, and it only runs once per mount, preventing unnecessary network requests.",
              "language": "typescript"
            },
            {
              "id": "example_shouldcomponentupdate",
              "title": "Optimizing with shouldComponentUpdate",
              "code": "class OptimizedComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'value' prop changes or the internal 'count' state changes\n    if (nextProps.value !== this.props.value || nextState.count !== this.state.count) {\n      console.log('OptimizedComponent: Re-rendering!');\n      return true;\n    }\n    console.log('OptimizedComponent: Skipping re-render.');\n    return false; // Prevent re-render\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  incrementCount = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <h3>Optimized Component</h3>\n        <p>Prop Value: {this.props.value}</p>\n        <p>Internal Count: {this.state.count}</p>\n        <button onClick={this.incrementCount}>Increment Internal Count</button>\n      </div>\n    );\n  }\n}\n\n// Example Parent Component to demonstrate `shouldComponentUpdate`\n// class ParentComponent extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { parentValue: 'Initial', irrelevant: 0 };\n//   }\n\n//   componentDidMount() {\n//     setInterval(() => {\n//       this.setState(prevState => ({ irrelevant: prevState.irrelevant + 1 }));\n//     }, 1000);\n//   }\n\n//   render() {\n//     return (\n//       <div>\n//         <OptimizedComponent value={this.state.parentValue} />\n//         <button onClick={() => this.setState({ parentValue: 'New Value' })}>Change Parent Value</button>\n//         <p>Irrelevant Parent State: {this.state.irrelevant}</p>\n//       </div>\n//     );\n//   }\n// }",
              "explanation": "This example shows how `shouldComponentUpdate` can be used for performance optimization. By implementing a custom check, the component only re-renders if the `value` prop or the `count` state actually changes. If the parent component re-renders but passes the same `value` prop and the internal `count` hasn't changed, `shouldComponentUpdate` will return `false`, preventing the `render` method and subsequent `componentDidUpdate` from being called, thus saving CPU cycles.",
              "language": "typescript"
            },
            {
              "id": "example_componentwillunmount",
              "title": "Using componentWillUnmount for Cleanup",
              "code": "class TimerComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { seconds: 0 };\n    this.timerId = null;\n  }\n\n  componentDidMount() {\n    // Start a timer when the component mounts\n    this.timerId = setInterval(() => {\n      this.setState(prevState => ({ seconds: prevState.seconds + 1 }));\n    }, 1000);\n    console.log('Timer started.');\n  }\n\n  componentWillUnmount() {\n    // Clear the timer when the component unmounts to prevent memory leaks\n    clearInterval(this.timerId);\n    console.log('Timer cleared.');\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Seconds: {this.state.seconds}</p>\n        <p>Watch the console for 'Timer cleared.' when this component is removed.</p>\n      </div>\n    );\n  }\n}\n\n// Example usage (e.g., in a parent component that conditionally renders TimerComponent):\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { showTimer: true };\n//   }\n\n//   toggleTimer = () => {\n//     this.setState(prevState => ({ showTimer: !prevState.showTimer }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={this.toggleTimer}>\n//           {this.state.showTimer ? 'Hide Timer' : 'Show Timer'}\n//         </button>\n//         {this.state.showTimer && <TimerComponent />}\n//       </div>\n//     );\n//   }\n// }",
              "explanation": "This example demonstrates `componentWillUnmount`. It sets up an interval timer in `componentDidMount`. If the component were to be removed from the DOM without cleaning up this timer, it would continue to run in the background, consuming memory and potentially causing errors, leading to a 'memory leak'. `componentWillUnmount` is the ideal place to perform such cleanup (e.g., `clearInterval`, `cancelSubscription`, `removeEventListener`) to prevent these issues, ensuring resources are released when the component is destroyed.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_specific_lifecycle_mcq_1",
            "question_specific_lifecycle_mcq_2",
            "question_specific_lifecycle_open_1",
            "question_specific_lifecycle_code_1",
            "question_specific_lifecycle_flashcard_1",
            "question_specific_lifecycle_flashcard_2",
            "question_specific_lifecycle_flashcard_3"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_performance_optimization_sCU",
            "task_scroll_position_sync",
            "task_error_boundary_implementation"
          ],
          "tags": [
            "react",
            "lifecycle",
            "constructor",
            "render",
            "componentDidMount",
            "componentDidUpdate",
            "componentWillUnmount",
            "shouldComponentUpdate"
          ],
          "technology": "React",
          "prerequisites": [
            "modern_react_lifecycle_react163"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_component_design",
            "performance_tuning"
          ]
        },
        {
          "id": "theory_method_ordering_best_practices",
          "title": "Consistent Method Ordering in React Components",
          "content": "Following a consistent and logical order for methods within your React class components is a best practice that significantly improves code readability, maintainability, and collaboration, especially in larger codebases. It makes it easier for developers (including yourself in the future) to quickly understand a component's structure and behavior.\n\nWhile React doesn't enforce a specific order, a commonly accepted convention groups methods by their purpose and lifecycle phase. This creates a predictable structure that makes navigating components intuitive.\n\n## Recommended Method Ordering:\n\n1.  **Static methods and properties:** (e.g., `static defaultProps`, `static propTypes`, `static getDerivedStateFromProps`, `static getDerivedStateFromError`)\n    *   These are class-level properties and methods, independent of component instances, and thus logically come first.\n\n2.  **`constructor()`:**\n    *   The constructor is the first instance-level method called and sets up the initial state and binds methods.\n\n3.  **`getChildContext()`:** (Deprecated for Context API, but if used for legacy code, placed here)\n\n4.  **Lifecycle Methods (Mounting Order):**\n    *   `componentWillMount()` / `UNSAFE_componentWillMount()` (Deprecated - avoid)\n    *   `componentDidMount()`\n\n5.  **Lifecycle Methods (Updating Order):**\n    *   `componentWillReceiveProps()` / `UNSAFE_componentWillReceiveProps()` (Deprecated - avoid)\n    *   `shouldComponentUpdate()`\n    *   `componentWillUpdate()` / `UNSAFE_componentWillUpdate()` (Deprecated - avoid)\n    *   `getSnapshotBeforeUpdate()`\n    *   `componentDidUpdate()`\n\n6.  **Lifecycle Methods (Unmounting Order):**\n    *   `componentWillUnmount()`\n\n7.  **Lifecycle Methods (Error Handling):**\n    *   `componentDidCatch()`\n\n8.  **Event handlers:** (e.g., `onClickSubmit()`, `onChangeDescription()`, `handleSubmit()`)\n    *   These are methods that respond to user interactions or other events. Grouping them makes it easy to find component interactivity logic.\n    *   It's common to use arrow functions for these to automatically bind `this`.\n\n9.  **Getter methods for render:** (e.g., `getSelectReason()`, `getFooterContent()`, `getClasses()`)\n    *   Methods that calculate and return values specifically for the `render` method, often breaking down complex JSX generation.\n\n10. **Optional render methods:** (e.g., `renderNavigation()`, `renderProfilePicture()`, `renderItem()`)\n    *   If your `render` method is large, you might split it into smaller, private helper `render` methods for better readability.\n\n11. **`render()`:**\n    *   The `render` method is the core of the component's UI, and placing it last makes it the final destination for understanding what the component visually outputs, relying on all the methods defined above it.\n\nBy adhering to this or a similar consistent order, you create a standard blueprint for all your class components, which aids in code comprehension, debugging, and onboarding new team members.",
          "examples": [
            {
              "id": "example_method_ordering",
              "title": "Example of Recommended Method Ordering",
              "code": "class UserProfile extends React.Component {\n  // 1. Static methods and properties\n  static defaultProps = {\n    userId: 'default'\n  };\n\n  static propTypes = {\n    userId: PropTypes.string.isRequired\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (nextProps.userId !== prevState.currentUserId) {\n      return {\n        userData: null, // Clear data on user change\n        isLoading: true,\n        currentUserId: nextProps.userId\n      };\n    }\n    return null;\n  }\n\n  // 2. constructor()\n  constructor(props) {\n    super(props);\n    this.state = {\n      userData: null,\n      isLoading: true,\n      error: null,\n      currentUserId: props.userId\n    };\n  }\n\n  // 3. componentDidMount()\n  componentDidMount() {\n    this.fetchUserProfile(this.props.userId);\n  }\n\n  // 4. shouldComponentUpdate()\n  shouldComponentUpdate(nextProps, nextState) {\n    return (\n      nextProps.userId !== this.props.userId ||\n      nextState.userData !== this.state.userData ||\n      nextState.isLoading !== this.state.isLoading\n    );\n  }\n\n  // 5. componentDidUpdate()\n  componentDidUpdate(prevProps, prevState) {\n    if (this.props.userId !== prevProps.userId) {\n      this.fetchUserProfile(this.props.userId);\n    } else if (this.state.userData && !prevState.userData) {\n      console.log('User data loaded.');\n    }\n  }\n\n  // 6. componentWillUnmount()\n  componentWillUnmount() {\n    // Cleanup if any subscriptions/timers were here\n    console.log('UserProfile component unmounted.');\n  }\n\n  // 7. Event handlers\n  handleRefreshClick = () => {\n    this.fetchUserProfile(this.props.userId);\n  };\n\n  // 8. Getter methods for render\n  getDisplayUserName = () => {\n    return this.state.userData ? this.state.userData.name : 'N/A';\n  };\n\n  // 9. Optional render methods\n  renderLoading = () => {\n    if (this.state.isLoading) {\n      return <p>Loading user data...</p>;\n    }\n    return null;\n  };\n\n  renderError = () => {\n    if (this.state.error) {\n      return <p style={{ color: 'red' }}>Error: {this.state.error.message}</p>;\n    }\n    return null;\n  };\n\n  // 10. render()\n  render() {\n    const { userData } = this.state;\n    return (\n      <div className=\"user-profile-card\">\n        <h2>User Profile: {this.getDisplayUserName()}</h2>\n        {this.renderLoading()}\n        {this.renderError()}\n        {userData && !this.state.isLoading && (\n          <div>\n            <p>Email: {userData.email}</p>\n            <p>ID: {userData.id}</p>\n            <button onClick={this.handleRefreshClick}>Refresh Profile</button>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Helper method (private, not a lifecycle or event handler)\n  async fetchUserProfile(userId) {\n    this.setState({ isLoading: true, error: null });\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`); // Placeholder API\n      if (!response.ok) {\n        throw new Error(`Failed to fetch user ${userId}`);\n      }\n      const data = await response.json();\n      this.setState({ userData: data, isLoading: false });\n    } catch (error) {\n      this.setState({ error, isLoading: false, userData: null });\n    }\n  }\n}\n\n// Note: PropTypes requires 'prop-types' package\n// import PropTypes from 'prop-types';",
              "explanation": "This example demonstrates the recommended method ordering within a React class component. Methods are grouped logically, starting with static properties and the constructor, followed by lifecycle methods in their natural flow (mount, update, unmount), then event handlers, getter methods, optional render helpers, and finally the main `render` method. This structure enhances clarity and makes it easier for anyone reading the code to quickly locate specific functionalities.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_method_ordering_open_1",
            "question_method_ordering_mcq_1",
            "question_method_ordering_flashcard_1"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "best_practices",
            "code_style",
            "maintainability",
            "readability"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "specific_lifecycle_methods_detailed"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "professional_react_development",
            "team_collaboration"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lifecycle_phases_1",
          "topic": "React Component Lifecycle Phases",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following are the three main phases of a React component's lifecycle?",
          "answer": "Mounting, Updating, and Unmounting",
          "options": [
            "Initialization, Configuration, and Destruction",
            "Creation, Re-rendering, and Removal",
            "Mounting, Updating, and Unmounting",
            "Setup, Interaction, and Cleanup"
          ],
          "analysisPoints": [
            "Tests basic knowledge of React lifecycle terminology.",
            "Ensures understanding of the fundamental stages a component goes through."
          ],
          "keyConcepts": [
            "Mounting Phase",
            "Updating Phase",
            "Unmounting Phase",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct identification of the standard React lifecycle phases."
          ],
          "example": "The three main phases are Mounting (component created and inserted into DOM), Updating (component re-rendered due to prop/state changes), and Unmounting (component removed from DOM).",
          "tags": [
            "react",
            "lifecycle",
            "phases",
            "fundamentals",
            "mcq"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_flashcard_1",
          "topic": "React Component Lifecycle Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "What happens during the 'Mounting' phase of a React component's lifecycle?",
          "answer": "A component instance is created and inserted into the DOM for the first time.",
          "analysisPoints": [
            "Tests recall of the definition of the Mounting phase.",
            "Verifies understanding of initial component rendering."
          ],
          "keyConcepts": [
            "Mounting Phase",
            "DOM Insertion",
            "Initial Render"
          ],
          "evaluationCriteria": [
            "Ability to define the Mounting phase concisely."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "mounting",
            "flashcard"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_open_1",
          "topic": "React Component Lifecycle Phases",
          "level": "medium",
          "type": "open",
          "question": "Describe the primary difference between the 'Mounting' and 'Updating' phases of a React component. Provide a common use case for a lifecycle method in each phase.",
          "answer": "During the 'Mounting' phase, a component is created and inserted into the DOM for the very first time. A common use case is fetching initial data from an API in `componentDidMount`.\n\nIn contrast, the 'Updating' phase occurs when a component is re-rendered due to changes in its props or state after it has already been mounted. A common use case is re-fetching data when a specific prop changes in `componentDidUpdate`.",
          "analysisPoints": [
            "Tests ability to differentiate between lifecycle phases.",
            "Assesses knowledge of appropriate use cases for lifecycle methods in each phase.",
            "Encourages understanding of why each phase exists."
          ],
          "keyConcepts": [
            "Mounting Phase",
            "Updating Phase",
            "componentDidMount",
            "componentDidUpdate",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Clear distinction between phases.",
            "Relevant and correct examples of method usage.",
            "Demonstration of understanding of side effect placement."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "mounting",
            "updating",
            "componentDidMount",
            "componentDidUpdate",
            "open-ended"
          ],
          "prerequisites": [
            "theory_component_lifecycle_overview",
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deprecated_methods_1",
          "topic": "Deprecated React Lifecycle Methods",
          "level": "medium",
          "type": "open",
          "question": "Explain why `componentWillReceiveProps` was deprecated in React 16.3+ and what problems it commonly led to. What is its modern replacement, and how does it address these issues?",
          "answer": "`componentWillReceiveProps` was deprecated because it was often misused, leading to bugs and performance issues. Its main problems were:\n1.  **Frequent Calling:** It could be called multiple times for a single update, even if props hadn't semantically changed, leading to unnecessary re-renders or side effects.\n2.  **State Synchronization Issues:** Developers often updated state directly based on props here, which could lead to infinite loops or inconsistent state if not handled carefully, especially when also combined with internal state updates.\n3.  **Ambiguity with Async React:** It was problematic in React's async rendering model because it could run multiple times before a render was committed, making side effects unpredictable.\n\nThe modern replacement for deriving state from props is `static getDerivedStateFromProps(props, state)`. It addresses these issues by:\n1.  **Being Static:** It doesn't have access to `this`, preventing direct side effects or accidental state mutations outside its intended purpose.\n2.  **Pure Function:** It's a pure function that *only* returns an object to update state (or `null`). This makes its behavior predictable and avoids infinite loops.\n3.  **Clear Separation of Concerns:** It separates the logic for deriving state from props from other side effects (which belong in `componentDidUpdate`).",
          "analysisPoints": [
            "Tests understanding of deprecation rationale.",
            "Assesses knowledge of specific problems caused by legacy methods.",
            "Verifies awareness of modern replacements and their advantages.",
            "Requires explanation of `static` nature and `pure` function concept."
          ],
          "keyConcepts": [
            "componentWillReceiveProps",
            "static getDerivedStateFromProps",
            "Deprecation",
            "Pure Functions",
            "Side Effects",
            "State Synchronization"
          ],
          "evaluationCriteria": [
            "Accuracy of reasons for deprecation.",
            "Correct identification of replacement method.",
            "Thorough explanation of how the new method solves old problems."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "deprecated",
            "getDerivedStateFromProps",
            "state_management",
            "interview"
          ],
          "prerequisites": [
            "theory_legacy_lifecycle_methods",
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deprecated_methods_mcq_1",
          "topic": "Deprecated React Lifecycle Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the primary problem with using `componentWillMount` for side effects like data fetching?",
          "answer": "It can run multiple times if React pauses, aborts, or restarts a render, leading to inconsistencies.",
          "options": [
            "It blocks the main thread, causing UI freezes.",
            "It cannot access `this.props` or `this.state`.",
            "It can run multiple times if React pauses, aborts, or restarts a render, leading to inconsistencies.",
            "It is called after the component has been unmounted."
          ],
          "analysisPoints": [
            "Tests specific understanding of `componentWillMount`'s deprecation.",
            "Highlights the issue with side effects in render-phase methods.",
            "Distinguishes between correct and incorrect reasons for deprecation."
          ],
          "keyConcepts": [
            "componentWillMount",
            "Deprecated Methods",
            "Side Effects",
            "Async Rendering",
            "Render Phase"
          ],
          "evaluationCriteria": [
            "Correct identification of the core problem with `componentWillMount`."
          ],
          "example": "The core issue with `componentWillMount` is its placement in the 'render phase' which React can start and stop. If you initiate side effects here (like API calls or subscriptions), they might be duplicated or left in an inconsistent state if the render is aborted before being committed to the DOM. `componentDidMount` is the correct place as it's guaranteed to run only once after the component is fully mounted.",
          "tags": [
            "react",
            "lifecycle",
            "deprecated",
            "componentWillMount",
            "mcq"
          ],
          "prerequisites": [
            "theory_legacy_lifecycle_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deprecated_methods_flashcard_1",
          "topic": "Deprecated React Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Name two lifecycle methods that were deprecated in React 16.3+ and are now prefixed with `UNSAFE_`.",
          "answer": "Any two of: `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`.",
          "analysisPoints": [
            "Tests recall of specific deprecated methods.",
            "Verifies basic awareness of the `UNSAFE_` prefix."
          ],
          "keyConcepts": [
            "Deprecated Methods",
            "UNSAFE_ prefix",
            "React 16.3"
          ],
          "evaluationCriteria": [
            "Ability to list deprecated methods."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "deprecated",
            "flashcard"
          ],
          "prerequisites": [
            "theory_legacy_lifecycle_methods"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_modern_lifecycle_1",
          "topic": "Modern React Lifecycle Methods (React 16.3+)",
          "level": "hard",
          "type": "open",
          "question": "React 16.3+ introduced `getSnapshotBeforeUpdate` to replace certain use cases of `componentWillUpdate`. Explain its purpose, what it returns, and how its return value is utilized. Provide a concrete example of a scenario where `getSnapshotBeforeUpdate` is essential.",
          "answer": "`getSnapshotBeforeUpdate(prevProps, prevState)` is a lifecycle method called right before the changes from `render()` are committed to the DOM. Its purpose is to capture information from the DOM *before* it is potentially modified by React's update.\n\nIt returns a value, which will then be passed as the third argument (`snapshot`) to `componentDidUpdate(prevProps, prevState, snapshot)`.\n\n**Scenario Example:** Maintaining scroll position in a chat application or a dynamic list where new items are added to the top or bottom.\n\nLet's say you have a chat window, and new messages arrive. If you simply update the state with new messages, the scroll position might jump, or the user might lose their place. `getSnapshotBeforeUpdate` can be used to capture the current scroll height and position of the scrollable container *before* the new messages are added and the DOM updates. For instance, it can return `scrollHeight - scrollTop`. Then, in `componentDidUpdate`, you can use this `snapshot` value to adjust `scrollTop` back to maintain the user's view, ensuring they remain at the bottom (or wherever they were) as new messages appear.",
          "analysisPoints": [
            "Tests in-depth understanding of `getSnapshotBeforeUpdate`.",
            "Requires knowledge of its return value and interaction with `componentDidUpdate`.",
            "Demands a practical and detailed use case explanation.",
            "Assesses ability to connect theoretical concepts to real-world problems."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "DOM manipulation",
            "Scroll position",
            "Pre-commit Phase",
            "Lifecycle Interaction"
          ],
          "evaluationCriteria": [
            "Accurate description of purpose and mechanics.",
            "Clear and relevant example.",
            "Demonstration of understanding the flow between `getSnapshotBeforeUpdate` and `componentDidUpdate`."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "dom",
            "performance",
            "interview"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163",
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_modern_lifecycle_open_1",
          "topic": "React 16.3+ Lifecycle Phases",
          "level": "medium",
          "type": "open",
          "question": "React 16.3+ categorizes lifecycle methods into 'Render Phase', 'Pre-commit Phase', and 'Commit Phase'. Describe what characterizes each phase and provide one example method for each.",
          "answer": "1.  **Render Phase:**\n    *   **Characteristics:** Pure and has no side effects. Methods in this phase should only calculate the next state or JSX. React may pause, abort, or restart this phase multiple times.\n    *   **Example Method:** `render()` (or `static getDerivedStateFromProps()`, `constructor()`).\n\n2.  **Pre-commit Phase:**\n    *   **Characteristics:** Occurs right before React commits the changes to the actual DOM. Methods in this phase can read the DOM (e.g., measure scroll position) before updates are applied.\n    *   **Example Method:** `getSnapshotBeforeUpdate()`.\n\n3.  **Commit Phase:**\n    *   **Characteristics:** This is where React works with the actual DOM, applying all calculated changes. Methods here can run side effects (e.g., network requests, subscriptions, direct DOM manipulations) and are guaranteed to be called only once per update cycle after the DOM is updated.\n    *   **Example Method:** `componentDidMount()` (for initial side effects), `componentDidUpdate()` (for update-related side effects), or `componentWillUnmount()` (for cleanup).",
          "analysisPoints": [
            "Tests understanding of the new lifecycle categorization.",
            "Requires accurate description of each phase's purpose and constraints.",
            "Demands correct examples of methods fitting each phase."
          ],
          "keyConcepts": [
            "Render Phase",
            "Pre-commit Phase",
            "Commit Phase",
            "Pure Functions",
            "Side Effects",
            "DOM interaction"
          ],
          "evaluationCriteria": [
            "Correctly outlines characteristics of each phase.",
            "Provides accurate method examples for each phase."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "phases",
            "react16.3",
            "interview"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_modern_lifecycle_mcq_1",
          "topic": "Modern React Lifecycle Methods (React 16.3+)",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about `static getDerivedStateFromProps` is TRUE?",
          "answer": "It is a static method used to derive state from props, and it should return an object to update state or null.",
          "options": [
            "It has access to `this` and can perform side effects.",
            "It is called after the component has mounted and is ready for API calls.",
            "It is a static method used to derive state from props, and it should return an object to update state or null.",
            "It replaces `componentDidUpdate` for all state updates based on props."
          ],
          "analysisPoints": [
            "Tests understanding of `getDerivedStateFromProps`'s static nature.",
            "Verifies knowledge of its return value and purpose.",
            "Differentiates its role from `componentDidUpdate`."
          ],
          "keyConcepts": [
            "static getDerivedStateFromProps",
            "Static Methods",
            "State Derivation",
            "Side Effects",
            "Render Phase"
          ],
          "evaluationCriteria": [
            "Accurate identification of `getDerivedStateFromProps` characteristics."
          ],
          "example": "The key characteristic of `static getDerivedStateFromProps` is that it's static and cannot access `this`, meaning it can't perform side effects. Its only job is to return an object to update the component's state based on the new props and current state, or `null` if no state change is needed. It runs before `render` on both mount and update.",
          "tags": [
            "react",
            "lifecycle",
            "getDerivedStateFromProps",
            "state_management",
            "mcq"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_modern_lifecycle_mcq_2",
          "topic": "Error Boundaries",
          "level": "medium",
          "type": "mcq",
          "question": "To create a React Error Boundary that catches JavaScript errors in its child component tree and displays a fallback UI, which two lifecycle methods must you implement?",
          "answer": "`static getDerivedStateFromError` and `componentDidCatch`",
          "options": [
            "`componentDidMount` and `componentWillUnmount`",
            "`static getDerivedStateFromProps` and `componentDidUpdate`",
            "`static getDerivedStateFromError` and `componentDidCatch`",
            "`shouldComponentUpdate` and `render`"
          ],
          "analysisPoints": [
            "Tests knowledge of Error Boundary implementation.",
            "Requires identifying the specific methods used for error handling."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Error Handling",
            "static getDerivedStateFromError",
            "componentDidCatch"
          ],
          "evaluationCriteria": [
            "Correctly identifies the pair of methods required for Error Boundaries."
          ],
          "example": "Error Boundaries are special React components that implement `static getDerivedStateFromError(error)` to update state when an error occurs (to show fallback UI) and `componentDidCatch(error, info)` for side effects like logging the error.",
          "tags": [
            "react",
            "error_boundaries",
            "lifecycle",
            "mcq"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_modern_lifecycle_flashcard_1",
          "topic": "Modern React Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which new static lifecycle method was introduced in React 16.3 to replace `componentWillReceiveProps` for state derivation?",
          "answer": "`static getDerivedStateFromProps`",
          "analysisPoints": [
            "Tests direct recall of the modern replacement for a deprecated method.",
            "Focuses on a key change in React 16.3+."
          ],
          "keyConcepts": [
            "static getDerivedStateFromProps",
            "componentWillReceiveProps",
            "React 16.3",
            "State Derivation"
          ],
          "evaluationCriteria": [
            "Ability to name the specific replacement method."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "getDerivedStateFromProps",
            "flashcard"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_modern_lifecycle_flashcard_2",
          "topic": "React Lifecycle Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "In which React lifecycle phase are methods like `constructor()`, `static getDerivedStateFromProps()`, and `render()` executed? What is a key characteristic of this phase?",
          "answer": "Render Phase. Key characteristic: Pure and has no side effects; may be paused, aborted, or restarted by React.",
          "analysisPoints": [
            "Tests recall of methods associated with the Render Phase.",
            "Verifies understanding of the 'purity' requirement for the Render Phase."
          ],
          "keyConcepts": [
            "Render Phase",
            "Pure Functions",
            "constructor",
            "getDerivedStateFromProps",
            "render"
          ],
          "evaluationCriteria": [
            "Correctly identifies the phase and its main characteristic."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "render_phase",
            "flashcard"
          ],
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_mcq_1",
          "topic": "Specific Lifecycle Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```jsx\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: 'Initial Data' };\n  }\n\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({ data: 'Updated Data after Mount' });\n    }, 100);\n  }\n\n  render() {\n    return <div>{this.state.data}</div>;\n  }\n}\n```\n\nWhat will be the sequence of text displayed in the div element during the initial mount of `MyComponent`?",
          "answer": "Initial Data, then Updated Data after Mount",
          "options": [
            "Initial Data",
            "Updated Data after Mount",
            "Initial Data, then Updated Data after Mount",
            "Nothing, it will throw an error"
          ],
          "analysisPoints": [
            "Tests understanding of component rendering flow.",
            "Assesses knowledge of `constructor` and `componentDidMount` execution order.",
            "Confirms understanding of `setState` triggering re-renders."
          ],
          "keyConcepts": [
            "constructor",
            "componentDidMount",
            "setState",
            "Render",
            "Mounting Phase"
          ],
          "evaluationCriteria": [
            "Accurate prediction of UI rendering sequence based on lifecycle events."
          ],
          "example": "Initially, the `constructor` sets `data` to 'Initial Data', and `render` is called, displaying 'Initial Data'. After the component mounts, `componentDidMount` is called, which schedules a `setTimeout`. After 100ms, `setState` is called, which updates the `data` state, triggering a re-render, and then 'Updated Data after Mount' is displayed.",
          "tags": [
            "react",
            "lifecycle",
            "componentDidMount",
            "state",
            "rendering",
            "mcq"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_mcq_2",
          "topic": "Specific Lifecycle Methods",
          "level": "hard",
          "type": "mcq",
          "question": "Which lifecycle method is specifically designed for performance optimization by allowing you to control whether a component should re-render or not, based on changes in props and state?",
          "answer": "`shouldComponentUpdate`",
          "options": [
            "`componentDidUpdate`",
            "`render`",
            "`shouldComponentUpdate`",
            "`static getDerivedStateFromProps`"
          ],
          "analysisPoints": [
            "Tests knowledge of performance-related lifecycle methods.",
            "Checks understanding of `shouldComponentUpdate`'s specific role.",
            "Distinguishes `shouldComponentUpdate` from other methods that can impact performance (e.g., `render` or `getDerivedStateFromProps`'s efficiency)."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Re-rendering",
            "Lifecycle Control"
          ],
          "evaluationCriteria": [
            "Correctly identifies the method responsible for render control."
          ],
          "example": "The `shouldComponentUpdate(nextProps, nextState)` method returns a boolean. If it returns `false`, React will skip the re-rendering of the component and its children for that specific update, which can lead to significant performance improvements when dealing with complex or frequently updated component trees where not all changes necessitate a visual update.",
          "tags": [
            "react",
            "lifecycle",
            "shouldComponentUpdate",
            "performance",
            "optimization",
            "mcq"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_specific_lifecycle_open_1",
          "topic": "Specific Lifecycle Methods",
          "level": "medium",
          "type": "open",
          "question": "When would you typically use `componentWillUnmount()`? Provide at least three distinct types of operations or cleanup activities that are best performed in this method.",
          "answer": "`componentWillUnmount()` is typically used to perform cleanup operations right before a component is unmounted and destroyed from the DOM. It's crucial for preventing memory leaks and ensuring that resources are properly released.\n\nThree distinct types of operations/cleanup activities:\n1.  **Clearing timers:** Any `setTimeout` or `setInterval` that was initiated in `componentDidMount` should be cleared here to prevent them from continuing to run in the background after the component is gone.\n2.  **Canceling network requests:** If a component initiated a network request (e.g., an `fetch` or `axios` call) in `componentDidMount` or `componentDidUpdate`, and the component is unmounted before the request completes, the promise might resolve and try to update state on a non-existent component, leading to errors. Requests can be canceled using `AbortController`.\n3.  **Removing event listeners:** Any custom event listeners (e.g., `window.addEventListener`, `document.addEventListener`) or subscriptions to external services (like a Redux store or a WebSocket) that were set up in `componentDidMount` should be removed/unsubscribed here to avoid memory leaks and prevent callbacks on unmounted components.",
          "analysisPoints": [
            "Tests understanding of `componentWillUnmount`'s purpose.",
            "Requires specific examples of cleanup operations.",
            "Emphasizes the importance of preventing memory leaks."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "Cleanup",
            "Memory Leaks",
            "Timers",
            "Network Requests",
            "Event Listeners",
            "Subscriptions"
          ],
          "evaluationCriteria": [
            "Correct explanation of purpose.",
            "Provision of multiple, distinct, and appropriate cleanup examples.",
            "Understanding of the consequences of not performing cleanup."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "componentWillUnmount",
            "cleanup",
            "memory_management",
            "interview"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_code_1",
          "topic": "Specific Lifecycle Methods",
          "level": "medium",
          "type": "code",
          "question": "Implement a React class component named `TypingIndicator` that displays 'User is typing...' for 3 seconds after its `isTyping` prop changes from `false` to `true`. If `isTyping` changes back to `false` before 3 seconds, or the component unmounts, the indicator should hide immediately. Use appropriate lifecycle methods.",
          "answer": "```typescript\nimport React from 'react';\n\nclass TypingIndicator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      showIndicator: false\n    };\n    this.typingTimeout = null;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.isTyping && !prevProps.isTyping) {\n      // isTyping changed from false to true\n      this.setState({ showIndicator: true });\n      // Clear any existing timeout to avoid multiple indicators\n      if (this.typingTimeout) {\n        clearTimeout(this.typingTimeout);\n      }\n      // Set a new timeout to hide the indicator after 3 seconds\n      this.typingTimeout = setTimeout(() => {\n        this.setState({ showIndicator: false });\n        this.typingTimeout = null;\n      }, 3000);\n    } else if (!this.props.isTyping && prevProps.isTyping) {\n      // isTyping changed from true to false\n      // Immediately hide indicator and clear any pending timeout\n      if (this.typingTimeout) {\n        clearTimeout(this.typingTimeout);\n        this.typingTimeout = null;\n      }\n      this.setState({ showIndicator: false });\n    }\n  }\n\n  componentWillUnmount() {\n    // Clear timeout if component unmounts while indicator is visible\n    if (this.typingTimeout) {\n      clearTimeout(this.typingTimeout);\n      this.typingTimeout = null;\n    }\n  }\n\n  render() {\n    if (this.state.showIndicator) {\n      return <p>User is typing...</p>;\n    }\n    return null;\n  }\n}\n\n// Example Usage:\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { userTyping: false };\n//   }\n\n//   toggleTyping = () => {\n//     this.setState(prevState => ({ userTyping: !prevState.userTyping }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={this.toggleTyping}>\n//           {this.state.userTyping ? 'Stop Typing' : 'Start Typing'}\n//         </button>\n//         <TypingIndicator isTyping={this.state.userTyping} />\n//       </div>\n//     );\n//   }\n// }\n```",
          "analysisPoints": [
            "Tests ability to use `componentDidUpdate` for prop-triggered side effects.",
            "Assesses understanding of `setTimeout` and `clearTimeout` for timed actions.",
            "Verifies correct usage of `componentWillUnmount` for cleanup.",
            "Requires handling multiple state transitions and edge cases (clearing timeout)."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "componentWillUnmount",
            "setTimeout",
            "clearTimeout",
            "Side Effects",
            "Conditional Rendering",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correct implementation of `componentDidUpdate` logic.",
            "Proper cleanup in `componentWillUnmount`.",
            "Accurate management of the timer.",
            "Handles `isTyping` state changes correctly."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "componentDidUpdate",
            "componentWillUnmount",
            "timers",
            "code_challenge"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_flashcard_1",
          "topic": "Specific Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which lifecycle method is the ideal place to perform initial DOM manipulations or fetch data from an API after the component has rendered for the first time?",
          "answer": "`componentDidMount()`",
          "analysisPoints": [
            "Tests recall of the primary use case for `componentDidMount`.",
            "Focuses on side effects that require the component to be in the DOM."
          ],
          "keyConcepts": [
            "componentDidMount",
            "Mounting Phase",
            "Side Effects",
            "API Calls",
            "DOM Interaction"
          ],
          "evaluationCriteria": [
            "Correctly identifies the method for post-mount side effects."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "componentDidMount",
            "flashcard"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_specific_lifecycle_flashcard_2",
          "topic": "Specific Lifecycle Methods",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the return value of `shouldComponentUpdate`? What does returning `false` from this method signify?",
          "answer": "It returns a `boolean`. Returning `false` signifies that React should skip the re-rendering of this component and its children for the current update cycle.",
          "analysisPoints": [
            "Tests knowledge of `shouldComponentUpdate`'s return type.",
            "Verifies understanding of its effect on the rendering process."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Boolean Return",
            "Performance Optimization",
            "Re-rendering Control"
          ],
          "evaluationCriteria": [
            "Accurate description of return value and consequence."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "shouldComponentUpdate",
            "flashcard",
            "performance"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specific_lifecycle_flashcard_3",
          "topic": "Specific Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which lifecycle method is called exactly once after the component is first created and mounted, and is typically used for initializing local state and binding event handlers?",
          "answer": "`constructor(props)`",
          "analysisPoints": [
            "Tests recall of the earliest lifecycle method.",
            "Focuses on its primary responsibilities."
          ],
          "keyConcepts": [
            "constructor",
            "Initial State",
            "Binding Methods",
            "Mounting Phase"
          ],
          "evaluationCriteria": [
            "Correctly identifies the constructor's role and timing."
          ],
          "example": "",
          "tags": [
            "react",
            "lifecycle",
            "constructor",
            "flashcard"
          ],
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_method_ordering_open_1",
          "topic": "Consistent Method Ordering",
          "level": "medium",
          "type": "open",
          "question": "Why is it considered a best practice to follow a consistent method ordering within React class components? Provide at least two benefits this practice offers.",
          "answer": "Following a consistent method ordering within React class components is a best practice because it significantly improves code readability, maintainability, and collaboration.\n\n**Two benefits are:**\n1.  **Improved Readability and Understanding:** When developers know where to look for specific types of logic (e.g., lifecycle methods, event handlers, render helpers), they can quickly grasp the component's structure and behavior without having to search through disorganized code. This is particularly helpful in larger components or when onboarding new team members.\n2.  **Easier Maintenance and Debugging:** A predictable structure makes it simpler to locate and modify relevant code sections. When debugging, you can quickly trace the flow of execution or isolate issues to specific lifecycle phases or event handling logic, reducing the time spent on troubleshooting.",
          "analysisPoints": [
            "Tests understanding of code organization principles.",
            "Requires articulation of benefits beyond just 'good style'.",
            "Connects practice to real-world development advantages."
          ],
          "keyConcepts": [
            "Code Readability",
            "Maintainability",
            "Best Practices",
            "Code Organization",
            "Collaboration",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Clear and concise explanation of benefits.",
            "Demonstration of understanding the practical impact of code structure."
          ],
          "example": "",
          "tags": [
            "react",
            "best_practices",
            "code_style",
            "maintainability",
            "readability",
            "open-ended"
          ],
          "prerequisites": [
            "theory_method_ordering_best_practices"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_method_ordering_mcq_1",
          "topic": "Consistent Method Ordering",
          "level": "easy",
          "type": "mcq",
          "question": "According to best practices for method ordering in React class components, which group of methods should generally appear first?",
          "answer": "Static methods and properties",
          "options": [
            "Event handlers",
            "Lifecycle methods like `render()`",
            "Static methods and properties",
            "Getter methods for render"
          ],
          "analysisPoints": [
            "Tests recall of the recommended order.",
            "Focuses on the top-level grouping of methods."
          ],
          "keyConcepts": [
            "Method Ordering",
            "Best Practices",
            "Static Methods",
            "Class Properties"
          ],
          "evaluationCriteria": [
            "Correctly identifies the initial section of a well-ordered component."
          ],
          "example": "The recommended order often starts with static methods and properties (like `static getDerivedStateFromProps`, `defaultProps`, `propTypes`) because they are class-level and independent of instance-specific data or behavior, providing an overview of the component's setup.",
          "tags": [
            "react",
            "best_practices",
            "code_style",
            "mcq"
          ],
          "prerequisites": [
            "theory_method_ordering_best_practices"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_method_ordering_flashcard_1",
          "topic": "Consistent Method Ordering",
          "level": "easy",
          "type": "flashcard",
          "question": "In a well-structured React class component, where would you typically find the main `render()` method in the method ordering?",
          "answer": "Typically, the `render()` method is placed last, or near the end, after all other lifecycle methods, event handlers, and helper methods.",
          "analysisPoints": [
            "Tests recall of the `render` method's common placement.",
            "Reinforces the idea of `render` being the 'output' method."
          ],
          "keyConcepts": [
            "Method Ordering",
            "render()",
            "Code Structure"
          ],
          "evaluationCriteria": [
            "Correctly identifies the usual position of the `render` method."
          ],
          "example": "",
          "tags": [
            "react",
            "best_practices",
            "code_style",
            "flashcard"
          ],
          "prerequisites": [
            "theory_method_ordering_best_practices"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_data_fetching_component",
          "title": "Implement a Data Fetching and Display Component with Lifecycle Methods",
          "description": "\nCreate a React class component called `UserCard` that fetches user data from a placeholder API and displays it. The component should:\n\n1.  Fetch user data when it **mounts** using `componentDidMount`.\n2.  Display a 'Loading...' message while data is being fetched.\n3.  Display the user's name and email if the fetch is successful.\n4.  Display an error message if the fetch fails.\n5.  Include a `userId` prop. If this prop **changes**, the component should re-fetch the data for the new `userId` using `componentDidUpdate`.\n6.  Ensure any pending network requests are canceled if the `userId` changes or the component **unmounts**.\n\nUse `https://jsonplaceholder.typicode.com/users/{userId}` as your API endpoint. Assume `userId` will be a number from 1 to 10.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass UserCard extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true,\n      error: null\n    };\n    this.abortController = null; // For cancelling fetch requests\n  }\n\n  // TODO: Implement componentDidMount to fetch initial data\n\n  // TODO: Implement componentDidUpdate to re-fetch data if userId prop changes\n\n  // TODO: Implement componentWillUnmount to clean up any pending requests\n\n  fetchUserData = async (userId) => {\n    // Implement actual fetch logic here, use abortController\n    // ...\n  };\n\n  render() {\n    const { user, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '8px' }}>\n        <h3>User Details</h3>\n        <p><strong>Name:</strong> {user.name}</p>\n        <p><strong>Email:</strong> {user.email}</p>\n      </div>\n    );\n  }\n}\n\n// Example usage in a parent component (for testing):\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { currentUserId: 1 };\n//   }\n\n//   changeUser = () => {\n//     this.setState(prevState => ({ \n//       currentUserId: prevState.currentUserId < 10 ? prevState.currentUserId + 1 : 1\n//     }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={this.changeUser}>Next User ({this.state.currentUserId})</button>\n//         <UserCard userId={this.state.currentUserId} />\n//       </div>\n//     );\n//   }\n// }\n",
          "solutionCode": "import React from 'react';\n\nclass UserCard extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true,\n      error: null\n    };\n    this.abortController = null; // For cancelling fetch requests\n  }\n\n  componentDidMount() {\n    this.fetchUserData(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.userId !== prevProps.userId) {\n      // Cancel previous request if any\n      if (this.abortController) {\n        this.abortController.abort();\n      }\n      this.setState({ loading: true, error: null, user: null }); // Reset state for new fetch\n      this.fetchUserData(this.props.userId);\n    }\n  }\n\n  componentWillUnmount() {\n    // Cancel any pending request if the component unmounts\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n  }\n\n  fetchUserData = async (userId) => {\n    this.abortController = new AbortController();\n    const signal = this.abortController.signal;\n    try {\n      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`, { signal });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ user: data, loading: false });\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        console.log('Fetch aborted for user:', userId);\n        // Do not update state if the fetch was intentionally aborted\n      } else {\n        this.setState({ error: error, loading: false });\n      }\n    }\n  };\n\n  render() {\n    const { user, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '8px' }}>\n        <h3>User Details</h3>\n        <p><strong>Name:</strong> {user.name}</p>\n        <p><strong>Email:</strong> {user.email}</p>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "UserCard with userId=1 should display 'Leanne Graham' and 'Sincere@april.biz'.",
            "Changing userId from 1 to 2 should trigger a new fetch and display 'Ervin Howell'.",
            "Changing userId multiple times quickly should handle aborting previous requests correctly.",
            "UserCard with an invalid userId (e.g., 999) should display an error message.",
            "Unmounting the component while a fetch is in progress should cancel the request and not cause errors."
          ],
          "hints": [
            "Remember `componentDidMount` is for initial setup, `componentDidUpdate` for reactions to prop/state changes, and `componentWillUnmount` for cleanup.",
            "Use `AbortController` to cancel `fetch` requests. Create a new controller for each request and abort it in `componentDidUpdate` (if `userId` changes) and `componentWillUnmount`.",
            "Don't forget to reset loading and error states when a new fetch starts in `componentDidUpdate`."
          ],
          "tags": [
            "react",
            "lifecycle",
            "componentDidMount",
            "componentDidUpdate",
            "componentWillUnmount",
            "data_fetching",
            "api_integration",
            "cleanup",
            "async"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "fetch_api",
            "abort_controller",
            "side_effects",
            "state_management"
          ]
        },
        {
          "id": "task_performance_optimization_sCU",
          "title": "Optimize Component Re-renders with `shouldComponentUpdate`",
          "description": "\nCreate a `DisplayNumber` React class component that receives a `value` prop (a number) and displays it. The component should also maintain an internal `clickCount` state, which increments when a button inside the component is clicked.\n\nYour task is to optimize this component using `shouldComponentUpdate` such that:\n\n1.  The component **only re-renders** if the `value` prop changes OR the internal `clickCount` state changes.\n2.  It should NOT re-render if its parent component re-renders but passes the exact same `value` prop and the internal `clickCount` hasn't changed.\n\nInclude console logs within `render()` and `shouldComponentUpdate()` to demonstrate when they are called (or skipped).\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass DisplayNumber extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clickCount: 0 };\n  }\n\n  // TODO: Implement shouldComponentUpdate for optimization\n\n  incrementClick = () => {\n    this.setState(prevState => ({ clickCount: prevState.clickCount + 1 }));\n  };\n\n  render() {\n    console.log('DisplayNumber: render called');\n    return (\n      <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n        <h3>Display Number Component</h3>\n        <p>Prop Value: {this.props.value}</p>\n        <p>Internal Click Count: {this.state.clickCount}</p>\n        <button onClick={this.incrementClick}>Increment Internal Count</button>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing (no need to modify this)\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = {\n//       externalValue: 10,\n//       irrelevantParentState: 0\n//     };\n//   }\n\n//   componentDidMount() {\n//     // Simulate parent re-renders due to irrelevant state changes\n//     setInterval(() => {\n//       this.setState(prevState => ({\n//         irrelevantParentState: prevState.irrelevantParentState + 1\n//       }));\n//     }, 2000);\n//   }\n\n//   changeExternalValue = () => {\n//     this.setState(prevState => ({ externalValue: prevState.externalValue + 1 }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <h2>Parent Component</h2>\n//         <p>Parent Irrelevant State: {this.state.irrelevantParentState}</p>\n//         <button onClick={this.changeExternalValue}>Change External Value</button>\n//         <DisplayNumber value={this.state.externalValue} />\n//       </div>\n//     );\n//   }\n// }\n",
          "solutionCode": "import React from 'react';\n\nclass DisplayNumber extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clickCount: 0 };\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('DisplayNumber: shouldComponentUpdate called');\n    // Only re-render if 'value' prop changes OR 'clickCount' state changes\n    if (\n      nextProps.value !== this.props.value ||\n      nextState.clickCount !== this.state.clickCount\n    ) {\n      console.log('DisplayNumber: shouldComponentUpdate returns TRUE (re-render)');\n      return true;\n    }\n    console.log('DisplayNumber: shouldComponentUpdate returns FALSE (skip re-render)');\n    return false;\n  }\n\n  incrementClick = () => {\n    this.setState(prevState => ({ clickCount: prevState.clickCount + 1 }));\n  };\n\n  render() {\n    console.log('DisplayNumber: render called');\n    return (\n      <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n        <h3>Display Number Component</h3>\n        <p>Prop Value: {this.props.value}</p>\n        <p>Internal Click Count: {this.state.clickCount}</p>\n        <button onClick={this.incrementClick}>Increment Internal Count</button>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial mount: `render` should be called once.",
            "Clicking 'Increment Internal Count' button: `shouldComponentUpdate` should return `true`, then `render` should be called.",
            "Parent component re-rendering with the SAME `value` prop (e.g., due to `irrelevantParentState` changing): `shouldComponentUpdate` should be called, return `false`, and `render` should NOT be called.",
            "Parent component changing `externalValue` prop: `shouldComponentUpdate` should return `true`, then `render` should be called."
          ],
          "hints": [
            "`shouldComponentUpdate` receives `nextProps` and `nextState` as arguments.",
            "You need to compare `nextProps.value` with `this.props.value` and `nextState.clickCount` with `this.state.clickCount`.",
            "Remember that `shouldComponentUpdate` must return a boolean: `true` to re-render, `false` to skip."
          ],
          "tags": [
            "react",
            "lifecycle",
            "shouldComponentUpdate",
            "performance",
            "optimization",
            "code_challenge"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "pure_component",
            "memoization"
          ]
        },
        {
          "id": "task_scroll_position_sync",
          "title": "Maintain Scroll Position in a Dynamic List",
          "description": "\nCreate a `ChatWindow` React class component that simulates a chat application. It should display a list of messages. When new messages are added, the scroll position of the chat window should automatically adjust to keep the user at the bottom if they were already scrolled to the bottom before the update.\n\nUse `getSnapshotBeforeUpdate` to capture the necessary DOM information before the update, and `componentDidUpdate` to apply the scroll adjustment.\n\n**Requirements:**\n1.  The component should render a scrollable `div` containing messages.\n2.  Include a button to `Add New Message` to the list.\n3.  When new messages are added:\n    *   If the user was scrolled to the very bottom, keep them at the bottom.\n    *   If the user was scrolled up (not at the bottom), maintain their current view relative to the bottom (e.g., if they were 50px from the bottom, keep them 50px from the bottom).\n\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\nclass ChatWindow extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { messages: [] };\n    this.chatRef = React.createRef(); // Reference to the scrollable div\n  }\n\n  componentDidMount() {\n    // Simulate initial messages\n    this.setState({\n      messages: Array.from({ length: 15 }, (_, i) => `Initial Message ${i + 1}`)\n    });\n  }\n\n  // TODO: Implement getSnapshotBeforeUpdate\n\n  // TODO: Implement componentDidUpdate\n\n  addMessage = () => {\n    this.setState(prevState => ({\n      messages: [...prevState.messages, `New Message ${prevState.messages.length + 1}`]\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ padding: '20px' }}>\n        <div\n          ref={this.chatRef}\n          style={{\n            height: '300px',\n            overflowY: 'scroll',\n            border: '1px solid #ddd',\n            padding: '10px',\n            marginBottom: '10px'\n          }}\n        >\n          {this.state.messages.map((msg, index) => (\n            <p key={index} style={{ margin: '5px 0' }}>\n              {msg}\n            </p>\n          ))}\n        </div>\n        <button onClick={this.addMessage}>Add New Message</button>\n      </div>\n    );\n  }\n}\n",
          "solutionCode": "import React from 'react';\n\nclass ChatWindow extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { messages: [] };\n    this.chatRef = React.createRef(); // Reference to the scrollable div\n  }\n\n  componentDidMount() {\n    // Simulate initial messages\n    this.setState({\n      messages: Array.from({ length: 15 }, (_, i) => `Initial Message ${i + 1}`)\n    });\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    const chatElement = this.chatRef.current;\n    if (chatElement) {\n      // Check if we were scrolled to the bottom before the update\n      const isScrolledToBottom = \n        chatElement.scrollTop + chatElement.clientHeight >= chatElement.scrollHeight;\n      \n      // If new messages are being added, capture scroll info\n      if (this.state.messages.length > prevState.messages.length) {\n        return {\n          scrollHeight: chatElement.scrollHeight,\n          scrollTop: chatElement.scrollTop,\n          isScrolledToBottom: isScrolledToBottom\n        };\n      }\n    }\n    return null; // No snapshot needed\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (snapshot !== null) {\n      const chatElement = this.chatRef.current;\n      if (chatElement) {\n        // Calculate the difference in scroll height (due to new messages)\n        const scrollHeightDelta = chatElement.scrollHeight - snapshot.scrollHeight;\n        \n        if (snapshot.isScrolledToBottom) {\n          // If user was at the bottom, scroll them to the new bottom\n          chatElement.scrollTop = chatElement.scrollHeight;\n        } else {\n          // If user was scrolled up, maintain their relative position\n          chatElement.scrollTop = snapshot.scrollTop + scrollHeightDelta;\n        }\n      }\n    }\n  }\n\n  addMessage = () => {\n    this.setState(prevState => ({\n      messages: [...prevState.messages, `New Message ${prevState.messages.length + 1}`]\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ padding: '20px' }}>\n        <div\n          ref={this.chatRef}\n          style={{\n            height: '300px',\n            overflowY: 'scroll',\n            border: '1px solid #ddd',\n            padding: '10px',\n            marginBottom: '10px'\n          }}\n        >\n          {this.state.messages.map((msg, index) => (\n            <p key={index} style={{ margin: '5px 0' }}>\n              {msg}\n            </p>\n          ))}\n        </div>\n        <button onClick={this.addMessage}>Add New Message</button>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial render: Messages fill the scrollable area, scrollbar appears if content overflows.",
            "Add new messages when scrolled to the top: Scroll position should remain at the top.",
            "Add new messages when scrolled to the middle: Scroll position should remain relatively the same (relative to the old content).",
            "Add new messages when scrolled to the very bottom: Scroll position should jump to the new bottom (new messages become visible)."
          ],
          "hints": [
            "In `getSnapshotBeforeUpdate`, you'll need `this.chatRef.current.scrollHeight` (total height of content) and `this.chatRef.current.scrollTop` (current scroll position from top).",
            "To check if the user is at the bottom, compare `scrollTop + clientHeight` with `scrollHeight`. `clientHeight` is the visible height of the element.",
            "The value returned by `getSnapshotBeforeUpdate` will be the third argument (`snapshot`) to `componentDidUpdate`.",
            "In `componentDidUpdate`, if `snapshot` is not null, calculate the difference in `scrollHeight` between the previous and current state to adjust `scrollTop`."
          ],
          "tags": [
            "react",
            "lifecycle",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "dom_manipulation",
            "ux",
            "scroll",
            "code_challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_modern_lifecycle_react163",
            "theory_specific_lifecycle_methods_detailed"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "chat_application",
            "user_experience",
            "virtual_dom"
          ]
        },
        {
          "id": "task_error_boundary_implementation",
          "title": "Build a Reusable React Error Boundary Component",
          "description": "\nCreate a generic `ErrorBoundary` React class component that can catch JavaScript errors anywhere in its child component tree and display a fallback UI instead of crashing the entire application.\n\n**Requirements:**\n1.  The `ErrorBoundary` component should implement `static getDerivedStateFromError` to update its state when an error occurs.\n2.  It should implement `componentDidCatch` to log the error information (e.g., to the console or an external service).\n3.  If an error is caught, it should render a fallback message (e.g., \"Something went wrong.\").\n4.  If no error is caught, it should render its children normally.\n\nProvide a simple `BuggyComponent` that intentionally throws an error to demonstrate your `ErrorBoundary` in action.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  // TODO: Implement static getDerivedStateFromError\n\n  // TODO: Implement componentDidCatch\n\n  render() {\n    if (this.state.hasError) {\n      // Fallback UI when an error occurs\n      return (\n        <div style={{ border: '2px solid red', padding: '20px', margin: '20px', backgroundColor: '#ffe6e6' }}>\n          <h1>Oops! Something went wrong.</h1>\n          {/* Optional: display error details for debugging */}\n          {/* <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo && this.state.errorInfo.componentStack}\n          </details> */}\n        </div>\n      );\n    }\n\n    return this.props.children; // Render children normally if no error\n  }\n}\n\n// A component that will intentionally throw an error\nclass BuggyComponent extends React.Component {\n  render() {\n    if (this.props.shouldThrowError) {\n      throw new Error('I am a buggy component that crashed!');\n    }\n    return <p>This component is working fine.</p>;\n  }\n}\n\n// Example usage for testing:\n// class App extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { throwError: false };\n//   }\n\n//   toggleError = () => {\n//     this.setState(prevState => ({ throwError: !prevState.throwError }));\n//   };\n\n//   render() {\n//     return (\n//       <div>\n//         <button onClick={this.toggleError}>\n//           {this.state.throwError ? 'Reset Error' : 'Trigger Error'}\n//         </button>\n//         <ErrorBoundary>\n//           <BuggyComponent shouldThrowError={this.state.throwError} />\n//         </ErrorBoundary>\n//         <p>This part of the app should continue to work.</p>\n//       </div>\n//     );\n//   }\n// }\n",
          "solutionCode": "import React from 'react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true, error: error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    console.error(\"Error caught by Error Boundary:\", error, errorInfo);\n    this.setState({\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Fallback UI when an error occurs\n      return (\n        <div style={{ border: '2px solid red', padding: '20px', margin: '20px', backgroundColor: '#ffe6e6' }}>\n          <h1>Oops! Something went wrong.</h1>\n          {/* Optional: display error details for debugging */}\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo && this.state.errorInfo.componentStack}\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children; // Render children normally if no error\n  }\n}\n\n// A component that will intentionally throw an error\nclass BuggyComponent extends React.Component {\n  render() {\n    if (this.props.shouldThrowError) {\n      throw new Error('I am a buggy component that crashed!');\n    }\n    return <p>This component is working fine.</p>;\n  }\n}\n",
          "testCases": [
            "BuggyComponent `shouldThrowError=false`: ErrorBoundary should render BuggyComponent normally.",
            "BuggyComponent `shouldThrowError=true`: ErrorBoundary should catch the error and display its fallback UI. The console should show the logged error.",
            "Other components outside the ErrorBoundary should continue to function normally when an error is thrown inside.",
            "After an error, changing `shouldThrowError` back to `false` should reset the ErrorBoundary (by unmounting the old `BuggyComponent` instance and mounting a new one that doesn't throw)."
          ],
          "hints": [
            "`static getDerivedStateFromError(error)` is a static method and should return an object to update the state (e.g., `hasError: true`).",
            "`componentDidCatch(error, errorInfo)` is for side effects like logging. It receives the error and an object with `componentStack`.",
            "Remember that Error Boundaries only catch errors in their *descendant* components, not errors within themselves."
          ],
          "tags": [
            "react",
            "error_boundaries",
            "error_handling",
            "lifecycle",
            "getDerivedStateFromError",
            "componentDidCatch",
            "code_challenge"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_modern_lifecycle_react163"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "fault_tolerance",
            "application_stability",
            "logging"
          ]
        }
      ]
    }
  },
  {
    "id": "7179922c-a12a-4675-8c25-3dae01672c05",
    "startLine": 4400,
    "endLine": 4499,
    "processedDate": "2025-06-17T09:08:55.472Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_component_lifecycle_flow",
          "title": "React Component Lifecycle and Rendering Flow",
          "content": "Understanding the lifecycle of a React component is fundamental for building robust and efficient applications. A component goes through distinct phases: **mounting** (when it's first created and inserted into the DOM), **updating** (when its props or state change), and **unmounting** (when it's removed from the DOM). React provides special methods, called lifecycle methods, that allow developers to execute code at specific points in these phases.\n\n## Component Creation and Mounting Flow\n\n1.  **Component Definition**: This is the initial step where you define your React component, either as a class component or a functional component. For class components, this involves defining a class that extends `React.Component`.\n2.  **Component Usage**: The component is used within another component's `render` method or, for the root component, directly with `ReactDOM.render`.\n3.  **Instance Creation**: React creates an instance of the component's element. For class components, this is where `this.props` becomes accessible.\n4.  **Constructor Execution**: If a `constructor` method is defined in a class component, it is the *first* lifecycle method called. It's used for initializing state and binding event handlers.\n5.  **Virtual DOM Processing (Render)**: React calls the component's `render` method. This method returns a new React element tree (the Virtual DOM representation) that describes what the UI should look like.\n6.  **DOM Interaction (Mounting)**: For the initial render, React interacts with the browser's DOM to display the elements described by the Virtual DOM. This process is called \"mounting.\"\n7.  **`componentDidMount` Call**: After the component has been mounted and rendered to the actual DOM, `componentDidMount` is called. This is an ideal place for side effects like fetching data, setting up subscriptions, or interacting directly with the DOM.\n\n## Component Update Cycle\n\nWhen a component's props or state change, React initiates an update process:\n\n1.  **State/Prop Change**: The update cycle is triggered when `setState()` is called (either internally or from a parent component) or when a parent component re-renders and passes new props.\n2.  **Pre-Update Methods (`componentWillReceiveProps`, `getDerivedStateFromProps`)**: If props change, legacy class components would call `componentWillReceiveProps`. In modern React, `static getDerivedStateFromProps(nextProps, prevState)` is used. It's called right before `render` on every update and returns an object to update state, or `null` to update nothing. It should be a pure function.\n3.  **Update Decision (`shouldComponentUpdate`)**: React calls `shouldComponentUpdate(nextProps, nextState)`. This method returns a boolean indicating whether React should proceed with the update. It's a crucial optimization point; returning `false` prevents re-rendering of the component and its children, but can lead to stale UI if not used carefully.\n4.  **Pre-Rendering (`componentWillUpdate`, `getSnapshotBeforeUpdate`)**: If `shouldComponentUpdate` returns `true`, legacy class components would call `componentWillUpdate`. In newer React, `getSnapshotBeforeUpdate(prevProps, prevState)` is called right before the changes from the Virtual DOM are applied to the actual DOM. It returns a snapshot value (or `null`) that is passed to `componentDidUpdate`.\n5.  **Re-render**: The component's `render` method is called again to generate a new Virtual DOM tree based on the updated props/state.\n6.  **Diffing**: React performs a diffing algorithm, comparing the new Virtual DOM tree with the previous one. It identifies the minimal set of changes needed to update the actual DOM.\n7.  **DOM Update**: Only the necessary changes are applied to the actual DOM, optimizing performance.\n8.  **`componentDidUpdate` Call**: After the component has been updated and the changes have been flushed to the DOM, `componentDidUpdate(prevProps, prevState, snapshot)` is called. This is a good place to perform side effects after an update, such as network requests based on prop changes or interacting with the updated DOM. The `snapshot` value from `getSnapshotBeforeUpdate` is available here.\n\n## Component Unmounting Phase\n\nWhen a component is removed from the DOM (e.g., due to a conditional render, or its parent unmounting):\n\n1.  **`componentWillUnmount` Call**: Before the component is actually removed from the DOM, `componentWillUnmount()` is called. This is the ideal place to perform cleanup activities, such as invalidating timers, cancelling network requests, or removing event listeners that were set up in `componentDidMount`.\n\n",
          "examples": [
            {
              "id": "example_lifecycle_1",
              "title": "Basic Class Component with Lifecycle Methods",
              "code": "import React from 'react';\n\nclass LifecycleDemo extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('1. Constructor: Initializing state and binding methods.');\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('2. getDerivedStateFromProps: Called before render, returns state update.');\n    // Example: Update state based on props\n    if (nextProps.initialCount && nextProps.initialCount !== prevState.count) {\n      return { count: nextProps.initialCount };\n    }\n    return null; // No state update needed\n  }\n\n  componentDidMount() {\n    console.log('4. componentDidMount: Component mounted to DOM. Good for data fetching.');\n    this.timer = setInterval(() => {\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n    }, 1000);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(`5. shouldComponentUpdate: Current count ${this.state.count}, Next count ${nextState.count}.`);\n    // Only update if count changes\n    return nextState.count !== this.state.count;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('6. getSnapshotBeforeUpdate: Called right before DOM updates.');\n    // Example: Capture scroll position before update\n    return 'captured snapshot';\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log(`8. componentDidUpdate: Component updated. Snapshot: ${snapshot}`);\n    console.log(`   Previous state: ${prevState.count}, Current state: ${this.state.count}`);\n  }\n\n  componentWillUnmount() {\n    console.log('9. componentWillUnmount: Cleanup before component unmounts.');\n    clearInterval(this.timer);\n  }\n\n  render() {\n    console.log('3 & 7. Render: Building the Virtual DOM.');\n    return (\n      <div>\n        <h2>Lifecycle Demo</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState({ count: this.state.count + 10 })}>Add 10 (Manual Update)</button>\n      </div>\n    );\n  }\n}\n\nexport default LifecycleDemo;",
              "explanation": "This example demonstrates a class component integrating various lifecycle methods. The console logs illustrate the order of execution for mounting and updating phases. `constructor` initializes state. `getDerivedStateFromProps` potentially updates state based on new props. `componentDidMount` sets up a timer. `shouldComponentUpdate` provides a performance optimization. `getSnapshotBeforeUpdate` captures information before DOM updates. `componentDidUpdate` acts after DOM updates. `componentWillUnmount` performs cleanup.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_lifecycle_1",
            "question_lifecycle_2",
            "question_lifecycle_3",
            "question_lifecycle_4",
            "question_lifecycle_5",
            "question_lifecycle_6",
            "question_lifecycle_7",
            "question_lifecycle_8"
          ],
          "relatedTasks": [
            "task_lifecycle_component_management"
          ],
          "tags": [
            "React",
            "Component Lifecycle",
            "Mounting",
            "Updating",
            "Unmounting",
            "Class Components"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Basics",
            "ES6 Classes",
            "React Basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "State Management",
            "Performance Optimization",
            "Side Effects in React"
          ]
        },
        {
          "id": "theory_state_reconciliation",
          "title": "React State Updates and Reconciliation Process",
          "content": "State is a core concept in React that allows components to maintain and manage their own data. When a component's state changes, React efficiently updates the UI through a process called **reconciliation**.\n\n## State Updates with `setState()`\n\nWhen you call `this.setState()`, React initiates a series of steps:\n\n1.  **State Merging**: React merges the object you passed into `setState()` with the component's current state. This means `setState()` performs a shallow merge; it doesn't replace the entire state object, but rather updates the properties you specify.\n2.  **Asynchronous Nature**: `setState()` calls are asynchronous. React may batch multiple `setState()` calls into a single update for performance reasons. This means that if you log `this.state` immediately after calling `setState()`, you might not see the updated value.\n3.  **Functional `setState` for Reliability**: For updates that depend on the previous state or props, it is crucial to use the functional form of `setState`. This form receives the `prevState` and `props` as arguments, ensuring you are always working with the most up-to-date values, especially when multiple updates are batched.\n    ```javascript\n    this.setState(prevState => {\n      return { count: prevState.count + 1 };\n    });\n    \n    // Or with props\n    this.setState((prevState, props) => {\n      return { counter: prevState.counter + props.step };\n    });\n    ```\n4.  **Callback Function**: `setState()` accepts an optional callback function as its second argument. This function executes *after* the state has been updated and the component has been re-rendered. It's useful for performing actions that rely on the updated state.\n    ```javascript\n    this.setState({ data: [1, 2, 3] }, () => {\n      console.log('State updated and component re-rendered:', this.state.data);\n    });\n    ```\n5.  **Preventing Unnecessary Updates**: You can prevent state updates (and thus re-renders) by returning `null` from the functional `setState` if the new state is identical to the current state, or by using `shouldComponentUpdate`.\n    ```javascript\n    this.setState(state => {\n      if (state.address === latestAddress) {\n        return null; // No update needed, prevents re-render\n      } else {\n        return { address: latestAddress };\n      }\n    });\n    ```\n\n## Reconciliation Process\n\nReconciliation is the algorithm React uses to update the browser's DOM. It's React's way of efficiently responding to changes in state or props without re-rendering the entire page. Here's how it works:\n\n1.  **New Virtual DOM Tree**: When `setState()` is called (or new props are received), React constructs a new tree of React elements (Virtual DOM) that represents the desired UI based on the new state/props.\n2.  **Diffing Algorithm**: React then compares this new Virtual DOM tree with the previous one. This comparison process is called \"diffing.\"\n    *   **Element Type**: If the root elements have different types (e.g., `<div>` to `<span>`), React tears down the old tree and builds the new one from scratch.\n    *   **Keys**: When reconciling children elements, React uses `key` props to identify which items have changed, been added, or removed. Keys should be stable and unique among siblings.\n    *   **Attributes/Props**: For elements of the same type, React compares attributes/props and only updates what has changed in the actual DOM.\n3.  **Minimal DOM Operations**: Based on the diffing result, React calculates the minimal set of changes (additions, deletions, updates) required to make the actual DOM reflect the new Virtual DOM. This optimization is key to React's performance.\n4.  **Actual DOM Update**: Finally, React applies only these necessary changes to the actual browser DOM, making it very efficient.\n\nThis entire process ensures that React only touches the parts of the DOM that absolutely need to change, minimizing expensive DOM manipulations.",
          "examples": [
            {
              "id": "example_state_1",
              "title": "Asynchronous setState and Functional Form",
              "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  // Demonstrates asynchronous nature\n  handleBadIncrement = () => {\n    this.setState({ count: this.state.count + 1 });\n    console.log('After setState (may not be updated):', this.state.count); // Logs old value\n  }\n\n  // Demonstrates functional setState for reliability\n  handleGoodIncrement = () => {\n    this.setState(prevState => {\n      console.log('Inside functional setState (prevState):', prevState.count);\n      return { count: prevState.count + 1 };\n    });\n    console.log('After functional setState (still may be old value outside):', this.state.count); // Logs old value\n  }\n\n  // Demonstrates setState with callback\n  handleIncrementWithCallback = () => {\n    this.setState(\n      prevState => ({ count: prevState.count + 1 }),\n      () => {\n        console.log('Callback fired (state is updated):', this.state.count);\n      }\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Counter: {this.state.count}</h3>\n        <button onClick={this.handleBadIncrement}>Bad Increment (Async)</button>\n        <button onClick={this.handleGoodIncrement}>Good Increment (Functional)</button>\n        <button onClick={this.handleIncrementWithCallback}>Increment with Callback</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;",
              "explanation": "This example showcases the different ways to use `setState`. `handleBadIncrement` illustrates the asynchronous nature, where `console.log` immediately after `setState` might show an outdated value. `handleGoodIncrement` uses the functional form, which is crucial for updates based on `prevState` to avoid race conditions. `handleIncrementWithCallback` demonstrates how to execute code reliably after the state update and re-render have completed.",
              "language": "typescript"
            },
            {
              "id": "example_state_2",
              "title": "Preventing Redundant Updates with Functional setState",
              "code": "import React from 'react';\n\nclass DataDisplay extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { dataVersion: 0, content: 'Initial Content' };\n  }\n\n  updateContent = (newContent) => {\n    this.setState(prevState => {\n      // Only update if newContent is actually different\n      if (prevState.content === newContent) {\n        console.log('Content is the same, no update needed.');\n        return null; // Prevents state update and re-render\n      }\n      console.log('Content changed, updating state.');\n      return { content: newContent, dataVersion: prevState.dataVersion + 1 };\n    });\n  }\n\n  render() {\n    console.log('Rendered DataDisplay. Version:', this.state.dataVersion);\n    return (\n      <div>\n        <p>{this.state.content}</p>\n        <button onClick={() => this.updateContent('Updated Content')}>Update Content</button>\n        <button onClick={() => this.updateContent('Initial Content')}>Set Initial Content</button>\n      </div>\n    );\n  }\n}\n\nexport default DataDisplay;",
              "explanation": "This example demonstrates how to use the functional `setState` to conditionally prevent a state update. By checking if `newContent` is the same as `prevState.content` and returning `null` from the functional `setState` callback, we avoid unnecessary state changes and subsequent re-renders, optimizing performance. The `render` method's `console.log` will only fire when an actual update occurs.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_state_1",
            "question_state_2",
            "question_state_3",
            "question_state_4",
            "question_state_5",
            "question_state_6",
            "question_state_7"
          ],
          "relatedTasks": [
            "task_state_counter_management",
            "task_reconciliation_optimization"
          ],
          "tags": [
            "React",
            "State Management",
            "setState",
            "Reconciliation",
            "Virtual DOM",
            "Performance",
            "Asynchronous",
            "Functional setState"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Closures",
            "React Basics"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "Debugging React Apps",
            "Building Interactive UIs",
            "Optimizing React Performance"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lifecycle_1",
          "topic": "React Component Mounting Phase",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following lifecycle methods is called *after* a React component has been mounted and rendered to the actual DOM?",
          "answer": "componentDidMount",
          "options": [
            "constructor",
            "render",
            "componentDidMount",
            "componentWillUnmount"
          ],
          "analysisPoints": [
            "Identifies the correct lifecycle method for post-mount operations.",
            "Distinguishes `componentDidMount` from methods called earlier (constructor, render) or later (componentWillUnmount)."
          ],
          "keyConcepts": [
            "Component Lifecycle",
            "Mounting Phase",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental lifecycle phases."
          ],
          "example": "The `componentDidMount` method is the ideal place to perform side effects that require the component to be fully rendered in the DOM, such as fetching data from an API, setting up subscriptions, or directly manipulating the DOM using third-party libraries.",
          "tags": [
            "React",
            "Lifecycle",
            "Mounting",
            "componentDidMount"
          ],
          "prerequisites": [
            "React Component Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_2",
          "topic": "React Component Unmounting Phase",
          "level": "medium",
          "type": "mcq",
          "question": "You have a React component that sets up a global event listener in `componentDidMount`. Which lifecycle method should you use to clean up this event listener to prevent memory leaks?",
          "answer": "componentWillUnmount",
          "options": [
            "componentDidUpdate",
            "render",
            "componentWillUnmount",
            "constructor"
          ],
          "analysisPoints": [
            "Tests knowledge of proper cleanup practices in React lifecycle.",
            "Highlights the purpose of `componentWillUnmount`."
          ],
          "keyConcepts": [
            "Component Lifecycle",
            "Unmounting Phase",
            "Memory Leaks",
            "Cleanup"
          ],
          "evaluationCriteria": [
            "Ability to apply lifecycle methods for resource management.",
            "Understanding of common pitfalls like memory leaks."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    // Set up event listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    // Clean up event listener\n    window.removeEventListener('resize', this.handleResize);\n  }\n\n  handleResize = () => {\n    console.log('Window resized!');\n  };\n\n  render() {\n    return <div>My Component</div>;\n  }\n}\n```\n`componentWillUnmount` is the last method called before a component is removed from the DOM, making it the perfect place to clean up any subscriptions, timers, or event listeners initiated during the component's lifetime to prevent memory leaks.",
          "tags": [
            "React",
            "Lifecycle",
            "Unmounting",
            "componentWillUnmount",
            "Memory Leaks",
            "Cleanup"
          ],
          "prerequisites": [
            "Event Listeners",
            "React Component Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_3",
          "topic": "Optimizing React Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which lifecycle method is crucial for performance optimization in class components by allowing you to control whether a component re-renders?",
          "answer": "shouldComponentUpdate",
          "options": [
            "componentDidMount",
            "componentDidUpdate",
            "render",
            "shouldComponentUpdate"
          ],
          "analysisPoints": [
            "Identifies the key method for preventing unnecessary re-renders.",
            "Differentiates it from methods that always trigger during updates."
          ],
          "keyConcepts": [
            "Component Lifecycle",
            "Performance Optimization",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Understanding of performance best practices in React.",
            "Knowledge of how to control component updates."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass OptimizedComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'value' prop has changed\n    if (this.props.value !== nextProps.value) {\n      return true;\n    }\n    return false; // Prevent re-render\n  }\n\n  render() {\n    console.log('OptimizedComponent rendered');\n    return <div>Value: {this.props.value}</div>;\n  }\n}\n```\n`shouldComponentUpdate` allows you to define a condition under which the component should re-render. If it returns `false`, `render` and `componentDidUpdate` will not be called for that update cycle, effectively skipping the re-render. This is a powerful tool for performance optimization, especially for components that receive frequent prop or state changes but whose rendered output doesn't always need to change.",
          "tags": [
            "React",
            "Lifecycle",
            "Performance",
            "Optimization",
            "shouldComponentUpdate"
          ],
          "prerequisites": [
            "React Component Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_4",
          "topic": "React Lifecycle Method Order",
          "level": "hard",
          "type": "open",
          "question": "Describe the complete sequence of lifecycle methods (constructor, render, componentDidMount, getDerivedStateFromProps, shouldComponentUpdate, getSnapshotBeforeUpdate, componentDidUpdate, componentWillUnmount) called during the *initial mounting* of a class component and during a subsequent *update* triggered by new props. Clearly state the purpose of each method in the context of its execution.",
          "answer": "N/A",
          "analysisPoints": [
            "Tests comprehensive understanding of the React lifecycle.",
            "Requires accurate recall of method order for both mounting and updating.",
            "Demands concise explanation of each method's role.",
            "Checks for distinction between legacy and modern lifecycle methods (though not explicitly asked, a good answer would hint at it)."
          ],
          "keyConcepts": [
            "Component Lifecycle",
            "Mounting Phase",
            "Updating Phase",
            "Lifecycle Method Order",
            "Side Effects",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Accuracy of lifecycle method order.",
            "Clarity and correctness of purpose descriptions.",
            "Completeness of coverage for both mounting and updating."
          ],
          "example": "### Initial Mounting Phase:\n1.  **`constructor(props)`**: Called first. Used for initializing `state` and binding event handlers. `super(props)` must be called.\n2.  **`static getDerivedStateFromProps(nextProps, prevState)`**: Called before `render`. Used to update state based on props changes. Returns an object to update state or `null`.\n3.  **`render()`**: Called to create the component's Virtual DOM representation. Should be a pure function.\n4.  **React updates DOM**: React performs the actual DOM manipulation.\n5.  **`componentDidMount()`**: Called after the component has been mounted to the DOM. Ideal for side effects like data fetching, subscriptions, or direct DOM manipulation.\n\n### Update Triggered by New Props (assuming `shouldComponentUpdate` returns `true`):\n1.  **`static getDerivedStateFromProps(nextProps, prevState)`**: Called again before `render` due to new props. Updates state based on new props.\n2.  **`shouldComponentUpdate(nextProps, nextState)`**: Called to determine if the component should re-render. Returns `true` to proceed, `false` to skip.\n3.  **`render()`**: Called again to generate a new Virtual DOM.\n4.  **`getSnapshotBeforeUpdate(prevProps, prevState)`**: Called right before the changes are applied to the actual DOM. It can capture information (e.g., scroll position) from the DOM before it's updated. The return value is passed as the third argument to `componentDidUpdate`.\n5.  **React updates DOM**: React applies the diffed changes to the actual DOM.\n6.  **`componentDidUpdate(prevProps, prevState, snapshot)`**: Called after the component has been updated and re-rendered. Good for side effects that need access to the updated DOM or previous state/props.",
          "tags": [
            "React",
            "Lifecycle",
            "Mounting",
            "Updating",
            "Interview Question",
            "Advanced"
          ],
          "prerequisites": [
            "React Lifecycle Methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifecycle_5",
          "topic": "Lifecycle Method Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `render()` method in a React class component?",
          "answer": "To return the React elements (Virtual DOM) that represent the component's UI.",
          "analysisPoints": [
            "Tests recall of the core function of `render`."
          ],
          "keyConcepts": [
            "Component Rendering",
            "Virtual DOM"
          ],
          "evaluationCriteria": [
            "Basic understanding of component structure."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Lifecycle",
            "Render",
            "Flashcard"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_6",
          "topic": "Legacy vs. Modern Lifecycle",
          "level": "medium",
          "type": "open",
          "question": "What is the modern replacement for `componentWillReceiveProps` and `componentWillUpdate` in React class components, and what advantages do they offer?",
          "answer": "N/A",
          "analysisPoints": [
            "Tests knowledge of modern React lifecycle practices.",
            "Requires understanding of why legacy methods were deprecated.",
            "Evaluates ability to explain advantages of new methods (purity, snapshot capability)."
          ],
          "keyConcepts": [
            "Lifecycle Methods",
            "Deprecation",
            "Purity",
            "Snapshot",
            "getDerivedStateFromProps",
            "getSnapshotBeforeUpdate"
          ],
          "evaluationCriteria": [
            "Understanding of React's evolution.",
            "Ability to articulate reasons for design changes."
          ],
          "example": "`componentWillReceiveProps` is replaced by `static getDerivedStateFromProps(nextProps, prevState)`. This new static method is safer because it's pure and only used for state derivation, preventing side effects. `componentWillUpdate` is replaced by `getSnapshotBeforeUpdate(prevProps, prevState)`. This method is called right before the DOM is updated, allowing the component to capture information (e.g., scroll position) from the DOM before changes are applied, which can then be used in `componentDidUpdate`.",
          "tags": [
            "React",
            "Lifecycle",
            "Deprecation",
            "Modern React",
            "getDerivedStateFromProps",
            "getSnapshotBeforeUpdate"
          ],
          "prerequisites": [
            "React Lifecycle Methods",
            "Static Methods"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifecycle_7",
          "topic": "Lifecycle Method Timing",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React class component:\n\n```typescript\nimport React from 'react';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('Constructor Called');\n  }\n\n  componentDidMount() {\n    console.log('componentDidMount Called');\n    this.setState({ count: 1 });\n  }\n\n  componentDidUpdate() {\n    console.log('componentDidUpdate Called');\n  }\n\n  render() {\n    console.log('Render Called');\n    return <div>Count: {this.state.count}</div>;\n  }\n}\n\nexport default App;\n```\n\nWhat will be the exact sequence of console logs when this component is initially mounted?",
          "answer": "Constructor Called, Render Called, componentDidMount Called, Render Called, componentDidUpdate Called",
          "options": [
            "Constructor Called, componentDidMount Called, Render Called, componentDidUpdate Called",
            "Constructor Called, Render Called, componentDidMount Called",
            "Constructor Called, Render Called, componentDidMount Called, Render Called, componentDidUpdate Called",
            "Constructor Called, Render Called, componentDidUpdate Called, componentDidMount Called"
          ],
          "analysisPoints": [
            "Tests understanding of the mounting and initial update cycle triggered by `setState` in `componentDidMount`.",
            "Requires knowledge of `setState` causing a re-render and subsequent `componentDidUpdate` call."
          ],
          "keyConcepts": [
            "Component Lifecycle Order",
            "setState Triggering Update",
            "Mounting Phase"
          ],
          "evaluationCriteria": [
            "Accurate prediction of lifecycle method execution flow.",
            "Understanding of side effects of `setState`."
          ],
          "example": "1.  **Constructor Called**: The `constructor` is the first method called during instantiation.\n2.  **Render Called**: The `render` method is called to generate the initial Virtual DOM.\n3.  **componentDidMount Called**: After the component is mounted to the actual DOM, `componentDidMount` is called. Inside this method, `this.setState({ count: 1 })` is called.\n4.  **Render Called**: The `setState` call triggers an update. React re-renders the component with the new state.\n5.  **componentDidUpdate Called**: After the update (including the second render) is applied to the DOM, `componentDidUpdate` is called.",
          "tags": [
            "React",
            "Lifecycle",
            "Mounting",
            "Update",
            "setState",
            "Order"
          ],
          "prerequisites": [
            "React Lifecycle Methods",
            "React State"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_8",
          "topic": "Virtual DOM and DOM Interaction",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the term for the process where React communicates with the browser to display the element for the first time?",
          "answer": "Mounting",
          "analysisPoints": [
            "Tests recall of key terminology related to initial rendering."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Real DOM",
            "Mounting"
          ],
          "evaluationCriteria": [
            "Knowledge of basic React rendering concepts."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "DOM",
            "Mounting",
            "Virtual DOM",
            "Flashcard"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_1",
          "topic": "setState Asynchronous Behavior",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code snippet:\n\n```typescript\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  state = { count: 0 };\n\n  handleClick = () => {\n    this.setState({ count: this.state.count + 1 });\n    console.log(this.state.count); // Line A\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n}\n```\n\nIf the initial `count` is 0, what value will `console.log(this.state.count)` on Line A likely display immediately after the button is clicked for the first time?",
          "answer": "0",
          "options": [
            "0",
            "1",
            "Undefined",
            "It depends on React's batching"
          ],
          "analysisPoints": [
            "Tests understanding of `setState`'s asynchronous nature.",
            "Highlights the common pitfall of relying on `this.state` immediately after a `setState` call."
          ],
          "keyConcepts": [
            "setState",
            "Asynchronous Operations",
            "State Updates"
          ],
          "evaluationCriteria": [
            "Ability to predict output based on `setState` behavior.",
            "Understanding of React's internal update mechanisms."
          ],
          "example": "Because `setState` is asynchronous and React may batch updates for performance, `this.state.count` inside `handleClick` will often reflect the value *before* the `setState` call has been processed and the component has re-rendered. The updated value will only be reliably available in subsequent renders, in `componentDidUpdate`, or within the `setState` callback function.",
          "tags": [
            "React",
            "State",
            "setState",
            "Asynchronous",
            "Interview Question"
          ],
          "prerequisites": [
            "React State Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_2",
          "topic": "Functional setState",
          "level": "medium",
          "type": "mcq",
          "question": "When should you use the functional form of `setState` (i.e., `this.setState(prevState => { ... })`) instead of passing an object directly?",
          "answer": "When the new state depends on the previous state or props.",
          "options": [
            "Always, it's a best practice.",
            "When the state update is simple and doesn't depend on previous state.",
            "When the new state depends on the previous state or props.",
            "Only when you need to use a callback function."
          ],
          "analysisPoints": [
            "Identifies the primary use case for functional `setState`.",
            "Distinguishes it from direct object passing for independent updates."
          ],
          "keyConcepts": [
            "setState",
            "Functional setState",
            "Previous State",
            "Reliable Updates"
          ],
          "evaluationCriteria": [
            "Understanding of safe state update practices.",
            "Knowledge of handling batched updates correctly."
          ],
          "example": "```typescript\nthis.setState(prevState => {\n  // Correctly increments count based on the latest state, even if batched\n  return { count: prevState.count + 1 };\n});\n```\nUsing the functional form of `setState` ensures that you are working with the most up-to-date `prevState` and `props` values, even if React batches multiple `setState` calls. This prevents race conditions and ensures predictable state updates, especially for operations like incrementing a counter or toggling a boolean.",
          "tags": [
            "React",
            "State",
            "setState",
            "Functional setState",
            "Best Practices"
          ],
          "prerequisites": [
            "React State Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_3",
          "topic": "React Reconciliation",
          "level": "hard",
          "type": "open",
          "question": "Explain the concept of React's reconciliation process. Include details about the Virtual DOM, diffing algorithm, and how React optimizes actual DOM updates.",
          "answer": "N/A",
          "analysisPoints": [
            "Tests a deep understanding of React's core rendering mechanism.",
            "Requires explanation of Virtual DOM as an abstraction.",
            "Demands description of the diffing algorithm's role and its optimizations (element type, keys).",
            "Evaluates knowledge of how actual DOM updates are minimized."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Virtual DOM",
            "Diffing Algorithm",
            "DOM Manipulation",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of explanation.",
            "Clarity of technical concepts.",
            "Ability to connect different parts of the process."
          ],
          "example": "React's reconciliation is the process by which React updates the browser's DOM to match the latest state or props of your components. It does this by:\n\n1.  **Virtual DOM**: React maintains an in-memory representation of the UI called the Virtual DOM. When `setState` is called or new props are received, React generates a *new* Virtual DOM tree.\n2.  **Diffing Algorithm**: React then compares this new Virtual DOM tree with the previous one. This comparison, or \"diffing,\" is the core of reconciliation. React uses a heuristic algorithm to efficiently find differences:\n    *   **Different Element Types**: If the root elements have different types (e.g., `<div>` vs. `<span>`), React destroys the old component tree and builds a new one from scratch, discarding its state.\n    *   **Same Element Type**: If elements are of the same type, React looks at their attributes (props). Only attributes that have changed are updated on the real DOM.\n    *   **Lists and Keys**: For lists of elements, React uses the `key` prop to identify which items have changed, been added, or removed. Without stable keys, React might re-render the entire list or perform inefficient updates.\n3.  **Minimal DOM Operations**: After identifying the differences, React calculates the most efficient way to update the actual DOM. It batches multiple updates together to reduce expensive DOM manipulation operations.\n4.  **Actual DOM Update**: Finally, React applies only these necessary, optimized changes to the real browser DOM. This minimal direct DOM manipulation is why React is often perceived as fast, as it avoids direct, frequent manipulation of the costly browser DOM.",
          "tags": [
            "React",
            "Reconciliation",
            "Virtual DOM",
            "Diffing",
            "Performance",
            "Interview Question",
            "Advanced"
          ],
          "prerequisites": [
            "React State",
            "DOM Basics"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_state_4",
          "topic": "setState Callback",
          "level": "easy",
          "type": "flashcard",
          "question": "When does the callback function passed to `setState()` execute?",
          "answer": "After the state has been updated and the component has re-rendered.",
          "analysisPoints": [
            "Tests recall of `setState` callback timing."
          ],
          "keyConcepts": [
            "setState Callback",
            "Asynchronous State",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Basic understanding of `setState` functionality."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "State",
            "setState",
            "Callback",
            "Flashcard"
          ],
          "prerequisites": [
            "React State Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_5",
          "topic": "State Merging",
          "level": "medium",
          "type": "mcq",
          "question": "You have a component state `{ name: 'Alice', age: 30 }`. If you call `this.setState({ age: 31 })`, what will the state object be after the update?",
          "answer": "{ name: 'Alice', age: 31 }",
          "options": [
            "{ age: 31 }",
            "{ name: 'Alice', age: 31 }",
            "Undefined",
            "The state will not change as `name` is missing."
          ],
          "analysisPoints": [
            "Tests understanding of how `setState` merges objects.",
            "Clarifies that `setState` performs a shallow merge, not a replacement."
          ],
          "keyConcepts": [
            "setState",
            "State Merging",
            "Shallow Merge"
          ],
          "evaluationCriteria": [
            "Accurate prediction of state after an update.",
            "Understanding of `setState`'s merging behavior."
          ],
          "example": "React's `setState` performs a shallow merge of the object you provide into the current state. This means that only the keys explicitly present in the object passed to `setState` will be updated or added, while other existing keys in the state object remain unchanged.",
          "tags": [
            "React",
            "State",
            "setState",
            "Merging"
          ],
          "prerequisites": [
            "React State Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_6",
          "topic": "Reconciliation Keys",
          "level": "medium",
          "type": "open",
          "question": "Explain the importance of the `key` prop when rendering lists of elements in React. What problems can arise if `keys` are not used correctly or are unstable?",
          "answer": "N/A",
          "analysisPoints": [
            "Tests understanding of `key` prop's role in reconciliation.",
            "Requires explanation of issues like incorrect rendering, performance problems, and state issues."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Keys",
            "Lists",
            "Performance",
            "State Persistence"
          ],
          "evaluationCriteria": [
            "Clarity on `key`'s purpose.",
            "Ability to identify consequences of incorrect `key` usage."
          ],
          "example": "The `key` prop is a special string attribute you need to include when creating lists of elements in React (e.g., using `map` to render an array). Keys help React identify which items have changed, been added, or removed. They help React's reconciliation algorithm efficiently update the UI.\n\n### Importance:\n*   **Efficient Updates**: Keys allow React to uniquely identify each child in a list. When the list changes, React can use keys to quickly determine exactly which components need to be re-ordered, added, or removed, rather than re-rendering the entire list or destroying and recreating components unnecessarily.\n*   **Preserving State**: When items are reordered, keys help React preserve the component's internal state. If a component moves to a new position, but its key remains the same, React knows it's the same component instance and can reuse its state and DOM, rather than remounting it.\n\n### Problems with Incorrect/Unstable Keys:\n*   **Unpredictable UI**: If keys are missing or unstable (e.g., using array index as key when items can be reordered, added, or removed), React's diffing algorithm can get confused. This can lead to:\n    *   **Incorrect Rendering**: The wrong item might be displayed at a certain position.\n    *   **State Issues**: State associated with a component might be incorrectly applied to a different component if React thinks it's the same component due to a reused index key.\n    *   **Performance Degradation**: React might re-render more than necessary, leading to slower updates, as it can't efficiently identify changes and might rebuild large parts of the DOM unnecessarily.",
          "tags": [
            "React",
            "Reconciliation",
            "Keys",
            "Lists",
            "Performance"
          ],
          "prerequisites": [
            "React State",
            "Array Mapping"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_7",
          "topic": "setState Batching",
          "level": "medium",
          "type": "code",
          "question": "Given the following React class component, predict the final value of `count` displayed in the UI after the button is clicked. Explain your reasoning regarding `setState` batching.\n\n```typescript\nimport React from 'react';\n\nclass BatchingDemo extends React.Component {\n  state = { count: 0 };\n\n  handleClick = () => {\n    this.setState({ count: this.state.count + 1 });\n    this.setState({ count: this.state.count + 1 });\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment Three Times</button>\n      </div>\n    );\n  }\n}\n```\n",
          "answer": "N/A",
          "analysisPoints": [
            "Tests understanding of `setState` batching and the difference between object and functional updates.",
            "Requires logical deduction of the final state."
          ],
          "keyConcepts": [
            "setState",
            "Batching",
            "Asynchronous",
            "Functional setState",
            "Object setState"
          ],
          "evaluationCriteria": [
            "Correct prediction of the final state.",
            "Clear explanation of batching and its impact on state updates.",
            "Demonstration of understanding when to use functional `setState`."
          ],
          "example": "When the button is clicked, `handleClick` is called. React batches the `setState` calls within a single event handler. The initial `count` is 0.\n\n1.  `this.setState({ count: this.state.count + 1 });`\n    *   React sees `this.state.count` as 0. The pending state change is `{ count: 1 }`.\n2.  `this.setState({ count: this.state.count + 1 });`\n    *   React still sees `this.state.count` as 0 (because the previous `setState` hasn't been processed yet in the current batch). The pending state change becomes `{ count: 1 }` (overwriting the previous pending `count` update for the same key, effectively).\n3.  `this.setState(prevState => ({ count: prevState.count + 1 }));`\n    *   This is the functional form. React will queue this update. When the batch is processed, `prevState` for this specific update will be the result of the *previously batched updates*.\n\nDuring the batch processing:\n*   The first two object-based `setState` calls are effectively merged into one: `{ count: 1 }` (from `0 + 1`).\n*   Then, the functional `setState` call takes this intermediate result (`count: 1`) as `prevState` and increments it by 1.\n\nTherefore, the final `count` will be **2**.\n\n**Reasoning**: In React's synthetic event handlers, `setState` calls are batched. The first two `setState` calls use the `this.state.count` value from the *beginning* of the event loop (`0`). Since they both operate on the same property (`count`) and are passed objects, the second one overwrites the first's effect *within the same render cycle's state update queue*. The third `setState` call, being functional, correctly receives the *intermediate state* after the previous object-based `setState`s have been processed within the batch, ensuring it calculates `1 + 1 = 2`.\n",
          "tags": [
            "React",
            "State",
            "setState",
            "Batching",
            "Functional setState",
            "Interview Question"
          ],
          "prerequisites": [
            "React State Basics",
            "JavaScript Event Loop"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_lifecycle_component_management",
          "title": "Build a Component with Managed Side Effects",
          "description": "\nCreate a React class component named `TimerComponent` that demonstrates proper lifecycle management for side effects.\n\n**Requirements:**\n\n1.  **Mounting**: When `TimerComponent` mounts, it should start a timer that increments a `seconds` state variable every second. Display the current `seconds` value.\n2.  **Updating**: If a `limit` prop is passed to `TimerComponent`, the timer should automatically stop when `seconds` reaches `limit`.\n3.  **Unmounting**: When `TimerComponent` is removed from the DOM, ensure the timer is properly cleared to prevent memory leaks.\n4.  Add `console.log` statements in `constructor`, `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` to observe the lifecycle flow.\n\n**Bonus**: Implement `shouldComponentUpdate` to prevent unnecessary re-renders if a parent passes the same `limit` prop multiple times without an actual change.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass TimerComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      seconds: 0,\n      isRunning: false\n    };\n    this.timerId = null;\n    // console.log('Constructor Called');\n  }\n\n  // TODO: Implement componentDidMount to start the timer\n\n  // TODO: Implement componentDidUpdate to handle the 'limit' prop and stop the timer\n\n  // TODO: Implement componentWillUnmount to clear the timer\n\n  // Bonus: Implement shouldComponentUpdate\n\n  render() {\n    // console.log('Render Called');\n    return (\n      <div>\n        <h3>Timer: {this.state.seconds}s</h3>\n        {this.props.limit && <p>Limit: {this.props.limit}s</p>}\n      </div>\n    );\n  }\n}\n\nexport default TimerComponent;\n\n// To test, you might use an App component like this:\n/*\nimport React, { useState } from 'react';\nimport TimerComponent from './TimerComponent';\n\nfunction App() {\n  const [showTimer, setShowTimer] = useState(true);\n  const [timerLimit, setTimerLimit] = useState(10);\n\n  return (\n    <div>\n      <h1>Timer App</h1>\n      <button onClick={() => setShowTimer(!showTimer)}>\n        {showTimer ? 'Hide Timer' : 'Show Timer'}\n      </button>\n      <button onClick={() => setTimerLimit(prev => prev + 5)}>Increase Limit</button>\n      <button onClick={() => setTimerLimit(5)}>Set Limit to 5</button>\n\n      {showTimer && <TimerComponent limit={timerLimit} />}\n      {!showTimer && <p>Timer is hidden.</p>}\n    </div>\n  );\n}\n\nexport default App;\n*/",
          "solutionCode": "import React from 'react';\n\nclass TimerComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      seconds: 0,\n      isRunning: false\n    };\n    this.timerId = null;\n    console.log('Constructor Called');\n  }\n\n  componentDidMount() {\n    console.log('componentDidMount Called: Starting timer.');\n    this.timerId = setInterval(() => {\n      this.setState(prevState => {\n        const newSeconds = prevState.seconds + 1;\n        const isRunning = !this.props.limit || newSeconds <= this.props.limit;\n        if (!isRunning && this.timerId) {\n          clearInterval(this.timerId);\n          this.timerId = null;\n          console.log('Timer stopped due to limit.');\n        }\n        return { seconds: newSeconds, isRunning: isRunning };\n      });\n    }, 1000);\n    this.setState({ isRunning: true });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    console.log('componentDidUpdate Called');\n    // Handle limit prop changes or stopping the timer if limit is reached\n    if (this.props.limit !== prevProps.limit && this.state.seconds < this.props.limit) {\n        console.log(`Limit changed from ${prevProps.limit} to ${this.props.limit}.`);\n        // If timer was stopped and limit increased, restart if needed\n        if (!this.state.isRunning && this.timerId === null) {\n            this.componentDidMount(); // Re-start timer if it was stopped\n        }\n    }\n    // If the component reaches the limit AFTER componentDidMount check\n    if (this.props.limit && this.state.seconds > this.props.limit && this.timerId) {\n        clearInterval(this.timerId);\n        this.timerId = null;\n        this.setState({ isRunning: false });\n        console.log('Timer stopped by componentDidUpdate due to limit.');\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount Called: Clearing timer.');\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      this.timerId = null;\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Bonus: Only re-render if seconds or limit prop actually changes\n    const shouldUpdate = (\n      nextState.seconds !== this.state.seconds ||\n      nextProps.limit !== this.props.limit\n    );\n    console.log(`shouldComponentUpdate: ${shouldUpdate ? 'Re-rendering' : 'Skipping render'}`);\n    return shouldUpdate;\n  }\n\n  render() {\n    console.log('Render Called');\n    return (\n      <div>\n        <h3>Timer: {this.state.seconds}s</h3>\n        {this.props.limit !== undefined && <p>Limit: {this.props.limit}s</p>}\n      </div>\n    );\n  }\n}\n\nexport default TimerComponent;\n",
          "testCases": [
            "Initial mount: Verify `constructor`, `render`, `componentDidMount` logs appear in order. `seconds` should start incrementing.",
            "Unmount: Hide the component. Verify `componentWillUnmount` log appears and timer stops (no more `seconds` increments).",
            "Re-mount: Show the component again. Verify a new timer starts from 0.",
            "Limit prop: Pass `limit={5}`. Verify timer stops at 5s. Check `componentDidUpdate` logs.",
            "Change limit dynamically: Change `limit` prop from, e.g., 5 to 10 while timer is running. Verify timer continues past 5s and stops at 10s. Check `componentDidUpdate` logs.",
            "Bonus `shouldComponentUpdate`: Pass the same `limit` prop multiple times without an actual change. Verify `render` is not called and `shouldComponentUpdate` logs 'Skipping render'."
          ],
          "hints": [
            "Remember that `setInterval` returns an ID that you need to store to clear it later.",
            "`componentDidMount` is for initial setup, `componentDidUpdate` for handling changes after initial render, and `componentWillUnmount` for cleanup.",
            "Be careful when conditionally stopping the timer inside `setState`; you might need a separate check or rely on `componentDidUpdate` for a clearer separation of concerns regarding `limit` prop.",
            "For `shouldComponentUpdate`, ensure you compare both `nextProps` and `nextState` with `this.props` and `this.state` respectively."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Side Effects",
            "Timers",
            "Cleanup",
            "Performance",
            "Class Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Class Components",
            "JavaScript Timers"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "componentDidMount",
            "componentDidUpdate",
            "componentWillUnmount",
            "shouldComponentUpdate",
            "setState"
          ]
        },
        {
          "id": "task_state_counter_management",
          "title": "Implement a Smart Counter with State and Reconciliation Principles",
          "description": "\nCreate a React class component called `SmartCounter` that manages a count and demonstrates proper `setState` usage and basic reconciliation awareness.\n\n**Requirements:**\n\n1.  **Basic Counter**: Initialize a `count` state variable to 0. Display the current `count`.\n2.  **Increment Button**: Add a button that increments the `count` by 1. Use the **functional form** of `setState` to ensure reliable updates, even if the button is clicked rapidly multiple times.\n3.  **Decrement Button**: Add a button that decrements the `count` by 1. Also use the functional form.\n4.  **Async Update Demo**: Add another button that calls `this.setState({ count: this.state.count + 10 });` immediately followed by `console.log(this.state.count)`. In the `render` method, also `console.log` the `count`. Observe and explain the console output.\n5.  **Conditional Update**: Add a button that only increments `count` if it's currently an even number. Use the functional form of `setState` and return `null` if no update is needed.\n\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass SmartCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  handleIncrement = () => {\n    // TODO: Implement increment using functional setState\n  };\n\n  handleDecrement = () => {\n    // TODO: Implement decrement using functional setState\n  };\n\n  handleAsyncUpdate = () => {\n    // TODO: Implement async update demo\n  };\n\n  handleConditionalIncrement = () => {\n    // TODO: Implement conditional increment using functional setState and returning null\n  };\n\n  render() {\n    // TODO: Add console.log for render method\n    return (\n      <div>\n        <h2>Smart Counter: {this.state.count}</h2>\n        <button onClick={this.handleIncrement}>Increment</button>\n        <button onClick={this.handleDecrement}>Decrement</button>\n        <button onClick={this.handleAsyncUpdate}>Async +10 & Log</button>\n        <button onClick={this.handleConditionalIncrement}>Increment if Even</button>\n      </div>\n    );\n  }\n}\n\nexport default SmartCounter;\n",
          "solutionCode": "import React from 'react';\n\nclass SmartCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  handleIncrement = () => {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  handleDecrement = () => {\n    this.setState(prevState => ({\n      count: prevState.count - 1\n    }));\n  };\n\n  handleAsyncUpdate = () => {\n    // This demonstrates the asynchronous nature of setState\n    this.setState({ count: this.state.count + 10 });\n    console.log('Inside handleClick (state might not be updated yet):', this.state.count);\n    // The actual update will be reflected in the next render cycle.\n  };\n\n  handleConditionalIncrement = () => {\n    this.setState(prevState => {\n      if (prevState.count % 2 === 0) {\n        console.log('Count is even, incrementing.');\n        return { count: prevState.count + 1 };\n      } else {\n        console.log('Count is odd, no update needed.');\n        return null; // Return null to prevent update\n      }\n    });\n  };\n\n  render() {\n    console.log('Render Called. Current Count:', this.state.count);\n    return (\n      <div>\n        <h2>Smart Counter: {this.state.count}</h2>\n        <button onClick={this.handleIncrement}>Increment</button>\n        <button onClick={this.handleDecrement}>Decrement</button>\n        <button onClick={this.handleAsyncUpdate}>Async +10 & Log</button>\n        <button onClick={this.handleConditionalIncrement}>Increment if Even</button>\n      </div>\n    );\n  }\n}\n\nexport default SmartCounter;\n",
          "testCases": [
            "Basic Increment/Decrement: Click Increment/Decrement multiple times. Verify `count` updates correctly.",
            "Rapid Increment: Click Increment button very quickly. Verify `count` updates by the correct amount, showcasing the functional `setState`'s reliability.",
            "Async Update: Click 'Async +10 & Log'. Observe the console output: The `console.log` inside `handleAsyncUpdate` should show the old `count` value, while the `console.log` in `render` will eventually show the updated value (after React processes the `setState` and re-renders).",
            "Conditional Update (Even): Set `count` to an even number (e.g., 0, 2, 4) and click 'Increment if Even'. Verify `count` increments by 1. Check console for 'Count is even, incrementing.'.",
            "Conditional Update (Odd): Set `count` to an odd number (e.g., 1, 3, 5) and click 'Increment if Even'. Verify `count` does not change. Check console for 'Count is odd, no update needed.' and that `render` is not called again immediately after this click.",
            "Batching behavior: Click 'Async +10 & Log' then quickly click 'Increment' twice. Observe the sequence of `render` calls and final `count`."
          ],
          "hints": [
            "For functional `setState`, the function signature is `(prevState, props) => newState`.",
            "To prevent a `setState` call from triggering an update (and thus a re-render), the functional `setState` callback can return `null`.",
            "Remember that `setState` is asynchronous and React batches updates. The `this.state` value inside an event handler might not be the latest if you've called `setState` just before accessing it.",
            "Use `console.log` extensively to trace the execution flow and state values at different points."
          ],
          "tags": [
            "React",
            "State Management",
            "setState",
            "Functional setState",
            "Asynchronous",
            "Reconciliation",
            "Performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "JavaScript Closures"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "setState",
            "Reconciliation",
            "Virtual DOM",
            "Batching"
          ]
        }
      ]
    }
  }
]