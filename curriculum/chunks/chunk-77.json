[
  {
    "id": "ad81f9a5-126b-4c5d-aaf5-3682307740a3",
    "startLine": 15900,
    "endLine": 15999,
    "processedDate": "2025-06-17T15:14:03.750Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_matrix_transformations",
          "title": "Matrix Transformations: Rotation and Spiral Traversal",
          "content": "## Matrix Rotation (90 Degrees Clockwise)\nMatrix rotation is a common operation in computer graphics and algorithms. For a square matrix, a 90-degree clockwise rotation can be performed in-place. One efficient approach involves iterating through layers of the matrix and cyclically shifting the four elements at each corner of the current layer. This method avoids the need for extra space.\n\n### Algorithm for In-place 90-degree Clockwise Rotation:\n1.  **Iterate through layers**: A square matrix of size `n x n` has `n / 2` layers (for `n` even) or `(n - 1) / 2` layers (for `n` odd). Loop from `layer = 0` to `floor(n / 2) - 1`.\n2.  **Define boundaries**: For each `layer`, define `first = layer` and `last = n - 1 - layer`. These represent the current layer's top-left and bottom-right boundaries.\n3.  **Iterate within the layer**: For each `i` from `first` to `last - 1` (this range ensures we pick unique elements for each cycle):\n    *   Store the top element: `top = matrix[first][i]`\n    *   Move left to top: `matrix[first][i] = matrix[last - (i - first)][first]`\n    *   Move bottom to left: `matrix[last - (i - first)][first] = matrix[last][last - (i - first)]`\n    *   Move right to bottom: `matrix[last][last - (i - first)] = matrix[i][last]`\n    *   Move stored top to right: `matrix[i][last] = top`\n\n## Spiral Matrix Traversal\nSpiral matrix traversal involves extracting elements from a matrix in a spiral order. This is typically achieved by maintaining four boundary pointers (top, bottom, left, right) and iteratively moving them inwards after traversing each side.\n\n### Algorithm for Spiral Traversal:\n1.  **Initialize boundaries**: `top = 0`, `bottom = matrix.length - 1`, `left = 0`, `right = matrix[0].length - 1`.\n2.  **Initialize direction**: `direction = 0` (0: right, 1: down, 2: left, 3: up).\n3.  **Loop while boundaries are valid**: Continue as long as `top <= bottom` and `left <= right`.\n    *   **Move Right (direction 0)**: Traverse from `left` to `right` along `matrix[top]`. Increment `top`.\n    *   **Move Down (direction 1)**: Traverse from `top` to `bottom` along `matrix[i][right]`. Decrement `right`.\n    *   **Move Left (direction 2)**: Traverse from `right` to `left` along `matrix[bottom]`. Decrement `bottom`.\n    *   **Move Up (direction 3)**: Traverse from `bottom` to `top` along `matrix[i][left]`. Increment `left`.\n4.  **Change direction**: After each side traversal, update `direction = (direction + 1) % 4` to cycle through the four directions.\n5.  **Collect results**: Add each visited element to a result array.",
          "examples": [
            {
              "id": "example_matrix_rotation_1",
              "title": "In-place Matrix Rotation (90 Degrees Clockwise)",
              "code": "function rotateMatrix(matrix) {\n  const n = matrix.length; // Assuming square matrix\n\n  for (let layer = 0; layer < Math.floor(n / 2); layer++) {\n    let first = layer;\n    let last = n - 1 - layer;\n\n    for (let i = first; i < last; i++) {\n      let offset = i - first;\n      // Save top-left element\n      let top = matrix[first][i];\n\n      // Move bottom-left to top-left\n      matrix[first][i] = matrix[last - offset][first];\n\n      // Move bottom-right to bottom-left\n      matrix[last - offset][first] = matrix[last][last - offset];\n\n      // Move top-right to bottom-right\n      matrix[last][last - offset] = matrix[i][last];\n\n      // Move saved top-left to top-right\n      matrix[i][last] = top;\n    }\n  }\n}\n\n// Example Usage:\nconst matrixToRotate = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\nconsole.log(\"Original matrix:\", matrixToRotate);\nrotateMatrix(matrixToRotate);\nconsole.log(\"Rotated matrix:\", matrixToRotate);\n/* Expected Result:\n[\n  [7, 4, 1],\n  [8, 5, 2],\n  [9, 6, 3]\n]\n*/",
              "explanation": "This function performs an in-place 90-degree clockwise rotation of a square matrix. It works by processing the matrix in concentric layers. For each layer, it iterates through elements on the top row (from `first` to `last-1`) and performs a cyclic swap of four elements: top-left with bottom-left, then bottom-left with bottom-right, then bottom-right with top-right, and finally top-right with the initially stored top-left element. This moves all four elements in a cycle, effectively rotating them.",
              "language": "javascript"
            },
            {
              "id": "example_spiral_traversal_1",
              "title": "Spiral Order Matrix Traversal",
              "code": "function spiralOrder(matrix) {\n  if (!matrix.length) return [];\n  \n  const result = [];\n  let top = 0;\n  let bottom = matrix.length - 1;\n  let left = 0;\n  let right = matrix[0].length - 1;\n  let direction = 0; // 0: right, 1: down, 2: left, 3: up\n  \n  while (top <= bottom && left <= right) {\n    if (direction === 0) {\n      // Move right\n      for (let i = left; i <= right; i++) {\n        result.push(matrix[top][i]);\n      }\n      top++;\n    } else if (direction === 1) {\n      // Move down\n      for (let i = top; i <= bottom; i++) {\n        result.push(matrix[i][right]);\n      }\n      right--;\n    } else if (direction === 2) {\n      // Move left (only if top is still <= bottom, avoids double counting in single row/column cases)\n      if (top <= bottom) { \n        for (let i = right; i >= left; i--) {\n          result.push(matrix[bottom][i]);\n        }\n      }\n      bottom--;\n    } else if (direction === 3) {\n      // Move up (only if left is still <= right, avoids double counting in single row/column cases)\n      if (left <= right) {\n        for (let i = bottom; i >= top; i--) {\n          result.push(matrix[i][left]);\n        }\n      }\n      left++;\n    }\n    \n    direction = (direction + 1) % 4; // Cycle direction\n  }\n  \n  return result;\n}\n\n// Example Usage:\nconst matrixToSpiral = [\n  [1, 2, 3, 4, 5],\n  [6, 7, 8, 9, 10],\n  [11, 12, 13, 14, 15],\n  [16, 17, 18, 19, 20]\n];\n\nconsole.log(\"Spiral order:\", spiralOrder(matrixToSpiral));\n// Expected: [1, 2, 3, 4, 5, 10, 15, 20, 19, 18, 17, 16, 11, 6, 7, 8, 9, 14, 13, 12]",
              "explanation": "This function extracts elements from a given matrix in a spiral order. It uses four pointers (`top`, `bottom`, `left`, `right`) to define the current boundaries of the sub-matrix being traversed. A `direction` variable (0-3) determines which side is being processed. After traversing one side, the corresponding boundary pointer is adjusted inwards, and the `direction` is updated cyclically. The loops for moving left and up include `if (top <= bottom)` and `if (left <= right)` checks, respectively, to prevent adding duplicate elements in cases of single-row or single-column matrices, which might happen after `top` or `right` have been incremented/decremented past `bottom` or `left`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_matrix_spiral_mcq_1",
            "question_matrix_rotation_open_1",
            "question_matrix_spiral_flashcard_1",
            "question_matrix_rotation_code_1",
            "question_matrix_spiral_open_2",
            "question_matrix_rotation_flashcard_2"
          ],
          "relatedTasks": [
            "task_matrix_rotation",
            "task_spiral_traversal"
          ],
          "tags": [
            "matrix",
            "algorithms",
            "in-place",
            "traversal",
            "array",
            "data-structures"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "arrays",
            "loops",
            "basic_algorithms"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "graph_algorithms",
            "game_development",
            "image_processing"
          ]
        },
        {
          "id": "theory_string_processing",
          "title": "String Processing: Finding Most Consecutive Character Occurrences",
          "content": "## Finding the Character with Most Consecutive Occurrences\nThis problem involves scanning a string to identify which character appears consecutively the most number of times. It's a common string manipulation problem that tests basic iteration and state management skills.\n\n### Algorithm:\n1.  **Handle Edge Cases**: If the string is empty, return `null` (or handle as per requirements).\n2.  **Initialize Variables**: \n    *   `maxChar`: Stores the character with the overall maximum consecutive count. Initialize with the first character of the string.\n    *   `maxCount`: Stores the overall maximum consecutive count. Initialize with `1`.\n    *   `currentChar`: Stores the character of the current consecutive sequence. Initialize with the first character.\n    *   `currentCount`: Stores the count of the current consecutive sequence. Initialize with `1`.\n3.  **Iterate through the string**: Start from the second character (index 1) up to the end of the string.\n    *   **If current character matches previous**: Increment `currentCount`.\n    *   **If current character is different**: \n        *   First, compare `currentCount` with `maxCount`. If `currentCount` is greater, update `maxCount` to `currentCount` and `maxChar` to `currentChar`.\n        *   Then, reset `currentChar` to the new character and `currentCount` to `1`.\n4.  **Final Check**: After the loop finishes, perform one last comparison of `currentCount` with `maxCount`. This is crucial because if the string ends with the longest consecutive sequence, the `else` block inside the loop won't be triggered for that sequence.\n5.  **Return `maxChar`**.",
          "examples": [
            {
              "id": "example_string_processing_1",
              "title": "Finding Most Consecutive Character",
              "code": "function findMostConsecutiveChar(str) {\n  if (str.length === 0) return null;\n  \n  let maxChar = str[0];\n  let maxCount = 1;\n  let currentChar = str[0];\n  let currentCount = 1;\n  \n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      // Check if the sequence that just ended was the longest\n      if (currentCount > maxCount) {\n        maxCount = currentCount;\n        maxChar = currentChar;\n      }\n      // Start a new sequence\n      currentChar = str[i];\n      currentCount = 1;\n    }\n  }\n  \n  // Crucial: After the loop, check the last sequence\n  if (currentCount > maxCount) {\n    maxCount = currentCount;\n    maxChar = currentChar;\n  }\n  \n  return maxChar;\n}\n\n// Example Usage:\nconsole.log(\"abcccccccdddefffffaaa ->\", findMostConsecutiveChar(\"abcccccccdddefffffaaa\")); // Expected: 'c'\nconsole.log(\"aaabbcdddd ->\", findMostConsecutiveChar(\"aaabbcdddd\"));             // Expected: 'd'\nconsole.log(\"aaaaa ->\", findMostConsecutiveChar(\"aaaaa\"));                     // Expected: 'a'\nconsole.log(\"abc ->\", findMostConsecutiveChar(\"abc\"));                         // Expected: 'a'\nconsole.log(\" ->\", findMostConsecutiveChar(\"\"));                               // Expected: null",
              "explanation": "This function iterates through the string, keeping track of the `currentChar` and its `currentCount` of consecutive occurrences. When the character changes, or the string ends, it compares `currentCount` with `maxCount` and updates `maxChar` and `maxCount` if a new maximum is found. The final check after the loop ensures that if the longest sequence is at the end of the string, it is correctly captured.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_string_consecutive_open_1",
            "question_string_consecutive_mcq_1",
            "question_string_consecutive_code_1",
            "question_string_consecutive_flashcard_1",
            "question_string_consecutive_open_2"
          ],
          "relatedTasks": [
            "task_find_most_consecutive_char"
          ],
          "tags": [
            "string",
            "algorithms",
            "iteration",
            "counting",
            "character_frequency"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "strings",
            "loops",
            "variables"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "text_processing",
            "data_validation"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_matrix_rotation_open_1",
          "topic": "Matrix Rotation",
          "level": "medium",
          "type": "open",
          "question": "Describe the core logic behind rotating a square matrix 90 degrees clockwise in-place using the layer-by-layer approach. Explain how elements are moved within each layer.",
          "answer": "The layer-by-layer approach for rotating a square matrix 90 degrees clockwise in-place involves iterating through concentric square 'layers' of the matrix. For each layer, four elements at the corners of the current layer's segment are cyclically swapped. \n\nFor a matrix of size `n x n`, you would iterate from `layer = 0` up to `floor(n / 2) - 1`. Within each `layer`, you define `first = layer` and `last = n - 1 - layer`. Then, you iterate with an index `i` from `first` to `last - 1` along the 'top' edge of the current layer.\n\nIn each step of the inner loop, four elements are involved:\n1.  **Top-Left**: `matrix[first][i]`\n2.  **Bottom-Left**: `matrix[last - (i - first)][first]`\n3.  **Bottom-Right**: `matrix[last][last - (i - first)]`\n4.  **Top-Right**: `matrix[i][last]`\n\nThe rotation happens by moving `Bottom-Left` to `Top-Left`, `Bottom-Right` to `Bottom-Left`, `Top-Right` to `Bottom-Right`, and the original `Top-Left` (which was temporarily saved) to `Top-Right`. This effectively shifts elements clockwise around the perimeter of the current layer.",
          "analysisPoints": [
            "Understanding of layers and boundaries.",
            "Correct identification of the four elements involved in a cyclic swap.",
            "Ability to explain the `offset` concept (`i - first`) for dynamic indexing.",
            "Knowledge of in-place modification benefits (space complexity)."
          ],
          "keyConcepts": [
            "Matrix Rotation",
            "In-place Algorithm",
            "Layer-by-layer",
            "Cyclic Swapping",
            "Time Complexity O(N^2)",
            "Space Complexity O(1)"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of the algorithm description.",
            "Correctness of indexing logic explanation.",
            "Demonstration of understanding of in-place concept.",
            "Completeness of the explanation for edge cases like n=1 matrix or even/odd n."
          ],
          "example": "See the `rotateMatrix` function in the theory section for a concrete implementation.",
          "tags": [
            "matrix",
            "algorithms",
            "in-place",
            "rotation",
            "interview_question"
          ],
          "prerequisites": [
            "arrays",
            "loops"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_matrix_spiral_mcq_1",
          "topic": "Spiral Matrix Traversal",
          "level": "medium",
          "type": "mcq",
          "question": "In the `spiralOrder` function for matrix traversal, what is the primary purpose of the line `direction = (direction + 1) % 4;`?",
          "answer": "To cyclically change the direction of traversal (right, down, left, up).",
          "options": [
            "To cyclically change the direction of traversal (right, down, left, up).",
            "To reset the `direction` to 0 after completing a full spiral.",
            "To ensure the loop terminates when all elements are visited.",
            "To calculate the next boundary pointer for the traversal."
          ],
          "analysisPoints": [
            "Understanding of the modulo operator's use for cyclic progression.",
            "Knowledge of the four states representing traversal directions.",
            "Ability to distinguish between state management and loop termination/boundary calculation."
          ],
          "keyConcepts": [
            "Spiral Traversal",
            "State Machine",
            "Modulo Operator",
            "Array Iteration"
          ],
          "evaluationCriteria": [
            "Correct identification of the modulo operator's role.",
            "Understanding of the algorithm's state transitions.",
            "Ability to differentiate between control flow mechanisms."
          ],
          "example": "The `direction` variable cycles through 0, 1, 2, 3, then back to 0. Each number corresponds to a specific traversal path (right, down, left, up) along the matrix's current boundaries. The modulo operation ensures this cycle continues indefinitely until the boundary conditions (`top <= bottom && left <= right`) are no longer met, causing the `while` loop to terminate.",
          "tags": [
            "matrix",
            "algorithms",
            "traversal",
            "mcq"
          ],
          "prerequisites": [
            "loops",
            "operators"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_matrix_spiral_flashcard_1",
          "topic": "Spiral Matrix Traversal",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the four boundary pointers typically used in the spiral matrix traversal algorithm?",
          "answer": "Top, Bottom, Left, Right.",
          "analysisPoints": [
            "Recall of algorithm's key variables.",
            "Understanding of boundary-based iteration."
          ],
          "keyConcepts": [
            "Spiral Traversal",
            "Boundary Pointers",
            "Matrix"
          ],
          "evaluationCriteria": [
            "Accuracy of recall.",
            "Basic understanding of traversal mechanism."
          ],
          "example": "These pointers define the current sub-matrix that is being traversed. `top` and `bottom` define the row boundaries, while `left` and `right` define the column boundaries.",
          "tags": [
            "matrix",
            "algorithms",
            "traversal",
            "flashcard"
          ],
          "prerequisites": [
            "arrays"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_matrix_rotation_code_1",
          "topic": "Matrix Rotation",
          "level": "hard",
          "type": "code",
          "question": "Implement a function `rotateMatrixTransposeReverse(matrix)` that rotates a square matrix 90 degrees clockwise in-place by first transposing the matrix and then reversing each of its rows. Assume the input `matrix` is always square.",
          "answer": "```javascript\nfunction rotateMatrixTransposeReverse(matrix) {\n  const n = matrix.length;\n\n  // Step 1: Transpose the matrix\n  // Swap elements across the main diagonal (matrix[i][j] with matrix[j][i])\n  for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) { // Start j from i to avoid double swapping\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n\n  // Step 2: Reverse each row\n  for (let i = 0; i < n; i++) {\n    matrix[i].reverse(); // Array.prototype.reverse() method\n  }\n}\n\n// Example usage:\nconst matrix1 = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\nconsole.log(\"Original:\", matrix1);\nrotateMatrixTransposeReverse(matrix1);\nconsole.log(\"Rotated (Transpose+Reverse):\", matrix1);\n// Expected: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\nconst matrix2 = [\n  [1, 2],\n  [3, 4]\n];\nconsole.log(\"Original:\", matrix2);\nrotateMatrixTransposeReverse(matrix2);\nconsole.log(\"Rotated (Transpose+Reverse):\", matrix2);\n// Expected: [[3, 1], [4, 2]]\n```",
          "analysisPoints": [
            "Correct implementation of matrix transposition (swapping `matrix[i][j]` with `matrix[j][i]`).",
            "Understanding that `j` should start from `i` in the transpose loop to avoid redundant swaps and maintain in-place property.",
            "Correct application of row reversal (e.g., using `Array.prototype.reverse()` or a manual two-pointer swap).",
            "Handling edge cases like 1x1 matrix (implicitly handled correctly)."
          ],
          "keyConcepts": [
            "Matrix Transposition",
            "In-place Algorithm",
            "Array Reversal",
            "Time Complexity O(N^2)",
            "Space Complexity O(1)"
          ],
          "evaluationCriteria": [
            "Functional correctness for various square matrix sizes.",
            "Efficiency (O(N^2) time, O(1) space).",
            "Clarity and readability of the code.",
            "Adherence to in-place constraint."
          ],
          "example": "This solution demonstrates an alternative and often simpler way to perform 90-degree clockwise rotation. First, the matrix is transposed, meaning rows become columns and columns become rows (e.g., `matrix[i][j]` becomes `matrix[j][i]`). Then, each row of the *transposed* matrix is reversed. This combination achieves the desired 90-degree clockwise rotation. The `j = i` in the inner loop for transposition ensures each pair is swapped only once.",
          "tags": [
            "matrix",
            "algorithms",
            "in-place",
            "rotation",
            "coding_challenge"
          ],
          "prerequisites": [
            "arrays",
            "loops",
            "array_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_matrix_spiral_open_2",
          "topic": "Spiral Matrix Traversal",
          "level": "medium",
          "type": "open",
          "question": "Discuss the time and space complexity of the `spiralOrder` function. What are the key factors contributing to these complexities?",
          "answer": "**Time Complexity:**\nThe time complexity of the `spiralOrder` function is O(M*N), where M is the number of rows and N is the number of columns in the matrix.\n\n**Reasoning:**\nEvery element in the matrix is visited and added to the `result` array exactly once. The `while` loop continues as long as `top <= bottom` and `left <= right`, ensuring all elements are processed. Each inner `for` loop iterates over a distinct set of elements (a row or a column segment) that are not revisited. Therefore, the total number of operations is directly proportional to the total number of elements in the matrix.\n\n**Space Complexity:**\nThe space complexity of the `spiralOrder` function is O(M*N).\n\n**Reasoning:**\nA new array, `result`, is created to store all elements of the matrix in spiral order. In the worst-case scenario, this array will hold all M*N elements of the input matrix. If the problem allowed for printing elements directly without storing them, the auxiliary space complexity would be O(1) (excluding the input matrix itself and recursion stack if applicable). However, since the function returns a new array containing all elements, the space complexity is proportional to the size of the output.",
          "analysisPoints": [
            "Correctly identifying both time and space complexity.",
            "Providing clear reasoning for the time complexity based on visiting each element once.",
            "Providing clear reasoning for the space complexity based on the output array size.",
            "Distinguishing between auxiliary space and total space if relevant (e.g., if problem asked for printing vs. returning a list)."
          ],
          "keyConcepts": [
            "Time Complexity",
            "Space Complexity",
            "Big O Notation",
            "Matrix Traversal",
            "Algorithm Analysis"
          ],
          "evaluationCriteria": [
            "Accuracy of complexity analysis.",
            "Clarity and completeness of explanation.",
            "Understanding of how data structures (like `result` array) impact space complexity."
          ],
          "example": "Consider a 3x3 matrix. The function will visit 9 elements. For a 4x5 matrix, it visits 20 elements. This linear relationship to the total number of elements (M*N) defines its time complexity.",
          "tags": [
            "matrix",
            "algorithms",
            "complexity",
            "analysis",
            "interview_question"
          ],
          "prerequisites": [
            "big_o_notation"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_matrix_rotation_flashcard_2",
          "topic": "Matrix Rotation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the typical space complexity for in-place matrix rotation algorithms (like the layer-by-layer method or transpose-then-reverse)?",
          "answer": "O(1) (constant space).",
          "analysisPoints": [
            "Recall of in-place algorithm benefits.",
            "Understanding of auxiliary space."
          ],
          "keyConcepts": [
            "Space Complexity",
            "In-place Algorithm",
            "Matrix Rotation"
          ],
          "evaluationCriteria": [
            "Accuracy of recall.",
            "Basic understanding of space efficiency."
          ],
          "example": "In-place algorithms modify the input matrix directly without allocating significant additional data structures proportional to the input size, hence achieving O(1) space complexity.",
          "tags": [
            "matrix",
            "algorithms",
            "complexity",
            "flashcard"
          ],
          "prerequisites": [
            "big_o_notation"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_string_consecutive_open_1",
          "topic": "String Processing",
          "level": "medium",
          "type": "open",
          "question": "How would you modify the `findMostConsecutiveChar` function to return an object containing both the character and its maximum consecutive count, instead of just the character?",
          "answer": "To modify the `findMostConsecutiveChar` function to return an object `{ char: maxChar, count: maxCount }`, you would make the following changes:\n\n1.  **Modify Return Type**: Change the final `return` statement to return an object.\n2.  **Initialize `maxCount`**: Ensure `maxCount` is initialized correctly (e.g., `1` for non-empty string, or `0` for an empty string if you want `{ char: null, count: 0 }`).\n3.  **Handle Empty String**: For an empty string, return a default object like `{ char: null, count: 0 }` or throw an error, depending on requirements.\n\n```javascript\nfunction findMostConsecutiveCharExtended(str) {\n  if (str.length === 0) {\n    return { char: null, count: 0 }; // Return null char and 0 count for empty string\n  }\n  \n  let maxChar = str[0];\n  let maxCount = 1;\n  let currentChar = str[0];\n  let currentCount = 1;\n  \n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      if (currentCount > maxCount) {\n        maxCount = currentCount;\n        maxChar = currentChar;\n      }\n      currentChar = str[i];\n      currentCount = 1;\n    }\n  }\n  \n  if (currentCount > maxCount) {\n    maxCount = currentCount;\n    maxChar = currentChar;\n  }\n  \n  return { char: maxChar, count: maxCount }; // Return an object\n}\n\n// Example Usage:\nconsole.log(findMostConsecutiveCharExtended(\"abcccccccdddefffffaaa\")); // { char: 'c', count: 7 }\nconsole.log(findMostConsecutiveCharExtended(\"aaaaa\"));                     // { char: 'a', count: 5 }\nconsole.log(findMostConsecutiveCharExtended(\"\"));                           // { char: null, count: 0 }\n```",
          "analysisPoints": [
            "Correctly identifying the need to return an object.",
            "Properly initializing `maxCount` and `maxChar` (and `currentChar`, `currentCount`) based on the first character.",
            "Handling the empty string case with an appropriate return value.",
            "Ensuring the final `if (currentCount > maxCount)` check is still in place before returning."
          ],
          "keyConcepts": [
            "String Iteration",
            "State Management",
            "Data Structures (Objects)",
            "Edge Cases"
          ],
          "evaluationCriteria": [
            "Functional correctness of the modified function.",
            "Appropriate handling of initial state and edge cases.",
            "Clarity of the returned data structure."
          ],
          "example": "This modification is useful when you need more than just the character; knowing the count is often critical for further processing or display. For instance, if you're building a simple run-length encoding feature, this information is vital.",
          "tags": [
            "string",
            "modification",
            "data_structure",
            "interview_question"
          ],
          "prerequisites": [
            "objects",
            "functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_string_consecutive_mcq_1",
          "topic": "String Processing",
          "level": "easy",
          "type": "mcq",
          "question": "Consider the `findMostConsecutiveChar` function. If the input string is `\"abbccc\"`, what character will `maxChar` hold after the loop finishes and the final check is performed?",
          "answer": "c",
          "options": [
            "a",
            "b",
            "c",
            "null"
          ],
          "analysisPoints": [
            "Tracing variable states through the loop.",
            "Understanding the role of `maxCount` and `maxChar` updates.",
            "Importance of the final check after the loop for the last sequence."
          ],
          "keyConcepts": [
            "String Iteration",
            "Variable Tracking",
            "Consecutive Count"
          ],
          "evaluationCriteria": [
            "Ability to mentally execute code.",
            "Correct application of comparison logic."
          ],
          "example": "Let's trace `\"abbccc\"`:\n- Initial: `maxChar='a'`, `maxCount=1`, `currentChar='a'`, `currentCount=1`\n- i=1 ('b'): `str[1]` != `currentChar`. `currentCount` (1) not > `maxCount` (1). Reset: `currentChar='b'`, `currentCount=1`.\n- i=2 ('b'): `str[2]` == `currentChar`. `currentCount` becomes 2.\n- i=3 ('c'): `str[3]` != `currentChar`. `currentCount` (2) > `maxCount` (1). Update: `maxCount=2`, `maxChar='b'`. Reset: `currentChar='c'`, `currentCount=1`.\n- i=4 ('c'): `str[4]` == `currentChar`. `currentCount` becomes 2.\n- i=5 ('c'): `str[5]` == `currentChar`. `currentCount` becomes 3.\n- Loop ends. Final check: `currentCount` (3) > `maxCount` (2). Update: `maxCount=3`, `maxChar='c'`.\nResult: `maxChar` is 'c'.",
          "tags": [
            "string",
            "logic_trace",
            "mcq"
          ],
          "prerequisites": [
            "loops",
            "variables"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_string_consecutive_code_1",
          "topic": "String Processing",
          "level": "medium",
          "type": "code",
          "question": "Implement a function `findLeastConsecutiveChar(str)` that finds the character with the *least* consecutive occurrences in a string. If multiple characters have the same minimum count, return the one that appears first alphabetically. Assume the string only contains lowercase English letters. If the string is empty, return `null`.",
          "answer": "```javascript\nfunction findLeastConsecutiveChar(str) {\n  if (str.length === 0) return null;\n\n  let minChar = str[0];\n  let minCount = Infinity; // Initialize with a very large number\n\n  let currentChar = str[0];\n  let currentCount = 1;\n\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      // Check if the sequence that just ended is the new minimum\n      if (currentCount < minCount) {\n        minCount = currentCount;\n        minChar = currentChar;\n      } else if (currentCount === minCount) {\n        // If counts are equal, prioritize alphabetically smaller character\n        if (currentChar < minChar) {\n          minChar = currentChar;\n        }\n      }\n      // Start a new sequence\n      currentChar = str[i];\n      currentCount = 1;\n    }\n  }\n\n  // Crucial: After the loop, check the last sequence\n  if (currentCount < minCount) {\n    minCount = currentCount;\n    minChar = currentChar;\n  } else if (currentCount === minCount) {\n    if (currentChar < minChar) {\n      minChar = currentChar;\n    }\n  }\n\n  return minChar;\n}\n\n// Example Usage:\nconsole.log(findLeastConsecutiveChar(\"abcccccccdddefffffaaa\")); // Expected: 'b' (count 1)\nconsole.log(findLeastConsecutiveChar(\"aaabbcdddd\"));             // Expected: 'b' (count 1)\nconsole.log(findLeastConsecutiveChar(\"aaaaa\"));                     // Expected: 'a' (count 5)\nconsole.log(findLeastConsecutiveChar(\"abc\"));                         // Expected: 'a' (count 1, 'a' < 'b' < 'c')\nconsole.log(findLeastConsecutiveChar(\"eeeaabbbccc\"));           // Expected: 'a' (count 2, 'a' < 'e')\nconsole.log(findLeastConsecutiveChar(\"\"));                           // Expected: null\n```",
          "analysisPoints": [
            "Correctly adapting the logic from 'most' to 'least' (i.e., using `minCount` and `minChar` and initializing `minCount` to `Infinity`).",
            "Implementing the tie-breaking rule: if `currentCount` equals `minCount`, choose the alphabetically smaller character.",
            "Properly handling the empty string case.",
            "Ensuring the final check after the loop for the last sequence."
          ],
          "keyConcepts": [
            "String Iteration",
            "Minimum Finding",
            "Tie-breaking Logic",
            "Edge Cases",
            "Alphabetical Comparison"
          ],
          "evaluationCriteria": [
            "Functional correctness for various string inputs, including ties.",
            "Efficiency (O(N) time, O(1) space).",
            "Adherence to specified tie-breaking rule.",
            "Robustness for edge cases."
          ],
          "example": "This problem is a twist on finding the maximum, requiring careful adaptation of the comparison logic, especially for handling ties based on alphabetical order. Initializing `minCount` to `Infinity` is a common pattern when looking for a minimum value.",
          "tags": [
            "string",
            "algorithms",
            "variation",
            "coding_challenge"
          ],
          "prerequisites": [
            "find_most_consecutive_char",
            "string_comparison"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_string_consecutive_flashcard_1",
          "topic": "String Processing",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the time complexity of the `findMostConsecutiveChar` algorithm?",
          "answer": "O(N), where N is the length of the string.",
          "analysisPoints": [
            "Recall of linear time complexity for single pass algorithms.",
            "Understanding that each character is visited a constant number of times."
          ],
          "keyConcepts": [
            "Time Complexity",
            "Big O Notation",
            "String Iteration"
          ],
          "evaluationCriteria": [
            "Accuracy of recall.",
            "Basic understanding of algorithm efficiency."
          ],
          "example": "The algorithm involves a single loop that iterates through the string once. Operations inside the loop (comparisons, increments, assignments) take constant time. Therefore, the total time complexity is directly proportional to the length of the string.",
          "tags": [
            "string",
            "complexity",
            "flashcard"
          ],
          "prerequisites": [
            "big_o_notation"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_string_consecutive_open_2",
          "topic": "String Processing",
          "level": "medium",
          "type": "open",
          "question": "What happens if the longest consecutive sequence is at the very end of the string in `findMostConsecutiveChar` if the final check after the loop is omitted?",
          "answer": "If the final `if (currentCount > maxCount)` check after the loop is omitted in `findMostConsecutiveChar`, the function might return an incorrect result if the longest consecutive sequence occurs at the very end of the string.\n\n**Explanation:**\nThe `maxChar` and `maxCount` variables are updated *only* when `str[i]` is different from `currentChar` (i.e., when a sequence *ends*) or during the initial assignment. If the string ends with its longest sequence (e.g., `\"aaabbbcccc\"`), the `else` block (where `maxCount` and `maxChar` are updated) will not be triggered for the final sequence (`\"cccc\"`). The `currentCount` will correctly hold `4`, but `maxCount` would still hold the value from the previous longest sequence (e.g., `3` for `\"bbb\"`), leading to `maxChar` being `b` instead of `c`.\n\nTherefore, the final check is crucial to ensure that the statistics of the last sequence processed are properly compared and, if necessary, used to update the overall maximum.",
          "analysisPoints": [
            "Identifying the specific failure scenario (longest sequence at end).",
            "Explaining *why* the failure occurs (update logic tied to sequence termination within loop).",
            "Highlighting the importance of the post-loop check for correctness.",
            "Providing a concrete example to illustrate the point."
          ],
          "keyConcepts": [
            "Edge Cases",
            "Loop Invariants",
            "Algorithm Correctness",
            "State Management"
          ],
          "evaluationCriteria": [
            "Clear and accurate explanation of the defect.",
            "Demonstration of understanding of loop control flow.",
            "Ability to predict algorithm behavior under specific conditions."
          ],
          "example": "For the string `\"aaabbbcccc\"`:\n- After `\"aaa\"` (i=2), `maxChar='a'`, `maxCount=3` (or initial state if 'aaa' is not longest).\n- After `\"bbb\"` (i=5), `currentCount` (3) is compared. If `maxCount` was previously 1, then `maxCount` becomes 3, `maxChar` becomes 'b'.\n- When processing `\"cccc\"`, `currentCount` becomes 4. However, since the loop ends, the `else` block is never entered for the 'cccc' sequence. Without the final check, `maxChar` would remain 'b' and `maxCount` would remain 3, which is incorrect.",
          "tags": [
            "string",
            "edge_case",
            "logic",
            "interview_question"
          ],
          "prerequisites": [
            "loops",
            "debugging"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_matrix_rotation",
          "title": "Implement In-place Matrix Rotation (90 Degrees Clockwise)",
          "description": "\nImplement the `rotateMatrix` function that rotates a given `n x n` 2D matrix 90 degrees clockwise in-place. You must modify the input matrix directly. Assume the input `matrix` is always square (i.e., `matrix.length === matrix[0].length`).\n\n**Requirements:**\n1.  The rotation must be 90 degrees clockwise.\n2.  The operation must be performed in-place (do not create a new matrix).\n3.  Your solution should be efficient in terms of time and space complexity.\n\n**Example:**\nInput:\n```\n[\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]\n```\nOutput (modified in-place):\n```\n[\n  [7, 4, 1],\n  [8, 5, 2],\n  [9, 6, 3]\n]\n```\n",
          "difficulty": "medium",
          "startingCode": "function rotateMatrix(matrix) {\n  const n = matrix.length;\n\n  // TODO: Implement the in-place 90-degree clockwise rotation.\n  // Consider iterating through layers.\n  // For each layer, perform cyclic swaps of four elements.\n\n}\n\n// Example usage (for testing):\n// const matrix = [[1,2,3],[4,5,6],[7,8,9]];\n// rotateMatrix(matrix);\n// console.log(matrix);\n",
          "solutionCode": "function rotateMatrix(matrix) {\n  const n = matrix.length;\n\n  for (let layer = 0; layer < Math.floor(n / 2); layer++) {\n    let first = layer;\n    let last = n - 1 - layer;\n\n    for (let i = first; i < last; i++) {\n      let offset = i - first;\n      // Save top-left element\n      let top = matrix[first][i];\n\n      // Move bottom-left to top-left\n      matrix[first][i] = matrix[last - offset][first];\n\n      // Move bottom-right to bottom-left\n      matrix[last - offset][first] = matrix[last][last - offset];\n\n      // Move top-right to bottom-right\n      matrix[last][last - offset] = matrix[i][last];\n\n      // Move saved top-left to top-right\n      matrix[i][last] = top;\n    }\n  }\n}",
          "testCases": [
            "Test with 3x3 matrix: `[[1,2,3],[4,5,6],[7,8,9]]` should become `[[7,4,1],[8,5,2],[9,6,3]]`",
            "Test with 2x2 matrix: `[[1,2],[3,4]]` should become `[[3,1],[4,2]]`",
            "Test with 1x1 matrix: `[[5]]` should remain `[[5]]`",
            "Test with 4x4 matrix: `[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]` should become `[[13,9,5,1],[14,10,6,2],[15,11,7,3],[16,12,8,4]]`",
            "Test with matrix containing zeros or negative numbers."
          ],
          "hints": [
            "Think about processing the matrix in concentric layers, starting from the outermost.",
            "For each layer, focus on cyclically rotating four elements at a time (top-left, top-right, bottom-right, bottom-left).",
            "Use an `offset` variable to correctly index elements within the current layer's segment.",
            "The time complexity should be O(N^2) and space complexity O(1)."
          ],
          "tags": [
            "matrix",
            "in-place",
            "rotation",
            "algorithm",
            "array"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "arrays",
            "loops"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "matrix_transposition",
            "image_processing",
            "game_development"
          ]
        },
        {
          "id": "task_spiral_traversal",
          "title": "Implement Spiral Matrix Traversal",
          "description": "\nImplement the `spiralOrder` function that takes a `m x n` matrix and returns a new array containing all elements of the matrix in spiral order.\n\n**Requirements:**\n1.  Handle matrices of different dimensions (e.g., `m x n`, `m x 1`, `1 x n`).\n2.  Handle an empty input matrix.\n\n**Example:**\nInput:\n```\n[\n  [1, 2, 3, 4, 5],\n  [6, 7, 8, 9, 10],\n  [11, 12, 13, 14, 15],\n  [16, 17, 18, 19, 20]\n]\n```\nOutput:\n```\n[1, 2, 3, 4, 5, 10, 15, 20, 19, 18, 17, 16, 11, 6, 7, 8, 9, 14, 13, 12]\n```\n",
          "difficulty": "medium",
          "startingCode": "function spiralOrder(matrix) {\n  // TODO: Handle empty matrix case.\n  // TODO: Initialize boundary pointers (top, bottom, left, right).\n  // TODO: Initialize direction.\n  // TODO: Loop while boundaries are valid, traversing each side and updating boundaries and direction.\n  // TODO: Collect elements in a result array.\n}\n\n// Example usage (for testing):\n// const matrix = [\n//   [1, 2, 3],\n//   [8, 9, 4],\n//   [7, 6, 5]\n// ];\n// console.log(spiralOrder(matrix)); // Expected: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
          "solutionCode": "function spiralOrder(matrix) {\n  if (!matrix.length) return [];\n  \n  const result = [];\n  let top = 0;\n  let bottom = matrix.length - 1;\n  let left = 0;\n  let right = matrix[0].length - 1;\n  let direction = 0; // 0: right, 1: down, 2: left, 3: up\n  \n  while (top <= bottom && left <= right) {\n    if (direction === 0) {\n      // Move right\n      for (let i = left; i <= right; i++) {\n        result.push(matrix[top][i]);\n      }\n      top++;\n    } else if (direction === 1) {\n      // Move down\n      for (let i = top; i <= bottom; i++) {\n        result.push(matrix[i][right]);\n      }\n      right--;\n    } else if (direction === 2) {\n      // Move left (only if top is still <= bottom, avoids double counting in single row/column cases)\n      if (top <= bottom) { \n        for (let i = right; i >= left; i--) {\n          result.push(matrix[bottom][i]);\n        }\n      }\n      bottom--;\n    } else if (direction === 3) {\n      // Move up (only if left is still <= right, avoids double counting in single row/column cases)\n      if (left <= right) {\n        for (let i = bottom; i >= top; i--) {\n          result.push(matrix[i][left]);\n        }\n      }\n      left++;\n    }\n    \n    direction = (direction + 1) % 4; // Cycle direction\n  }\n  \n  return result;\n}",
          "testCases": [
            "Test with empty matrix: `[]` should return `[]`.",
            "Test with 1x1 matrix: `[[1]]` should return `[1]`.",
            "Test with 1xn matrix: `[[1,2,3,4]]` should return `[1,2,3,4]`.",
            "Test with nx1 matrix: `[[1],[2],[3]]` should return `[1,2,3]`.",
            "Test with a 3x3 matrix: `[[1,2,3],[8,9,4],[7,6,5]]` should return `[1,2,3,4,5,6,7,8,9]`.",
            "Test with the given example 4x5 matrix.",
            "Test with a 2x4 matrix: `[[1,2,3,4],[5,6,7,8]]` should return `[1,2,3,4,8,7,6,5]`."
          ],
          "hints": [
            "Use four pointers: `top`, `bottom`, `left`, `right` to define the current boundaries.",
            "Use a `direction` variable (e.g., 0 for right, 1 for down, 2 for left, 3 for up) and update it using the modulo operator.",
            "Remember to increment/decrement the correct boundary pointer after each traversal phase.",
            "Add checks (e.g., `if (top <= bottom)` or `if (left <= right)`) before the 'move left' and 'move up' phases to handle non-square matrices or single-row/column scenarios correctly and avoid duplicate elements."
          ],
          "tags": [
            "matrix",
            "traversal",
            "algorithm",
            "array",
            "data-structures"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "arrays",
            "loops",
            "conditional_logic"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "matrix_manipulation",
            "boundary_conditions"
          ]
        },
        {
          "id": "task_find_most_consecutive_char",
          "title": "Implement Find Most Consecutive Character",
          "description": "\nImplement the `findMostConsecutiveChar` function that takes a string `str` and returns the character with the most consecutive occurrences.\n\n**Requirements:**\n1.  If the string is empty, return `null`.\n2.  If there's a tie in consecutive counts, return the character that appears first in the string.\n3.  The function should be case-sensitive (e.g., 'a' and 'A' are different characters).\n\n**Examples:**\n*   `findMostConsecutiveChar(\"abcccccccdddefffffaaa\")` should return `'c'` (7 'c's).\n*   `findMostConsecutiveChar(\"aaabbcdddd\")` should return `'d'` (4 'd's).\n*   `findMostConsecutiveChar(\"aaaaa\")` should return `'a'` (5 'a's).\n*   `findMostConsecutiveChar(\"abc\")` should return `'a'` (all 1, 'a' comes first).\n*   `findMostConsecutiveChar(\"\")` should return `null`.\n",
          "difficulty": "easy",
          "startingCode": "function findMostConsecutiveChar(str) {\n  if (str.length === 0) return null;\n  \n  let maxChar = str[0];\n  let maxCount = 1;\n  let currentChar = str[0];\n  let currentCount = 1;\n  \n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      // TODO: Logic for when current sequence ends\n      // Compare currentCount with maxCount and update if necessary\n      \n      // TODO: Reset for new character sequence\n      // currentChar = ...\n      // currentCount = ...\n    }\n  }\n  \n  // TODO: Important: Final check after the loop for the last sequence\n  \n  return maxChar;\n}",
          "solutionCode": "function findMostConsecutiveChar(str) {\n  if (str.length === 0) return null;\n  \n  let maxChar = str[0];\n  let maxCount = 1;\n  let currentChar = str[0];\n  let currentCount = 1;\n  \n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      // Current sequence ended. Check if it's the new max.\n      if (currentCount > maxCount) {\n        maxCount = currentCount;\n        maxChar = currentChar;\n      }\n      // Start new sequence\n      currentChar = str[i];\n      currentCount = 1;\n    }\n  }\n  \n  // After the loop, check the very last sequence\n  if (currentCount > maxCount) {\n    maxCount = currentCount;\n    maxChar = currentChar;\n  }\n  \n  return maxChar;\n}",
          "testCases": [
            "Test with `\"\"` (empty string) should return `null`.",
            "Test with `\"a\"` (single character) should return `'a'`.",
            "Test with `\"aaabbb\"` should return `'a'` (both 'a' and 'b' have count 3, 'a' appears first).",
            "Test with `\"abcccccccdddefffffaaa\"` should return `'c'`.",
            "Test with `\"aaabbcdddd\"` should return `'d'`.",
            "Test with `\"xyz\"` should return `'x'` (all count 1, 'x' appears first).",
            "Test with `\"AAAAABBBCC\"` should return `'A'`."
          ],
          "hints": [
            "You need to keep track of two sets of counts: one for the current consecutive sequence and one for the overall maximum found so far.",
            "Don't forget to handle the case where the longest consecutive sequence is at the very end of the string.",
            "The problem asks for the character itself, not its count, but you need the count for comparison."
          ],
          "tags": [
            "string",
            "algorithm",
            "iteration",
            "character_frequency"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "loops",
            "variables",
            "conditional_logic"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "run_length_encoding",
            "string_parsing"
          ]
        }
      ]
    }
  },
  {
    "id": "652cd6da-ccd6-4837-9a62-dfebd41cdd6f",
    "startLine": 16000,
    "endLine": 16099,
    "processedDate": "2025-06-17T15:15:23.237Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_string_consecutive_char",
          "title": "String Manipulation: Finding the Most Consecutive Character",
          "content": "This theory block covers an algorithmic approach to find the character that appears most consecutively in a given string. This problem requires iterating through the string, keeping track of the current character and its consecutive count, and comparing it against the maximum count found so far.\n\n## Key Concepts\n-   **Iteration**: Processing each character of the string one by one.\n-   **State Management**: Maintaining `currentChar`, `currentCount`, `maxChar`, and `maxCount` variables to track the state of consecutive sequences.\n-   **Edge Cases**: Handling empty strings, strings with a single character, and ensuring the last sequence in the string is also checked.\n\n## Algorithm Steps\n1.  Initialize `maxChar` and `maxCount` to default values (e.g., empty string/first char and 0/1). For an empty string, handle it explicitly.\n2.  Initialize `currentChar` and `currentCount` for the current sequence being examined.\n3.  Iterate through the string from the second character (index 1).\n4.  If the current character is the same as the `currentChar`, increment `currentCount`.\n5.  If the current character is different, it means a sequence has ended:\n    a.  Compare `currentCount` with `maxCount`. If `currentCount` is greater, update `maxCount` and `maxChar`.\n    b.  Reset `currentChar` to the new character and `currentCount` to 1.\n6.  After the loop finishes, there might be a pending `currentCount` for the last sequence. Perform a final comparison of `currentCount` with `maxCount` to ensure the last sequence is considered.",
          "examples": [
            {
              "id": "example_string_consecutive_char_1",
              "title": "Basic Implementation of findMostConsecutiveChar",
              "code": "function findMostConsecutiveChar(str) {\n  if (!str || str.length === 0) {\n    return { char: '', count: 0 };\n  }\n\n  let maxChar = str[0];\n  let maxCount = 1;\n  let currentChar = str[0];\n  let currentCount = 1;\n\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      if (currentCount > maxCount) {\n        maxCount = currentCount;\n        maxChar = currentChar;\n      }\n      currentChar = str[i];\n      currentCount = 1;\n    }\n  }\n  \n  // Check for the last character sequence\n  if (currentCount > maxCount) {\n    maxCount = currentCount;\n    maxChar = currentChar;\n  }\n  \n  return { char: maxChar, count: maxCount };\n}\n\n// Example Usage:\nconst str1 = 'bbbaaaaccadd';\nconst result1 = findMostConsecutiveChar(str1);\nconsole.log(result1); // Expected: { char: 'a', count: 4 }\n\nconst str2 = 'aabbbcccc';\nconst result2 = findMostConsecutiveChar(str2);\nconsole.log(result2); // Expected: { char: 'c', count: 4 }\n\nconst str3 = 'a';\nconst result3 = findMostConsecutiveChar(str3);\nconsole.log(result3); // Expected: { char: 'a', count: 1 }",
              "explanation": "This example provides the complete JavaScript function `findMostConsecutiveChar`. It initializes `maxChar` and `maxCount` with the first character's details. It then iterates through the string, comparing each character to the `currentChar`. If they match, `currentCount` increments. If they differ, it means a sequence has ended, so it checks if `currentCount` is a new maximum, updates `maxCount` and `maxChar` if necessary, and then resets `currentChar` and `currentCount` for the new sequence. A crucial final check outside the loop handles the case where the longest consecutive sequence occurs at the very end of the string.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_string_consecutive_char_1",
            "question_string_consecutive_char_2",
            "question_string_consecutive_char_3",
            "question_string_consecutive_char_4"
          ],
          "relatedTasks": [
            "task_string_consecutive_char_1"
          ],
          "tags": [
            "string-manipulation",
            "algorithms",
            "iteration",
            "data-processing"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "basic-javascript",
            "loops",
            "conditional-statements"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "sliding-window",
            "dynamic-programming-basics"
          ]
        },
        {
          "id": "theory_linked_list_reverse_iterative",
          "title": "Linked List Operations: Iterative Reversal",
          "content": "Reversing a linked list is a fundamental operation that involves changing the direction of the `next` pointers for each node. This can be achieved iteratively by carefully managing three pointers: `current`, `prev`, and `next`. This approach avoids the overhead and potential stack overflow issues associated with recursive solutions for very long lists.\n\n## Key Concepts\n-   **Linked List Structure**: Understanding that each node contains a value and a pointer (`next`) to the subsequent node.\n-   **Pointer Manipulation**: The core of linked list operations involves correctly updating `next` pointers to change the list's structure.\n-   **Three-Pointer Technique**: Using `current`, `prev`, and `next` pointers to facilitate the reversal:\n    -   `current`: Points to the node currently being processed.\n    -   `prev`: Points to the node that was previously processed, which will become the `current` node's new `next`.\n    -   `next`: Temporarily stores the `current` node's original `next` node before `current.next` is modified. This is crucial to avoid losing the rest of the list.\n\n## Iterative Reversal Algorithm\n1.  Initialize `prev` to `null` (the new head will point to `null`).\n2.  Initialize `current` to the `head` of the original list.\n3.  Loop while `current` is not `null`:\n    a.  Store `current.next` in a `next` temporary variable. This preserves the link to the rest of the un-reversed list.\n    b.  Change the `current` node's `next` pointer to point to `prev`. This reverses the link.\n    c.  Move `prev` forward to `current`. `current` is now part of the reversed section.\n    d.  Move `current` forward to `next`. `current` is now ready to process the next original node.\n4.  After the loop, `current` will be `null`, and `prev` will point to the new head of the reversed list (which was the original tail). Return `prev`.",
          "examples": [
            {
              "id": "example_linked_list_reverse_iterative_1",
              "title": "Iterative Linked List Reversal Implementation",
              "code": "class ListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction reverseLinkedList(head) {\n  let current = head;\n  let prev = null;\n  let next = null; // Used to temporarily store the next node\n  \n  while (current !== null) {\n    // 1. Store next node before modifying current.next\n    next = current.next;\n    \n    // 2. Reverse current node's pointer: make it point to prev\n    current.next = prev;\n    \n    // 3. Move prev one step forward (it now points to the last reversed node)\n    prev = current;\n    \n    // 4. Move current one step forward (to the next node in the original list)\n    current = next;\n  }\n  \n  // After loop, prev is the new head of the reversed list\n  return prev;\n}\n\n// Example Usage:\n// Create list: 1 -> 2 -> 3 -> 4 -> 5 -> 6\nconst head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nhead.next.next.next = new ListNode(4);\nhead.next.next.next.next = new ListNode(5);\nhead.next.next.next.next.next = new ListNode(6);\n\nconsole.log(\"Original list:\");\nlet temp = head;\nlet values = [];\nwhile (temp !== null) { values.push(temp.value); temp = temp.next; }\nconsole.log(values); // [1, 2, 3, 4, 5, 6]\n\n// Reverse the list\nconst newHead = reverseLinkedList(head);\n\n// Print the reversed list: 6 -> 5 -> 4 -> 3 -> 2 -> 1\nconsole.log(\"Reversed list:\");\nlet current = newHead;\nvalues = [];\nwhile (current !== null) {\n  values.push(current.value);\n  current = current.next;\n}\nconsole.log(values); // [6, 5, 4, 3, 2, 1]",
              "explanation": "This example demonstrates the iterative approach to reversing a singly linked list. The `ListNode` class defines the basic structure. The `reverseLinkedList` function uses three pointers: `current` (the node being processed), `prev` (the node that `current` will point to after reversal), and `next` (a temporary pointer to save the next node in the original list before `current.next` is modified). The loop continues until `current` becomes `null`, at which point `prev` holds the reference to the new head of the reversed list.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_linked_list_reverse_1",
            "question_linked_list_reverse_2",
            "question_linked_list_reverse_3",
            "question_linked_list_reverse_4"
          ],
          "relatedTasks": [
            "task_linked_list_reverse_1"
          ],
          "tags": [
            "linked-lists",
            "data-structures",
            "algorithms",
            "pointers",
            "interview-prep"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "data-structures-basics",
            "javascript-pointers-references"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "doubly-linked-lists",
            "list-cycle-detection",
            "merge-sorted-lists"
          ]
        },
        {
          "id": "theory_tree_traversal_iterative_preorder",
          "title": "Tree Traversal: Iterative Preorder Traversal",
          "content": "Tree traversal refers to the process of visiting each node in a tree data structure exactly once. While recursion is a natural fit for tree traversals, iterative approaches are often preferred in interviews to demonstrate a deeper understanding of data structures (like stacks) and to avoid potential stack overflow issues with very deep trees.\n\nPreorder traversal visits nodes in the order: **Root -> Left Subtree -> Right Subtree**.\n\n## Key Concepts\n-   **Binary Tree Structure**: Nodes typically have a `value`, `left` child, and `right` child.\n-   **Stack Data Structure**: Crucial for iterative traversals. A stack follows a Last-In, First-Out (LIFO) principle, which is essential for remembering nodes to visit later.\n-   **Preorder Logic**: For iterative preorder traversal, we push the right child first, then the left child. This ensures that when we pop, the left child is processed before the right, following the Root-Left-Right pattern.\n\n## Iterative Preorder Traversal Algorithm\n1.  Initialize an empty `result` array to store the traversed node values.\n2.  If the `root` is `null`, return the empty `result` array immediately.\n3.  Initialize an empty `stack` and push the `root` node onto it.\n4.  While the `stack` is not empty:\n    a.  Pop a `node` from the `stack`. This `node` is the current root to be processed.\n    b.  Add the `node.value` to the `result` array (this is the 'Root' part of 'Root-Left-Right').\n    c.  If the `node` has a `right` child, push it onto the `stack`. (Process right after left).\n    d.  If the `node` has a `left` child, push it onto the `stack`. (Process left first).\n5.  Return the `result` array.",
          "examples": [
            {
              "id": "example_tree_traversal_iterative_preorder_1",
              "title": "Iterative Preorder Traversal Implementation",
              "code": "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction preorderTraversal(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const stack = [root]; // Initialize stack with the root node\n  \n  while (stack.length > 0) {\n    const node = stack.pop(); // Pop the node to visit\n    result.push(node.value); // Add its value to the result (Root)\n    \n    // Push right child first, so left child is processed before it (LIFO)\n    if (node.right) {\n      stack.push(node.right);\n    }\n    if (node.left) {\n      stack.push(node.left);\n    }\n  }\n  return result;\n}\n\n// Example Tree:\n//        1\n//       / \\n//      2   3\n//     / \\n//    4   5\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(\"Preorder Traversal:\", preorderTraversal(root)); // Expected: [1, 2, 4, 5, 3]\n\nconst emptyRoot = null;\nconsole.log(\"Preorder Traversal (empty tree):\", preorderTraversal(emptyRoot)); // Expected: []",
              "explanation": "This example provides the complete JavaScript implementation for iterative preorder tree traversal. It uses a `TreeNode` class for the tree structure and a `stack` (implemented using a JavaScript array acting as a stack) to manage the nodes to visit. The key insight is to push the right child onto the stack *before* the left child. Because a stack is LIFO, the left child will be popped and processed first, ensuring the Root -> Left -> Right order is maintained.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_tree_traversal_preorder_1",
            "question_tree_traversal_preorder_2",
            "question_tree_traversal_preorder_3",
            "question_tree_traversal_preorder_4"
          ],
          "relatedTasks": [
            "task_tree_traversal_1"
          ],
          "tags": [
            "trees",
            "data-structures",
            "algorithms",
            "stack",
            "traversal",
            "binary-tree"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "data-structures-basics",
            "stack-data-structure",
            "recursion-basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "bfs-dfs",
            "binary-search-trees",
            "graph-traversals"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_string_consecutive_char_1",
          "topic": "String Manipulation: Consecutive Characters",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `findMostConsecutiveChar` function. What would be the output for the input string `'abcaadddefffff'`?",
          "answer": "{ char: 'f', count: 5 }",
          "options": [
            "{ char: 'a', count: 2 }",
            "{ char: 'd', count: 3 }",
            "{ char: 'f', count: 5 }",
            "{ char: 'c', count: 1 }"
          ],
          "analysisPoints": [
            "The function tracks `maxCount` and `maxChar` throughout the iteration.",
            "It correctly updates `maxCount` when a longer consecutive sequence is found.",
            "It handles the final sequence check outside the loop, which is crucial if the longest sequence is at the end.",
            "For 'abcaadddefffff': 'a' (1), 'b' (1), 'c' (1), 'aa' (2), 'ddd' (3), 'e' (1), 'fffff' (5). The maximum is 'f' with count 5."
          ],
          "keyConcepts": [
            "String iteration",
            "Consecutive sequence tracking",
            "Edge case handling for string end"
          ],
          "evaluationCriteria": [
            "Ability to trace algorithm execution.",
            "Understanding of comparison logic for maximum count.",
            "Attention to edge cases."
          ],
          "example": "```javascript\nfunction findMostConsecutiveChar(str) {\n  if (!str || str.length === 0) {\n    return { char: '', count: 0 };\n  }\n  let maxChar = str[0];\n  let maxCount = 1;\n  let currentChar = str[0];\n  let currentCount = 1;\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      if (currentCount > maxCount) {\n        maxCount = currentCount;\n        maxChar = currentChar;\n      }\n      currentChar = str[i];\n      currentCount = 1;\n    }\n  }\n  if (currentCount > maxCount) {\n    maxCount = currentCount;\n    maxChar = currentChar;\n  }\n  return { char: maxChar, count: maxCount };\n}\nconsole.log(findMostConsecutiveChar('abcaadddefffff')); // { char: 'f', count: 5 }\n```",
          "tags": [
            "string-manipulation",
            "algorithms",
            "mcq"
          ],
          "prerequisites": [
            "string-basics",
            "loops"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_string_consecutive_char_2",
          "topic": "String Manipulation: Consecutive Characters",
          "level": "medium",
          "type": "open",
          "question": "Analyze the time and space complexity of the `findMostConsecutiveChar` function. Justify your answer.",
          "answer": "Time Complexity: O(N), where N is the length of the input string. The function iterates through the string once using a single `for` loop.\nSpace Complexity: O(1). The function uses a constant amount of extra space for variables like `maxChar`, `maxCount`, `currentChar`, and `currentCount`, regardless of the input string's length.",
          "analysisPoints": [
            "**Time Complexity**: The algorithm involves a single pass through the input string. Each character is visited and processed a constant number of times (comparison, increment, assignment). Therefore, the time complexity scales linearly with the length of the string, making it O(N).",
            "**Space Complexity**: The auxiliary space used by the algorithm (variables like `maxChar`, `maxCount`, `currentChar`, `currentCount`) does not depend on the size of the input string. It's a fixed number of variables. Hence, the space complexity is constant, O(1)."
          ],
          "keyConcepts": [
            "Time complexity analysis",
            "Space complexity analysis",
            "Big O notation"
          ],
          "evaluationCriteria": [
            "Accuracy of time complexity analysis.",
            "Accuracy of space complexity analysis.",
            "Clarity of justification."
          ],
          "example": null,
          "tags": [
            "string-manipulation",
            "algorithms",
            "complexity-analysis",
            "open-ended"
          ],
          "prerequisites": [
            "big-o-notation"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_string_consecutive_char_3",
          "topic": "String Manipulation: Consecutive Characters",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary data structure or technique used to find the most consecutive character in a string as shown in the example?",
          "answer": "Iteration with state variables.",
          "analysisPoints": [
            "The solution uses a loop to go through each character.",
            "It maintains variables (state) to keep track of the current consecutive character and its count, as well as the overall maximum."
          ],
          "keyConcepts": [
            "Iteration",
            "State management",
            "Character comparison"
          ],
          "evaluationCriteria": [
            "Quick recall of fundamental algorithm approach."
          ],
          "example": null,
          "tags": [
            "string-manipulation",
            "algorithms",
            "flashcard"
          ],
          "prerequisites": [
            "loops"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_string_consecutive_char_4",
          "topic": "String Manipulation: Consecutive Characters",
          "level": "hard",
          "type": "code",
          "question": "Modify the `findMostConsecutiveChar` function to return an array of all characters that have the maximum consecutive count. If there are multiple characters with the same maximum count, they should all be included in the result array.",
          "answer": "```javascript\nfunction findAllMostConsecutiveChars(str) {\n  if (!str || str.length === 0) {\n    return [];\n  }\n\n  let maxChars = [str[0]];\n  let maxCount = 1;\n  let currentChar = str[0];\n  let currentCount = 1;\n\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      if (currentCount > maxCount) {\n        maxCount = currentCount;\n        maxChars = [currentChar]; // New max, reset array\n      } else if (currentCount === maxCount) {\n        maxChars.push(currentChar); // Same max, add to array\n      }\n      currentChar = str[i];\n      currentCount = 1;\n    }\n  }\n  \n  // Check for the last character sequence\n  if (currentCount > maxCount) {\n    maxCount = currentCount;\n    maxChars = [currentChar];\n  } else if (currentCount === maxCount) {\n    maxChars.push(currentChar);\n  }\n  \n  return maxChars;\n}\n\n// Example Usage:\nconsole.log(findAllMostConsecutiveChars('aaabbbccc')); // ['a', 'b', 'c']\nconsole.log(findAllMostConsecutiveChars('aabbcdddeee')); // ['d', 'e']\nconsole.log(findAllMostConsecutiveChars('bbbaaaaccadd')); // ['a']\n```",
          "analysisPoints": [
            "The key modification is changing `maxChar` from a single character to `maxChars` (an array).",
            "When `currentCount` exceeds `maxCount`, `maxChars` must be reset to contain only the new `currentChar`.",
            "When `currentCount` equals `maxCount`, the `currentChar` should be *added* to `maxChars`.",
            "The logic for the final sequence check remains critical and must incorporate the same comparison for equality."
          ],
          "keyConcepts": [
            "Array manipulation",
            "Handling multiple maximums",
            "Adapting existing algorithms"
          ],
          "evaluationCriteria": [
            "Correctly implementing array logic for multiple results.",
            "Handling edge cases like empty string and single character string.",
            "Maintaining correct comparison logic throughout the loop and final check."
          ],
          "example": "```javascript\n// See answer for example code.\n```",
          "tags": [
            "string-manipulation",
            "algorithms",
            "coding-challenge",
            "arrays"
          ],
          "prerequisites": [
            "string-consecutive-char-theory"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_linked_list_reverse_1",
          "topic": "Linked List Operations: Reversal",
          "level": "medium",
          "type": "open",
          "question": "How would you reverse a linked list iteratively? Describe the role of each pointer used in the process.",
          "answer": "To reverse a linked list iteratively, you typically use three pointers: `prev`, `current`, and `next`.\n\n1.  **Initialize**: `prev` is set to `null` (this will eventually be the new tail, and the new head will point to it). `current` is set to the `head` of the original list.\n2.  **Iterate**: Loop while `current` is not `null`:\n    *   **`next`**: Temporarily store `current.next` in `next`. This is crucial because `current.next` is about to be changed, and we need to preserve the link to the rest of the original list.\n    *   **Reverse Link**: Set `current.next` to `prev`. This changes the direction of the pointer for the `current` node.\n    *   **Advance `prev`**: Move `prev` to `current`. The `current` node (which has just been reversed) becomes the `prev` for the next iteration.\n    *   **Advance `current`**: Move `current` to `next`. This moves to the next node in the original list.\n3.  **Return**: Once the loop finishes (`current` becomes `null`), `prev` will be pointing to the original tail, which is now the new head of the reversed list. Return `prev`.",
          "analysisPoints": [
            "Clear explanation of the three-pointer technique.",
            "Correct sequence of pointer updates within the loop.",
            "Understanding of why `next` temporary pointer is necessary.",
            "Correct identification of the new head."
          ],
          "keyConcepts": [
            "Linked list structure",
            "Pointer manipulation",
            "Iterative algorithm",
            "Time and space complexity (O(N) time, O(1) space)"
          ],
          "evaluationCriteria": [
            "Completeness of the algorithm description.",
            "Accuracy of pointer roles.",
            "Clarity and conciseness."
          ],
          "example": null,
          "tags": [
            "linked-lists",
            "data-structures",
            "algorithms",
            "open-ended"
          ],
          "prerequisites": [
            "linked-list-basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_linked_list_reverse_2",
          "topic": "Linked List Operations: Reversal",
          "level": "medium",
          "type": "mcq",
          "question": "In the iterative linked list reversal algorithm, what is the purpose of the `prev` pointer?",
          "answer": "It stores the previously processed node, which becomes the `next` node for the current node after reversal.",
          "options": [
            "It stores the next node in the original list to prevent loss of reference.",
            "It always points to the head of the original list.",
            "It stores the previously processed node, which becomes the `next` node for the current node after reversal.",
            "It is used to count the number of nodes processed so far."
          ],
          "analysisPoints": [
            "`prev` is initialized to `null` because the first node of the original list will become the new head and its `next` should be `null`.",
            "As `current` iterates, `prev` follows, holding the reference to the *already reversed* part of the list.",
            "When `current.next` is set to `prev`, it means `current` now points backward, connecting to the reversed segment."
          ],
          "keyConcepts": [
            "Pointer roles in linked list reversal",
            "State management",
            "Iterative process"
          ],
          "evaluationCriteria": [
            "Understanding of pointer mechanics.",
            "Ability to distinguish roles of different pointers."
          ],
          "example": "```javascript\n// Snippet from reverseLinkedList function\n// ...\n// current.next = prev; // Here, current node's next is set to prev\n// prev = current;     // Then, prev moves to current\n// ...\n```",
          "tags": [
            "linked-lists",
            "data-structures",
            "algorithms",
            "mcq"
          ],
          "prerequisites": [
            "linked-list-basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_linked_list_reverse_3",
          "topic": "Linked List Operations: Reversal",
          "level": "hard",
          "type": "code",
          "question": "Implement a **recursive** function to reverse a singly linked list. You should still use the `ListNode` class provided in the theory.",
          "answer": "```javascript\nclass ListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction reverseLinkedListRecursive(head) {\n  // Base case: If head is null or only one node, it's already reversed\n  if (head === null || head.next === null) {\n    return head;\n  }\n\n  // Recursively reverse the rest of the list\n  // newHead will be the last node of the original list (and new head)\n  const newHead = reverseLinkedListRecursive(head.next);\n\n  // Attach the current head to the end of the reversed sublist\n  // head.next is the second node in the original list.\n  // After recursive call, head.next.next points back to head.\n  head.next.next = head;\n  \n  // Set current head's next to null to break the original forward link\n  // This current head will become the new tail of its reversed sublist\n  head.next = null;\n\n  // Return the new head of the fully reversed list\n  return newHead;\n}\n\n// Example Usage:\nconst head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nhead.next.next.next = new ListNode(4);\n\nconsole.log(\"Original list:\");\nlet temp = head;\nlet values = [];\nwhile (temp !== null) { values.push(temp.value); temp = temp.next; }\nconsole.log(values); // [1, 2, 3, 4]\n\nconst newHead = reverseLinkedListRecursive(head);\n\nconsole.log(\"Reversed list (recursive):\");\nlet current = newHead;\nvalues = [];\nwhile (current !== null) { values.push(current.value); current = current.next; }\nconsole.log(values); // [4, 3, 2, 1]\n```",
          "analysisPoints": [
            "The base case handles empty lists or lists with a single node.",
            "The recursive call effectively reverses the 'tail' of the list.",
            "The crucial step is `head.next.next = head;` which reverses the pointer of the node *after* `head` to point back to `head`.",
            "`head.next = null;` is essential to prevent a cycle and to correctly set the new tail of the current sub-problem.",
            "The function returns the new head of the *entire* reversed list, which is the original tail."
          ],
          "keyConcepts": [
            "Recursion",
            "Linked list manipulation",
            "Base cases",
            "Building solution from sub-problems"
          ],
          "evaluationCriteria": [
            "Correct implementation of recursive logic.",
            "Proper handling of base cases.",
            "Prevention of cycles.",
            "Correct return value."
          ],
          "example": "```javascript\n// See answer for example code.\n```",
          "tags": [
            "linked-lists",
            "data-structures",
            "algorithms",
            "recursion",
            "coding-challenge"
          ],
          "prerequisites": [
            "linked-list-basics",
            "recursion-basics"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_linked_list_reverse_4",
          "topic": "Linked List Operations: Reversal",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the three essential pointers typically used in the iterative method to reverse a singly linked list?",
          "answer": "`current`, `prev`, and `next` (or `tempNext`).",
          "analysisPoints": [
            "Each pointer plays a distinct and critical role in the reversal process.",
            "`current` moves through the list, `prev` builds the new reversed list, and `next` temporarily saves the original forward link."
          ],
          "keyConcepts": [
            "Pointer names",
            "Memory management in linked lists"
          ],
          "evaluationCriteria": [
            "Recall of key terms."
          ],
          "example": null,
          "tags": [
            "linked-lists",
            "data-structures",
            "flashcard"
          ],
          "prerequisites": [
            "linked-list-basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_tree_traversal_preorder_1",
          "topic": "Tree Traversal: Iterative Preorder",
          "level": "medium",
          "type": "open",
          "question": "How would you implement a preorder tree traversal without recursion? Explain the role of the data structure used.",
          "answer": "To implement a preorder tree traversal iteratively, you can use a **stack** data structure.\n\n1.  **Initialization**: Create an empty `result` list and an empty `stack`. If the root node is null, return the empty `result` list.\n2.  **Start**: Push the `root` node onto the `stack`.\n3.  **Iteration**: While the `stack` is not empty:\n    *   **Pop**: Pop a node from the top of the `stack`. This node is the current one to be visited.\n    *   **Visit**: Add the `node's value` to the `result` list.\n    *   **Push Children**: Push the `right` child onto the `stack` first, then the `left` child. This order is crucial because a stack is LIFO (Last-In, First-Out), and in preorder, we want to process the left child before the right child. By pushing right then left, when we pop, left will be on top.\n\n**Role of the Stack**: The stack is used to keep track of the nodes that still need to be visited. When we visit a node, we push its children onto the stack to ensure they are processed later. The LIFO nature of the stack ensures that when we pop, we retrieve the most recently added child first, which facilitates the correct traversal order (left child before right child for preorder, after the parent has been visited).",
          "analysisPoints": [
            "Clear explanation of the algorithm steps.",
            "Correct identification of the stack as the core data structure.",
            "Accurate description of how the stack's LIFO property helps achieve the preorder sequence.",
            "Distinction between recursive and iterative approaches."
          ],
          "keyConcepts": [
            "Tree traversal algorithms",
            "Stack data structure",
            "Iterative vs. recursive solutions",
            "Preorder traversal order (Root-Left-Right)"
          ],
          "evaluationCriteria": [
            "Correctness of algorithm steps.",
            "Depth of explanation for stack's role.",
            "Clarity and precision of language."
          ],
          "example": null,
          "tags": [
            "trees",
            "data-structures",
            "algorithms",
            "stack",
            "open-ended"
          ],
          "prerequisites": [
            "tree-basics",
            "stack-data-structure"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_tree_traversal_preorder_2",
          "topic": "Tree Traversal: Preorder",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following binary tree:\n```\n      A\n     / \\\n    B   C\n   / \\n  D   E\n```\nWhat is the correct preorder traversal sequence for this tree?",
          "answer": "A, B, D, E, C",
          "options": [
            "D, B, E, A, C",
            "A, B, D, E, C",
            "D, E, B, C, A",
            "A, C, B, D, E"
          ],
          "analysisPoints": [
            "Preorder traversal visits the root first, then the left subtree, then the right subtree.",
            "For 'A', visit A, then left (subtree B), then right (subtree C).",
            "For 'B', visit B, then left (D), then right (E).",
            "For 'C', visit C (it has no children).",
            "Combining these: A -> B -> D -> E -> C."
          ],
          "keyConcepts": [
            "Preorder traversal definition",
            "Applying traversal rules"
          ],
          "evaluationCriteria": [
            "Correct application of preorder traversal rules.",
            "Ability to trace tree traversals."
          ],
          "example": "```javascript\n// Tree definition as in the theory block.\n// const root = new TreeNode('A');\n// root.left = new TreeNode('B');\n// root.right = new TreeNode('C');\n// root.left.left = new TreeNode('D');\n// root.left.right = new TreeNode('E');\n// console.log(preorderTraversal(root)); // Should output ['A', 'B', 'D', 'E', 'C']\n```",
          "tags": [
            "trees",
            "data-structures",
            "algorithms",
            "mcq"
          ],
          "prerequisites": [
            "tree-basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_tree_traversal_preorder_3",
          "topic": "Tree Traversal: Iterative Preorder",
          "level": "medium",
          "type": "code",
          "question": "The provided markdown content includes a partial `preorderTraversal` function. Complete the function to correctly perform an iterative preorder traversal using a stack. The `TreeNode` class is also provided.",
          "answer": "```javascript\nclass TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction preorderTraversal(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const stack = [root];\n  \n  while (stack.length > 0) {\n    const node = stack.pop();\n    result.push(node.value);\n    \n    // Push right child first, so left child is processed next (LIFO)\n    if (node.right) {\n      stack.push(node.right);\n    }\n    if (node.left) {\n      stack.push(node.left);\n    }\n  }\n  return result;\n}\n\n// Example Tree:\n//        1\n//       / \\\n//      2   3\n//     / \\n//    4   5\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(\"Preorder Traversal:\", preorderTraversal(root)); // Expected: [1, 2, 4, 5, 3]\n\nconst emptyRoot = null;\nconsole.log(\"Preorder Traversal (empty tree):\", preorderTraversal(emptyRoot)); // Expected: []\n```",
          "analysisPoints": [
            "Correct initialization of the stack with the root.",
            "Proper use of `stack.pop()` to get the current node.",
            "Correctly adding the node's value to the `result` array.",
            "Crucial order of pushing children: right child *then* left child to ensure left is processed first due to LIFO."
          ],
          "keyConcepts": [
            "Stack operations (`push`, `pop`, `length`)",
            "Iterative tree traversal logic",
            "Preorder traversal rules",
            "Handling null nodes"
          ],
          "evaluationCriteria": [
            "Functional correctness of the completed code.",
            "Adherence to iterative approach using a stack.",
            "Correct preorder output for various tree structures."
          ],
          "example": "```javascript\n// See answer for example code.\n```",
          "tags": [
            "trees",
            "data-structures",
            "algorithms",
            "stack",
            "coding-challenge"
          ],
          "prerequisites": [
            "tree-traversal-iterative-preorder-theory"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_tree_traversal_preorder_4",
          "topic": "Tree Traversal: Iterative",
          "level": "easy",
          "type": "flashcard",
          "question": "Which data structure is commonly used to implement iterative tree traversals (like preorder, inorder, postorder) and why?",
          "answer": "A stack. Because its Last-In, First-Out (LIFO) property allows us to manage the order of nodes to visit by pushing children and processing the desired next node first.",
          "analysisPoints": [
            "Understanding that stacks are fundamental for iterative depth-first traversals.",
            "Connecting the LIFO property to how nodes are ordered for visitation."
          ],
          "keyConcepts": [
            "Stack data structure",
            "LIFO principle",
            "Tree traversal mechanisms"
          ],
          "evaluationCriteria": [
            "Quick recall of essential data structure.",
            "Understanding of its role."
          ],
          "example": null,
          "tags": [
            "trees",
            "data-structures",
            "stack",
            "flashcard"
          ],
          "prerequisites": [
            "stack-data-structure"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_string_consecutive_char_1",
          "title": "Analyze and Summarize String Consecutive Character Properties",
          "description": "\nImplement a function `getStringConsecutiveAnalysis(str)` that takes a string and returns an object containing:\n\n1.  `mostConsecutiveChar`: The character with the longest consecutive sequence.\n2.  `maxConsecutiveCount`: The length of that longest sequence.\n3.  `allMaxChars`: An array of all characters that achieve this `maxConsecutiveCount` (if multiple characters have the same max count).\n4.  `firstCharSequence`: The first character in the string and its consecutive count.\n5.  `totalDistinctChars`: The total count of unique characters in the string.\n\nYour solution should be efficient (O(N) time complexity) and handle edge cases like empty strings or strings with a single character gracefully.\n",
          "difficulty": "medium",
          "startingCode": "function getStringConsecutiveAnalysis(str) {\n  if (!str || str.length === 0) {\n    return {\n      mostConsecutiveChar: '',\n      maxConsecutiveCount: 0,\n      allMaxChars: [],\n      firstCharSequence: { char: '', count: 0 },\n      totalDistinctChars: 0\n    };\n  }\n\n  let maxChar = str[0];\n  let maxCount = 1;\n  let allMaxChars = [str[0]];\n  \n  let currentChar = str[0];\n  let currentCount = 1;\n\n  let firstCharSequence = { char: str[0], count: 0 }; // To be updated properly\n  let distinctChars = new Set();\n\n  // TODO: Implement the core logic here\n  // You will need to iterate through the string and update the variables.\n  // Remember to handle the last sequence check.\n\n  return {\n    mostConsecutiveChar: maxChar,\n    maxConsecutiveCount: maxCount,\n    allMaxChars: allMaxChars,\n    firstCharSequence: firstCharSequence,\n    totalDistinctChars: distinctChars.size\n  };\n}\n",
          "solutionCode": "function getStringConsecutiveAnalysis(str) {\n  if (!str || str.length === 0) {\n    return {\n      mostConsecutiveChar: '',\n      maxConsecutiveCount: 0,\n      allMaxChars: [],\n      firstCharSequence: { char: '', count: 0 },\n      totalDistinctChars: 0\n    };\n  }\n\n  let maxChar = str[0];\n  let maxCount = 1;\n  let allMaxChars = [str[0]];\n  \n  let currentChar = str[0];\n  let currentCount = 1;\n\n  let firstCharSequence = { char: str[0], count: 1 }; // First char always has at least 1 count\n  let distinctChars = new Set();\n  distinctChars.add(str[0]);\n\n  for (let i = 1; i < str.length; i++) {\n    distinctChars.add(str[i]);\n\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      // Check and update for max consecutive\n      if (currentCount > maxCount) {\n        maxCount = currentCount;\n        maxChars = [currentChar];\n      } else if (currentCount === maxCount) {\n        allMaxChars.push(currentChar);\n      }\n      \n      // Reset for new sequence\n      currentChar = str[i];\n      currentCount = 1;\n    }\n    \n    // Update firstCharSequence if it's still processing the very first sequence\n    if (i < str.length && str[i] === firstCharSequence.char && firstCharSequence.count === i) {\n        firstCharSequence.count++;\n    } else if (i === 1 && str[i] !== firstCharSequence.char) {\n        // If the second char is different, the first sequence is just 1\n        // This handles cases like 'abc', where firstCharSequence.count would be wrongly 2 for 'a' if not handled.\n        // No, this needs to be simpler: first sequence count is set once if the char changes. \n        // Or more simply: just check it after the loop if the first char was isolated.\n    }\n  }\n  \n  // Final check for the last character sequence\n  if (currentCount > maxCount) {\n    maxCount = currentCount;\n    maxChars = [currentChar];\n  } else if (currentCount === maxCount) {\n    allMaxChars.push(currentChar);\n  }\n\n  // Re-calculate firstCharSequence more reliably\n  let firstSeqChar = str[0];\n  let firstSeqCount = 1;\n  for(let i = 1; i < str.length; i++) {\n      if (str[i] === firstSeqChar) {\n          firstSeqCount++;\n      } else {\n          break; // First sequence ended\n      }\n  }\n  firstCharSequence = { char: firstSeqChar, count: firstSeqCount };\n\n  return {\n    mostConsecutiveChar: maxChar,\n    maxConsecutiveCount: maxCount,\n    allMaxChars: Array.from(new Set(allMaxChars)), // Remove duplicates for allMaxChars\n    firstCharSequence: firstCharSequence,\n    totalDistinctChars: distinctChars.size\n  };\n}\n",
          "testCases": [
            "getStringConsecutiveAnalysis('') should return { mostConsecutiveChar: '', maxConsecutiveCount: 0, allMaxChars: [], firstCharSequence: { char: '', count: 0 }, totalDistinctChars: 0 }",
            "getStringConsecutiveAnalysis('a') should return { mostConsecutiveChar: 'a', maxConsecutiveCount: 1, allMaxChars: ['a'], firstCharSequence: { char: 'a', count: 1 }, totalDistinctChars: 1 }",
            "getStringConsecutiveAnalysis('bbbaaaaccadd') should return { mostConsecutiveChar: 'a', maxConsecutiveCount: 4, allMaxChars: ['a'], firstCharSequence: { char: 'b', count: 3 }, totalDistinctChars: 4 }",
            "getStringConsecutiveAnalysis('aabbcddddeee') should return { mostConsecutiveChar: 'd', maxConsecutiveCount: 4, allMaxChars: ['d', 'e'], firstCharSequence: { char: 'a', count: 2 }, totalDistinctChars: 5 }",
            "getStringConsecutiveAnalysis('zyxw') should return { mostConsecutiveChar: 'z', maxConsecutiveCount: 1, allMaxChars: ['z', 'y', 'x', 'w'], firstCharSequence: { char: 'z', count: 1 }, totalDistinctChars: 4 }",
            "getStringConsecutiveAnalysis('qqqwww') should return { mostConsecutiveChar: 'q', maxConsecutiveCount: 3, allMaxChars: ['q', 'w'], firstCharSequence: { char: 'q', count: 3 }, totalDistinctChars: 2 }"
          ],
          "hints": [
            "Remember to initialize your variables correctly before the loop, especially for single-character strings.",
            "The logic for `allMaxChars` needs to handle two scenarios: finding a *new* maximum and finding an *equal* maximum.",
            "A `Set` can be very useful for tracking `totalDistinctChars` efficiently.",
            "The `firstCharSequence` can be determined by a separate, simple loop or by modifying your main loop with an `if` condition to break after the first sequence is counted."
          ],
          "tags": [
            "string-manipulation",
            "algorithms",
            "data-analysis",
            "javascript"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "string-consecutive-char-theory",
            "arrays",
            "sets"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "sliding-window",
            "character-frequency"
          ]
        },
        {
          "id": "task_linked_list_reverse_1",
          "title": "Reverse Linked List and Find Middle Element",
          "description": "\nImplement two functions for a singly linked list:\n\n1.  `reverseLinkedList(head)`: Takes the head of a singly linked list and returns the new head of the reversed list using the iterative three-pointer approach.\n2.  `findMiddle(head)`: Takes the head of a singly linked list and returns the value of the middle node. If the list has an even number of nodes, return the value of the second middle node (e.g., for 1->2->3->4, return 3).\n\nFinally, demonstrate how to reverse a given linked list and then find the middle element of the *reversed* list.\n",
          "difficulty": "medium",
          "startingCode": "class ListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction reverseLinkedList(head) {\n  // TODO: Implement iterative linked list reversal\n  return null;\n}\n\nfunction findMiddle(head) {\n  // TODO: Implement finding the middle element (slow/fast pointers)\n  return null;\n}\n\n// Example Usage (provided for testing):\n// Create list: 1 -> 2 -> 3 -> 4 -> 5 -> 6\n// const head = new ListNode(1);\n// head.next = new ListNode(2);\n// head.next.next = new ListNode(3);\n// head.next.next.next = new ListNode(4);\n// head.next.next.next.next = new ListNode(5);\n// head.next.next.next.next.next = new ListNode(6);\n\n// const reversedHead = reverseLinkedList(head);\n// const middleOfReversed = findMiddle(reversedHead);\n// console.log(middleOfReversed); // Expected: 4\n",
          "solutionCode": "class ListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction reverseLinkedList(head) {\n  let current = head;\n  let prev = null;\n  let next = null;\n  \n  while (current !== null) {\n    next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n  \n  return prev;\n}\n\nfunction findMiddle(head) {\n  if (!head) return null;\n  let slow = head;\n  let fast = head;\n\n  while (fast !== null && fast.next !== null) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow.value;\n}\n\n// Example Usage:\n// Create list: 1 -> 2 -> 3 -> 4 -> 5 -> 6\nconst head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nhead.next.next.next = new ListNode(4);\nhead.next.next.next.next = new ListNode(5);\nhead.next.next.next.next.next = new ListNode(6);\n\nconsole.log(\"Original List:\");\nlet temp = head;\nlet values = [];\nwhile (temp !== null) { values.push(temp.value); temp = temp.next; }\nconsole.log(values); // [1, 2, 3, 4, 5, 6]\n\nconst reversedHead = reverseLinkedList(head);\n\nconsole.log(\"Reversed List:\");\ntemp = reversedHead;\nvalues = [];\nwhile (temp !== null) { values.push(temp.value); temp = temp.next; }\nconsole.log(values); // [6, 5, 4, 3, 2, 1]\n\nconst middleOfReversed = findMiddle(reversedHead);\nconsole.log(\"Middle of Reversed List:\", middleOfReversed); // Expected: 4\n\n// Test with odd length list\nconst headOdd = new ListNode(10);\nheadOdd.next = new ListNode(20);\nheadOdd.next.next = new ListNode(30);\nconst reversedOdd = reverseLinkedList(headOdd);\nconst middleOfReversedOdd = findMiddle(reversedOdd);\nconsole.log(\"Middle of Reversed Odd List:\", middleOfReversedOdd); // Expected: 20\n",
          "testCases": [
            "reverseLinkedList(null) should return null.",
            "reverseLinkedList(new ListNode(1)) should return a list with value 1.",
            "reverseLinkedList(1->2->3) should return 3->2->1.",
            "findMiddle(null) should return null.",
            "findMiddle(new ListNode(1)) should return 1.",
            "findMiddle(1->2->3) should return 2.",
            "findMiddle(1->2->3->4) should return 3 (second middle).",
            "Demonstrate `findMiddle` on the output of `reverseLinkedList` for a list like 1->2->3->4->5->6. Expected output for middle of reversed list: 4."
          ],
          "hints": [
            "For `reverseLinkedList`, remember the three-pointer technique (`prev`, `current`, `next`).",
            "For `findMiddle`, consider the 'slow and fast pointer' (or 'tortoise and hare') approach to traverse the list in a single pass.",
            "Pay attention to the definition of 'middle' for even-length lists in `findMiddle`."
          ],
          "tags": [
            "linked-lists",
            "data-structures",
            "algorithms",
            "pointers"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "linked-list-reverse-iterative-theory"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "floyds-cycle-finding",
            "merge-two-sorted-lists"
          ]
        },
        {
          "id": "task_tree_traversal_1",
          "title": "Implement All Iterative Tree Traversals",
          "description": "\nImplement three functions for a binary tree using an iterative approach (without recursion). Each function should return an array of node values in the specified traversal order.\n\n1.  `preorderTraversalIterative(root)`: Root -> Left -> Right\n2.  `inorderTraversalIterative(root)`: Left -> Root -> Right\n3.  `postorderTraversalIterative(root)`: Left -> Right -> Root\n\nUse the `TreeNode` class provided below. Consider edge cases like an empty tree.\n",
          "difficulty": "hard",
          "startingCode": "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction preorderTraversalIterative(root) {\n  // TODO: Implement preorder iteratively\n  return [];\n}\n\nfunction inorderTraversalIterative(root) {\n  // TODO: Implement inorder iteratively\n  return [];\n}\n\nfunction postorderTraversalIterative(root) {\n  // TODO: Implement postorder iteratively\n  return [];\n}\n\n// Example Tree:\n//        1\n//       / \\\n//      2   3\n//     / \\n//    4   5\n// const root = new TreeNode(1);\n// root.left = new TreeNode(2);\n// root.right = new TreeNode(3);\n// root.left.left = new TreeNode(4);\n// root.left.right = new TreeNode(5);\n\n// console.log(\"Preorder:\", preorderTraversalIterative(root));\n// console.log(\"Inorder:\", inorderTraversalIterative(root));\n// console.log(\"Postorder:\", postorderTraversalIterative(root));\n",
          "solutionCode": "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction preorderTraversalIterative(root) {\n  if (!root) return [];\n  const result = [];\n  const stack = [root];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    result.push(node.value);\n    if (node.right) {\n      stack.push(node.right);\n    }\n    if (node.left) {\n      stack.push(node.left);\n    }\n  }\n  return result;\n}\n\nfunction inorderTraversalIterative(root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n  while (current !== null || stack.length > 0) {\n    while (current !== null) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop();\n    result.push(current.value);\n    current = current.right;\n  }\n  return result;\n}\n\nfunction postorderTraversalIterative(root) {\n  if (!root) return [];\n  const result = [];\n  const stack1 = [root]; // Main stack\n  const stack2 = [];    // Output stack (used for reversing order)\n\n  while (stack1.length > 0) {\n    const node = stack1.pop();\n    stack2.push(node.value); // Push to output stack\n\n    if (node.left) {\n      stack1.push(node.left);\n    }\n    if (node.right) {\n      stack1.push(node.right);\n    }\n  }\n  // Pop from stack2 to get in correct Postorder (Left-Right-Root)\n  while(stack2.length > 0) {\n      result.push(stack2.pop());\n  }\n  return result;\n}\n\n// Example Tree:\n//        1\n//       / \\\n//      2   3\n//     / \\n//    4   5\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(\"Preorder:\", preorderTraversalIterative(root));    // Expected: [1, 2, 4, 5, 3]\nconsole.log(\"Inorder:\", inorderTraversalIterative(root));      // Expected: [4, 2, 5, 1, 3]\nconsole.log(\"Postorder:\", postorderTraversalIterative(root));  // Expected: [4, 5, 2, 3, 1]\n\nconst emptyRoot = null;\nconsole.log(\"Preorder (empty):\", preorderTraversalIterative(emptyRoot)); // []\nconsole.log(\"Inorder (empty):\", inorderTraversalIterative(emptyRoot));   // []\nconsole.log(\"Postorder (empty):\", postorderTraversalIterative(emptyRoot)); // []\n",
          "testCases": [
            "preorderTraversalIterative(null) should return [].",
            "inorderTraversalIterative(null) should return [].",
            "postorderTraversalIterative(null) should return [].",
            "For a simple tree (1->2, 1->3), test all three traversals and verify output.",
            "For the provided example tree (1, 2, 3, 4, 5), `preorderTraversalIterative` should return `[1, 2, 4, 5, 3]`.",
            "For the provided example tree, `inorderTraversalIterative` should return `[4, 2, 5, 1, 3]`.",
            "For the provided example tree, `postorderTraversalIterative` should return `[4, 5, 2, 3, 1]`.",
            "Test with a tree that only has left children (e.g., 1->2->3) for all traversals.",
            "Test with a tree that only has right children (e.g., 1->2->3) for all traversals."
          ],
          "hints": [
            "All iterative traversals use a stack. The main difference lies in when you `push` children and when you `pop` and `visit` nodes.",
            "For Inorder, you typically traverse left as far as possible, pushing nodes onto the stack, then pop, visit, and move to the right.",
            "For Postorder, a common iterative trick involves using two stacks, or one stack and keeping track of the previously visited node to determine if a right child needs processing."
          ],
          "tags": [
            "trees",
            "data-structures",
            "algorithms",
            "stack",
            "traversal"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "tree-traversal-iterative-preorder-theory",
            "stack-data-structure"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "breadth-first-search",
            "binary-search-tree-operations"
          ]
        }
      ]
    }
  },
  {
    "id": "c0998467-3109-4f04-b332-06ee7ec8d2da",
    "startLine": 16100,
    "endLine": 16199,
    "processedDate": "2025-06-17T15:18:02.337Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_tree_preorder_traversal",
          "title": "Tree Traversal: Pre-order (Iterative)",
          "content": "Tree traversal is the process of visiting each node in a tree data structure exactly once. Pre-order traversal is a depth-first traversal strategy that visits the root node first, then recursively traverses the left subtree, and finally recursively traverses the right subtree. This order is commonly used to create a copy of the tree or to obtain a prefix expression of an expression tree.\n\nWhile pre-order traversal can be implemented recursively very naturally, an iterative approach is often preferred in certain scenarios (e.g., to avoid stack overflow for very deep trees or for better performance control).\n\n## Iterative Pre-order Traversal using a Stack\n\nThe iterative approach for pre-order traversal uses a stack data structure to keep track of nodes to visit. The general steps are:\n\n1.  Initialize an empty result list and an empty stack.\n2.  If the root is null, return the empty result list.\n3.  Push the root node onto the stack.\n4.  While the stack is not empty:\n    a.  Pop a node from the top of the stack. This is the `current` node.\n    b.  Add the `current` node's value to the result list.\n    c.  Push the `current` node's right child onto the stack (if it exists). This is pushed first because a stack is LIFO, so the right child will be processed *after* the left child.\n    d.  Push the `current` node's left child onto the stack (if it exists). This is pushed second, ensuring it's on top and processed next.\n5.  Return the result list.\n\nThis sequence ensures that the root is processed first, then its left child (and its subtree), and then its right child (and its subtree), mimicking the pre-order logic.",
          "examples": [
            {
              "id": "example_tree_preorder_1",
              "title": "Basic Iterative Pre-order Traversal",
              "code": "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction preorderTraversal(root) {\n  const result = [];\n  const stack = [];\n\n  if (!root) {\n    return result;\n  }\n\n  stack.push(root);\n\n  while (stack.length > 0) {\n    // Pop the top node from the stack\n    const current = stack.pop();\n\n    // Process the current node (add to result)\n    result.push(current.value);\n\n    // Push right child first (to process left child first since it's a stack)\n    if (current.right) {\n      stack.push(current.right);\n    }\n\n    // Push left child\n    if (current.left) {\n      stack.push(current.left);\n    }\n  }\n\n  return result;\n}\n\n// Example Usage:\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(preorderTraversal(root)); // Expected output: [1, 2, 4, 5, 3]",
              "explanation": "This example defines a `TreeNode` class and the `preorderTraversal` function which performs an iterative pre-order traversal. It uses a stack to manage the nodes. The key insight is pushing the right child before the left child, so that the left child is popped and processed first, adhering to the 'Root, Left, Right' order of pre-order traversal.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_tree_preorder_1",
            "question_tree_preorder_2",
            "question_tree_preorder_3",
            "question_tree_preorder_4",
            "question_tree_preorder_5"
          ],
          "relatedTasks": [
            "task_tree_traversal_implementations",
            "task_tree_serialization"
          ],
          "tags": [
            "data-structures",
            "trees",
            "traversal",
            "algorithms",
            "stack",
            "interview-prep"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "data_structures_basic",
            "stack_data_structure"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "binary_search_trees",
            "graph_traversal_dfs"
          ]
        },
        {
          "id": "theory_object_flattening",
          "title": "Object Operations: Flattening Deeply Nested Objects",
          "content": "Flattening a deeply nested object involves transforming an object with hierarchical structure into a single-level object, where keys represent the path to the original values. This is particularly useful for tasks like preparing data for forms, logging, serializing to specific formats, or simplifying data access.\n\n## Approach: Recursion with Dot Notation Concatenation\n\nThe most common way to flatten a nested object is using a recursive function that iterates through the object's keys. For each key:\n\n1.  **Construct the new key:** If a `prefix` (representing the path from the root) is provided, append the current key using dot notation (e.g., `prefix.key`). Otherwise, the current key is the new key.\n2.  **Check for nested objects:** If the value associated with the current key is itself an object (and not `null` and not an array, as arrays are usually treated as leaf values or handled specially):\n    a.  Recursively call the flattening function on this nested object, passing the `newKey` as the prefix.\n    b.  Merge the results of this recursive call into the main result object.\n3.  **Handle leaf values:** If the value is not a nested object, it's a leaf value. Add it directly to the result object with the `newKey`.\n\n`Object.keys()`, `Array.prototype.reduce()`, and `Object.assign()` (or spread syntax `{...result, ...flattenedNestedObject}`) are powerful JavaScript tools that facilitate this process.",
          "examples": [
            {
              "id": "example_object_flattening_1",
              "title": "Basic Object Flattening",
              "code": "function flattenObject(obj, prefix = '') {\n  return Object.keys(obj).reduce((result, key) => {\n    const newKey = prefix ? `${prefix}.${key}` : key;\n    \n    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {\n      // Recursively flatten nested objects\n      Object.assign(result, flattenObject(obj[key], newKey));\n    } else {\n      // Add leaf values to the result\n      result[newKey] = obj[key];\n    }\n    \n    return result;\n  }, {});\n}\n\n// Example Usage:\nconst nestedObject = {\n  level1: {\n    level2: {\n      level3: {\n        value: 'deep value',\n        another: 'another deep value'\n      }\n    },\n    value: 'not so deep'\n  },\n  topLevel: 'top level value',\n  arr: [1, 2, { a: 3 }],\n  empty: null\n};\n\nconst flattened = flattenObject(nestedObject);\nconsole.log(flattened);\n/* Expected Result:\n{\n  'level1.level2.level3.value': 'deep value',\n  'level1.level2.level3.another': 'another deep value',\n  'level1.value': 'not so deep',\n  'topLevel': 'top level value',\n  'arr': [1, 2, { a: 3 }],\n  'empty': null\n}\n*/",
              "explanation": "This function demonstrates a common recursive pattern for flattening objects. It iterates over the keys of the input object. If a value is another object (but not an array or null), it recursively calls itself to flatten that sub-object. The `prefix` argument builds the dot-separated path for each key. Non-object values (including arrays and null) are added directly.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_object_flatten_1",
            "question_object_flatten_2",
            "question_object_flatten_3",
            "question_object_flatten_4",
            "question_object_flatten_5"
          ],
          "relatedTasks": [
            "task_flatten_object_enhanced",
            "task_unflatten_object"
          ],
          "tags": [
            "objects",
            "recursion",
            "data-transformation",
            "javascript",
            "interview-prep"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "recursion_basics",
            "array_reduce"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "form_data_processing",
            "api_serialization"
          ]
        },
        {
          "id": "theory_system_design_parking_lot",
          "title": "System Design: Parking Lot Management System",
          "content": "Designing a parking lot system involves managing available parking spaces, handling vehicle entry and exit, and potentially supporting various vehicle types, pricing models, and query functionalities. It's a common system design interview question that tests your ability to think about data structures, algorithms, and system architecture.\n\n## Core Components and Functionalities:\n\n1.  **Parking Lot:** Represents the physical parking area with a defined capacity.\n2.  **Parking Slots:** Individual spaces within the parking lot. Each slot might have properties like `isOccupied`, `vehicleType` allowed, and potentially a `vehicle` object occupying it.\n3.  **Vehicle:** Objects representing cars, motorcycles, or buses, with properties like `licensePlate`, `entryTime`, `type`.\n4.  **Operations:**\n    *   `parkVehicle(vehicle)`: Assigns a vehicle to an available slot, marks the slot as occupied, and records entry time.\n    *   `unparkVehicle(licensePlate)`: Frees up a slot occupied by a specific vehicle, calculates parking fees, and updates availability.\n    *   `getAvailableSlots(vehicleType)`: Returns the number of or specific IDs of available slots for a given vehicle type.\n    *   `getOccupiedSlots()`: Lists currently occupied slots.\n\n## Data Structures for Efficiency:\n\n*   **Array/List for Slots:** An array can represent the `N` slots, where `slots[i]` holds `null` if empty or a `Vehicle` object if occupied. This allows for direct access by slot number.\n*   **Set for Available Slots:** A `Set` (or a `Min-Heap` if closest/lowest slot number is desired) can efficiently track `availableSlots` for O(1) average-time addition and deletion of slot numbers. Categorizing by vehicle type (e.g., `Map<VehicleType, Set<SlotId>>`) would enhance this.\n*   **Map for Occupied Vehicles:** A `Map<LicensePlate, SlotId>` can quickly locate a vehicle's slot given its license plate for `unparkVehicle` operations. A `Map<SlotId, VehicleObject>` could store the actual vehicle object.\n\n## Key Design Considerations:\n\n*   **Scalability:** How to handle multiple parking lots, or a very large parking lot.\n*   **Concurrency:** How to manage multiple vehicles trying to park/unpark simultaneously.\n*   **Pricing Model:** Flat rate, hourly, tiered pricing based on duration or vehicle type.\n*   **Ticket System:** Generating and validating tickets.\n*   **Vehicle Types:** Different types of vehicles might require different slot sizes or have different pricing.\n*   **Reporting:** Historical data, occupancy rates.",
          "examples": [
            {
              "id": "example_parking_lot_system_1",
              "title": "Basic ParkingLot Class Structure",
              "code": "class Vehicle {\n  constructor(licensePlate, type) {\n    this.licensePlate = licensePlate;\n    this.type = type; // e.g., 'car', 'motorcycle', 'bus'\n    this.entryTime = Date.now();\n  }\n}\n\nclass ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null); // null means empty, else stores Vehicle object\n    this.availableSlots = new Set(Array.from({ length: capacity }, (_, i) => i)); // Stores indices of available slots\n    this.occupiedVehiclesMap = new Map(); // Map: licensePlate -> slotIndex\n    this.slotToVehicleMap = new Map(); // Map: slotIndex -> Vehicle object\n  }\n\n  _findAvailableSlot() {\n    if (this.availableSlots.size === 0) {\n      return -1; // No slots available\n    }\n    // For simplicity, just take the first available slot. \n    // In real-world, might need logic for specific types or nearest slot.\n    const slotIndex = this.availableSlots.values().next().value;\n    return slotIndex;\n  }\n\n  parkVehicle(vehicle) {\n    if (this.occupiedVehiclesMap.has(vehicle.licensePlate)) {\n      console.log(`Vehicle ${vehicle.licensePlate} is already parked.`);\n      return null;\n    }\n    const slotIndex = this._findAvailableSlot();\n    if (slotIndex === -1) {\n      console.log('Sorry, parking lot is full.');\n      return null;\n    }\n\n    this.slots[slotIndex] = vehicle; // Assign vehicle to slot\n    this.availableSlots.delete(slotIndex); // Remove from available set\n    this.occupiedVehiclesMap.set(vehicle.licensePlate, slotIndex); // Map plate to slot\n    this.slotToVehicleMap.set(slotIndex, vehicle); // Map slot to vehicle\n\n    console.log(`Vehicle ${vehicle.licensePlate} (${vehicle.type}) parked at slot ${slotIndex + 1}.`);\n    return slotIndex;\n  }\n\n  unparkVehicle(licensePlate) {\n    if (!this.occupiedVehiclesMap.has(licensePlate)) {\n      console.log(`Vehicle ${licensePlate} not found in parking lot.`);\n      return null;\n    }\n\n    const slotIndex = this.occupiedVehiclesMap.get(licensePlate);\n    const vehicle = this.slotToVehicleMap.get(slotIndex);\n\n    this.slots[slotIndex] = null; // Free up slot\n    this.availableSlots.add(slotIndex); // Add back to available set\n    this.occupiedVehiclesMap.delete(licensePlate); // Remove from maps\n    this.slotToVehicleMap.delete(slotIndex);\n\n    const duration = (Date.now() - vehicle.entryTime) / (1000 * 60 * 60); // duration in hours\n    const fee = Math.ceil(duration) * 5; // Example: $5 per hour\n\n    console.log(`Vehicle ${licensePlate} unparked from slot ${slotIndex + 1}. Duration: ${duration.toFixed(2)} hours. Fee: $${fee}.`);\n    return { vehicle, fee };\n  }\n\n  getAvailableSlotsCount() {\n    return this.availableSlots.size;\n  }\n\n  getOccupiedSlotsInfo() {\n    return Array.from(this.slotToVehicleMap.entries()).map(([slot, vehicle]) => `Slot ${slot + 1}: ${vehicle.licensePlate} (${vehicle.type})`);\n  }\n}\n\n// Example Usage:\nconst lot = new ParkingLot(5);\nconsole.log(`Initial available slots: ${lot.getAvailableSlotsCount()}`); // 5\n\nconst car1 = new Vehicle('ABC-123', 'car');\nlot.parkVehicle(car1);\n\nconst motorcycle1 = new Vehicle('MOTO-456', 'motorcycle');\nlot.parkVehicle(motorcycle1);\n\nconsole.log(`Available slots: ${lot.getAvailableSlotsCount()}`); // 3\nconsole.log('Occupied slots:', lot.getOccupiedSlotsInfo());\n\n// Simulate time passing\nsetTimeout(() => {\n  lot.unparkVehicle('ABC-123');\n  console.log(`Available slots after unparking: ${lot.getAvailableSlotsCount()}`); // 4\n}, 1000);",
              "explanation": "This example provides a foundational `ParkingLot` class. It demonstrates the use of an array (`slots`) to represent physical slots, a `Set` (`availableSlots`) for efficient tracking of free slots, and `Maps` (`occupiedVehiclesMap`, `slotToVehicleMap`) for quick lookups by license plate or slot index. It includes basic `parkVehicle` and `unparkVehicle` methods with simple fee calculation.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_parking_lot_1",
            "question_parking_lot_2",
            "question_parking_lot_3",
            "question_parking_lot_4",
            "question_parking_lot_5"
          ],
          "relatedTasks": [
            "task_parking_lot_full_design",
            "task_parking_lot_fee_calculator"
          ],
          "tags": [
            "system-design",
            "object-oriented-programming",
            "data-structures",
            "algorithms",
            "interview-prep"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "object_oriented_programming",
            "data_structures_basic",
            "maps_sets"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "large_scale_applications",
            "backend_system_design"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_tree_preorder_1",
          "topic": "Tree Traversal: Pre-order",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the order of visiting nodes in a pre-order tree traversal?",
          "answer": "Root -> Left Subtree -> Right Subtree",
          "options": [],
          "analysisPoints": [
            "Tests basic knowledge of tree traversal orders.",
            "Highlights the 'Root-first' nature of pre-order traversal."
          ],
          "keyConcepts": [
            "pre-order traversal",
            "tree traversal",
            "root node",
            "left subtree",
            "right subtree"
          ],
          "evaluationCriteria": [
            "Ability to recall definitions"
          ],
          "example": "Pre-order traversal is often used to create a prefix expression of an expression tree.",
          "tags": [
            "trees",
            "traversal",
            "flashcard"
          ],
          "prerequisites": [
            "tree_data_structure"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_tree_preorder_2",
          "topic": "Tree Traversal: Pre-order (Iterative)",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following binary tree:\n```\n    A\n   / \\\n  B   C\n / \\\nD   E\n```\nWhich of the following sequences represents a pre-order traversal of the tree?",
          "answer": "A, B, D, E, C",
          "options": [
            "D, B, E, A, C",
            "A, B, D, E, C",
            "D, E, B, C, A",
            "A, C, B, D, E"
          ],
          "analysisPoints": [
            "Tests understanding of pre-order traversal sequence.",
            "Requires applying the 'Root, Left, Right' rule.",
            "Distinguishes from in-order and post-order sequences."
          ],
          "keyConcepts": [
            "pre-order traversal",
            "binary tree",
            "traversal sequence"
          ],
          "evaluationCriteria": [
            "Ability to apply traversal rules to a given tree"
          ],
          "example": "A pre-order traversal starts at the root, then explores the entire left subtree, and finally the entire right subtree. For node B, its left child D is visited before its right child E.",
          "tags": [
            "trees",
            "traversal",
            "mcq"
          ],
          "prerequisites": [
            "tree_data_structure",
            "pre_order_traversal_concept"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_tree_preorder_3",
          "topic": "Tree Traversal: Iterative Pre-order",
          "level": "hard",
          "type": "code",
          "question": "Implement the `inorderTraversal` function iteratively for a binary tree. You are given the `TreeNode` class definition. The function should return an array of node values in in-order sequence.\n\n```javascript\nclass TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction inorderTraversal(root) {\n  // Your implementation here\n}\n\n// Example Usage:\nconst root = new TreeNode(1);\nroot.right = new TreeNode(2);\nroot.right.left = new TreeNode(3);\n\n// inorderTraversal(root) should return [1, 3, 2]\n```",
          "answer": "// Solution for inorderTraversal iteratively\nclass TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction inorderTraversal(root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n\n  while (current !== null || stack.length > 0) {\n    // Traverse to the leftmost node, pushing nodes onto stack along the way\n    while (current !== null) {\n      stack.push(current);\n      current = current.left;\n    }\n    \n    // Pop a node from stack (this is the leftmost unvisited node)\n    current = stack.pop();\n    result.push(current.value);\n\n    // Move to the right child to process its subtree\n    current = current.right;\n  }\n\n  return result;\n}",
          "options": [],
          "analysisPoints": [
            "Tests ability to adapt iterative traversal logic for different orders.",
            "Requires correct use of stack and handling of `null` nodes.",
            "Assesses understanding of the 'Left, Root, Right' order for in-order."
          ],
          "keyConcepts": [
            "in-order traversal",
            "iterative traversal",
            "stack",
            "binary tree"
          ],
          "evaluationCriteria": [
            "Correctness of the algorithm.",
            "Efficiency (time and space complexity).",
            "Handling edge cases like empty tree or single-node tree."
          ],
          "example": "In-order traversal, especially iteratively, is more complex than pre-order because the root is visited in between its left and right subtrees. This requires keeping track of visited nodes and those yet to be fully processed on the stack.",
          "tags": [
            "trees",
            "traversal",
            "algorithms",
            "coding-challenge"
          ],
          "prerequisites": [
            "tree_data_structure",
            "stack_data_structure",
            "pre_order_traversal_iterative"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_tree_preorder_4",
          "topic": "Tree Traversal: DFS vs BFS",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast Depth-First Search (DFS) traversals (pre-order, in-order, post-order) with Breadth-First Search (BFS) (level-order traversal) in terms of their typical use cases, time complexity, and space complexity for a binary tree. When would you prefer one over the other?",
          "answer": "Depth-First Search (DFS) traversals (pre-order, in-order, post-order) explore as far as possible along each branch before backtracking. They typically use a stack (iterative) or recursion (implicit stack).\n\n*   **Pre-order (Root, Left, Right):** Used for creating a copy of the tree, prefix expressions.\n*   **In-order (Left, Root, Right):** Used for sorted output in Binary Search Trees, infix expressions.\n*   **Post-order (Left, Right, Root):** Used for deleting a tree, postfix expressions.\n\n**Time Complexity (DFS):** O(N), where N is the number of nodes, as each node is visited once.\n**Space Complexity (DFS):** O(H), where H is the height of the tree, due to the stack (or recursion call stack). In the worst case (skewed tree), H can be N.\n\nBreadth-First Search (BFS), or level-order traversal, explores all nodes at the current depth level before moving on to nodes at the next depth level. It typically uses a queue.\n\n*   **Level-order:** Used for finding the shortest path in an unweighted graph, processing nodes level by level (e.g., UI elements in a tree structure).\n\n**Time Complexity (BFS):** O(N), where N is the number of nodes, as each node is visited once.\n**Space Complexity (BFS):** O(W), where W is the maximum width of the tree (max number of nodes at any level). In the worst case (complete binary tree), W can be N/2, so O(N).\n\n**When to prefer:**\n*   **DFS:** Preferred for problems that require exploring all paths from a source to a target (e.g., finding a specific node deep in the tree), or if space is a major concern (for balanced trees where H << N). Also, when the order of processing (pre, in, post) is crucial for the problem's logic.\n*   **BFS:** Preferred for finding the shortest path in an unweighted tree/graph, or when processing nodes level by level is required (e.g., finding all nodes at a certain depth, or for social network 'friends of friends' problems).",
          "options": [],
          "analysisPoints": [
            "Requires understanding of both DFS and BFS principles.",
            "Ability to articulate typical use cases for each.",
            "Correctly identifies and compares time and space complexities.",
            "Provides insights into when to choose one over the other based on problem constraints."
          ],
          "keyConcepts": [
            "DFS",
            "BFS",
            "pre-order",
            "in-order",
            "post-order",
            "level-order",
            "time complexity",
            "space complexity",
            "stack",
            "queue"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison.",
            "Accuracy of complexity analysis.",
            "Relevance of use cases.",
            "Clear explanation of decision factors."
          ],
          "example": "While both DFS and BFS visit all nodes in O(N) time, their memory consumption can differ significantly depending on the tree's shape. A very deep, narrow tree favors BFS in terms of worst-case space, while a wide, shallow tree favors DFS.",
          "tags": [
            "trees",
            "traversal",
            "algorithms",
            "complexity",
            "system-design"
          ],
          "prerequisites": [
            "tree_traversal_basics",
            "stack_data_structure",
            "queue_data_structure",
            "big_o_notation"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_tree_preorder_5",
          "topic": "Tree Traversal",
          "level": "easy",
          "type": "flashcard",
          "question": "What data structure is commonly used to implement iterative Depth-First Search (DFS) traversals like pre-order, in-order, or post-order?",
          "answer": "A Stack",
          "options": [],
          "analysisPoints": [
            "Tests recall of fundamental data structures in algorithm implementations.",
            "Connects the concept of DFS with its typical iterative implementation."
          ],
          "keyConcepts": [
            "DFS",
            "iterative traversal",
            "stack"
          ],
          "evaluationCriteria": [
            "Direct recall of knowledge"
          ],
          "example": "The LIFO (Last-In, First-Out) nature of a stack naturally supports the 'go deep first' strategy of DFS.",
          "tags": [
            "data-structures",
            "trees",
            "algorithms",
            "flashcard"
          ],
          "prerequisites": [
            "stack_data_structure",
            "tree_traversal_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_flatten_1",
          "topic": "Object Flattening",
          "level": "medium",
          "type": "mcq",
          "question": "Given the `flattenObject` function:\n```javascript\nfunction flattenObject(obj, prefix = '') {\n  return Object.keys(obj).reduce((result, key) => {\n    const newKey = prefix ? `${prefix}.${key}` : key;\n    \n    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {\n      Object.assign(result, flattenObject(obj[key], newKey));\n    } else {\n      result[newKey] = obj[key];\n    }\n    \n    return result;\n  }, {});\n}\n\nconst input = {\n  a: 1,\n  b: {\n    c: 2,\n    d: {\n      e: 3\n    }\n  },\n  f: 'test'\n};\n\n```\nWhat will be the output of `flattenObject(input)`?",
          "answer": "{\n  'a': 1,\n  'b.c': 2,\n  'b.d.e': 3,\n  'f': 'test'\n}",
          "options": [
            "{\n  'a': 1,\n  'b': { 'c': 2, 'd': { 'e': 3 } },\n  'f': 'test'\n}",
            "{\n  'a': 1,\n  'b.c': 2,\n  'b.d.e': 3,\n  'f': 'test'\n}",
            "{\n  'a': 1,\n  'c': 2,\n  'e': 3,\n  'f': 'test'\n}",
            "{\n  'a': 1,\n  'b_c': 2,\n  'b_d_e': 3,\n  'f': 'test'\n}"
          ],
          "analysisPoints": [
            "Tests understanding of recursive object flattening.",
            "Verifies correct key concatenation using dot notation.",
            "Ensures correct handling of nested objects versus primitive values."
          ],
          "keyConcepts": [
            "object flattening",
            "recursion",
            "dot notation",
            "Object.keys",
            "Array.prototype.reduce"
          ],
          "evaluationCriteria": [
            "Ability to trace recursive function execution",
            "Correctly predict output of data transformation"
          ],
          "example": "The function recursively descends into `b`, then into `b.d`, building the full path 'b.d.e' for the value 3. `a` and `f` are top-level and retain their original keys.",
          "tags": [
            "objects",
            "recursion",
            "data-transformation",
            "mcq"
          ],
          "prerequisites": [
            "javascript_objects",
            "recursion_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_flatten_2",
          "topic": "Object Flattening",
          "level": "hard",
          "type": "code",
          "question": "Modify the `flattenObject` function to handle arrays. If a value is an array, its elements should be flattened with bracket notation (e.g., `parent.array[0]`, `parent.array[1].nested`).\n\n```javascript\nfunction flattenObject(obj, prefix = '') {\n  return Object.keys(obj).reduce((result, key) => {\n    const newKey = prefix ? `${prefix}.${key}` : key;\n    \n    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {\n      Object.assign(result, flattenObject(obj[key], newKey));\n    } else {\n      result[newKey] = obj[key];\n    }\n    \n    return result;\n  }, {});\n}\n\n// Example Input:\nconst nestedObjectWithArray = {\n  name: 'Test',\n  details: {\n    items: [\n      { id: 1, value: 'A' },\n      { id: 2, value: 'B' }\n    ],\n    tags: ['red', 'blue']\n  },\n  data: [10, 20]\n};\n\n// Expected Output:\n/*\n{\n  'name': 'Test',\n  'details.items[0].id': 1,\n  'details.items[0].value': 'A',\n  'details.items[1].id': 2,\n  'details.items[1].value': 'B',\n  'details.tags[0]': 'red',\n  'details.tags[1]': 'blue',\n  'data[0]': 10,\n  'data[1]': 20\n}\n*/\n```",
          "answer": "```javascript\nfunction flattenObject(obj, prefix = '') {\n  return Object.keys(obj).reduce((result, key) => {\n    const currentVal = obj[key];\n    const newKey = prefix ? `${prefix}.${key}` : key;\n\n    if (typeof currentVal === 'object' && currentVal !== null) {\n      if (Array.isArray(currentVal)) {\n        // Handle arrays by iterating over elements\n        currentVal.forEach((item, index) => {\n          // Recursively flatten array elements, using bracket notation for key\n          const arrayElementKey = `${newKey}[${index}]`;\n          if (typeof item === 'object' && item !== null) {\n            Object.assign(result, flattenObject(item, arrayElementKey));\n          } else {\n            result[arrayElementKey] = item;\n          }\n        });\n      } else {\n        // Handle nested objects\n        Object.assign(result, flattenObject(currentVal, newKey));\n      }\n    } else {\n      // Add leaf values (primitives, null, undefined)\n      result[newKey] = currentVal;\n    }\n    \n    return result;\n  }, {});\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to extend recursive logic to handle different data types (arrays).",
            "Requires careful construction of keys using bracket notation for array elements.",
            "Assesses understanding of how to recursively flatten elements within an array if they are objects."
          ],
          "keyConcepts": [
            "object flattening",
            "recursion",
            "array iteration",
            "bracket notation",
            "Object.assign"
          ],
          "evaluationCriteria": [
            "Correct handling of array types.",
            "Accurate generation of flattened keys for array elements.",
            "Preservation of existing object flattening logic.",
            "Edge case handling (empty arrays, arrays of primitives/objects)."
          ],
          "example": "The key challenge is to distinguish between objects and arrays, and for arrays, to iterate over their elements and apply the flattening logic, dynamically generating keys like `parent.array[index]`.",
          "tags": [
            "objects",
            "recursion",
            "data-transformation",
            "coding-challenge",
            "arrays"
          ],
          "prerequisites": [
            "object_flattening_basic",
            "javascript_arrays"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_flatten_3",
          "topic": "Object Flattening",
          "level": "medium",
          "type": "open",
          "question": "What are the advantages and disadvantages of flattening an object into a single-level structure using dot notation (e.g., `parent.child.value`)?",
          "answer": "Advantages:\n1.  **Simplified Access:** All values become directly accessible without multiple levels of property access (e.g., `obj['parent.child.value']` instead of `obj.parent.child.value`). This can simplify certain algorithms or data processing.\n2.  **Serialization/Deserialization:** Easily maps to formats that prefer flat structures, like query parameters (URLSearchParams), form data, or some NoSQL database entries.\n3.  **Data Uniformity:** Provides a consistent structure, which can be beneficial for validation, filtering, or display in tabular formats.\n4.  **Debugging/Logging:** Can make it easier to log or inspect all values in a complex object at a glance.\n\nDisadvantages:\n1.  **Loss of Hierarchy:** The original semantic structure and relationships between nested objects are lost, which might make the data harder to reason about or process if the hierarchy is important.\n2.  **Key Name Collisions:** If original keys contain dots, or if generated flattened keys collide with existing keys or paths, it can lead to unexpected behavior or require complex escaping strategies.\n3.  **Increased Key Length:** Keys can become very long, potentially consuming more memory or making the flattened object less readable.\n4.  **Reconstruction Complexity:** Un-flattening the object back to its original nested structure can be more complex than flattening it.",
          "options": [],
          "analysisPoints": [
            "Requires critical thinking about data representation.",
            "Identifies practical benefits and drawbacks of a common data transformation.",
            "Discusses implications for data integrity and usability."
          ],
          "keyConcepts": [
            "object flattening",
            "data structure design",
            "pros and cons",
            "data serialization"
          ],
          "evaluationCriteria": [
            "Balanced perspective on advantages and disadvantages.",
            "Clear and concise explanations for each point.",
            "Identification of relevant real-world implications."
          ],
          "example": "Consider a UI where user input from a deeply nested form is sent to an API. Flattening the object simplifies preparing the data for a `FormData` object, but if the API expects a nested JSON structure, it would need to be un-flattened on the backend.",
          "tags": [
            "objects",
            "data-transformation",
            "system-design",
            "open-ended"
          ],
          "prerequisites": [
            "javascript_objects",
            "data_structures_basic"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_flatten_4",
          "topic": "Object Flattening",
          "level": "easy",
          "type": "flashcard",
          "question": "What JavaScript method is commonly used to iterate over the own enumerable properties of an object and is useful in object flattening functions?",
          "answer": "`Object.keys()`",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of fundamental JavaScript object methods.",
            "Connects a specific method to its practical application in object processing."
          ],
          "keyConcepts": [
            "Object.keys()",
            "object iteration",
            "enumerable properties"
          ],
          "evaluationCriteria": [
            "Direct recall of knowledge"
          ],
          "example": "`Object.keys(obj)` returns an array of a given object's own enumerable string-keyed property names.",
          "tags": [
            "javascript",
            "objects",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_objects_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_flatten_5",
          "topic": "Object Flattening",
          "level": "hard",
          "type": "open",
          "question": "Design an `unflattenObject` function that takes a flattened object (e.g., `{'a.b.c': 1, 'd.e': 2}`) and reconstructs its original nested structure. Consider edge cases like invalid paths or arrays (if you've handled them in flattening).",
          "answer": "```javascript\nfunction unflattenObject(flattenedObj) {\n  const result = {};\n\n  for (const key in flattenedObj) {\n    const value = flattenedObj[key];\n    const parts = key.split('.');\n    let current = result;\n\n    for (let i = 0; i < parts.length; i++) {\n      let part = parts[i];\n      \n      // Check for array notation like 'key[index]'\n      const arrayMatch = part.match(/(.*)\\[(\\d+)\\]$/);\n      if (arrayMatch) {\n        const arrayKey = arrayMatch[1];\n        const index = parseInt(arrayMatch[2], 10);\n\n        if (!current[arrayKey]) {\n          current[arrayKey] = [];\n        }\n        if (!Array.isArray(current[arrayKey])) {\n          // Handle collision: if arrayKey already exists and is not an array\n          console.warn(`Path collision: '${arrayKey}' is not an array but key '${key}' expects it to be.`);\n          // Decide how to handle: overwrite, skip, or throw error\n          current[arrayKey] = []; // Force to array\n        }\n        \n        // If this is the last part, assign the value\n        if (i === parts.length - 1) {\n          current[arrayKey][index] = value;\n        } else {\n          // If not last part, ensure nested object/array exists\n          if (!current[arrayKey][index] || typeof current[arrayKey][index] !== 'object' || Array.isArray(current[arrayKey][index])) {\n            current[arrayKey][index] = {};\n          }\n          current = current[arrayKey][index];\n        }\n\n      } else { // Regular object key\n        if (i === parts.length - 1) {\n          current[part] = value;\n        } else {\n          if (!current[part] || typeof current[part] !== 'object' || Array.isArray(current[part])) {\n            current[part] = {};\n          }\n          current = current[part];\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// Example Usage:\nconst flattened = {\n  'level1.level2.level3.value': 'deep value',\n  'level1.level2.level3.another': 'another deep value',\n  'level1.value': 'not so deep',\n  'topLevel': 'top level value',\n  'details.items[0].id': 1,\n  'details.items[0].value': 'A',\n  'details.items[1].id': 2,\n  'details.items[1].value': 'B',\n  'details.tags[0]': 'red',\n  'details.tags[1]': 'blue',\n  'data[0]': 10,\n  'data[1]': 20\n};\n\nconst unflattened = unflattenObject(flattened);\nconsole.log(JSON.stringify(unflattened, null, 2));\n/* Expected Output:\n{\n  \"level1\": {\n    \"level2\": {\n      \"level3\": {\n        \"value\": \"deep value\",\n        \"another\": \"another deep value\"\n      }\n    },\n    \"value\": \"not so deep\"\n  },\n  \"topLevel\": \"top level value\",\n  \"details\": {\n    \"items\": [\n      {\n        \"id\": 1,\n        \"value\": \"A\"\n      },\n      {\n        \"id\": 2,\n        \"value\": \"B\"\n      }\n    ],\n    \"tags\": [\n      \"red\",\n      \"blue\"\n    ]\n  },\n  \"data\": [\n    10,\n    20\n  ]\n}\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to reverse a complex data transformation.",
            "Requires parsing complex string keys (dot notation and bracket notation).",
            "Challenges handling dynamic object/array creation during reconstruction.",
            "Forces consideration of potential path collisions or type mismatches."
          ],
          "keyConcepts": [
            "object reconstruction",
            "string parsing",
            "dynamic object creation",
            "array handling",
            "edge cases"
          ],
          "evaluationCriteria": [
            "Correctness of nested object/array reconstruction.",
            "Robustness in handling various key formats.",
            "Efficiency of the reconstruction process.",
            "Consideration of potential errors or warnings for malformed flattened objects."
          ],
          "example": "The core logic involves splitting each flattened key by '.' and then iteratively traversing/creating the nested structure. Special handling is needed for array elements indicated by `[index]` in the key.",
          "tags": [
            "objects",
            "data-transformation",
            "algorithms",
            "coding-challenge"
          ],
          "prerequisites": [
            "object_flattening_basic",
            "javascript_strings",
            "javascript_objects_advanced"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_parking_lot_1",
          "topic": "System Design: Parking Lot",
          "level": "medium",
          "type": "mcq",
          "question": "In a parking lot system, which data structure would be most efficient for quickly finding and removing an available parking slot, ensuring O(1) average time complexity for these operations?",
          "answer": "Set",
          "options": [
            "Array (linear scan)",
            "Linked List",
            "Set",
            "Queue"
          ],
          "analysisPoints": [
            "Tests knowledge of data structure efficiency for specific operations.",
            "Highlights the O(1) average time complexity of Sets for add/delete/check existence.",
            "Differentiates from other structures that would involve linear time for finding/removing by value (Array, Linked List) or only offer specific order (Queue)."
          ],
          "keyConcepts": [
            "data structures",
            "Set",
            "time complexity",
            "parking lot system",
            "available slots"
          ],
          "evaluationCriteria": [
            "Correct selection of optimal data structure",
            "Understanding of Big O notation"
          ],
          "example": "A Set allows for very fast `add()`, `delete()`, and `has()` operations on average. If we store the indices of available slots in a Set, we can quickly pick one (e.g., `set.values().next().value`) and remove it.",
          "tags": [
            "system-design",
            "data-structures",
            "mcq"
          ],
          "prerequisites": [
            "data_structures_basic",
            "big_o_notation"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_parking_lot_2",
          "topic": "System Design: Parking Lot",
          "level": "hard",
          "type": "open",
          "question": "How would you extend the basic `ParkingLot` design to support different types of vehicles (e.g., motorcycles, cars, buses) where each type might require a different size or type of parking slot, and potentially have different hourly rates?",
          "answer": "To support different vehicle types and varying slot requirements/rates, the `ParkingLot` system would need the following extensions:\n\n1.  **Vehicle Type Enum/Constant:** Define vehicle types (e.g., `VehicleType.MOTORCYCLE`, `VehicleType.CAR`, `VehicleType.BUS`).\n\n2.  **Slot Types:** Introduce `Slot` objects or separate arrays/maps for different slot types. Each `Slot` object could have properties like `id`, `size`, `allowedVehicleTypes`, `isOccupied`.\n    *   **Motorcycle Slot:** Smallest, can only fit motorcycles.\n    *   **Compact Slot:** Fits cars and motorcycles.\n    *   **Large Slot:** Fits cars, motorcycles, and potentially small buses.\n    *   **Bus Slot:** Largest, specifically for buses, possibly allowing smaller vehicles if no specific compact/large slots are available (policy dependent).\n\n3.  **Tiered Slot Management:** Instead of a single `availableSlots` set, use a `Map<VehicleType, Set<SlotIndex>>` or `Map<SlotType, Set<SlotIndex>>` to track available slots for each category. For example:\n    ```javascript\n    this.availableSlotsByType = {\n      [VehicleType.MOTORCYCLE]: new Set(),\n      [VehicleType.CAR]: new Set(), // This would be for compact/standard car slots\n      [VehicleType.BUS]: new Set()\n    };\n    // Or more granular: Map<SlotType, Set<SlotIndex>>\n    this.availableSlotsByPhysicalType = {\n      'motorcycle_only': new Set(),\n      'compact': new Set(),\n      'large': new Set(),\n      'bus_specific': new Set()\n    };\n    ```\n\n4.  **`parkVehicle` Logic Enhancement:**\n    *   When a vehicle arrives, first try to find the most specific slot for its type.\n    *   If no specific slot is available, check if it can fit into larger, more general slots (e.g., a motorcycle can park in a car slot if no motorcycle-specific slot is free).\n    *   This might involve a prioritized search order (e.g., motorcycle -> compact -> large for a motorcycle).\n\n5.  **Pricing Model:**\n    *   Introduce a `PricingStrategy` class or a simple `Map<VehicleType, Rate>`.\n    *   `Map<VehicleType, { hourlyRate: number, firstHourRate?: number, dailyRate?: number }>`. This map would define the specific pricing rules for each vehicle type.\n    *   The `unparkVehicle` method would then look up the appropriate rate based on `vehicle.type` and `duration`.\n\n6.  **Ticket System (Optional but good):** Generate a unique ticket ID on entry, store vehicle info and entry time. On exit, validate the ticket. This separates the physical slot management from the transaction.\n\nThis approach allows for flexible allocation, efficient lookup of suitable slots, and dynamic pricing based on vehicle characteristics.",
          "options": [],
          "analysisPoints": [
            "Tests ability to handle complexity and extend a basic design.",
            "Requires designing for different data types and their interactions.",
            "Demonstrates understanding of flexible system architecture (e.g., using enums, mapping strategies).",
            "Considers practical scenarios like slot hierarchy and pricing variations."
          ],
          "keyConcepts": [
            "system design",
            "object-oriented programming",
            "vehicle types",
            "slot management",
            "pricing models",
            "data modeling"
          ],
          "evaluationCriteria": [
            "Completeness of proposed solution.",
            "Clarity of data structure choices.",
            "Logical flow of operational changes (e.g., `parkVehicle` logic).",
            "Consideration of edge cases and scalability."
          ],
          "example": "A concrete example could be: a `Motorcycle` object attempts to park. The system first checks `availableSlotsByType.MOTORCYCLE`. If empty, it checks `availableSlotsByType.CAR` or `availableSlotsByPhysicalType.compact`, and so on, until a suitable (and available) slot is found or rejected.",
          "tags": [
            "system-design",
            "object-oriented-programming",
            "scalability",
            "open-ended"
          ],
          "prerequisites": [
            "object_oriented_programming",
            "data_structures_advanced"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_parking_lot_3",
          "topic": "System Design: Parking Lot",
          "level": "medium",
          "type": "code",
          "question": "Add a method `getOccupiedSlotsByVehicleType(type)` to the `ParkingLot` class that returns an array of slot numbers currently occupied by vehicles of a specific `type`. If no type is provided, it should return all occupied slots.\n\n```javascript\nclass Vehicle {\n  constructor(licensePlate, type) {\n    this.licensePlate = licensePlate;\n    this.type = type; // e.g., 'car', 'motorcycle', 'bus'\n    this.entryTime = Date.now();\n  }\n}\n\nclass ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null); \n    this.availableSlots = new Set(Array.from({ length: capacity }, (_, i) => i)); \n    this.occupiedVehiclesMap = new Map(); \n    this.slotToVehicleMap = new Map(); \n  }\n\n  _findAvailableSlot() {\n    if (this.availableSlots.size === 0) {\n      return -1;\n    }\n    const slotIndex = this.availableSlots.values().next().value;\n    return slotIndex;\n  }\n\n  parkVehicle(vehicle) {\n    if (this.occupiedVehiclesMap.has(vehicle.licensePlate)) {\n      console.log(`Vehicle ${vehicle.licensePlate} is already parked.`);\n      return null;\n    }\n    const slotIndex = this._findAvailableSlot();\n    if (slotIndex === -1) {\n      console.log('Sorry, parking lot is full.');\n      return null;\n    }\n\n    this.slots[slotIndex] = vehicle;\n    this.availableSlots.delete(slotIndex);\n    this.occupiedVehiclesMap.set(vehicle.licensePlate, slotIndex);\n    this.slotToVehicleMap.set(slotIndex, vehicle);\n\n    console.log(`Vehicle ${vehicle.licensePlate} (${vehicle.type}) parked at slot ${slotIndex + 1}.`);\n    return slotIndex;\n  }\n\n  unparkVehicle(licensePlate) {\n    if (!this.occupiedVehiclesMap.has(licensePlate)) {\n      console.log(`Vehicle ${licensePlate} not found in parking lot.`);\n      return null;\n    }\n\n    const slotIndex = this.occupiedVehiclesMap.get(licensePlate);\n    const vehicle = this.slotToVehicleMap.get(slotIndex);\n\n    this.slots[slotIndex] = null;\n    this.availableSlots.add(slotIndex);\n    this.occupiedVehiclesMap.delete(licensePlate);\n    this.slotToVehicleMap.delete(slotIndex);\n\n    const duration = (Date.now() - vehicle.entryTime) / (1000 * 60 * 60);\n    const fee = Math.ceil(duration) * 5;\n\n    console.log(`Vehicle ${licensePlate} unparked from slot ${slotIndex + 1}. Duration: ${duration.toFixed(2)} hours. Fee: $${fee}.`);\n    return { vehicle, fee };\n  }\n\n  getAvailableSlotsCount() {\n    return this.availableSlots.size;\n  }\n\n  getOccupiedSlotsInfo() {\n    return Array.from(this.slotToVehicleMap.entries()).map(([slot, vehicle]) => `Slot ${slot + 1}: ${vehicle.licensePlate} (${vehicle.type})`);\n  }\n}\n\n// Expected Usage:\n// const lot = new ParkingLot(5);\n// lot.parkVehicle(new Vehicle('C1', 'car'));\n// lot.parkVehicle(new Vehicle('M1', 'motorcycle'));\n// lot.parkVehicle(new Vehicle('C2', 'car'));\n// console.log(lot.getOccupiedSlotsByVehicleType('car')); // Should return [0, 2] (or 1-based [1, 3])\n// console.log(lot.getOccupiedSlotsByVehicleType('motorcycle')); // Should return [1] (or 1-based [2])\n// console.log(lot.getOccupiedSlotsByVehicleType()); // Should return [0, 1, 2] (or 1-based [1, 2, 3])\n```",
          "answer": "```javascript\nclass Vehicle {\n  constructor(licensePlate, type) {\n    this.licensePlate = licensePlate;\n    this.type = type; // e.g., 'car', 'motorcycle', 'bus'\n    this.entryTime = Date.now();\n  }\n}\n\nclass ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null); \n    this.availableSlots = new Set(Array.from({ length: capacity }, (_, i) => i)); \n    this.occupiedVehiclesMap = new Map(); // licensePlate -> slotIndex\n    this.slotToVehicleMap = new Map(); // slotIndex -> Vehicle object\n  }\n\n  _findAvailableSlot() {\n    if (this.availableSlots.size === 0) {\n      return -1;\n    }\n    const slotIndex = this.availableSlots.values().next().value;\n    return slotIndex;\n  }\n\n  parkVehicle(vehicle) {\n    if (this.occupiedVehiclesMap.has(vehicle.licensePlate)) {\n      console.log(`Vehicle ${vehicle.licensePlate} is already parked.`);\n      return null;\n    }\n    const slotIndex = this._findAvailableSlot();\n    if (slotIndex === -1) {\n      console.log('Sorry, parking lot is full.');\n      return null;\n    }\n\n    this.slots[slotIndex] = vehicle;\n    this.availableSlots.delete(slotIndex);\n    this.occupiedVehiclesMap.set(vehicle.licensePlate, slotIndex);\n    this.slotToVehicleMap.set(slotIndex, vehicle);\n\n    console.log(`Vehicle ${vehicle.licensePlate} (${vehicle.type}) parked at slot ${slotIndex + 1}.`);\n    return slotIndex;\n  }\n\n  unparkVehicle(licensePlate) {\n    if (!this.occupiedVehiclesMap.has(licensePlate)) {\n      console.log(`Vehicle ${licensePlate} not found in parking lot.`);\n      return null;\n    }\n\n    const slotIndex = this.occupiedVehiclesMap.get(licensePlate);\n    const vehicle = this.slotToVehicleMap.get(slotIndex);\n\n    this.slots[slotIndex] = null;\n    this.availableSlots.add(slotIndex);\n    this.occupiedVehiclesMap.delete(licensePlate);\n    this.slotToVehicleMap.delete(slotIndex);\n\n    const duration = (Date.now() - vehicle.entryTime) / (1000 * 60 * 60);\n    const fee = Math.ceil(duration) * 5;\n\n    console.log(`Vehicle ${licensePlate} unparked from slot ${slotIndex + 1}. Duration: ${duration.toFixed(2)} hours. Fee: $${fee}.`);\n    return { vehicle, fee };\n  }\n\n  getAvailableSlotsCount() {\n    return this.availableSlots.size;\n  }\n\n  getOccupiedSlotsInfo() {\n    return Array.from(this.slotToVehicleMap.entries()).map(([slot, vehicle]) => `Slot ${slot + 1}: ${vehicle.licensePlate} (${vehicle.type})`);\n  }\n\n  getOccupiedSlotsByVehicleType(type = null) {\n    const occupiedSlots = [];\n    for (const [slotIndex, vehicle] of this.slotToVehicleMap.entries()) {\n      if (type === null || vehicle.type === type) {\n        occupiedSlots.push(slotIndex);\n      }\n    }\n    return occupiedSlots.sort((a, b) => a - b); // Return sorted indices for consistent output\n  }\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to iterate through `Map` entries efficiently.",
            "Requires conditional filtering based on an optional parameter.",
            "Demonstrates practical use of stored vehicle data.",
            "Ensures correct return format (array of slot indices)."
          ],
          "keyConcepts": [
            "object-oriented-programming",
            "Map iteration",
            "conditional logic",
            "data filtering"
          ],
          "evaluationCriteria": [
            "Correct implementation of filtering logic.",
            "Efficient iteration over occupied vehicles.",
            "Handling of the optional `type` parameter.",
            "Returning the correct data type and format."
          ],
          "example": "The method iterates through `this.slotToVehicleMap`, which stores `slotIndex -> Vehicle` mappings. For each entry, it checks if `type` is null (meaning all types are requested) or if the vehicle's type matches the requested type. The `slotIndex` is then added to the result array.",
          "tags": [
            "system-design",
            "object-oriented-programming",
            "data-querying",
            "coding-challenge"
          ],
          "prerequisites": [
            "javascript_classes",
            "javascript_maps"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_parking_lot_4",
          "topic": "System Design: Parking Lot",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a key piece of information that MUST be recorded when a vehicle enters a parking lot to correctly calculate its parking fee upon exit?",
          "answer": "Entry Time",
          "options": [],
          "analysisPoints": [
            "Tests understanding of fundamental requirements for billing systems.",
            "Highlights the importance of timestamping events in system design."
          ],
          "keyConcepts": [
            "parking lot",
            "billing",
            "entry time",
            "data capture"
          ],
          "evaluationCriteria": [
            "Direct recall of crucial system design elements"
          ],
          "example": "Without the entry time, calculating the duration a vehicle was parked would be impossible, making accurate fee calculation unfeasible.",
          "tags": [
            "system-design",
            "flashcard"
          ],
          "prerequisites": [
            "basic_system_design_concepts"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_parking_lot_5",
          "topic": "System Design: Parking Lot",
          "level": "medium",
          "type": "mcq",
          "question": "When designing a parking lot system, which of the following is NOT a typical concern for the `parkVehicle` operation itself (assuming a single-threaded environment)?",
          "answer": "Calculating the parking fee.",
          "options": [
            "Finding an available slot.",
            "Marking the slot as occupied.",
            "Recording the vehicle's entry time.",
            "Calculating the parking fee."
          ],
          "analysisPoints": [
            "Tests understanding of responsibilities of different system components/operations.",
            "Distinguishes between entry-time operations and exit-time operations.",
            "Emphasizes that fees are usually calculated upon *exit*."
          ],
          "keyConcepts": [
            "parking lot",
            "parkVehicle",
            "unparkVehicle",
            "system responsibilities"
          ],
          "evaluationCriteria": [
            "Ability to identify correct operational scope",
            "Understanding of functional decomposition"
          ],
          "example": "The `parkVehicle` operation's primary role is to assign a vehicle to a slot and record its arrival. Fee calculation is logically part of the `unparkVehicle` process when the vehicle leaves.",
          "tags": [
            "system-design",
            "object-oriented-programming",
            "mcq"
          ],
          "prerequisites": [
            "system_design_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_tree_traversal_implementations",
          "title": "Implement All Three DFS Tree Traversals",
          "description": "\nImplement the following three Depth-First Search (DFS) traversals for a Binary Tree, both recursively and iteratively:\n\n1.  **Pre-order Traversal** (Root, Left, Right)\n2.  **In-order Traversal** (Left, Root, Right)\n3.  **Post-order Traversal** (Left, Right, Root)\n\nFor each traversal, your function should return an array containing the values of the nodes in the correct order.\n\n**Requirements:**\n*   Use the provided `TreeNode` class.\n*   Implement `preorderTraversalRecursive`, `preorderTraversalIterative`.\n*   Implement `inorderTraversalRecursive`, `inorderTraversalIterative`.\n*   Implement `postorderTraversalRecursive`, `postorderTraversalIterative`.\n*   Handle edge cases like an empty tree (`root = null`).\n",
          "difficulty": "hard",
          "startingCode": "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Pre-order Traversal (Root, Left, Right)\nfunction preorderTraversalRecursive(root) {\n  const result = [];\n  // TODO: Implement recursive pre-order traversal\n  return result;\n}\n\nfunction preorderTraversalIterative(root) {\n  const result = [];\n  // TODO: Implement iterative pre-order traversal using a stack\n  return result;\n}\n\n// In-order Traversal (Left, Root, Right)\nfunction inorderTraversalRecursive(root) {\n  const result = [];\n  // TODO: Implement recursive in-order traversal\n  return result;\n}\n\nfunction inorderTraversalIterative(root) {\n  const result = [];\n  // TODO: Implement iterative in-order traversal using a stack\n  return result;\n}\n\n// Post-order Traversal (Left, Right, Root)\nfunction postorderTraversalRecursive(root) {\n  const result = [];\n  // TODO: Implement recursive post-order traversal\n  return result;\n}\n\nfunction postorderTraversalIterative(root) {\n  const result = [];\n  // TODO: Implement iterative post-order traversal using a stack\n  return result;\n}\n\n// Example Tree:\n//     1\n//    / \\\n//   2   3\n//  / \\\n// 4   5\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\n// console.log(preorderTraversalRecursive(root)); // Expected: [1, 2, 4, 5, 3]\n// console.log(preorderTraversalIterative(root)); // Expected: [1, 2, 4, 5, 3]\n// console.log(inorderTraversalRecursive(root));  // Expected: [4, 2, 5, 1, 3]\n// console.log(inorderTraversalIterative(root));  // Expected: [4, 2, 5, 1, 3]\n// console.log(postorderTraversalRecursive(root)); // Expected: [4, 5, 2, 3, 1]\n// console.log(postorderTraversalIterative(root)); // Expected: [4, 5, 2, 3, 1]\n",
          "solutionCode": "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Pre-order Traversal (Root, Left, Right)\nfunction preorderTraversalRecursive(root) {\n  const result = [];\n  function traverse(node) {\n    if (node === null) return;\n    result.push(node.value);\n    traverse(node.left);\n    traverse(node.right);\n  }\n  traverse(root);\n  return result;\n}\n\nfunction preorderTraversalIterative(root) {\n  const result = [];\n  const stack = [];\n  if (!root) return result;\n  stack.push(root);\n  while (stack.length > 0) {\n    const current = stack.pop();\n    result.push(current.value);\n    if (current.right) stack.push(current.right);\n    if (current.left) stack.push(current.left);\n  }\n  return result;\n}\n\n// In-order Traversal (Left, Root, Right)\nfunction inorderTraversalRecursive(root) {\n  const result = [];\n  function traverse(node) {\n    if (node === null) return;\n    traverse(node.left);\n    result.push(node.value);\n    traverse(node.right);\n  }\n  traverse(root);\n  return result;\n}\n\nfunction inorderTraversalIterative(root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n\n  while (current !== null || stack.length > 0) {\n    while (current !== null) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop();\n    result.push(current.value);\n    current = current.right;\n  }\n  return result;\n}\n\n// Post-order Traversal (Left, Right, Root)\nfunction postorderTraversalRecursive(root) {\n  const result = [];\n  function traverse(node) {\n    if (node === null) return;\n    traverse(node.left);\n    traverse(node.right);\n    result.push(node.value);\n  }\n  traverse(root);\n  return result;\n}\n\nfunction postorderTraversalIterative(root) {\n  const result = [];\n  const stack1 = [];\n  const stack2 = [];\n  if (!root) return result;\n\n  stack1.push(root);\n  while (stack1.length > 0) {\n    const current = stack1.pop();\n    stack2.push(current.value);\n    if (current.left) stack1.push(current.left);\n    if (current.right) stack1.push(current.right);\n  }\n  // Reverse stack2 to get post-order sequence\n  while (stack2.length > 0) {\n    result.push(stack2.pop());\n  }\n  return result;\n}\n",
          "testCases": [
            "Test with empty tree: `preorderTraversalRecursive(null)` should return `[]`.",
            "Test with single node tree: `inorderTraversalIterative(new TreeNode(10))` should return `[10]`.",
            "Test with balanced tree: `preorderTraversalIterative(root)` where root is 1,2,3,4,5 should return `[1, 2, 4, 5, 3]`.",
            "Test with skewed tree (right-skewed): `inorderTraversalIterative(skewedRoot)` where 1->null->2->null->3 should return `[1, 2, 3]`.",
            "Test with skewed tree (left-skewed): `postorderTraversalIterative(skewedRoot)` where 1->2->3->null->null should return `[3, 2, 1]`.",
            "Verify all 6 functions return correct results for the example tree provided in starting code."
          ],
          "hints": [
            "For recursive solutions, the base case is always a null node.",
            "For iterative DFS, use a stack. The order of pushing left/right children onto the stack is crucial and depends on the traversal type.",
            "Iterative in-order traversal is often considered the trickiest due to visiting the root in the middle.",
            "Iterative post-order can be achieved by a slight modification of pre-order logic and then reversing the result, or by using two stacks."
          ],
          "tags": [
            "trees",
            "traversal",
            "algorithms",
            "recursion",
            "stack",
            "data-structures"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "tree_data_structure",
            "stack_data_structure",
            "recursion_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "binary_tree_implementation",
            "dfs_vs_bfs"
          ]
        },
        {
          "id": "task_flatten_object_enhanced",
          "title": "Flatten Object with Custom Separator and Array Handling",
          "description": "\nEnhance the `flattenObject` function to provide more flexibility:\n\n1.  **Custom Separator:** Allow the caller to specify a custom separator string instead of always using a dot (`.`). Default to `.`.\n2.  **Array Handling:** Flatten array elements using bracket notation (`[index]`). If an element is an object, continue flattening it recursively. If it's a primitive, add it directly.\n3.  **Null/Undefined Handling:** Ensure `null` and `undefined` values are preserved correctly as leaf nodes.\n\n**Requirements:**\n*   The function signature should be `flattenObject(obj, separator = '.', prefix = '')`.\n*   Handle deeply nested objects and arrays within objects.\n*   Return a new flattened object.\n\n**Example Input:**\n```javascript\nconst complexObject = {\n  user: {\n    id: 123,\n    profile: {\n      name: 'Alice',\n      email: 'alice@example.com',\n      settings: {\n        theme: 'dark',\n        notifications: true\n      }\n    },\n    roles: ['admin', 'editor'],\n    contact: null\n  },\n  metadata: {\n    lastLogin: '2023-10-26'\n  },\n  permissions: [\n    { name: 'read', level: 1 },\n    { name: 'write', level: 2 }\n  ]\n};\n```\n\n**Expected Output (with default separator '.'):**\n```json\n{\n  \"user.id\": 123,\n  \"user.profile.name\": \"Alice\",\n  \"user.profile.email\": \"alice@example.com\",\n  \"user.profile.settings.theme\": \"dark\",\n  \"user.profile.settings.notifications\": true,\n  \"user.roles[0]\": \"admin\",\n  \"user.roles[1]\": \"editor\",\n  \"user.contact\": null,\n  \"metadata.lastLogin\": \"2023-10-26\",\n  \"permissions[0].name\": \"read\",\n  \"permissions[0].level\": 1,\n  \"permissions[1].name\": \"write\",\n  \"permissions[1].level\": 2\n}\n```\n",
          "difficulty": "hard",
          "startingCode": "function flattenObject(obj, separator = '.', prefix = '') {\n  // TODO: Implement the enhanced flattening logic here\n  // Consider the custom separator, array handling, and null/undefined values.\n  return {};\n}\n\n// Example Input (from description)\nconst complexObject = {\n  user: {\n    id: 123,\n    profile: {\n      name: 'Alice',\n      email: 'alice@example.com',\n      settings: {\n        theme: 'dark',\n        notifications: true\n      }\n    },\n    roles: ['admin', 'editor'],\n    contact: null\n  },\n  metadata: {\n    lastLogin: '2023-10-26'\n  },\n  permissions: [\n    { name: 'read', level: 1 },\n    { name: 'write', level: 2 }\n  ]\n};\n\n// Expected Output (with default separator '.'):\n// console.log(flattenObject(complexObject));\n\n// Expected Output (with custom separator '_'):\n// console.log(flattenObject(complexObject, '_'));\n/*\n{\n  \"user_id\": 123,\n  \"user_profile_name\": \"Alice\",\n  \"user_profile_email\": \"alice@example.com\",\n  \"user_profile_settings_theme\": \"dark\",\n  \"user_profile_settings_notifications\": true,\n  \"user_roles[0]\": \"admin\",\n  \"user_roles[1]\": \"editor\",\n  \"user_contact\": null,\n  \"metadata_lastLogin\": \"2023-10-26\",\n  \"permissions[0]_name\": \"read\",\n  \"permissions[0]_level\": 1,\n  \"permissions[1]_name\": \"write\",\n  \"permissions[1]_level\": 2\n}\n*/\n",
          "solutionCode": "function flattenObject(obj, separator = '.', prefix = '') {\n  const result = {};\n\n  for (const key in obj) {\n    if (!obj.hasOwnProperty(key)) continue; // Ensure own properties\n\n    const newKey = prefix ? `${prefix}${separator}${key}` : key;\n    const value = obj[key];\n\n    if (typeof value === 'object' && value !== null) {\n      if (Array.isArray(value)) {\n        // Handle arrays\n        value.forEach((item, index) => {\n          const arrayItemKey = `${newKey}[${index}]`;\n          if (typeof item === 'object' && item !== null) {\n            Object.assign(result, flattenObject(item, separator, arrayItemKey));\n          } else {\n            result[arrayItemKey] = item;\n          }\n        });\n      } else {\n        // Handle plain objects\n        Object.assign(result, flattenObject(value, separator, newKey));\n      }\n    } else {\n      // Handle primitive values, null, undefined\n      result[newKey] = value;\n    }\n  }\n  return result;\n}\n",
          "testCases": [
            "Test with the `complexObject` and default separator.",
            "Test with the `complexObject` and a custom separator like `_`.",
            "Test with an empty object: `flattenObject({})` should return `{}`.",
            "Test with an object containing only primitives: `flattenObject({a:1, b:'test'})` should return `{a:1, b:'test'}`.",
            "Test with an object containing `null` and `undefined` values: `flattenObject({a: null, b: undefined})` should return `{a: null, b: undefined}`.",
            "Test with an array containing mixed types: `flattenObject({data: [1, {x:2}, null, 'str']})` should produce correct flattened keys and values."
          ],
          "hints": [
            "The recursive function should accept the `separator` and `prefix` as arguments.",
            "When processing an array, iterate over its elements using `forEach` or a `for` loop.",
            "For array elements, build the `newKey` using `[index]` notation.",
            "Remember to recursively call `flattenObject` on object *elements* within an array, too."
          ],
          "tags": [
            "objects",
            "recursion",
            "data-transformation",
            "javascript",
            "arrays",
            "interview-prep"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "object_flattening_basic",
            "javascript_objects_advanced",
            "recursion_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "object_serialization",
            "form_data_processing",
            "unflatten_object"
          ]
        },
        {
          "id": "task_unflatten_object",
          "title": "Reconstruct Nested Object from Flattened Keys",
          "description": "\nCreate a function `unflattenObject(flattenedObj, separator = '.')` that performs the inverse operation of flattening. It should take a flattened object (where keys are path strings) and reconstruct the original deeply nested object.\n\n**Requirements:**\n*   Accept a `separator` argument for key splitting, defaulting to `.`.\n*   Correctly interpret dot-separated paths for nested objects.\n*   Correctly interpret bracket-notation `[index]` for array elements.\n*   Handle cases where intermediate objects/arrays need to be created.\n*   Be robust against potential issues like a key `a.b` existing and then `a.b.c` being encountered, or a path expecting an object where an array was previously created and vice versa (in such cases, default to the expected type for the current path segment).\n\n**Example Input (using default separator):**\n```json\n{\n  \"user.id\": 123,\n  \"user.profile.name\": \"Alice\",\n  \"user.profile.email\": \"alice@example.com\",\n  \"user.profile.settings.theme\": \"dark\",\n  \"user.profile.settings.notifications\": true,\n  \"user.roles[0]\": \"admin\",\n  \"user.roles[1]\": \"editor\",\n  \"user.contact\": null,\n  \"metadata.lastLogin\": \"2023-10-26\",\n  \"permissions[0].name\": \"read\",\n  \"permissions[0].level\": 1,\n  \"permissions[1].name\": \"write\",\n  \"permissions[1].level\": 2\n}\n```\n\n**Expected Output (as shown in theory for `flattenObject`):**\n```javascript\n{\n  user: {\n    id: 123,\n    profile: {\n      name: 'Alice',\n      email: 'alice@example.com',\n      settings: {\n        theme: 'dark',\n        notifications: true\n      }\n    },\n    roles: ['admin', 'editor'],\n    contact: null\n  },\n  metadata: {\n    lastLogin: '2023-10-26'\n  },\n  permissions: [\n    { name: 'read', level: 1 },\n    { name: 'write', level: 2 }\n  ]\n}\n```\n",
          "difficulty": "hard",
          "startingCode": "function unflattenObject(flattenedObj, separator = '.') {\n  const result = {};\n\n  for (const key in flattenedObj) {\n    if (!flattenedObj.hasOwnProperty(key)) continue;\n    const value = flattenedObj[key];\n    // TODO: Implement the unflattening logic here\n    // Split key by separator, handle array notation\n    // Dynamically create nested objects and arrays\n  }\n  return result;\n}\n\n// Example Input (from description)\nconst flattenedObject = {\n  \"user.id\": 123,\n  \"user.profile.name\": \"Alice\",\n  \"user.profile.email\": \"alice@example.com\",\n  \"user.profile.settings.theme\": \"dark\",\n  \"user.profile.settings.notifications\": true,\n  \"user.roles[0]\": \"admin\",\n  \"user.roles[1]\": \"editor\",\n  \"user.contact\": null,\n  \"metadata.lastLogin\": \"2023-10-26\",\n  \"permissions[0].name\": \"read\",\n  \"permissions[0].level\": 1,\n  \"permissions[1].name\": \"write\",\n  \"permissions[1].level\": 2\n};\n\n// console.log(JSON.stringify(unflattenObject(flattenedObject), null, 2));\n",
          "solutionCode": "function unflattenObject(flattenedObj, separator = '.') {\n  const result = {};\n\n  for (const key in flattenedObj) {\n    if (!flattenedObj.hasOwnProperty(key)) continue;\n\n    const value = flattenedObj[key];\n    const parts = key.split(separator);\n    let current = result;\n\n    for (let i = 0; i < parts.length; i++) {\n      let part = parts[i];\n      let isArrayPart = false;\n      let arrayKey = '';\n      let arrayIndex = -1;\n\n      // Check for array notation e.g., 'key[index]'\n      const arrayMatch = part.match(/(.*)\\[(\\d+)\\]$/);\n      if (arrayMatch) {\n        isArrayPart = true;\n        arrayKey = arrayMatch[1];\n        arrayIndex = parseInt(arrayMatch[2], 10);\n        part = arrayKey; // Use the base key for property access\n      }\n\n      // If it's the last part of the path, assign the value\n      if (i === parts.length - 1) {\n        if (isArrayPart) {\n          if (!current[part]) {\n            current[part] = [];\n          } else if (!Array.isArray(current[part])) {\n            // Path conflict: e.g., 'a' was an object, now 'a[0]' expects array\n            console.warn(`Type conflict at path segment '${part}': Expected array but found object. Overwriting.`);\n            current[part] = [];\n          }\n          current[part][arrayIndex] = value;\n        } else {\n          current[part] = value;\n        }\n      } else { // Not the last part, ensure intermediate container exists\n        if (isArrayPart) {\n          if (!current[part]) {\n            current[part] = [];\n          } else if (!Array.isArray(current[part])) {\n             console.warn(`Type conflict at path segment '${part}': Expected array but found object. Overwriting.`);\n             current[part] = [];\n          }\n\n          // Ensure nested object/array exists at the array index\n          if (!current[part][arrayIndex] || typeof current[part][arrayIndex] !== 'object' || Array.isArray(current[part][arrayIndex])) {\n            current[part][arrayIndex] = {}; // Assume it should be an object for further nesting\n          }\n          current = current[part][arrayIndex];\n        } else { // Regular object part\n          if (!current[part] || typeof current[part] !== 'object' || Array.isArray(current[part])) {\n            current[part] = {}; // Assume it should be an object for further nesting\n          }\n          current = current[part];\n        }\n      }\n    }\n  }\n  return result;\n}\n",
          "testCases": [
            "Test with the complex `flattenedObject` and default separator.",
            "Test with a flattened object using a custom separator (e.g., `_`): `{'user_id': 123, 'user_roles[0]': 'admin'}` and `separator = '_'`.",
            "Test with an empty flattened object: `unflattenObject({})` should return `{}`.",
            "Test with a single-level flattened object: `unflattenObject({a:1, b:'test'})` should return `{a:1, b:'test'}`.",
            "Test with a flattened object containing `null` and `undefined` values: `unflattenObject({'a.b': null, 'c': undefined})` should preserve them.",
            "Test with a challenging edge case: `{'a.b': 1, 'a.b.c': 2}` (the first key creates a primitive where the second expects an object). Solution should handle or warn.",
            "Test with a key `a[0]` then `a` itself. (e.g., `{'a[0]': 1, 'a': 'some value'}`). The latest assignment overwrites or a warning is issued based on implementation.",
            "Test with `{'arr[0].name': 'test', 'arr': 'not an array'}`. It should ideally resolve `arr` as an array or warn."
          ],
          "hints": [
            "Iterate through the keys of the `flattenedObj`.",
            "For each key, split it into parts using the `separator`.",
            "For each part, determine if it's an object key or an array index (e.g., using `RegExp.prototype.match()` to detect `[index]`).",
            "Maintain a `current` pointer to navigate the `result` object and create intermediate objects (`{}`) or arrays (`[]`) as needed.",
            "Pay careful attention to when to assign the `value` vs. when to move the `current` pointer further into the nested structure.",
            "Consider potential type conflicts (e.g., if a path like `a.b` refers to a primitive, but then `a.b.c` implies `a.b` should be an object). You might choose to overwrite, throw an error, or issue a warning."
          ],
          "tags": [
            "objects",
            "data-transformation",
            "javascript",
            "string-parsing",
            "algorithms",
            "interview-prep"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "object_flattening_enhanced",
            "javascript_strings_regex",
            "dynamic_object_creation"
          ],
          "complexity": 9,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "json_serialization",
            "object_mapping"
          ]
        },
        {
          "id": "task_parking_lot_full_design",
          "title": "Full Parking Lot System Design with Vehicle Types and Pricing",
          "description": "\nDesign and implement a more robust `ParkingLot` system that accounts for different vehicle types and a dynamic pricing structure. Your system should be able to:\n\n1.  **Initialize with capacity and slot types:** The `ParkingLot` should be initialized with a total capacity and possibly a distribution of slot types (e.g., 20 car slots, 5 motorcycle slots, 2 bus slots).\n2.  **Support Vehicle Types:** Distinguish between 'CAR', 'MOTORCYCLE', 'BUS' vehicles. Each vehicle object should have a `type` property.\n3.  **Intelligent Parking:** When a vehicle parks, assign it to the most suitable available slot. For instance, a motorcycle can take a motorcycle slot, then a car slot, then a bus slot if needed (in that order of preference). Cars can take car or bus slots. Buses can only take bus slots.\n4.  **Dynamic Pricing:** Implement a basic pricing model. For example:\n    *   Motorcycles: $2/hour\n    *   Cars: $5/hour\n    *   Buses: $10/hour\n    *   Fees are rounded up to the nearest full hour.\n5.  **Tracking & Querying:** Provide methods to:\n    *   `parkVehicle(licensePlate, type)`: Parks a vehicle and returns its assigned slot number.\n    *   `unparkVehicle(licensePlate)`: Unparks a vehicle, calculates and returns the fee.\n    *   `getAvailableSlots(vehicleType)`: Returns the number of available slots for a given vehicle type (considering where it can fit).\n    *   `getOccupiedSlots()`: Returns a list of all occupied slots with vehicle details.\n\n**Considerations:**\n*   Use appropriate data structures for efficient lookup and management (e.g., Maps for vehicles, Sets for available slots per type).\n*   Handle full parking lots and non-existent vehicles gracefully.\n",
          "difficulty": "expert",
          "startingCode": "class Vehicle {\n  constructor(licensePlate, type) {\n    this.licensePlate = licensePlate;\n    this.type = type; // e.g., 'car', 'motorcycle', 'bus'\n    this.entryTime = null;\n  }\n}\n\nclass ParkingLot {\n  constructor(capacityConfig) {\n    // capacityConfig example: { car: 20, motorcycle: 5, bus: 2 }\n    this.capacityConfig = capacityConfig;\n    this.totalCapacity = Object.values(capacityConfig).reduce((sum, count) => sum + count, 0);\n\n    // TODO: Initialize data structures for different slot types\n    // this.slots = ...\n    // this.availableSlotsByType = {\n    //   'car': new Set(),\n    //   'motorcycle': new Set(),\n    //   'bus': new Set()\n    // };\n    // this.occupiedVehiclesMap = new Map(); // licensePlate -> Vehicle object\n    // this.slotIdToVehicleMap = new Map(); // slotId -> Vehicle object\n\n    // Initialize slots based on config, e.g., 'C1', 'C2', 'M1', 'B1'\n    let currentSlotId = 0;\n    this.slotsMap = new Map(); // slotId -> { vehicle: Vehicle | null, type: 'car' | 'motorcycle' | 'bus' }\n    this.availableSlotsByType = {\n        'CAR': new Set(),\n        'MOTORCYCLE': new Set(),\n        'BUS': new Set()\n    };\n    \n    for (const type in capacityConfig) {\n        for (let i = 0; i < capacityConfig[type]; i++) {\n            const slotIdentifier = `${type.toUpperCase()}_${i + 1}`;\n            this.slotsMap.set(slotIdentifier, { vehicle: null, type: type.toUpperCase() });\n            this.availableSlotsByType[type.toUpperCase()].add(slotIdentifier);\n        }\n    }\n\n    this.occupiedVehiclesMap = new Map(); // licensePlate -> Vehicle object\n  }\n\n  _getParkingPreference(vehicleType) {\n    // Define preference order for different vehicle types\n    const preferences = {\n      'MOTORCYCLE': ['MOTORCYCLE', 'CAR', 'BUS'],\n      'CAR': ['CAR', 'BUS'],\n      'BUS': ['BUS']\n    };\n    return preferences[vehicleType];\n  }\n\n  _calculateFee(vehicle) {\n    const rates = {\n      'MOTORCYCLE': 2,\n      'CAR': 5,\n      'BUS': 10\n    };\n    if (!vehicle.entryTime) return 0; // Should not happen if parked correctly\n    const durationHours = Math.ceil((Date.now() - vehicle.entryTime) / (1000 * 60 * 60));\n    return durationHours * (rates[vehicle.type] || 0);\n  }\n\n  parkVehicle(licensePlate, type) {\n    const vehicle = new Vehicle(licensePlate, type.toUpperCase());\n    // TODO: Implement parking logic\n    // 1. Check if vehicle is already parked.\n    // 2. Find an available slot based on preference and type.\n    // 3. Update data structures (availableSlotsByType, occupiedVehiclesMap, slotsMap).\n    // 4. Set vehicle entry time.\n    // 5. Return slotId or null.\n    return null; \n  }\n\n  unparkVehicle(licensePlate) {\n    // TODO: Implement unparking logic\n    // 1. Check if vehicle exists.\n    // 2. Retrieve slotId and vehicle.\n    // 3. Calculate fee.\n    // 4. Update data structures (availableSlotsByType, occupiedVehiclesMap, slotsMap).\n    // 5. Return { vehicle, fee } or null.\n    return null;\n  }\n\n  getAvailableSlots(vehicleType) {\n    // TODO: Implement logic to count available slots for a given vehicle type\n    // This should consider all slot types the vehicle can fit into.\n    return 0;\n  }\n\n  getOccupiedSlots() {\n    const occupied = [];\n    // TODO: Iterate through slotsMap and collect occupied slot details.\n    return occupied;\n  }\n}\n\n// Example Usage:\n// const parkingLot = new ParkingLot({ car: 2, motorcycle: 1, bus: 1 });\n// console.log(parkingLot.getAvailableSlots('CAR')); // Should be 3 (2 car, 1 bus)\n// console.log(parkingLot.getAvailableSlots('MOTORCYCLE')); // Should be 4 (1 moto, 2 car, 1 bus)\n\n// const s1 = parkingLot.parkVehicle('ABC1', 'CAR');\n// const s2 = parkingLot.parkVehicle('XYZ9', 'MOTORCYCLE');\n// const s3 = parkingLot.parkVehicle('BUS1', 'BUS');\n\n// console.log(parkingLot.getOccupiedSlots());\n// setTimeout(() => {\n//   const { fee } = parkingLot.unparkVehicle('ABC1');\n//   console.log(`Fee for ABC1: $${fee}`);\n// }, 1000);",
          "solutionCode": "class Vehicle {\n  constructor(licensePlate, type) {\n    this.licensePlate = licensePlate;\n    this.type = type; // e.g., 'car', 'motorcycle', 'bus'\n    this.entryTime = null;\n  }\n}\n\nclass ParkingLot {\n  constructor(capacityConfig) {\n    this.capacityConfig = capacityConfig;\n    this.totalCapacity = Object.values(capacityConfig).reduce((sum, count) => sum + count, 0);\n\n    this.slotsMap = new Map(); // slotId -> { vehicle: Vehicle | null, type: 'CAR' | 'MOTORCYCLE' | 'BUS' }\n    this.availableSlotsByType = {\n        'CAR': new Set(),\n        'MOTORCYCLE': new Set(),\n        'BUS': new Set()\n    };\n    \n    let slotCounter = 0;\n    for (const type in capacityConfig) {\n        for (let i = 0; i < capacityConfig[type]; i++) {\n            const slotId = `${type.toUpperCase()}_${i + 1}`;\n            this.slotsMap.set(slotId, { vehicle: null, type: type.toUpperCase(), id: slotId });\n            this.availableSlotsByType[type.toUpperCase()].add(slotId);\n        }\n    }\n\n    this.occupiedVehiclesMap = new Map(); // licensePlate -> { vehicle: Vehicle, slotId: string }\n  }\n\n  _getParkingPreference(vehicleType) {\n    // Define preference order for different vehicle types\n    const preferences = {\n      'MOTORCYCLE': ['MOTORCYCLE', 'CAR', 'BUS'],\n      'CAR': ['CAR', 'BUS'],\n      'BUS': ['BUS']\n    };\n    return preferences[vehicleType];\n  }\n\n  _calculateFee(vehicle) {\n    const rates = {\n      'MOTORCYCLE': 2,\n      'CAR': 5,\n      'BUS': 10\n    };\n    if (!vehicle.entryTime) return 0; \n    const durationHours = Math.ceil((Date.now() - vehicle.entryTime) / (1000 * 60 * 60));\n    return durationHours * (rates[vehicle.type] || 0);\n  }\n\n  parkVehicle(licensePlate, type) {\n    const vehicleType = type.toUpperCase();\n    if (this.occupiedVehiclesMap.has(licensePlate)) {\n      console.log(`Vehicle ${licensePlate} is already parked.`);\n      return null;\n    }\n\n    const preferredSlotTypes = this._getParkingPreference(vehicleType);\n    let foundSlotId = null;\n\n    for (const slotType of preferredSlotTypes) {\n      if (this.availableSlotsByType[slotType] && this.availableSlotsByType[slotType].size > 0) {\n        // Get the first available slot of this type\n        foundSlotId = this.availableSlotsByType[slotType].values().next().value;\n        this.availableSlotsByType[slotType].delete(foundSlotId);\n        break; \n      }\n    }\n\n    if (!foundSlotId) {\n      console.log(`Sorry, no suitable parking slot available for ${vehicleType} (License: ${licensePlate}).`);\n      return null;\n    }\n\n    const vehicle = new Vehicle(licensePlate, vehicleType);\n    vehicle.entryTime = Date.now();\n    this.slotsMap.get(foundSlotId).vehicle = vehicle;\n    this.occupiedVehiclesMap.set(licensePlate, { vehicle, slotId: foundSlotId });\n\n    console.log(`Vehicle ${licensePlate} (${vehicleType}) parked at slot ${foundSlotId}.`);\n    return foundSlotId;\n  }\n\n  unparkVehicle(licensePlate) {\n    if (!this.occupiedVehiclesMap.has(licensePlate)) {\n      console.log(`Vehicle ${licensePlate} not found in parking lot.`);\n      return null;\n    }\n\n    const { vehicle, slotId } = this.occupiedVehiclesMap.get(licensePlate);\n    \n    // Free up the slot\n    this.slotsMap.get(slotId).vehicle = null;\n    this.availableSlotsByType[this.slotsMap.get(slotId).type].add(slotId);\n    this.occupiedVehiclesMap.delete(licensePlate);\n\n    const fee = this._calculateFee(vehicle);\n\n    console.log(`Vehicle ${licensePlate} unparked from slot ${slotId}. Duration: ${((Date.now() - vehicle.entryTime) / (1000 * 60 * 60)).toFixed(2)} hours. Fee: $${fee}.`);\n    return { vehicle, fee };\n  }\n\n  getAvailableSlots(vehicleType) {\n    const type = vehicleType.toUpperCase();\n    const relevantSlotTypes = this._getParkingPreference(type);\n    let count = 0;\n    for (const slotType of relevantSlotTypes) {\n      if (this.availableSlotsByType[slotType]) {\n        count += this.availableSlotsByType[slotType].size;\n      }\n    }\n    return count;\n  }\n\n  getOccupiedSlots() {\n    const occupied = [];\n    for (const [slotId, slotInfo] of this.slotsMap.entries()) {\n      if (slotInfo.vehicle) {\n        occupied.push({\n          slotId: slotId,\n          vehicle: slotInfo.vehicle,\n          slotType: slotInfo.type\n        });\n      }\n    }\n    return occupied;\n  }\n}\n",
          "testCases": [
            "Initialize with a mix of slots: `new ParkingLot({ car: 2, motorcycle: 1, bus: 1 })`.",
            "Park a motorcycle, then a car, then a bus; check `getOccupiedSlots()`.",
            "Test parking when a specific slot type is full, but a larger type is available (e.g., park motorcycle when motorcycle slots are full but car slots are open).",
            "Test `getAvailableSlots('CAR')` and `getAvailableSlots('MOTORCYCLE')` after various parking actions to ensure accurate counts considering preferences.",
            "Attempt to park a vehicle when the lot is completely full for its type (and larger types it can use).",
            "Unpark a vehicle and verify the fee calculation and slot availability update.",
            "Attempt to unpark a non-existent vehicle.",
            "Test with multiple park/unpark cycles for the same vehicle.",
            "Test with all slots occupied and then unpark one to create availability."
          ],
          "hints": [
            "Think about how to represent the physical slots. A `Map` mapping `slotId` to a `slotInfo` object (containing `vehicle` and `type`) is robust.",
            "Use separate `Set`s for `availableSlotsByType` to ensure O(1) efficiency for adding/removing available slots.",
            "The `_getParkingPreference` helper is crucial for implementing the intelligent parking logic (finding the 'best' fit).",
            "Ensure `entryTime` is set when `parkVehicle` is successful and used when `unparkVehicle` calculates the fee.",
            "Remember to convert vehicle types to a consistent uppercase format for map/set keys."
          ],
          "tags": [
            "system-design",
            "object-oriented-programming",
            "data-structures",
            "algorithms",
            "interview-prep",
            "complex-logic"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "theory_system_design_parking_lot",
            "javascript_maps_sets",
            "object_oriented_design_principles"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "expert",
          "relatedConcepts": [
            "concurrency_control",
            "database_design",
            "distributed_systems"
          ]
        }
      ]
    }
  }
]