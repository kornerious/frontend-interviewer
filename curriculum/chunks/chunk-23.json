[
  {
    "id": "750bddfc-a945-4c8a-b673-ca40a0faeeea",
    "startLine": 4600,
    "endLine": 4699,
    "processedDate": "2025-06-17T09:13:47.032Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_update_lifecycle_overview",
          "title": "React Component Lifecycle: Updating Phase Overview",
          "content": "The updating phase of a React component's lifecycle begins when a component receives new props or state. This phase is crucial for ensuring that the UI reflects the latest data. The methods in this phase allow developers to react to changes, optimize performance, and manage side effects.\n\n### Triggers for Update Phase:\n- **New props**: Parent component re-renders and passes new props to the child.\n- **`setState()`**: The component's internal state changes via `this.setState()`.\n- **`forceUpdate()`**: Explicitly forces a re-render of the component.\n\nThe methods are called in a specific order, enabling a predictable flow of operations from prop/state changes to DOM updates and subsequent side effects.\n\n**Sequence of methods in the Updating Phase:**\n1.  `static getDerivedStateFromProps(props, state)`\n2.  `shouldComponentUpdate(nextProps, nextState)`\n3.  `render()`\n4.  `getSnapshotBeforeUpdate(prevProps, prevState)`\n5.  `componentDidUpdate(prevProps, prevState, snapshot)`",
          "examples": [
            {
              "id": "example_react_update_lifecycle_overview_1",
              "title": "Basic Component Update Flow",
              "code": "import React from 'react';\n\nclass UpdatingComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('1. Constructor (update)');\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    console.log('2. static getDerivedStateFromProps');\n    // Returning null means no state update from props\n    return null;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('3. shouldComponentUpdate');\n    // By default, returns true. For demonstration, let's always re-render.\n    return true;\n  }\n\n  render() {\n    console.log('4. render (update)');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Increment</button>\n      </div>\n    );\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('5. getSnapshotBeforeUpdate');\n    // This method returns a snapshot that will be passed to componentDidUpdate\n    return { prevCount: prevState.count };\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('6. componentDidUpdate');\n    console.log('Snapshot from getSnapshotBeforeUpdate:', snapshot);\n    if (this.state.count !== prevState.count) {\n      console.log(`Count changed from ${prevState.count} to ${this.state.count}`);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('7. componentWillUnmount');\n  }\n}\n\n// To see update in action, you'd render this component and interact with its button\n// or update its props from a parent component.\n\n/*\nExpected console output when button is clicked:\n2. static getDerivedStateFromProps\n3. shouldComponentUpdate\n4. render (update)\n5. getSnapshotBeforeUpdate\n6. componentDidUpdate\nCount changed from X to Y\n*/\n",
              "explanation": "This example demonstrates the typical flow of methods during the update phase when the component's state changes. Console logs illustrate the order of execution. Note that the constructor is only called during the initial mount, not subsequent updates.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_update_lifecycle_order_mcq",
            "question_update_triggers_open",
            "question_lifecycle_phases_flashcard"
          ],
          "relatedTasks": [
            "task_implement_update_lifecycle_logger"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Updating Phase",
            "Component",
            "Class Component"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "class_components",
            "state_props"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_optimization",
            "side_effects_management",
            "dom_manipulation"
          ]
        },
        {
          "id": "theory_static_get_derived_state_from_props",
          "title": "static getDerivedStateFromProps(props, state)",
          "content": "The `static getDerivedStateFromProps` method is part of React's render phase lifecycle methods, meaning it's called during render and should be pure with no side effects. It is invoked right before calling the `render` method, both on the initial mount and on subsequent updates.\n\n### Purpose:\nIts primary purpose is to allow a component to update its internal state based on changes in props. This is a rare use case, typically when the state needs to be a direct derivation of props over time.\n\n### Signature and Behavior:\n- **`props`**: The new props the component received.\n- **`state`**: The current state of the component.\n- It must be a `static` method, so it does not have access to `this`.\n- It returns an object to update the state, or `null` to indicate that nothing needs to be updated.\n\n### Important Considerations:\n- **Pure Function**: This method must be a pure function. It should not cause any side effects (e.g., network requests, DOM manipulation, `setState` calls).\n- **Infrequent Use**: This method is generally discouraged for common patterns. Most cases where you think you need `getDerivedStateFromProps` can be handled by `componentDidUpdate` (for side effects) or by making the component fully controlled (i.e., not managing its own state internally).\n- **Unconditional Calls**: It's called on *every* render, regardless of whether props have actually changed. This means it must carefully compare `props` and `state` to avoid unnecessary state updates if the derivation is conditional.\n\n### Anti-patterns:\n- Copying props to state for every render when `props` haven't changed leads to redundant state updates.\n- Using it for side effects; `componentDidUpdate` is the correct place for side effects based on prop/state changes.",
          "examples": [
            {
              "id": "example_get_derived_state_from_props_1",
              "title": "Updating State from Props (Controlled Input)",
              "code": "import React from 'react';\n\nclass ControlledInput extends React.Component {\n  state = {\n    internalValue: this.props.value || ''\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // Only update internalValue if the external prop 'value' has changed\n    if (nextProps.value !== prevState.internalValue) {\n      return {\n        internalValue: nextProps.value\n      };\n    }\n    // No state update needed\n    return null;\n  }\n\n  handleChange = (event) => {\n    this.setState({ internalValue: event.target.value });\n  };\n\n  render() {\n    return (\n      <input\n        type=\"text\"\n        value={this.state.internalValue}\n        onChange={this.handleChange}\n      />\n    );\n  }\n}\n\n// Usage:\n// <ControlledInput value=\"Hello\" />\n// The internal state `internalValue` will always reflect the `value` prop unless the user types in it.\n// If parent changes `value` prop, internal state will update accordingly.\n",
              "explanation": "This example shows a scenario where `getDerivedStateFromProps` is used to keep an internal state (`internalValue`) synchronized with a prop (`value`). This is typical for components like a controlled input field where the parent can dictate its value, but the component also manages its own input changes. The conditional check `nextProps.value !== prevState.internalValue` is crucial to prevent infinite loops or unnecessary updates.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_gdsfp_purpose_mcq",
            "question_gdsfp_conditions_open",
            "question_gdsfp_pure_function_flashcard",
            "question_gdsfp_incorrect_use_code"
          ],
          "relatedTasks": [
            "task_implement_gdsfp_prop_sync"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "static",
            "State",
            "Props",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "derived_state",
            "controlled_components"
          ]
        },
        {
          "id": "theory_should_component_update",
          "title": "shouldComponentUpdate(nextProps, nextState)",
          "content": "The `shouldComponentUpdate` method is a performance optimization hook. It's called before `render` when new props or state are received. By default, it returns `true`, meaning the component will re-render. If it returns `false`, React skips calling `render()`, `getSnapshotBeforeUpdate()`, and `componentDidUpdate()` for that update cycle.\n\n### Purpose:\n- **Performance Optimization**: Prevents unnecessary re-renders of a component and its children, which can be critical for complex UIs or large component trees.\n\n### Signature and Behavior:\n- **`nextProps`**: The next props the component will receive.\n- **`nextState`**: The next state the component will have.\n- Returns a `boolean`: `true` to allow re-render, `false` to prevent it.\n\n### Important Considerations:\n- **Not for Initial Render**: This method is not called for the initial render.\n- **`forceUpdate()` bypasses**: It is not called when `forceUpdate()` is used.\n- **PureComponent**: `React.PureComponent` implements `shouldComponentUpdate` with a shallow comparison of props and state. This makes `PureComponent` a convenient way to achieve basic performance optimization without manually implementing `shouldComponentUpdate`.\n- **Caveats**: Implementing `shouldComponentUpdate` manually requires careful consideration. A subtle bug (e.g., incorrect comparison) can lead to parts of the UI not updating when they should, causing inconsistencies. It's generally safer to rely on `PureComponent` or `React.memo` (for functional components) unless you have a deep understanding of the component's data flow and performance bottlenecks.\n- **No Side Effects**: This method should be pure and contain only a comparison logic. Do not perform side effects here.",
          "examples": [
            {
              "id": "example_should_component_update_1",
              "title": "Preventing Unnecessary Renders",
              "code": "import React from 'react';\n\nclass OptimizedList extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'items' prop has actually changed its length,\n    // or if the reference to the array has changed AND its contents are different.\n    // A deeper comparison might be needed for complex objects.\n    if (nextProps.items.length !== this.props.items.length) {\n      return true; // Length changed, definitely re-render\n    }\n    // If lengths are same, check if specific items changed (shallow check)\n    for (let i = 0; i < nextProps.items.length; i++) {\n      if (nextProps.items[i] !== this.props.items[i]) {\n        return true; // An item changed, re-render\n      }\n    }\n    return false; // No relevant change, don't re-render\n  }\n\n  render() {\n    console.log('OptimizedList rendered');\n    return (\n      <ul>\n        {this.props.items.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    );\n  }\n}\n\n// Usage example:\n/*\nclass ParentComponent extends React.Component {\n  state = { data: ['A', 'B'] };\n\n  componentDidMount() {\n    // This will trigger a re-render but OptimizedList won't update\n    // because the data array reference changed but its content is same.\n    setTimeout(() => this.setState({ data: ['A', 'B'] }), 1000);\n\n    // This will trigger a re-render and OptimizedList WILL update\n    // because the content changes.\n    setTimeout(() => this.setState({ data: ['A', 'B', 'C'] }), 2000);\n  }\n\n  render() {\n    return <OptimizedList items={this.state.data} />;\n  }\n}\n*/\n",
              "explanation": "This `shouldComponentUpdate` implementation prevents the `OptimizedList` from re-rendering if its `items` prop array has the same length and its elements are shallowly equal. This can be effective for lists where the data might be frequently passed down, but the actual content doesn't always change, thus avoiding costly DOM updates.",
              "language": "typescript"
            },
            {
              "id": "example_pure_component_optimization",
              "title": "PureComponent vs. shouldComponentUpdate",
              "code": "import React, { PureComponent } from 'react';\n\n// Using PureComponent for shallow comparison\nclass MyPureComponent extends PureComponent {\n  render() {\n    console.log('MyPureComponent rendered');\n    return <div>Value: {this.props.value}</div>;\n  }\n}\n\n// Equivalent using shouldComponentUpdate (simplified)\nclass MyRegularComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Manual shallow comparison\n    if (nextProps.value !== this.props.value || nextState.someProp !== this.state.someProp) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    console.log('MyRegularComponent rendered');\n    return <div>Value: {this.props.value}</div>;\n  }\n}\n\n/*\nIn most cases, MyPureComponent is preferred for simplicity if a shallow comparison is sufficient.\n*/\n",
              "explanation": "`PureComponent` (or `React.memo` for functional components) offers a built-in optimization by performing a shallow comparison of props and state. This example illustrates how `PureComponent` achieves similar behavior to manually implementing `shouldComponentUpdate` for simple cases, reducing boilerplate and potential errors.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_should_component_update_purpose_mcq",
            "question_pure_component_scu_open",
            "question_scu_drawbacks_flashcard",
            "question_scu_implement_performance_code"
          ],
          "relatedTasks": [
            "task_optimize_component_with_scu"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Performance",
            "Optimization",
            "shouldComponentUpdate",
            "PureComponent"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_tuning",
            "complex_ui_optimization"
          ]
        },
        {
          "id": "theory_render_update_phase",
          "title": "render() in Updating Phase",
          "content": "The `render()` method functions the same way in the updating phase as it does in the mounting phase. It's a pure function that returns the React elements to be rendered to the DOM.\n\n### When is it called?\n- It is called if `shouldComponentUpdate` returns `true` (or by default, if `shouldComponentUpdate` is not implemented or returns `true`).\n- It's also called when `forceUpdate()` is invoked, bypassing `shouldComponentUpdate`.\n\n### Important Considerations:\n- **Pure Function**: `render()` should remain a pure function. It should not modify component state, perform side effects (like network requests or DOM manipulations), or interact with the browser directly. Any such operations belong in `componentDidUpdate` or other lifecycle methods.\n- **Returns**: It returns a React element (JSX), `null`, `false`, or an array/fragment of elements.\n- **Read-only**: `this.props` and `this.state` are read-only within `render()`.",
          "examples": [
            {
              "id": "example_render_update_1",
              "title": "Render Method Example",
              "code": "import React from 'react';\n\nclass DisplayMessage extends React.Component {\n  state = { message: 'Initial Message' };\n\n  componentDidMount() {\n    // Simulate a state update after 2 seconds\n    setTimeout(() => {\n      this.setState({ message: 'Updated Message after 2s' });\n    }, 2000);\n  }\n\n  render() {\n    console.log('render method called with message:', this.state.message);\n    return (\n      <div>\n        <h1>{this.state.message}</h1>\n        <p>Current Prop Value: {this.props.title}</p>\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <DisplayMessage title=\"My App\" />\n",
              "explanation": "This example shows the `render` method simply displaying content based on `this.state` and `this.props`. When `setState` is called in `componentDidMount`, the component will update, `render` will be called again, and the displayed message will change. The `render` method itself does not perform any side effects.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_render_purity_mcq",
            "question_render_side_effects_open"
          ],
          "relatedTasks": [],
          "tags": [
            "React",
            "Lifecycle",
            "Render",
            "Pure Function"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "class_components"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "component_rendering"
          ]
        },
        {
          "id": "theory_get_snapshot_before_update",
          "title": "getSnapshotBeforeUpdate(prevProps, prevState)",
          "content": "The `getSnapshotBeforeUpdate` method is invoked right before the most recently rendered output is committed to the DOM. It's a method that enables components to capture some information from the DOM (e.g., scroll position, element dimensions) *before* the DOM is potentially changed.\n\n### Purpose:\n- **Capture Pre-Update DOM State**: Allows you to read layout information from the DOM, such as scroll position or element size, just before React is about to make changes to the DOM. This information can then be passed to `componentDidUpdate` to perform necessary adjustments *after* the DOM has been updated.\n\n### Signature and Behavior:\n- **`prevProps`**: The props before the current update.\n- **`prevState`**: The state before the current update.\n- It must return a `snapshot` value (any type, or `null` if nothing to pass). This `snapshot` value will be passed as the third argument to `componentDidUpdate`.\n\n### Important Considerations:\n- **Rare Use Case**: This method is rarely needed. It's specifically for scenarios where you need to preserve some ephemeral UI state (like scroll position) that might be lost during a DOM update.\n- **Replaces `componentWillUpdate`**: It replaces the deprecated `componentWillUpdate` method, which was problematic because it was called *before* the render method, and changes made there might not reflect in the snapshot accurately.\n- **Side Effects**: Like `render`, `getSnapshotBeforeUpdate` should not cause side effects. Its purpose is to read from the DOM, not to modify it.",
          "examples": [
            {
              "id": "example_get_snapshot_before_update_1",
              "title": "Preserving Scroll Position",
              "code": "import React from 'react';\n\nclass ScrollableList extends React.Component {\n  listRef = React.createRef();\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Are we adding new items to the top of the list?\n    // If so, we need to adjust scroll position.\n    if (prevProps.list.length < this.props.list.length && this.props.scrollFromTop) {\n      const list = this.listRef.current;\n      // Capture scrollHeight and scrollTop before DOM update\n      return list.scrollHeight - list.scrollTop;\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      // Adjust scroll position after DOM update\n      list.scrollTop = list.scrollHeight - snapshot;\n    }\n  }\n\n  render() {\n    return (\n      <div ref={this.listRef} style={{ height: '200px', overflowY: 'scroll', border: '1px solid black' }}>\n        {this.props.list.map((item, index) => (\n          <div key={index} style={{ padding: '5px', borderBottom: '1px dashed #ccc' }}>{item}</div>\n        ))}\n      </div>\n    );\n  }\n}\n\n// Parent component to demonstrate:\n/*\nclass App extends React.Component {\n  state = { items: Array.from({ length: 20 }, (_, i) => `Item ${i + 1}`) };\n\n  addItemsToTop = () => {\n    this.setState(prevState => ({\n      items: Array.from({ length: 5 }, (_, i) => `New Item ${i + 1}`).concat(prevState.items)\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.addItemsToTop}>Add Items to Top</button>\n        <ScrollableList list={this.state.items} scrollFromTop={true} />\n      </div>\n    );\n  }\n}\n*/\n",
              "explanation": "This example demonstrates how to use `getSnapshotBeforeUpdate` to maintain scroll position when new items are added to the top of a list. Before the DOM updates, `getSnapshotBeforeUpdate` captures the difference between the current scroll height and scroll top. This 'snapshot' is then used in `componentDidUpdate` to adjust the `scrollTop` so the user's view remains stable despite new content appearing above.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_gsbu_purpose_mcq",
            "question_gsbu_return_value_flashcard",
            "question_gsbu_vs_cwupdate_open",
            "question_gsbu_dom_interaction_code"
          ],
          "relatedTasks": [
            "task_preserve_scroll_position"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "DOM",
            "Snapshot",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "refs",
            "dom_manipulation_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_ui_interactions",
            "legacy_react_understanding"
          ]
        },
        {
          "id": "theory_component_did_update",
          "title": "componentDidUpdate(prevProps, prevState, snapshot)",
          "content": "The `componentDidUpdate` method is called immediately after updating. This method is not called for the initial render. It's a crucial place for performing side effects after a component has re-rendered and the DOM has been updated.\n\n### Purpose:\n- **Side Effects**: Ideal for performing side effects such as network requests, DOM manipulation, or interacting with third-party libraries based on changes in props or state.\n- **Conditional `setState`**: You can call `setState()` here, but it **must** be wrapped in a conditional statement (e.g., comparing `prevProps` with `this.props`) to prevent an infinite loop. Calling `setState` unconditionally would trigger another update, which calls `componentDidUpdate` again, leading to a loop.\n- **Using Snapshot**: Receives the `snapshot` value returned by `getSnapshotBeforeUpdate`, allowing you to use pre-update DOM information after the update has completed.\n\n### Signature and Behavior:\n- **`prevProps`**: The props before the current update.\n- **`prevState`**: The state before the current update.\n- **`snapshot`**: The value returned by `getSnapshotBeforeUpdate` (if implemented), otherwise `undefined`.\n\n### Important Considerations:\n- **Compare Props/State**: Always compare `prevProps` and `prevState` with `this.props` and `this.state` to ensure that side effects are only performed when necessary, preventing redundant operations and potential infinite loops when calling `setState`.\n- **DOM Operations**: This is the earliest point where you can reliably interact with the updated DOM, as `render` has completed and the DOM has been patched.",
          "examples": [
            {
              "id": "example_component_did_update_1",
              "title": "Fetching Data on Prop Change",
              "code": "import React from 'react';\n\nclass UserProfile extends React.Component {\n  state = {\n    userData: null,\n    loading: true,\n    error: null,\n  };\n\n  componentDidMount() {\n    // Initial data fetch on mount\n    this.fetchData(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Only re-fetch data if userId prop has changed\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchData(this.props.userId);\n    }\n  }\n\n  fetchData = async (userId) => {\n    this.setState({ loading: true, error: null });\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ userData: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching user data:', error);\n      this.setState({ error: error.message, loading: false });\n    }\n  };\n\n  render() {\n    const { userData, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n    if (error) {\n      return <div>Error: {error}</div>;\n    }\n    if (!userData) {\n      return <div>No user data available.</div>;\n    }\n\n    return (\n      <div>\n        <h2>{userData.name}</h2>\n        <p>Email: {userData.email}</p>\n        <p>ID: {userData.id}</p>\n      </div>\n    );\n  }\n}\n\n// Usage (e.g., in a parent component):\n// <UserProfile userId={1} />\n// <UserProfile userId={2} /> // This prop change will trigger a new fetch\n",
              "explanation": "This `UserProfile` component fetches user data. `componentDidMount` handles the initial fetch. `componentDidUpdate` then listens for changes in `userId` prop and re-fetches data only when it changes, preventing redundant API calls and potential infinite loops. It also includes basic loading and error handling.",
              "language": "typescript"
            },
            {
              "id": "example_component_did_update_2",
              "title": "Conditional setState to avoid infinite loop",
              "code": "import React from 'react';\n\nclass CounterDisplay extends React.Component {\n  state = { \n    count: 0,\n    message: '' \n  };\n\n  componentDidUpdate(prevProps, prevState) {\n    // Condition 1: Update message if count crosses 10\n    if (this.state.count > 10 && prevState.count <= 10) {\n      this.setState({ message: 'Count exceeded 10!' });\n    }\n\n    // Condition 2: Reset count if prop 'resetTrigger' changes\n    if (this.props.resetTrigger !== prevProps.resetTrigger && this.props.resetTrigger) {\n      // This setState will trigger another update, but the condition ensures\n      // it only happens once per resetTrigger change, avoiding infinite loop.\n      this.setState({ count: 0, message: 'Count reset!' });\n    }\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.message}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <CounterDisplay resetTrigger={false} />\n// <CounterDisplay resetTrigger={true} /> // will reset count\n",
              "explanation": "This example shows how `setState` can be safely used within `componentDidUpdate`. The first `setState` updates `message` only when `count` crosses 10. The second `setState` resets the `count` and `message` if `this.props.resetTrigger` changes to `true`. Both are guarded by conditions comparing current and previous states/props to prevent uncontrolled re-renders and infinite loops.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_cdu_purpose_mcq",
            "question_cdu_infinite_loop_open",
            "question_cdu_snapshot_flashcard",
            "question_cdu_data_fetch_code"
          ],
          "relatedTasks": [
            "task_fetch_data_on_prop_change",
            "task_implement_conditional_state_update"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Side Effects",
            "API Calls",
            "DOM Manipulation",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "state_props",
            "async_js"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_fetching",
            "complex_interactivity",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_react_unmount_lifecycle_overview",
          "title": "React Component Lifecycle: Unmounting Phase Overview",
          "content": "The unmounting phase is the final stage of a React component's lifecycle. It occurs when a component is being removed from the DOM, either because it's no longer needed, its parent unmounted, or its `render` method no longer includes it.\n\n### Purpose:\n- **Cleanup**: The primary purpose of this phase is to perform any necessary cleanup before the component is destroyed. This prevents memory leaks and ensures that resources are properly released.\n\n### Method in Unmounting Phase:\n1.  `componentWillUnmount()`",
          "examples": [
            {
              "id": "example_react_unmount_lifecycle_overview_1",
              "title": "Simulating Unmounting",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\n\nclass DisposableComponent extends React.Component {\n  componentWillUnmount() {\n    console.log('DisposableComponent: componentWillUnmount called!');\n  }\n\n  render() {\n    return <div>I am a component that will be unmounted.</div>;\n  }\n}\n\nclass App extends React.Component {\n  state = { showComponent: true };\n\n  toggleComponent = () => {\n    this.setState(prevState => ({ showComponent: !prevState.showComponent }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.toggleComponent}>\n          {this.state.showComponent ? 'Unmount Component' : 'Mount Component'}\n        </button>\n        {this.state.showComponent && <DisposableComponent />}\n      </div>\n    );\n  }\n}\n\n// To see this in action:\n// ReactDOM.render(<App />, document.getElementById('root'));\n// Click the 'Unmount Component' button and observe the console log.\n",
              "explanation": "This example demonstrates how a component (`DisposableComponent`) is unmounted from the DOM. When the `toggleComponent` button is clicked and `showComponent` becomes `false`, `DisposableComponent` is no longer rendered. At this point, its `componentWillUnmount` method is called, which logs a message to the console, signifying the cleanup phase.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_unmount_phase_purpose_mcq",
            "question_unmount_trigger_open"
          ],
          "relatedTasks": [],
          "tags": [
            "React",
            "Lifecycle",
            "Unmounting Phase",
            "Cleanup"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "class_components"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "resource_management"
          ]
        },
        {
          "id": "theory_component_will_unmount",
          "title": "componentWillUnmount()",
          "content": "The `componentWillUnmount` method is invoked immediately before a component is unmounted and destroyed from the DOM. It's the ideal and last opportunity to perform any necessary cleanup for the component.\n\n### Purpose:\n- **Cleanup**: This is the designated place to tear down or clean up any resources that were set up in `componentDidMount` (or other lifecycle methods) to prevent memory leaks and ensure proper resource management.\n\n### Common Cleanup Tasks:\n- **Canceling network requests**: Prevents `setState` on an unmounted component, which would cause a warning or error.\n- **Invalidating timers**: Clear `setTimeout` and `setInterval` calls.\n- **Removing event listeners**: Unsubscribe from `window`, `document`, or other non-React DOM elements' events.\n- **Cleaning up subscriptions**: Unsubscribe from global event buses or Redux store subscriptions.\n- **Destroying non-React DOM elements**: If you manually created any DOM nodes outside of React's control, destroy them here.\n\n### Important Considerations:\n- **No `setState()`**: You should **NOT** call `setState()` in `componentWillUnmount()` because the component is about to be unmounted and will never re-render. Calling `setState` here is pointless and can lead to warnings or errors in development mode.\n- **Final Opportunity**: After `componentWillUnmount` executes, the component instance is destroyed and will not be remounted.\n- **Memory Leaks**: Failure to perform proper cleanup (e.g., leaving event listeners or timers active) can lead to memory leaks, where resources are consumed by components that are no longer part of the active application.",
          "examples": [
            {
              "id": "example_component_will_unmount_1",
              "title": "Cleaning Up Timers and Event Listeners",
              "code": "import React from 'react';\n\nclass TimerAndResizeTracker extends React.Component {\n  state = { \n    seconds: 0,\n    windowWidth: window.innerWidth\n  };\n  timerId = null;\n\n  componentDidMount() {\n    // Set up a timer\n    this.timerId = setInterval(() => {\n      this.setState(prevState => ({ seconds: prevState.seconds + 1 }));\n    }, 1000);\n\n    // Add a resize event listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount: Cleaning up resources');\n    // Clean up the timer\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log('Timer cleared.');\n    }\n    // Remove the event listener\n    window.removeEventListener('resize', this.handleResize);\n    console.log('Resize event listener removed.');\n  }\n\n  handleResize = () => {\n    this.setState({ windowWidth: window.innerWidth });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Seconds: {this.state.seconds}</p>\n        <p>Window Width: {this.state.windowWidth}px</p>\n        <p>Resize your browser window or wait for timer.</p>\n      </div>\n    );\n  }\n}\n\n/*\nTo test:\n1. Render <TimerAndResizeTracker />\n2. Open console and observe seconds updating.\n3. Resize window and observe width updating.\n4. Unmount the component (e.g., using a parent toggle as in the previous example).\n5. Observe the 'Cleaning up resources' logs and confirm timer/listener are stopped.\n*/\n",
              "explanation": "This example shows a component that sets up a `setInterval` timer and a `window.resize` event listener in `componentDidMount`. Crucially, `componentWillUnmount` is used to call `clearInterval` and `removeEventListener`. This ensures that when the component is removed from the DOM, these background processes are stopped, preventing memory leaks and errors (e.g., trying to `setState` on an unmounted component).",
              "language": "typescript"
            },
            {
              "id": "example_component_will_unmount_2",
              "title": "Canceling Network Request (Example)",
              "code": "import React from 'react';\n\n// This is a simplified example. In a real app, you'd use AbortController or a library.\nconst cancellableFetch = (url, options) => {\n  let controller = new AbortController();\n  let signal = controller.signal;\n\n  const promise = fetch(url, { ...options, signal });\n\n  return {\n    promise: promise,\n    cancel: () => controller.abort() // Abort the fetch request\n  };\n};\n\nclass DataFetcher extends React.Component {\n  state = { data: null, loading: true, error: null };\n  fetchRequest = null;\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    // If a fetch request is pending, cancel it to avoid setting state on unmounted component\n    if (this.fetchRequest) {\n      this.fetchRequest.cancel();\n      console.log('Network request cancelled in componentWillUnmount.');\n    }\n  }\n\n  fetchData = async () => {\n    this.setState({ loading: true, error: null });\n    try {\n      this.fetchRequest = cancellableFetch('https://api.example.com/data');\n      const response = await this.fetchRequest.promise;\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ data, loading: false });\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        console.log('Fetch aborted.');\n      } else {\n        console.error('Fetch error:', error);\n        this.setState({ error: error.message, loading: false });\n      }\n    }\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading...</div>;\n    if (this.state.error) return <div>Error: {this.state.error}</div>;\n    return <div>Data: {JSON.stringify(this.state.data)}</div>;\n  }\n}\n\n/*\nTo test:\n1. Mount <DataFetcher />\n2. Immediately unmount it before the fetch completes (e.g., via a parent toggle).\n3. Observe 'Network request cancelled' log, preventing 'setState on unmounted component' warning.\n*/\n",
              "explanation": "This example illustrates how to cancel a pending network request using `componentWillUnmount`. By leveraging an `AbortController` (or similar mechanism), the `fetchRequest` initiated in `componentDidMount` can be aborted if the component is unmounted before the request completes. This prevents common React warnings about trying to `setState` on an unmounted component, which can happen if the async operation resolves after the component is gone.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_cwunmount_purpose_mcq",
            "question_cwunmount_no_setstate_open",
            "question_cwunmount_memory_leaks_flashcard",
            "question_cwunmount_cleanup_code"
          ],
          "relatedTasks": [
            "task_implement_cleanup_in_cwu"
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Cleanup",
            "Memory Leaks",
            "Event Listeners",
            "Timers",
            "Network Requests"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "async_js",
            "event_handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "resource_management",
            "bug_prevention",
            "performance_tuning"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_update_lifecycle_order_mcq",
          "topic": "React Updating Phase",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following represents the correct order of lifecycle methods called during the React component's updating phase?",
          "answer": "static getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate",
          "options": [
            "componentDidUpdate, render, shouldComponentUpdate, static getDerivedStateFromProps, getSnapshotBeforeUpdate",
            "static getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate",
            "render, static getDerivedStateFromProps, componentDidUpdate, shouldComponentUpdate, getSnapshotBeforeUpdate",
            "shouldComponentUpdate, render, componentDidUpdate, static getDerivedStateFromProps, getSnapshotBeforeUpdate"
          ],
          "analysisPoints": [
            "Tests knowledge of the precise order of execution for React's updating lifecycle methods.",
            "Differentiates between methods called before render (getDerivedStateFromProps, shouldComponentUpdate) and after render (getSnapshotBeforeUpdate, componentDidUpdate).",
            "Confirms understanding that `static getDerivedStateFromProps` is the first method called in the update cycle (after new props/state trigger).",
            "Highlights the position of `getSnapshotBeforeUpdate` immediately before DOM commit and its relationship with `componentDidUpdate`."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Updating Phase",
            "Method Order",
            "getDerivedStateFromProps",
            "shouldComponentUpdate",
            "render",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate"
          ],
          "evaluationCriteria": [
            "Accurate recall of lifecycle method sequence.",
            "Ability to distinguish between render-phase and commit-phase methods."
          ],
          "example": "The update lifecycle methods follow a strict sequence to ensure proper state derivation, rendering optimization, UI updates, and side effect management.",
          "tags": [
            "React",
            "Lifecycle",
            "Updating Phase",
            "Order"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_update_triggers_open",
          "topic": "React Updating Phase Triggers",
          "level": "medium",
          "type": "open",
          "question": "What are the primary triggers that initiate the 'updating' phase of a React class component's lifecycle? Explain how each trigger leads to an update.",
          "answer": "The primary triggers that initiate the updating phase of a React class component's lifecycle are:\n\n1.  **New props from parent:** When a parent component re-renders and passes new props to its child component, the child component will undergo an update cycle. React's reconciliation process will compare the new props with the existing ones, and if differences are found (or if `shouldComponentUpdate` allows), the child will update.\n\n2.  **`this.setState()` calls:** When `this.setState()` is called within a component (or any of its children, which then causes the parent to re-render), React schedules an update for that component. This method is the primary way for a component's internal state to change, leading to a re-render to reflect the new state.\n\n3.  **`this.forceUpdate()` calls:** This method explicitly forces a component to re-render, bypassing `shouldComponentUpdate()`. While generally discouraged due to its potential to hide performance issues, it can be used in rare cases where the component's state or props haven't nominally changed but its output needs to update (e.g., when deeply nested mutable data changes without a state or prop reference change).",
          "analysisPoints": [
            "Tests comprehensive understanding of the events that cause a React component to re-render.",
            "Assesses ability to articulate the mechanism behind each trigger.",
            "Evaluates awareness of `forceUpdate` as an explicit, less common trigger."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Updating Phase",
            "Props",
            "State",
            "setState",
            "forceUpdate",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Completeness of triggers listed.",
            "Accuracy of explanation for each trigger.",
            "Clarity and conciseness of response."
          ],
          "example": "Understanding these triggers is fundamental to predicting component behavior and debugging rendering issues.",
          "tags": [
            "React",
            "Lifecycle",
            "Updating Phase",
            "Props",
            "State",
            "forceUpdate"
          ],
          "prerequisites": [
            "react_basics",
            "state_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_phases_flashcard",
          "topic": "React Lifecycle Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the three main phases of a React class component's lifecycle?",
          "answer": "Mounting, Updating, and Unmounting.",
          "analysisPoints": [
            "Tests basic recall of React component lifecycle phases."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Mounting Phase",
            "Updating Phase",
            "Unmounting Phase"
          ],
          "evaluationCriteria": [
            "Correct identification of all three phases."
          ],
          "example": "Knowing these phases helps understand when different lifecycle methods are called.",
          "tags": [
            "React",
            "Lifecycle",
            "Phases"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_gdsfp_purpose_mcq",
          "topic": "static getDerivedStateFromProps",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of `static getDerivedStateFromProps(props, state)`?",
          "answer": "To update the component's internal state based on changes in props, immediately before rendering.",
          "options": [
            "To perform side effects like data fetching after props change.",
            "To update the component's internal state based on changes in props, immediately before rendering.",
            "To prevent unnecessary re-renders of the component.",
            "To capture DOM information before the component updates the DOM."
          ],
          "analysisPoints": [
            "Distinguishes `getDerivedStateFromProps` from other lifecycle methods like `componentDidUpdate` (side effects), `shouldComponentUpdate` (optimization), and `getSnapshotBeforeUpdate` (DOM snapshot).",
            "Emphasizes its role in state derivation from props.",
            "Highlights its execution during the render phase."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Derived State",
            "Props to State",
            "Pure Function"
          ],
          "evaluationCriteria": [
            "Correct identification of method's specific purpose.",
            "Understanding of its timing in the lifecycle."
          ],
          "example": "```typescript\nclass MyComponent extends React.Component {\n  state = { count: 0 };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // If the 'maxCount' prop changes, reset the internal count\n    if (nextProps.maxCount !== prevState.derivedMaxCount) {\n      return {\n        count: 0,\n        derivedMaxCount: nextProps.maxCount\n      };\n    }\n    return null;\n  }\n\n  render() {\n    return <p>Count: {this.state.count}, Max: {this.props.maxCount}</p>;\n  }\n}\n```\nThis example shows `getDerivedStateFromProps` being used to reset the internal `count` state when the `maxCount` prop changes.",
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "State",
            "Props"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gdsfp_conditions_open",
          "topic": "static getDerivedStateFromProps Usage",
          "level": "hard",
          "type": "open",
          "question": "Explain the concept of 'derived state' and when `static getDerivedStateFromProps` is an appropriate (though rare) tool to manage it. What are its critical constraints and why should it be used with caution?",
          "answer": "Derived state refers to a component's internal state that is computed or synchronized based on its props. `static getDerivedStateFromProps` is a lifecycle method that allows a component to update its state based on prop changes just before every render. It's an appropriate tool when:\n\n*   **The state truly needs to be a direct 'derivation' of props:** For example, an `AlertDialog` component that needs to manage an `isOpen` state, but also needs to `reset` internal form data whenever the `dialogId` prop changes.\n*   **You need to 'reset' internal state when props change:** If a prop effectively changes the 'identity' of the data the component is displaying (e.g., `userId` prop changes on a profile component), you might derive a new loading state or clear previous data.\n\n**Critical Constraints:**\n\n1.  **Static Method, No `this`:** It's a static method, meaning it does not have access to `this` (the component instance). This prevents accessing instance properties, methods, or directly triggering side effects.\n2.  **Pure Function:** It must be a pure function. It should only compute state based on `props` and `state`, and return an object or `null`. It must not cause any side effects (e.g., network requests, DOM mutations, calling `setState` inside it).\n3.  **Called on Every Render:** It is called on *every* render, regardless of whether props have actually changed. This means any logic inside it needs to be carefully conditionalized to prevent redundant or incorrect state updates. Without proper `if (nextProps.someProp !== prevState.someDerivedProp)` checks, you can create performance issues or bugs.\n\n**Why use with caution?**\n\n*   **Complexity:** It adds complexity and can make it harder to trace state flow, especially if the derived state logic is not trivial.\n*   **Potential for Bugs:** Incorrect implementation (e.g., not properly checking for changes, introducing side effects) can lead to infinite loops, inconsistent UI, or performance degradation.\n*   **Alternatives Often Better:** Most use cases can often be handled more cleanly with:\n    *   **`componentDidUpdate`**: For side effects triggered by prop/state changes.\n    *   **Fully Controlled Components**: Where the parent component fully manages the state and passes it down as props, making the child purely presentational.\n    *   **Memoization**: For expensive computations based on props, perform them directly in `render` using memoization libraries like `reselect` or `useMemo` hooks (for functional components).",
          "analysisPoints": [
            "Defines derived state accurately.",
            "Identifies valid (though rare) use cases for `getDerivedStateFromProps`.",
            "Articulates the strict constraints (static, pure, called on every render).",
            "Explains the pitfalls and why caution is advised.",
            "Suggests alternative patterns for common scenarios."
          ],
          "keyConcepts": [
            "Derived State",
            "getDerivedStateFromProps",
            "Pure Function",
            "Side Effects",
            "Performance",
            "Controlled Components",
            "componentDidUpdate"
          ],
          "evaluationCriteria": [
            "Depth of explanation for 'derived state'.",
            "Thoroughness of constraints and caveats.",
            "Clarity on when to use vs. avoid.",
            "Ability to propose alternative solutions."
          ],
          "example": "Misusing `getDerivedStateFromProps` can lead to complex state management that is difficult to debug and maintain.",
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "Derived State",
            "Best Practices",
            "Anti-patterns"
          ],
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_gdsfp_pure_function_flashcard",
          "topic": "static getDerivedStateFromProps",
          "level": "medium",
          "type": "flashcard",
          "question": "Why must `static getDerivedStateFromProps` be a pure function, and what does this imply about its behavior?",
          "answer": "It must be a pure function because it runs during the 'render' phase of React's lifecycle. This implies it should only compute state based on inputs (props and state) and return an object or null, without causing any side effects (e.g., network requests, DOM manipulation, or calls to `setState`).",
          "analysisPoints": [
            "Tests understanding of the 'pure function' concept in the context of React lifecycle.",
            "Connects purity to the render phase.",
            "Identifies what actions are forbidden within this method due to its pure nature."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Pure Function",
            "Render Phase",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Correctly defines purity in this context.",
            "Lists examples of forbidden side effects."
          ],
          "example": "If `getDerivedStateFromProps` were not pure, it could introduce unpredictable behavior or break React's rendering optimizations.",
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "Pure Function",
            "Side Effects"
          ],
          "prerequisites": [
            "react_basics",
            "pure_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gdsfp_incorrect_use_code",
          "topic": "static getDerivedStateFromProps Misuse",
          "level": "hard",
          "type": "code",
          "question": "Consider the following component intended to fetch user data when the `userId` prop changes. Identify the incorrect use of `static getDerivedStateFromProps` and explain why it's problematic. Rewrite the component using the correct lifecycle method for this use case.",
          "answer": "The incorrect usage is attempting to perform a side effect (data fetching) directly within `static getDerivedStateFromProps`. This method is designed to be pure and should only return state updates or `null`; it has no access to `this` (instance methods like `fetchUserData`) and should not perform async operations or DOM manipulations.\n\n**Problematic Code:**\n```typescript\nimport React from 'react';\n\nclass UserProfileProblem extends React.Component {\n  state = { userData: null, loading: false };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (nextProps.userId !== prevState.currentUserId) {\n      // PROBLEMATIC: Attempting side effect (data fetch) in a pure, static method\n      // This method does not have 'this' context needed for fetchData.\n      // Even if it did, it's the wrong place for side effects.\n      // this.fetchData(nextProps.userId); // This would not work as 'this' is undefined\n      return {\n        loading: true,\n        userData: null, // Clear previous data\n        currentUserId: nextProps.userId // Store for comparison\n      };\n    }\n    return null;\n  }\n\n  fetchData = async (userId) => {\n    this.setState({ loading: true });\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`);\n      const data = await response.json();\n      this.setState({ userData: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching data:', error);\n      this.setState({ loading: false });\n    }\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading user data...</div>;\n    if (!this.state.userData) return <div>No user selected.</div>;\n    return (\n      <div>\n        <h2>{this.state.userData.name}</h2>\n        <p>Email: {this.state.userData.email}</p>\n      </div>\n    );\n  }\n}\n```\n\n**Corrected Component using `componentDidUpdate`:**\n`componentDidUpdate` is the correct lifecycle method for performing side effects like data fetching after a component has updated and its props/state have changed.\n\n```typescript\nimport React from 'react';\n\nclass UserProfileCorrected extends React.Component {\n  state = { userData: null, loading: false };\n\n  componentDidMount() {\n    // Initial fetch when component mounts\n    this.fetchData(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Correct: Fetch data here when userId prop changes\n    if (this.props.userId !== prevProps.userId) {\n      this.fetchData(this.props.userId);\n    }\n  }\n\n  fetchData = async (userId) => {\n    this.setState({ loading: true });\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`);\n      const data = await response.json();\n      this.setState({ userData: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching data:', error);\n      this.setState({ loading: false });\n    }\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading user data...</div>;\n    if (!this.state.userData) return <div>No user selected.</div>;\n    return (\n      <div>\n        <h2>{this.state.userData?.name}</h2>\n        <p>Email: {this.state.userData?.email}</p>\n      </div>\n    );\n  }\n}\n```",
          "analysisPoints": [
            "Identifies the anti-pattern of side effects in `getDerivedStateFromProps`.",
            "Explains the reasons for the problem (static context, purity requirement).",
            "Demonstrates the correct application of `componentDidUpdate` for data fetching.",
            "Shows how to handle initial data fetch and subsequent fetches on prop changes.",
            "Highlights the importance of `prevProps` comparison in `componentDidUpdate`."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "componentDidUpdate",
            "Side Effects",
            "Data Fetching",
            "Pure Function",
            "Anti-pattern",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Correct identification of the problem.",
            "Clear explanation of why it's problematic.",
            "Accurate and idiomatic refactoring using the appropriate lifecycle method.",
            "Consideration of both initial and subsequent data fetches."
          ],
          "example": "This is a common mistake for developers new to the modern React lifecycle, highlighting the strict separation of concerns.",
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "componentDidUpdate",
            "Data Fetching",
            "Anti-pattern",
            "Code Refactoring"
          ],
          "prerequisites": [
            "react_class_components",
            "async_js"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_should_component_update_purpose_mcq",
          "topic": "shouldComponentUpdate",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of the `shouldComponentUpdate(nextProps, nextState)` lifecycle method?",
          "answer": "To allow React to know if a component's output is not affected by the current change in props or state, thereby preventing unnecessary re-renders.",
          "options": [
            "To perform API calls before the component updates.",
            "To update the component's internal state based on new props.",
            "To allow React to know if a component's output is not affected by the current change in props or state, thereby preventing unnecessary re-renders.",
            "To clean up resources before the component is removed from the DOM."
          ],
          "analysisPoints": [
            "Tests understanding of `shouldComponentUpdate` as a performance optimization.",
            "Distinguishes its role from data fetching (`componentDidUpdate`), state derivation (`getDerivedStateFromProps`), and cleanup (`componentWillUnmount`).",
            "Focuses on its return value's impact on the rendering process."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Re-render",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct identification of the method's core function.",
            "Differentiation from other lifecycle method purposes."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass OptimizedButton extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    // Only re-render if the 'label' or 'onClick' prop changes\n    return nextProps.label !== this.props.label || nextProps.onClick !== this.props.onClick;\n  }\n\n  render() {\n    console.log('Button rendered:', this.props.label);\n    return <button onClick={this.props.onClick}>{this.props.label}</button>;\n  }\n}\n```\nThis `shouldComponentUpdate` ensures the button only re-renders if its visible label or click handler has genuinely changed, saving rendering cycles if other unrelated props of its parent change.",
          "tags": [
            "React",
            "Lifecycle",
            "shouldComponentUpdate",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pure_component_scu_open",
          "topic": "PureComponent and shouldComponentUpdate",
          "level": "medium",
          "type": "open",
          "question": "Explain the relationship between `React.PureComponent` and `shouldComponentUpdate`. In what scenarios would you choose one over the other, and what are the limitations of `PureComponent`?",
          "answer": "`React.PureComponent` is a base class for React components that internally implements the `shouldComponentUpdate` lifecycle method with a shallow comparison of `props` and `state`. This means that if the props and state of a `PureComponent` are shallowly equal to the previous props and state, `shouldComponentUpdate` will return `false`, preventing an unnecessary re-render of the component and its children.\n\n**Relationship:** `PureComponent` essentially provides an opinionated, built-in `shouldComponentUpdate` logic, saving you from writing it manually.\n\n**Choosing one over the other:**\n\n*   **Choose `React.PureComponent` (or `React.memo` for functional components):**\n    *   When your component's props and state are simple (primitive values like numbers, strings, booleans) or immutable objects/arrays. Shallow comparison works well here.\n    *   When you want a quick and easy performance optimization without writing custom logic.\n    *   When you are confident that changes in nested data structures will always result in new object/array references.\n\n*   **Choose custom `shouldComponentUpdate`:**\n    *   When `PureComponent`'s shallow comparison is insufficient because your component deals with deeply nested data structures, and you need a custom deep comparison logic (though deep comparison can be expensive itself).\n    *   When you need highly specific or complex logic to determine if a re-render is necessary that goes beyond simple equality checks (e.g., checking only specific keys, or comparing only a subset of props).\n    *   When you inherit from `React.Component` and have a specific performance bottleneck that `PureComponent` doesn't address.\n\n**Limitations of `PureComponent`:**\n\n1.  **Shallow Comparison Only:** This is the main limitation. If your props or state contain deeply nested objects or arrays, and a property within those nested structures changes, `PureComponent` will *not* detect this change because the top-level reference to the object/array remains the same. This can lead to your component not updating when it should.\n    ```javascript\n    // If user object changes like this, PureComponent WILL NOT re-render:\n    const prevProps = { user: { name: 'Alice', age: 30 } };\n    const nextProps = { user: { name: 'Alice', age: 31 } }; // 'user' reference is same\n    ```\n2.  **Context API:** `PureComponent` does not optimize updates related to `contextType` or `useContext`. A component using context will still re-render when context values change, regardless of `PureComponent`.\n3.  **Performance cost of comparison:** While it optimizes rendering, the shallow comparison itself still has a small cost. For very simple components that rarely update, the overhead might not be worth it compared to a regular `React.Component`.\n\nIn modern React, `React.memo` (for functional components) is the equivalent of `PureComponent` and often preferred for its simplicity with hooks.",
          "analysisPoints": [
            "Clearly defines `PureComponent` and its internal implementation of `shouldComponentUpdate`.",
            "Compares and contrasts scenarios for using `PureComponent` vs. a custom `shouldComponentUpdate`.",
            "Highlights the critical limitation of shallow comparison with concrete examples.",
            "Mentions other limitations like Context API and overhead."
          ],
          "keyConcepts": [
            "PureComponent",
            "shouldComponentUpdate",
            "Shallow Comparison",
            "Deep Comparison",
            "Performance Optimization",
            "React.memo",
            "Context API"
          ],
          "evaluationCriteria": [
            "Accurate description of relationship.",
            "Comprehensive list of use case scenarios.",
            "Clear explanation of `PureComponent` limitations with examples."
          ],
          "example": "Understanding the shallow comparison is critical to effectively using `PureComponent` and `React.memo`.",
          "tags": [
            "React",
            "PureComponent",
            "shouldComponentUpdate",
            "Performance",
            "Optimization",
            "Shallow Comparison",
            "Limitations"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_scu_drawbacks_flashcard",
          "topic": "shouldComponentUpdate Caveats",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the main risk or drawback of manually implementing `shouldComponentUpdate` incorrectly?",
          "answer": "The main risk is that an incorrect implementation (e.g., a buggy comparison logic) can prevent a component from re-rendering when it *should* have, leading to a stale or inconsistent UI that doesn't reflect the latest data.",
          "analysisPoints": [
            "Tests understanding of the potential negative consequences of misusing `shouldComponentUpdate`.",
            "Focuses on the critical outcome: UI inconsistencies."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Bugs",
            "UI Inconsistency",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Identifies the core problem of incorrect implementation."
          ],
          "example": "A button that doesn't update its text after a prop change because `shouldComponentUpdate` always returns `false` would be a common example of this drawback.",
          "tags": [
            "React",
            "Lifecycle",
            "shouldComponentUpdate",
            "Bugs",
            "UI"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_scu_implement_performance_code",
          "topic": "shouldComponentUpdate Implementation",
          "level": "medium",
          "type": "code",
          "question": "You have a `ProgressBar` component that receives a `progress` (number from 0-100) and a `label` string. The `ProgressBar` also has an internal `animationActive` boolean state. Implement `shouldComponentUpdate` for this component to prevent unnecessary re-renders. The component should only re-render if the `progress` prop changes significantly (e.g., by more than 1 unit), the `label` prop changes, or the `animationActive` state changes. Consider edge cases where `progress` might be a float.",
          "answer": "```typescript\nimport React from 'react';\n\nclass ProgressBar extends React.Component {\n  state = { animationActive: false };\n\n  // Assume some method that toggles animation, e.g., on hover\n  toggleAnimation = () => {\n    this.setState(prevState => ({ animationActive: !prevState.animationActive }));\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Check if label prop has changed\n    if (nextProps.label !== this.props.label) {\n      console.log('SCU: Label changed');\n      return true;\n    }\n\n    // Check if animationActive state has changed\n    if (nextState.animationActive !== this.state.animationActive) {\n      console.log('SCU: Animation state changed');\n      return true;\n    }\n\n    // Check if progress prop has changed significantly\n    // Using Math.abs to handle small float differences and comparing with 1 unit threshold\n    if (Math.abs(nextProps.progress - this.props.progress) > 1) {\n      console.log('SCU: Progress changed significantly');\n      return true;\n    }\n\n    console.log('SCU: No significant change, preventing re-render');\n    return false; // No significant change, prevent re-render\n  }\n\n  render() {\n    console.log(`ProgressBar rendered: ${this.props.label} - ${this.props.progress}%`);\n    const barStyle = {\n      width: `${this.props.progress}%`,\n      backgroundColor: this.state.animationActive ? 'orange' : 'skyblue',\n      height: '20px',\n      transition: this.state.animationActive ? 'width 0.3s ease-in-out' : 'none'\n    };\n    return (\n      <div style={{ border: '1px solid #ccc', width: '300px' }}>\n        <div style={barStyle}></div>\n        <p>{this.props.label}: {this.props.progress.toFixed(1)}% {this.state.animationActive ? '(Animating)' : ''}</p>\n        <button onClick={this.toggleAnimation}>Toggle Animation</button>\n      </div>\n    );\n  }\n}\n\n// Example Usage:\n/*\nclass App extends React.Component {\n  state = { currentProgress: 0 };\n\n  componentDidMount() {\n    // Simulate frequent small updates\n    this.interval = setInterval(() => {\n      this.setState(prevState => ({\n        currentProgress: (prevState.currentProgress + 0.5) % 101 // small change\n      }));\n    }, 50);\n\n    // Simulate larger changes\n    setTimeout(() => this.setState({ currentProgress: 50 }), 2000);\n    setTimeout(() => this.setState({ currentProgress: 95 }), 4000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    return <ProgressBar progress={this.state.currentProgress} label=\"Task Progress\" />;\n  }\n}\n*/\n```",
          "analysisPoints": [
            "Demonstrates conditional logic within `shouldComponentUpdate` based on specific prop and state changes.",
            "Handles numerical comparisons with a tolerance for floats (`Math.abs` and threshold).",
            "Correctly returns `true` or `false` based on the comparison results.",
            "Shows how `console.log` can be used to observe `shouldComponentUpdate`'s behavior.",
            "Illustrates a practical use case for performance optimization.",
            "Covers both prop and state changes as criteria."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Conditional Rendering",
            "Props Comparison",
            "State Comparison",
            "Floating Point Comparison"
          ],
          "evaluationCriteria": [
            "Correct implementation of `shouldComponentUpdate`.",
            "Accurate handling of numerical comparison (especially floats).",
            "Logical conditions for re-rendering.",
            "Prevention of unnecessary re-renders as per requirements."
          ],
          "example": "This task requires careful comparison logic to ensure the component re-renders only when truly necessary, optimizing performance for frequently changing props.",
          "tags": [
            "React",
            "Lifecycle",
            "shouldComponentUpdate",
            "Performance",
            "Optimization",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_class_components",
            "props_state"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_purity_mcq",
          "topic": "render() Method",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following operations should NOT be performed inside the `render()` method of a React class component?",
          "answer": "Modifying component state using `this.setState()`.",
          "options": [
            "Returning JSX elements.",
            "Accessing `this.props` to display data.",
            "Modifying component state using `this.setState()`.",
            "Using `map()` to render a list of items."
          ],
          "analysisPoints": [
            "Tests fundamental understanding of `render` method's purity.",
            "Identifies `setState` as a side effect that should not occur in `render`.",
            "Distinguishes allowed (pure rendering logic) from disallowed operations (side effects)."
          ],
          "keyConcepts": [
            "render method",
            "Pure Function",
            "Side Effects",
            "setState"
          ],
          "evaluationCriteria": [
            "Correctly identifies the forbidden operation.",
            "Understanding of the pure nature of `render`."
          ],
          "example": "If `setState` is called inside `render`, it can lead to an infinite loop of re-renders and errors, as `setState` triggers an update, which calls `render` again, and so on.",
          "tags": [
            "React",
            "Lifecycle",
            "render",
            "Pure Function",
            "Side Effects"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_side_effects_open",
          "topic": "render() Side Effects",
          "level": "medium",
          "type": "open",
          "question": "Why is it considered an anti-pattern to perform side effects (like data fetching, DOM manipulation, or `setState`) directly within the `render()` method in React? What are the potential consequences, and which lifecycle methods are appropriate for such operations?",
          "answer": "It is considered an anti-pattern to perform side effects directly within the `render()` method because `render()` is expected to be a **pure function**. This means it should only compute the output based on `props` and `state` and not cause any observable changes outside its scope.\n\n**Potential Consequences:**\n\n1.  **Infinite Loops:** If `setState()` is called directly within `render()`, it will trigger another re-render, which calls `render()` again, leading to an uncontrolled infinite loop and a crash.\n2.  **Performance Issues:** `render()` can be called frequently (on every state or prop update of the component or its ancestors). Performing expensive operations like data fetching or complex DOM manipulations in `render()` would cause severe performance degradation and unnecessary resource consumption.\n3.  **Unpredictable Behavior/Bugs:** The order of rendering is not strictly guaranteed across different components or during initial vs. update renders. Side effects performed non-deterministically in `render()` can lead to hard-to-debug inconsistencies and race conditions.\n4.  **Violation of React Principles:** It breaks React's fundamental principle of a predictable, declarative UI. React expects `render()` to simply describe *what* the UI should look like, not *how* to achieve side effects.\n\n**Appropriate Lifecycle Methods for Side Effects:**\n\n*   **`componentDidMount()`**: For side effects that should run once after the initial render (e.g., initial data fetching, setting up subscriptions, adding event listeners).\n*   **`componentDidUpdate(prevProps, prevState, snapshot)`**: For side effects that should run after subsequent re-renders, typically in response to prop or state changes (e.g., re-fetching data when an ID prop changes, updating DOM based on new state, conditional `setState`).\n*   **`componentWillUnmount()`**: For cleaning up any resources (e.g., removing event listeners, clearing timers, canceling network requests) that were set up in `componentDidMount` or `componentDidUpdate`.",
          "analysisPoints": [
            "Explains the 'pure function' concept for `render`.",
            "Lists and explains common consequences of violating `render`'s purity (infinite loops, performance, unpredictability).",
            "Identifies the correct lifecycle methods for various types of side effects (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`)."
          ],
          "keyConcepts": [
            "render method",
            "Pure Function",
            "Side Effects",
            "Anti-pattern",
            "componentDidMount",
            "componentDidUpdate",
            "componentWillUnmount",
            "Performance"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of the 'why'.",
            "Detailed list of consequences.",
            "Accurate mapping of side effects to appropriate lifecycle methods."
          ],
          "example": "A classic example of a `render` anti-pattern is `fetchData()` or `this.setState()` directly inside the `render` method, which inevitably leads to an infinite loop of fetches/renders.",
          "tags": [
            "React",
            "Lifecycle",
            "render",
            "Side Effects",
            "Anti-pattern",
            "Best Practices",
            "Performance"
          ],
          "prerequisites": [
            "react_basics",
            "lifecycle_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_gsbu_purpose_mcq",
          "topic": "getSnapshotBeforeUpdate",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of `getSnapshotBeforeUpdate(prevProps, prevState)`?",
          "answer": "To capture information from the DOM (e.g., scroll position) right before React commits the updated output to the DOM, which can then be used in `componentDidUpdate`.",
          "options": [
            "To decide if the component should re-render or not.",
            "To perform asynchronous data fetching before the component mounts.",
            "To capture information from the DOM (e.g., scroll position) right before React commits the updated output to the DOM, which can then be used in `componentDidUpdate`.",
            "To synchronize internal state with new props."
          ],
          "analysisPoints": [
            "Tests understanding of `getSnapshotBeforeUpdate`'s unique role in reading pre-DOM-update information.",
            "Distinguishes it from `shouldComponentUpdate` (re-render decision), `componentDidMount` (initial fetch), and `getDerivedStateFromProps` (state sync).",
            "Highlights its direct relationship with `componentDidUpdate` via the `snapshot` parameter."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "DOM Snapshot",
            "componentDidUpdate",
            "Lifecycle",
            "Scroll Position"
          ],
          "evaluationCriteria": [
            "Correct identification of its specific use case.",
            "Understanding of its timing relative to DOM updates."
          ],
          "example": "The most common use case for `getSnapshotBeforeUpdate` is managing scroll positions in chat applications or lists where new items are added, and the user's current view needs to be maintained.",
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "DOM",
            "Snapshot"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gsbu_return_value_flashcard",
          "topic": "getSnapshotBeforeUpdate Return Value",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `getSnapshotBeforeUpdate` return, and where is this returned value used?",
          "answer": "It returns a 'snapshot' value (which can be any type, or `null`). This value is then passed as the third argument to `componentDidUpdate`.",
          "analysisPoints": [
            "Tests recall of the `getSnapshotBeforeUpdate`'s return type.",
            "Confirms understanding of the data flow between `getSnapshotBeforeUpdate` and `componentDidUpdate`."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "Snapshot",
            "componentDidUpdate",
            "Return Value"
          ],
          "evaluationCriteria": [
            "Accurate description of return value.",
            "Correct identification of its destination."
          ],
          "example": "If `getSnapshotBeforeUpdate` returns `100`, then `componentDidUpdate(prevProps, prevState, 100)`.",
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "Snapshot",
            "componentDidUpdate"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gsbu_vs_cwupdate_open",
          "topic": "getSnapshotBeforeUpdate vs componentWillUpdate",
          "level": "hard",
          "type": "open",
          "question": "React's `getSnapshotBeforeUpdate` replaced the deprecated `componentWillUpdate`. Explain why `componentWillUpdate` was problematic and how `getSnapshotBeforeUpdate` addresses these issues, making it a safer alternative for capturing DOM information.",
          "answer": "`componentWillUpdate` was deprecated because it was called *before* the `render` method and before React applied any changes to the DOM. This meant that any DOM reads performed in `componentWillUpdate` would be based on the *previous* DOM state, not the state immediately *before* the current render's DOM changes were applied. If the `render` method or a child component in `render` caused a synchronous DOM mutation (e.g., due to a layout effect or third-party library), the snapshot taken in `componentWillUpdate` could be stale and incorrect.\n\n**Problems with `componentWillUpdate`:**\n\n1.  **Timing Issue:** It was called *before* `render` and *before* React potentially updated the DOM. If `render` itself or a child component triggered synchronous DOM changes, the snapshot taken in `componentWillUpdate` would be based on an outdated DOM.\n2.  **Unreliable DOM Reads:** The DOM might be in an inconsistent state during `componentWillUpdate` if React's internal processes or external factors modified it after `componentWillUpdate` but before the actual commit.\n\n**How `getSnapshotBeforeUpdate` Addresses These Issues:**\n\n`getSnapshotBeforeUpdate` is called right after `render` (and `static getDerivedStateFromProps`, `shouldComponentUpdate`), but *before* the rendered output is committed (i.e., actually applied) to the DOM. This precise timing ensures:\n\n1.  **Consistent DOM State for Snapshot:** When `getSnapshotBeforeUpdate` is called, React has just calculated the new virtual DOM tree, but the browser's actual DOM has *not yet* been updated. This means you can reliably read the current (pre-update) DOM properties (like scroll position, element dimensions) knowing that these values represent the state immediately before React's pending DOM mutations are applied.\n2.  **Direct Data Flow:** Any value returned by `getSnapshotBeforeUpdate` is explicitly passed as a `snapshot` argument to `componentDidUpdate`. This creates a clear, reliable channel to pass pre-update DOM information to the post-update phase, where you can then apply necessary adjustments (e.g., reset scroll position). This avoids relying on instance variables or indirect state updates.\n\nIn essence, `getSnapshotBeforeUpdate` provides a reliable 'last chance' to inspect the DOM *before* it changes, bridging the gap between the render phase and the commit phase, and solving the timing problem inherent in `componentWillUpdate`.",
          "analysisPoints": [
            "Explains the fundamental timing problem of `componentWillUpdate`.",
            "Highlights how `render` or synchronous DOM changes could invalidate `componentWillUpdate`'s snapshot.",
            "Describes the precise timing of `getSnapshotBeforeUpdate` (after render, before DOM commit).",
            "Explains how this timing ensures reliable DOM reads.",
            "Emphasizes the clear data flow from `getSnapshotBeforeUpdate` to `componentDidUpdate`.",
            "Relates the deprecation to the solution provided by the new method."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "componentWillUpdate",
            "Deprecation",
            "DOM Manipulation",
            "Timing",
            "Render Phase",
            "Commit Phase",
            "Snapshot"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of `componentWillUpdate`'s flaws.",
            "Clear articulation of `getSnapshotBeforeUpdate`'s advantages and solution.",
            "Understanding of React's render and commit phases."
          ],
          "example": "If you had a chat window and needed to maintain scroll position when new messages arrived, `componentWillUpdate` might give you a stale scroll position if the new messages were rendered and affected DOM size *before* `componentWillUpdate` finished. `getSnapshotBeforeUpdate` ensures you get the position just before the new messages become visible.",
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "componentWillUpdate",
            "Deprecation",
            "DOM",
            "Advanced"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_gsbu_dom_interaction_code",
          "topic": "getSnapshotBeforeUpdate Usage",
          "level": "medium",
          "type": "code",
          "question": "Implement a component called `AnimatedBox` that changes its width based on a prop `targetWidth`. Use `getSnapshotBeforeUpdate` to capture the *initial* width of the box just before the update occurs. Then, in `componentDidUpdate`, log the initial width, the new width, and the difference. This demonstrates reading a DOM property before it changes.",
          "answer": "```typescript\nimport React from 'react';\n\nclass AnimatedBox extends React.Component {\n  boxRef = React.createRef();\n\n  // State to manage current width for animation (optional, but makes it clear)\n  state = { currentWidth: this.props.initialWidth || 100 };\n\n  componentDidMount() {\n    // Ensure initial width is set\n    if (this.props.initialWidth) {\n      this.setState({ currentWidth: this.props.initialWidth });\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // If targetWidth prop changes, update currentWidth state\n    if (nextProps.targetWidth !== prevState.currentWidth) {\n      return { currentWidth: nextProps.targetWidth };\n    }\n    return null;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Capture the current width of the box element *before* the DOM updates\n    const boxElement = this.boxRef.current;\n    if (boxElement) {\n      const initialWidth = boxElement.offsetWidth;\n      console.log(`getSnapshotBeforeUpdate: Captured initial width: ${initialWidth}px`);\n      return initialWidth; // Pass this value as snapshot\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    const boxElement = this.boxRef.current;\n    if (boxElement && snapshot !== null) {\n      const finalWidth = boxElement.offsetWidth;\n      const widthDifference = finalWidth - snapshot;\n      console.log(`componentDidUpdate: Final width: ${finalWidth}px`);\n      console.log(`componentDidUpdate: Width difference (Final - Initial): ${widthDifference}px`);\n      \n      // Example of applying animation if needed after getting snapshot\n      // You could apply a class here to trigger a CSS transition\n      // this.boxRef.current.classList.add('animate-width');\n    }\n  }\n\n  render() {\n    const { currentWidth } = this.state;\n    console.log(`render: Rendering with width: ${currentWidth}px`);\n    return (\n      <div\n        ref={this.boxRef}\n        style={{\n          width: `${currentWidth}px`,\n          height: '50px',\n          backgroundColor: 'blue',\n          transition: 'width 0.5s ease-in-out'\n        }}\n      >\n        Box\n      </div>\n    );\n  }\n}\n\n// Example usage in a parent component:\n/*\nclass AppContainer extends React.Component {\n  state = { width: 100 };\n\n  componentDidMount() {\n    setInterval(() => {\n      this.setState(prevState => ({\n        width: prevState.width === 100 ? 300 : 100\n      }));\n    }, 2000);\n  }\n\n  render() {\n    return <AnimatedBox targetWidth={this.state.width} initialWidth={100} />;\n  }\n}\n*/\n```",
          "analysisPoints": [
            "Demonstrates the practical use of `React.createRef()` to access a DOM element.",
            "Shows how `getSnapshotBeforeUpdate` captures a DOM property (`offsetWidth`) immediately before the DOM update.",
            "Illustrates the transfer of the snapshot value to `componentDidUpdate`.",
            "Uses `componentDidUpdate` to compare the pre-update snapshot with the post-update DOM state.",
            "Includes `static getDerivedStateFromProps` to smoothly manage state transition from `targetWidth` prop.",
            "Incorporates console logs to visualize the timing of lifecycle methods and property changes."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "Refs",
            "DOM Manipulation",
            "Snapshot",
            "Lifecycle Order",
            "Animation"
          ],
          "evaluationCriteria": [
            "Correct use of `getSnapshotBeforeUpdate` for DOM reads.",
            "Effective passing and use of the snapshot in `componentDidUpdate`.",
            "Proper use of `React.createRef` for DOM access.",
            "Clear demonstration of before/after DOM state."
          ],
          "example": "This task simulates a scenario where understanding the DOM's state before a visual change is critical, often for smooth animations or layout adjustments.",
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "DOM",
            "Refs",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_class_components",
            "refs",
            "dom_manipulation_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_cdu_purpose_mcq",
          "topic": "componentDidUpdate",
          "level": "easy",
          "type": "mcq",
          "question": "What is the main responsibility of the `componentDidUpdate(prevProps, prevState, snapshot)` method?",
          "answer": "To perform side effects (e.g., API calls, DOM manipulation) after a component has updated, comparing previous and current props/state.",
          "options": [
            "To decide whether the component should re-render.",
            "To initialize state from props during mounting.",
            "To perform side effects (e.g., API calls, DOM manipulation) after a component has updated, comparing previous and current props/state.",
            "To clean up event listeners before the component is destroyed."
          ],
          "analysisPoints": [
            "Tests core understanding of `componentDidUpdate`'s role in handling post-render side effects.",
            "Emphasizes the importance of comparing `prevProps`/`prevState` to avoid infinite loops.",
            "Distinguishes it from `shouldComponentUpdate`, `constructor`/`getDerivedStateFromProps`, and `componentWillUnmount`."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "Side Effects",
            "API Calls",
            "DOM Manipulation",
            "Lifecycle",
            "prevProps",
            "prevState"
          ],
          "evaluationCriteria": [
            "Correct identification of the method's primary function.",
            "Understanding of its timing and parameters."
          ],
          "example": "A common use case is fetching new data when a `userId` prop changes: `if (this.props.userId !== prevProps.userId) { this.fetchData(this.props.userId); }`",
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "Side Effects",
            "API Calls"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cdu_infinite_loop_open",
          "topic": "componentDidUpdate and Infinite Loops",
          "level": "medium",
          "type": "open",
          "question": "Explain why calling `this.setState()` unconditionally inside `componentDidUpdate()` can lead to an infinite loop. Provide a simple code example of such a loop and explain how to correctly prevent it.",
          "answer": "Calling `this.setState()` unconditionally inside `componentDidUpdate()` creates an infinite loop because `setState()` itself triggers a component update. When `setState()` is called in `componentDidUpdate`, it causes the component to re-render, which in turn calls `componentDidUpdate` again, leading to a continuous cycle of updates and renders.\n\n**Example of an Infinite Loop:**\n```typescript\nimport React from 'react';\n\nclass InfiniteLoopComponent extends React.Component {\n  state = { count: 0 };\n\n  componentDidUpdate() {\n    console.log('componentDidUpdate called');\n    // PROBLEM: Unconditionally calls setState, causing an infinite loop\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    console.log('render called', this.state.count);\n    return <div>Count: {this.state.count}</div>;\n  }\n}\n\n// This component would crash the browser due to rapid, continuous re-renders.\n```\n\n**How to Correctly Prevent it:**\n\nTo prevent an infinite loop when calling `this.setState()` in `componentDidUpdate()`, you **must** wrap the `setState()` call in a conditional statement. This condition should check whether the relevant `props` or `state` values have actually changed in a way that warrants the new state update. By comparing `this.props` with `prevProps` or `this.state` with `prevState`, you ensure that `setState` is only called when a specific, meaningful change occurs, thus breaking the re-render cycle.\n\n**Corrected Example:**\n```typescript\nimport React from 'react';\n\nclass SafeUpdateComponent extends React.Component {\n  state = { count: 0, message: '' };\n\n  componentDidUpdate(prevProps, prevState) {\n    // GOOD: Conditionally call setState based on state change\n    if (this.state.count !== prevState.count && this.state.count >= 5) {\n      if (this.state.message === '') { // Only set message once\n        this.setState({ message: 'Count is 5 or more!' });\n      }\n    }\n\n    // GOOD: Conditionally call setState based on prop change\n    if (this.props.someProp !== prevProps.someProp) {\n      console.log('Prop changed, perhaps fetch new data or update state related to prop');\n      // Example: this.setState({ derivedFromProp: this.props.someProp * 2 });\n    }\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>{this.state.message}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n```",
          "analysisPoints": [
            "Clearly explains the mechanism of the infinite loop.",
            "Provides a concise and accurate problematic code example.",
            "Presents the correct solution: conditional `setState`.",
            "Offers a clear, runnable corrected code example.",
            "Emphasizes the role of `prevProps` and `prevState` for comparison."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "setState",
            "Infinite Loop",
            "Side Effects",
            "Conditional Logic",
            "prevProps",
            "prevState"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation for loop mechanism.",
            "Correctness and clarity of code examples.",
            "Demonstration of effective prevention strategy."
          ],
          "example": "This is one of the most common pitfalls when working with `componentDidUpdate`.",
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "setState",
            "Infinite Loop",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cdu_snapshot_flashcard",
          "topic": "componentDidUpdate Parameters",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the third parameter received by `componentDidUpdate`, and what is its origin?",
          "answer": "The third parameter is `snapshot`. It originates from the return value of `getSnapshotBeforeUpdate()`, which is called right before the DOM is updated. If `getSnapshotBeforeUpdate` is not implemented or returns `null`, `snapshot` will be `undefined`.",
          "analysisPoints": [
            "Tests recall of `componentDidUpdate` parameters.",
            "Confirms understanding of the `snapshot` parameter's purpose and its link to `getSnapshotBeforeUpdate`."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "snapshot",
            "getSnapshotBeforeUpdate",
            "Parameters"
          ],
          "evaluationCriteria": [
            "Correct identification of the parameter.",
            "Accurate explanation of its origin."
          ],
          "example": "You might use the `snapshot` to restore scroll position after a list update: `window.scrollTo(0, snapshot.scrollPos);`",
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "getSnapshotBeforeUpdate",
            "Snapshot"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cdu_data_fetch_code",
          "topic": "componentDidUpdate Data Fetching",
          "level": "medium",
          "type": "code",
          "question": "Create a React class component `UserPosts` that displays a list of posts for a given `userId` received as a prop. Implement data fetching in `componentDidUpdate` such that new posts are fetched only when the `userId` prop changes. Handle loading and error states.",
          "answer": "```typescript\nimport React from 'react';\n\nclass UserPosts extends React.Component {\n  state = {\n    posts: [],\n    loading: true,\n    error: null,\n  };\n\n  componentDidMount() {\n    // Initial data fetch when component mounts\n    this.fetchUserPosts(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Only fetch new posts if the userId prop has changed\n    if (this.props.userId !== prevProps.userId) {\n      this.fetchUserPosts(this.props.userId);\n    }\n  }\n\n  fetchUserPosts = async (userId) => {\n    this.setState({ loading: true, error: null, posts: [] }); // Reset state before new fetch\n    try {\n      // Simulate API call using JSONPlaceholder for example posts\n      const response = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${userId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ posts: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching posts:', error);\n      this.setState({ error: error.message, loading: false });\n    }\n  };\n\n  render() {\n    const { posts, loading, error } = this.state;\n    const { userId } = this.props;\n\n    if (loading) {\n      return <div>Loading posts for User ID: {userId}...</div>;\n    }\n\n    if (error) {\n      return <div>Error fetching posts for User ID: {userId}: {error}</div>;\n    }\n\n    if (posts.length === 0) {\n      return <div>No posts found for User ID: {userId}.</div>;\n    }\n\n    return (\n      <div>\n        <h3>Posts by User ID: {userId}</h3>\n        <ul>\n          {posts.map(post => (\n            <li key={post.id}>\n              <h4>{post.title}</h4>\n              <p>{post.body}</p>\n            </li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Example Parent Component for testing:\n/*\nclass App extends React.Component {\n  state = { currentUserId: 1 };\n\n  changeUser = (newId) => {\n    this.setState({ currentUserId: newId });\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.changeUser(1)}>Load User 1 Posts</button>\n        <button onClick={() => this.changeUser(2)}>Load User 2 Posts</button>\n        <button onClick={() => this.changeUser(999)}>Load Non-existent User Posts</button>\n        <UserPosts userId={this.state.currentUserId} />\n      </div>\n    );\n  }\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/\n```",
          "analysisPoints": [
            "Demonstrates proper use of `componentDidMount` for initial data fetch.",
            "Shows correct conditional data fetching in `componentDidUpdate` based on prop changes (`userId`).",
            "Includes robust error handling and loading states.",
            "Resets `posts` array and `error` state before new fetch to ensure correct UI during loading.",
            "Uses a public API (JSONPlaceholder) for realistic data fetching.",
            "Provides a clear `render` method to display posts or messages."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "componentDidMount",
            "Data Fetching",
            "API Calls",
            "Conditional Logic",
            "State Management",
            "Error Handling",
            "Loading State"
          ],
          "evaluationCriteria": [
            "Correct implementation of data fetching in lifecycle methods.",
            "Effective use of `prevProps` for conditional re-fetching.",
            "Proper handling of loading, error, and empty states.",
            "Clean and readable code structure."
          ],
          "example": "This is a very common interview task, demonstrating the ability to manage asynchronous operations and component updates.",
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "Data Fetching",
            "API",
            "Code Challenge",
            "State Management"
          ],
          "prerequisites": [
            "react_class_components",
            "async_js"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_unmount_phase_purpose_mcq",
          "topic": "React Unmounting Phase",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the 'unmounting' phase in a React component's lifecycle?",
          "answer": "To perform cleanup operations before the component is removed from the DOM.",
          "options": [
            "To initialize state and props for the component.",
            "To update the component's state based on new props.",
            "To render the component's UI to the DOM for the first time.",
            "To perform cleanup operations before the component is removed from the DOM."
          ],
          "analysisPoints": [
            "Tests basic understanding of the unmounting phase's role.",
            "Distinguishes cleanup from mounting, updating, and rendering phases."
          ],
          "keyConcepts": [
            "React Lifecycle",
            "Unmounting Phase",
            "Cleanup",
            "Memory Leaks"
          ],
          "evaluationCriteria": [
            "Correctly identifies the core purpose."
          ],
          "example": "This phase ensures resources like timers or event listeners are properly released.",
          "tags": [
            "React",
            "Lifecycle",
            "Unmounting Phase",
            "Cleanup"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_unmount_trigger_open",
          "topic": "React Unmounting Triggers",
          "level": "medium",
          "type": "open",
          "question": "Describe scenarios that would typically cause a React class component to enter its 'unmounting' phase.",
          "answer": "A React class component enters its 'unmounting' phase when it is removed from the DOM. Common scenarios that trigger unmounting include:\n\n1.  **Conditional Rendering:** A parent component stops rendering the child component, often controlled by a state or prop. For example, `render() { return this.state.showComponent ? <MyComponent /> : null; }`  when `showComponent` becomes `false`, `MyComponent` unmounts.\n\n2.  **Parent Component Unmounting:** If a parent component unmounts, all of its child components will also unmount, regardless of their own state or props.\n\n3.  **Key Changes in Lists:** When rendering a list of components using `map()` and assigning a `key` prop, if an item is removed from the list, or its `key` changes, the corresponding component instance will be unmounted and a new one might be mounted in its place. This is why stable `keys` are crucial.\n\n4.  **Routing Changes:** In single-page applications using client-side routing libraries (like React Router), navigating to a different route often means that components associated with the previous route are unmounted, and new components for the current route are mounted.\n\n5.  **Direct DOM Manipulation (Rare/Discouraged):** If external JavaScript or a library directly removes the DOM node that React is managing for the component, React will detect this and unmount the corresponding component instance. This is generally an anti-pattern as it bypasses React's reconciliation.",
          "analysisPoints": [
            "Identifies common and less common triggers for unmounting.",
            "Explains how each trigger leads to unmounting (e.g., `key` changes, conditional rendering).",
            "Demonstrates understanding of React's reconciliation process in context of unmounting."
          ],
          "keyConcepts": [
            "Unmounting Phase",
            "Conditional Rendering",
            "Keys",
            "Routing",
            "Reconciliation",
            "Parent-Child Relationship"
          ],
          "evaluationCriteria": [
            "Completeness and accuracy of scenarios.",
            "Clarity of explanation for each trigger.",
            "Understanding of underlying React mechanisms."
          ],
          "example": "Imagine a modal component that is shown/hidden based on a boolean prop. When the prop changes to `false`, the modal component unmounts.",
          "tags": [
            "React",
            "Lifecycle",
            "Unmounting Phase",
            "Triggers",
            "Conditional Rendering",
            "Keys",
            "Routing"
          ],
          "prerequisites": [
            "react_basics",
            "state_props"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cwunmount_purpose_mcq",
          "topic": "componentWillUnmount",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary function of `componentWillUnmount()` in a React class component?",
          "answer": "To perform necessary cleanup operations before the component is completely removed from the DOM.",
          "options": [
            "To re-render the component when new props are received.",
            "To set up initial state and event listeners for the component.",
            "To perform necessary cleanup operations before the component is completely removed from the DOM.",
            "To fetch data from an API after the component has rendered."
          ],
          "analysisPoints": [
            "Tests basic understanding of `componentWillUnmount`'s purpose.",
            "Distinguishes it from other lifecycle methods and their roles.",
            "Focuses on its role in preventing memory leaks."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "Cleanup",
            "Memory Leaks",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct identification of the method's core function."
          ],
          "example": "Clearing timers and removing event listeners are common tasks in `componentWillUnmount`.",
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "Cleanup",
            "Memory Leaks"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_cwunmount_no_setstate_open",
          "topic": "componentWillUnmount setState Restriction",
          "level": "medium",
          "type": "open",
          "question": "Why should you never call `this.setState()` inside `componentWillUnmount()`?",
          "answer": "You should never call `this.setState()` inside `componentWillUnmount()` because the component is about to be unmounted and destroyed from the DOM. After `componentWillUnmount` executes, the component instance is permanently removed from the render tree and will not be re-rendered. Therefore, any call to `setState()` would be pointless as it would trigger an update on a component that no longer exists in the DOM.\n\n**Reasons:**\n\n1.  **No Re-render:** The component instance is being destroyed. Even if `setState` were to update its internal state, there would be no subsequent `render()` call, and no effect on the DOM.\n2.  **Memory Leaks (Indirectly):** While `setState` itself doesn't directly cause a memory leak here, trying to perform actions on an 'about to be dead' component can sometimes indicate a larger issue or pattern that *could* lead to memory leaks if similar logic is applied elsewhere.\n3.  **Development Warnings/Errors:** React will often issue a warning in development mode (e.g., 'Can't perform a React state update on an unmounted component...') if you try to `setState` on an unmounted component, alerting you to a potential issue, even if it's not strictly a runtime error in all cases.\n\nThe primary purpose of `componentWillUnmount` is cleanup, not triggering new renders or state updates.",
          "analysisPoints": [
            "Explains the core reason: component is being destroyed and won't re-render.",
            "Articulates why `setState` would be pointless.",
            "Mentions potential development warnings/errors.",
            "Reinforces the correct purpose of `componentWillUnmount` (cleanup)."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "setState",
            "Unmounting",
            "Memory Leaks",
            "Lifecycle Restrictions"
          ],
          "evaluationCriteria": [
            "Clear and accurate explanation of the restriction.",
            "Understanding of component destruction process.",
            "Mention of practical implications (warnings)."
          ],
          "example": "If a `componentWillUnmount` tried to update a loading spinner state, it would be useless because the spinner component would already be gone.",
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "setState",
            "Restrictions"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cwunmount_memory_leaks_flashcard",
          "topic": "componentWillUnmount and Memory Leaks",
          "level": "medium",
          "type": "flashcard",
          "question": "What is a 'memory leak' in the context of React components, and how does `componentWillUnmount` help prevent them?",
          "answer": "A memory leak occurs when an application retains references to objects (like components, event listeners, timers, network requests) that are no longer needed, preventing them from being garbage-collected. This leads to increased memory usage over time. `componentWillUnmount` helps prevent memory leaks by providing a lifecycle hook to 'clean up' or 'tear down' these resources (e.g., removing event listeners, clearing timers, canceling subscriptions) before the component is destroyed, ensuring they are properly released.",
          "analysisPoints": [
            "Defines memory leak accurately.",
            "Explains how `componentWillUnmount` directly addresses the problem through cleanup."
          ],
          "keyConcepts": [
            "Memory Leak",
            "componentWillUnmount",
            "Cleanup",
            "Event Listeners",
            "Timers",
            "Subscriptions"
          ],
          "evaluationCriteria": [
            "Clear definition of memory leak.",
            "Correct explanation of method's preventative role.",
            "Examples of resources to clean up."
          ],
          "example": "If you add a `window.resize` event listener in `componentDidMount` but don't remove it in `componentWillUnmount`, that listener will persist even after the component is gone, leading to a memory leak.",
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "Memory Leaks",
            "Cleanup"
          ],
          "prerequisites": [
            "react_basics",
            "browser_events"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_cwunmount_cleanup_code",
          "topic": "componentWillUnmount Cleanup",
          "level": "medium",
          "type": "code",
          "question": "Create a React class component `CountdownTimer` that displays a countdown from a given `initialSeconds` prop. It should update every second. Implement the necessary lifecycle methods to start the timer when the component mounts and ensure it is properly stopped and cleaned up when the component unmounts to prevent memory leaks. Also, log messages to the console for mount, update, and unmount events.",
          "answer": "```typescript\nimport React from 'react';\n\nclass CountdownTimer extends React.Component {\n  state = {\n    secondsLeft: this.props.initialSeconds,\n  };\n  timerId = null; // To store the interval ID for cleanup\n\n  componentDidMount() {\n    console.log('CountdownTimer: componentDidMount - Starting timer.');\n    // Start the countdown timer\n    this.timerId = setInterval(() => {\n      this.setState(prevState => {\n        if (prevState.secondsLeft <= 1) {\n          clearInterval(this.timerId);\n          console.log('CountdownTimer: Timer finished.');\n          return { secondsLeft: 0 };\n        }\n        return { secondsLeft: prevState.secondsLeft - 1 };\n      });\n    }, 1000);\n  }\n\n  // Optional: If initialSeconds can change during component's lifetime\n  componentDidUpdate(prevProps) {\n    if (this.props.initialSeconds !== prevProps.initialSeconds) {\n      console.log('CountdownTimer: componentDidUpdate - initialSeconds changed, resetting timer.');\n      // Clear existing timer if prop changes, then restart\n      if (this.timerId) {\n        clearInterval(this.timerId);\n      }\n      this.setState({ secondsLeft: this.props.initialSeconds });\n      this.componentDidMount(); // Re-call mount logic to restart timer\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('CountdownTimer: componentWillUnmount - Clearing timer.');\n    // Crucial: Clean up the timer to prevent memory leaks\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      this.timerId = null;\n    }\n  }\n\n  render() {\n    console.log('CountdownTimer: render');\n    const { secondsLeft } = this.state;\n    return (\n      <div>\n        <h2>Countdown: {secondsLeft} seconds</h2>\n        {secondsLeft <= 0 && <p>Time's Up!</p>}\n      </div>\n    );\n  }\n}\n\n// Example Parent Component to demonstrate mounting/unmounting\n/*\nimport ReactDOM from 'react-dom';\nclass App extends React.Component {\n  state = { showTimer: true, initialDuration: 10 };\n\n  toggleTimer = () => {\n    this.setState(prevState => ({ showTimer: !prevState.showTimer }));\n  };\n\n  resetTimer = () => {\n    // Changing the key forces remounting, which triggers componentWillUnmount and then componentDidMount\n    this.setState(prevState => ({ initialDuration: prevState.initialDuration === 10 ? 15 : 10 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.toggleTimer}>Toggle Timer</button>\n        <button onClick={this.resetTimer}>Reset Timer (Remount)</button>\n        {this.state.showTimer && <CountdownTimer key={this.state.initialDuration} initialSeconds={this.state.initialDuration} />}\n      </div>\n    );\n  }\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/\n```",
          "analysisPoints": [
            "Correctly uses `componentDidMount` to start the `setInterval` timer.",
            "Crucially implements `componentWillUnmount` to `clearInterval`, preventing memory leaks.",
            "Manages state updates for the countdown correctly, including stopping the timer when it reaches zero.",
            "Includes optional `componentDidUpdate` logic to handle prop changes and reset the timer.",
            "Uses console logs to track lifecycle events and demonstrate proper cleanup.",
            "Uses `timerId` to store and clear the interval reference."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "componentDidMount",
            "Timers",
            "setInterval",
            "clearInterval",
            "Memory Leaks",
            "Cleanup",
            "State Management",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct timer setup and cleanup in appropriate lifecycle methods.",
            "Prevention of memory leaks through `clearInterval`.",
            "Accurate state management for the countdown.",
            "Clear logging to demonstrate lifecycle flow."
          ],
          "example": "This task is a fundamental test of understanding resource management within React components.",
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "componentDidMount",
            "Timers",
            "Memory Leaks",
            "Cleanup",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_class_components",
            "javascript_timers"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_update_lifecycle_logger",
          "title": "Implement a Component Demonstrating Update Lifecycle",
          "description": "\nCreate a React class component named `LifecycleLogger` that displays a `count` in its state and a `message` received as a prop. Implement the following lifecycle methods to log their execution order during an update:\n\n1.  `static getDerivedStateFromProps`: Log its call, and if `message` prop changes, update a derived state `displayMessage`.\n2.  `shouldComponentUpdate`: Log its call and return `true` unconditionally for now.\n3.  `render`: Log its call.\n4.  `getSnapshotBeforeUpdate`: Log its call and return a simple string 'Snapshot taken'.\n5.  `componentDidUpdate`: Log its call, and also log the `snapshot` received and if `message` prop actually changed.\n\nInclude a button in `render` that increments the `count` state to trigger updates. The goal is to visually observe the sequence of lifecycle method calls in the browser console when the component updates.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass LifecycleLogger extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      displayMessage: props.message || 'No message'\n    };\n    console.log('Constructor (mount)');\n  }\n\n  // 1. static getDerivedStateFromProps\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('1. static getDerivedStateFromProps');\n    // TODO: Implement logic to update displayMessage if message prop changes\n    return null; // or an object to update state\n  }\n\n  // 2. shouldComponentUpdate\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('2. shouldComponentUpdate');\n    // TODO: Implement logic to return true\n    return true;\n  }\n\n  // 3. render\n  render() {\n    console.log('3. render');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.displayMessage}</p>\n        <button onClick={() => this.setState(prevState => ({ count: prevState.count + 1 }))}>\n          Increment Count\n        </button>\n      </div>\n    );\n  }\n\n  // 4. getSnapshotBeforeUpdate\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('4. getSnapshotBeforeUpdate');\n    // TODO: Implement logic to return 'Snapshot taken'\n    return null; // or a snapshot value\n  }\n\n  // 5. componentDidUpdate\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('5. componentDidUpdate');\n    // TODO: Log snapshot and check if message prop changed\n  }\n\n  // Optional: componentWillUnmount for completeness if component is removed\n  componentWillUnmount() {\n    console.log('componentWillUnmount (cleanup)');\n  }\n}\n\n// Parent component for demonstration:\n/*\nclass App extends React.Component {\n  state = { appMessage: 'Initial App Message' };\n\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({ appMessage: 'Updated App Message' });\n    }, 3000);\n  }\n\n  render() {\n    return <LifecycleLogger message={this.state.appMessage} />;\n  }\n}\n// Render <App /> to observe lifecycle\n*/",
          "solutionCode": "import React from 'react';\n\nclass LifecycleLogger extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      displayMessage: props.message || 'No message'\n    };\n    console.log('Constructor (mount)');\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('1. static getDerivedStateFromProps');\n    // Update displayMessage if message prop changes\n    if (nextProps.message !== prevState.displayMessage) {\n      return {\n        displayMessage: nextProps.message\n      };\n    }\n    return null; // No state update needed from props\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('2. shouldComponentUpdate');\n    // Return true to allow rendering for this task\n    return true;\n  }\n\n  render() {\n    console.log('3. render');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.displayMessage}</p>\n        <button onClick={() => this.setState(prevState => ({ count: prevState.count + 1 }))}>\n          Increment Count\n        </button>\n      </div>\n    );\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('4. getSnapshotBeforeUpdate');\n    // Return a simple snapshot string\n    return 'Snapshot taken: ' + prevState.count; // Example: Capture old count\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('5. componentDidUpdate');\n    console.log('Snapshot received:', snapshot);\n    if (this.props.message !== prevProps.message) {\n      console.log('Message prop changed from \"' + prevProps.message + '\" to \"' + this.props.message + '\"');\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount (cleanup)');\n  }\n}\n",
          "testCases": [
            "Initial mount: Constructor, getDerivedStateFromProps, render, componentDidMount should log in order.",
            "Clicking 'Increment Count' button: should trigger getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate.",
            "Changing `message` prop from parent component: should also trigger the update sequence and log the prop change in componentDidUpdate."
          ],
          "hints": [
            "Remember that `static getDerivedStateFromProps` does not have access to `this`.",
            "The value returned by `getSnapshotBeforeUpdate` is passed as the third argument to `componentDidUpdate`.",
            "Use `console.log` at the beginning of each method to observe the execution order clearly."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "Updating Phase",
            "Logging",
            "Class Component"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_basics",
            "class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_update_lifecycle_overview",
            "static_get_derived_state_from_props",
            "should_component_update",
            "render_update_phase",
            "get_snapshot_before_update",
            "component_did_update"
          ]
        },
        {
          "id": "task_implement_gdsfp_prop_sync",
          "title": "Synchronize Internal State with Prop Changes using getDerivedStateFromProps",
          "description": "\nCreate a `ControlledInputWithReset` React class component. This component should display an input field whose value is controlled by its internal state. The internal state `inputValue` should be synchronized with a prop `externalValue`.\n\n**Requirements:**\n1.  The input's initial value should come from `externalValue` prop.\n2.  When `externalValue` prop changes, the internal `inputValue` state *must* update to reflect the new `externalValue`.\n3.  The user should be able to type into the input, and their input should update the `inputValue` state locally.\n4.  Use `static getDerivedStateFromProps` to handle the synchronization of `inputValue` with `externalValue`.\n5.  Ensure that `getDerivedStateFromProps` only updates the state when `externalValue` has actually changed, preventing unnecessary re-renders or infinite loops.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ControlledInputWithReset extends React.Component {\n  state = {\n    inputValue: '',\n  };\n\n  // TODO: Implement static getDerivedStateFromProps\n  // It should compare nextProps.externalValue with prevState.inputValue\n  // and return an object to update state or null.\n\n  handleChange = (event) => {\n    this.setState({ inputValue: event.target.value });\n  };\n\n  render() {\n    return (\n      <div>\n        <label>Input Value: </label>\n        <input\n          type=\"text\"\n          value={this.state.inputValue}\n          onChange={this.handleChange}\n        />\n        <p>Prop received: {this.props.externalValue}</p>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nclass App extends React.Component {\n  state = { parentValue: 'Hello' };\n\n  changeParentValue = () => {\n    this.setState(prevState => ({\n      parentValue: prevState.parentValue === 'Hello' ? 'World' : 'Hello'\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.changeParentValue}>Change External Value</button>\n        <ControlledInputWithReset externalValue={this.state.parentValue} />\n      </div>\n    );\n  }\n}\n// Render <App /> to test\n*/",
          "solutionCode": "import React from 'react';\n\nclass ControlledInputWithReset extends React.Component {\n  state = {\n    inputValue: this.props.externalValue || '',\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // Only update internal state if the externalValue prop has genuinely changed\n    // and is different from the current internal state (to avoid unnecessary updates).\n    if (nextProps.externalValue !== prevState.inputValue) {\n      return {\n        inputValue: nextProps.externalValue,\n      };\n    }\n    return null; // No state update needed\n  }\n\n  handleChange = (event) => {\n    this.setState({ inputValue: event.target.value });\n  };\n\n  render() {\n    return (\n      <div>\n        <label>Input Value: </label>\n        <input\n          type=\"text\"\n          value={this.state.inputValue}\n          onChange={this.handleChange}\n        />\n        <p>Prop received: {this.props.externalValue}</p>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial render: Input value should be 'Hello' if parent passes `externalValue=\"Hello\"`.",
            "User types: Typing 'XYZ' should change input to 'HelloXYZ', and `this.state.inputValue` should reflect 'HelloXYZ'.",
            "Parent changes `externalValue`: If parent changes `externalValue` from 'Hello' to 'World', the input field's value should automatically update to 'World', overriding any user input.",
            "Parent re-renders `externalValue` to same value: If `externalValue` prop is passed the same value, `getDerivedStateFromProps` should return `null` and not cause a re-render or state update.",
            "Empty `externalValue`: If `externalValue` is an empty string or undefined, input should handle it gracefully (e.g., show empty string)."
          ],
          "hints": [
            "Remember that `static getDerivedStateFromProps` is a `static` method and does not have access to `this` instance.",
            "The method should return an object to update state or `null` if no update is necessary.",
            "A critical part of the solution is comparing `nextProps.externalValue` with `prevState.inputValue` to prevent unnecessary updates or infinite loops if the prop hasn't changed.",
            "Consider how `inputValue` initially gets its value from `externalValue`."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "getDerivedStateFromProps",
            "Controlled Component",
            "State Management",
            "Props"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_static_get_derived_state_from_props"
          ]
        },
        {
          "id": "task_optimize_component_with_scu",
          "title": "Optimize Component Re-renders with shouldComponentUpdate",
          "description": "\nCreate a `DataDisplay` React class component that receives a `data` prop (an array of objects: `{ id: number, value: string }`) and a `version` prop (a number). This component should simulate an expensive rendering process.\n\n**Requirements:**\n1.  The component should render the `data` prop as an unordered list.\n2.  Implement `shouldComponentUpdate(nextProps, nextState)` to optimize performance.\n3.  The component should **only** re-render if:\n    *   The `version` prop changes.\n    *   The *length* of the `data` array changes.\n    *   Any `value` property of an object within the `data` array changes (a shallow check is sufficient for object content, but deep check for array reference).\n4.  Add a `console.log` inside the `render` method to confirm when it actually renders.\n5.  Add a `console.log` inside `shouldComponentUpdate` to indicate why it returned `true` or `false`.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\nclass DataDisplay extends React.Component {\n  // Simulate an expensive rendering operation\n  simulateExpensiveRender() {\n    let sum = 0;\n    for (let i = 0; i < 10000000; i++) {\n      sum += Math.sqrt(i);\n    }\n    console.log(`Expensive calculation sum: ${sum.toFixed(2)}`);\n  }\n\n  // TODO: Implement shouldComponentUpdate\n  shouldComponentUpdate(nextProps, nextState) {\n    // Return true or false based on requirements\n    return true; // Default behavior\n  }\n\n  render() {\n    console.log('DataDisplay: render method called');\n    this.simulateExpensiveRender(); // Call the expensive function\n\n    return (\n      <div>\n        <h3>Data Version: {this.props.version}</h3>\n        <ul>\n          {this.props.data.map(item => (\n            <li key={item.id}>{item.value}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nclass App extends React.Component {\n  state = {\n    data: [{ id: 1, value: 'Item A' }, { id: 2, value: 'Item B' }],\n    version: 1,\n    unrelatedProp: 0\n  };\n\n  componentDidMount() {\n    setInterval(() => {\n      // This should NOT trigger a re-render of DataDisplay\n      this.setState(prevState => ({ unrelatedProp: prevState.unrelatedProp + 1 }));\n    }, 1000);\n\n    setTimeout(() => {\n      // This SHOULD trigger a re-render (version changes)\n      this.setState({ version: 2 });\n    }, 3000);\n\n    setTimeout(() => {\n      // This SHOULD trigger a re-render (data length changes)\n      this.setState(prevState => ({\n        data: [...prevState.data, { id: 3, value: 'Item C' }],\n        version: prevState.version + 1 // also change version to ensure update\n      }));\n    }, 6000);\n\n    setTimeout(() => {\n      // This SHOULD trigger a re-render (value of an item changes)\n      this.setState(prevState => ({\n        data: prevState.data.map(item => item.id === 1 ? { ...item, value: 'Updated Item A' } : item),\n        version: prevState.version + 1 // also change version to ensure update\n      }));\n    }, 9000);\n\n    setTimeout(() => {\n        // This should NOT trigger a re-render (data reference changes but content is shallowly identical)\n        this.setState(prevState => ({\n            data: prevState.data.map(item => ({...item})), // New array & new objects, but same content\n            version: prevState.version // Version is same\n        }));\n    }, 12000);\n\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Unrelated Prop: {this.state.unrelatedProp}</p>\n        <DataDisplay data={this.state.data} version={this.state.version} />\n      </div>\n    );\n  }\n}\n// Render <App /> to test\n*/",
          "solutionCode": "import React from 'react';\n\nclass DataDisplay extends React.Component {\n  // Simulate an expensive rendering operation\n  simulateExpensiveRender() {\n    let sum = 0;\n    for (let i = 0; i < 10000000; i++) {\n      sum += Math.sqrt(i);\n    }\n    console.log(`Expensive calculation sum: ${sum.toFixed(2)}`);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Check if version prop has changed\n    if (nextProps.version !== this.props.version) {\n      console.log('SCU: Returning true - version prop changed.');\n      return true;\n    }\n\n    // Check if data array length has changed\n    if (nextProps.data.length !== this.props.data.length) {\n      console.log('SCU: Returning true - data array length changed.');\n      return true;\n    }\n\n    // Check if any item's 'value' in data array has changed (shallow content comparison)\n    // Assuming order of items is stable and items are objects with 'id' and 'value'\n    for (let i = 0; i < nextProps.data.length; i++) {\n      // Check if item exists at index and its value has changed\n      if (!this.props.data[i] || nextProps.data[i].value !== this.props.data[i].value) {\n        console.log(`SCU: Returning true - data item at index ${i} value changed.`);\n        return true;\n      }\n    }\n\n    console.log('SCU: Returning false - no significant prop/state changes.');\n    return false; // No significant change, prevent re-render\n  }\n\n  render() {\n    console.log('DataDisplay: render method called');\n    this.simulateExpensiveRender(); // Call the expensive function\n\n    return (\n      <div>\n        <h3>Data Version: {this.props.version}</h3>\n        <ul>\n          {this.props.data.map(item => (\n            <li key={item.id}>{item.value}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial render: `render` should be called once.",
            "Parent changes an `unrelatedProp`: `DataDisplay`'s `render` should NOT be called (due to `shouldComponentUpdate`). Console log should indicate `SCU: Returning false`.",
            "`version` prop changes: `DataDisplay`'s `render` SHOULD be called. Console log should show `SCU: Returning true - version prop changed`.",
            "`data` array length changes: `DataDisplay`'s `render` SHOULD be called. Console log should show `SCU: Returning true - data array length changed`.",
            "An item's `value` within `data` array changes (same array length, same reference, but internal object content changes): `DataDisplay`'s `render` SHOULD be called. Console log should show `SCU: Returning true - data item at index X value changed`.",
            "`data` array reference changes, but content is shallowly identical: `DataDisplay`'s `render` should NOT be called. Console log should indicate `SCU: Returning false`.",
            "Empty `data` array: Should handle gracefully."
          ],
          "hints": [
            "Remember that `shouldComponentUpdate` receives `nextProps` and `nextState`.",
            "When comparing arrays of objects, you'll need to iterate through them. A shallow comparison of object properties is often sufficient for performance gains without going too deep.",
            "Make sure your `console.log` statements clearly indicate *why* `shouldComponentUpdate` decided to re-render or not.",
            "Consider edge cases like empty arrays.",
            "Using `PureComponent` would also implement a shallow comparison but wouldn't allow the custom logic for specific changes like `data.length` or `item.value`."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "shouldComponentUpdate",
            "Performance",
            "Optimization",
            "Code Challenge",
            "Arrays",
            "Props"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "array_methods",
            "javascript_objects"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_should_component_update",
            "pure_component"
          ]
        },
        {
          "id": "task_preserve_scroll_position",
          "title": "Preserve Scroll Position with getSnapshotBeforeUpdate",
          "description": "\nCreate a React class component `ChatWindow` that displays a list of messages. This component should handle new messages being added, especially at the top of the list, while ensuring the user's scroll position is preserved (i.e., the view doesn't jump).\n\n**Requirements:**\n1.  The `ChatWindow` component should receive an array of `messages` (strings) as a prop.\n2.  Use a `ref` to access the DOM element of the scrollable chat container.\n3.  Implement `getSnapshotBeforeUpdate(prevProps, prevState)` to capture necessary DOM information *before* the new messages are rendered.\n4.  Implement `componentDidUpdate(prevProps, prevState, snapshot)` to use the captured snapshot to adjust the scroll position, ensuring the view remains stable when new messages are added to the `messages` array from the *top*.\n5.  Add console logs to `getSnapshotBeforeUpdate` and `componentDidUpdate` to show the captured snapshot and the scroll adjustment.\n6.  The component should have `overflowY: 'scroll'` and a fixed height to enable scrolling.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\nclass ChatWindow extends React.Component {\n  chatContainerRef = React.createRef();\n\n  // Optional: Scroll to bottom on initial mount or when messages are added to bottom\n  componentDidMount() {\n    this.scrollToBottom();\n  }\n\n  scrollToBottom = () => {\n    const chatContainer = this.chatContainerRef.current;\n    if (chatContainer) {\n      chatContainer.scrollTop = chatContainer.scrollHeight;\n    }\n  };\n\n  // TODO: Implement getSnapshotBeforeUpdate\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Capture necessary information before update\n    return null; // Return snapshot or null\n  }\n\n  // TODO: Implement componentDidUpdate\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // Use snapshot to adjust scroll position\n  }\n\n  render() {\n    return (\n      <div\n        ref={this.chatContainerRef}\n        style={{\n          height: '300px',\n          overflowY: 'scroll',\n          border: '1px solid #ccc',\n          padding: '10px',\n          display: 'flex',\n          flexDirection: 'column-reverse' // To make new messages appear at top visually\n        }}\n      >\n        {this.props.messages.map((msg, index) => (\n          <div key={index} style={{ marginBottom: '5px', background: '#f0f0f0', padding: '5px' }}>\n            {msg}\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nclass App extends React.Component {\n  state = {\n    messages: Array.from({ length: 15 }, (_, i) => `Initial Message ${i + 1}`)\n  };\n\n  addMessageToTop = () => {\n    const newMessage = `New Message ${this.state.messages.length + 1}`;\n    this.setState(prevState => ({\n      messages: [newMessage, ...prevState.messages]\n    }));\n  };\n\n  addMessageToBottom = () => {\n    const newMessage = `Bottom Message ${this.state.messages.length + 1}`;\n    this.setState(prevState => ({\n      messages: [...prevState.messages, newMessage]\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.addMessageToTop}>Add Message to Top</button>\n        <button onClick={this.addMessageToBottom}>Add Message to Bottom (no scroll adjust)</button>\n        <ChatWindow messages={this.state.messages} />\n      </div>\n    );\n  }\n}\n// Render <App /> to test\n*/",
          "solutionCode": "import React from 'react';\n\nclass ChatWindow extends React.Component {\n  chatContainerRef = React.createRef();\n\n  // Optional: Scroll to bottom on initial mount or when messages are added to bottom\n  componentDidMount() {\n    this.scrollToBottom();\n  }\n\n  scrollToBottom = () => {\n    const chatContainer = this.chatContainerRef.current;\n    if (chatContainer) {\n      chatContainer.scrollTop = chatContainer.scrollHeight;\n    }\n  };\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    const chatContainer = this.chatContainerRef.current;\n\n    // Only capture snapshot if messages are being added and this is a scenario\n    // where we need to adjust scroll (e.g., adding to top).\n    // This condition checks if new messages were added and the component is scrollable.\n    if (chatContainer && this.props.messages.length > prevProps.messages.length) {\n      const scrollOffset = chatContainer.scrollHeight - chatContainer.scrollTop;\n      console.log(`getSnapshotBeforeUpdate: Captured scroll offset: ${scrollOffset}px`);\n      return scrollOffset;\n    }\n    return null; // No snapshot needed\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    const chatContainer = this.chatContainerRef.current;\n\n    // Only apply adjustment if a snapshot was captured\n    if (snapshot !== null && chatContainer) {\n      // Adjust scroll position to maintain user's view relative to the bottom\n      chatContainer.scrollTop = chatContainer.scrollHeight - snapshot;\n      console.log(`componentDidUpdate: Adjusted scroll to ${chatContainer.scrollTop}px using snapshot: ${snapshot}px`);\n    } else if (this.props.messages.length > prevProps.messages.length && snapshot === null) {\n      // If new messages are added but no snapshot was taken (e.g., adding to bottom),\n      // or it's an initial render, scroll to bottom.\n      this.scrollToBottom();\n    }\n  }\n\n  render() {\n    return (\n      <div\n        ref={this.chatContainerRef}\n        style={{\n          height: '300px',\n          overflowY: 'scroll',\n          border: '1px solid #ccc',\n          padding: '10px',\n          display: 'flex',\n          flexDirection: 'column-reverse' // To make new messages appear at top visually\n        }}\n      >\n        {/* Reverse order for chat messages: newest at bottom (but UI displays them top-down) */}\n        {/* To make messages appear at the bottom of the scroll container, and new messages push old ones up,*/}\n        {/* the flex-direction: column-reverse is used here, so the rendering order in JSX needs to be adjusted. */}\n        {/* If new messages are prepended to the array, they will appear visually at the top due to column-reverse. */}\n        {this.props.messages.slice().reverse().map((msg, index) => (\n          <div key={index} style={{ marginBottom: '5px', background: '#f0f0f0', padding: '5px' }}>\n            {msg}\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial mount: Chat window should scroll to the bottom.",
            "Add message to bottom: Chat window should scroll to the bottom to show the new message.",
            "Add message to top: Chat window's scroll position should be maintained relative to its original view (the content should shift without the scrollbar moving if you're not at the very bottom). Console logs should show snapshot capture and adjustment.",
            "No new messages, but parent re-renders: No scroll adjustment should occur, and `getSnapshotBeforeUpdate` should return `null`."
          ],
          "hints": [
            "To get the current scroll position and total scrollable height before the DOM updates, use `scrollHeight` and `scrollTop` properties of the DOM element.",
            "The snapshot should represent the 'distance from the bottom' or 'offset from the bottom' rather than a fixed `scrollTop` value, as the `scrollHeight` will change.",
            "The `flexDirection: 'column-reverse'` style is crucial for simulating chat behavior where new messages appear at the bottom but push older ones up, requiring `getSnapshotBeforeUpdate` for preservation when prepending messages.",
            "Remember to access the DOM element via `this.chatContainerRef.current`."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "componentDidUpdate",
            "DOM Manipulation",
            "Scroll",
            "Refs",
            "Chat"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "refs",
            "dom_manipulation_basics"
          ],
          "complexity": 9,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_get_snapshot_before_update",
            "theory_component_did_update"
          ]
        },
        {
          "id": "task_fetch_data_on_prop_change",
          "title": "Implement Data Fetching on Prop Change using componentDidUpdate",
          "description": "\nCreate a React class component `ProductDetail` that displays product information fetched from an API. The component should fetch data based on a `productId` prop.\n\n**Requirements:**\n1.  On initial mount, fetch product details for the given `productId`.\n2.  If the `productId` prop changes, re-fetch the new product details.\n3.  Implement loading and error states. Display 'Loading...' while fetching and an error message if the fetch fails.\n4.  Use `componentDidMount` for the initial fetch and `componentDidUpdate` for subsequent fetches.\n5.  Ensure that `componentDidUpdate` only triggers a fetch if `productId` has genuinely changed, preventing unnecessary API calls and infinite loops.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ProductDetail extends React.Component {\n  state = {\n    product: null,\n    loading: true,\n    error: null,\n  };\n\n  componentDidMount() {\n    // TODO: Initial data fetch\n  }\n\n  componentDidUpdate(prevProps) {\n    // TODO: Conditional data re-fetch based on productId prop change\n  }\n\n  fetchProductData = async (productId) => {\n    this.setState({ loading: true, error: null, product: null });\n    try {\n      // Simulate API call, replace with a real endpoint for testing\n      // Example: `https://fakestoreapi.com/products/${productId}`\n      const response = await fetch(`https://api.example.com/products/${productId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ product: data, loading: false });\n    } catch (error) {\n      console.error('Fetch error:', error);\n      this.setState({ error: error.message, loading: false });\n    }\n  };\n\n  render() {\n    const { product, loading, error } = this.state;\n    const { productId } = this.props;\n\n    if (loading) {\n      return <div>Loading product {productId} details...</div>;\n    }\n\n    if (error) {\n      return <div>Error loading product {productId}: {error}</div>;\n    }\n\n    if (!product) {\n      return <div>No product data available for ID: {productId}.</div>;\n    }\n\n    return (\n      <div>\n        <h2>{product.title}</h2>\n        <p>Category: {product.category}</p>\n        <p>Price: ${product.price}</p>\n        <img src={product.image} alt={product.title} style={{ width: '100px', height: '100px' }} />\n        <p>{product.description}</p>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nclass App extends React.Component {\n  state = { currentProductId: 1 };\n\n  changeProduct = (id) => {\n    this.setState({ currentProductId: id });\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.changeProduct(1)}>Load Product 1</button>\n        <button onClick={() => this.changeProduct(2)}>Load Product 2</button>\n        <button onClick={() => this.changeProduct(999)}>Load Non-existent Product</button>\n        <ProductDetail productId={this.state.currentProductId} />\n      </div>\n    );\n  }\n}\n// Render <App /> to test\n*/",
          "solutionCode": "import React from 'react';\n\nclass ProductDetail extends React.Component {\n  state = {\n    product: null,\n    loading: true,\n    error: null,\n  };\n\n  componentDidMount() {\n    // Initial data fetch when component mounts for the first time\n    this.fetchProductData(this.props.productId);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Only re-fetch data if the productId prop has changed\n    if (this.props.productId !== prevProps.productId) {\n      this.fetchProductData(this.props.productId);\n    }\n  }\n\n  fetchProductData = async (productId) => {\n    this.setState({ loading: true, error: null, product: null }); // Reset state before new fetch\n    try {\n      // Using a public API for demonstration: JSONPlaceholder or FakeStoreAPI\n      const response = await fetch(`https://fakestoreapi.com/products/${productId}`);\n      if (!response.ok) {\n        // For 404 or other non-200 responses, throw an error\n        throw new Error(`HTTP error! Status: ${response.status} for product ID: ${productId}`);\n      }\n      const data = await response.json();\n      this.setState({ product: data, loading: false });\n    } catch (error) {\n      console.error('Fetch error for product ID ' + productId + ':', error);\n      this.setState({ error: error.message, loading: false });\n    }\n  };\n\n  render() {\n    const { product, loading, error } = this.state;\n    const { productId } = this.props;\n\n    if (loading) {\n      return <div>Loading product {productId} details...</div>;\n    }\n\n    if (error) {\n      return <div>Error loading product {productId}: {error}</div>;\n    }\n\n    // Handle case where product might be null even if no error (e.g., initial state)\n    if (!product || Object.keys(product).length === 0) {\n        return <div>No product data found for ID: {productId}.</div>;\n    }\n\n    return (\n      <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '8px', maxWidth: '400px' }}>\n        <h2>{product.title}</h2>\n        <p style={{ color: '#555' }}>Category: {product.category}</p>\n        <p style={{ fontWeight: 'bold', fontSize: '1.2em' }}>Price: ${product.price?.toFixed(2)}</p>\n        <img src={product.image} alt={product.title} style={{ width: '100%', maxHeight: '200px', objectFit: 'contain', marginBottom: '10px' }} />\n        <p>{product.description}</p>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial mount with `productId=1`: Component should display product 1 details after loading.",
            "Change `productId` from 1 to 2: Component should show 'Loading...' then display product 2 details. No unnecessary re-fetches.",
            "Change `productId` to a non-existent ID (e.g., 999): Component should display an error message.",
            "Re-render with same `productId`: `componentDidUpdate` should not trigger a new fetch.",
            "Network error simulation: Component should display an appropriate error message (e.g., by mocking fetch or using an invalid URL)."
          ],
          "hints": [
            "Remember to clear previous data (e.g., `product: null`, `error: null`) in `fetchProductData` before making a new API call to ensure proper loading state display.",
            "The comparison `this.props.productId !== prevProps.productId` is crucial in `componentDidUpdate` to prevent infinite loops.",
            "Handle cases where the API might return an empty object or an error for non-existent IDs.",
            "Consider using a `try-catch` block within your `async` `fetchProductData` function for robust error handling."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "componentDidMount",
            "Data Fetching",
            "API",
            "State Management",
            "Error Handling",
            "Code Challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "async_js",
            "fetch_api"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_component_did_update"
          ]
        },
        {
          "id": "task_implement_conditional_state_update",
          "title": "Implement Conditional State Update in componentDidUpdate",
          "description": "\nCreate a `Scoreboard` React class component that displays a player's `score` (integer state) and a `status` message (string state). The `score` can be incremented by a button. The `status` message should update based on specific `score` thresholds.\n\n**Requirements:**\n1.  The component should have an initial `score` of 0 and an empty `status`.\n2.  Provide a button to increment the `score`.\n3.  Implement `componentDidUpdate(prevProps, prevState)`.\n4.  Inside `componentDidUpdate`, update the `status` state only when the `score` crosses these thresholds:\n    *   `score` becomes 10 or more: `status` should be \"Good Job!\"\n    *   `score` becomes 20 or more: `status` should be \"Excellent!\"\n    *   `score` becomes 30 or more: `status` should be \"Amazing!\"\n5.  Ensure that `setState` calls for `status` are strictly conditional to prevent infinite loops or redundant updates (e.g., don't set \"Good Job!\" every time `score` increases past 10, only when it *crosses* 10 from below).\n6.  Add console logs to `componentDidUpdate` to show when a status update occurs.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass Scoreboard extends React.Component {\n  state = {\n    score: 0,\n    status: '',\n  };\n\n  incrementScore = () => {\n    this.setState(prevState => ({ score: prevState.score + 1 }));\n  };\n\n  componentDidUpdate(prevProps, prevState) {\n    // TODO: Implement conditional setState for status message based on score thresholds\n    // Ensure no infinite loops and updates only when crossing threshold\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Score: {this.state.score}</h1>\n        <p>Status: {this.state.status}</p>\n        <button onClick={this.incrementScore}>Increment Score</button>\n      </div>\n    );\n  }\n}\n",
          "solutionCode": "import React from 'react';\n\nclass Scoreboard extends React.Component {\n  state = {\n    score: 0,\n    status: '',\n  };\n\n  incrementScore = () => {\n    this.setState(prevState => ({ score: prevState.score + 1 }));\n  };\n\n  componentDidUpdate(prevProps, prevState) {\n    const currentScore = this.state.score;\n    const previousScore = prevState.score;\n\n    // Check if score has increased\n    if (currentScore > previousScore) {\n      if (currentScore >= 30 && previousScore < 30) {\n        this.setState({ status: 'Amazing!' });\n        console.log(`Status updated: Amazing! (Score crossed 30 from ${previousScore})`);\n      } else if (currentScore >= 20 && previousScore < 20) {\n        this.setState({ status: 'Excellent!' });\n        console.log(`Status updated: Excellent! (Score crossed 20 from ${previousScore})`);\n      } else if (currentScore >= 10 && previousScore < 10) {\n        this.setState({ status: 'Good Job!' });\n        console.log(`Status updated: Good Job! (Score crossed 10 from ${previousScore})`);\n      }\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Score: {this.state.score}</h1>\n        <p>Status: {this.state.status}</p>\n        <button onClick={this.incrementScore}>Increment Score</button>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial state: Score 0, Status empty.",
            "Increment score from 0 to 9: Status remains empty.",
            "Increment score from 9 to 10: Status changes to 'Good Job!'. Console log confirms.",
            "Increment score from 10 to 19: Status remains 'Good Job!'. No new `setState` for status.",
            "Increment score from 19 to 20: Status changes to 'Excellent!'. Console log confirms.",
            "Increment score from 20 to 29: Status remains 'Excellent!'.",
            "Increment score from 29 to 30: Status changes to 'Amazing!'. Console log confirms.",
            "Further increments (e.g., to 35): Status remains 'Amazing!'. No new `setState` for status."
          ],
          "hints": [
            "The core of the solution lies in comparing `this.state.score` with `prevState.score`.",
            "You need to check if the score *crossed* a threshold, not just if it's *at or above* it.",
            "Order of `if/else if` statements matters for the thresholds.",
            "Avoid redundant `setState` calls by ensuring the `status` is only updated when it actually *needs* to change, not on every increment past a threshold."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "componentDidUpdate",
            "State Management",
            "Conditional Logic",
            "Performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_class_components",
            "state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_component_did_update"
          ]
        },
        {
          "id": "task_implement_cleanup_in_cwu",
          "title": "Implement Cleanup in componentWillUnmount",
          "description": "\nCreate a `BackgroundEffect` React class component that simulates a background animation or a continuously running process. This component should:\n\n**Requirements:**\n1.  On mounting, start a `setInterval` that logs a message to the console every 1 second (e.g., 'Background effect running...').\n2.  On mounting, add a global `mousemove` event listener to `window` that logs the mouse coordinates to the console (e.g., 'Mouse X: Y:').\n3.  Implement `componentWillUnmount()` to properly clean up **both** the `setInterval` timer and the `mousemove` event listener.\n4.  The component should display a simple message like 'Background Effect Active'.\n5.  Provide a way to mount and unmount this component (e.g., via a parent component's toggle button) to test the cleanup. Observe the console for logs disappearing upon unmount.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass BackgroundEffect extends React.Component {\n  timerId = null;\n\n  componentDidMount() {\n    console.log('BackgroundEffect: componentDidMount - Starting effects.');\n    // TODO: Start setInterval and add window.mousemove listener\n  }\n\n  handleMouseMove = (event) => {\n    console.log(`Mouse X: ${event.clientX}, Y: ${event.clientY}`);\n  };\n\n  componentWillUnmount() {\n    console.log('BackgroundEffect: componentWillUnmount - Cleaning up effects.');\n    // TODO: Clear setInterval and remove window.mousemove listener\n  }\n\n  render() {\n    return (\n      <div style={{ border: '1px dashed blue', padding: '20px', margin: '20px' }}>\n        <p>Background Effect Active. Check console for logs and move your mouse!</p>\n      </div>\n    );\n  }\n}\n\n// Parent component for testing:\n/*\nimport ReactDOM from 'react-dom';\n\nclass App extends React.Component {\n  state = { showEffect: true };\n\n  toggleEffect = () => {\n    this.setState(prevState => ({ showEffect: !prevState.showEffect }));\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.toggleEffect}>\n          {this.state.showEffect ? 'Hide Effect' : 'Show Effect'}\n        </button>\n        {this.state.showEffect && <BackgroundEffect />}\n      </div>\n    );\n  }\n}\n\n// Render <App /> to test in your environment\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/",
          "solutionCode": "import React from 'react';\n\nclass BackgroundEffect extends React.Component {\n  timerId = null;\n\n  componentDidMount() {\n    console.log('BackgroundEffect: componentDidMount - Starting effects.');\n    // Start setInterval\n    this.timerId = setInterval(() => {\n      console.log('Background effect running...');\n    }, 1000);\n\n    // Add global mousemove event listener\n    window.addEventListener('mousemove', this.handleMouseMove);\n  }\n\n  handleMouseMove = (event) => {\n    console.log(`Mouse X: ${event.clientX}, Y: ${event.clientY}`);\n  };\n\n  componentWillUnmount() {\n    console.log('BackgroundEffect: componentWillUnmount - Cleaning up effects.');\n    // Clear setInterval\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      this.timerId = null; // Good practice to nullify after clearing\n      console.log('BackgroundEffect: setInterval cleared.');\n    }\n\n    // Remove global mousemove event listener\n    window.removeEventListener('mousemove', this.handleMouseMove);\n    console.log('BackgroundEffect: mousemove listener removed.');\n  }\n\n  render() {\n    return (\n      <div style={{ border: '1px dashed blue', padding: '20px', margin: '20px' }}>\n        <p>Background Effect Active. Check console for logs and move your mouse!</p>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Initial mount: 'Background effect running...' logs should appear every second. Mouse coordinates should log on mouse move.",
            "Unmount component (via parent toggle): 'BackgroundEffect: componentWillUnmount - Cleaning up effects.' should log. 'Background effect running...' logs should STOP. Mouse coordinate logs should STOP. No console warnings about `setState` on unmounted components.",
            "Remount component: Effects should restart and logs should resume."
          ],
          "hints": [
            "Remember to store the ID returned by `setInterval` so you can clear it later.",
            "When removing an event listener, you must pass the exact same function reference that was used when adding it. Using an arrow function directly in `addEventListener` and `removeEventListener` can sometimes be tricky unless it's an instance method.",
            "The `handleMouseMove` method is already defined as an instance method, so `this.handleMouseMove` can be used directly for both `addEventListener` and `removeEventListener`."
          ],
          "tags": [
            "React",
            "Lifecycle",
            "componentWillUnmount",
            "Cleanup",
            "Memory Leaks",
            "Timers",
            "Event Listeners",
            "Code Challenge"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "react_class_components",
            "javascript_timers",
            "browser_events"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_component_will_unmount"
          ]
        }
      ]
    }
  }
]